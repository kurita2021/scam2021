class: aBehavior variable: aString  self changeClass: aBehavior.  variable := aString-=JUAMPI=-hasPermutedArguments  ^hasPermutedArguments ifNil: [ hasPermutedArguments := super hasPermutedArguments ] ifNotNil: [ hasPermutedArguments ]-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' classNames: '.  classNames asArray storeOn: aStream.  aStream nextPut: $)-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' addMethod: ''';     nextPutAll: source;     nextPutAll: ''' toClass: '.  class storeOn: aStream.  aStream nextPutAll: ' inProtocols: '.  protocols storeOn: aStream.  aStream nextPut: $)-=JUAMPI=-storeOn: aStream  super storeOn: aStream.  aStream nextPutAll: ' class'-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' sourceCode: '''.  sourceCode storeOn: aStream.  aStream nextPutAll: ''' in: '.  class storeOn: aStream.  aStream     nextPutAll: ' withProtocol: #';     nextPutAll: protocol asString.  aStream nextPut: $)-=JUAMPI=-category  ^category-=JUAMPI=-testClassVariable  | refactoring |  refactoring := (RBPullUpVariableTransformation classVariable: #RecursiveSelfRule class: #RBDummyLintRuleTest) asRefactoring.  [ refactoring transform ] on: RBRefactoringError do: [:e |  e resume ].  self assert: ((refactoring model classNamed: #RBDummyLintRuleTest) directlyDefinesClassVariable: #RecursiveSelfRule).  self deny: ((refactoring model classNamed: #RBTransformationDummyRuleTest) directlyDefinesClassVariable: #RecursiveSelfRule)-=JUAMPI=-asEpiceaEvent  ^EpRenameMethodRefactoring renameMethod: oldSelector in: class name to: newSelector-=JUAMPI=-changeForMetaclass: aClassName selector: aSelector  changes reverseDo: [:each |  | change |        change := each changeForMetaclass: aClassName selector: aSelector.        change notNil ifTrue: [ ^change ] ].  ^nil-=JUAMPI=-formNameFor: aSelector  | method keywords arguments |  method := class methodFor: aSelector.  keywords := method parseTree keywords asOrderedCollection ifNil: [ '' ].  arguments := method parseTree arguments ifNil: [ '' ].  (keywords isNotEmpty and: [ arguments isNotEmpty ]) ifTrue: [ ^String streamContents: [:s |  keywords with: arguments do: [:keyword :arg |  s nextPutAll: keyword , ' ' , arg name , ' ' ] ] ] ifFalse: [ ^aSelector asString ]-=JUAMPI=-computeLiteralsForSelector: aSelector in: aClass  | method |  method := aClass compiledMethodAt: aSelector ifAbsent: [ nil ].  method ifNil: [ ^self ].  self addLiteralsFor: method-=JUAMPI=-classVariableNames: aCollectionOfStrings  classVariableNames := (aCollectionOfStrings collect: [:each |  each asSymbol ]) asOrderedCollection-=JUAMPI=-visitBlockNode: aBlockNode  aBlockNode arguments do: [:arg |  self replace: arg with: 'tempMatch' , temporaries asString.        temporaries := temporaries + 1 ].  super visitBlockNode: aBlockNode-=JUAMPI=-renameClassVariable: oldName to: newName in: aClass  ^RBRenameClassVariableChange rename: oldName to: newName in: aClass-=JUAMPI=-checkBrowseOccurrenceOf: selector in: aRBMethod  self refactoringError: ('Possible call to <2s> in <1p><n>Browse references?' expandMacrosWith: aRBMethod modelClass with: selector) with: [ self openBrowserOn: (RBBrowserEnvironment new referencesTo: selector) ]-=JUAMPI=-modifiesCollection  | collection |  collection := (1 to: 10) asOrderedCollection.  collection do: [:each |  each > 5 ifTrue: [ collection remove: each ] ].  ^collection-=JUAMPI=-transform  class compile: source classified: protocols-=JUAMPI=-replaceReferences  | rewriter |  rewriter := RBParseTreeRewriter new.  rewriter replaceTree: assignmentNode variable withTree: assignmentNode value.  definingNode removeTemporaryNamed: assignmentNode variable name.  rewriter executeTree: definingNode-=JUAMPI=-pragma: aPragmaDefinition inMethod: aSelector inClass: aClassName  self className: aClassName.  selector := aSelector.  pragma := aPragmaDefinition-=JUAMPI=-testNonExistantName  self     shouldFail: (RBRemoveDirectAccessToVariableTransformation instanceVariable: 'foo' class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBRemoveDirectAccessToVariableTransformation classVariable: #Foo class: #RBBasicLintRuleTestData) asRefactoring-=JUAMPI=-initialize  super initialize.  changes := OrderedCollection new-=JUAMPI=-buildArgumentSearch  self createArgumentSearchWith: 'aSmalllintContext' selectors: #(#checkMethod: #checkClass:) inClass: RBBasicLintRuleTestData-=JUAMPI=-testRefactoring  | refactoring selector class |  selector := 'selectorNotReferenced' asSymbol.  refactoring := (RBRemoveMethodTransformation selector: selector from: #RBRefactoryTestDataApp) asRefactoring.  class := refactoring model classNamed: #RBRefactoryTestDataApp.  self assert: (class directlyDefinesMethod: selector).  refactoring transform.  self deny: (class directlyDefinesMethod: selector)-=JUAMPI=-transform  | source tree formatted |  self model allClassesDo: [:class |  class selectors do: [:selector |  (self model environment includesSelector: selector in: class realClass) ifTrue: [ source := class sourceCodeFor: selector.                    source ifNotNil: [ tree := class parseTreeFor: selector.                          tree ifNotNil: [ formatted := tree formattedCode.                                (source ~= formatted and: [ (self parserClass parseMethod: formatted) = tree ]) ifTrue: [ class compile: formatted classified: (class protocolsFor: selector) ] ] ] ] ] ]-=JUAMPI=-accept: presenter  self okToChange ifFalse: [ ^self ].  [ change do: [:aChange |  RBRefactoryChangeManager instance performChange: aChange ] ] asJob     title: 'Refactoring';     run.  presenter     beOk;     close-=JUAMPI=-testRenameClass  | refactoring class |  refactoring := RBRenameClassRefactoring rename: (testingEnvironment at: ('RBClass' , 'ToRename') asSymbol) to: 'RBNew' , 'ClassName' asSymbol.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: ('RBNew' , 'ClassName') asSymbol) parseTreeFor: #method1) equals: (self parseMethod: 'method1	^self method2').  self deny: (refactoring model includesClassNamed: ('RBClass' , 'ToRename') asSymbol).  class := refactoring model classNamed: ('RBSubclass' , 'OfClassToRename') asSymbol.  self assert: class superclass equals: (refactoring model classNamed: ('RBNew' , 'ClassName') asSymbol).  self assert: (class parseTreeFor: #symbolReference) equals: (self parseMethod: 'symbolReference								^#RBNewClassName').  self assert: (class parseTreeFor: #reference) equals: (self parseMethod: 'reference								^RBNewClassName new')-=JUAMPI=-testRemoveClassVariable  | change |  change := changes removeClassVariable: 'ClassVar' from: self class.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self assert: change variable equals: 'ClassVar'.  self universalTestFor: change-=JUAMPI=-testObjectIsNotAbstract  self deny: objectClass isAbstract.  self deny: objectClass classSide isAbstract-=JUAMPI=-isOkEnabled  ^argumentsList isEmpty-=JUAMPI=-pullUp: selectorCollection from: aClass to: aSuperClass  self setOption: #superClass toUse: [:ref |   ].  class := self classObjectFor: aClass.  targetSuperclass := self classObjectFor: aSuperClass.  selectors := selectorCollection.  removeDuplicates := false-=JUAMPI=-asUndoOperation  ^self class selector: self selector in: self changeClass classified: self oldProtocol-=JUAMPI=-signalFailure: aString  self classForTestResult failure signal: aString-=JUAMPI=-findMessageNodes  beforeNodes := cascadeNode messages select: [:each |  each stop <= selectedInterval first ].  afterNodes := cascadeNode messages select: [:each |  selectedInterval last <= each keywordsPositions first ].  (beforeNodes isEmpty or: [ afterNodes isEmpty ]) ifTrue: [ self refactoringFailure: 'Splitting a cascade into the whole cascade and an empty one is pointless' ].  beforeNodes size + afterNodes size = cascadeNode messages size ifFalse: [ self refactoringFailure: 'To set the split boundary place the cursor inbetween two cascaded messages' ]-=JUAMPI=-reparentClasses: aRBClassCollection to: newClass  aRBClassCollection do: [:aClass |  self defineClass: (self replaceClassNameIn: aClass definitionString to: newClass name) ]-=JUAMPI=-allSubclasses  | allSubclasses index |  index := 1.  allSubclasses := OrderedCollection withAll: self subclasses.  [ index <= allSubclasses size ] whileTrue: [ allSubclasses addAll: (allSubclasses at: index) subclasses.        index := index + 1 ].  ^allSubclasses-=JUAMPI=-definingClass  ^classVariable ifTrue: [ class classSide ] ifFalse: [ class ]-=JUAMPI=-realName: aSymbol  self subclassResponsibility-=JUAMPI=-testBadName  self shouldFail: (RBExtractToTemporaryRefactoring extract: (14 to: 23) to: 'a sdf' from: #testMethod in: RBRefactoryTestDataApp)-=JUAMPI=-nonUnaryAccessingMessageStatementMethodWithoutReturn: anObject  self value-=JUAMPI=-sendsDifferentSuper  super printString-=JUAMPI=-newMethodName  | methodName newAttempt |  newAttempt := newSelector isNil.  methodName := RBMethodName new.  methodName arguments: arguments.  newSelector ifNotNil: [ methodName selector: newSelector ].  [ newAttempt ] whileTrue: [ methodName := (RBMethodNameEditor openOn: methodName) methodName.        methodName ifNil: [ newAttempt := false ] ifNotNil: [:newMethodName |  newSelector := newMethodName selector.              newAttempt := newSelector isNil.              (newSelector isString and: [ RBScanner isSelector: newSelector ]) ifFalse: [ self inform: newSelector asString , ' is not a valid selector.'.                    newSelector := nil ].              (self definingClass directlyDefinesLocalMethod: newSelector) ifTrue: [ self inform: newSelector , ' is already defined in ' , class asString.                    newSelector := nil ] ] ].  ^methodName-=JUAMPI=-performComponentRefactoring: aRefactoring  aRefactoring copyOptionsFrom: self options.  aRefactoring primitiveExecute-=JUAMPI=-withAllSubclasses  ^self allSubclasses     add: self;     yourself-=JUAMPI=-selector: aSelector in: aClass classified: aProtocol  selector := aSelector.  self changeClass: aClass.  self protocols: aProtocol-=JUAMPI=-preconditions  ^RBCondition withBlock: [ (class hierarchyDefinesInstanceVariable: variableName) ifFalse: [ self refactoringFailure: 'No subclass defines ' , variableName ].        (class subclasses anySatisfy: [:each |  (each directlyDefinesInstanceVariable: variableName) not ]) ifTrue: [ self refactoringWarning: 'Not all subclasses have an instance variable named ' , variableName , '.' ].        true ]-=JUAMPI=-createTemporariesInExtractedMethodFor: assigned  assigned do: [:each |  extractedParseTree body addTemporaryNamed: each ]-=JUAMPI=-testMoveMethodIntoArgument  | refactoring class |  self proceedThroughWarning: [ refactoring := RBMoveMethodRefactoring selector: #checkMethod: class: RBTransformationRuleTestData variable: 'aSmalllintContext'.        self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.        self setupVariableTypesFor: refactoring toReturn: (Array with: (refactoring model classNamed: #RBSmalllintContext)).        self setupMethodNameFor: refactoring toReturn: #foo:.        self executeRefactoring: refactoring ].  class := refactoring model classNamed: #RBTransformationRuleTestData.  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext aSmalllintContext foo: self').  self assert: ((refactoring model classNamed: #RBSmalllintContext) parseTreeFor: #foo:) equals: (self parseMethod: 'foo: transformationRule	transformationRule class: self selectedClass.	(transformationRule rewriteRule executeTree: self parseTree) ifTrue: 			[(transformationRule class recursiveSelfRule executeTree: transformationRule rewriteRule tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: transformationRule rewriteRule tree printString						in: transformationRule class1						classified: self protocols]]').  self assert: (class parseTreeFor: #class1) equals: (self parseMethod: 'class1 ^class').  self assert: (class parseTreeFor: #class:) equals: (self parseMethod: 'class: anObject class := anObject').  self assert: (class classSide parseTreeFor: #recursiveSelfRule:) equals: (self parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').  self assert: (class classSide parseTreeFor: #recursiveSelfRule) equals: (self parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').  self assert: (class parseTreeFor: #builder) equals: (self parseMethod: 'builder ^builder').  self assert: (class parseTreeFor: #builder:) equals: (self parseMethod: 'builder: anObject builder := anObject').  self assert: (class parseTreeFor: #rewriteRule) equals: (self parseMethod: 'rewriteRule ^rewriteRule').  self assert: (class parseTreeFor: #rewriteRule:) equals: (self parseMethod: 'rewriteRule: anObject rewriteRule := anObject')-=JUAMPI=-return: anExpression inMethod: aSelector inClass: aClassName  self className: aClassName.  selector := aSelector.  returnValue := anExpression-=JUAMPI=-primitiveExecute  self changeClass organization removeProtocol: (self changeClass organization protocolNamed: protocol)-=JUAMPI=-initialize  super initialize.  modelFactory := RBClassModelFactory new.  changeFactory := RBRefactoryChangeManager changeFactory-=JUAMPI=-buildTransformations  ^transformations ifNil: [ transformations := OrderedCollection with: (RBAddMethodTransformation sourceCode: (String streamContents: [:code |  code                             nextPutAll: 'new';                             nextPutAll: String cr;                             nextPutAll: String tab;                             nextPutAll: 'self deprecated: ''Use superclass '' on: ''4 May 2016'' in: #Pharo60.';                             nextPutAll: String cr;                             nextPutAll: String tab;                             nextPutAll: '^ super new' ]) in: (className , ' class') asSymbol withProtocol: 'deprecation') with: (RBAddMethodTransformation sourceCode: (String streamContents: [:code |  code                             nextPutAll: 'deprecated';                             nextPutAll: String cr;                             nextPutAll: String tab;                             nextPutAll: '^ true' ]) in: (className , ' class') asSymbol withProtocol: 'deprecation') with: (RBAddMethodTransformation sourceCode: (String streamContents: [:code |  code                             nextPutAll: 'systemIcon';                             nextPutAll: String cr;                             nextPutAll: String tab;                             nextPutAll: '^ Smalltalk ui icons iconNamed: #packageDelete' ]) in: (className , ' class') asSymbol withProtocol: 'deprecation') with: (RBAddClassCommentTransformation comment: 'Deprecated!!! Use superclass' in: className) ]-=JUAMPI=-renameReferences  | replacer subclasses |  replacer := RBParseTreeRewriter rename: variableName to: newVariableName handler: [ self refactoringError: ('<1s> is already defined as a method					or block temporary <n> variable in this class or one of its subclasses' expandMacrosWith: newVariableName) ].  subclasses := (self model classObjectFor: className) withAllSubclasses.  isClassVariable ifTrue: [ subclasses addAll: self definingClass withAllSubclasses ].  self model convertClasses: subclasses select: [:aClass |  self referencesFor: aClass ] using: replacer-=JUAMPI=-renameSuperclassOfSubclasses  | replacement |  replacement := self model classNamed: newName.  self model reparentClasses: deprecatedClass subclasses to: replacement-=JUAMPI=-environmentForInstanceVariable: aString in: aClass  | selectorEnvironment isReader isWriter |  selectorEnvironment := RBSelectorEnvironment onEnvironment: self.  selectorEnvironment addSearchString: aString.  isReader := isWriter := false.  ((instanceVariables at: aClass name ifAbsent: [ #() ]) includes: aString) ifTrue: [ isReader := true.        isWriter := true ].  ((instanceVariableWriters at: aClass name ifAbsent: [ #() ]) includes: aString) ifTrue: [ isWriter := true ].  ((instanceVariableReaders at: aClass name ifAbsent: [ #() ]) includes: aString) ifTrue: [ isReader := true ].  aClass withAllSubAndSuperclassesDo: [:each |  isWriter ifTrue: [ (each whichSelectorsStoreInto: aString) do: [:sel |  selectorEnvironment addClass: each selector: sel ] ].        isReader ifTrue: [ (each whichSelectorsRead: aString) do: [:sel |  selectorEnvironment addClass: each selector: sel ] ] ].  ^selectorEnvironment-=JUAMPI=-executeNotifying: aBlock  | undo |  self addNewVariable.  self copyOldValuesToNewVariable.  undo := super executeNotifying: aBlock.  undo     oldName: newName;     newName: oldName.  self removeOldVariable.  ^undo-=JUAMPI=-removeClasses  classNames do: [:each |  self model removeClassNamed: each ]-=JUAMPI=-testMethodDoesNotExist  self shouldFail: (RBRemoveAssignmentTransformation variable: 'variable' value: '1 asString' inMethod: #method inClass: #RBRemoveAssignmentTransformationTest) asRefactoring-=JUAMPI=-testTransform  | transformation |  transformation := (RBAddProtocolTransformation new protocol: 'transforming' inClass: #RBDummyEmptyClass) transform.  self assert: transformation model changes changes size equals: 1-=JUAMPI=-left: aCondition right: aCondition2  left := aCondition.  right := aCondition2.  failed := #unknownFailed-=JUAMPI=-booleanPrecedence  ^(true & 4) = 45-=JUAMPI=-endTrueFalse  self isVariable ifTrue: [ self printString.        self isVariable printString ] ifFalse: [ self printString.        ^4 ]-=JUAMPI=-getNewSelector  | tree |  (class directlyDefinesMethod: oldSelector) ifFalse: [ self refactoringFailure: 'Method doesn''t exist' ].  tree := class parseTreeFor: oldSelector.  tree ifNil: [ self refactoringFailure: 'Cannot parse sources' ].  argument ifNil: [ self refactoringFailure: 'This method does not have an argument' ].  parameterIndex := tree argumentNames indexOf: argument ifAbsent: [ self refactoringFailure: 'Select a parameter!!' ].  permutation := (1 to: oldSelector numArgs) copyWithout: parameterIndex.  newSelector := self computeNewSelector-=JUAMPI=-transform  | original replacement protocols |  self model allClassesDo: [:class |  class selectors do: [:selector |  original := class sourceCodeFor: selector.              replacement := self execute: original.              replacement = original ifFalse: [ (self parseMethod: replacement) ifNotNil: [ protocols := class protocolsFor: selector.                          (self parseSelector: replacement) = selector ifFalse: [ class removeMethod: selector ].                          class compile: replacement classified: protocols ] ] ] ]-=JUAMPI=-assertCollection: actual equals: expected  ^self assert: expected = actual description: [ self comparingCollectionBetween: actual and: expected ]-=JUAMPI=-asSelectorEnvironment  ^RBSelectorEnvironment new     searchStrings: #();     label: self label;     onEnvironment: self environment;     classSelectors: self classSelectorDictionary metaClassSelectors: self metaClassSelectorDictionary;     yourself-=JUAMPI=-testMetaClassFailure  self shouldFail: (RBRenameClassVariableRefactoring rename: #RecursiveSelfRule to: #Foo in: RBTransformationRuleTestData class)-=JUAMPI=-testNonExistantName  self shouldFail: (RBRenameInstanceVariableRefactoring rename: 'foo' to: 'newFoo' in: RBBasicLintRuleTestData)-=JUAMPI=-testAccessorsAlreadyExist  | class |  (RBProtectVariableTransformation model: model instanceVariable: 'instVarName1' class: #Foo) asRefactoring transform.  class := model classNamed: #Foo.  self assert: (class parseTreeFor: #bar) equals: (self parseMethod: 'bar			"Add one to instVarName1"			self instVarName11: self instVarName11 + 1').  self assert: (class parseTreeFor: #instVarName11:) equals: (self parseMethod: 'instVarName11: anObject			instVarName1 := anObject').  self assert: (class parseTreeFor: #instVarName11) equals: (self parseMethod: 'instVarName11 ^instVarName1').  self assert: ((model classNamed: #Bar) parseTreeFor: #foo) equals: (self parseMethod: 'foo			self instVarName11: self instVarName11 + instVarName2 + ClassVarName1')-=JUAMPI=-inlineMethod  | temp |  temp := self     foo;     inlineMethod;     bar.  ^temp-=JUAMPI=-caller  | anObject |  anObject := 5.  self called: anObject + 1 on: [ ^anObject ]-=JUAMPI=-testModelRemoveUnusedVariable  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  self assert: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  self executeRefactoring: (RBPushDownClassVariableRefactoring model: model variable: #Foo class: (model classNamed: #SomeClass)).  self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).  self deny: ((model classNamed: #Subclass) directlyDefinesVariable: #Foo)-=JUAMPI=-testAddClassVariable  | refactoring |  refactoring := (RBAddVariableTransformation classVariable: 'Asdf' class: #RBTransformationRuleTestData) asRefactoring transform.  self assert: ((refactoring model classNamed: #RBTransformationRuleTestData) directlyDefinesClassVariable: #Asdf)-=JUAMPI=-transform  | brokenSenders |  class addInstanceVariable: variableName asString.  oldClass removeInstanceVariable: variableName asString.  brokenSenders := self collectSendersOfInstVar.  brokenSenders ifNotEmpty: [ Smalltalk tools messageList browse: (brokenSenders collect: #method) title: 'Broken methods' autoSelect: brokenSenders first selector ]-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' comment: ''';     nextPutAll: comment;     nextPutAll: ''' in: ''';     nextPutAll: className.  aStream nextPut: $)-=JUAMPI=-comment: aString  model comment: (comment := aString) in: self-=JUAMPI=-postCopy  | newDict |  super postCopy.  newDict := classSelectors copy.  newDict keysAndValuesDo: [:key :value |  newDict at: key put: value copy ].  classSelectors := newDict.  newDict := metaClassSelectors copy.  newDict keysAndValuesDo: [:key :value |  newDict at: key put: value copy ].  metaClassSelectors := newDict-=JUAMPI=-includesCategory: aCategory  ^true-=JUAMPI=-testAddClass  | refactoring newClass superClass classTest |  refactoring := (RBAddClassTransformation addClass: #FooTest superclass: #RBTransformationTest subclasses: #(RBAddClassTransformationTest) category: #'Refactory-Testing') asRefactoring.  refactoring transform.  newClass := refactoring model classNamed: #FooTest.  superClass := refactoring model classNamed: #RBTransformationTest.  classTest := refactoring model classNamed: self class name.  self assert: newClass superclass equals: superClass.  self assert: (superClass subclasses includes: newClass).  self assert: newClass theMetaClass superclass equals: superClass theMetaClass.  self assert: (superClass theMetaClass subclasses includes: newClass theMetaClass).  self assert: classTest superclass equals: newClass.  self assert: (newClass subclasses includes: classTest).  self assert: classTest theMetaClass superclass equals: newClass theMetaClass.  self assert: (newClass theMetaClass subclasses includes: classTest theMetaClass)-=JUAMPI=-classNamesFor: anEnvironment  | classNames allClassNames |  classNames := IdentitySet new     addAll: anEnvironment classNames asSet;     addAll: anEnvironment not classNames;     yourself.  allClassNames := universalEnvironment classNames asSortedCollection.  self assert: classNames asSortedCollection equals: allClassNames.  self assertEmpty: (anEnvironment & anEnvironment not) classNames.  self assert: (anEnvironment | anEnvironment not) classNames asSortedCollection equals: allClassNames-=JUAMPI=-initialize  super initialize.  delegatesPreconditions := true-=JUAMPI=-testInheritedName  self     shouldFail: (RBRemoveDirectAccessToVariableTransformation instanceVariable: 'name' class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBRemoveDirectAccessToVariableTransformation classVariable: #DependentsFields class: #RBBasicLintRuleTestData) asRefactoring-=JUAMPI=-comment: aString in: aClass  ^changes comment: aString in: aClass-=JUAMPI=-addMethodSource: sourceCode in: aClass for: aController  ^RBAddMethodChange compile: sourceCode in: aClass for: aController-=JUAMPI=-testInlineMethod5  | refactoring |  refactoring := RBInlineMethodRefactoring inline: (53 to: 64) inMethod: #inlineLast forClass: RBRefactoryTestDataApp.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineLast) equals: (self parseMethod: 'inlineLast									5 = 3 ifTrue: [^self caller] ifFalse: [^	(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)]]')-=JUAMPI=-asRefactoring  ^self     checksPreconditions;     yourself-=JUAMPI=-includesBehaviorNamed: aClassName  | current |  current := self selectedClass.  [ current isNil ] whileFalse: [ current name = aClassName ifTrue: [ ^true ].        current := current superclass ].  ^false-=JUAMPI=-extractedParseTree  ^extractedParseTree-=JUAMPI=-allPoolDictionaryNames  | sprClass |  sprClass := self superclass.  ^sprClass ifNil: [ self sharedPoolNames ] ifNotNil: [ sprClass allPoolDictionaryNames , self sharedPoolNames ]-=JUAMPI=-removeClass: aClass classVariable: aSymbol  | vars |  vars := classVariables at: aClass name ifAbsent: [ Set new ].  vars remove: aSymbol ifAbsent: [  ].  vars ifEmpty: [ classVariables removeKey: aClass name ifAbsent: [  ] ].  self flushCachesFor: aClass-=JUAMPI=-isEmpty  ^environmentDictionaries isEmpty-=JUAMPI=-newContentMorph  ^labelGroup := (self newRow: {(self newLabelGroup: {('Selector:' -> (selectorField := (self newTextEntryFor: self getText: #selector setText: #selector: help: nil)                       autoAccept: true;                       on: #keyStroke send: #value:value: to: [:key :morph |  key keyCharacter = Character cr ifTrue: [ self ok.                                true ].                          false ];                       hResizing: #spaceFill;                       yourself)) .               ('Arguments:' -> (self newRow: {((self newColumn: {(self newButtonFor: self action: #add label: '+' help: nil) .                                 (self newButtonFor: self action: #remove label: '-' help: nil)}) hResizing: #shrinkWrap) .                           ((self newListFor: self list: #argumentList selected: #argumentIndex changeSelected: #argumentIndex: help: nil)                             hResizing: #spaceFill;                             yourself)})) .               ('Preview:' -> (labelMorph := self newLabel: self methodName printString))})})     minWidth: 400;     hResizing: #spaceFill;     yourself-=JUAMPI=-initialize  self computeLiterals-=JUAMPI=-testNotEnvironmentWithClassEnvironments  | numberEnvironment notNumberEnvironment |  numberEnvironment := RBBrowserEnvironment new forClasses: Number withAllSubclasses.  notNumberEnvironment := numberEnvironment not.  self universalTestFor: notNumberEnvironment.  self deny: (notNumberEnvironment includesClass: Number).  self assertEmpty: (notNumberEnvironment & numberEnvironment) classes.  self assert: (notNumberEnvironment not includesClass: Number)-=JUAMPI=-checkMethod: aMethod  (self basicCheck: aMethod) ifTrue: [ result addMethod: aMethod ]-=JUAMPI=-compile: aString  ^self compile: aString withAttributesFrom: (self methodFor: (self parserClass parseMethodPattern: aString))-=JUAMPI=-newSelector  ^newSelector-=JUAMPI=-preconditions  ^className inject: RBCondition empty into: [:cond :aClass |  | aClassOrTrait |        aClassOrTrait := self model classNamed: className asSymbol.        aClassOrTrait ifNil: [ self refactoringError: 'No such class or trait named ' , className ].        cond & ((self preconditionIsNotMetaclass: aClassOrTrait) & (self preconditionHasNoReferences: className) & (self preconditionHasNoSubclasses: aClassOrTrait) & (self preconditionHasNoUsers: aClassOrTrait)) ]-=JUAMPI=-testPerformAddRemoveClass  | change |  change := changes defineClass: 'Object subclass: #' , self changeMock name , 'Temporary	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	package: ''' , self class category , ''''.  self perform: change do: [ self assert: (workingEnvironment hasClassNamed: change changeClassName).        self assert: change definedClass name equals: change changeClassName.        self assert: change definedClass isBehavior ].  self deny: (workingEnvironment hasClassNamed: change changeClassName).  self assert: change definedClass isObsolete-=JUAMPI=-isComposite  ^true-=JUAMPI=-selectorsFor: aProtocol in: aClass  ^(aClass organization listAtCategoryNamed: aProtocol) select: [:each |  self includesSelector: each in: aClass ]-=JUAMPI=-createReference  self performComponentRefactoring: (RBAddInstanceVariableRefactoring variable: referenceVariableName class: class)-=JUAMPI=-uncommonMessageSend2  | a |  a := 3 Object new.  ^a-=JUAMPI=-hasConflicts  ^true-=JUAMPI=-methodAfter  | variable |  variable := 'String'.  variable byteAt: 1-=JUAMPI=-testNonExistantName  self shouldFail: (RBRemoveInstanceVariableRefactoring variable: 'name1' class: RBLintRuleTestData)-=JUAMPI=-parameters: anOrderedCollection  parameters := anOrderedCollection-=JUAMPI=-fillOutDefinition: aDictionary  className := (aDictionary at: '`traitName') asSymbol-=JUAMPI=-inline: anInterval from: aSelector in: aClass  class := self classObjectFor: aClass.  selector := aSelector.  sourceInterval := anInterval-=JUAMPI=-classForName: aString  | name isMeta class |  isMeta := aString includes: $ .  name := (isMeta ifTrue: [ aString copyFrom: 1 to: (aString size - 6 max: 1) ] ifFalse: [ aString ]) asSymbol.  class := self systemDictionary at: name ifAbsent: [ nil ].  ^(class notNil and: [ isMeta ]) ifTrue: [ class class ] ifFalse: [ class ]-=JUAMPI=-rationale  ^'Checks for ifTrue:ifFalse: blocks that have the same code at the beginning or end.'-=JUAMPI=-setUp  super setUp.  model := self abstractVariableTestData-=JUAMPI=-addChangeToClass: aRBClass  ^changedClasses at: aRBClass name put: (Array with: aRBClass instanceSide with: aRBClass classSide)-=JUAMPI=-toDoCollect  | array |  array := Array new: 10.  1 to: 10 do: [:i |  array at: i put: i * i ].  ^array-=JUAMPI=-checkClass: aSmalllintContext  ^classBlock value: aSmalllintContext value: result-=JUAMPI=-classVarRefsTo: instVarName in: aClass  ^RBVariableEnvironment on: self referencesToClassVariable: instVarName in: aClass-=JUAMPI=-newName  ^newName-=JUAMPI=-testMetaClassFailure  self shouldFail: (RBChildrenToSiblingsRefactoring name: #Foo class: RBLintRuleTestData class subclasses: (Array with: RBBasicLintRuleTestData class with: RBCompositeLintRuleTestData class))-=JUAMPI=-includesClass: aClass  (super includesClass: aClass) ifFalse: [ ^false ].  (instanceVariables includesKey: aClass name) ifTrue: [ ^true ].  (classVariables includesKey: aClass name) ifTrue: [ ^true ].  ^(self selectorCacheFor: aClass) anySatisfy: [:each |  self includesSelector: each in: aClass ]-=JUAMPI=-denyEmpty: aCollection  ^self assert: aCollection isNotEmpty description: aCollection asString , ' should not have been empty'-=JUAMPI=-checkSuperMessages  inlineParseTree superMessages isEmpty ifFalse: [ self refactoringError: 'Cannot inline method since it sends a super message' ]-=JUAMPI=-equalNotUsed  | string |  string = '' yourself.  (1 to: 10) do: [:i |  string := i printString ].  ^string-=JUAMPI=-testMoveDefinition  | transformation class |  transformation := (RBMoveTemporaryVariableDefinitionTransformation variable: #temp inMethod: #moveDefinition inClass: #RBDummyRefactoryTestDataApp) transform.  class := transformation model classNamed: #RBDummyRefactoryTestDataApp.  self assert: (class parseTreeFor: #moveDefinition) equals: (self parseMethod: 'moveDefinition								^(self collect: 										[:each | 										| temp |										temp := each printString.										temp , temp]) 									select: 										[:each | 										| temp |										temp := each size.										temp odd]')-=JUAMPI=-shouldUseExistingMethod: aSelector  ^(self options at: #useExistingMethod) value: self value: aSelector-=JUAMPI=-remainingTemporaries  | temps |  temps := modifiedParseTree allDefinedVariables asSet.  extractedParseTree allDefinedVariables do: [:each |  temps remove: each ifAbsent: [  ] ].  ^temps-=JUAMPI=-classSelectors: classSelectorDictionary metaClassSelectors: metaClassSelectorDictionary  classSelectors := classSelectorDictionary.  metaClassSelectors := metaClassSelectorDictionary-=JUAMPI=-testTransform  | transformation class |  transformation := (RBRenameVariableTransformation rename: 'classBlock' to: 'asdf' in: #RBBasicLintRuleTestData classVariable: false) transform.  class := transformation model classNamed: #RBBasicLintRuleTestData.  self assert: (class directlyDefinesInstanceVariable: 'asdf').  self deny: (class directlyDefinesInstanceVariable: 'classBlock').  self assert: (class parseTreeFor: #checkClass:) equals: (self parseMethod: 'checkClass: aSmalllintContext 					^asdf value: aSmalllintContext value: result').  self assert: (class parseTreeFor: #initialize) equals: (self parseMethod: 'initialize					super initialize.					self anInstVar: 1.					asdf := [:context :aResult | ].					methodBlock := [:context :aResult | ].					self resultClass: RBSelectorEnvironment')-=JUAMPI=-preconditions  | aSubtree |  aSubtree := self calculateSubtree.  ^(RBCondition withBlock: [ aSubtree ifNil: [ self refactoringError: 'Cannot extract code.' ].        true ]) & (RBCondition withBlock: [ aSubtree parent isCascade ifTrue: [ self refactoringError: 'Cannot extract code in a cascaded message' ].              true ]) & (RBCondition withBlock: [ | tempVariables |              tempVariables := self calculateTemporaries.              (RBReadBeforeWrittenTester readBeforeWritten: tempVariables in: aSubtree) ifNotEmpty: [ self refactoringError: 'Cannot extract temporaries if they are read before written.' ].              true ]) & (RBCondition withBlock: [ self calculateAssignments size > 1 ifTrue: [ self refactoringError: 'Cannot extract two or more assignments to temporaries without also extracting all the references.' ].              true ]) & (RBCondition withBlock: [ | assignmentCollection |              assignmentCollection := self calculateAssignments.              assignmentCollection ifNotEmpty: [ ((RBReadBeforeWrittenTester isVariable: assignmentCollection first readBeforeWrittenIn: aSubtree) or: [ aSubtree containsReturn ]) ifTrue: [ self refactoringError: ('Cannot extract assignment to <1s> without also extracting all the references.' expandMacrosWith: assignments asString) ] ].              true ]) & (RBCondition withBlock: [ | searchSpace |              searchSpace := (self class allMethodsInHierarchyOf: self definingClass) reject: [:m |  m selector = selector ].              (RBParseTreeSearcher whichMethodIn: searchSpace matches: aSubtree) ifNotEmpty: [:opportunities |  self refactoringError: ('<1s> method(s) already implement this code.<n>Do you want to send a message instead?' expandMacrosWith: opportunities size asString) with: [ (RBParseTreeRewriter replaceCode: aSubtree byMessageSendTo: opportunities anyOne in: (self definingClass methodFor: self calculateTree selector)) transform ].                    false ] ifEmpty: [ true ] ])-=JUAMPI=-includesSelector: aSelector in: aClass  ^(self includesClass: aClass) and: [ environment includesSelector: aSelector in: aClass ]-=JUAMPI=-testRemovePool  | change |  change := changes removePool: 'PoolDict' from: self class.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self assert: change variable equals: 'PoolDict'.  self universalTestFor: change-=JUAMPI=-returnInEnsure  [ self error: 'asdf' ] ensure: [ ^4 ]-=JUAMPI=-testRefactoring  | refactoring class |  refactoring := (RBAddAssignmentTransformation variable: 'variable' value: '1 asString' inMethod: #methodBefore inClass: #RBAddAssignmentTransformationTest) asRefactoring transform.  self assert: refactoring model changes changes size equals: 1.  class := refactoring model classNamed: #RBAddAssignmentTransformationTest.  self assert: (class directlyDefinesMethod: #methodBefore).  self assert: (class parseTreeFor: #methodBefore) body statements size equals: 2.  self assert: (class parseTreeFor: #methodBefore) body statements last value sourceCode equals: '1 asString'-=JUAMPI=-testModelAlreadyExistingName  | refactoring |  refactoring := RBAddClassVariableRefactoring model: model variable: #ClassVarName2 class: (model classNamed: #Bar).  self shouldFail: refactoring-=JUAMPI=-methodSourceFor: aSymbol  ^(self changeClass includesSelector: aSymbol) ifTrue: [ self changeClass sourceCodeAt: aSymbol ]-=JUAMPI=-removeClassVariable: aString  self privateClassVariableNames remove: aString asSymbol.  model removeClassVariable: aString from: self-=JUAMPI=-checkIsSubclass: aClass  aClass ~= class ifTrue: [ (class subclasses includes: aClass) ifFalse: [ self refactoringError: ('<1p> is not subclass of <2s>' expandMacrosWith: aClass name with: class name) ] ]-=JUAMPI=-removeDuplicateMethods  selectors do: [:each |  self removeDuplicatesOf: each ]-=JUAMPI=-booleanPrecedence  ^(true & 4) = 45-=JUAMPI=-rules  ^rules-=JUAMPI=-leaves  ^{self}-=JUAMPI=-check: anEntity forCritiquesDo: aCriticBlock  (self basicCheck: anEntity) ifTrue: [ aCriticBlock cull: (self critiqueFor: anEntity) ]-=JUAMPI=-includesProtocol: aProtocol in: aClass  ^(aClass organization protocolOrganizer getProtocolNamed: aProtocol ifNone: [ ^false ]) methods anySatisfy: [:selector |  self includesSelector: selector in: aClass ]-=JUAMPI=-testNonExistantName  self     shouldFail: (RBRemoveVariableTransformation instanceVariable: 'name1' class: #RBDummyLintRuleTest) asRefactoring;     shouldFail: (RBRemoveVariableTransformation classVariable: #RecursiveSelfRule1 class: #RBTransformationDummyRuleTest) asRefactoring-=JUAMPI=-addClass: aClass instanceVariableWriter: aString  (instanceVariableWriters at: aClass name ifAbsentPut: [ Set new ]) add: aString.  self flushCachesFor: aClass.  self addSearchString: aString-=JUAMPI=-delete: selector in: aClass  (aClass realClass includesSelector: selector) ifTrue: [ [ self performComponentRefactoring: (RBRemoveMethodRefactoring model: self model removeMethods: {selector} from: aClass) ] on: RBRefactoringError do: [:ex |  (self confirm: (ex messageText copyReplaceAll: 'Browse references?' with: 'Remove anyway?')) ifTrue: [ ex resume ] ] ]-=JUAMPI=-shouldFail: aRefactoring  self proceedThroughWarning: [ self should: [ aRefactoring transform ] raise: RBRefactoringError ]-=JUAMPI=-testModelAddClass  | refactoring newClass superClass subclass |  subclass := model classNamed: #Bar.  superClass := model classNamed: #Foo.  refactoring := (RBAddClassTransformation model: model addClass: #FooTest superclass: #Foo subclasses: #(Bar) category: #'Refactory-Testing') asRefactoring.  refactoring transform.  newClass := model classNamed: #FooTest.  self assert: newClass superclass equals: superClass.  self assert: (superClass subclasses includes: newClass).  self assert: newClass theMetaClass superclass equals: superClass theMetaClass.  self assert: (superClass theMetaClass subclasses includes: newClass theMetaClass).  self assert: subclass superclass equals: newClass.  self assert: (newClass subclasses includes: subclass).  self assert: subclass theMetaClass superclass equals: newClass theMetaClass.  self assert: (newClass theMetaClass subclasses includes: subclass theMetaClass)-=JUAMPI=-testTransform  | transformation class |  transformation := (RBDeprecateClassTransformation class: self changeMock name) transform.  self assert: transformation model changes changes size equals: 4.  class := transformation model classNamed: self changeMock name asSymbol.  self assert: class comment equals: 'Deprecated!!! Use superclass'.  class := transformation model metaclassNamed: self changeMock name.  self assert: (class parseTreeFor: #new) equals: (self parseMethod: 'new				self deprecated: ''Use superclass '' on: ''4 May 2016''  in: #Pharo60.				^ super new').  self assert: (class parseTreeFor: #deprecated) equals: (self parseMethod: 'deprecated ^ true').  self assert: (class parseTreeFor: #systemIcon) equals: (self parseMethod: 'systemIcon				^ Smalltalk ui icons iconNamed: #packageDelete')-=JUAMPI=-testModelAlreadyExistingName  self     shouldFail: (RBAddVariableTransformation model: model instanceVariable: 'instVarName1' class: (model classNamed: #Bar)) asRefactoring;     shouldFail: (RBAddVariableTransformation model: model classVariable: #ClassVarName2 class: (model classNamed: #Bar)) asRefactoring-=JUAMPI=-neitherFailed  ^(left errorStringFor: true) , ' AND ' , (right errorStringFor: true)-=JUAMPI=-convertAllReferencesToClass: aRBClass using: searchReplacer  self model allReferencesToClass: aRBClass do: [:method |  self convertMethod: method selector for: method modelClass using: searchReplacer ]-=JUAMPI=-testSystemIntegrity  | classes environment |  classes := IdentitySet new.  environment := RBBrowserEnvironment new.  environment allClassesDo: [:class |  (classes includes: class) ifFalse: [ classes add: class ] ifTrue: [ self error: 'The class ' , class name , ' that is available under two or more names. This causes problems with the refactoring browser.' ] ]-=JUAMPI=-rootClasses  ^rootClasses ifNil: [ rootClasses := self privateRootClasses ]-=JUAMPI=-checkClassVars  selectors do: [:each |  self checkClassVarsFor: each ]-=JUAMPI=-testInheritedName  self shouldFail: (RBAbstractInstanceVariableRefactoring variable: 'name' class: RBBasicLintRuleTestData)-=JUAMPI=-condition: aCondition  condition := aCondition.  self errorMacro: condition errorMacro-=JUAMPI=-renameClass: aRBClass to: newName  ^RBRenameClassChange rename: aRBClass name to: newName-=JUAMPI=-extractMethod  | parseTree isSequence extractCode subtree newCode errorMessage |  extractCode := self getExtractedSource.  extractedParseTree := self parserClass parseExpression: extractCode onError: [:string :pos :parser |  errorMessage := string.        parser parseErrorNode: string ].  extractedParseTree ifNil: [ self refactoringFailure: 'Invalid source to extract' ].  extractedParseTree isFaulty ifTrue: [ self refactoringFailure: 'Invalid source to extract - ' , errorMessage ].  (extractedParseTree isSequence and: [ extractedParseTree statements isEmpty ]) ifTrue: [ self refactoringError: 'Select some code to extract' ].  isSequence := extractedParseTree isSequence or: [ extractedParseTree isReturn ].  extractedParseTree := RBMethodNode selector: #value arguments: #() body: (extractedParseTree isSequence ifTrue: [ extractedParseTree ] ifFalse: [ RBSequenceNode temporaries: #() statements: (OrderedCollection with: extractedParseTree) ]).  extractedParseTree body temporaries ifNotEmpty: [ extractedParseTree body temporaries: #() ].  extractedParseTree source: extractCode.  parseTree := class parseTreeFor: selector.  parseTree ifNil: [ self refactoringFailure: 'Could not parse ' , selector printString ].  subtree := isSequence ifTrue: [ self parseTreeSearcherClass treeMatchingStatements: extractedParseTree body formattedCode in: parseTree ] ifFalse: [ self parseTreeSearcherClass treeMatching: extractCode in: parseTree ].  subtree ifNil: [ self refactoringFailure: 'Could not extract code from method' ].  newCode := self methodDelimiter.  isSequence ifTrue: [ | stmts |        stmts := extractedParseTree body statements.        stmts ifNotEmpty: [ stmts last isAssignment ifTrue: [ | name |                    name := stmts last variable name.                    (self shouldExtractAssignmentTo: name) ifFalse: [ newCode := '<1s> := <2s>' expandMacrosWith: name with: newCode.                          stmts at: stmts size put: stmts last value ] ] ] ].  modifiedParseTree := isSequence ifTrue: [ RBParseTreeRewriter replaceStatements: subtree formattedCode with: newCode in: parseTree onInterval: extractionInterval ] ifFalse: [ RBParseTreeRewriter replace: subtree formattedCode with: newCode in: parseTree onInterval: extractionInterval ]-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' bindTight: '.  interval storeOn: aStream.  aStream nextPutAll: ' in: '.  class storeOn: aStream.  aStream     nextPutAll: ' selector: #';     nextPutAll: selector.  aStream nextPut: $)-=JUAMPI=-receiver: aString  receiver := aString-=JUAMPI=-isMeta  ^true-=JUAMPI=-existingMethodsThatReferToInstanceVariable: aString  | existingMethods |  existingMethods := self realClass whichSelectorsAccess: aString.  (newMethods isNil and: [ removedMethods isNil ]) ifTrue: [ ^existingMethods ].  ^existingMethods reject: [:each |  (self hasRemoved: each) or: [ self newMethods includesKey: each ] ]-=JUAMPI=-postCopy  super postCopy.  protocols := protocols copy-=JUAMPI=-testBasicLintRuleTypes  | typer types |  typer := RBRefactoryTyper new.  types := typer guessTypesFor: 'classBlock' in: RBBasicLintRuleTestData.  self assert: ([  ] class withAllSuperclasses detect: [:each |  types includes: (typer model classFor: each) ] ifNone: [ nil ]) notNil.  types := typer typesFor: 'methodBlock' in: (typer model classFor: RBBasicLintRuleTestData).  self assert: ([  ] class withAllSuperclasses detect: [:each |  types includes: (typer model classFor: each) ] ifNone: [ nil ]) notNil.  typer printString-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' variable: ''';     nextPutAll: variableName;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: aStream.  aStream nextPut: $)-=JUAMPI=-options: aDictionary  options := aDictionary-=JUAMPI=-transform: aClass  | class method parseTree |  aClass allSelectors do: [:selector |  class := aClass whoDefinesMethod: selector.        (class notNil and: [ class ~= aClass ]) ifTrue: [ method := class methodFor: selector.              (method notNil and: [ method refersToSymbol: #subclassResponsibility ]) ifTrue: [ parseTree := method parseTree.                    parseTree body                       temporaries: OrderedCollection new;                       statements: OrderedCollection new;                       addNode: (RBMessageNode receiver: (RBVariableNode named: 'self') selector: #shouldBeImplemented).                    aClass compile: parseTree newSource withAttributesFrom: method ] ] ]-=JUAMPI=-uniqueClassesIn: aBrowserEnvironment  | allClasses |  allClasses := IdentitySet new.  aBrowserEnvironment classesDo: [:each |  self deny: (allClasses includes: each).        allClasses add: each ]-=JUAMPI=-pushUpMethodsFrom: aClass  | selectorsToPushUp |  selectorsToPushUp := self selectorsToPushUpFrom: aClass.  aClass selectors do: [:each |  (selectorsToPushUp includes: each) ifTrue: [ self pushUp: each in: aClass ] ifFalse: [ self createSubclassResponsibilityFor: each in: aClass ] ].  selectorsToPushUp do: [:each |  aClass removeMethod: each ]-=JUAMPI=-testTransform  | transformation class |  transformation := (RBRemoveAssignmentTransformation new variable: 'variable' value: '1 asString' inMethod: #methodBefore inClass: self class name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self class name.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) body-=JUAMPI=-checkMethod: aSmalllintContext  rules do: [:each |  each checkMethod: aSmalllintContext.        Processor yield ]-=JUAMPI=-preconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition withBlock: [ | methodSource |              interval first <= interval last ifFalse: [ self refactoringFailure: 'You must select a variable name' ].              methodSource := class sourceCodeFor: selector.              methodSource size >= interval last ifFalse: [ self refactoringFailure: 'Invalid range for variable' ].              name := methodSource copyFrom: interval first to: interval last.              (self checkInstanceVariableName: name in: class) ifFalse: [ self refactoringFailure: name , ' does not seem to be a valid variable name.' ].              parseTree := class parseTreeFor: selector.              self checkParseTree.              true ])-=JUAMPI=-executeRefactoring: aRefactoring  aRefactoring primitiveExecute.  self parserClass parseExpression: aRefactoring storeString-=JUAMPI=-checkSuperMessages  self inlineClass = class ifTrue: [ ^self ].  self inlineClass superclass ifNil: [ ^self ].  inlineParseTree superMessages do: [:each |  (self inlineClass superclass whoDefinesMethod: each) = (class superclass whoDefinesMethod: each) ifFalse: [ self refactoringError: ('Cannot inline method since it sends a super message <1s> that is overriden' expandMacrosWith: each) ] ]-=JUAMPI=-buildTransformations  self subclassResponsibility-=JUAMPI=-testRefactoring  | refactoring |  refactoring := (RBRemoveClassTransformation className: #RBFooDummyLintRuleTest1) asRefactoring.  [ refactoring transform ] on: RBRefactoringError do: [:error |  self resumeIfCannotRemove: error ].  self assert: (refactoring model classNamed: #RBFooDummyLintRuleTest1) isNil.  self assert: (refactoring model classNamed: 'RBTransformationDummyRuleTest1' asSymbol) superclass equals: (refactoring model classNamed: #RBDummyLintRuleTest)-=JUAMPI=-hasConflicts  ^rules anySatisfy: [:each |  each hasConflicts ]-=JUAMPI=-forPackageNames: aCollection  ^RBPackageEnvironment onEnvironment: self packageNames: aCollection-=JUAMPI=-testMetaclassFailure  self shouldFail: (RBPullUpVariableTransformation classVariable: #RecursiveSelfRule class: RBDummyLintRuleTest class) asRefactoring-=JUAMPI=-testNonExistantName  self     shouldFail: (RBCreateAccessorsForVariableRefactoring variable: #Foo class: RBBasicLintRuleTestData classVariable: true);     shouldFail: (RBCreateAccessorsForVariableRefactoring variable: 'foo' class: RBBasicLintRuleTestData classVariable: true)-=JUAMPI=-removeClassVariable: variableName from: aClass  ^RBRemoveClassVariableChange remove: variableName from: aClass-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' class: '.  class storeOn: aStream.  aStream nextPutAll: ' instanceVariables: '.  instanceVariables asArray storeOn: aStream.  aStream     nextPutAll: ' newClassName: #';     nextPutAll: newClassName;     nextPutAll: ' referenceVariableName: ''';     nextPutAll: referenceVariableName;     nextPutAll: ''')'-=JUAMPI=-setupSelfArgumentNameFor: aRefactoring toReturn: aString  | options |  options := aRefactoring options copy.  options at: #selfArgumentName put: [:ref |  aString ].  aRefactoring options: options-=JUAMPI=-findSequenceNode  sequenceNode := self parserClass parseExpression: self selectedSource onError: [:msg :pos |  self refactoringFailure: 'Invalid source to rewrite' ].  (sequenceNode isSequence and: [ sequenceNode statements size > 1 ]) ifFalse: [ self refactoringFailure: 'You must select two or more statements' ]-=JUAMPI=-protocol: aString inClass: aClassName  self className: aClassName.  protocol := aString-=JUAMPI=-refineTypesByLookingAtAssignments  | searcher needsSearch |  needsSearch := false.  searcher := self parseTreeSearcher.  variableTypes keysAndValuesDo: [:key :value |  key first = $- ifFalse: [ needsSearch := true.              searcher matches: key , ' := ``@object' do: [:aNode :answer |  self guessTypeFromAssignment: aNode ] ] ].  needsSearch ifTrue: [ self executeSearch: searcher ]-=JUAMPI=-testExtractMethodThatNeedsTemporaryVariable  | refactoring class |  refactoring := RBExtractMethodRefactoring extract: (78 to: 197) from: #displayName in: RBLintRuleTestData.  self setupMethodNameFor: refactoring toReturn: #foo:.  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBLintRuleTestData.  self assert: (class parseTreeFor: #displayName) equals: (self parseMethod: 'displayName	| nameStream |	nameStream := WriteStream on: (String new: 64).	self foo: nameStream.	^nameStream contents').  self assert: (class parseTreeFor: #foo:) equals: (self parseMethod: 'foo: nameStream 	nameStream nextPutAll: self name;		nextPutAll: '' (''.	self problemCount printOn: nameStream.	nameStream nextPut: $).')-=JUAMPI=-classNames  ^IdentitySet new     addAll: classSelectors keys;     addAll: metaClassSelectors keys;     yourself-=JUAMPI=-inlineParameter: aString in: aClass selector: aSelector  oldSelector := aSelector.  class := self classObjectFor: aClass.  argument := aString-=JUAMPI=-checkMethod: aMethod  -=JUAMPI=-addClassVariable: aString to: aRBClass  ^changes addClassVariable: aString to: aRBClass-=JUAMPI=-isParseTreeEquivalentTo: aSelector  | tree definingClass |  definingClass := class whoDefinesMethod: aSelector.  tree := definingClass parseTreeFor: aSelector.  tree ifNil: [ ^false ].  tree isPrimitive ifTrue: [ ^false ].  (tree body equalTo: extractedParseTree body exceptForVariables: (tree arguments collect: [:each |  each name ])) ifFalse: [ ^false ].  (definingClass = class or: [ (tree superMessages anySatisfy: [:each |  (class superclass whichClassIncludesSelector: aSelector) ~= (definingClass superclass whichClassIncludesSelector: each) ]) not ]) ifFalse: [ ^false ].  ^self shouldUseExistingMethod: aSelector-=JUAMPI=-newResultClass: aClass  result := aClass new-=JUAMPI=-problemCount  ^self numberSelectors-=JUAMPI=-initialize  super initialize.  keywords := IdentitySet new.  condition := [:pragma |  true ]-=JUAMPI=-removeArgument  | removeIndex |  removeIndex := parseTree argumentNames indexOf: variable.  removeIndex = 0 ifFalse: [ parseTree selector: ('' join: (parseTree selector keywords asOrderedCollection                       removeAt: removeIndex;                       yourself)) asSymbol keywordsPositions: (parseTree keywordsPositions asOrderedCollection                 removeAt: removeIndex;                 yourself) asIntegerArray arguments: (parseTree arguments asOrderedCollection                 removeAt: removeIndex;                 yourself) asArray ]-=JUAMPI=-initialize  super initialize.  comment := LookupComment-=JUAMPI=-abstractSuperclass  ^self model classNamed: className asSymbol-=JUAMPI=-testModelRemoveInstanceVariable  | class |  model defineClass: 'nil subclass: #Object		instanceVariableNames: ''foo1''		classVariableNames: ''''		poolDictionaries: ''''		category: #''Refactory-Test data'''.  class := model classNamed: #Object.  self assert: (class definesInstanceVariable: 'foo1').  (RBRemoveVariableTransformation model: model instanceVariable: 'foo1' class: class) asRefactoring transform.  self deny: (class definesInstanceVariable: 'foo1')-=JUAMPI=-definitionClass  ^Trait-=JUAMPI=-matchNodes  ^matchNodes ifNil: [ | visitor node sourceCode |        visitor := RBMatchVisitor new.        node := method sourceNode copy.        node acceptVisitor: visitor.        sourceCode := self replaceArgumentsByPattern: node newSource.        sourceCode := sourceCode copyFrom: method sourceNode body statements first start + visitor difference to: sourceCode size.        matchNodes := OrderedCollection new.        matchNodes add: (RBPatternParser parseExpression: sourceCode).        node lastIsReturn ifTrue: [ node hasMultipleReturns ifFalse: [ sourceCode := sourceCode copyReplaceAll: '^' with: ''.                    matchNodes add: (RBPatternParser parseExpression: sourceCode) ] ].        matchNodes ]-=JUAMPI=-testVariableDoesNotExist  self     shouldFail: (RBRenameVariableTransformation rename: 'foo' to: 'newFoo' in: #RBBasicLintRuleTestData classVariable: false) asRefactoring;     shouldFail: (RBRenameVariableTransformation rename: #foo to: #newFoo in: #RBBasicLintRuleTestData classVariable: true) asRefactoring-=JUAMPI=-isSelectorEnvironment  ^false-=JUAMPI=-testEmptyCode  self shouldFail: (RBReplaceSubtreeTransformation replace: '' to: '^ selector' inMethod: #selector:from: inClass: #RBRemoveMethodTransformation) asRefactoring-=JUAMPI=-testRenamePermuteArgs  | refactoring class |  refactoring := RBRenameMethodRefactoring renameMethod: ('rename:' , 'two:') asSymbol in: RBRefactoryTestDataApp to: ('rename:' , 'two:') asSymbol permutation: #(2 1).  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBRefactoryTestDataApp.  self assert: (class parseTreeFor: ('rename:' , 'two:') asSymbol) equals: (self parseMethod: 'rename: argumentMethod two: this ^self printString, this, argumentMethod').  self assert: (class parseTreeFor: #exampleCall) equals: (self parseMethod: 'exampleCall <sampleInstance> ^self rename: 2 two: 1')-=JUAMPI=-initialize  super initialize.  self resetResult-=JUAMPI=-refactoringFailure: aString  ^RBRefactoringFailure signal: aString-=JUAMPI=-classBlock  ^self anInstVar + 5-=JUAMPI=-renameSelfReferences  self addSelfReferenceToSourceMessage.  self addSelfReferenceToInlineParseTree-=JUAMPI=-cruft  < haltOrBreakpointForTesting>  self halt-=JUAMPI=-setUp  super setUp.  model := Smalltalk compiler evaluate: self childrenToSiblingTestData-=JUAMPI=-refactoringError: aString with: aBlock  ^RBRefactoringError signal: aString with: aBlock-=JUAMPI=-callFoo  ^self testFoo: 5-=JUAMPI=-transform  self transform: self theClass.  self transform: self theClass classSide-=JUAMPI=-preconditionHasNoReferences: aClass  | env |  env := self environmentWithReferencesTo: aClass.  ^(RBCondition withBlock: [ env isEmpty ])     errorMacro: aClass , ' is referenced.<n>Browse references?';     errorBlock: [ self openBrowserOn: env ];     yourself-=JUAMPI=-includesSelector: aSelector in: aClass  (environment includesSelector: aSelector in: aClass) ifFalse: [ ^false ].  ^(aClass compiledMethodAt: aSelector) pragmas anySatisfy: [:each |  self includesPragma: each ]-=JUAMPI=-literalArrayWithTrueFalseOrNil2  | b c |  b := #(#true #false #nil).  c := #(#true #(#true #false #nil) #false #nil).  ^b-=JUAMPI=-transform  self renameMessageSends-=JUAMPI=-testTransform  | transformation class |  transformation := (RBAddVariableAccessorTransformation instanceVariable: 'instVar' class: self changeMock name) transform.  self assert: transformation model changes changes size equals: 2.  class := transformation model classNamed: self changeMock name asSymbol.  self assert: (class parseTreeFor: #instVar) equals: (self parseMethod: 'instVar ^instVar').  self assert: (class parseTreeFor: #instVar:) equals: (self parseMethod: 'instVar: anObject instVar := anObject')-=JUAMPI=-hash  ^self changeClassName hash bitXor: self variable hash-=JUAMPI=-renameReferences  | replacer |  replacer := RBParseTreeRewriter rename: variableName to: newName handler: [ self refactoringError: ('<1s> is already defined as a method or block temporary <n> variable in this class or one of its subclasses' expandMacrosWith: newName) ].  self convertClasses: class withAllSubclasses select: [:aClass |  aClass whichSelectorsReferToInstanceVariable: variableName ] using: replacer-=JUAMPI=-result  ^result-=JUAMPI=-selectors: aList  selectors := aList-=JUAMPI=-classNameFor: aBehavior  ^aBehavior instanceSide name-=JUAMPI=-buildTransformations  ^OrderedCollection new     addAll: (self variableDefinitionsInHierarchy collect: [:each |  RBRemoveVariableTransformation model: self model variable: variableName class: each classVariable: isClassVariable ]);     add: (RBAddVariableTransformation model: self model variable: variableName class: className classVariable: isClassVariable);     yourself-=JUAMPI=-returnsIfTrue  ^self isNil ifTrue: [ 4 ]-=JUAMPI=-environmentWithUsersOf: aTrait  ^RBClassEnvironment onEnvironment: RBBrowserEnvironment new classes: aTrait realClass users-=JUAMPI=-equivalentSuperclassMethods  ^self identityHash-=JUAMPI=-= aRefactoryBuilder  self class = aRefactoryBuilder class ifFalse: [ ^false ].  changes size = aRefactoryBuilder changes size ifFalse: [ ^false ].  changes with: aRefactoryBuilder changes do: [:first :second |  first = second ifFalse: [ ^false ] ].  ^true-=JUAMPI=-sharedPoolNames  ^self privatePoolDictionaryNames copy-=JUAMPI=-whichCategoryIncludes: aClassName  ^self systemDictionary organization categoryOfElement: aClassName-=JUAMPI=-changeString  ^'Add Protocol named ' , self displayProtocolName , ' in ' , self displayClassName-=JUAMPI=-changeSymbol  ^#addSharedPool:-=JUAMPI=-isSharedPool  ^(self allSuperclasses collect: #name) includes: #SharedPool-=JUAMPI=-shouldPushUp: aSelector from: aClass  ^(aClass isMeta ifTrue: [ subclasses collect: [:each |  each classSide ] ] ifFalse: [ subclasses ]) anySatisfy: [:each |  (each directlyDefinesMethod: aSelector) not ]-=JUAMPI=-definesClass: aClass  ^self includesClass: aClass-=JUAMPI=-createReference  transformations add: (RBAddVariableTransformation model: self model instanceVariable: referenceVariableName class: class)-=JUAMPI=-addClassAndMetaClassFor: aClassOrMetaClass  self     addClass: aClassOrMetaClass classSide;     addClass: aClassOrMetaClass instanceSide-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' removeMethods: '.  selectors asArray storeOn: aStream.  aStream nextPutAll: ' from: '.  class storeOn: aStream.  aStream nextPut: $)-=JUAMPI=-getClassesForTemporaryVariable  | types |  types := RBRefactoryTyper typesFor: variable in: parseTree model: self model.  types ifEmpty: [ types := OrderedCollection with: (self model classNamed: #Object) ].  moveToClasses := self selectVariableTypesFrom: types selected: types.  moveToClasses ifNil: [ self refactoringFailure: 'Method not moved' ]-=JUAMPI=-parserClass  ^RBParser-=JUAMPI=-hierarchyDefinesVariable: aString  (self definesVariable: aString) ifTrue: [ ^true ].  ^self allSubclasses anySatisfy: [:each |  each directlyDefinesVariable: aString ]-=JUAMPI=-printOn: aStream  super printOn: aStream.  self name ifNotNil: [ aStream           nextPutAll: ' name: ';           print: self name ]-=JUAMPI=-preconditions  | cond |  cond := ((RBCondition isMetaclass: (self model classObjectFor: superclass)) errorMacro: 'Superclass must not be a metaclass') not.  cond := subclasses inject: cond into: [:sub :each |  sub & ((RBCondition isMetaclass: (self model classObjectFor: each)) errorMacro: 'Subclass must <1?not :>be a metaclass') not & (RBCondition isImmediateSubclass: (self model classObjectFor: each) of: (self model classObjectFor: superclass)) ].  ^cond & (RBCondition isValidClassName: className) & (RBCondition isGlobal: className in: self model) not & (RBCondition isSymbol: category) & ((RBCondition withBlock: [ category isEmpty not ]) errorMacro: 'Invalid category name')-=JUAMPI=-model  ^model ifNil: [ model := (RBClassModelFactory rbNamespace onEnvironment: self defaultEnvironment)           name: self printString;           yourself ] ifNotNil: [ model ]-=JUAMPI=-allSuperclassesUntil: aClass  | supers sprClass |  supers := OrderedCollection new.  sprClass := self superclass.  [ sprClass notNil and: [ sprClass name ~= aClass name ] ] whileTrue: [ supers add: sprClass.        sprClass := sprClass superclass ].  ^supers-=JUAMPI=-protocol: aString  protocol := aString-=JUAMPI=-someDemoMethod  ^self junk-=JUAMPI=-directlyDefinesClassVariable: aString  ^self theNonMetaClass directlyDefinesClassVariable: aString-=JUAMPI=-privateTransform  self model     defineClass: ('<1p> subclass: #<2s> instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: <3p>' expandMacrosWith: (self model classObjectFor: superclass) with: className with: category asString);     reparentClasses: (subclasses collect: [:e |  self model classObjectFor: e ]) to: (self model classNamed: className asSymbol)-=JUAMPI=-testExtractMethodThatNeedsArgument  | refactoring class |  refactoring := RBExtractMethodRefactoring extract: (145 to: 343) from: #checkMethod: in: RBTransformationRuleTestData.  self setupMethodNameFor: refactoring toReturn: #foo:.  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBTransformationRuleTestData.  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 	class := aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[self foo: aSmalllintContext]').  self assert: (class parseTreeFor: #foo:) equals: (self parseMethod: 'foo: aSmalllintContext (RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)				ifFalse: 					[builder compile: rewriteRule tree printString						in: class						classified: aSmalllintContext protocols]')-=JUAMPI=-rename: this two: argumentMethod  ^self printString , this , argumentMethod-=JUAMPI=-methodAfter  < gtInspectorPresentationOrder: 56>  | variable |  variable := 'String'-=JUAMPI=-selectionIntervalFor: aString  | parseTree node |  matcher ifNil: [ ^super selectionIntervalFor: aString ].  parseTree := RBParser parseMethod: aString onError: [:error :position |  ^super selectionIntervalFor: aString ].  node := matcher executeTree: parseTree initialAnswer: nil.  ^(node isKindOf: RBProgramNode) ifTrue: [ node sourceInterval ] ifFalse: [ super selectionIntervalFor: aString ]-=JUAMPI=-variableAssignedLiteral  temporaryVariable := #()-=JUAMPI=-multiplePeriodsTerminatingAssignmentStatement  | strings |  strings := OrderedCollection.  strings     add: 'one';     add: 'two'.  ^strings-=JUAMPI=-executeNotifying: aBlock  | undo |  undo := self asUndoOperation.  undo name: self name.  self primitiveExecute.  aBlock value.  ^undo-=JUAMPI=-testRemoveClassWithReferences  self shouldFail: (RBRemoveClassTransformation className: #RBBasicLintRuleTestData) asRefactoring-=JUAMPI=-reparentSubclasses  self model reparentClasses: self definingClass subclasses copy to: self definingClass superclass-=JUAMPI=-equalsTrue  ^true == self-=JUAMPI=-notifyUserOfCommand: aCommand  | answer title |  title := self actionBlock ifNotNil: [ 'Warning' ] ifNil: [ 'Warning. Want to proceed?' ].  answer := UIManager default confirm: self messageText label: title.  answer ifTrue: [ self actionBlock ifNil: [ self resume: true ] ifNotNil: #value ]-=JUAMPI=-testModelInvalidSubclass  self shouldFail: (RBAddClassTransformation model: model addClass: #Foo2 superclass: #Object subclasses: (Array with: (model classNamed: #Bar)) category: #'Refactory-Tesing') asRefactoring-=JUAMPI=-calculateTree  ^parseTree ifNil: [ parseTree := self definingMethod ]-=JUAMPI=-isEmpty  ^self builder changes isEmpty-=JUAMPI=-propagateTransformation  self renameReferences-=JUAMPI=-shouldCopyExtensions: anObject  shouldCopyExtensions := anObject-=JUAMPI=-testMethodDoesNotExist  self shouldFail: (RBMethodProtocolTransformation protocol: 'empty protocol 2' inMethod: #method inClass: #RBDummyEmptyClass) asRefactoring-=JUAMPI=-methods  | methods |  methods := IdentitySet new: 4096.  self methodsDo: [:each |  methods add: each ].  ^methods-=JUAMPI=-rationale  ^'Checks for ifTrue: or ifFalse: conditions at end of methods that have two or more statements inside their blocks. Such code might better represent the true meaning of the code if they returned self instead.'-=JUAMPI=-textToDisplay  ^self source-=JUAMPI=-safeVariableNameFor: aClass temporaries: allTempVars  | baseString i newString |  newString := baseString := 'anObject'.  i := 0.  [ (allTempVars includes: newString) or: [ aClass definesInstanceVariable: newString ] ] whileTrue: [ i := i + 1.        newString := baseString , i printString ].  ^newString-=JUAMPI=-preconditions  ^(selectors inject: RBCondition empty into: [:cond :each |  cond & (RBCondition definesSelector: each in: class) ]) & (RBCondition withBlock: [ self checkSuperMethods.              true ])-=JUAMPI=-classSide  ^model metaclassNamed: self name-=JUAMPI=-storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' deprecateMethod: #';     nextPutAll: oldSelector;     nextPutAll: ' in: '.  class storeOn: aStream.  aStream     nextPutAll: ' using: #';     nextPutAll: newSelector.  aStream nextPut: $)-=JUAMPI=-changeStamp  ^Author changeStamp-=JUAMPI=-consistencyCheck  ^(1 to: 10) size > 0-=JUAMPI=-testModel  | class |  class := model metaclassNamed: #Bar.  (RBAddMethodTransformation model: model sourceCode: 'printString1 ^super printString' in: class withProtocol: #accessing) asRefactoring transform.  self assert: (class parseTreeFor: #printString1) equals: (self parseMethod: 'printString1 ^super printString')-=JUAMPI=-testNewClassVariableAccessors  | refactoring class |  refactoring := (RBAddVariableAccessorTransformation classVariable: 'Foo1' class: #RBDummyLintRuleTest) asRefactoring transform.  class := refactoring model metaclassNamed: #RBDummyLintRuleTest.  self denyEmpty: refactoring changes changes.  self assert: (class parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 ^Foo1').  self assert: (class parseTreeFor: #foo1:) equals: (self parseMethod: 'foo1: anObject Foo1 := anObject')-=JUAMPI=-environment  ^self-=JUAMPI=-testMetaclass  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model metaclassNamed: #SomeClass) addInstanceVariable: 'foo'.  model defineClass: 'SomeClass subclass: #Subclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model metaclassNamed: #Subclass) compile: 'foo ^foo' classified: #(#accessing).  (RBPushDownVariableTransformation model: model instanceVariable: 'foo' class: (model metaclassNamed: #SomeClass)) asRefactoring transform.  self deny: ((model metaclassNamed: #SomeClass) directlyDefinesVariable: 'foo').  self assert: ((model metaclassNamed: #Subclass) directlyDefinesVariable: 'foo')-=JUAMPI=-hash  ^(self class hash bitXor: self oldName hash) bitXor: self newName hash-=JUAMPI=-errorMacro  ^errorMacro ifNil: [ self longMacro ] ifNotNil: [ super errorMacro ]-=JUAMPI=-method1  ^self method2-=JUAMPI=-unaryAccessingMessageStatementMethodWithReturn  ^self value-=JUAMPI=-testExistingSelector  self shouldFail: (RBAddMethodRefactoring addMethod: 'printString ^super printString' toClass: RBBasicLintRuleTestData inProtocols: #(#accessing))-=JUAMPI=-selectorNotReferenced  ^self selectorNotReferenced + 4-=JUAMPI=-detectContains  ^(1 to: 10) do: [:each |  each > 2 ifTrue: [ ^each ] ]-=JUAMPI=-removeMethod: aSelector from: aClass  ^self addChange: (changeFactory removeMethod: aSelector from: aClass)-=JUAMPI=-asUndoOperation  ^RBAddProtocolChange addProtocolNamed: protocol in: self changeClass-=JUAMPI=-missingYourself  ^OrderedCollection new     add: 1;     add: 2;     removeFirst-=JUAMPI=-testPullUpInstVar  | refactoring |  self proceedThroughWarning: [ refactoring := RBPullUpInstanceVariableRefactoring variable: 'result' class: RBLintRuleTestData.        self executeRefactoring: refactoring ].  self assert: ((refactoring model classNamed: #RBLintRuleTestData) directlyDefinesInstanceVariable: 'result').  self deny: ((refactoring model classNamed: #RBBasicLintRuleTestData) directlyDefinesInstanceVariable: 'result')-=JUAMPI=-changeString  ^'Remove protocol named ' , self displayProtocolName , ' in ' , self displayClassName-=JUAMPI=-testBadInterval  self shouldFail: (RBRenameTemporaryRefactoring renameTemporaryFrom: (14 to: 17) to: 'asdf' in: RBRefactoryTestDataApp selector: #testMethod)-=JUAMPI=-description: aString  self changes name: aString-=JUAMPI=-deny: actual equals: expected  ^self deny: expected = actual description: [ self unexpectedEqualityStringBetween: actual and: expected ]-=JUAMPI=-testMoveMethodThatReferencesPoolDictionary  | refactoring class |  self proceedThroughWarning: [ refactoring := RBMoveMethodRefactoring selector: #junk class: RBLintRuleTestData variable: 'RefactoryTestDataApp'.        self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.        self setupVariableTypesFor: refactoring toReturn: (Array with: (refactoring model classNamed: 'RBRefactoryTestDataApp class' asSymbol)).        self setupMethodNameFor: refactoring toReturn: #junk1.        self executeRefactoring: refactoring ].  class := refactoring model classNamed: #RBLintRuleTestData.  self assert: (class parseTreeFor: #junk) equals: (self parseMethod: 'junk ^RefactoryTestDataApp junk1').  self assert: ((refactoring model metaclassNamed: #RBRefactoryTestDataApp) parseTreeFor: #junk1) equals: (self parseMethod: 'junk1	^RBRefactoryTestDataApp printString copyFrom: 1 to: CR').  self assert: (class directlyDefinesPoolDictionary: 'TextConstants' asSymbol)-=JUAMPI=-testMoveInstVarToClassAlreadyDefined  self shouldFail: (RBMoveInstVarToClassRefactoring model: model variable: 'result' class: RBBasicLintRuleTestData oldClass: RBFooLintRuleTestData)-=JUAMPI=-methodBefore  | variable |  variable := 'String'-=JUAMPI=-copyDownMethod: aSelector  | oldProtocol oldSource superclassDefiner subclasses refactoring |  superclassDefiner := targetSuperclass whoDefinesMethod: aSelector.  superclassDefiner ifNil: [ ^self ].  oldSource := superclassDefiner sourceCodeFor: aSelector.  oldSource ifNil: [ self refactoringFailure: ('Source code for <1s> superclass method not available' expandMacrosWith: aSelector) ].  oldProtocol := superclassDefiner protocolsFor: aSelector.  subclasses := targetSuperclass subclasses reject: [:each |  each directlyDefinesMethod: aSelector ].  subclasses ifEmpty: [ ^self ].  (superclassDefiner parseTreeFor: aSelector) superMessages detect: [:each |  superclassDefiner directlyDefinesMethod: each ] ifFound: [ self refactoringError: ('Cannot pull up <1s> since we must copy down the superclass method in <2p><n>to the other subclasses, and the superclass method sends a super message which is overriden.' expandMacrosWith: aSelector with: superclassDefiner) ].  self refactoringWarning: 'Do you want to copy down the superclass method to the classes that don''t define ' , aSelector.  refactoring := RBExpandReferencedPoolsRefactoring model: self model forMethod: (superclassDefiner parseTreeFor: aSelector) fromClass: superclassDefiner toClasses: subclasses.  self performComponentRefactoring: refactoring.  subclasses do: [:each |  each compile: oldSource classified: oldProtocol ]-=JUAMPI=-modifiesCollection  | collection |  collection := (1 to: 10) asOrderedCollection.  collection do: [:each |  each > 5 ifTrue: [ collection remove: each ] ].  ^collection-=JUAMPI=-buildTransformations  ^OrderedCollection with: (RBAddVariableTransformation model: self model instanceVariable: variableName asString class: className) with: (RBRemoveVariableTransformation model: self model instanceVariable: variableName asString class: oldClass)-=JUAMPI=-removeInstanceVariable: aString  self privateInstanceVariableNames remove: aString.  model removeInstanceVariable: aString from: self-=JUAMPI=-testTransform  | transformation class |  transformation := (RBRemoveDirectAccessToVariableTransformation instanceVariable: 'class' class: #RBTransformationRuleTestData) transform.  class := transformation model classNamed: #RBTransformationRuleTestData.  self assert: (class parseTreeFor: #superSends) equals: (self parseMethod: 'superSends		| rule |		rule := RBParseTreeRewriter new.		rule addSearch: ''super `@message: ``@args'' 			-> (				[:aNode | 				(self class withAllSubclasses 					detect: [:each | each includesSelector: aNode selector]					ifNone: [nil]) isNil] 						-> ''self `@message: ``@args'').		self rewriteUsing: rule').  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 		self class: aSmalllintContext selectedClass.		(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) ifFalse: 				[builder 					compile: rewriteRule tree printString					in: self class					classified: aSmalllintContext protocols]]')-=JUAMPI=-displayClassName  ^isMeta ifTrue: [ self changeClassName , ' class' ] ifFalse: [ self changeClassName asString ]-=JUAMPI=-initialize  combinations := OrderedCollection new-=JUAMPI=-refersToClass  ^RBRefactoryTestDataApp-=JUAMPI=-parserClass  ^RBParser-=JUAMPI=-split: anInterval from: aSelector in: aClass  class := self classObjectFor: aClass.  selector := aSelector.  selectedInterval := anInterval-=JUAMPI=-resultClass  self subclassResponsibility-=JUAMPI=-