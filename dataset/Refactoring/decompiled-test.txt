class: arg1 variable: arg2  self changeClass: arg1.  variable := arg2-=JUAMPI=-hasPermutedArguments  ^hasPermutedArguments ifNil: [ hasPermutedArguments := super hasPermutedArguments ] ifNotNil: [ hasPermutedArguments ]-=JUAMPI=-storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' classNames: '.  classNames asArray storeOn: arg1.  arg1 nextPut: $)-=JUAMPI=-storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' addMethod: ''';     nextPutAll: source;     nextPutAll: ''' toClass: '.  class storeOn: arg1.  arg1 nextPutAll: ' inProtocols: '.  protocols storeOn: arg1.  arg1 nextPut: $)-=JUAMPI=-storeOn: arg1  super storeOn: arg1.  arg1 nextPutAll: ' class'-=JUAMPI=-storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' sourceCode: '''.  sourceCode storeOn: arg1.  arg1 nextPutAll: ''' in: '.  class storeOn: arg1.  arg1     nextPutAll: ' withProtocol: #';     nextPutAll: protocol asString.  arg1 nextPut: $)-=JUAMPI=-category  ^category-=JUAMPI=-testClassVariable  | tmp1 |  tmp1 := (RBPullUpVariableTransformation classVariable: #RecursiveSelfRule class: #RBDummyLintRuleTest) asRefactoring.  [ tmp1 transform ] on: RBRefactoringError do: [:arg1 |  arg1 resume ].  self assert: ((tmp1 model classNamed: #RBDummyLintRuleTest) directlyDefinesClassVariable: #RecursiveSelfRule).  self deny: ((tmp1 model classNamed: #RBTransformationDummyRuleTest) directlyDefinesClassVariable: #RecursiveSelfRule)-=JUAMPI=-asEpiceaEvent  ^EpRenameMethodRefactoring renameMethod: oldSelector in: class name to: newSelector-=JUAMPI=-changeForMetaclass: arg1 selector: arg2  changes reverseDo: [:arg3 |  | tmp1 |        tmp1 := arg3 changeForMetaclass: arg1 selector: arg2.        tmp1 notNil ifTrue: [ ^tmp1 ] ].  ^nil-=JUAMPI=-formNameFor: arg1  | tmp1 tmp2 tmp3 |  tmp1 := class methodFor: arg1.  tmp2 := tmp1 parseTree keywords asOrderedCollection ifNil: [ '' ].  tmp3 := tmp1 parseTree arguments ifNil: [ '' ].  (tmp2 isNotEmpty and: [ tmp3 isNotEmpty ]) ifTrue: [ ^String streamContents: [:arg2 |  tmp2 with: tmp3 do: [:arg3 :arg4 |  arg2 nextPutAll: arg3 , ' ' , arg4 name , ' ' ] ] ] ifFalse: [ ^arg1 asString ]-=JUAMPI=-computeLiteralsForSelector: arg1 in: arg2  | tmp1 |  tmp1 := arg2 compiledMethodAt: arg1 ifAbsent: [ nil ].  tmp1 ifNil: [ ^self ].  self addLiteralsFor: tmp1-=JUAMPI=-classVariableNames: arg1  classVariableNames := (arg1 collect: [:arg2 |  arg2 asSymbol ]) asOrderedCollection-=JUAMPI=-visitBlockNode: arg1  arg1 arguments do: [:arg2 |  self replace: arg2 with: 'tempMatch' , temporaries asString.        temporaries := temporaries + 1 ].  super visitBlockNode: arg1-=JUAMPI=-renameClassVariable: arg1 to: arg2 in: arg3  ^RBRenameClassVariableChange rename: arg1 to: arg2 in: arg3-=JUAMPI=-checkBrowseOccurrenceOf: arg1 in: arg2  self refactoringError: ('Possible call to <2s> in <1p><n>Browse references?' expandMacrosWith: arg2 modelClass with: arg1) with: [ self openBrowserOn: (RBBrowserEnvironment new referencesTo: arg1) ]-=JUAMPI=-modifiesCollection  | tmp1 |  tmp1 := (1 to: 10) asOrderedCollection.  tmp1 do: [:arg1 |  arg1 > 5 ifTrue: [ tmp1 remove: arg1 ] ].  ^tmp1-=JUAMPI=-transform  class compile: source classified: protocols-=JUAMPI=-replaceReferences  | tmp1 |  tmp1 := RBParseTreeRewriter new.  tmp1 replaceTree: assignmentNode variable withTree: assignmentNode value.  definingNode removeTemporaryNamed: assignmentNode variable name.  tmp1 executeTree: definingNode-=JUAMPI=-pragma: arg1 inMethod: arg2 inClass: arg3  self className: arg3.  selector := arg2.  pragma := arg1-=JUAMPI=-testNonExistantName  self     shouldFail: (RBRemoveDirectAccessToVariableTransformation instanceVariable: 'foo' class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBRemoveDirectAccessToVariableTransformation classVariable: #Foo class: #RBBasicLintRuleTestData) asRefactoring-=JUAMPI=-initialize  super initialize.  changes := OrderedCollection new-=JUAMPI=-buildArgumentSearch  self createArgumentSearchWith: 'aSmalllintContext' selectors: #(#checkMethod: #checkClass:) inClass: RBBasicLintRuleTestData-=JUAMPI=-testRefactoring  | tmp1 tmp2 tmp3 |  tmp2 := 'selectorNotReferenced' asSymbol.  tmp1 := (RBRemoveMethodTransformation selector: tmp2 from: #RBRefactoryTestDataApp) asRefactoring.  tmp3 := tmp1 model classNamed: #RBRefactoryTestDataApp.  self assert: (tmp3 directlyDefinesMethod: tmp2).  tmp1 transform.  self deny: (tmp3 directlyDefinesMethod: tmp2)-=JUAMPI=-transform  | tmp1 tmp2 tmp3 |  self model allClassesDo: [:arg1 |  arg1 selectors do: [:arg2 |  (self model environment includesSelector: arg2 in: arg1 realClass) ifTrue: [ tmp1 := arg1 sourceCodeFor: arg2.                    tmp1 ifNotNil: [ tmp2 := arg1 parseTreeFor: arg2.                          tmp2 ifNotNil: [ tmp3 := tmp2 formattedCode.                                (tmp1 ~= tmp3 and: [ (self parserClass parseMethod: tmp3) = tmp2 ]) ifTrue: [ arg1 compile: tmp3 classified: (arg1 protocolsFor: arg2) ] ] ] ] ] ]-=JUAMPI=-accept: arg1  self okToChange ifFalse: [ ^self ].  [ change do: [:arg2 |  RBRefactoryChangeManager instance performChange: arg2 ] ] asJob     title: 'Refactoring';     run.  arg1     beOk;     close-=JUAMPI=-testRenameClass  | tmp1 tmp2 |  tmp1 := RBRenameClassRefactoring rename: (testingEnvironment at: ('RBClass' , 'ToRename') asSymbol) to: 'RBNew' , 'ClassName' asSymbol.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: ('RBNew' , 'ClassName') asSymbol) parseTreeFor: #method1) equals: (self parseMethod: 'method1	^self method2').  self deny: (tmp1 model includesClassNamed: ('RBClass' , 'ToRename') asSymbol).  tmp2 := tmp1 model classNamed: ('RBSubclass' , 'OfClassToRename') asSymbol.  self assert: tmp2 superclass equals: (tmp1 model classNamed: ('RBNew' , 'ClassName') asSymbol).  self assert: (tmp2 parseTreeFor: #symbolReference) equals: (self parseMethod: 'symbolReference								^#RBNewClassName').  self assert: (tmp2 parseTreeFor: #reference) equals: (self parseMethod: 'reference								^RBNewClassName new')-=JUAMPI=-testRemoveClassVariable  | tmp1 |  tmp1 := changes removeClassVariable: 'ClassVar' from: self class.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class.  self assert: tmp1 isMeta not.  self assert: tmp1 variable equals: 'ClassVar'.  self universalTestFor: tmp1-=JUAMPI=-testObjectIsNotAbstract  self deny: objectClass isAbstract.  self deny: objectClass classSide isAbstract-=JUAMPI=-isOkEnabled  ^argumentsList isEmpty-=JUAMPI=-pullUp: arg1 from: arg2 to: arg3  self setOption: #superClass toUse: [:arg4 |   ].  class := self classObjectFor: arg2.  targetSuperclass := self classObjectFor: arg3.  selectors := arg1.  removeDuplicates := false-=JUAMPI=-asUndoOperation  ^self class selector: self selector in: self changeClass classified: self oldProtocol-=JUAMPI=-signalFailure: arg1  self classForTestResult failure signal: arg1-=JUAMPI=-findMessageNodes  beforeNodes := cascadeNode messages select: [:arg1 |  arg1 stop <= selectedInterval first ].  afterNodes := cascadeNode messages select: [:arg1 |  selectedInterval last <= arg1 keywordsPositions first ].  (beforeNodes isEmpty or: [ afterNodes isEmpty ]) ifTrue: [ self refactoringFailure: 'Splitting a cascade into the whole cascade and an empty one is pointless' ].  beforeNodes size + afterNodes size = cascadeNode messages size ifFalse: [ self refactoringFailure: 'To set the split boundary place the cursor inbetween two cascaded messages' ]-=JUAMPI=-reparentClasses: arg1 to: arg2  arg1 do: [:arg3 |  self defineClass: (self replaceClassNameIn: arg3 definitionString to: arg2 name) ]-=JUAMPI=-allSubclasses  | tmp1 tmp2 |  tmp2 := 1.  tmp1 := OrderedCollection withAll: self subclasses.  [ tmp2 <= tmp1 size ] whileTrue: [ tmp1 addAll: (tmp1 at: tmp2) subclasses.        tmp2 := tmp2 + 1 ].  ^tmp1-=JUAMPI=-definingClass  ^classVariable ifTrue: [ class classSide ] ifFalse: [ class ]-=JUAMPI=-realName: arg1  self subclassResponsibility-=JUAMPI=-testBadName  self shouldFail: (RBExtractToTemporaryRefactoring extract: (14 to: 23) to: 'a sdf' from: #testMethod in: RBRefactoryTestDataApp)-=JUAMPI=-nonUnaryAccessingMessageStatementMethodWithoutReturn: arg1  self value-=JUAMPI=-sendsDifferentSuper  super printString-=JUAMPI=-newMethodName  | tmp1 tmp2 |  tmp2 := newSelector isNil.  tmp1 := RBMethodName new.  tmp1 arguments: arguments.  newSelector ifNotNil: [ tmp1 selector: newSelector ].  [ tmp2 ] whileTrue: [ tmp1 := (RBMethodNameEditor openOn: tmp1) methodName.        tmp1 ifNil: [ tmp2 := false ] ifNotNil: [:arg1 |  newSelector := arg1 selector.              tmp2 := newSelector isNil.              (newSelector isString and: [ RBScanner isSelector: newSelector ]) ifFalse: [ self inform: newSelector asString , ' is not a valid selector.'.                    newSelector := nil ].              (self definingClass directlyDefinesLocalMethod: newSelector) ifTrue: [ self inform: newSelector , ' is already defined in ' , class asString.                    newSelector := nil ] ] ].  ^tmp1-=JUAMPI=-performComponentRefactoring: arg1  arg1 copyOptionsFrom: self options.  arg1 primitiveExecute-=JUAMPI=-withAllSubclasses  ^self allSubclasses     add: self;     yourself-=JUAMPI=-selector: arg1 in: arg2 classified: arg3  selector := arg1.  self changeClass: arg2.  self protocols: arg3-=JUAMPI=-preconditions  ^RBCondition withBlock: [ (class hierarchyDefinesInstanceVariable: variableName) ifFalse: [ self refactoringFailure: 'No subclass defines ' , variableName ].        (class subclasses anySatisfy: [:arg1 |  (arg1 directlyDefinesInstanceVariable: variableName) not ]) ifTrue: [ self refactoringWarning: 'Not all subclasses have an instance variable named ' , variableName , '.' ].        true ]-=JUAMPI=-createTemporariesInExtractedMethodFor: arg1  arg1 do: [:arg2 |  extractedParseTree body addTemporaryNamed: arg2 ]-=JUAMPI=-testMoveMethodIntoArgument  | tmp1 tmp2 |  self proceedThroughWarning: [ tmp1 := RBMoveMethodRefactoring selector: #checkMethod: class: RBTransformationRuleTestData variable: 'aSmalllintContext'.        self setupSelfArgumentNameFor: tmp1 toReturn: 'transformationRule'.        self setupVariableTypesFor: tmp1 toReturn: (Array with: (tmp1 model classNamed: #RBSmalllintContext)).        self setupMethodNameFor: tmp1 toReturn: #foo:.        self executeRefactoring: tmp1 ].  tmp2 := tmp1 model classNamed: #RBTransformationRuleTestData.  self assert: (tmp2 parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext aSmalllintContext foo: self').  self assert: ((tmp1 model classNamed: #RBSmalllintContext) parseTreeFor: #foo:) equals: (self parseMethod: 'foo: transformationRule	transformationRule class: self selectedClass.	(transformationRule rewriteRule executeTree: self parseTree) ifTrue: 			[(transformationRule class recursiveSelfRule executeTree: transformationRule rewriteRule tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: transformationRule rewriteRule tree printString						in: transformationRule class1						classified: self protocols]]').  self assert: (tmp2 parseTreeFor: #class1) equals: (self parseMethod: 'class1 ^class').  self assert: (tmp2 parseTreeFor: #class:) equals: (self parseMethod: 'class: anObject class := anObject').  self assert: (tmp2 classSide parseTreeFor: #recursiveSelfRule:) equals: (self parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').  self assert: (tmp2 classSide parseTreeFor: #recursiveSelfRule) equals: (self parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').  self assert: (tmp2 parseTreeFor: #builder) equals: (self parseMethod: 'builder ^builder').  self assert: (tmp2 parseTreeFor: #builder:) equals: (self parseMethod: 'builder: anObject builder := anObject').  self assert: (tmp2 parseTreeFor: #rewriteRule) equals: (self parseMethod: 'rewriteRule ^rewriteRule').  self assert: (tmp2 parseTreeFor: #rewriteRule:) equals: (self parseMethod: 'rewriteRule: anObject rewriteRule := anObject')-=JUAMPI=-return: arg1 inMethod: arg2 inClass: arg3  self className: arg3.  selector := arg2.  returnValue := arg1-=JUAMPI=-primitiveExecute  self changeClass organization removeProtocol: (self changeClass organization protocolNamed: protocol)-=JUAMPI=-initialize  super initialize.  modelFactory := RBClassModelFactory new.  changeFactory := RBRefactoryChangeManager changeFactory-=JUAMPI=-buildTransformations  ^transformations ifNil: [ transformations := OrderedCollection with: (RBAddMethodTransformation sourceCode: (String streamContents: [:arg1 |  arg1                             nextPutAll: 'new';                             nextPutAll: String cr;                             nextPutAll: String tab;                             nextPutAll: 'self deprecated: ''Use superclass '' on: ''4 May 2016'' in: #Pharo60.';                             nextPutAll: String cr;                             nextPutAll: String tab;                             nextPutAll: '^ super new' ]) in: (className , ' class') asSymbol withProtocol: 'deprecation') with: (RBAddMethodTransformation sourceCode: (String streamContents: [:arg1 |  arg1                             nextPutAll: 'deprecated';                             nextPutAll: String cr;                             nextPutAll: String tab;                             nextPutAll: '^ true' ]) in: (className , ' class') asSymbol withProtocol: 'deprecation') with: (RBAddMethodTransformation sourceCode: (String streamContents: [:arg1 |  arg1                             nextPutAll: 'systemIcon';                             nextPutAll: String cr;                             nextPutAll: String tab;                             nextPutAll: '^ Smalltalk ui icons iconNamed: #packageDelete' ]) in: (className , ' class') asSymbol withProtocol: 'deprecation') with: (RBAddClassCommentTransformation comment: 'Deprecated!!! Use superclass' in: className) ]-=JUAMPI=-renameReferences  | tmp1 tmp2 |  tmp1 := RBParseTreeRewriter rename: variableName to: newVariableName handler: [ self refactoringError: ('<1s> is already defined as a method					or block temporary <n> variable in this class or one of its subclasses' expandMacrosWith: newVariableName) ].  tmp2 := (self model classObjectFor: className) withAllSubclasses.  isClassVariable ifTrue: [ tmp2 addAll: self definingClass withAllSubclasses ].  self model convertClasses: tmp2 select: [:arg1 |  self referencesFor: arg1 ] using: tmp1-=JUAMPI=-renameSuperclassOfSubclasses  | tmp1 |  tmp1 := self model classNamed: newName.  self model reparentClasses: deprecatedClass subclasses to: tmp1-=JUAMPI=-environmentForInstanceVariable: arg1 in: arg2  | tmp1 tmp2 tmp3 |  tmp1 := RBSelectorEnvironment onEnvironment: self.  tmp1 addSearchString: arg1.  tmp2 := tmp3 := false.  ((instanceVariables at: arg2 name ifAbsent: [ #() ]) includes: arg1) ifTrue: [ tmp2 := true.        tmp3 := true ].  ((instanceVariableWriters at: arg2 name ifAbsent: [ #() ]) includes: arg1) ifTrue: [ tmp3 := true ].  ((instanceVariableReaders at: arg2 name ifAbsent: [ #() ]) includes: arg1) ifTrue: [ tmp2 := true ].  arg2 withAllSubAndSuperclassesDo: [:arg3 |  tmp3 ifTrue: [ (arg3 whichSelectorsStoreInto: arg1) do: [:arg4 |  tmp1 addClass: arg3 selector: arg4 ] ].        tmp2 ifTrue: [ (arg3 whichSelectorsRead: arg1) do: [:arg4 |  tmp1 addClass: arg3 selector: arg4 ] ] ].  ^tmp1-=JUAMPI=-executeNotifying: arg1  | tmp1 |  self addNewVariable.  self copyOldValuesToNewVariable.  tmp1 := super executeNotifying: arg1.  tmp1     oldName: newName;     newName: oldName.  self removeOldVariable.  ^tmp1-=JUAMPI=-removeClasses  classNames do: [:arg1 |  self model removeClassNamed: arg1 ]-=JUAMPI=-testMethodDoesNotExist  self shouldFail: (RBRemoveAssignmentTransformation variable: 'variable' value: '1 asString' inMethod: #method inClass: #RBRemoveAssignmentTransformationTest) asRefactoring-=JUAMPI=-testTransform  | tmp1 |  tmp1 := (RBAddProtocolTransformation new protocol: 'transforming' inClass: #RBDummyEmptyClass) transform.  self assert: tmp1 model changes changes size equals: 1-=JUAMPI=-left: arg1 right: arg2  left := arg1.  right := arg2.  failed := #unknownFailed-=JUAMPI=-booleanPrecedence  ^(true & 4) = 45-=JUAMPI=-endTrueFalse  self isVariable ifTrue: [ self printString.        self isVariable printString ] ifFalse: [ self printString.        ^4 ]-=JUAMPI=-getNewSelector  | tmp1 |  (class directlyDefinesMethod: oldSelector) ifFalse: [ self refactoringFailure: 'Method doesn''t exist' ].  tmp1 := class parseTreeFor: oldSelector.  tmp1 ifNil: [ self refactoringFailure: 'Cannot parse sources' ].  argument ifNil: [ self refactoringFailure: 'This method does not have an argument' ].  parameterIndex := tmp1 argumentNames indexOf: argument ifAbsent: [ self refactoringFailure: 'Select a parameter!!' ].  permutation := (1 to: oldSelector numArgs) copyWithout: parameterIndex.  newSelector := self computeNewSelector-=JUAMPI=-transform  | tmp1 tmp2 tmp3 |  self model allClassesDo: [:arg1 |  arg1 selectors do: [:arg2 |  tmp1 := arg1 sourceCodeFor: arg2.              tmp2 := self execute: tmp1.              tmp2 = tmp1 ifFalse: [ (self parseMethod: tmp2) ifNotNil: [ tmp3 := arg1 protocolsFor: arg2.                          (self parseSelector: tmp2) = arg2 ifFalse: [ arg1 removeMethod: arg2 ].                          arg1 compile: tmp2 classified: tmp3 ] ] ] ]-=JUAMPI=-assertCollection: arg1 equals: arg2  ^self assert: arg2 = arg1 description: [ self comparingCollectionBetween: arg1 and: arg2 ]-=JUAMPI=-asSelectorEnvironment  ^RBSelectorEnvironment new     searchStrings: #();     label: self label;     onEnvironment: self environment;     classSelectors: self classSelectorDictionary metaClassSelectors: self metaClassSelectorDictionary;     yourself-=JUAMPI=-testMetaClassFailure  self shouldFail: (RBRenameClassVariableRefactoring rename: #RecursiveSelfRule to: #Foo in: RBTransformationRuleTestData class)-=JUAMPI=-testNonExistantName  self shouldFail: (RBRenameInstanceVariableRefactoring rename: 'foo' to: 'newFoo' in: RBBasicLintRuleTestData)-=JUAMPI=-testAccessorsAlreadyExist  | tmp1 |  (RBProtectVariableTransformation model: model instanceVariable: 'instVarName1' class: #Foo) asRefactoring transform.  tmp1 := model classNamed: #Foo.  self assert: (tmp1 parseTreeFor: #bar) equals: (self parseMethod: 'bar			"Add one to instVarName1"			self instVarName11: self instVarName11 + 1').  self assert: (tmp1 parseTreeFor: #instVarName11:) equals: (self parseMethod: 'instVarName11: anObject			instVarName1 := anObject').  self assert: (tmp1 parseTreeFor: #instVarName11) equals: (self parseMethod: 'instVarName11 ^instVarName1').  self assert: ((model classNamed: #Bar) parseTreeFor: #foo) equals: (self parseMethod: 'foo			self instVarName11: self instVarName11 + instVarName2 + ClassVarName1')-=JUAMPI=-inlineMethod  | tmp1 |  tmp1 := self     foo;     inlineMethod;     bar.  ^tmp1-=JUAMPI=-caller  | tmp1 |  tmp1 := 5.  self called: tmp1 + 1 on: [ ^tmp1 ]-=JUAMPI=-testModelRemoveUnusedVariable  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  self assert: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  self executeRefactoring: (RBPushDownClassVariableRefactoring model: model variable: #Foo class: (model classNamed: #SomeClass)).  self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: #Foo).  self deny: ((model classNamed: #Subclass) directlyDefinesVariable: #Foo)-=JUAMPI=-testAddClassVariable  | tmp1 |  tmp1 := (RBAddVariableTransformation classVariable: 'Asdf' class: #RBTransformationRuleTestData) asRefactoring transform.  self assert: ((tmp1 model classNamed: #RBTransformationRuleTestData) directlyDefinesClassVariable: #Asdf)-=JUAMPI=-transform  | tmp1 |  class addInstanceVariable: variableName asString.  oldClass removeInstanceVariable: variableName asString.  tmp1 := self collectSendersOfInstVar.  tmp1 ifNotEmpty: [ Smalltalk tools messageList browse: (tmp1 collect: #method) title: 'Broken methods' autoSelect: tmp1 first selector ]-=JUAMPI=-storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' comment: ''';     nextPutAll: comment;     nextPutAll: ''' in: ''';     nextPutAll: className.  arg1 nextPut: $)-=JUAMPI=-comment: arg1  model comment: (comment := arg1) in: self-=JUAMPI=-postCopy  | tmp1 |  super postCopy.  tmp1 := classSelectors copy.  tmp1 keysAndValuesDo: [:arg1 :arg2 |  tmp1 at: arg1 put: arg2 copy ].  classSelectors := tmp1.  tmp1 := metaClassSelectors copy.  tmp1 keysAndValuesDo: [:arg1 :arg2 |  tmp1 at: arg1 put: arg2 copy ].  metaClassSelectors := tmp1-=JUAMPI=-includesCategory: arg1  ^true-=JUAMPI=-testAddClass  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := (RBAddClassTransformation addClass: #FooTest superclass: #RBTransformationTest subclasses: #(RBAddClassTransformationTest) category: #'Refactory-Testing') asRefactoring.  tmp1 transform.  tmp2 := tmp1 model classNamed: #FooTest.  tmp3 := tmp1 model classNamed: #RBTransformationTest.  tmp4 := tmp1 model classNamed: self class name.  self assert: tmp2 superclass equals: tmp3.  self assert: (tmp3 subclasses includes: tmp2).  self assert: tmp2 theMetaClass superclass equals: tmp3 theMetaClass.  self assert: (tmp3 theMetaClass subclasses includes: tmp2 theMetaClass).  self assert: tmp4 superclass equals: tmp2.  self assert: (tmp2 subclasses includes: tmp4).  self assert: tmp4 theMetaClass superclass equals: tmp2 theMetaClass.  self assert: (tmp2 theMetaClass subclasses includes: tmp4 theMetaClass)-=JUAMPI=-classNamesFor: arg1  | tmp1 tmp2 |  tmp1 := IdentitySet new     addAll: arg1 classNames asSet;     addAll: arg1 not classNames;     yourself.  tmp2 := universalEnvironment classNames asSortedCollection.  self assert: tmp1 asSortedCollection equals: tmp2.  self assertEmpty: (arg1 & arg1 not) classNames.  self assert: (arg1 | arg1 not) classNames asSortedCollection equals: tmp2-=JUAMPI=-initialize  super initialize.  delegatesPreconditions := true-=JUAMPI=-testInheritedName  self     shouldFail: (RBRemoveDirectAccessToVariableTransformation instanceVariable: 'name' class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBRemoveDirectAccessToVariableTransformation classVariable: #DependentsFields class: #RBBasicLintRuleTestData) asRefactoring-=JUAMPI=-comment: arg1 in: arg2  ^changes comment: arg1 in: arg2-=JUAMPI=-addMethodSource: arg1 in: arg2 for: arg3  ^RBAddMethodChange compile: arg1 in: arg2 for: arg3-=JUAMPI=-testInlineMethod5  | tmp1 |  tmp1 := RBInlineMethodRefactoring inline: (53 to: 64) inMethod: #inlineLast forClass: RBRefactoryTestDataApp.  self executeRefactoring: tmp1.  self assert: ((tmp1 model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineLast) equals: (self parseMethod: 'inlineLast									5 = 3 ifTrue: [^self caller] ifFalse: [^	(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)]]')-=JUAMPI=-asRefactoring  ^self     checksPreconditions;     yourself-=JUAMPI=-includesBehaviorNamed: arg1  | tmp1 |  tmp1 := self selectedClass.  [ tmp1 isNil ] whileFalse: [ tmp1 name = arg1 ifTrue: [ ^true ].        tmp1 := tmp1 superclass ].  ^false-=JUAMPI=-extractedParseTree  ^extractedParseTree-=JUAMPI=-allPoolDictionaryNames  | tmp1 |  tmp1 := self superclass.  ^tmp1 ifNil: [ self sharedPoolNames ] ifNotNil: [ tmp1 allPoolDictionaryNames , self sharedPoolNames ]-=JUAMPI=-removeClass: arg1 classVariable: arg2  | tmp1 |  tmp1 := classVariables at: arg1 name ifAbsent: [ Set new ].  tmp1 remove: arg2 ifAbsent: [  ].  tmp1 ifEmpty: [ classVariables removeKey: arg1 name ifAbsent: [  ] ].  self flushCachesFor: arg1-=JUAMPI=-isEmpty  ^environmentDictionaries isEmpty-=JUAMPI=-newContentMorph  ^labelGroup := (self newRow: {(self newLabelGroup: {('Selector:' -> (selectorField := (self newTextEntryFor: self getText: #selector setText: #selector: help: nil)                       autoAccept: true;                       on: #keyStroke send: #value:value: to: [:arg1 :arg2 |  arg1 keyCharacter = Character cr ifTrue: [ self ok.                                true ].                          false ];                       hResizing: #spaceFill;                       yourself)) .               ('Arguments:' -> (self newRow: {((self newColumn: {(self newButtonFor: self action: #add label: '+' help: nil) .                                 (self newButtonFor: self action: #remove label: '-' help: nil)}) hResizing: #shrinkWrap) .                           ((self newListFor: self list: #argumentList selected: #argumentIndex changeSelected: #argumentIndex: help: nil)                             hResizing: #spaceFill;                             yourself)})) .               ('Preview:' -> (labelMorph := self newLabel: self methodName printString))})})     minWidth: 400;     hResizing: #spaceFill;     yourself-=JUAMPI=-initialize  self computeLiterals-=JUAMPI=-testNotEnvironmentWithClassEnvironments  | tmp1 tmp2 |  tmp1 := RBBrowserEnvironment new forClasses: Number withAllSubclasses.  tmp2 := tmp1 not.  self universalTestFor: tmp2.  self deny: (tmp2 includesClass: Number).  self assertEmpty: (tmp2 & tmp1) classes.  self assert: (tmp2 not includesClass: Number)-=JUAMPI=-checkMethod: arg1  (self basicCheck: arg1) ifTrue: [ result addMethod: arg1 ]-=JUAMPI=-compile: arg1  ^self compile: arg1 withAttributesFrom: (self methodFor: (self parserClass parseMethodPattern: arg1))-=JUAMPI=-newSelector  ^newSelector-=JUAMPI=-preconditions  ^className inject: RBCondition empty into: [:arg1 :arg2 |  | tmp1 |        tmp1 := self model classNamed: className asSymbol.        tmp1 ifNil: [ self refactoringError: 'No such class or trait named ' , className ].        arg1 & ((self preconditionIsNotMetaclass: tmp1) & (self preconditionHasNoReferences: className) & (self preconditionHasNoSubclasses: tmp1) & (self preconditionHasNoUsers: tmp1)) ]-=JUAMPI=-testPerformAddRemoveClass  | tmp1 |  tmp1 := changes defineClass: 'Object subclass: #' , self changeMock name , 'Temporary	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	package: ''' , self class category , ''''.  self perform: tmp1 do: [ self assert: (workingEnvironment hasClassNamed: tmp1 changeClassName).        self assert: tmp1 definedClass name equals: tmp1 changeClassName.        self assert: tmp1 definedClass isBehavior ].  self deny: (workingEnvironment hasClassNamed: tmp1 changeClassName).  self assert: tmp1 definedClass isObsolete-=JUAMPI=-isComposite  ^true-=JUAMPI=-selectorsFor: arg1 in: arg2  ^(arg2 organization listAtCategoryNamed: arg1) select: [:arg3 |  self includesSelector: arg3 in: arg2 ]-=JUAMPI=-createReference  self performComponentRefactoring: (RBAddInstanceVariableRefactoring variable: referenceVariableName class: class)-=JUAMPI=-uncommonMessageSend2  | tmp1 |  tmp1 := 3 Object new.  ^tmp1-=JUAMPI=-hasConflicts  ^true-=JUAMPI=-methodAfter  | tmp1 |  tmp1 := 'String'.  tmp1 byteAt: 1-=JUAMPI=-testNonExistantName  self shouldFail: (RBRemoveInstanceVariableRefactoring variable: 'name1' class: RBLintRuleTestData)-=JUAMPI=-parameters: arg1  parameters := arg1-=JUAMPI=-fillOutDefinition: arg1  className := (arg1 at: '`traitName') asSymbol-=JUAMPI=-inline: arg1 from: arg2 in: arg3  class := self classObjectFor: arg3.  selector := arg2.  sourceInterval := arg1-=JUAMPI=-classForName: arg1  | tmp1 tmp2 tmp3 |  tmp2 := arg1 includes: $ .  tmp1 := (tmp2 ifTrue: [ arg1 copyFrom: 1 to: (arg1 size - 6 max: 1) ] ifFalse: [ arg1 ]) asSymbol.  tmp3 := self systemDictionary at: tmp1 ifAbsent: [ nil ].  ^(tmp3 notNil and: [ tmp2 ]) ifTrue: [ tmp3 class ] ifFalse: [ tmp3 ]-=JUAMPI=-rationale  ^'Checks for ifTrue:ifFalse: blocks that have the same code at the beginning or end.'-=JUAMPI=-setUp  super setUp.  model := self abstractVariableTestData-=JUAMPI=-addChangeToClass: arg1  ^changedClasses at: arg1 name put: (Array with: arg1 instanceSide with: arg1 classSide)-=JUAMPI=-toDoCollect  | tmp1 |  tmp1 := Array new: 10.  1 to: 10 do: [:arg1 |  tmp1 at: arg1 put: arg1 * arg1 ].  ^tmp1-=JUAMPI=-checkClass: arg1  ^classBlock value: arg1 value: result-=JUAMPI=-classVarRefsTo: arg1 in: arg2  ^RBVariableEnvironment on: self referencesToClassVariable: arg1 in: arg2-=JUAMPI=-newName  ^newName-=JUAMPI=-testMetaClassFailure  self shouldFail: (RBChildrenToSiblingsRefactoring name: #Foo class: RBLintRuleTestData class subclasses: (Array with: RBBasicLintRuleTestData class with: RBCompositeLintRuleTestData class))-=JUAMPI=-includesClass: arg1  (super includesClass: arg1) ifFalse: [ ^false ].  (instanceVariables includesKey: arg1 name) ifTrue: [ ^true ].  (classVariables includesKey: arg1 name) ifTrue: [ ^true ].  ^(self selectorCacheFor: arg1) anySatisfy: [:arg2 |  self includesSelector: arg2 in: arg1 ]-=JUAMPI=-denyEmpty: arg1  ^self assert: arg1 isNotEmpty description: arg1 asString , ' should not have been empty'-=JUAMPI=-checkSuperMessages  inlineParseTree superMessages isEmpty ifFalse: [ self refactoringError: 'Cannot inline method since it sends a super message' ]-=JUAMPI=-equalNotUsed  | tmp1 |  tmp1 = '' yourself.  (1 to: 10) do: [:arg1 |  tmp1 := arg1 printString ].  ^tmp1-=JUAMPI=-testMoveDefinition  | tmp1 tmp2 |  tmp1 := (RBMoveTemporaryVariableDefinitionTransformation variable: #temp inMethod: #moveDefinition inClass: #RBDummyRefactoryTestDataApp) transform.  tmp2 := tmp1 model classNamed: #RBDummyRefactoryTestDataApp.  self assert: (tmp2 parseTreeFor: #moveDefinition) equals: (self parseMethod: 'moveDefinition								^(self collect: 										[:each | 										| temp |										temp := each printString.										temp , temp]) 									select: 										[:each | 										| temp |										temp := each size.										temp odd]')-=JUAMPI=-shouldUseExistingMethod: arg1  ^(self options at: #useExistingMethod) value: self value: arg1-=JUAMPI=-remainingTemporaries  | tmp1 |  tmp1 := modifiedParseTree allDefinedVariables asSet.  extractedParseTree allDefinedVariables do: [:arg1 |  tmp1 remove: arg1 ifAbsent: [  ] ].  ^tmp1-=JUAMPI=-classSelectors: arg1 metaClassSelectors: arg2  classSelectors := arg1.  metaClassSelectors := arg2-=JUAMPI=-testTransform  | tmp1 tmp2 |  tmp1 := (RBRenameVariableTransformation rename: 'classBlock' to: 'asdf' in: #RBBasicLintRuleTestData classVariable: false) transform.  tmp2 := tmp1 model classNamed: #RBBasicLintRuleTestData.  self assert: (tmp2 directlyDefinesInstanceVariable: 'asdf').  self deny: (tmp2 directlyDefinesInstanceVariable: 'classBlock').  self assert: (tmp2 parseTreeFor: #checkClass:) equals: (self parseMethod: 'checkClass: aSmalllintContext 					^asdf value: aSmalllintContext value: result').  self assert: (tmp2 parseTreeFor: #initialize) equals: (self parseMethod: 'initialize					super initialize.					self anInstVar: 1.					asdf := [:context :aResult | ].					methodBlock := [:context :aResult | ].					self resultClass: RBSelectorEnvironment')-=JUAMPI=-preconditions  | tmp1 |  tmp1 := self calculateSubtree.  ^(RBCondition withBlock: [ tmp1 ifNil: [ self refactoringError: 'Cannot extract code.' ].        true ]) & (RBCondition withBlock: [ tmp1 parent isCascade ifTrue: [ self refactoringError: 'Cannot extract code in a cascaded message' ].              true ]) & (RBCondition withBlock: [ | tmp2 |              tmp2 := self calculateTemporaries.              (RBReadBeforeWrittenTester readBeforeWritten: tmp2 in: tmp1) ifNotEmpty: [ self refactoringError: 'Cannot extract temporaries if they are read before written.' ].              true ]) & (RBCondition withBlock: [ self calculateAssignments size > 1 ifTrue: [ self refactoringError: 'Cannot extract two or more assignments to temporaries without also extracting all the references.' ].              true ]) & (RBCondition withBlock: [ | tmp3 |              tmp3 := self calculateAssignments.              tmp3 ifNotEmpty: [ ((RBReadBeforeWrittenTester isVariable: tmp3 first readBeforeWrittenIn: tmp1) or: [ tmp1 containsReturn ]) ifTrue: [ self refactoringError: ('Cannot extract assignment to <1s> without also extracting all the references.' expandMacrosWith: assignments asString) ] ].              true ]) & (RBCondition withBlock: [ | tmp4 |              tmp4 := (self class allMethodsInHierarchyOf: self definingClass) reject: [:arg1 |  arg1 selector = selector ].              (RBParseTreeSearcher whichMethodIn: tmp4 matches: tmp1) ifNotEmpty: [:arg2 |  self refactoringError: ('<1s> method(s) already implement this code.<n>Do you want to send a message instead?' expandMacrosWith: arg2 size asString) with: [ (RBParseTreeRewriter replaceCode: tmp1 byMessageSendTo: arg2 anyOne in: (self definingClass methodFor: self calculateTree selector)) transform ].                    false ] ifEmpty: [ true ] ])-=JUAMPI=-includesSelector: arg1 in: arg2  ^(self includesClass: arg2) and: [ environment includesSelector: arg1 in: arg2 ]-=JUAMPI=-testRemovePool  | tmp1 |  tmp1 := changes removePool: 'PoolDict' from: self class.  self assert: tmp1 changeClassName equals: self class name.  self assert: tmp1 changeClass equals: self class.  self assert: tmp1 isMeta not.  self assert: tmp1 variable equals: 'PoolDict'.  self universalTestFor: tmp1-=JUAMPI=-returnInEnsure  [ self error: 'asdf' ] ensure: [ ^4 ]-=JUAMPI=-testRefactoring  | tmp1 tmp2 |  tmp1 := (RBAddAssignmentTransformation variable: 'variable' value: '1 asString' inMethod: #methodBefore inClass: #RBAddAssignmentTransformationTest) asRefactoring transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: #RBAddAssignmentTransformationTest.  self assert: (tmp2 directlyDefinesMethod: #methodBefore).  self assert: (tmp2 parseTreeFor: #methodBefore) body statements size equals: 2.  self assert: (tmp2 parseTreeFor: #methodBefore) body statements last value sourceCode equals: '1 asString'-=JUAMPI=-testModelAlreadyExistingName  | tmp1 |  tmp1 := RBAddClassVariableRefactoring model: model variable: #ClassVarName2 class: (model classNamed: #Bar).  self shouldFail: tmp1-=JUAMPI=-methodSourceFor: arg1  ^(self changeClass includesSelector: arg1) ifTrue: [ self changeClass sourceCodeAt: arg1 ]-=JUAMPI=-removeClassVariable: arg1  self privateClassVariableNames remove: arg1 asSymbol.  model removeClassVariable: arg1 from: self-=JUAMPI=-checkIsSubclass: arg1  arg1 ~= class ifTrue: [ (class subclasses includes: arg1) ifFalse: [ self refactoringError: ('<1p> is not subclass of <2s>' expandMacrosWith: arg1 name with: class name) ] ]-=JUAMPI=-removeDuplicateMethods  selectors do: [:arg1 |  self removeDuplicatesOf: arg1 ]-=JUAMPI=-booleanPrecedence  ^(true & 4) = 45-=JUAMPI=-rules  ^rules-=JUAMPI=-leaves  ^{self}-=JUAMPI=-check: arg1 forCritiquesDo: arg2  (self basicCheck: arg1) ifTrue: [ arg2 cull: (self critiqueFor: arg1) ]-=JUAMPI=-includesProtocol: arg1 in: arg2  ^(arg2 organization protocolOrganizer getProtocolNamed: arg1 ifNone: [ ^false ]) methods anySatisfy: [:arg3 |  self includesSelector: arg3 in: arg2 ]-=JUAMPI=-testNonExistantName  self     shouldFail: (RBRemoveVariableTransformation instanceVariable: 'name1' class: #RBDummyLintRuleTest) asRefactoring;     shouldFail: (RBRemoveVariableTransformation classVariable: #RecursiveSelfRule1 class: #RBTransformationDummyRuleTest) asRefactoring-=JUAMPI=-addClass: arg1 instanceVariableWriter: arg2  (instanceVariableWriters at: arg1 name ifAbsentPut: [ Set new ]) add: arg2.  self flushCachesFor: arg1.  self addSearchString: arg2-=JUAMPI=-delete: arg1 in: arg2  (arg2 realClass includesSelector: arg1) ifTrue: [ [ self performComponentRefactoring: (RBRemoveMethodRefactoring model: self model removeMethods: {arg1} from: arg2) ] on: RBRefactoringError do: [:arg3 |  (self confirm: (arg3 messageText copyReplaceAll: 'Browse references?' with: 'Remove anyway?')) ifTrue: [ arg3 resume ] ] ]-=JUAMPI=-shouldFail: arg1  self proceedThroughWarning: [ self should: [ arg1 transform ] raise: RBRefactoringError ]-=JUAMPI=-testModelAddClass  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := model classNamed: #Bar.  tmp3 := model classNamed: #Foo.  tmp1 := (RBAddClassTransformation model: model addClass: #FooTest superclass: #Foo subclasses: #(Bar) category: #'Refactory-Testing') asRefactoring.  tmp1 transform.  tmp2 := model classNamed: #FooTest.  self assert: tmp2 superclass equals: tmp3.  self assert: (tmp3 subclasses includes: tmp2).  self assert: tmp2 theMetaClass superclass equals: tmp3 theMetaClass.  self assert: (tmp3 theMetaClass subclasses includes: tmp2 theMetaClass).  self assert: tmp4 superclass equals: tmp2.  self assert: (tmp2 subclasses includes: tmp4).  self assert: tmp4 theMetaClass superclass equals: tmp2 theMetaClass.  self assert: (tmp2 theMetaClass subclasses includes: tmp4 theMetaClass)-=JUAMPI=-testTransform  | tmp1 tmp2 |  tmp1 := (RBDeprecateClassTransformation class: self changeMock name) transform.  self assert: tmp1 model changes changes size equals: 4.  tmp2 := tmp1 model classNamed: self changeMock name asSymbol.  self assert: tmp2 comment equals: 'Deprecated!!! Use superclass'.  tmp2 := tmp1 model metaclassNamed: self changeMock name.  self assert: (tmp2 parseTreeFor: #new) equals: (self parseMethod: 'new				self deprecated: ''Use superclass '' on: ''4 May 2016''  in: #Pharo60.				^ super new').  self assert: (tmp2 parseTreeFor: #deprecated) equals: (self parseMethod: 'deprecated ^ true').  self assert: (tmp2 parseTreeFor: #systemIcon) equals: (self parseMethod: 'systemIcon				^ Smalltalk ui icons iconNamed: #packageDelete')-=JUAMPI=-testModelAlreadyExistingName  self     shouldFail: (RBAddVariableTransformation model: model instanceVariable: 'instVarName1' class: (model classNamed: #Bar)) asRefactoring;     shouldFail: (RBAddVariableTransformation model: model classVariable: #ClassVarName2 class: (model classNamed: #Bar)) asRefactoring-=JUAMPI=-neitherFailed  ^(left errorStringFor: true) , ' AND ' , (right errorStringFor: true)-=JUAMPI=-convertAllReferencesToClass: arg1 using: arg2  self model allReferencesToClass: arg1 do: [:arg3 |  self convertMethod: arg3 selector for: arg3 modelClass using: arg2 ]-=JUAMPI=-testSystemIntegrity  | tmp1 tmp2 |  tmp1 := IdentitySet new.  tmp2 := RBBrowserEnvironment new.  tmp2 allClassesDo: [:arg1 |  (tmp1 includes: arg1) ifFalse: [ tmp1 add: arg1 ] ifTrue: [ self error: 'The class ' , arg1 name , ' that is available under two or more names. This causes problems with the refactoring browser.' ] ]-=JUAMPI=-rootClasses  ^rootClasses ifNil: [ rootClasses := self privateRootClasses ]-=JUAMPI=-checkClassVars  selectors do: [:arg1 |  self checkClassVarsFor: arg1 ]-=JUAMPI=-testInheritedName  self shouldFail: (RBAbstractInstanceVariableRefactoring variable: 'name' class: RBBasicLintRuleTestData)-=JUAMPI=-condition: arg1  condition := arg1.  self errorMacro: condition errorMacro-=JUAMPI=-renameClass: arg1 to: arg2  ^RBRenameClassChange rename: arg1 name to: arg2-=JUAMPI=-extractMethod  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp3 := self getExtractedSource.  extractedParseTree := self parserClass parseExpression: tmp3 onError: [:arg1 :arg2 :arg3 |  tmp6 := arg1.        arg3 parseErrorNode: arg1 ].  extractedParseTree ifNil: [ self refactoringFailure: 'Invalid source to extract' ].  extractedParseTree isFaulty ifTrue: [ self refactoringFailure: 'Invalid source to extract - ' , tmp6 ].  (extractedParseTree isSequence and: [ extractedParseTree statements isEmpty ]) ifTrue: [ self refactoringError: 'Select some code to extract' ].  tmp2 := extractedParseTree isSequence or: [ extractedParseTree isReturn ].  extractedParseTree := RBMethodNode selector: #value arguments: #() body: (extractedParseTree isSequence ifTrue: [ extractedParseTree ] ifFalse: [ RBSequenceNode temporaries: #() statements: (OrderedCollection with: extractedParseTree) ]).  extractedParseTree body temporaries ifNotEmpty: [ extractedParseTree body temporaries: #() ].  extractedParseTree source: tmp3.  tmp1 := class parseTreeFor: selector.  tmp1 ifNil: [ self refactoringFailure: 'Could not parse ' , selector printString ].  tmp4 := tmp2 ifTrue: [ self parseTreeSearcherClass treeMatchingStatements: extractedParseTree body formattedCode in: tmp1 ] ifFalse: [ self parseTreeSearcherClass treeMatching: tmp3 in: tmp1 ].  tmp4 ifNil: [ self refactoringFailure: 'Could not extract code from method' ].  tmp5 := self methodDelimiter.  tmp2 ifTrue: [ | tmp7 |        tmp7 := extractedParseTree body statements.        tmp7 ifNotEmpty: [ tmp7 last isAssignment ifTrue: [ | tmp8 |                    tmp8 := tmp7 last variable name.                    (self shouldExtractAssignmentTo: tmp8) ifFalse: [ tmp5 := '<1s> := <2s>' expandMacrosWith: tmp8 with: tmp5.                          tmp7 at: tmp7 size put: tmp7 last value ] ] ] ].  modifiedParseTree := tmp2 ifTrue: [ RBParseTreeRewriter replaceStatements: tmp4 formattedCode with: tmp5 in: tmp1 onInterval: extractionInterval ] ifFalse: [ RBParseTreeRewriter replace: tmp4 formattedCode with: tmp5 in: tmp1 onInterval: extractionInterval ]-=JUAMPI=-storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' bindTight: '.  interval storeOn: arg1.  arg1 nextPutAll: ' in: '.  class storeOn: arg1.  arg1     nextPutAll: ' selector: #';     nextPutAll: selector.  arg1 nextPut: $)-=JUAMPI=-receiver: arg1  receiver := arg1-=JUAMPI=-isMeta  ^true-=JUAMPI=-existingMethodsThatReferToInstanceVariable: arg1  | tmp1 |  tmp1 := self realClass whichSelectorsAccess: arg1.  (newMethods isNil and: [ removedMethods isNil ]) ifTrue: [ ^tmp1 ].  ^tmp1 reject: [:arg2 |  (self hasRemoved: arg2) or: [ self newMethods includesKey: arg2 ] ]-=JUAMPI=-postCopy  super postCopy.  protocols := protocols copy-=JUAMPI=-testBasicLintRuleTypes  | tmp1 tmp2 |  tmp1 := RBRefactoryTyper new.  tmp2 := tmp1 guessTypesFor: 'classBlock' in: RBBasicLintRuleTestData.  self assert: ([  ] class withAllSuperclasses detect: [:arg1 |  tmp2 includes: (tmp1 model classFor: arg1) ] ifNone: [ nil ]) notNil.  tmp2 := tmp1 typesFor: 'methodBlock' in: (tmp1 model classFor: RBBasicLintRuleTestData).  self assert: ([  ] class withAllSuperclasses detect: [:arg1 |  tmp2 includes: (tmp1 model classFor: arg1) ] ifNone: [ nil ]) notNil.  tmp1 printString-=JUAMPI=-storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' variable: ''';     nextPutAll: variableName;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: arg1.  arg1 nextPut: $)-=JUAMPI=-options: arg1  options := arg1-=JUAMPI=-transform: arg1  | tmp1 tmp2 tmp3 |  arg1 allSelectors do: [:arg2 |  tmp1 := arg1 whoDefinesMethod: arg2.        (tmp1 notNil and: [ tmp1 ~= arg1 ]) ifTrue: [ tmp2 := tmp1 methodFor: arg2.              (tmp2 notNil and: [ tmp2 refersToSymbol: #subclassResponsibility ]) ifTrue: [ tmp3 := tmp2 parseTree.                    tmp3 body                       temporaries: OrderedCollection new;                       statements: OrderedCollection new;                       addNode: (RBMessageNode receiver: (RBVariableNode named: 'self') selector: #shouldBeImplemented).                    arg1 compile: tmp3 newSource withAttributesFrom: tmp2 ] ] ]-=JUAMPI=-uniqueClassesIn: arg1  | tmp1 |  tmp1 := IdentitySet new.  arg1 classesDo: [:arg2 |  self deny: (tmp1 includes: arg2).        tmp1 add: arg2 ]-=JUAMPI=-pushUpMethodsFrom: arg1  | tmp1 |  tmp1 := self selectorsToPushUpFrom: arg1.  arg1 selectors do: [:arg2 |  (tmp1 includes: arg2) ifTrue: [ self pushUp: arg2 in: arg1 ] ifFalse: [ self createSubclassResponsibilityFor: arg2 in: arg1 ] ].  tmp1 do: [:arg2 |  arg1 removeMethod: arg2 ]-=JUAMPI=-testTransform  | tmp1 tmp2 |  tmp1 := (RBRemoveAssignmentTransformation new variable: 'variable' value: '1 asString' inMethod: #methodBefore inClass: self class name) transform.  self assert: tmp1 model changes changes size equals: 1.  tmp2 := tmp1 model classNamed: self class name.  self assert: (tmp2 parseTreeFor: #methodBefore) body equals: (tmp2 parseTreeFor: #methodAfter) body-=JUAMPI=-checkMethod: arg1  rules do: [:arg2 |  arg2 checkMethod: arg1.        Processor yield ]-=JUAMPI=-preconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition withBlock: [ | tmp1 |              interval first <= interval last ifFalse: [ self refactoringFailure: 'You must select a variable name' ].              tmp1 := class sourceCodeFor: selector.              tmp1 size >= interval last ifFalse: [ self refactoringFailure: 'Invalid range for variable' ].              name := tmp1 copyFrom: interval first to: interval last.              (self checkInstanceVariableName: name in: class) ifFalse: [ self refactoringFailure: name , ' does not seem to be a valid variable name.' ].              parseTree := class parseTreeFor: selector.              self checkParseTree.              true ])-=JUAMPI=-executeRefactoring: arg1  arg1 primitiveExecute.  self parserClass parseExpression: arg1 storeString-=JUAMPI=-checkSuperMessages  self inlineClass = class ifTrue: [ ^self ].  self inlineClass superclass ifNil: [ ^self ].  inlineParseTree superMessages do: [:arg1 |  (self inlineClass superclass whoDefinesMethod: arg1) = (class superclass whoDefinesMethod: arg1) ifFalse: [ self refactoringError: ('Cannot inline method since it sends a super message <1s> that is overriden' expandMacrosWith: arg1) ] ]-=JUAMPI=-buildTransformations  self subclassResponsibility-=JUAMPI=-testRefactoring  | tmp1 |  tmp1 := (RBRemoveClassTransformation className: #RBFooDummyLintRuleTest1) asRefactoring.  [ tmp1 transform ] on: RBRefactoringError do: [:arg1 |  self resumeIfCannotRemove: arg1 ].  self assert: (tmp1 model classNamed: #RBFooDummyLintRuleTest1) isNil.  self assert: (tmp1 model classNamed: 'RBTransformationDummyRuleTest1' asSymbol) superclass equals: (tmp1 model classNamed: #RBDummyLintRuleTest)-=JUAMPI=-hasConflicts  ^rules anySatisfy: [:arg1 |  arg1 hasConflicts ]-=JUAMPI=-forPackageNames: arg1  ^RBPackageEnvironment onEnvironment: self packageNames: arg1-=JUAMPI=-testMetaclassFailure  self shouldFail: (RBPullUpVariableTransformation classVariable: #RecursiveSelfRule class: RBDummyLintRuleTest class) asRefactoring-=JUAMPI=-testNonExistantName  self     shouldFail: (RBCreateAccessorsForVariableRefactoring variable: #Foo class: RBBasicLintRuleTestData classVariable: true);     shouldFail: (RBCreateAccessorsForVariableRefactoring variable: 'foo' class: RBBasicLintRuleTestData classVariable: true)-=JUAMPI=-removeClassVariable: arg1 from: arg2  ^RBRemoveClassVariableChange remove: arg1 from: arg2-=JUAMPI=-storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' class: '.  class storeOn: arg1.  arg1 nextPutAll: ' instanceVariables: '.  instanceVariables asArray storeOn: arg1.  arg1     nextPutAll: ' newClassName: #';     nextPutAll: newClassName;     nextPutAll: ' referenceVariableName: ''';     nextPutAll: referenceVariableName;     nextPutAll: ''')'-=JUAMPI=-setupSelfArgumentNameFor: arg1 toReturn: arg2  | tmp1 |  tmp1 := arg1 options copy.  tmp1 at: #selfArgumentName put: [:arg3 |  arg2 ].  arg1 options: tmp1-=JUAMPI=-findSequenceNode  sequenceNode := self parserClass parseExpression: self selectedSource onError: [:arg1 :arg2 |  self refactoringFailure: 'Invalid source to rewrite' ].  (sequenceNode isSequence and: [ sequenceNode statements size > 1 ]) ifFalse: [ self refactoringFailure: 'You must select two or more statements' ]-=JUAMPI=-protocol: arg1 inClass: arg2  self className: arg2.  protocol := arg1-=JUAMPI=-refineTypesByLookingAtAssignments  | tmp1 tmp2 |  tmp2 := false.  tmp1 := self parseTreeSearcher.  variableTypes keysAndValuesDo: [:arg1 :arg2 |  arg1 first = $- ifFalse: [ tmp2 := true.              tmp1 matches: arg1 , ' := ``@object' do: [:arg3 :arg4 |  self guessTypeFromAssignment: arg3 ] ] ].  tmp2 ifTrue: [ self executeSearch: tmp1 ]-=JUAMPI=-testExtractMethodThatNeedsTemporaryVariable  | tmp1 tmp2 |  tmp1 := RBExtractMethodRefactoring extract: (78 to: 197) from: #displayName in: RBLintRuleTestData.  self setupMethodNameFor: tmp1 toReturn: #foo:.  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBLintRuleTestData.  self assert: (tmp2 parseTreeFor: #displayName) equals: (self parseMethod: 'displayName	| nameStream |	nameStream := WriteStream on: (String new: 64).	self foo: nameStream.	^nameStream contents').  self assert: (tmp2 parseTreeFor: #foo:) equals: (self parseMethod: 'foo: nameStream 	nameStream nextPutAll: self name;		nextPutAll: '' (''.	self problemCount printOn: nameStream.	nameStream nextPut: $).')-=JUAMPI=-classNames  ^IdentitySet new     addAll: classSelectors keys;     addAll: metaClassSelectors keys;     yourself-=JUAMPI=-inlineParameter: arg1 in: arg2 selector: arg3  oldSelector := arg3.  class := self classObjectFor: arg2.  argument := arg1-=JUAMPI=-checkMethod: arg1  -=JUAMPI=-addClassVariable: arg1 to: arg2  ^changes addClassVariable: arg1 to: arg2-=JUAMPI=-isParseTreeEquivalentTo: arg1  | tmp1 tmp2 |  tmp2 := class whoDefinesMethod: arg1.  tmp1 := tmp2 parseTreeFor: arg1.  tmp1 ifNil: [ ^false ].  tmp1 isPrimitive ifTrue: [ ^false ].  (tmp1 body equalTo: extractedParseTree body exceptForVariables: (tmp1 arguments collect: [:arg2 |  arg2 name ])) ifFalse: [ ^false ].  (tmp2 = class or: [ (tmp1 superMessages anySatisfy: [:arg2 |  (class superclass whichClassIncludesSelector: arg1) ~= (tmp2 superclass whichClassIncludesSelector: arg2) ]) not ]) ifFalse: [ ^false ].  ^self shouldUseExistingMethod: arg1-=JUAMPI=-newResultClass: arg1  result := arg1 new-=JUAMPI=-problemCount  ^self numberSelectors-=JUAMPI=-initialize  super initialize.  keywords := IdentitySet new.  condition := [:arg1 |  true ]-=JUAMPI=-removeArgument  | tmp1 |  tmp1 := parseTree argumentNames indexOf: variable.  tmp1 = 0 ifFalse: [ parseTree selector: ('' join: (parseTree selector keywords asOrderedCollection                       removeAt: tmp1;                       yourself)) asSymbol keywordsPositions: (parseTree keywordsPositions asOrderedCollection                 removeAt: tmp1;                 yourself) asIntegerArray arguments: (parseTree arguments asOrderedCollection                 removeAt: tmp1;                 yourself) asArray ]-=JUAMPI=-initialize  super initialize.  comment := LookupComment-=JUAMPI=-abstractSuperclass  ^self model classNamed: className asSymbol-=JUAMPI=-testModelRemoveInstanceVariable  | tmp1 |  model defineClass: 'nil subclass: #Object		instanceVariableNames: ''foo1''		classVariableNames: ''''		poolDictionaries: ''''		category: #''Refactory-Test data'''.  tmp1 := model classNamed: #Object.  self assert: (tmp1 definesInstanceVariable: 'foo1').  (RBRemoveVariableTransformation model: model instanceVariable: 'foo1' class: tmp1) asRefactoring transform.  self deny: (tmp1 definesInstanceVariable: 'foo1')-=JUAMPI=-definitionClass  ^Trait-=JUAMPI=-matchNodes  ^matchNodes ifNil: [ | tmp1 tmp2 tmp3 |        tmp1 := RBMatchVisitor new.        tmp2 := method sourceNode copy.        tmp2 acceptVisitor: tmp1.        tmp3 := self replaceArgumentsByPattern: tmp2 newSource.        tmp3 := tmp3 copyFrom: method sourceNode body statements first start + tmp1 difference to: tmp3 size.        matchNodes := OrderedCollection new.        matchNodes add: (RBPatternParser parseExpression: tmp3).        tmp2 lastIsReturn ifTrue: [ tmp2 hasMultipleReturns ifFalse: [ tmp3 := tmp3 copyReplaceAll: '^' with: ''.                    matchNodes add: (RBPatternParser parseExpression: tmp3) ] ].        matchNodes ]-=JUAMPI=-testVariableDoesNotExist  self     shouldFail: (RBRenameVariableTransformation rename: 'foo' to: 'newFoo' in: #RBBasicLintRuleTestData classVariable: false) asRefactoring;     shouldFail: (RBRenameVariableTransformation rename: #foo to: #newFoo in: #RBBasicLintRuleTestData classVariable: true) asRefactoring-=JUAMPI=-isSelectorEnvironment  ^false-=JUAMPI=-testEmptyCode  self shouldFail: (RBReplaceSubtreeTransformation replace: '' to: '^ selector' inMethod: #selector:from: inClass: #RBRemoveMethodTransformation) asRefactoring-=JUAMPI=-testRenamePermuteArgs  | tmp1 tmp2 |  tmp1 := RBRenameMethodRefactoring renameMethod: ('rename:' , 'two:') asSymbol in: RBRefactoryTestDataApp to: ('rename:' , 'two:') asSymbol permutation: #(2 1).  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBRefactoryTestDataApp.  self assert: (tmp2 parseTreeFor: ('rename:' , 'two:') asSymbol) equals: (self parseMethod: 'rename: argumentMethod two: this ^self printString, this, argumentMethod').  self assert: (tmp2 parseTreeFor: #exampleCall) equals: (self parseMethod: 'exampleCall <sampleInstance> ^self rename: 2 two: 1')-=JUAMPI=-initialize  super initialize.  self resetResult-=JUAMPI=-refactoringFailure: arg1  ^RBRefactoringFailure signal: arg1-=JUAMPI=-classBlock  ^self anInstVar + 5-=JUAMPI=-renameSelfReferences  self addSelfReferenceToSourceMessage.  self addSelfReferenceToInlineParseTree-=JUAMPI=-cruft  < haltOrBreakpointForTesting>  self halt-=JUAMPI=-setUp  super setUp.  model := Smalltalk compiler evaluate: self childrenToSiblingTestData-=JUAMPI=-refactoringError: arg1 with: arg2  ^RBRefactoringError signal: arg1 with: arg2-=JUAMPI=-callFoo  ^self testFoo: 5-=JUAMPI=-transform  self transform: self theClass.  self transform: self theClass classSide-=JUAMPI=-preconditionHasNoReferences: arg1  | tmp1 |  tmp1 := self environmentWithReferencesTo: arg1.  ^(RBCondition withBlock: [ tmp1 isEmpty ])     errorMacro: arg1 , ' is referenced.<n>Browse references?';     errorBlock: [ self openBrowserOn: tmp1 ];     yourself-=JUAMPI=-includesSelector: arg1 in: arg2  (environment includesSelector: arg1 in: arg2) ifFalse: [ ^false ].  ^(arg2 compiledMethodAt: arg1) pragmas anySatisfy: [:arg3 |  self includesPragma: arg3 ]-=JUAMPI=-literalArrayWithTrueFalseOrNil2  | tmp1 tmp2 |  tmp1 := #(#true #false #nil).  tmp2 := #(#true #(#true #false #nil) #false #nil).  ^tmp1-=JUAMPI=-transform  self renameMessageSends-=JUAMPI=-testTransform  | tmp1 tmp2 |  tmp1 := (RBAddVariableAccessorTransformation instanceVariable: 'instVar' class: self changeMock name) transform.  self assert: tmp1 model changes changes size equals: 2.  tmp2 := tmp1 model classNamed: self changeMock name asSymbol.  self assert: (tmp2 parseTreeFor: #instVar) equals: (self parseMethod: 'instVar ^instVar').  self assert: (tmp2 parseTreeFor: #instVar:) equals: (self parseMethod: 'instVar: anObject instVar := anObject')-=JUAMPI=-hash  ^self changeClassName hash bitXor: self variable hash-=JUAMPI=-renameReferences  | tmp1 |  tmp1 := RBParseTreeRewriter rename: variableName to: newName handler: [ self refactoringError: ('<1s> is already defined as a method or block temporary <n> variable in this class or one of its subclasses' expandMacrosWith: newName) ].  self convertClasses: class withAllSubclasses select: [:arg1 |  arg1 whichSelectorsReferToInstanceVariable: variableName ] using: tmp1-=JUAMPI=-result  ^result-=JUAMPI=-selectors: arg1  selectors := arg1-=JUAMPI=-classNameFor: arg1  ^arg1 instanceSide name-=JUAMPI=-buildTransformations  ^OrderedCollection new     addAll: (self variableDefinitionsInHierarchy collect: [:arg1 |  RBRemoveVariableTransformation model: self model variable: variableName class: arg1 classVariable: isClassVariable ]);     add: (RBAddVariableTransformation model: self model variable: variableName class: className classVariable: isClassVariable);     yourself-=JUAMPI=-returnsIfTrue  ^self isNil ifTrue: [ 4 ]-=JUAMPI=-environmentWithUsersOf: arg1  ^RBClassEnvironment onEnvironment: RBBrowserEnvironment new classes: arg1 realClass users-=JUAMPI=-equivalentSuperclassMethods  ^self identityHash-=JUAMPI=-= arg1  self class = arg1 class ifFalse: [ ^false ].  changes size = arg1 changes size ifFalse: [ ^false ].  changes with: arg1 changes do: [:arg2 :arg3 |  arg2 = arg3 ifFalse: [ ^false ] ].  ^true-=JUAMPI=-sharedPoolNames  ^self privatePoolDictionaryNames copy-=JUAMPI=-whichCategoryIncludes: arg1  ^self systemDictionary organization categoryOfElement: arg1-=JUAMPI=-changeString  ^'Add Protocol named ' , self displayProtocolName , ' in ' , self displayClassName-=JUAMPI=-changeSymbol  ^#addSharedPool:-=JUAMPI=-isSharedPool  ^(self allSuperclasses collect: #name) includes: #SharedPool-=JUAMPI=-shouldPushUp: arg1 from: arg2  ^(arg2 isMeta ifTrue: [ subclasses collect: [:arg3 |  arg3 classSide ] ] ifFalse: [ subclasses ]) anySatisfy: [:arg3 |  (arg3 directlyDefinesMethod: arg1) not ]-=JUAMPI=-definesClass: arg1  ^self includesClass: arg1-=JUAMPI=-createReference  transformations add: (RBAddVariableTransformation model: self model instanceVariable: referenceVariableName class: class)-=JUAMPI=-addClassAndMetaClassFor: arg1  self     addClass: arg1 classSide;     addClass: arg1 instanceSide-=JUAMPI=-storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1 nextPutAll: ' removeMethods: '.  selectors asArray storeOn: arg1.  arg1 nextPutAll: ' from: '.  class storeOn: arg1.  arg1 nextPut: $)-=JUAMPI=-getClassesForTemporaryVariable  | tmp1 |  tmp1 := RBRefactoryTyper typesFor: variable in: parseTree model: self model.  tmp1 ifEmpty: [ tmp1 := OrderedCollection with: (self model classNamed: #Object) ].  moveToClasses := self selectVariableTypesFrom: tmp1 selected: tmp1.  moveToClasses ifNil: [ self refactoringFailure: 'Method not moved' ]-=JUAMPI=-parserClass  ^RBParser-=JUAMPI=-hierarchyDefinesVariable: arg1  (self definesVariable: arg1) ifTrue: [ ^true ].  ^self allSubclasses anySatisfy: [:arg2 |  arg2 directlyDefinesVariable: arg1 ]-=JUAMPI=-printOn: arg1  super printOn: arg1.  self name ifNotNil: [ arg1           nextPutAll: ' name: ';           print: self name ]-=JUAMPI=-preconditions  | tmp1 |  tmp1 := ((RBCondition isMetaclass: (self model classObjectFor: superclass)) errorMacro: 'Superclass must not be a metaclass') not.  tmp1 := subclasses inject: tmp1 into: [:arg1 :arg2 |  arg1 & ((RBCondition isMetaclass: (self model classObjectFor: arg2)) errorMacro: 'Subclass must <1?not :>be a metaclass') not & (RBCondition isImmediateSubclass: (self model classObjectFor: arg2) of: (self model classObjectFor: superclass)) ].  ^tmp1 & (RBCondition isValidClassName: className) & (RBCondition isGlobal: className in: self model) not & (RBCondition isSymbol: category) & ((RBCondition withBlock: [ category isEmpty not ]) errorMacro: 'Invalid category name')-=JUAMPI=-model  ^model ifNil: [ model := (RBClassModelFactory rbNamespace onEnvironment: self defaultEnvironment)           name: self printString;           yourself ] ifNotNil: [ model ]-=JUAMPI=-allSuperclassesUntil: arg1  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  tmp2 := self superclass.  [ tmp2 notNil and: [ tmp2 name ~= arg1 name ] ] whileTrue: [ tmp1 add: tmp2.        tmp2 := tmp2 superclass ].  ^tmp1-=JUAMPI=-protocol: arg1  protocol := arg1-=JUAMPI=-someDemoMethod  ^self junk-=JUAMPI=-directlyDefinesClassVariable: arg1  ^self theNonMetaClass directlyDefinesClassVariable: arg1-=JUAMPI=-privateTransform  self model     defineClass: ('<1p> subclass: #<2s> instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: <3p>' expandMacrosWith: (self model classObjectFor: superclass) with: className with: category asString);     reparentClasses: (subclasses collect: [:arg1 |  self model classObjectFor: arg1 ]) to: (self model classNamed: className asSymbol)-=JUAMPI=-testExtractMethodThatNeedsArgument  | tmp1 tmp2 |  tmp1 := RBExtractMethodRefactoring extract: (145 to: 343) from: #checkMethod: in: RBTransformationRuleTestData.  self setupMethodNameFor: tmp1 toReturn: #foo:.  self executeRefactoring: tmp1.  tmp2 := tmp1 model classNamed: #RBTransformationRuleTestData.  self assert: (tmp2 parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 	class := aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[self foo: aSmalllintContext]').  self assert: (tmp2 parseTreeFor: #foo:) equals: (self parseMethod: 'foo: aSmalllintContext (RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)				ifFalse: 					[builder compile: rewriteRule tree printString						in: class						classified: aSmalllintContext protocols]')-=JUAMPI=-rename: arg1 two: arg2  ^self printString , arg1 , arg2-=JUAMPI=-methodAfter  < gtInspectorPresentationOrder: 56>  | tmp1 |  tmp1 := 'String'-=JUAMPI=-selectionIntervalFor: arg1  | tmp1 tmp2 |  matcher ifNil: [ ^super selectionIntervalFor: arg1 ].  tmp1 := RBParser parseMethod: arg1 onError: [:arg2 :arg3 |  ^super selectionIntervalFor: arg1 ].  tmp2 := matcher executeTree: tmp1 initialAnswer: nil.  ^(tmp2 isKindOf: RBProgramNode) ifTrue: [ tmp2 sourceInterval ] ifFalse: [ super selectionIntervalFor: arg1 ]-=JUAMPI=-variableAssignedLiteral  temporaryVariable := #()-=JUAMPI=-multiplePeriodsTerminatingAssignmentStatement  | tmp1 |  tmp1 := OrderedCollection.  tmp1     add: 'one';     add: 'two'.  ^tmp1-=JUAMPI=-executeNotifying: arg1  | tmp1 |  tmp1 := self asUndoOperation.  tmp1 name: self name.  self primitiveExecute.  arg1 value.  ^tmp1-=JUAMPI=-testRemoveClassWithReferences  self shouldFail: (RBRemoveClassTransformation className: #RBBasicLintRuleTestData) asRefactoring-=JUAMPI=-reparentSubclasses  self model reparentClasses: self definingClass subclasses copy to: self definingClass superclass-=JUAMPI=-equalsTrue  ^true == self-=JUAMPI=-notifyUserOfCommand: arg1  | tmp1 tmp2 |  tmp2 := self actionBlock ifNotNil: [ 'Warning' ] ifNil: [ 'Warning. Want to proceed?' ].  tmp1 := UIManager default confirm: self messageText label: tmp2.  tmp1 ifTrue: [ self actionBlock ifNil: [ self resume: true ] ifNotNil: #value ]-=JUAMPI=-testModelInvalidSubclass  self shouldFail: (RBAddClassTransformation model: model addClass: #Foo2 superclass: #Object subclasses: (Array with: (model classNamed: #Bar)) category: #'Refactory-Tesing') asRefactoring-=JUAMPI=-calculateTree  ^parseTree ifNil: [ parseTree := self definingMethod ]-=JUAMPI=-isEmpty  ^self builder changes isEmpty-=JUAMPI=-propagateTransformation  self renameReferences-=JUAMPI=-shouldCopyExtensions: arg1  shouldCopyExtensions := arg1-=JUAMPI=-testMethodDoesNotExist  self shouldFail: (RBMethodProtocolTransformation protocol: 'empty protocol 2' inMethod: #method inClass: #RBDummyEmptyClass) asRefactoring-=JUAMPI=-methods  | tmp1 |  tmp1 := IdentitySet new: 4096.  self methodsDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1-=JUAMPI=-rationale  ^'Checks for ifTrue: or ifFalse: conditions at end of methods that have two or more statements inside their blocks. Such code might better represent the true meaning of the code if they returned self instead.'-=JUAMPI=-textToDisplay  ^self source-=JUAMPI=-safeVariableNameFor: arg1 temporaries: arg2  | tmp1 tmp2 tmp3 |  tmp3 := tmp1 := 'anObject'.  tmp2 := 0.  [ (arg2 includes: tmp3) or: [ arg1 definesInstanceVariable: tmp3 ] ] whileTrue: [ tmp2 := tmp2 + 1.        tmp3 := tmp1 , tmp2 printString ].  ^tmp3-=JUAMPI=-preconditions  ^(selectors inject: RBCondition empty into: [:arg1 :arg2 |  arg1 & (RBCondition definesSelector: arg2 in: class) ]) & (RBCondition withBlock: [ self checkSuperMethods.              true ])-=JUAMPI=-classSide  ^model metaclassNamed: self name-=JUAMPI=-storeOn: arg1  arg1 nextPut: $(.  self class storeOn: arg1.  arg1     nextPutAll: ' deprecateMethod: #';     nextPutAll: oldSelector;     nextPutAll: ' in: '.  class storeOn: arg1.  arg1     nextPutAll: ' using: #';     nextPutAll: newSelector.  arg1 nextPut: $)-=JUAMPI=-changeStamp  ^Author changeStamp-=JUAMPI=-consistencyCheck  ^(1 to: 10) size > 0-=JUAMPI=-testModel  | tmp1 |  tmp1 := model metaclassNamed: #Bar.  (RBAddMethodTransformation model: model sourceCode: 'printString1 ^super printString' in: tmp1 withProtocol: #accessing) asRefactoring transform.  self assert: (tmp1 parseTreeFor: #printString1) equals: (self parseMethod: 'printString1 ^super printString')-=JUAMPI=-testNewClassVariableAccessors  | tmp1 tmp2 |  tmp1 := (RBAddVariableAccessorTransformation classVariable: 'Foo1' class: #RBDummyLintRuleTest) asRefactoring transform.  tmp2 := tmp1 model metaclassNamed: #RBDummyLintRuleTest.  self denyEmpty: tmp1 changes changes.  self assert: (tmp2 parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 ^Foo1').  self assert: (tmp2 parseTreeFor: #foo1:) equals: (self parseMethod: 'foo1: anObject Foo1 := anObject')-=JUAMPI=-environment  ^self-=JUAMPI=-testMetaclass  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model metaclassNamed: #SomeClass) addInstanceVariable: 'foo'.  model defineClass: 'SomeClass subclass: #Subclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model metaclassNamed: #Subclass) compile: 'foo ^foo' classified: #(#accessing).  (RBPushDownVariableTransformation model: model instanceVariable: 'foo' class: (model metaclassNamed: #SomeClass)) asRefactoring transform.  self deny: ((model metaclassNamed: #SomeClass) directlyDefinesVariable: 'foo').  self assert: ((model metaclassNamed: #Subclass) directlyDefinesVariable: 'foo')-=JUAMPI=-hash  ^(self class hash bitXor: self oldName hash) bitXor: self newName hash-=JUAMPI=-errorMacro  ^errorMacro ifNil: [ self longMacro ] ifNotNil: [ super errorMacro ]-=JUAMPI=-method1  ^self method2-=JUAMPI=-unaryAccessingMessageStatementMethodWithReturn  ^self value-=JUAMPI=-testExistingSelector  self shouldFail: (RBAddMethodRefactoring addMethod: 'printString ^super printString' toClass: RBBasicLintRuleTestData inProtocols: #(#accessing))-=JUAMPI=-selectorNotReferenced  ^self selectorNotReferenced + 4-=JUAMPI=-detectContains  ^(1 to: 10) do: [:arg1 |  arg1 > 2 ifTrue: [ ^arg1 ] ]-=JUAMPI=-removeMethod: arg1 from: arg2  ^self addChange: (changeFactory removeMethod: arg1 from: arg2)-=JUAMPI=-asUndoOperation  ^RBAddProtocolChange addProtocolNamed: protocol in: self changeClass-=JUAMPI=-missingYourself  ^OrderedCollection new     add: 1;     add: 2;     removeFirst-=JUAMPI=-testPullUpInstVar  | tmp1 |  self proceedThroughWarning: [ tmp1 := RBPullUpInstanceVariableRefactoring variable: 'result' class: RBLintRuleTestData.        self executeRefactoring: tmp1 ].  self assert: ((tmp1 model classNamed: #RBLintRuleTestData) directlyDefinesInstanceVariable: 'result').  self deny: ((tmp1 model classNamed: #RBBasicLintRuleTestData) directlyDefinesInstanceVariable: 'result')-=JUAMPI=-changeString  ^'Remove protocol named ' , self displayProtocolName , ' in ' , self displayClassName-=JUAMPI=-testBadInterval  self shouldFail: (RBRenameTemporaryRefactoring renameTemporaryFrom: (14 to: 17) to: 'asdf' in: RBRefactoryTestDataApp selector: #testMethod)-=JUAMPI=-description: arg1  self changes name: arg1-=JUAMPI=-deny: arg1 equals: arg2  ^self deny: arg2 = arg1 description: [ self unexpectedEqualityStringBetween: arg1 and: arg2 ]-=JUAMPI=-testMoveMethodThatReferencesPoolDictionary  | tmp1 tmp2 |  self proceedThroughWarning: [ tmp1 := RBMoveMethodRefactoring selector: #junk class: RBLintRuleTestData variable: 'RefactoryTestDataApp'.        self setupSelfArgumentNameFor: tmp1 toReturn: 'transformationRule'.        self setupVariableTypesFor: tmp1 toReturn: (Array with: (tmp1 model classNamed: 'RBRefactoryTestDataApp class' asSymbol)).        self setupMethodNameFor: tmp1 toReturn: #junk1.        self executeRefactoring: tmp1 ].  tmp2 := tmp1 model classNamed: #RBLintRuleTestData.  self assert: (tmp2 parseTreeFor: #junk) equals: (self parseMethod: 'junk ^RefactoryTestDataApp junk1').  self assert: ((tmp1 model metaclassNamed: #RBRefactoryTestDataApp) parseTreeFor: #junk1) equals: (self parseMethod: 'junk1	^RBRefactoryTestDataApp printString copyFrom: 1 to: CR').  self assert: (tmp2 directlyDefinesPoolDictionary: 'TextConstants' asSymbol)-=JUAMPI=-testMoveInstVarToClassAlreadyDefined  self shouldFail: (RBMoveInstVarToClassRefactoring model: model variable: 'result' class: RBBasicLintRuleTestData oldClass: RBFooLintRuleTestData)-=JUAMPI=-methodBefore  | tmp1 |  tmp1 := 'String'-=JUAMPI=-copyDownMethod: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp3 := targetSuperclass whoDefinesMethod: arg1.  tmp3 ifNil: [ ^self ].  tmp2 := tmp3 sourceCodeFor: arg1.  tmp2 ifNil: [ self refactoringFailure: ('Source code for <1s> superclass method not available' expandMacrosWith: arg1) ].  tmp1 := tmp3 protocolsFor: arg1.  tmp4 := targetSuperclass subclasses reject: [:arg2 |  arg2 directlyDefinesMethod: arg1 ].  tmp4 ifEmpty: [ ^self ].  (tmp3 parseTreeFor: arg1) superMessages detect: [:arg2 |  tmp3 directlyDefinesMethod: arg2 ] ifFound: [ self refactoringError: ('Cannot pull up <1s> since we must copy down the superclass method in <2p><n>to the other subclasses, and the superclass method sends a super message which is overriden.' expandMacrosWith: arg1 with: tmp3) ].  self refactoringWarning: 'Do you want to copy down the superclass method to the classes that don''t define ' , arg1.  tmp5 := RBExpandReferencedPoolsRefactoring model: self model forMethod: (tmp3 parseTreeFor: arg1) fromClass: tmp3 toClasses: tmp4.  self performComponentRefactoring: tmp5.  tmp4 do: [:arg2 |  arg2 compile: tmp2 classified: tmp1 ]-=JUAMPI=-modifiesCollection  | tmp1 |  tmp1 := (1 to: 10) asOrderedCollection.  tmp1 do: [:arg1 |  arg1 > 5 ifTrue: [ tmp1 remove: arg1 ] ].  ^tmp1-=JUAMPI=-buildTransformations  ^OrderedCollection with: (RBAddVariableTransformation model: self model instanceVariable: variableName asString class: className) with: (RBRemoveVariableTransformation model: self model instanceVariable: variableName asString class: oldClass)-=JUAMPI=-removeInstanceVariable: arg1  self privateInstanceVariableNames remove: arg1.  model removeInstanceVariable: arg1 from: self-=JUAMPI=-testTransform  | tmp1 tmp2 |  tmp1 := (RBRemoveDirectAccessToVariableTransformation instanceVariable: 'class' class: #RBTransformationRuleTestData) transform.  tmp2 := tmp1 model classNamed: #RBTransformationRuleTestData.  self assert: (tmp2 parseTreeFor: #superSends) equals: (self parseMethod: 'superSends		| rule |		rule := RBParseTreeRewriter new.		rule addSearch: ''super `@message: ``@args'' 			-> (				[:aNode | 				(self class withAllSubclasses 					detect: [:each | each includesSelector: aNode selector]					ifNone: [nil]) isNil] 						-> ''self `@message: ``@args'').		self rewriteUsing: rule').  self assert: (tmp2 parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 		self class: aSmalllintContext selectedClass.		(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) ifFalse: 				[builder 					compile: rewriteRule tree printString					in: self class					classified: aSmalllintContext protocols]]')-=JUAMPI=-displayClassName  ^isMeta ifTrue: [ self changeClassName , ' class' ] ifFalse: [ self changeClassName asString ]-=JUAMPI=-initialize  combinations := OrderedCollection new-=JUAMPI=-refersToClass  ^RBRefactoryTestDataApp-=JUAMPI=-parserClass  ^RBParser-=JUAMPI=-split: arg1 from: arg2 in: arg3  class := self classObjectFor: arg3.  selector := arg2.  selectedInterval := arg1-=JUAMPI=-resultClass  self subclassResponsibility-=JUAMPI=-