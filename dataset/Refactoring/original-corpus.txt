isEmpty  ^protocols isEmptystoreOn: aStream  aStream     nextPutAll: '(';     nextPutAll: self class name;     nextPutAll: ' onEnvironment: '.  environment storeOn: aStream.  aStream nextPut: $)resetResult  result := result copyEmpty.  result label: namesource  ^source ifNil: [ super oldVersionTextToDisplay ]allPoolDictionaryNames  ^self instanceSide allPoolDictionaryNamescontains  ^((1 to: 10) detect: [:each |  each > 2 ] ifNone: [ nil ]) isNilmethodAfter  | variable |  variable := 'String'transform  self abstractVariableReferences.  self renameSelfReferences.  super transformname  ^name ifNil: [ self changeString ] ifNotNil: [ name ]visitSequenceNode: aSequenceNode  | starts ends |  starts := aSequenceNode statements collect: [:node |  node start ].  ends := aSequenceNode statements collect: [:node |  node stop ].  starts do: [:start |  ends do: [:end |  start < end ifTrue: [ combinations add: (Array with: start with: end) ] ] ].  super visitSequenceNode: aSequenceNodetestRefactoring  | transformation class |  self assert: self class category equals: #'Refactoring2-Transformations-Tests'.  transformation := (RBMoveClassTransformation move: self class name to: #'Refactoring2-Transformations-Utilities') asRefactoring transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self class name.  self assert: class category equals: #'Refactoring2-Transformations-Utilities'messageSend: aMessageSend inMethod: aSelector inClass: aClassName  self className: aClassName.  selector := aSelector.  message := aMessageSendtransform  selectors do: [:each |  self pushDown: each ].  selectors do: [:each |  class removeMethod: each ]stringConcatenation  | string |  string := '' yourself.  (1 to: 10) do: [:i |  string := string , i printString ].  ^stringtestVariableDoesNotExist  self     shouldFail: (RBProtectVariableTransformation instanceVariable: 'foo' class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBProtectVariableTransformation classVariable: #Foo class: #RBBasicLintRuleTestData) asRefactoringadd  | newArguments |  newArguments := self argumentList.  newArguments add: 'arg' , (newArguments size + 1) asString.  self methodName arguments: newArguments.  self updatepreconditions  ^(RBCondition isMetaclass: class) not & (RBCondition isValidClassVarName: variableName for: class) & (RBCondition hierarchyOf: class definesVariable: variableName asString) not & (RBCondition isGlobal: variableName in: self model) notimplementors  implementors ifNil: [ implementors := self model allImplementorsOf: oldSelector ].  ^implementorsisClassEnvironment  ^trueinitialize  super initialize.  self createClassesvariableAssignedLiteral  temporaryVariable := #()createSearchWith: aCodeString selectors: selectorCollection inClass: aClass  | search |  search := self parseTreeSearcher.  search matches: aCodeString do: [:aNode :answer |  answer           remove: self currentSelector ifAbsent: [ self error: 'failed' ];           yourself ].  search answer: selectorCollection asBag.  (classSearches at: aClass ifAbsentPut: [ Set new ]) add: searchpreconditions  ^self refactorings inject: RBCondition empty into: [:result :each |  result & each preconditions ]filteredResult  | filter |  result ifEmpty: [ ^result ].  filter := RBPragmaEnvironment onEnvironment: RBBrowserEnvironment new keywords: #(lint: #lint:rationale: #lint:rationale:author: #lint:author: ignoreLintRule: #ignoreLintRule:rationale: #ignoreLintRule:rationale:author: #ignoreLintRule:author:).  filter condition: [:pragma |  pragma arguments first = self name or: [ pragma arguments first = self group or: [ pragma arguments first = self class name ] ] ].  result isSelectorEnvironment ifTrue: [ ^result & filter not label: result label ].  result isClassEnvironment ifTrue: [ filter classesDo: [:class |  result                 removeClass: class classSide;                 removeClass: class instanceSide ] ] ifFalse: [ result isVariableEnvironment ifTrue: [ filter classesDo: [:class |  class classVarNames do: [:var |  result removeClass: class classVariable: var ].                    class instVarNames do: [:var |  result removeClass: class instanceVariable: var ] ] ] ].  ^resulttestClassDoesNotExist  self shouldFail: (RBAddReturnStatementTransformation return: '^ variable' inMethod: #methodBefore inClass: #RBReturnStatementTransformationTest) asRefactoringaddInstanceVariable: variableName to: aClass  ^self addChange: (changeFactory addInstanceVariable: variableName to: aClass)testInstanceVariable  | refactoring |  refactoring := (RBPushDownVariableTransformation instanceVariable: 'foo1' class: #RBDummyLintRuleTest) asRefactoring transform.  (refactoring model classNamed: #RBDummyLintRuleTest) subclasses do: [:each |  self assert: (each directlyDefinesInstanceVariable: 'foo1') ]hasConflicts  ^(rules detect: [:each |  each hasConflicts ] ifNone: [ nil ]) notNilremoveMethod: aSelector from: aRBClass  self flushCaches.  ^changes removeMethod: aSelector from: aRBClasscheckBrowseAllOccurences: anCollectionOfOccurrences  | methods callers |  methods := anCollectionOfOccurrences collect: [:c |  c key ] as: Set.  callers := anCollectionOfOccurrences collect: [:v |  v value ].  methods size = 1 ifTrue: [ self refactoringError: ('Possible call to <2s> in <1p> methods.<n>Browse references?' expandMacrosWith: anCollectionOfOccurrences size with: methods anyOne) with: [ self openBrowserOn: (RBBrowserEnvironment new referencesTo: methods anyOne) ] ] ifFalse: [ self refactoringError: ('Possible call to the <2p> selectors in <1p> methods.<n>Browse references?' expandMacrosWith: callers size with: methods size) with: [ | env |              env := RBSelectorEnvironment new.              callers do: [:d |  env addMethod: d method ].              self openBrowserOn: env ] ]definesClass: aClass  ^aClass == class and: [ super definesClass: aClass ]checkReturn  needsReturn := self placeholderNode isUsed.  extractedParseTree containsReturn ifFalse: [ ^self ].  extractedParseTree lastIsReturn ifTrue: [ ^self ].  (modifiedParseTree isLast: self placeholderNode) ifFalse: [ self refactoringError: 'Couldn''t extract code since it contains a return.' ].  self checkSelfReturnsargumentIndex  ^selectedArgumentIndex ifNil: [ selectedArgumentIndex := 0 ]usesAssignmentOf: aString in: aClass classVariable: isClassVar  | matcher definingClass |  matcher := self parseTreeSearcher.  matcher     answer: false;     matches: aString , ' := ``@object' do: [:aNode :answer |  answer or: [ aNode isUsed and: [ aNode methodNode selector ~= aString ] ] ].  definingClass := isClassVar ifTrue: [ aClass instanceSide ] ifFalse: [ aClass ].  ^definingClass withAllSubclasses , (isClassVar ifTrue: [ definingClass classSide withAllSubclasses ] ifFalse: [ #() ]) anySatisfy: [:each |  (isClassVar ifTrue: [ each whichSelectorsReferToClassVariable: aString ] ifFalse: [ each whichSelectorsReferToInstanceVariable: aString ]) anySatisfy: [:sel |  self checkClass: each selector: sel using: matcher ] ]hasPermutedArguments  oldSelector numArgs = newSelector numArgs ifFalse: [ ^true ].  1 to: oldSelector numArgs do: [:i |  (permutation at: i) = i ifFalse: [ ^true ] ].  ^falseisEmpty  self classesDo: [:each |  ^false ].  ^truetransform  self     replaceAssignment;     replaceReferences;     compileMethodwhatToDisplayIn: aBrowser  ^(self changes changes select: [:change |  selector = change selector ]) flatCollect: [:change |  change whatToDisplayIn: aBrowser ]environment: anObject  environment := anObjecttestInlineMethod  | refactoring |  refactoring := RBInlineMethodRefactoring inline: (455 to: 504) inMethod: #sentNotImplementedInApplication forClass: RBBasicLintRuleTestData class.  self executeRefactoring: refactoring.  self assert: ((refactoring model metaclassNamed: #RBBasicLintRuleTestData) parseTreeFor: #sentNotImplementedInApplication) equals: (self parseMethod: 'sentNotImplementedInApplication									| detector |									detector := self new.									detector name: ''Messages sent but not implemented in application''.									detector methodBlock: 											[:context :result | 											| message class block |											message := context messages 														detect: [:each | (context isItem: each in: context application) not]														ifNone: [nil].											class := context selectedClass.											block := 													[:each | 													| app methodApp root |													app := context application.													((class canUnderstand: each) 														ifTrue: 															[root := app rootApplication.															methodApp := ((class whichClassIncludesSelector: each) 																		compiledMethodAt: each) application 																		rootApplication.															methodApp == root or: [root isBasedOn: methodApp]]														ifFalse: [false]) not].											message isNil 												ifTrue: [message := context selfMessages detect: block ifNone: [nil]].											message isNil 												ifTrue: 													[class := class superclass.													class isNil 														ifTrue: 															[context superMessages isEmpty 																ifFalse: [message := context superMessages asArray first]]														ifFalse: [message := context superMessages detect: block ifNone: [nil]]].											message notNil 												ifTrue: 													[result addSearchString: message.													result addClass: context selectedClass selector: context selector]].									^detector')release  self disconnectFromChanges.  super releasecomment: aString in: aClass  self deprecated: 'use RBClass2 instead'abstractClassReferences  | replacer |  replacer := RBParseTreeRewriter variable: variableName getter: self accessorsRefactoring getterMethod setter: self accessorsRefactoring setterMethod.  self convertClasses: class classSide withAllSubclasses select: [:aClass |  (aClass whichSelectorsReferToClassVariable: variableName) reject: [:each |  aClass == class classSide and: [ each == self accessorsRefactoring getterMethod or: [ each == self accessorsRefactoring setterMethod ] ] ] ] using: replacersymbolReference  ^#(#renameThisMethod: #(4 #renameThisMethod:))addClassVariable: variableName to: aClass  ^RBAddClassVariableChange add: variableName to: aClassviewResults  builder inspect.  self resetResultshould: aBlock raise: anException withExceptionDo: anotherBlock  ^self assert: (self executeShould: aBlock inScopeOf: anException withExceptionDo: anotherBlock)protocol: aString inClass: aClassName  self className: aClassName.  protocol := aStringdirectlyDefinesMethod: aSelector  self isDefined ifTrue: [ (self hasRemoved: aSelector) ifTrue: [ ^false ].        (self realClass includesSelector: aSelector) ifTrue: [ ^true ] ].  ^newMethods notNil and: [ newMethods includesKey: aSelector ]gtInspectorPreviewIn: composite  composite list     title: 'Changes';     display: [ self changes ];     when: [ self changes notEmpty ]method1  ^self method2testReparentSuperclassChange  | st superclass subclasses |  st := modelFactory rbNamespace new.  superclass := st classFor: TestCase superclass.  subclasses := TestCase subclasses collect: [:each |  st classFor: each ].  st reparentClasses: subclasses to: superclass.  subclasses do: [:each |  self assert: each superclass equals: superclass ]inlineTemporary  | temp |  self isNil ifTrue: [ temp := 4 ].  ^tempopen  ^self openModalWithSpecinstanceVariableWriters  ^instanceVariableWritersisOverridden  | selector |  selector := self inlineSelector.  class allSubclassesDo: [:each |  (each directlyDefinesMethod: selector) ifTrue: [ ^true ] ].  ^falseexecuteNotifying: aBlock  self subclassResponsibilitycheckBrowseOccurrences: anCollectionOfOccurrences  anCollectionOfOccurrences size = 1 ifTrue: [ ^self checkBrowseOccurrenceOf: anCollectionOfOccurrences first key in: anCollectionOfOccurrences first value ] ifFalse: [ ^self checkBrowseAllOccurences: anCollectionOfOccurrences ]convertMethod: selector for: aClass using: searchReplacer  | parseTree |  parseTree := aClass parseTreeFor: selector.  parseTree ifNil: [ ^self ].  (searchReplacer executeTree: parseTree) ifTrue: [ aClass compileTree: searchReplacer tree ]testRenameMethodPermuteArgs  | refactoring class |  refactoring := RBRenameMethodRefactoring renameMethod: ('demoRenameMethod:' , 'PermuteArgs:') asSymbol in: RBRefactoryTestDataApp to: ('demoRenameMethod:' , 'PermuteArgs:') asSymbol permutation: #(2 1).  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBRefactoryTestDataApp.  self assert: (class parseTreeFor: ('demoRenameMethod:' , 'PermuteArgs:') asSymbol) equals: (self parseMethod: 'demoRenameMethod: arg2 PermuteArgs: arg1 self do: arg1.	self do: arg2.	^ arg1 > arg2').  self assert: (class parseTreeFor: #demoExampleCall) equals: (self parseMethod: 'demoExampleCall ^self demoRenameMethod: 2 PermuteArgs: 1')setUp  super setUp.  model := self abstractVariableTestDataabstractVariablesRefactoring  ^RBAbstractVariablesRefactoring model: self model abstractVariablesIn: parseTree from: class toAll: moveToClasses ignoring: variableusesAdd  ^(1 to: 10) asOrderedCollection addAll: (11 to: 20)rename: aVariableName to: aNewVariableName class: aClassName classVariable: aBoolean  self className: aClassName.  variableName := aVariableName.  newVariableName := aNewVariableName.  isClassVariable := aBooleanfail: aDescriptionString  ^self assert: false description: aDescriptionStringallImplementorsOf: aSelector  ^implementorsCache at: aSelector ifAbsentPut: [ self privateImplementorsOf: aSelector ]signalMultipleReferenceError  self signalReferenceError: ('Multiple subclasses reference <1s>' expandMacrosWith: variableName)testAddClass  | refactoring newClass superClass classTest |  refactoring := RBAddClassRefactoring addClass: #FooTest superclass: RBRefactoringTest subclasses: (Array with: self class) category: #'Refactory-Testing'.  self executeRefactoring: refactoring.  newClass := refactoring model classNamed: #FooTest.  superClass := refactoring model classNamed: #RBRefactoringTest.  classTest := refactoring model classNamed: self class name.  self assert: newClass superclass equals: superClass.  self assert: (superClass subclasses includes: newClass).  self assert: newClass classSide superclass equals: superClass classSide.  self assert: (superClass classSide subclasses includes: newClass classSide).  self assert: classTest superclass equals: newClass.  self assert: (newClass subclasses includes: classTest).  self assert: classTest classSide superclass equals: newClass classSide.  self assert: (newClass classSide subclasses includes: classTest classSide)privateTransform  | methodTree valueNode assignments nodeToRemove |  methodTree := self definingMethod.  assignments := (methodTree allChildren select: #isAssignment) select: [:each |  each variable name asString = variableName ].  nodeToRemove := assignments size = 1 ifTrue: [ assignments first ] ifFalse: [ valueNode := self parserClass parseExpression: value.        assignments detectMax: [:node |  ((node allChildren collect: #class) intersection: (valueNode allChildren collect: #class)) size ] ].  nodeToRemove parent removeNode: nodeToRemove.  class compileTree: methodTreeclasses  | classes |  classes := IdentitySet new: 4096.  self classesDo: [:each |  classes add: each ].  ^classesselector  selector ifNil: [ selector := self parserClass parseMethodPattern: source.        selector ifNil: [ selector := #unknown ] ].  ^selectorstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' interval: ''';     nextPutAll: interval asString;     nextPutAll: ' with: ''';     nextPutAll: sourceCode;     nextPutAll: ''' from: ''';     nextPutAll: selector;     nextPutAll: ''' in: '.  class storeOn: aStream.  aStream nextPut: $)transform  selectors do: [:each |  class removeMethod: each ]usesDirectly: aParseTree  | searcher |  searcher := self parseTreeSearcher.  searcher     matches: '[:`@args | | `@temps | `@.Statements]' do: [:aNode :answer |  answer ];     matches: name do: [:aNode :answer |  true ].  ^searcher executeTree: aParseTree initialAnswer: falseprivateReferencesTo: aSelector  | methods |  methods := OrderedCollection new.  self allBehaviorsDo: [:class |  (class whichSelectorsReferToSymbol: aSelector) do: [:selector |  methods add: (class methodFor: selector) ] ].  ^methodsexpressionsToInlineFrom: aTree  | searcher |  searcher := self parseTreeSearcher.  searcher matches: '``@obj ' , (self buildSelectorString: oldSelector) do: [:aNode :answer |  answer           add: (aNode arguments at: parameterIndex);           yourself ].  ^searcher executeTree: aTree initialAnswer: OrderedCollection newfoo: aValue  ^(1 to: 10) inject: aValue into: [:sum :each |  sum + each ]resetResult  result := self resultClass new.  result label: self namesource  ^sourcetextToDisplay  ^String streamContents: [:s |  s           << self printString;           cr.        self changes do: [:c |  s                 << c textToDisplay;                 cr ] ]guardingClause  self isSymbol ifFalse: [ self printString.        self isSymbol printString ]testInlineMethod3  | refactoring |  refactoring := RBInlineMethodRefactoring inline: (58 to: 73) inMethod: #caller2 forClass: RBRefactoryTestDataApp.  self setupInlineExpressionFor: refactoring toReturn: false.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #caller2) equals: (self parseMethod: 'caller2								^(1 to: 10) inject: 1 into: [:sum :each | sum * ((1 to: 10) inject: each into: [:sum1 :each1 | sum1 + each1])]	')severity  ^#warningprivateTransform  self transformations do: [:transformation |  transformation           copyOptionsFrom: self options;           model: self model;           preconditionChecking: delegatesPreconditions & self preconditionChecking;           transform ]uses: anObject  ^self literals includes: anObjectallMethods  ^self allSelectors collect: [:selector |  self methodFor: selector ] thenSelect: #isNotNilchangeString  ^'Category ' , self displayCategoryName , ' in ' , self displayClassNameinitialize  super initialize.  environmentDictionaries := Dictionary new.  environment := RBSelectorEnvironment newactionBlock: aBlock  actionBlock := aBlockmultipleCalls  self caller2.  self caller2setUp  super setUp.  modelFactory := RBClassModelFactory newtestMethodDoesNotExist  self shouldFail: (RBAddTemporaryVariableTransformation variable: 'variable2' inMethod: #method inClass: #RBAddReturnStatementTransformationTest) asRefactoringtmpName  ^(#TmpSubclass , className) asSymbolrenameInstanceVariable: oldName to: newName around: aBlock  self privateInstanceVariableNames at: (self privateInstanceVariableNames indexOf: oldName asString) put: newName asString.  model renameInstanceVariable: oldName to: newName in: self around: aBlockcomment  ^commentcomputeTypes  variableMessages keysAndValuesDo: [:key :value |  variableTypes at: key put: (self findTypeFor: value) ]testRemoveSameMethodButSendsSuper  < expectedFailure>  self shouldWarn: (RBRemoveMethodRefactoring removeMethods: #(#new) from: RBBasicLintRuleTestData class)testAlreadyExistingName  self shouldFail: (RBRenameInstanceVariableRefactoring rename: 'classBlock' to: 'name' in: RBBasicLintRuleTestData)directlyDefinesVariable: aVariableName  ^(self directlyDefinesClassVariable: aVariableName) or: [ self directlyDefinesInstanceVariable: aVariableName ]testAccessIsNotDefined  self shouldFail: (RBAddReturnStatementTransformation return: '^ variable2' inMethod: #methodBefore inClass: #RBAddReturnStatementTransformationTest) asRefactoringpreconditions  class := self model classObjectFor: className.  ^(isClassVariable ifTrue: [ (RBCondition isMetaclass: class) not & (RBCondition isValidClassVarName: newVariableName asString for: class) & (RBCondition definesClassVariable: variableName asString in: class) ] ifFalse: [ (RBCondition isValidInstanceVariableName: newVariableName for: class) & (RBCondition definesInstanceVariable: variableName in: class) ]) & (RBCondition hierarchyOf: class definesVariable: newVariableName) not & (RBCondition isGlobal: newVariableName in: self model) nottestOverriden  self shouldWarn: (RBInlineMethodRefactoring inline: (15 to: 26) inMethod: #failedRules forClass: RBLintRuleTestData)badMessage  self become: String newimplementorsCanBePrimitives  ^self hasPermutedArguments nottestExtractToTemporaryForLastStatementInBlock  | refactoring |  refactoring := RBExtractToTemporaryRefactoring extract: (52 to: 73) to: 'temp' from: #caller2 in: RBRefactoryTestDataApp.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #caller2) equals: (self parseMethod: 'caller2	^(1 to: 10) inject: 1 into: [:sum :each | | temp | temp := sum * (self foo: each). temp]')changeForClass: aClassName selector: aSelector  changes reverseDo: [:each |  | change |        change := each changeForClass: aClassName selector: aSelector.        change notNil ifTrue: [ ^change ] ].  ^nilstoreOn: aStream  aStream nextPut: $(.  super storeOn: aStream.  aStream nextPutAll: ' keywords: '.  keywords asArray storeOn: aStream.  aStream nextPut: $)testPerformRenameClass  | change |  change := changes renameClass: self changeMock to: self changeMock name , 'Plus'.  self perform: change do: [ self deny: (workingEnvironment hasClassNamed: change oldName).        self assert: (workingEnvironment hasClassNamed: change newName) ].  self assert: (workingEnvironment hasClassNamed: change oldName).  self deny: (workingEnvironment hasClassNamed: change newName)gtInspectorPreviewIn: composite  < gtInspectorPresentationOrder: 0>  composite diff     title: 'Changes';     display: [ {self oldVersionTextToDisplay .         self textToDisplay} ]replace: anOldString to: aNewString inMethod: aSelector inClass: aClass  self className: aClass.  selector := aSelector.  oldSourceCode := anOldString.  newSourceCode := aNewStringcreateGetterAccessor  getterMethod := self findGetterMethod.  getterMethod ifNil: [ getterMethod := self defineGetterMethod ]storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' variable: '.  variableName storeOn: aStream.  aStream nextPutAll: ' fromClass: '.  oldClass storeOn: aStream.  aStream nextPutAll: ' toClass: '.  className storeOn: aStream.  aStream nextPut: $)testNonExistantName  self     shouldFail: (RBRemoveParameterRefactoring removeParameter: 'asdf' in: RBBasicLintRuleTestData selector: #checkClass:);     shouldFail: (RBRemoveParameterRefactoring removeParameter: 'aSmalllintContext' in: RBBasicLintRuleTestData selector: #checkClass1:)classesDo: aBlock  self systemDictionaryClassesDo: [:each |  (self includesClass: each) ifTrue: [ aBlock value: each ] ]problemCount  ^environment isClassEnvironment ifTrue: [ self numberClasses ] ifFalse: [ super problemCount ]whoDefinesMethod: aSelector  | sprClass |  (self directlyDefinesMethod: aSelector) ifTrue: [ ^self ].  sprClass := self superclass.  ^sprClass ifNil: [ nil ] ifNotNil: [ sprClass whoDefinesMethod: aSelector ]hasRemoved: aSymbol  ^removedClasses includes: aSymboltestInlineMethodWithMultipleSendersInMethod  | refactoring |  refactoring := RBInlineAllSendersRefactoring sendersOf: #caller2 in: RBRefactoryTestDataApp.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineLast) equals: (self parseMethod: 'inlineLast	5 = 3 ifTrue: [^self caller] ifFalse: [^(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)]] ').  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #multipleCalls) equals: (self parseMethod: 'multipleCalls	(1 to: 10) inject: 1 into: [:sum :each | sum * (self foo: each)].	(1 to: 10) inject: 1 into: [:sum1 :each1 | sum1 * (self foo: each1)]')asUndoOperation  ^changeFactory removePoolVariable: self variable from: self changeClasssignalStillReferencedError  self signalReferenceError: ('<1p> has references to <2s>' expandMacrosWith: class with: variableName)executeRefactoring: aRefactoring  aRefactoring primitiveExecute.  self parserClass parseExpression: aRefactoring storeStringchanges  ^changestestRenameTestMethod  | refactoring class |  refactoring := RBRenameMethodRefactoring renameMethod: ('rename' , 'ThisMethod:') asSymbol in: RBRefactoryTestDataApp to: #renameThisMethod2: permutation: (1 to: 1).  self proceedThroughWarning: [ self executeRefactoring: refactoring ].  class := refactoring model classNamed: #RBRefactoryTestDataApp.  self assert: (class parseTreeFor: #renameThisMethod2:) equals: (self parseMethod: 'renameThisMethod2: anArg	^self').  self assert: (class parseTreeFor: #callMethod) equals: (self parseMethod: 'callMethod	^(self renameThisMethod2: 5)').  self assert: (class parseTreeFor: #symbolReference) equals: (self parseMethod: 'symbolReference		^ #(#renameThisMethod2: #(4 #renameThisMethod2:))').  self deny: (class directlyDefinesMethod: ('rename' , 'ThisMethod:') asSymbol)storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' selector: ';     nextPutAll: selector;     nextPutAll: ' from: '.  class storeOn: aStream.  aStream nextPut: $)& aCondition  ^RBConjunctiveCondition new left: self right: aConditionasSelectorEnvironment  ^(RBClassEnvironment onEnvironment: self classes: self classes) asSelectorEnvironmenttestReferencedVariable  self     shouldFail: (RBRemoveVariableTransformation instanceVariable: 'name' class: #RBDummyLintRuleTest) asRefactoring;     shouldFail: (RBRemoveVariableTransformation classVariable: #RecursiveSelfRule class: #RBTransformationDummyRuleTest) asRefactoringtestAddClassVariable  | change |  change := changes addClassVariable: 'ClassVar' to: self class.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self assert: change variable equals: 'ClassVar'.  self universalTestFor: changeisDefined  ^self realClass notNiltestWithTemporariesSelected  | class refactoring |  model := RBNamespace2 new.  class := model classNamed: self class name.  class compile: 'foo [| temp | temp := 5. temp * temp] value' classified: #(#accessing).  refactoring := (RBExtractMethodTransformation model: model extract: '| temp | temp := 5. temp * temp' from: #foo to: #foobar in: class) asRefactoring transform.  self assert: refactoring model changes changes size equals: 4.  self assert: (class parseTreeFor: #foo) equals: (self parseMethod: 'foo [self foobar] value').  self assert: (class parseTreeFor: #foobar) equals: (self parseMethod: 'foobar |temp | temp := 5. ^temp * temp')multiplePeriodsTerminatingStatement  ^selfcollectionMessagesToExternalObject  self someObject collection remove: 10newName  ^newNametestAlreadyExistingName  self     shouldFail: (RBAddInstanceVariableRefactoring variable: 'class' class: RBTransformationRuleTestData);     shouldFail: (RBAddInstanceVariableRefactoring variable: 'name' class: RBTransformationRuleTestData)removeClass: aClass instanceVariableWriter: aString  | vars |  vars := instanceVariableWriters at: aClass name ifAbsent: [ Set new ].  vars remove: aString ifAbsent: [  ].  vars ifEmpty: [ instanceVariableWriters removeKey: aClass name ifAbsent: [  ] ].  self flushCachesFor: aClasspreconditions  ^RBCondition withBlock: [ (self theClass withAllSubclasses detect: [:each |  (each whichSelectorsReferToSymbol: #subclassResponsibility) notEmpty or: [ (each classSide whichSelectorsReferToSymbol: #subclassResponsibility) notEmpty ] ] ifNone: [ nil ]) isNil ] errorString: self theClass printString , ' is abstract or has abstract subclasses.'abstractVariableReferences  | refactoring |  refactoring := RBAbstractVariablesRefactoring model: self model abstractVariablesIn: inlineParseTree from: inlineClass toAll: (Array with: class).  self performComponentRefactoring: refactoring.  inlineParseTree := refactoring parseTreeprintOn: aStream  | argumentStream |  self isValid ifFalse: [ ^aStream nextPutAll: '(invalid)' ].  argumentStream := self arguments readStream.  self selector keywords keysAndValuesDo: [:key :part |  key = 1 ifFalse: [ aStream space ].        aStream nextPutAll: part.        (self selector isUnary or: [ argumentStream atEnd ]) ifTrue: [ ^self ].        aStream           space;           nextPutAll: argumentStream next ]storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' removeParameter: ''';     nextPutAll: argument;     nextPutAll: ''' in: '.  class storeOn: aStream.  aStream     nextPutAll: ' selector: #';     nextPutAll: oldSelector.  aStream nextPut: $)includesCategory: aCategory  ^(categories includes: aCategory) and: [ super includesCategory: aCategory ]compileNewMethods  moveToClasses do: [:each |  each compile: parseTree newSource withAttributesFrom: (class methodFor: selector) ]numberOfArgs: aSymbol  ^(aSymbol asString splitOn: ':') sizeinitialize  super initialize.  environment := Smalltalk globalspreconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ | pragmaNode |              pragmaNode := self parserClass parsePragma: pragma.              self definingMethod pragmas noneSatisfy: [:e |  e selector = pragmaNode selector ] ] errorString: ('Method named <1s> already has a pragma named <2s>' expandMacrosWith: selector with: (self parserClass parsePragma: pragma) selector))addSelfReferenceToInlineParseTree  | variableName rewriter newArguments |  variableName := self newNameForSelf.  rewriter := RBParseTreeRewriter rename: 'self' to: variableName.  (rewriter executeTree: inlineParseTree) ifTrue: [ inlineParseTree := rewriter tree ].  newArguments := inlineParseTree arguments asOrderedCollection.  newArguments addFirst: (RBVariableNode named: variableName).  inlineParseTree renameSelector: (self addArgumentToSelector: inlineParseTree selector) andArguments: newArguments.  sourceMessage receiver replaceWith: (RBVariableNode named: variableName)selectorsForClass: aClass do: aBlock  aClass selectorsAndMethodsDo: [:each :meth |  (self includesSelector: each in: aClass) ifTrue: [ aBlock value: each ] ]testAddInstanceVariable  | refactoring |  refactoring := (RBAddVariableTransformation instanceVariable: 'asdf' class: #RBTransformationRuleTestData) asRefactoring transform.  self assert: ((refactoring model classNamed: #RBTransformationRuleTestData) directlyDefinesInstanceVariable: 'asdf')privateTransform  | tree signature sourceCode |  tree := self definingMethod.  signature := tree source copyFrom: 1 to: tree body start - 1.  sourceCode := signature , String cr , (comment surroundedBy: '"') , String cr , tree body sourceCode.  self definingClass compileTree: (self parserClass parseMethod: sourceCode)testPullUpWithInvalidSuperSend  | class |  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #Foo2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model classNamed: #Foo2) compile: 'yourself ^super yourself + 1' classified: #(#accessing).  class := model classNamed: #Foo1.  class compile: 'yourself ^1' classified: #(#accessing).  self shouldFail: (RBPullUpMethodRefactoring model: model pullUp: #(#yourself) from: class)fileBlocks  | file |  ^[ file := 'asdf' asFileReference readStream.  file contents ] ensure: [ file close ]testChangeFactoryIsCorrectlyInitialized  RBRefactoryChangeManager nuke.  self assert: RBRefactoryChangeManager changeFactory isNotNilasUndoOperation  ^changeFactory removeClassVariable: self variable from: self changeClasstoDo  1 to: self size do: [:i |  (self at: i) printString ]asUndoOperation  | class |  class := onSystemDictionary classNamed: self changeClassName.  ^class isBehavior ifTrue: [ changeFactory addClassDefinition: class oldDefinition ] ifFalse: [ changeFactory removeClassNamed: self changeClassName ]critics  ^self result smallLintCriticsfailedRules  ^self isEmpty ifTrue: [ #() ] ifFalse: [ Array with: self ]initialize  super initialize.  self anInstVar: 1.  classBlock := [:context :aResult |   ].  methodBlock := [:context :aResult |   ].  self resultClass: RBSelectorEnvironmentchangeString  ^'Add instance variable <1s> to <2s>' expandMacrosWith: self variable with: self displayClassNameimplementorsOf: aSelector  ^RBSelectorEnvironment implementorsOf: aSelector in: selftestInlineMethod1  | refactoring |  refactoring := RBInlineMethodRefactoring inline: (39 to: 84) inMethod: #caller forClass: RBRefactoryTestDataApp.  self setupInlineExpressionFor: refactoring toReturn: false.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #caller) equals: (self parseMethod: 'caller 									| anObject anObject1 | 									anObject := 5.									anObject1 := anObject + 1.									Transcript										show: anObject1 printString;										cr.									^anObject')changeString  ^'Remove class variable <1s> from <2s>' expandMacrosWith: self variable with: self displayClassNametestDefinesMethod  self assert: (objectClass definesMethod: #printString).  self assert: (newClass definesMethod: #printString).  self assert: (messageNodeClass definesMethod: #printString)testMethodDoesNotExist  self shouldFail: (RBAddPragmaTransformation pragma: '<gtInspectorPresentationOrder: 56>' inMethod: #method inClass: #RBAddPragmaTransformationTest) asRefactoringclassVariable: aBoolean  classVariable := aBooleanprimitiveComputeLiterals  | semaphore |  literals := IdentitySet new: 25000.  literals addAll: self specialSelectors keys.  selectors := IdentitySet new.  RBBrowserEnvironment new classesDo: [:each |  self computeLiteralsForClass: each ].  semaphore := literalSemaphore.  literalSemaphore := nil.  self signalProcesses: semaphore.  ^literalProcess := nilaccessorsRefactoring  ^accessorsRefactoring ifNil: [ accessorsRefactoring := RBCreateAccessorsForVariableRefactoring model: self model variable: variableName class: class classVariable: false ] ifNotNil: [ accessorsRefactoring ]testMetaClassFailure  self shouldFail: (RBRenameClassRefactoring rename: self class class to: #Foo)methodBefore  | variable |  variable := 'String'storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' selector: #';     nextPutAll: method selector;     nextPutAll: ' class: '.  class storeOn: aStream.  aStream nextPutAll: ''')'testAddInstanceVariable  | refactoring |  refactoring := RBAddInstanceVariableRefactoring variable: 'asdf' class: RBTransformationRuleTestData.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBTransformationRuleTestData) directlyDefinesInstanceVariable: 'asdf')classVariableNames  ^self privateClassVariableNames copyremoveClassNamed: aClassName  ^RBRemoveClassChange removeClassName: aClassNametestPragmaEnvironment  | aPragmaEnvironment |  aPragmaEnvironment := universalEnvironment forPragmas: #(primitive:).  self universalTestFor: aPragmaEnvironmentincludesProtocol: aProtocol in: aClass  ^(environment includesProtocol: aProtocol in: aClass) and: [ andedEnvironment includesProtocol: aProtocol in: aClass ]= anAddMethodChange  super = anAddMethodChange ifFalse: [ ^false ].  ^self parseTree = anAddMethodChange parseTreerename: oldString to: newString  oldName := oldString.  newName := newStringmethodsReferencingVariable  ^classVariable ifTrue: [ self definingClass whichSelectorsReferToClassVariable: variableName ] ifFalse: [ self definingClass whichSelectorsReferToInstanceVariable: variableName ]requestExistingSelector  ^[ (self options at: #existingSelector) value: self ] on: Exception do: [ nil ]executeNotifying: aBlock  | undos undo |  undos := changes collect: [:each |  each executeNotifying: aBlock ].  undo := self copy.  undo changes: undos reversed.  ^undochange: anObject  | aCompositeChange |  aCompositeChange := RBRefactoryChangeManager changeFactory compositeRefactoryChange.  aCompositeChange addChange: anObject.  change := aCompositeChange whatToDisplayIn: selfname  ^changes nametestEnvironmentWrapper  | printString wrapper |  printString := RBBrowserEnvironment new referencesTo: #printString.  wrapper := RBBrowserEnvironmentWrapper onEnvironment: printString.  self assert: wrapper numberSelectors equals: printString numberSelectors.  self assert: wrapper numberClasses equals: printString numberClasses.  self assert: wrapper environment identicalTo: printStringtestMethod  ^self classaddClass: aClass into: aValue  (environmentDictionaries at: aValue ifAbsentPut: [ RBSelectorEnvironment new ]) addClass: aClassdefinesClass: aClass  ^(environment definesClass: aClass) or: [ orEnvironment definesClass: aClass ]abstractVariables  self performComponentRefactoring: self abstractVariablesRefactoring.  parseTree := self abstractVariablesRefactoring parseTreetestInheritedName  self shouldFail: (RBAbstractClassVariableRefactoring variable: #DependentsFields class: RBBasicLintRuleTestData)inline: aSelector  self onError: [ self performComponentRefactoring: (RBInlineAllSendersRefactoring model: self model sendersOf: aSelector in: class) ] do: [  ]setterMethod  ^setterMethod ifNil: [ setterMethod := (self definingClass setterMethodFor: variableName) ifNil: [ (variableName uncapitalized , ':') asSymbol ] ]addMethod: aString toClass: aClass inProtocols: protocolList  class := self classObjectFor: aClass.  source := aString.  protocols := protocolListcritiqueFor: anEntity  ^ReTrivialCritique withAnchor: (self anchorFor: anEntity) by: selfremoveClass: aClass instanceVariable: aString  | vars |  vars := instanceVariables at: aClass name ifAbsent: [ Set new ].  vars remove: aString ifAbsent: [  ].  vars ifEmpty: [ instanceVariables removeKey: aClass name ifAbsent: [  ] ].  self flushCachesFor: aClassrename: aVarName to: aName in: aClass  self variable: aVarName class: aClass.  newName := aNamecheckSuperMessages  self checkSuperSendsFromPushedUpMethods.  self checkSuperSendsFromSiblingsclassVariables  ^classVariablesaddProtocolNamed: aString in: aClass  ^changes addProtocolNamed: aString in: aClassshouldFix: aBlock  ^self should: aBlock raise: ExceptionclassVariablesFor: aClass  ^aClass classVarNameslastUndoPointer  ^undoPointers popaddSelfReferenceToSourceMessage  | newArguments |  newArguments := sourceMessage arguments asOrderedCollection.  newArguments addFirst: sourceMessage receiver copy.  sourceMessage renameSelector: (self addArgumentToSelector: sourceMessage selector) andArguments: newArgumentsshouldInlineExpression: aString  ^(self options at: #inlineExpression) value: self value: aStringallSubclassesDo: aBlock  self subclassesDo: [:cl |  aBlock value: cl.        cl allSubclassesDo: aBlock ]resultClass  ^RBParseTreeEnvironmentsearchingLiteral  ^self printString = #a or: [ #() = self printString | (#() == self printString) ]rootEnvironment  ^selfsendInlineParameterMethod  ^self inlineParameterMethod: #(#asdf)buildDiffFor: aChange  diffPresenter     leftText: aChange oldVersionTextToDisplay;     rightText: aChange textToDisplayallImplementorsOf: aSelector do: aBlock  (self allImplementorsOf: aSelector) do: aBlockrewriteUsing: searchReplacer  rewriteRule := searchReplacer.  self resetResulttestAddMethod  | refactoring |  refactoring := RBAddMethodRefactoring addMethod: 'printString1 ^super printString' toClass: RBBasicLintRuleTestData inProtocols: #(#accessing).  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBBasicLintRuleTestData) parseTreeFor: #printString1) equals: (self parseMethod: 'printString1 ^super printString')preconditions  ^variables inject: RBCondition empty into: [:condition :variable |  condition & (RBCondition definesInstanceVariable: variable in: self theClass) ]privateTransform  | methodTree assignmentNode assignments previousNode |  methodTree := self definingMethod.  assignmentNode := RBAssignmentNode variable: (RBVariableNode named: variableName) value: (self parserClass parseExpression: value).  assignments := (methodTree allChildren select: #isAssignment) select: [:each |  each variable name asString = variableName ].  previousNode := assignments detectMax: #stop.  previousNode ifNil: [ methodTree body addNodeFirst: assignmentNode ] ifNotNil: [ previousNode parent addNode: assignmentNode after: previousNode ].  class compileTree: methodTreejunk  ^RBDummyRefactoryTestDataApp printString copyFrom: 1 to: CRtestNonExistantName  self shouldFail: (RBSplitClassTransformation class: #RBDummyLintRuleTest instanceVariables: #(name1) newClassName: #RBDummyLintRuleTest123 referenceVariableName: #newName) asRefactoringvariable: aVariableName class: aClassName classVariable: aBoolean  variableName := aVariableName.  isClassVariable := aBoolean.  className := aClassNamename: aString  name := aStringjustSendsSuper  super justSendsSuperaccept: aText notifying: aController  ^falsepreconditions  ^(RBCondition isValidClassName: newClassName) & (RBCondition isGlobal: newClassName in: self model) not & (RBCondition isValidInstanceVariableName: referenceVariableName for: class) & (RBCondition hierarchyOf: class definesVariable: referenceVariableName) not & (RBCondition isGlobal: referenceVariableName in: self model) not & (RBCondition definesTemporaryVariable: referenceVariableName in: class) notaddClassDefinition: definition for: aController context: aDictionary  ^RBAddClassChange definition: definition for: aController context: aDictionaryrewriteRule1  ^rewriteRule1printOn: aStream  aStream     nextPutAll: self displayClassName;     nextPutAll: ' removeSelector: ';     print: self selector;     nextPut: $!hash  ^(self class hash bitXor: self oldName hash) bitXor: self newName hashtestRemoveParameter  | refactoring class |  refactoring := RBRemoveParameterRefactoring removeParameter: 'anArg' in: RBRefactoryTestDataApp selector: ('rename' , 'ThisMethod:') asSymbol.  self proceedThroughWarning: [ self executeRefactoring: refactoring ].  class := refactoring model classNamed: #RBRefactoryTestDataApp.  self assert: (class parseTreeFor: #renameThisMethod) equals: (self parseMethod: 'renameThisMethod								^self').  self assert: (class parseTreeFor: #callMethod) equals: (self parseMethod: 'callMethod								^(self renameThisMethod)').  self deny: (class directlyDefinesMethod: ('rename' , 'ThisMethod:') asSymbol)inlineSelector  sourceMessage ifNil: [ self findSelectedMessage ].  ^sourceMessage selectorclass: aClass selector: aSelector interval: anInterval  interval := anInterval.  class := self classObjectFor: aClass.  selector := aSelector= aRenameClassChange  super class = aRenameClassChange class ifFalse: [ ^false ].  ^oldName = aRenameClassChange oldName and: [ newName = aRenameClassChange newName ]testTransform  | transformation class |  transformation := (RBRemovePragmaTransformation new pragma: '<gtInspectorPresentationOrder: 34>' inMethod: #methodBefore inClass: self class name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self class name.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) bodyreturn: anExpression inMethod: aSelector inClass: aClassName  self className: aClassName.  selector := aSelector.  returnValue := anExpressionrealName: aSymbol  self realClass: (self class environment at: aSymbol)createNewClassFor: aBehavior  | nonMeta meta className |  className := aBehavior instanceSide name.  nonMeta := (self rbClassClass existingNamed: className)     model: self;     yourself.  meta := (self rbMetaclassClass existingNamed: className)     model: self;     yourself.  ^changedClasses at: className put: (Array with: nonMeta with: meta)testModelInlineMethodWithSameVariableNames  | class refactoring |  model := RBClassModelFactory rbNamespace new.  class := model classNamed: self class name.  class compile: 'a9: a b9: b ^self + a + b' classified: #(#accessing).  (model classNamed: #Object) compile: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^a a9: b b9: c' classified: #(#accessing).  self proceedThroughWarning: [ refactoring := RBInlineMethodFromComponentRefactoring model: model inline: (72 to: 84) inMethod: #foo forClass: (model classNamed: #Object).        self setupInlineExpressionFor: refactoring toReturn: false.        self executeRefactoring: refactoring ].  self assert: ((refactoring model classNamed: #Object) parseTreeFor: #foo) equals: (self parseMethod: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^a + b + c')hasConflicts  ^rules anySatisfy: [:each |  each hasConflicts ]toDo  1 to: self size do: [:i |  (self at: i) printString ]checkAssignments: variableNames  | node outsideVars removeAssigned |  removeAssigned := variableNames copy.  node := self placeholderNode.  outsideVars := variableNames select: [:each |  (node whoDefines: each) references: each ].  outsideVars size == 1 ifTrue: [ self checkSingleAssignment: outsideVars asArray first ].  outsideVars size > 1 ifTrue: [ self refactoringError: 'Cannot extract assignment without all references.' ].  removeAssigned removeAll: outsideVars.  (RBReadBeforeWrittenTester readBeforeWritten: removeAssigned in: extractedParseTree) ifNotEmpty: [ self refactoringError: 'Cannot extract assignment if read before written.' ].  removeAssigned do: [:each |  (node whoDefines: each) removeTemporaryNamed: each ].  self createTemporariesInExtractedMethodFor: variableNamesemptyExceptionHandler  [  ] on: Error do: [:err |   ]testTransform  | transformation |  transformation := (RBPullUpVariableTransformation instanceVariable: 'result' class: #RBDummyLintRuleTest) transform.  self assert: ((transformation model classNamed: #RBDummyLintRuleTest) directlyDefinesInstanceVariable: 'result').  self deny: ((transformation model classNamed: #RBBasicDummyLintRuleTest) directlyDefinesInstanceVariable: 'result').  self deny: ((transformation model classNamed: #RBFooDummyLintRuleTest) directlyDefinesInstanceVariable: 'result')backpointersSetWith: anObject  ^PluggableSet new     equalBlock: [:a :b |  a class == b class and: [ a = b ] ];     hashBlock: [:a |  a class identityHash bitXor: a hash ];     add: anObject;     yourselfinstanceVariableReaders: anObject  instanceVariableReaders := anObjectabstractClassVariables  | variables |  (classVarReaders isEmpty and: [ classVarWriters isEmpty ]) ifTrue: [ ^self ].  variables := Set new.  variables     addAll: classVarReaders;     addAll: classVarWriters.  variables do: [:each |  self abstractClassVariable: each ]definesClassVariable: aSymbol  self realClass isTrait ifTrue: [ ^false ].  (self directlyDefinesClassVariable: aSymbol) ifTrue: [ ^true ].  ^self superclass notNil and: [ self superclass definesClassVariable: aSymbol ]buildParseTree  | tree |  tree := self selectedClass parseTreeFor: self selector.  tree ifNil: [ ^RBParser parseMethod: 'method' ].  ^treeparserClass  ^RBParserincludesProtocol: aProtocol in: aClass  ^(environment includesProtocol: aProtocol in: aClass) or: [ orEnvironment includesProtocol: aProtocol in: aClass ]testMoveDefinition  | refactoring |  refactoring := RBMoveVariableDefinitionRefactoring bindTight: (19 to: 22) in: RBRefactoryTestDataApp selector: #moveDefinition.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #moveDefinition) equals: (self parseMethod: 'moveDefinition								^(self collect: 										[:each | 										| temp |										temp := each printString.										temp , temp]) 									select: 										[:each | 										| temp |										temp := each size.										temp odd]')setterMethod  ^setterMethodinitializeWidgets  diffPresenter := self newDiff     showOptions: false;     contextClass: True.  self whenBuiltDo: [ self buildDiffFor: change first ]check: aMethod forCritiquesDo: aCriticBlock  (self basicCheck: aMethod) ifTrue: [ aCriticBlock cull: (ReTransformationCritique for: aMethod by: self tree: rewriteRule tree) ]directlyDefinesInstanceVariable: aString  ^self instanceVariableNames includes: aStringenvironmentForClassVariable: aSymbol in: aClass  | selectorEnvironment assoc block |  selectorEnvironment := RBSelectorEnvironment onEnvironment: self.  selectorEnvironment addSearchString: aSymbol.  ((classVariables at: aClass name ifAbsent: [ #() ]) includes: aSymbol) ifFalse: [ ^selectorEnvironment ].  assoc := aClass bindingOf: aSymbol.  block := [:each |  (each whichSelectorsReferTo: assoc) do: [:sel |  selectorEnvironment addClass: each selector: sel ] ].  aClass withAllSubAndSuperclassesDo: [:each |  block           value: each;           value: each class ].  ^selectorEnvironmentbrowsedEnvironment  ^browsedEnvironment ifNil: [ browsedEnvironment := RBBrowserEnvironment new ]superclassName  ^superclassNameclassVariables: anObject  classVariables := anObjectincludesProtocol: aProtocol in: aClass  ^truesubblocksIn: aParseTree  | searcher |  searcher := self parseTreeSearcher.  searcher matches: '[:`@blockTemps | | `@temps | `@.Statements]' do: [:aNode :answer |  (aNode references: name) ifTrue: [ answer add: aNode ].        answer ].  ^searcher executeTree: aParseTree initialAnswer: OrderedCollection newallReferencesTo: aSymbol do: aBlock  (self allReferencesTo: aSymbol) do: aBlockstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' pushDown: '.  selectors asArray storeOn: aStream.  aStream nextPutAll: ' from: '.  class storeOn: aStream.  aStream nextPut: $)rewriteUsing: searchReplacer  rewriteRule := searchReplacer.  self resetResulttestNonExistantName  self shouldFail: (RBPushDownInstanceVariableRefactoring variable: 'foo' class: RBBasicLintRuleTestData)isEmpty  ^builder changes isEmptypreconditions  ^(RBCondition withBlock: [ class notNil and: [ class isMeta not ] ]) & (RBCondition isValidClassName: newName) & (RBCondition isGlobal: newName in: self model) not | (RBCondition withBlock: [ self refactoringFailure: newName , ' is not a valid class name' ])testInlineComponentMethodMax  | refactoring |  self proceedThroughWarning: [ | class |        refactoring := RBInlineMethodFromComponentRefactoring inline: (47 to: 58) inMethod: #inlineMax forClass: RBRefactoryTestDataApp.        self setupInlineExpressionFor: refactoring toReturn: true.        class := refactoring model classNamed: #Magnitude.        class compile: 'max: aMagnitude 					"Answer the receiver or the argument, whichever has the greater magnitude."					self > aMagnitude						ifTrue: [^self]						ifFalse: [^aMagnitude]' classified: #(#accessing).        self setupImplementorToInlineFor: refactoring toReturn: class.        self executeRefactoring: refactoring ].  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineMax) equals: (self parseMethod: 'inlineMax								| x y q |								x := 5.								y := 10.								q := x + 1 > y									ifTrue: [x + 1]									ifFalse: [y].								^q')changeSymbol  ^#removeSharedPool:rbMetaclass  ^self class rbMetaclassparserClass  ^RBParserincludesProtocol: aProtocol in: aClass  ^aClass == class and: [ (super includesProtocol: aProtocol in: aClass) and: [ protocols includes: aProtocol ] ]unaryNonAccessingMessageStatementMethodWithoutReturn  self valueparseTree  ^treerelease  context release.  super releaseproblemCount  ^self subclassResponsibilityasUndoOperation  ^changeFactory addInstanceVariable: self variable to: self changeClasstransform  | existingSelector |  existingSelector := self existingSelector.  self nameNewMethod: (existingSelector ifNil: [ newExtractedSelector ifNil: [ self getNewMethodName ] ] ifNotNil: [ existingSelector ]).  existingSelector ifNil: [ self renameAllParameters.        class compile: extractedParseTree newSource withAttributesFrom: (class methodFor: selector) ].  class compileTree: modifiedParseTreeaddUndo: aRefactoringChange  undo push: aRefactoringChange.  undo size > UndoSize ifTrue: [ undo removeFirst ].  redo := OrderedCollection newmatches: aString  ^RBSelectorEnvironment matches: aString in: selfsearchingLiteral  ^self printString = #a or: [ #() = self printString | (#() == self printString) ]testTransform  | transformation |  transformation := (RBPushDownVariableTransformation instanceVariable: 'foo1' class: #RBDummyLintRuleTest) transform.  (transformation model classNamed: #RBDummyLintRuleTest) subclasses do: [:each |  self assert: (each directlyDefinesInstanceVariable: 'foo1') ]rbClassClass  ^RBClass2preconditions  ^RBCondition emptyviewResults  builder inspect.  self resetResulttestTransform  | transformation class |  transformation := (RBAddMethodTransformation sourceCode: 'printString1 ^super printString' in: self changeMock name withProtocol: #accessing) transform.  class := transformation model classNamed: self changeMock name.  self assert: (class parseTreeFor: #printString1) equals: (self parseMethod: 'printString1 ^super printString')preconditions  | conditions |  conditions := (RBCondition withBlock: [ self haveSameNumberOfArgs.        true ]) & (RBCondition definesSelector: oldSelector in: class) & (RBCondition definesSelector: newSelector in: class).  ^conditions & (RBCondition withBlock: [ | senders |              senders := self model allReferencesTo: oldSelector.              senders size > 1 ifTrue: [ self refactoringWarning: ('This will modify all <1p> senders.' expandMacrosWith: senders size) ].              true ])hasConflicts  ^trueclassObjectFor: anObject  (anObject isBehavior or: [ anObject isTrait ]) ifTrue: [ ^self classFor: anObject ].  anObject isSymbol ifTrue: [ ^self classNamed: anObject ].  ^anObjecttestNonExistantName  self shouldFail: (RBAbstractClassVariableRefactoring variable: #Foo class: RBBasicLintRuleTestData)testRefactoring  | refactoring |  self assert: (RBDummyEmptyClass organization protocolOrganizer protocolNamed: 'empty protocol 2') isEmpty.  refactoring := (RBMethodProtocolTransformation protocol: 'empty protocol 2' inMethod: #someMethod inClass: #RBDummyEmptyClass) asRefactoring transform.  RBRefactoryChangeManager instance performChange: refactoring changes.  self deny: (RBDummyEmptyClass organization protocolOrganizer protocolNamed: 'empty protocol 2') isEmpty.  refactoring := (RBMethodProtocolTransformation protocol: 'empty protocol 1' inMethod: #someMethod inClass: #RBDummyEmptyClass) asRefactoring transform.  RBRefactoryChangeManager instance performChange: refactoring changes.  self assert: (RBDummyEmptyClass organization protocolOrganizer protocolNamed: 'empty protocol 2') isEmptychangeString  ^'Add class variable <1s> to <2s>' expandMacrosWith: self variable with: self displayClassNamerefactoringWarning: aString  ^RBRefactoringWarning signal: aStringcheckSingleAssignment: varName  ((RBReadBeforeWrittenTester isVariable: varName readBeforeWrittenIn: extractedParseTree) or: [ extractedParseTree containsReturn ]) ifTrue: [ self refactoringError: 'Cannot extract assignments to temporaries without all references' ].  extractedParseTree addNode: (RBReturnNode value: (RBVariableNode named: varName)).  modifiedParseTree := RBParseTreeRewriter replace: self methodDelimiter with: varName , ' := ' , self methodDelimiter in: modifiedParseTreeorderOcurrences: ocurrences  ^ocurrences asOrderedCollection sort: [:first :second |  first key first < second key first ]variable: aVarName class: aClass  class := self classObjectFor: aClass.  variableName := aVarNamewithBlock: aBlock  block := aBlock.  type := #(#generic)initialize  methodBlock := [  ].  environment := RBBrowserEnvironment new.  context := RBSmalllintContext newNoCachetestTransform  | transformation class |  transformation := (RBReplaceSubtreeTransformation replace: '^ 1' to: '^ 123' inMethod: #one inClass: self changeMock name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self changeMock name asSymbol.  self assert: (class directlyDefinesMethod: #one).  self assert: (class parseTreeFor: #one) body statements size equals: 1.  self assert: (class parseTreeFor: #one) body statements first isReturn.  self assert: (class parseTreeFor: #one) body statements first value value equals: 123privateTransform  isClassVariable ifTrue: [ self definingClass theNonMetaClass renameClassVariable: variableName to: newVariableName around: [ self renameReferences ] ] ifFalse: [ self definingClass renameInstanceVariable: variableName to: newVariableName around: [ self renameReferences ] ]testRefactoring  | refactoring class |  refactoring := (RBAddMessageSendTransformation messageSend: 'variable byteAt: 1' inMethod: #methodBefore inClass: #RBAddMessageSendTransformationTest) asRefactoring transform.  self assert: refactoring model changes changes size equals: 1.  class := refactoring model classNamed: #RBAddMessageSendTransformationTest.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) bodyconnectToChanges  SystemAnnouncer uniqueInstance weak when: CategoryAdded , CategoryRemoved , CategoryRenamed , ClassAdded , ClassModifiedClassDefinition , ClassRemoved , ClassRenamed , ClassReorganized , MethodAdded , MethodModified , MethodRemoved , ProtocolAdded , ProtocolRemoved send: #update: to: selfanInstVar: anObject  anInstVar := anObjectpackages  ^self subclassResponsibilitytestPerformChangeClass  | change |  change := changes defineClass: self class name , ' subclass: #' , self changeMock name , '	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	category: ''' , self class category , ''''.  self perform: change do: [ self assert: change changeClass superclass equals: self class.        self assertEmpty: change changeClass instVarNames ].  self assert: change changeClass superclass equals: Object.  self denyEmpty: change changeClass instVarNames.  self assert: change definedClass equals: self changeMockrbNamespace  ^self class rbNamespacenewName: anObject  newName := anObjectabstractUnaryAccessingMethodWithoutReturn  self subclassResponsibilitytestPerformAddRemoveClassInteractively  | change |  change := changeFactory addClassDefinition: 'Object subclass: #' , self changeMock name , 'Temporary	instanceVariableNames: ''''	classVariableNames: ''''	poolDictionaries: ''''	package: ''' , self class category , '''' for: self.  self perform: change do: [ self assert: (workingEnvironment hasClassNamed: change changeClassName).        self assert: change definedClass name equals: change changeClassName.        self assert: change definedClass isBehavior ].  self deny: (workingEnvironment hasClassNamed: change changeClassName).  self assert: change definedClass isObsoletetestCreation  | rbmethod |  rbmethod := RBMethodName selector: #foo: arguments: #('x').  self assert: rbmethod selector equals: #foo:.  self assert: rbmethod arguments equals: #('x')transform  self     inlineSelfSends;     removeMethod;     checkInlinedMethodsclassForTestResult  ^TestResultvalidateRenameNode: aParseTree withOldName: oldName toWithName: newName  | conditions block |  conditions := (RBCondition isValidInstanceVariableName: newName for: class) & (RBCondition definesSelector: selector in: class) & (RBCondition definesInstanceVariable: newName in: class) not & (RBCondition definesClassVariable: newName in: class) not.  conditions check ifFalse: [ block := conditions errorBlock.        block ifNotNil: [ self refactoringError: conditions errorString with: block ] ifNil: [ self refactoringError: conditions errorString ] ].  (parameterMap values includes: newName) ifTrue: [ self refactoringError: newName asString , ' is already defined as parameter' ].  (aParseTree whoDefines: newName) ifNotNil: [ self refactoringError: newName asString , ' is already defined' ].  (aParseTree allDefinedVariables includes: newName) ifTrue: [ self refactoringError: newName asString , ' is already defined' ]oldName  ^oldNameremoveMethods: selectorCollection from: aClass  class := self classObjectFor: aClass.  selectors := selectorCollectioncheckAssignmentsToVariable  | searcher |  variable ifNotNil: [ searcher := self parseTreeSearcher.        searcher matches: variable , ' := `@object' do: [:aNode :answer |  true ].        (searcher executeTree: parseTree initialAnswer: false) ifTrue: [ self refactoringError: ('Cannot move the method into <1s> since it is assigned' expandMacrosWith: variable) ] ]should: aBlock raise: anExceptionalEvent whoseDescriptionIncludes: substring description: aString  ^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionContaining: substring) description: aStringasRefactoring  ^super asRefactoring     delegatesPreconditions: false;     yourselftestModelPushDownVariableToClassDownTwoLevels  | class |  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  class := model metaclassNamed: #AnotherSubclass.  class compile: 'bar ^Foo' classified: #(#accessing).  class := class instanceSide.  self executeRefactoring: (RBPushDownClassVariableRefactoring model: model variable: #Foo class: class superclass superclass).  self deny: (class superclass superclass directlyDefinesClassVariable: #Foo).  self deny: (class superclass directlyDefinesClassVariable: #Foo).  self assert: (class directlyDefinesClassVariable: #Foo)testReferencesPrintOn  | hasFoundObject hasFoundSelf smalltalk |  hasFoundObject := false.  hasFoundSelf := false.  smalltalk := modelFactory rbNamespace new.  smalltalk allReferencesTo: #printOn: do: [:each |  hasFoundObject := hasFoundObject or: [ each selector = #fullPrintString and: [ each modelClass = (smalltalk classNamed: #Object) ] ].        hasFoundSelf := hasFoundSelf or: [ each selector = #testReferencesPrintOn and: [ each modelClass = (smalltalk classNamed: self class name) ] ] ].  self assert: hasFoundObject.  self assert: hasFoundSelfpullUpInstanceVariables  | newSuperclass |  newSuperclass := self abstractSuperclass.  parent instanceVariableNames do: [:each |  self performComponentRefactoring: (RBPullUpInstanceVariableRefactoring model: self model variable: each class: newSuperclass) ]replace: aFindString with: aReplaceString ignoreCase: aBoolean  | regex stream |  regex := RxParser preferredMatcherClass for: (RxParser new parse: aFindString) ignoreCase: aBoolean.  stream := aReplaceString readStream.  matchers add: regex -> streamreturnsIfTrue  ^self isNil ifTrue: [ 4 ]transform  | oldClass newClass rbMethod originalProtocol |  oldClass := self classModelOf: method methodClass.  newClass := self classModelOf: class.  rbMethod := RBClassModelFactory rbMethod for: newClass source: method sourceCode selector: method selector.  originalProtocol := method protocol.  oldClass removeMethod: method selector.  newClass addMethod: rbMethod.  newClass compile: rbMethod source classified: {originalProtocol}calls  ^self rewriteRule1: self name , self rewriteRule1includesCategory: aCategory  ^(super includesCategory: aCategory) and: [ environmentDictionaries anySatisfy: [:env |  env includesCategory: aCategory ] ]changeString  ^self class namedefinedClass  ^definedClassresetResult  classBlock: aBlock  classBlock := aBlock testMethod1checkForSuperReferences  | searcher |  searcher := self parseTreeSearcher.  searcher matches: 'super `@message: `@args' do: [:aNode :answer |  true ].  (searcher executeTree: parseTree initialAnswer: false) ifTrue: [ self refactoringError: 'Cannot move the method since it has a super message send.' ]performChange: aRefactoringChange  self ignoreChangesWhile: [ self addUndo: aRefactoringChange execute ]classVariablesFor: aClass  ^classVariables at: aClass name ifAbsent: [ #() ]storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' move: ''';     nextPutAll: category;     nextPutAll: ''' to: ';     nextPutAll: className.  aStream nextPut: $)selectedSource  | source |  source := class sourceCodeFor: selector.  source ifNil: [ self refactoringFailure: 'Couldn''t find sources' ].  ((sourceInterval first between: 1 and: source size) and: [ sourceInterval last between: 1 and: source size ]) ifFalse: [ self refactoringFailure: 'Invalid interval' ].  ^source copyFrom: sourceInterval first to: sourceInterval lastsuperSends  | rule |  rule := self parseTreeRewriter.  rule addSearch: 'super `@message: ``@args' -> ([:aNode |  (class withAllSubclasses detect: [:each |  each includesSelector: aNode selector ] ifNone: [ nil ]) isNil ] -> 'self `@message: ``@args').  self rewriteUsing: ruleassignmentInBlock  [ ^self printString ] ensure: [ self close ]testBadInterval  self     shouldFail: (RBInlineMethodRefactoring inline: (13 to: 23) inMethod: #testMethod forClass: RBRefactoryTestDataApp);     shouldFail: (RBInlineMethodRefactoring inline: (14 to: 17) inMethod: #testMethod forClass: RBRefactoryTestDataApp);     shouldFail: (RBInlineMethodRefactoring inline: (24 to: 30) inMethod: #testMethod forClass: RBRefactoryTestDataApp);     shouldFail: (RBInlineMethodRefactoring inline: (1 to: 30) inMethod: #testMethod forClass: RBRefactoryTestDataApp)storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' messageSend: ''';     nextPutAll: message;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: aStream.  aStream nextPut: $)removeOldVariable  self flag: #todo.  (RBRemoveInstanceVariableChange remove: oldName from: self changeClass) executemyConditions  ^RBCondition withBlock: [ oldSelector numArgs + 1 = newSelector numArgs ifFalse: [ self refactoringFailure: newSelector printString , ' doesn''t have the proper number of arguments.' ].        self verifyInitializationExpression.        true ]preconditions  | references |  references := RBCondition hierarchyOf: class referencesInstanceVariable: variableName.  class realClass ifNil: [ references errorMacro: ('<1s> is referenced.' expandMacrosWith: variableName) ] ifNotNil: [ references           errorMacro: ('<1s> is referenced.<n>Browse references?' expandMacrosWith: variableName);           errorBlock: [ self openBrowserOn: (RBBrowserEnvironment new instVarRefsTo: variableName in: class realClass) ] ].  ^(RBCondition definesInstanceVariable: variableName asString in: class) & references notsafeVariableNameBasedOn: aString  | baseString newString i allTempVars |  allTempVars := inlineParseTree allTemporaryVariables.  baseString := aString copy.  baseString at: 1 put: baseString first asLowercase.  newString := baseString.  i := 0.  [ (allTempVars includes: newString) or: [ class definesInstanceVariable: newString ] ] whileTrue: [ i := i + 1.        newString := baseString , i printString ].  ^newStringhash  ^self name hash bitXor: self class hashoptions  ^options ifNil: [ options := self class refactoringOptions copy ]name  ^'Check for same statements at end of ifTrue:ifFalse: blocks'preconditions  ^isClassVariable ifTrue: [ self preconditionsForClassVariable ] ifFalse: [ self preconditionsForInstanceVariable ]testClassVariableToMultipleSubclassesFailure  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''''			classVariableNames: ''Foo''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model classNamed: #Subclass) compile: 'foo ^Foo' classified: #(#accessing).  model defineClass: 'SomeClass subclass: #AnotherSubclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model metaclassNamed: #AnotherSubclass) compile: 'bar ^Foo' classified: #(#accessing).  self shouldFail: (RBPushDownVariableTransformation model: model classVariable: #Foo class: (model classNamed: #SomeClass)) asRefactoringclassFor: aBehavior  aBehavior ifNil: [ ^nil ].  ^aBehavior isMeta ifTrue: [ self metaclassNamed: aBehavior instanceSide name ] ifFalse: [ self classNamed: aBehavior instanceSide name ]testVariableDoesNotExist  self shouldFail: (RBRemoveTemporaryVariableTransformation variable: 'temp123' inMethod: #foo inClass: #RBRemoveTemporaryVariableTransformationTest) asRefactoringtestAddClassTraitPattern  self exampleTraits do: [:trait |  | change |        change := changes defineClass: trait classTrait definition.        self assert: (change isKindOf: RBAddClassTraitChange).        self assert: change changeClassName equals: trait name.        self universalTestFor: change ]includesGlobal: aSymbol  (self hasRemoved: aSymbol) ifTrue: [ ^false ].  (self includesClassNamed: aSymbol) ifTrue: [ ^true ].  environment at: aSymbol ifAbsent: [ ^false ].  ^trueperformChange: aCompositeRefactoryChange around: aBlock  | oldChanges |  changes addChange: aCompositeRefactoryChange.  oldChanges := changes.  changes := aCompositeRefactoryChange.  aBlock ensure: [ changes := oldChanges ].  ^aCompositeRefactoryChangekeywords: aCollection  keywords addAll: aCollectionchangeClass  | class |  class := onSystemDictionary classNamed: self changeClassName.  ^isMeta ifTrue: [ class class ] ifFalse: [ class ]initialize  super initialize.  rewriteRule := RBParseTreeRewriter newfailedRules  ^rules inject: OrderedCollection new into: [:oc :each |  oc           addAll: each failedRules;           yourself ]packages  ^self methods collect: [:m |  m package ]setterMethodFor: aVariableName  | matcher candidateSetters |  matcher := self parseTreeSearcherClass setterMethod: aVariableName.  candidateSetters := (self definesInstanceVariable: aVariableName) ifTrue: [ self whichSelectorsReferToInstanceVariable: aVariableName ] ifFalse: [ self whichSelectorsReferToClassVariable: aVariableName ].  candidateSetters := candidateSetters select: [:each |  each numArgs == 1 ].  ^candidateSetters detect: [:each |  (self checkSelector: each using: matcher) notNil and: [ (self subclassRedefines: each) not ] ] ifNone: [ nil ]testTransform  | transformation newClassName class |  newClassName := (self changeMock name , 'Temporary') asSymbol.  transformation := RBCompositeTransformation new transformations: (OrderedCollection new           add: (RBAddClassTransformation addClass: newClassName superclass: #Object subclasses: #() category: self class category);           add: (RBAddVariableTransformation instanceVariable: 'asdf' class: newClassName);           add: (RBAddMethodTransformation sourceCode: 'printString1 ^super printString' in: newClassName withProtocol: #accessing);           yourself).  transformation transform.  self assert: transformation model changes changes size equals: 3.  class := transformation model classNamed: (self changeMock name , 'Temporary') asSymbol.  self assert: (class directlyDefinesInstanceVariable: 'asdf').  self assert: (class parseTreeFor: #printString1) equals: (self parseMethod: 'printString1 ^super printString')checkMethodsForClass: aClass  ^environment selectorsForClass: aClass do: [:each |  rule checkMethod: aClass >> each.        methodBlock value ]move: aClassName to: aCategoryName  self className: aClassName.  category := aCategoryNametestRefactoring  | transformation class |  transformation := (RBExtractMethodTransformation extract: '(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)			ifFalse: [builder						compile: rewriteRule tree printString						in: class						classified: aSmalllintContext protocols]' from: #checkMethod: to: #foo: in: #RBTransformationRuleTestData) asRefactoring transform.  self assert: transformation model changes changes size equals: 2.  class := transformation model classNamed: #RBTransformationRuleTestData.  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 			class := aSmalllintContext selectedClass.			(rewriteRule executeTree: aSmalllintContext parseTree)				ifTrue: [self foo: aSmalllintContext]').  self assert: (class parseTreeFor: #foo:) equals: (self parseMethod: 'foo: aSmalllintContext 			(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)				ifFalse: [ builder							compile: rewriteRule tree printString							in: class							classified: aSmalllintContext protocols ]')instanceVariableWriters: anObject  instanceVariableWriters := anObjecttypeOfClassVariable: aSymbol  ^model classNamed: #Objectcalled: anObject on: aBlock  Transcript     show: anObject printString;     cr.  aBlock valueincludesSelector: aSelector in: aClass  ^(super includesSelector: aSelector in: aClass) and: [ environmentDictionaries anySatisfy: [:env |  env includesSelector: aSelector in: aClass ] ]associationForClassVariable: aName in: aClass ifAbsent: aBlock  ^aClass realClass classPool associationAt: aName asSymbol ifAbsent: [ aClass realClass classPool associationAt: aName asString ifAbsent: aBlock ]setUp  super setUp.  model := self abstractVariableTestDatapushUpVariables  self pullUpInstanceVariables.  self pullUpClassInstanceVariables.  self pullUpClassVariables.  self pullUpPoolVariablescheckNewVariable: aParseTree  aParseTree ifNil: [ self refactoringError: ('Temporary variable named {1} is not defined by this method.' format: {variableName asString}) ].  (aParseTree whoDefines: newVariableName) ifNotNil: [ self refactoringError: ('Temporary variable named {1} is already defined.' format: {newVariableName asString}) ].  (aParseTree allDefinedVariables includes: newVariableName) ifTrue: [ self refactoringError: ('Temporary variable named {1} is already defined.' format: {newVariableName asString}) ]testModelRenameSequenceClass  model defineClass: 'Object subclass: #Foo1 			instanceVariableNames: '''' 			classVariableNames: '''' poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model classNamed: #Foo1)     compile: 'foo	 ^ Foo1' classified: #(accessing);     compile: 'objectName ^ #(Foo1)' classified: #(accessing).  self executeRefactoring: (RBRenameClassRefactoring model: model rename: (model classNamed: #Foo1) to: #Foo2).  self executeRefactoring: (RBRenameClassRefactoring model: model rename: (model classNamed: #Foo2) to: #Foo3).  self deny: (model includesClassNamed: #Foo1).  self deny: (model includesClassNamed: #Foo2).  self assert: (model includesClassNamed: #Foo3).  self assert: ((model classNamed: #Foo3) parseTreeFor: #foo) equals: (self parseMethod: 'foo ^ Foo3').  self assert: ((model classNamed: #Foo3) parseTreeFor: #objectName) equals: (self parseMethod: 'objectName ^ #(Foo3)')isEmpty  ^classes isEmpty and: [ metaClasses isEmpty ]copyOptionsFrom: aDictionary  | dict |  dict := self options.  dict == self class refactoringOptions ifTrue: [ ^self options: aDictionary copy ].  dict keysAndValuesDo: [:key :value |  value == (self class refactoringOptions at: key) ifTrue: [ dict at: key put: (aDictionary at: key) ] ].  self options: dicttestWithTemporaryAssigned  | class method refactoring |  model := RBNamespace2 new.  class := model classNamed: self class name.  method := 'foo			| temp bar |			bar := 5.			temp := bar * bar.			Transcript show: temp printString; cr.			^temp * temp'.  class compile: method classified: #(#accessing).  refactoring := (RBExtractMethodTransformation model: model extract: (method copyFrom: 24 to: 98) from: #foo to: #foobar in: class) asRefactoring transform.  self assert: refactoring model changes changes size equals: 4.  self assert: (class parseTreeFor: #foo) equals: (self parseMethod: 'foo | temp | temp := self foobar. ^temp * temp').  self assert: (class parseTreeFor: #foobar) equals: (self parseMethod: 'foobar | temp bar | bar := 5. temp := bar * bar. Transcript show: temp printString; cr. ^temp.')at: aKey ifAbsent: aBlock  | association |  association := self associationAt: aKey ifAbsent: [ nil ].  ^association ifNil: [ aBlock value ] ifNotNil: [ association value ]addProtocolNamed: aString in: aClass  ^self addChange: (RBAddProtocolChange addProtocolNamed: aString in: aClass)privateTransform  | tree oldTree newTree |  tree := self definingClass parseTreeFor: selector.  tree ifNil: [ ^self ].  oldTree := tree extractSubtreeWith: oldSourceCode.  oldTree ifNil: [ ^self ].  newTree := self parserClass parseExpression: newSourceCode onError: [:string :pos |  ^nil ].  newTree ifNil: [ ^self ].  tree := oldTree isSequence ifTrue: [ self parseTreeRewriterClass replaceStatements: oldTree formattedCode with: newSourceCode in: tree ] ifFalse: [ self parseTreeRewriterClass replace: oldTree formattedCode with: newSourceCode in: tree onInterval: tree sourceInterval ].  self definingClass compileTree: treemethodsDo: aBlock  self classesDo: [:aClass |  self selectorsForClass: aClass do: [:selector |  aBlock value: aClass >> selector ].        self selectorsForClass: aClass class do: [:selector |  aBlock value: aClass class >> selector ] ]uniqueMethodNameFor: anInteger  | before after index name |  before := 'a'.  after := ''.  anInteger timesRepeat: [ after := after , 'z:' ].  index := 0.  [ name := before , index printString , after.  (Symbol findInterned: name) notNil ] whileTrue: [ index := index + 1 ].  ^name asSymboltestSelectorEnvironment  | printString |  printString := RBBrowserEnvironment new referencesTo: #printString.  self universalTestFor: printString.  self deny: universalEnvironment isSelectorEnvironment.  self assert: printString isSelectorEnvironment.  self assert: printString numberSelectors equals: (printString referencesTo: #printString) numberSelectors.  self assert: printString numberClasses equals: (printString referencesTo: #printString) numberClassescheckInstanceVariableName: aName in: aClass  ^RBCondition checkInstanceVariableName: aName in: aClassstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' rename: '.  variableName storeOn: aStream.  aStream nextPutAll: ' to: '.  newVariableName storeOn: aStream.  aStream nextPutAll: ' class: '.  class storeOn: aStream.  aStream nextPutAll: ' classVariable: '.  isClassVariable storeOn: aStream.  aStream nextPut: $)changeString  ^'Define ' , self displayClassNamemethod  ^compiledMethodpreconditions  self subclassResponsibilityhash  ^self class hash bitXor: self changes size hashtestRefactoring  | transformation class |  transformation := (RBReplaceSubtreeTransformation replace: 'selector := aSelector' to: '^ selector' inMethod: #selector:from: inClass: #RBRemoveMethodTransformation) asRefactoring transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: #RBRemoveMethodTransformation.  self assert: (class directlyDefinesMethod: #selector:from:).  self assert: (class parseTreeFor: #selector:from:) body statements size equals: 2.  self assert: (class parseTreeFor: #selector:from:) body statements last isReturnsetUp  super setUp.  model := self abstractVariableTestDatatestVariableDoesNotExist  self shouldFail: (RBRenameTemporaryVariableTransformation rename: #rule to: #name in: #RBLintRuleTestData selector: #openEditor)testRefactoring  self     shouldFail: (RBAddSubtreeTransformation interval: (0 to: 1) with: ':= 123' from: #selector:from: in: #RBRemoveMethodTransformation) asRefactoring;     shouldFail: (RBAddSubtreeTransformation interval: (0 to: 1) with: '^ selector' from: #selector:for: in: #RBRemoveMethodTransformation) asRefactoringsendInlineParameterMethod  ^self inlineParameterMethod: #(#asdf)problemCount  ^builder problemCountstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' pragma: ''';     nextPutAll: pragma;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: aStream.  aStream nextPut: $)testExtractToTemporaryWithDuplicates  | refactoring |  refactoring := RBExtractToTemporaryRefactoring extract: (73 to: 77) to: 'temp' from: #demoMethodWithDuplicates in: RBRefactoryTestDataApp.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #demoMethodWithDuplicates) equals: (self parseMethod: 'demoMethodWithDuplicates	| a b result1 result2 answer temp |	a := 3.	temp := a + 5.	b := temp.	result1 := a + b.	result2 := temp.	answer := result1 + result2 + temp.	^ answer')rootClass  ^rootClass ifNil: [ Object ]whichSelectorsReferToClassVariable: aString  | selectors |  selectors := Set new.  newMethods ifNotNil: [ newMethods do: [:each |  (each refersToVariable: aString) ifTrue: [ selectors add: each selector ] ] ].  self isDefined ifTrue: [ selectors addAll: (self existingMethodsThatReferToClassVariable: aString) ].  ^selectorstheMetaClass  ^model metaclassNamed: self namenewName  ^newNamecalculateAssignments  ^assignments ifNil: [ | sequenceNode whoDefinesTemp |        sequenceNode := (parseTree allChildren select: #isSequence) last.        assignments := temporaries select: [:temp |  whoDefinesTemp := sequenceNode whoDefines: temp.              whoDefinesTemp statements anySatisfy: [:statement |  (statement references: temp) and: [ (subtree allChildren includes: statement) not ] ] ] ]storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' variable: ''';     nextPutAll: variableName;     nextPutAll: ' value: ''';     nextPutAll: value;     nextPutAll: ' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: ''';     nextPutAll: className.  aStream nextPut: $)check: anEntity ifNoCritiques: alternativeBlock  | critics |  critics := OrderedCollection new.  self check: anEntity forCritiquesDo: [:critic |  critics add: critic ] ifNone: alternativeBlock.  ^criticspreconditions  ^(RBCondition definesSelector: selector in: self definingClass) & (RBCondition withBlock: [ self parserClass parseExpression: sourceCode onError: [:string :pos |  self refactoringError: 'Invalid source to add - ' , string ].              true ])debbuggingMessageSent  self rearmOneShottestClassEnvironment  | aClassEnvironment |  aClassEnvironment := RBClassEnvironment onEnvironment: universalEnvironment classes: (Array with: Object with: Object class).  self universalTestFor: aClassEnvironment.  self deny: universalEnvironment isClassEnvironment.  self assert: aClassEnvironment isClassEnvironment.  self assert: aClassEnvironment packages size equals: 1.  self assert: (aClassEnvironment implementorsOf: #printString) numberSelectors equals: 1.  self assert: (RBClassEnvironment class: Class) selectors size equals: Class methods size.  self assert: (RBClassEnvironment class: TSortable) selectors size equals: TSortable methods sizeisPrimitive  ^inlineParseTree isPrimitivereference  ^RBDummyClassToRename newaddMethodSource: sourceCode in: aClass classified: aProtocol for: aController  ^RBAddMethodChange compile: sourceCode in: aClass classified: aProtocol for: aControllerpreconditions  ^classVariable ifTrue: [ RBCondition definesClassVariable: variableName asSymbol in: class ] ifFalse: [ RBCondition definesInstanceVariable: variableName in: class ]whileTrue  | i |  i := 1.  [ i < self size ] whileTrue: [ (self at: i) printString.        i := i + 1 ]redoOperation  redo ifEmpty: [ ^self ].  self ignoreChangesWhile: [ | change |        change := redo removeLast.        undo add: change execute ]preconditions  | cond |  cond := ((RBCondition isMetaclass: superclass) errorMacro: 'Superclass must not be a metaclass') not.  cond := subclasses inject: cond into: [:sub :each |  sub & ((RBCondition isMetaclass: each) errorMacro: 'Subclass must <1?not :>be a metaclass') not & (RBCondition isImmediateSubclass: each of: superclass) ].  ^cond & (RBCondition isValidClassName: className) & (RBCondition isGlobal: className in: self model) not & (RBCondition isSymbol: category) & ((RBCondition withBlock: [ category isNotEmpty ]) errorMacro: 'Invalid category name')testTemporaryToInstanceVariable  | refactoring class |  refactoring := RBTemporaryToInstanceVariableRefactoring class: RBLintRuleTestData selector: #displayName variable: 'nameStream'.  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBLintRuleTestData.  self assert: (class parseTreeFor: #displayName) equals: (self parseMethod: 'displayName								nameStream := WriteStream on: (String new: 64).								nameStream									nextPutAll: self name;									nextPutAll: '' (''.								self problemCount printOn: nameStream.								nameStream nextPut: $).								^nameStream contents').  self assert: (class directlyDefinesInstanceVariable: 'nameStream')bindingOf: aString  ^self realClass classPool associationAt: aString asSymbol ifAbsent: [ self realClass classPool associationAt: aString asString ifAbsent: [ nil ] ]abstractVariableTestData  | newModel classEnvironment classes |  classes := #(#Bar #Foo) inject: OrderedCollection new into: [:sum :each |  testingEnvironment at: each ifPresent: [:class |  sum                 add: class;                 add: class class ].        sum ].  classEnvironment := RBClassEnvironment classes: classes.  newModel := RBNamespace2 onEnvironment: classEnvironment not.  newModel name: 'Test'.  #('Object subclass: #Foo		instanceVariableNames: ''instVarName1 instVarName2''		classVariableNames: ''ClassVarName1 ClassVarName2 ''		poolDictionaries: ''''		category: ''Testing'' ' 'Foo subclass: #Bar		instanceVariableNames: ''''		classVariableNames: ''''		poolDictionaries: ''''		category: ''Testing'' ') do: [:each |  newModel defineClass: each ].  #(#(#Bar #(#('instVarName1			^1242321' #tests) #('foo			instVarName1 := instVarName1 + instVarName2 + ClassVarName1' #tests))) #(#Foo #(#('foo			^instVarName2 := 3' #tests) #('bar			"Add one to instVarName1"			instVarName1 := instVarName1 + 1' #tests) #('classVarName1			^ClassVarName1' #tests) #('instVarName1: anObject			^anObject' #tests) #('asdf			^self classVarName1: (ClassVarName1 := ClassVarName1 + 1)' #tests) #('instVarName2			^instVarName2' #tests) #('instVarName2: anObject			instVarName2 := anObject' #tests) #('classVarName1: anObject			^ClassVarName1 := anObject' #tests))) #('Bar class' #(#('classVarName2: anObject			ClassVarName2 := anObject' #tests) #('classVarName2			^ClassVarName2' #tests))) #('Foo class' #(#('foo			^ClassVarName1 := ClassVarName1 * ClassVarName1 * ClassVarName1' #tests)))) do: [:each |  | class |        class := newModel classNamed: each first.        each last do: [:methodPair |  class compile: methodPair first classified: methodPair last ] ].  ^newModel= aRBClass  ^self class = aRBClass class and: [ self name = aRBClass name and: [ self model = aRBClass model ] ]problemCount  ^result problemCountcomputeNewSelector  | keywords |  oldSelector numArgs == 0 ifTrue: [ self refactoringFailure: 'This method contains no arguments' ].  oldSelector isInfix ifTrue: [ self refactoringFailure: 'Cannot remove parameters of infix selectors' ].  keywords := oldSelector keywords asOrderedCollection.  keywords size = 1 ifTrue: [ ^(keywords first copyWithout: $:) asSymbol ].  keywords removeAt: parameterIndex.  ^(String streamContents: [:str |  keywords do: [:each |  str nextPutAll: each ] ]) asSymbolabstractReferenceTo: each  | setterMethod replacer accessorRef getterMethod |  accessorRef := RBCreateAccessorsForVariableRefactoring variable: each class: newClass classVariable: false.  self performComponentRefactoring: accessorRef.  getterMethod := accessorRef getterMethod.  setterMethod := accessorRef setterMethod.  replacer := RBParseTreeRewriter variable: each getter: getterMethod setter: setterMethod receiver: referenceVariableName.  self convertClasses: class withAllSubclasses select: [:aClass |  aClass whichSelectorsReferToInstanceVariable: each ] using: replacer.  self performComponentRefactoring: (RBRemoveInstanceVariableRefactoring remove: each from: class)defineClass: aString  | change newClass newClassName |  change := changes defineClass: aString.  newClassName := change changeClassName.  newClass := self classNamed: newClassName.  newClass ifNil: [ | newMetaclass |        self unmarkAsRemoved: ' class'.        newClass := self rbClassClass named: newClassName.        newMetaclass := self rbMetaclassClass named: newClassName.        newClass model: self.        newMetaclass model: self.        newClasses at: newClassName put: (Array with: newClass with: newMetaclass) ].  newClass superclass: (self classNamed: change superclassName).  newClass superclass ifNil: [ self rootClasses add: newClass.        newClass theMetaClass superclass: (self classFor: Object class superclass) ] ifNotNil: [ newClass theMetaClass superclass: newClass superclass theMetaClass ].  newClass instanceVariableNames: change instanceVariableNames.  newClass classVariableNames: change classVariableNames.  newClass poolDictionaryNames: change sharedPoolNames.  newClass category: change category.  ^changetestPullUpReferencesInstVar  self shouldFail: (RBPullUpMethodRefactoring pullUp: #(#checkClass:) from: RBBasicLintRuleTestData)transform  self renameImplementors.  self renameMessageSends.  self removeRenamedImplementorstestModelRenameClass  | refactoring replacement deprecated user |  model defineClass: 'Object subclass: #ClassDeprecatorTestingClassReplacement instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'ClassDeprecatorTestingClassReplacement subclass: #ClassDeprecatorTestingClassDeprecated instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'ClassDeprecatorTestingClassDeprecated subclass: #ClassDeprecatorTestingClassDeprecatedUser instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  replacement := model classNamed: #ClassDeprecatorTestingClassReplacement.  deprecated := model classNamed: #ClassDeprecatorTestingClassDeprecated.  user := model classNamed: #ClassDeprecatorTestingClassDeprecatedUser.  user     compile: 'foo	^ClassDeprecatorTestingClassDeprecated' classified: #(#accessing);     compile: 'objectName ^#(ClassDeprecatorTestingClassDeprecated)' classified: #(#accessing).  refactoring := RBApplyClassDeprecationRefactoring model: model rename: deprecated to: #ClassDeprecatorTestingClassReplacement.  refactoring shouldCopyExtensions: false.  refactoring shouldRemoveExtensions: false.  self executeRefactoring: refactoring.  self assert: (model includesClassNamed: #ClassDeprecatorTestingClassReplacement).  self assert: (model includesClassNamed: #ClassDeprecatorTestingClassDeprecated).  self assert: (model includesClassNamed: #ClassDeprecatorTestingClassDeprecatedUser).  self assert: (model classNamed: #ClassDeprecatorTestingClassReplacement) equals: replacement.  self assert: (model classNamed: #ClassDeprecatorTestingClassDeprecated) equals: deprecated.  self assert: (model classNamed: #ClassDeprecatorTestingClassDeprecatedUser) equals: user.  self assert: (user parseTreeFor: #foo) equals: (self parseMethod: 'foo ^ClassDeprecatorTestingClassReplacement').  self assert: (user parseTreeFor: #objectName) equals: (self parseMethod: 'objectName ^#(ClassDeprecatorTestingClassReplacement)').  self assert: user superclass name equals: #ClassDeprecatorTestingClassReplacementpackages  ^self rootEnvironment packages select: [:package |  self includesPackage: package ]resetResult  super resetResult.  self result matcher: self matchertestRecursiveMethod  | refactoring class selector otherClass |  class := model classNamed: #Object.  selector := 'someMethodThatIsNotReferenced' asSymbol.  class compile: 'someMethodThatIsNotReferenced ^2' classified: #(#accessing).  self assert: (class definesMethod: selector).  otherClass := model metaclassNamed: self class superclass name.  otherClass compile: 'someMethodThatIsNotReferenced ^3 someMethodThatIsNotReferenced' classified: #(#accessing).  model removeClassNamed: self class name.  refactoring := (RBRemoveMethodTransformation model: model selector: selector from: class) asRefactoring.  [ refactoring transform ] on: RBRefactoringError do: [:e |  e resume ].  self deny: (class definesMethod: selector)testPullUpClassMethod  | class |  class := model classNamed: #Object.  class addClassVariable: #Foo.  class classSide compile: 'foo ^Foo' classified: #(#accessing).  self shouldFail: (RBPullUpMethodRefactoring model: model pullUp: #(#foo) from: class classSide)whatToDisplayIn: aChangeBrowser  ^{self}forPragmas: aKeywordCollection  ^RBPragmaEnvironment onEnvironment: self keywords: aKeywordCollectionstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' return: ''';     nextPutAll: returnValue;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: aStream.  aStream nextPut: $)buildSimpleVariableSearch  self createSearchWith: 'result' selectors: #(#checkClass: #checkMethod: #isEmpty #problemCount #resetResult #resetResult #resetResult #result #result: #resultClass: #newResultClass: #viewResults) inClass: RBBasicLintRuleTestDataprecedence  ^self isArray ifFalse: [ (self block + 5) * 34 ] ifTrue: [ self printString = 10 ]changeClassName  ^classNameallExpressionsToInline  | coll |  coll := Set new.  self model allReferencesTo: oldSelector do: [:each |  | tree |        tree := each parseTree.        tree ifNotNil: [ coll addAll: (self expressionsToInlineFrom: tree) ] ].  ^coll asOrderedCollectionisEmpty  ^rules allSatisfy: [:each |  each isEmpty ]includesSelector: aSelector in: aClass  ^(environment includesSelector: aSelector in: aClass) notincludesSelector: aSymbol in: aClass  ^(environment includesSelector: aSymbol in: aClass) and: [ (self selectorCacheFor: aClass) includes: aSymbol ]parseTreeSearcherClass  ^RBParseTreeSearchergtInspectorPreviewIn: composite  < gtInspectorPresentationOrder: 0>  self changes ifNil: [ ^self ].  self changes gtInspectorPreviewIn: compositetestTransform  | transformation class |  transformation := (RBAddMethodTransformation sourceCode: 'foo									| temp bar |									bar := 5.									temp := bar * bar.									Transcript show: temp printString; cr.									^temp * temp' in: self changeMock name withProtocol: #accessing) transform.  transformation := (RBExtractMethodTransformation model: transformation model extract: 'bar := 5.							temp := bar * bar.							Transcript show: temp printString; cr' from: #foo to: #foobar in: self changeMock name) transform.  self assert: transformation model changes changes size equals: 4.  class := transformation model classNamed: self changeMock name.  self assert: (class parseTreeFor: #foo) equals: (self parseMethod: 'foo													| temp |													temp := self foobar.													^temp * temp').  self assert: (class parseTreeFor: #foobar) equals: (self parseMethod: 'foobar													| temp bar |													bar := 5.													temp := bar * bar.													Transcript show: temp printString; cr.													^temp.')testPullUpVariableNotDefined  self shouldFail: (RBPullUpInstanceVariableRefactoring variable: 'notDefinedVariable' class: RBLintRuleTestData)hasRemoved: aSelector  ^removedMethods notNil and: [ removedMethods includes: aSelector ]testPerformChangeComment  | change comment |  change := changes comment: 'Some Comment' in: self changeMock.  comment := change changeClass organization classComment.  self perform: change do: [ self assert: change changeClass comment equals: 'Some Comment' ].  self assert: change changeClass organization classComment equals: commenttransform  replaceAll := false.  listToFindMatches ifNil: [ (self options at: #listToSearch) value: method value: self ].  listToFindMatches first isClass ifTrue: [ self findOcurrencesInClasses ] ifFalse: [ self findOcurrencesIn: listToFindMatches ]ifTrueReturns  self isSymbol ifFalse: [ ^true ].  ^falsecheckPreconditions  | conditions result |  conditions := self preconditions.  result := conditions check.  result ifFalse: [ self refactoringError: conditions errorString ].  ^resultopenBrowserOn: anEnvironment  ^(self options at: #openBrowser) value: self value: anEnvironmentreplaceInstanceAccesses  | replacer includeGettersAndSetters |  includeGettersAndSetters := receiver isNotNil.  replacer := RBParseTreeRewriter variable: variableName getter: self getterMethod setter: self setterMethod receiver: self receiver.  self model convertClasses: self definingClass withAllSubclasses select: [:aClass |  | allReferences |        allReferences := aClass whichSelectorsReferToInstanceVariable: variableName.        includeGettersAndSetters ifTrue: [ allReferences ] ifFalse: [ allReferences reject: [:each |  aClass == self definingClass and: [ each == self getterMethod or: [ each == self setterMethod ] ] ] ] ] using: replacerargumentsOf: aDictionary  | args limit |  limit := method argumentNames size - 1.  args := OrderedCollection new.  0 to: limit do: [:each |  args add: (aDictionary at: (aDictionary keys detect: [:e |  e name asString = ('`@argMatch' , each asString) ])) sourceCode ].  ^argsasUndoOperation  ^changeFactory removeInstanceVariable: self variable from: self changeClasstransform  self     reparentSubclasses;     removeClassesarguments  ^argumentsdemoExampleCall  ^self demoRenameMethod: 1 PermuteArgs: 2testMessageDoesNotExist  self shouldFail: (RBRemoveMessageSendTransformation messageSend: #byteAt123: inMethod: #methodBefore inClass: #RBRemoveMessageSendTransformationTest) asRefactoringcheckSuperMethods  (self justSendsSuper: selector) ifTrue: [ ^self ] ifFalse: [ (self superclassEquivalentlyDefines: selector) ifTrue: [ (self definingClass parseTreeFor: selector) superMessages ifNotEmpty: [ self refactoringError: ('Although <1s> is equivalent to a superclass method,<n>							it contains a super send so it might modify behavior.' expandMacrosWith: selector) ] ] ifFalse: [ self checkReferences ] ]foo: aValue  ^(1 to: 10) inject: aValue into: [:sum :each |  sum + each ]equalityTestFor: aChange  self assert: aChange equals: aChange.  self assert: aChange hash equals: aChange hash.  self assert: aChange copy equals: aChange.  self assert: aChange copy hash equals: aChange hashlongMethods  self printString.  self printString.  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ]testBadInterval  self     shouldFail: (RBExtractMethodToComponentRefactoring extract: (24 to: 30) from: #testMethod in: RBRefactoryTestDataApp);     shouldFail: (RBExtractMethodToComponentRefactoring extract: (80 to: 147) from: #subclassOf:overrides: in: RBBasicLintRuleTestData class)nonUnaryAccessingMethodWithoutReturn: anObject  testTransformOneOfManyStatements  | transformation class |  transformation := (RBReplaceSubtreeTransformation replace: 'self assert: (class parseTreeFor: #selector:from:) body statements size equals: 2' to: 'self assert: (class parseTreeFor: #selector:from:) body statements size = 2' inMethod: #testRefactoring inClass: #RBReplaceSubtreeTransformationTest) asRefactoring transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: #RBReplaceSubtreeTransformationTest.  self assert: (class directlyDefinesMethod: #testRefactoring).  self assert: (class parseTreeFor: #testRefactoring) body statements size equals: 6.  self assert: ((((class parseTreeFor: #testRefactoring) body statements at: 5) sourceCode withBlanksCondensed copyReplaceAll: String cr with: ' ') includesSubstring: 'assert: (class parseTreeFor: #selector:from:) body statements size = 2')changes: aCollection  changes := aCollectionclearUndoRedoList  undo := Stack new.  redo := OrderedCollection new.  undoPointers := Stack newnameToDisplay  ^self changeStringgetClassesForInstanceVariable  | definingClass typer types |  definingClass := class whoDefinesInstanceVariable: variable.  typer := RBRefactoryTyper newFor: self model.  typer runOn: definingClass.  types := typer typesFor: variable.  types ifEmpty: [ types := OrderedCollection with: (self model classNamed: #Object) ].  moveToClasses := self selectVariableTypesFrom: types selected: (typer guessTypesFor: variable).  moveToClasses ifNil: [ self refactoringFailure: 'Method not moved' ]methodClass  ^classabstractVariableReferences  instanceVariables do: [:each |  self abstractReferenceTo: each ]addSelfReturn  self hasOnlySelfReturns ifTrue: [ ^self ].  parseTree addSelfReturnfoobar  ^#(true false)changeSymbol  ^#addInstVarNamed:testMovePrimitiveMethod  | refactoring |  (model classNamed: #Object) compile: 'foo <primitive: 100> ^#() primitiveFailed' classified: #(#accessing).  refactoring := RBMoveMethodRefactoring model: model selector: #foo class: Object variable: 'OrderedCollection'.  self shouldFail: refactoringnumberSelectors  | total |  total := 0.  self selectorsDo: [:sel |  total := total + 1 ].  ^totaldefinesInstanceVariable: aString  (self directlyDefinesInstanceVariable: aString) ifTrue: [ ^true ].  ^self superclass notNil and: [ self superclass definesInstanceVariable: aString ]runOn: aClass  variableTypes := Dictionary new.  variableMessages := Dictionary new.  bestGuesses := Dictionary new.  class := model classFor: aClass.  class instanceVariableNames isEmpty ifTrue: [ ^self ].  self     selectedClass: aClass;     computeEquivalenceClassesForMethodsAndVars;     computeMessagesSentToVariables;     computeTypes;     refineTypesByLookingAtAssignmentspackages  ^(self methods collect: #package) asSettestInlineTemporary  | refactoring |  refactoring := RBInlineTemporaryRefactoring inline: (24 to: 72) from: #inlineMethod in: RBRefactoryTestDataApp.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineMethod) equals: (self parseMethod: 'inlineMethod										^self													foo;													inlineMethod;													bar')resumeIfCannotRemove: error  ^error messageText = RBRemoveClassTransformation cannotRemoveTopLevelClassErrorMesssage ifTrue: [ error resume ]primitiveExecute  self changeClass organization addCategory: protocolpreconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: 'No such class or trait named ' , className) & (RBCondition definesSelector: selector in: self definingClass) & (RBCondition withBlock: [ (self definingMethod allTemporaryVariables includes: variableName) not ] errorString: 'Method named ' , selector , ' already defines a temporary variable named ' , variableName) & (RBCondition withBlock: [ (self definingMethod allArgumentVariables includes: variableName) not ] errorString: 'Method named ' , selector , ' already defines an argument named ' , variableName)keysFor: aBrowserEnvironment  | allKeys |  allKeys := IdentitySet withAll: aBrowserEnvironment keys.  allKeys addAll: aBrowserEnvironment not keys.  allKeys removeAll: testingEnvironment keys.  self assertEmpty: allKeyssafeMethodNameFor: aClass basedOn: aString  | baseString newString hasParam i |  baseString := aString copy.  baseString at: 1 put: baseString first asLowercase.  newString := baseString.  hasParam := newString last = $:.  hasParam ifTrue: [ baseString := newString copyFrom: 1 to: newString size - 1 ].  i := 0.  [ aClass hierarchyDefinesMethod: newString asSymbol ] whileTrue: [ i := i + 1.        newString := baseString , i printString , (hasParam ifTrue: [ ':' ] ifFalse: [ '' ]) ].  ^newString asSymbolselector: aSymbol  selector := aSymbolcontains  ^((1 to: 10) detect: [:each |  each > 2 ] ifNone: [ nil ]) isNiltestConditions  | condition newCondition |  condition := RBCondition new type: #false block: [ false ] errorString: 'false'.  condition errorMacro: '<1?true:false>'.  self deny: condition check.  self assert: condition errorString equals: 'false'.  self assert: condition not check.  self assert: condition printString equals: 'false'.  self assert: condition not printString equals: 'NOT false'.  self deny: (condition not & condition) check.  self assert: (condition not & condition) printString equals: 'NOT false & false'.  self assert: (condition & condition) not check.  self assert: (condition | condition not) check.  self deny: (newCondition := condition | condition) check.  self assert: newCondition errorString equals: 'false AND false'.  self assert: (condition not | condition not) check.  self deny: (newCondition := condition & condition) check.  self assert: newCondition errorString equals: 'false'.  self assert: (condition not & condition not) check.  self assert: (condition & condition) errorString equals: 'false OR false'someOtherDemoMethod  | temp |  temp := self new.  ^temp junkanchorFor: anEntity  ^ReSourceAnchor entity: anEntitycheckBlocksIn: aParseTree  | searcher |  searcher := self parseTreeSearcher.  searcher     matches: '[:`@args | | `@temps | `@.Statements]' do: [:aNode :answer |  answer ];     matches: variableName do: [:aNode :answer |  true ].  ^searcher executeTree: aParseTree initialAnswer: falsemethod: aCompiledMethod  compiledMethod := aCompiledMethodselector: anObject  selector := anObject.  parseTree := compiledMethod := nilinitialize  super initialize.  changeFactory := RBRefactoryChangeFactory new.  self clearUndoRedoList.  isPerformingRefactoring := false.  self connectToChangestestCheckInvalidMethodName  self deny: (RBCondition checkMethodName: 'fofo fo').  self deny: (RBCondition checkMethodName: '123fofo').  self deny: (RBCondition checkMethodName: 'foo::').  self deny: (RBCondition checkMethodName: 'agr:goo:aa').  self deny: (RBCondition checkMethodName: 'foo:123:').  self deny: (RBCondition checkMethodName: 'foo[arg]').  self deny: (RBCondition checkMethodName: 'foo:=arg').  self deny: (RBCondition checkMethodName: 'foo:arg)').  self deny: (RBCondition checkMethodName: 'foo:(arg)').  self deny: (RBCondition checkMethodName: 'foo:+arg)').  self deny: (RBCondition checkMethodName: '<<foo:<<arg)').  self deny: (RBCondition checkMethodName: 'foo:agr^:').  self deny: (RBCondition checkMethodName: 'foo:agr')newExtractedSelector  ^newExtractedSelectorname  ^'Code Rewriting'definingClass  ^self model classObjectFor: classtheClass  ^(self classObjectFor: className) instanceSidepackages  ^packagesassociationAt: aKey  ^self associationAt: aKey ifAbsent: [ self error: aKey printString , ' not found' ]testModelPushDownToMultipleSubclassesFailure  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model classNamed: #Subclass) compile: 'foo ^Foo' classified: #(#accessing).  model defineClass: 'SomeClass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model metaclassNamed: #AnotherSubclass) compile: 'bar ^Foo' classified: #(#accessing).  self shouldFail: (RBPushDownClassVariableRefactoring model: model variable: #Foo class: (model classNamed: #SomeClass))renameReferences  | replacer methods |  replacer := RBParseTreeRewriter rename: variableName to: newName handler: [ self refactoringError: ('<1s> is already defined as a method or block temporary <n> variable in this class or one of its subclasses' expandMacrosWith: newName) ].  methods := class methodsUsingClassVariableNamed: variableName.  methods do: [:method |  self convertMethod: method selector for: method modelClass using: replacer ]testAbstractWithAssignmentUsed  | refactoring class |  class := model classNamed: #Foo.  refactoring := RBAbstractInstanceVariableRefactoring model: model variable: 'instVarName2' class: class.  self executeRefactoring: refactoring.  self assert: (class parseTreeFor: #foo) equals: (self parseMethod: 'foo						^self instVarName21: 3').  self assert: (class parseTreeFor: #instVarName2:) equals: (self parseMethod: 'instVarName2: anObject						self instVarName21: anObject').  self assert: (class parseTreeFor: #instVarName21:) equals: (self parseMethod: 'instVarName21: anObject						^instVarName2 := anObject').  self assert: (class parseTreeFor: #instVarName2) equals: (self parseMethod: 'instVarName2						^instVarName2').  self assert: ((model classNamed: #Bar) parseTreeFor: #foo) equals: (self parseMethod: 'foo						instVarName1 := instVarName1 + self instVarName2 + ClassVarName1')privateTransform  self replaceInstanceAccesses.  isClassVariable ifTrue: [ self replaceClassAccesses ]renameChangesForClass: oldClassName to: newClassName  ^self copy     changes: (self changes collect: [:each |  each renameChangesForClass: oldClassName to: newClassName ]);     yourselfcompileCode  class compileTree: (RBParseTreeRewriter replaceStatements: sequenceNode formattedCode with: transformedNode formattedCode in: self parseTree onInterval: selectedInterval)testDefineClassAfterDeletedChange  | st |  st := modelFactory rbNamespace new.  st removeClassNamed: self class name.  self deny: (st includesClassNamed: self class name).  st defineClass: self class oldDefinition.  self assert: (st includesClassNamed: self class name).  self assert: (st classNamed: self class name) notNilstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' variable: '.  variableName storeOn: aStream.  aStream nextPutAll: ' class: '.  className storeOn: aStream.  aStream nextPutAll: ' classVariable: '.  isClassVariable storeOn: aStream.  aStream nextPut: $)primitiveExecute  ^self subclassResponsibilitytransform  self model renameClass: class to: newName around: [ self renameReferences ]renameInstanceVariable: oldName to: newName in: aRBClass around: aBlock  ^self performChange: (changeFactory renameInstanceVariable: oldName to: newName in: aRBClass) around: aBlockrenameClassVariable: oldName to: newName in: aRBClass around: aBlock  ^self performChange: (changeFactory renameClassVariable: oldName to: newName in: aRBClass) around: aBlocktestInstanceVariableToMultipleSubclasses  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''foo''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model classNamed: #Subclass) compile: 'foo ^foo' classified: #(#accessing).  model defineClass: 'SomeClass subclass: #AnotherSubclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model classNamed: #AnotherSubclass) compile: 'bar ^foo' classified: #(#accessing).  (RBPushDownVariableTransformation model: model instanceVariable: 'foo' class: (model classNamed: #SomeClass)) asRefactoring transform.  self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: 'foo').  self assert: ((model classNamed: #Subclass) directlyDefinesVariable: 'foo').  self assert: ((model classNamed: #AnotherSubclass) directlyDefinesVariable: 'foo')propagateTransformation  testInlineRecursiveCascadedMethod  | refactoring |  refactoring := RBInlineMethodRefactoring inline: (33 to: 62) inMethod: #inlineMethod forClass: RBRefactoryTestDataApp.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineMethod) equals: (self parseMethod: 'inlineMethod									| temp temp1 |									self foo.									temp1 := self foo; inlineMethod; bar.									temp := self bar.									^temp')changeFactory  ^changeFactorytestPrimitiveMethods  | refactoring |  (model classNamed: #Object) compile: 'foo123: a <primitive: 100> ^#() primitiveFailed' classified: #(#accessing).  refactoring := RBRemoveParameterRefactoring model: model removeParameter: 'a' in: Object selector: #foo123:.  self shouldFail: refactoringtestMethodSendsSuper  < expectedFailure>  self shouldFail: (RBRemoveMethodTransformation selector: #new from: RBBasicLintRuleTestData class) asRefactoringselectionInterval  ^1 to: 0checkSelector: aSelector using: aMatcher  | parseTree |  parseTree := self parseTreeFor: aSelector.  parseTree ifNotNil: [ aMatcher executeTree: parseTree ].  ^aMatcher answerremoveRule: aRule  (rules anySatisfy: [:rule |  rule name = aRule name ]) ifTrue: [ rules := rules reject: [:rule |  rule name = aRule name ] ] ifFalse: [ rules do: [:rule |  rule isComposite ifTrue: [ rule removeRule: aRule ] ] ]modifiesCollection  | collection |  collection := (1 to: 10) asOrderedCollection.  collection do: [:each |  each > 5 ifTrue: [ collection remove: each ] ].  ^collectiondemoExampleCall  ^self demoRenameMethod: 1 PermuteArgs: 2testPullUpWhenSuperClassDoesNotDirectlyImplement  | classEnvironment classes |  classes := #(#ClassA #ClassB #ClassC) inject: OrderedCollection new into: [:sum :each |  testingEnvironment at: each ifPresent: [:class |  sum                 add: class;                 add: class class ].        sum ].  classEnvironment := RBClassEnvironment classes: classes.  model name: 'Test'.  #('Object subclass: #ClassA		instanceVariableNames: ''''		classVariableNames: ''''		poolDictionaries: ''''		category: ''Testing'' ' 'ClassA subclass: #ClassB		instanceVariableNames: ''''		classVariableNames: ''''		poolDictionaries: ''''		category: ''Testing'' ' 'ClassB subclass: #ClassC		instanceVariableNames: ''''		classVariableNames: ''''		poolDictionaries: ''''		category: ''Testing'' ') do: [:each |  model defineClass: each ].  #(#(#ClassA #(#('foo			^ ''ClassA foo''' #private))) #(#ClassC #(#('foo			^ ''ClassC foo''' #private)))) do: [:each |  | class |        class := model classNamed: each first.        each last do: [:methodPair |  class compile: methodPair first classified: methodPair last ] ].  self shouldntWarn: (RBPullUpMethodRefactoring model: model pullUp: #(#foo) from: (model classNamed: #ClassC))forMethod: aParseTree fromClass: aClass toClasses: classCollection  fromClass := self model classFor: aClass.  parseTree := aParseTree.  toClasses := classCollection collect: [:each |  self model classFor: each ]problemCount  ^self builder problemCountaccessorsRefactoring  ^accessorsRefactoring ifNil: [ accessorsRefactoring := RBCreateAccessorsForVariableRefactoring model: self model variable: variableName asString class: class classVariable: true ] ifNotNil: [ accessorsRefactoring ]classesAndTraits  | classesAndTraits |  classesAndTraits := OrderedCollection new: 4096.  self classesAndTraitsDo: [:each |  classesAndTraits add: each ].  ^classesAndTraits asArraytestTransform  | transformation |  self assert: (RBDummyEmptyClass organization protocolOrganizer protocolNamed: 'empty protocol 2') isEmpty.  transformation := (RBMethodProtocolTransformation new protocol: 'empty protocol 2' inMethod: #someMethod inClass: #RBDummyEmptyClass) transform.  RBRefactoryChangeManager instance performChange: transformation changes.  self assert: (RBDummyEmptyClass organization protocolOrganizer protocolNamed: 'empty protocol 2') isEmpty not.  transformation := (RBMethodProtocolTransformation new protocol: 'empty protocol 1' inMethod: #someMethod inClass: #RBDummyEmptyClass) transform.  RBRefactoryChangeManager instance performChange: transformation changes.  self assert: (RBDummyEmptyClass organization protocolOrganizer protocolNamed: 'empty protocol 2') isEmptychangeString  ^self displayClassNamestoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' name: #';     nextPutAll: className;     nextPutAll: ' class: '.  parent storeOn: aStream.  aStream nextPutAll: ' subclasses: '.  subclasses asArray storeOn: aStream.  aStream nextPut: $)testModelInlineMethodWithSameVariableNames1  | class refactoring |  model := RBClassModelFactory rbNamespace new.  class := model classNamed: #Rectangle.  class compile: 'rectangleRelativeTo: aRectangle ^self origin extent: aRectangle extent' classified: #(#accessing).  (model classNamed: #Object) compile: 'foo | aRectangle temp | aRectangle := 0@0 corner: 1@1. temp := aRectangle. ^aRectangle rectangleRelativeTo: temp' classified: #(#accessing).  self proceedThroughWarning: [ refactoring := RBInlineMethodFromComponentRefactoring model: model inline: (77 to: 112) inMethod: #foo forClass: (model classNamed: #Object).        self setupInlineExpressionFor: refactoring toReturn: false.        self setupImplementorToInlineFor: refactoring toReturn: class.        self executeRefactoring: refactoring ].  self assert: ((refactoring model classNamed: #Object) parseTreeFor: #foo) equals: (self parseMethod: 'foo | aRectangle temp | aRectangle := 0@0 corner: 1@1. temp := aRectangle. ^aRectangle origin extent: temp extent')assert: actualNumber closeTo: expectedNumber  ^self assert: (actualNumber closeTo: expectedNumber) description: [ self comparingStringBetween: actualNumber and: expectedNumber ]className: aName  className := aNameclass: aClass selector: aSelector interval: anInterval newName: aString  class := self classObjectFor: aClass.  selector := aSelector.  interval := anInterval.  newName := aStringinlineJunk  | asdf |  asdf := self inlineFoo: [:each |  | temp |        temp := each.        temp , temp ].  ^asdf foo: [:bar |  | baz |        baz := bar.        baz * baz ]classes  ^environment classes & andedEnvironment classesrefactoringConfirmWarning: aString  | ret |  ret := UIManager default confirm: aString orCancel: [ ^RBRefactoringFailure signal: 'aborted' ].  ^retcheckMethod: aSmalllintContext  class := aSmalllintContext selectedClass.  (rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: [ (RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) ifFalse: [ builder compile: rewriteRule tree printString in: class classified: aSmalllintContext protocols ] ]testMetaClassFailure  self shouldFail: (RBApplyClassDeprecationRefactoring rename: self class class to: #Foo)testVariableNotDefined  | refactoring |  refactoring := RBProtectInstanceVariableRefactoring variable: 'rewrite' class: RBSubclassOfClassToRename.  self shouldFail: refactoringflushCaches  implementorsCache := IdentityDictionary new.  sendersCache := IdentityDictionary newtestExtractToTemporaryInsideBlock  | refactoring |  refactoring := RBExtractToTemporaryRefactoring extract: (133 to: 141) to: 'asdf' from: #noMoveDefinition in: RBRefactoryTestDataApp.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #noMoveDefinition) equals: (self parseMethod: 'noMoveDefinition	| temp |	^(self collect: 			[:each | 			temp := each printString.			temp , temp]) 		select: [:each | | asdf | asdf := each size. temp := asdf + temp]')classes: aCollection  aCollection do: [:each |  self addClass: each ]addClass: aClass classVariable: aSymbol  (classVariables at: aClass name ifAbsentPut: [ Set new ]) add: aSymbol.  self flushCachesFor: aClass.  self addSearchString: aSymbolverifySelectedInterval  | selectedParseTree selectedSources |  selectedSources := self selectedSource.  selectedParseTree := self parserClass parseExpression: selectedSources onError: [:message :position |  self refactoringFailure: 'Invalid selection' ].  selectedParseTree isSequence ifTrue: [ self refactoringFailure: 'Cannot assign temp to multiple statements' ]name: aString  name := aStringunaryAccessingBranchingStatementMethodWithReturn  self value isString ifTrue: [ ^self value ] ifFalse: [ ^'' ]classesDo: aBlock  classSelectors keysDo: [:each |  | class |        class := self systemDictionary at: each ifAbsent: [ nil ].        (class notNil and: [ environment includesClass: class ]) ifTrue: [ aBlock value: class ] ].  metaClassSelectors keysDo: [:each |  | class |        class := self systemDictionary at: each ifAbsent: [ nil ].        (class notNil and: [ environment includesClass: class class ]) ifTrue: [ aBlock value: class class ] ]pullUpMethods  self pushUpMethodsFrom: parent.  self pushUpMethodsFrom: parent classSideprivateTransform  self subclassResponsibilitytestNewExistingName  model := RBNamespace2 new.  model name: 'Add instance variable'.  model defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.  self shouldFail: (RBAddVariableTransformation model: model instanceVariable: 'asdf' class: (model classNamed: #FOOBAR)) asRefactoringsuperclass: aRBClass  self superclass ifNotNil: [ self superclass removeSubclass: self ].  superclass := aRBClass.  superclass ifNotNil: [ superclass addSubclass: self ]rule: aLintRule  rule := aLintRuleselectionIntervalFor: aString  | interval |  interval := super selectionIntervalFor: aString.  interval ifNotNil: [ ^interval ].  ^andedEnvironment selectionIntervalFor: aStringdefinitionClass  ^onSystemDictionary classNamed: (self superclassName ifNil: [ #ProtoObject ])markAsRemoved: aClassName  removedClasses     add: aClassName;     add: aClassName , ' class'testValidateRenameParameters  | refactoring |  refactoring := RBExtractMethodRefactoring extract: (78 to: 197) from: #displayName in: RBLintRuleTestData.  self setupMethodNameFor: refactoring toReturn: #foo:.  refactoring parameterMap: (Dictionary new           at: #nameStream put: #nameStream;           yourself).  self should: [ refactoring validateRenameOf: #nameStream to: #name ] raise: RBRefactoringError.  self should: [ refactoring validateRenameOf: #nameStream to: #foo1 ] raise: RBRefactoringError.  self should: [ refactoring validateRenameOf: #nameStream to: #Foo1 ] raise: RBRefactoringErrorclassVariableNames  | nonMetaClass |  nonMetaClass := fromClass instanceSide.  ^(nonMetaClass allClassVariableNames collect: [:each |  each asString ]) asSettestVariableIsNotAccessed  | transformation class |  transformation := RBProtectVariableTransformation instanceVariable: 'instVar' class: self changeMock name.  class := transformation model classNamed: self changeMock name asSymbol.  self deny: (class directlyDefinesLocalMethod: #instVar).  self deny: (class directlyDefinesLocalMethod: #instVar:).  transformation transform.  self assert: transformation model changes changes size equals: 2.  self assert: (class directlyDefinesLocalMethod: #instVar).  self assert: (class directlyDefinesLocalMethod: #instVar:)changeClass  | class |  class := onSystemDictionary at: self changeClassName ifAbsent: [ ^nil ].  ^isMeta ifTrue: [ class classSide ] ifFalse: [ class ]preconditions  ^(RBCondition definesSelector: sourceSelector in: class) & (RBCondition withBlock: [ self findSelectedMessage.              self isOverridden ifTrue: [ self refactoringWarning: ('<1p>>><2s> is overriden. Do you want to inline it anyway?' expandMacrosWith: self inlineClass with: self inlineSelector) ].              self parseInlineMethod.              self isPrimitive ifTrue: [ self refactoringError: 'Cannot inline primitives' ].              self checkSuperMessages.              self rewriteInlinedTree.              (sourceMessage parent isReturn or: [ self hasMultipleReturns not ]) ifFalse: [ self refactoringError: 'Cannot inline method since it contains multiple returns that cannot be rewritten' ].              true ])classVariableNames: aCollectionOfStrings  classVariableNames := (aCollectionOfStrings collect: [:each |  each asSymbol ]) asOrderedCollectionaddTraitDefinition: definition  ^RBAddTraitChange definition: definitiontestExistingSelector  self shouldFail: (RBRenameMethodRefactoring renameMethod: #checkClass: in: RBBasicLintRuleTestData to: #runOnEnvironment: permutation: (1 to: 1))testReferencedVariable  self shouldFail: (RBRemoveInstanceVariableRefactoring variable: 'name' class: RBLintRuleTestData)testPushDownMethodOnNonAbstractClass  | refactoring |  refactoring := RBPushDownMethodRefactoring pushDown: #(#isArray) from: Array.  self shouldFail: refactoringprivateTransform  self definingClass removeMethod: selectortestClassDoesNotExist  self shouldFail: (RBRemoveAssignmentTransformation variable: 'variable' value: '1 asString' inMethod: #methodBefore inClass: #RBAssignmentTransformationTest) asRefactoringinlineParameterMethod: aSymbol  ^aSymbol isSymbolclassNames  ^self categories inject: IdentitySet new into: [:answer :each |  answer           addAll: (self classNamesFor: each);           yourself ]storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' variable: ''';     nextPutAll: variableName;     nextPutAll: ' value: ''';     nextPutAll: value;     nextPutAll: ' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: ''';     nextPutAll: className.  aStream nextPut: $)transform  | subclass |  subclass := self subclassDefiningVariable.  subclass removeClassVariable: variableName.  class addClassVariable: variableNameunaryAccessingMethodWithoutReturn  variable: aVariableName inMethod: aSelector inClass: aClass  self variable: aVariableName inInterval: nil inMethod: aSelector inClass: aClassremoveClassVariable: variableName from: aClass  ^self addChange: (changeFactory removeClassVariable: variableName from: aClass)defineGetterMethod  | selector definingClass |  definingClass := self definingClass.  selector := self safeMethodNameFor: definingClass basedOn: variableName asString.  definingClass compile: ('<1s><r><t>^ <2s>' expandMacrosWith: selector with: variableName) classified: #(#accessing).  ^selectortestModelRenameClass  | refactoring class |  model defineClass: 'Object subclass: #Foo instanceVariableNames: ''a'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  class := model classNamed: #Foo.  class     compile: 'foo	^Object' classified: #(#accessing);     compile: 'objectName ^#(Object)' classified: #(#accessing).  refactoring := RBRenameClassRefactoring model: model rename: Object to: #Thing.  self executeRefactoring: refactoring.  self assert: (model includesClassNamed: #Thing).  self deny: (model includesClassNamed: #Object).  self assert: (class parseTreeFor: #foo) equals: (self parseMethod: 'foo ^Thing').  self assert: (class parseTreeFor: #objectName) equals: (self parseMethod: 'objectName ^#(Thing)').  self assert: class superclass name equals: #ThingcompileMethod  class compileTree: sourceTreetestClassVariableToMultipleSubclasses2  | class |  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''''			classVariableNames: ''Foo''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #AnotherSubclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  class := model metaclassNamed: #AnotherSubclass.  class compile: 'bar ^Foo' classified: #(#accessing).  class := class theNonMetaClass.  (RBPushDownVariableTransformation model: model classVariable: #Foo class: class superclass superclass) asRefactoring transform.  self deny: (class superclass superclass directlyDefinesClassVariable: #Foo).  self deny: (class superclass directlyDefinesClassVariable: #Foo).  self assert: (class directlyDefinesClassVariable: #Foo)testCompileInClassified  | change |  change := changes compile: 'setUp' in: self class classified: #accessing.  self assert: change controller isNil.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self assert: change selector equals: #setUp.  self assert: change source equals: 'setUp'.  self assert: change protocol equals: #accessing.  self universalTestFor: changerefactoringError: aString  ^RBRefactoringError signal: aStringinstVarWritersTo: instVarName in: aClass  ^RBVariableEnvironment on: self writersOfInstanceVariable: instVarName in: aClassresetResult  rules do: [:each |  each resetResult ]addClass: aName superclass: superclassName subclasses: aCollection category: aSymbol  self className: aName.  superclass := superclassName asSymbol.  subclasses := aCollection.  category := aSymbol asSymbolshouldntRaiseException  self shouldnt: [ 0 / 1 ] raise: ExceptionimplementorsMatching: aString  ^RBSelectorEnvironment implementorsMatching: aString in: selfhasOnlyOneAssignment  | searcher |  searcher := self parseTreeSearcher.  searcher matches: assignmentNode variable name , ' := ``@object' do: [:aNode :answer |  answer + 1 ].  ^(searcher executeTree: definingNode initialAnswer: 0) == 1printOn: aStream  aStream     nextPutAll: self displayClassName;     nextPutAll: ' addProtocolNamed: ';     print: self displayProtocolName;     nextPutAll: ' stamp: ';     print: self changeStamp;     nextPutAll: '!'execute  ^self executeNotifying: [  ]errorStringFor: aBoolean  ^condition errorStringFor: aBoolean notstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' extract: '.  extractionInterval storeOn: aStream.  aStream     nextPutAll: ' from: #';     nextPutAll: selector;     nextPutAll: ' in: '.  class storeOn: aStream.  aStream nextPut: $)compositeRefactoryChangeNamed: name  ^RBCompositeRefactoryChange named: namestoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' className ''';     nextPutAll: className;     nextPutAll: ''' newClassName: ''';     nextPutAll: newClassName.  aStream nextPut: $)whichPoolDefines: varName  | currentClass |  currentClass := fromClass.  [ currentClass isNil ] whileFalse: [ currentClass allPoolDictionaryNames do: [:each |  ((self poolVariableNamesIn: each) includes: varName) ifTrue: [ ^each ] ].        currentClass := currentClass superclass ].  ^nilbasicCheck: anEntity  ^self subclassResponsibilitytestVariableNotDirectlyDefined  self     shouldFail: (RBProtectVariableTransformation instanceVariable: 'name' class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBProtectVariableTransformation classVariable: #DependentsFields class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBProtectVariableTransformation model: model classVariable: 'ClassVarName2' class: #Bar) asRefactoringconvertMethod: selector for: aClass using: searchReplacer  | parseTree |  parseTree := aClass parseTreeFor: selector.  parseTree ifNil: [ ^self ].  (searchReplacer executeTree: parseTree) ifTrue: [ aClass compileTree: searchReplacer tree ]isComposite  ^falsetestBadName  self     shouldFail: (RBApplyClassDeprecationRefactoring rename: RBLintRuleTestData to: self objectClassVariable);     shouldFail: (RBApplyClassDeprecationRefactoring rename: RBLintRuleTestData to: #'Ob ject')environments  ^environmentDictionaries keysstoreOn: aStream  aStream nextPut: $(.  environment storeOn: aStream.  aStream nextPutAll: ' & '.  andedEnvironment storeOn: aStream.  aStream nextPut: $)assignmentInIfTrue  | variable |  self isVariable ifTrue: [ variable := self ] ifFalse: [ variable := self printString ].  ^variablerequestMethodNameFor: aMethodName  ^(self options at: #methodName) value: self value: aMethodNamecheck: aMethod forCritiquesDo: aCriticBlock  (self matcher canMatchMethod: aMethod) ifTrue: [ | node |        node := self matcher executeTree: aMethod ast initialAnswer: nil.        node ifNotNil: [ ^aCriticBlock cull: (self critiqueFor: node about: aMethod) ] ]method: anObject1 with: anObject2 lots: anObject3 of: anObject4 arguments: anObject5  ^anObject5 + anObject1 > (anObject4 - anObject2 + anObject3)parseTreeSearcher  ^RBParseTreeSearcher newremoveProtocolNamed: aString in: aClass  self flag: #todo.  ^self addChange: (RBRemoveProtocolChange removeProtocolNamed: aString in: aClass)testModelAbstractClassVariable  | refactoring meta class |  class := model classNamed: #Foo.  meta := class classSide.  refactoring := RBAbstractClassVariableRefactoring model: model variable: 'ClassVarName1' class: class.  self executeRefactoring: refactoring.  self assert: (meta parseTreeFor: #classVarName1) equals: (self parseMethod: 'classVarName1 ^ClassVarName1').  self assert: (meta parseTreeFor: #classVarName1:) equals: (self parseMethod: 'classVarName1: anObject ^ClassVarName1 := anObject').  self assert: (meta parseTreeFor: #foo) equals: (self parseMethod: 'foo					^self classVarName1: self classVarName1 * self classVarName1 * self classVarName1').  self assert: (class parseTreeFor: #classVarName1) equals: (self parseMethod: 'classVarName1							^self class classVarName1').  self assert: (class parseTreeFor: #classVarName1:) equals: (self parseMethod: 'classVarName1: anObject							^self class classVarName1: anObject').  self assert: (class parseTreeFor: #asdf) equals: (self parseMethod: 'asdf						^self classVarName1: (self class classVarName1: self class classVarName1 + 1)').  self assert: ((model classNamed: #Bar) parseTreeFor: #foo) equals: (self parseMethod: 'foo					instVarName1 := instVarName1 + instVarName2 + self class classVarName1').  self assert: ((model classNamed: #Bar) parseTreeFor: #foo) equals: (self parseMethod: 'foo						instVarName1 := instVarName1 + instVarName2 + self class classVarName1')asSelectorEnvironment  | result |  result := RBSelectorEnvironment onEnvironment: environment.  self classesAndSelectorsDo: [:class :selector |  result addClass: class selector: selector ].  ^resulterrorMacro  ^errorMacro ifNil: [ 'unknown' ] ifNotNil: [ errorMacro ]transformationBlock: aBlockWithOneArg  transformationBlock := aBlockWithOneArggroup  ^renrakuRule grouptransform  self     createGetterAccessor;     createSetterAccessorclassesDo: aBlock  | enumerated |  enumerated := IdentitySet new.  environment classesDo: [:each |  aBlock value: each.        enumerated add: each ].  orEnvironment classesDo: [:each |  (enumerated includes: each) ifFalse: [ aBlock value: each ] ]testTransform  | transformation class |  transformation := (RBRemoveMessageSendTransformation new messageSend: #byteAt: inMethod: #methodBefore inClass: self class name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self class name.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) bodyprivateTransform  isClassVariable ifTrue: [ self definingClass theNonMetaClass addClassVariable: variableName ] ifFalse: [ self definingClass addInstanceVariable: variableName ]newContentMorph  ^(self newColumn: {(self newRow: {(self newGroupbox: 'Arguments' for: (self newColumn: {((self newListFor: self list: #arguments selected: #argumentIndex changeSelected: #argumentIndex: help: nil)                             hResizing: #spaceFill;                             yourself)})) .               (self newGroupbox: 'Values' for: (self newColumn: {((self newListFor: self list: #values selected: #valueIndex changeSelected: #valueIndex: help: nil)                             hResizing: #spaceFill;                             yourself)})) .               ((self newRow: {(self newButtonFor: self action: #addAssociation label: 'v' help: 'Map')}) hResizing: #shrinkWrap)}) .         (self newRow: {(self newGroupbox: 'Preview' for: (self newColumn: {(sourceCodeMorph := (self newText: tree formattedCode)                             extent: 400 @ 400;                             hResizing: #rigid)}))}) .         (self newRow: {(self newGroupbox: 'Associations' for: (self newColumn: {((self newListFor: self list: #associations selected: #associationIndex changeSelected: #associationIndex: help: nil)                             hResizing: #spaceFill;                             yourself)})) .               ((self newRow: {(self newButtonFor: self action: #removeAssociation label: '^' help: 'Unmap')}) hResizing: #shrinkWrap)})}) vResizing: #shrinkWraplabel: aString  label := aStringtestNewHierarchyExistingName  model := RBNamespace2 new.  model name: 'Add instance variable'.  model defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.  model defineClass: 'FOOBAR subclass: #BARFOO 				instanceVariableNames: '''' 					classVariableNames: ''''				poolDictionaries: ''''				category: ''Refactory-Test data'''.  self shouldFail: (RBAddVariableTransformation model: model instanceVariable: 'asdf' class: (model classNamed: #BARFOO)) asRefactoringsetupImplementorToInlineFor: aRefactoring toReturn: anObject  | options |  options := aRefactoring options copy.  options at: #implementorToInline put: [:ref :imps |  anObject ].  aRefactoring options: optionstestNonExistantSelector  self shouldFail: (RBInlineMethodRefactoring inline: (14 to: 17) inMethod: #checkClass1: forClass: RBRefactoryTestDataApp)realClass: aClass  realClass := aClass.  superclass ifNil: [ superclass := LookupSuperclass ]allSelectors  | class selectors |  class := self.  selectors := Set new.  [ class notNil ] whileTrue: [ selectors addAll: class selectors.        class := class superclass ].  ^selectorspreconditions  ^(RBCondition isMetaclass: class) not & (RBCondition isValidClassVarName: newName asString for: class) & (RBCondition definesClassVariable: variableName asString in: class) & (RBCondition hierarchyOf: class definesVariable: newName asString) not & (RBCondition isGlobal: newName asString in: self model) notcomputeSelectorCacheFor: aClass  ^(self instanceVariableSelectorsFor: aClass)     addAll: (self classVariableSelectorsFor: aClass);     yourselftransform  self     createNewClass;     createReference;     abstractVariableReferencesequalsTrue  ^true == selfwithAllSuperclassesUntil: aClass  ^(self allSuperclassesUntil: aClass)     add: self;     yourselftestModelInheritedSelector  | refactoring |  refactoring := RBAddMethodRefactoring model: model addMethod: 'printString ^super printString' toClass: (model classNamed: #Bar) inProtocols: #(#accessing).  self shouldFail: refactoringcheckPackage: aPackage  addArgumentToSelector: aSymbol  ^aSymbol isInfix ifTrue: [ #value:value: ] ifFalse: [ (aSymbol , 'value:') asSymbol ]removeDependentSends  self     removeDependent: #one;     removeDependent: #twotestRefactoring  | refactoring class |  refactoring := (RBRenameVariableTransformation rename: 'classBlock' to: 'asdf' in: #RBBasicLintRuleTestData classVariable: false) asRefactoring transform.  class := refactoring model classNamed: #RBBasicLintRuleTestData.  self assert: (class directlyDefinesInstanceVariable: 'asdf').  self deny: (class directlyDefinesInstanceVariable: 'classBlock').  self assert: (class parseTreeFor: #checkClass:) equals: (self parseMethod: 'checkClass: aSmalllintContext 					^asdf value: aSmalllintContext value: result').  self assert: (class parseTreeFor: #initialize) equals: (self parseMethod: 'initialize					super initialize.					self anInstVar: 1.					asdf := [:context :aResult | ].					methodBlock := [:context :aResult | ].					self resultClass: RBSelectorEnvironment')testMethodDoesNotExist  self shouldFail: (RBRemovePragmaTransformation pragma: '<gtInspectorPresentationOrder: 34>' inMethod: #method inClass: #RBRemovePragmaTransformationTest) asRefactoringincludesClass: aRBClass  | currentClass |  currentClass := self.  [ currentClass notNil and: [ currentClass ~= aRBClass ] ] whileTrue: [ currentClass := currentClass superclass ].  ^currentClass = aRBClasstransform  self setOption: #inlineExpression toUse: [:ref :string |  true ].  self getterSetterMethods do: [:each |  self inline: each ]pragma: aString inMethod: aSelector inClass: aClassName  self className: aClassName.  selector := aSelector.  pragma := aStringpreconditions  | newCondition |  newCondition := RBCondition withBlock: [ oldSelector numArgs = newSelector numArgs or: [ newSelector numArgs = 0 ] ] errorString: 'The new selectors should have the same number of arguments as the old one, or not have them at all'.  ^newConditionendTrueFalse  self isVariable ifTrue: [ self printString.        self isVariable printString ] ifFalse: [ self printString.        ^4 ]abstractInstanceVariable: aString  | refactoring rewriter |  refactoring := RBCreateAccessorsForVariableRefactoring model: self model variable: aString class: fromClass classVariable: false.  self performComponentRefactoring: refactoring.  rewriter := RBParseTreeRewriter new.  rewriter     replace: aString , ' := ``@object' with: ('self <1s> ``@object' expandMacrosWith: refactoring setterMethod);     replace: aString with: 'self ' , refactoring getterMethod.  (rewriter executeTree: tree) ifTrue: [ tree := rewriter tree ]selectorNotReferenced  ^self selectorNotReferenced + 4testPushDownMethod  | refactoring class |  refactoring := RBPushDownMethodRefactoring pushDown: #(#name:) from: RBLintRuleTestData.  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBLintRuleTestData.  self deny: (class directlyDefinesMethod: #name:).  class subclasses do: [:each |  self assert: (each parseTreeFor: #name:) equals: (self parseMethod: 'name: aString name := aString') ]testModelImplementorsSenders  | model class modelImps refs found |  model := modelFactory rbNamespace new.  model defineClass: 'Object subclass: #Asdf			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Testing'''.  class := model classNamed: #Asdf.  class compile: 'storeOn: aStream ^super storeOn: aStream' classified: #(#printing).  modelImps := model allImplementorsOf: #storeOn:.  self assert: (modelImps includes: class).  self assert: modelImps size - 1 equals: (RBBrowserEnvironment new implementorsOf: #storeOn:) numberSelectors.  refs := RBBrowserEnvironment new referencesTo: #storeOn:.  found := false.  model allReferencesTo: #storeOn: do: [:each |  each modelClass = class ifTrue: [ found := true ] ifFalse: [ self assert: (refs includesSelector: each selector in: each modelClass realClass) ] ].  self assert: foundtestPullUpInAHighHierarchyClass  | class superClass |  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  class := model classNamed: #Foo1.  superClass := model classNamed: #SomeClass.  class compile: 'example ^1' classified: #(#accessing).  self executeRefactoring: (RBPullUpMethodRefactoring model: model pullUp: #(#example) from: class to: superClass).  self assert: (superClass parseTreeFor: #example) equals: (self parseMethod: 'example ^1').  self deny: (class directlyDefinesMethod: #example).  class := model classNamed: #Subclass.  self assert: (class definesMethod: #example).  self assert: (class parseTreeFor: #example) equals: ((model classNamed: #SomeClass) parseTreeFor: #example)removeDependentSends  self removeDependent: #onenormalizeIfTrues  | rewriter |  rewriter := RBParseTreeRewriter new.  rewriter     replace: '| `@temps | ``@.s1. ``@boolean ifTrue: [| `@t1 | ``@.Stmts1. ^`@r1]. ``@.s2. ^``@r2' with: '| `@temps | ``@.s1. ``@boolean ifTrue: [| `@t1 | ``@.Stmts1. ^`@r1] ifFalse: [``@.s2. ^``@r2]';     replace: '| `@temps | ``@.s1. ``@boolean ifFalse: [| `@t1 | ``@.Stmts1. ^`@r1]. ``@.s2. ^``@r2' with: '| `@temps | ``@.s1. ``@boolean ifTrue: [``@.s2. ^``@r2] ifFalse: [| `@t1 | ``@.Stmts1. ^`@r1]'.  [ rewriter executeTree: inlineParseTree ] whileTrue: [ inlineParseTree := rewriter tree ]testAbstractClassVariable  | refactoring meta class |  refactoring := RBAbstractClassVariableRefactoring variable: 'RecursiveSelfRule' class: RBTransformationRuleTestData.  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBTransformationRuleTestData.  meta := class classSide.  self assert: (meta parseTreeFor: #recursiveSelfRule) equals: (self parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').  self assert: (meta parseTreeFor: #recursiveSelfRule:) equals: (self parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').  self assert: (meta parseTreeFor: #nuke) equals: (self parseMethod: 'nuke							self recursiveSelfRule: nil').  self assert: (meta parseTreeFor: #initializeAfterLoad1) equals: (self parseMethod: 'initializeAfterLoad1							self recursiveSelfRule: RBParseTreeSearcher new.							self recursiveSelfRule								addMethodSearches: #(''`@methodName: `@args | `@temps | self `@methodName: `@args'' ''`@methodName: `@args | `@temps | ^self `@methodName: `@args'')										-> [:aNode :answer | true]').  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 							class := aSmalllintContext selectedClass.							(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 									[(self class recursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)										ifFalse: 											[builder compile: rewriteRule tree printString												in: class												classified: aSmalllintContext protocols]]')displayName  | nameStream |  nameStream := WriteStream on: (String new: 64).  nameStream     nextPutAll: self name;     nextPutAll: ' ('.  self problemCount printOn: nameStream.  nameStream nextPut: $).  ^nameStream contentstestMetaClassFailure  self shouldFail: (RBAddClassRefactoring addClass: #Foo superclass: self class class subclasses: #() category: #'Refactory-Testing')problemCount  ^self subclassResponsibilitynameNewMethod: aSymbol  | args newSend |  newExtractedSelector := aSymbol.  args := parameters collect: [:parm |  RBVariableNode named: parm ].  extractedParseTree renameSelector: aSymbol andArguments: args asArray.  aSymbol numArgs = 0 ifTrue: [ modifiedParseTree := RBParseTreeRewriter replace: self methodDelimiter with: 'self ' , aSymbol asString in: modifiedParseTree.        ^self ].  newSend := String streamContents: [:str |  str nextPutAll: 'self '.        aSymbol keywords with: parameters do: [:key :arg |  str                 nextPutAll: key asString;                 nextPut: $ ;                 nextPutAll: arg asString;                 nextPut: $  ] ].  modifiedParseTree := RBParseTreeRewriter replace: self methodDelimiter with: newSend in: modifiedParseTreesafeMethodNameFor: aClass basedOn: aString  | baseString newString hasParam i |  baseString := aString copy.  baseString at: 1 put: baseString first asLowercase.  newString := baseString.  hasParam := newString last = $:.  hasParam ifTrue: [ baseString := newString copyFrom: 1 to: newString size - 1 ].  i := 0.  [ aClass hierarchyDefinesMethod: newString asSymbol ] whileTrue: [ i := i + 1.        newString := baseString , i printString , (hasParam ifTrue: [ ':' ] ifFalse: [ '' ]) ].  ^newString asSymbolcollectionNameFor: aString  ^'-<1s>-' expandMacrosWith: aStringmetaClassSelectorDictionary  ^metaClasses inject: (IdentityDictionary new: metaClasses size) into: [:answer :class |  answer           at: class put: (self systemDictionary at: class) class selectors;           yourself ]compileDelegatorMethod  | statementNode delegatorNode tree |  delegatorNode := RBMessageNode receiver: (RBVariableNode named: variable) selector: parseTree selector keywordsPositions: parseTree keywordsPositions arguments: (parseTree argumentNames collect: [:each |  RBVariableNode named: (each = selfVariableName ifTrue: [ 'self' ] ifFalse: [ each ]) ]).  self hasOnlySelfReturns ifFalse: [ delegatorNode := RBReturnNode value: delegatorNode ].  statementNode := RBSequenceNode temporaries: #() statements: (Array with: delegatorNode).  (tree := class parseTreeFor: selector) body: statementNode.  class compileTree: treefailedRules  ^self isEmpty ifTrue: [ #() ] ifFalse: [ Array with: self ]buildParseTree  parseTree := (class parseTreeFor: selector) copy.  parseTree ifNil: [ self refactoringFailure: 'Could not parse method' ]changes  ^Array with: selftestExtractMethodAtEndOfMethodThatNeedsReturn  | refactoring class selectorsSize |  refactoring := RBExtractMethodToComponentRefactoring extract: (52 to: 133) from: #openEditor in: RBLintRuleTestData.  self setupMethodNameFor: refactoring toReturn: #foo:.  self setupSelfArgumentNameFor: refactoring toReturn: 'asdf'.  self setupVariableToMoveToFor: refactoring toReturn: 'rules'.  self setupVariableTypesFor: refactoring toReturn: (Array with: (refactoring model classNamed: #Collection)).  class := refactoring model classNamed: #RBLintRuleTestData.  selectorsSize := class selectors size.  self proceedThroughWarning: [ self executeRefactoring: refactoring ].  self assert: (class parseTreeFor: #openEditor) equals: (self parseMethod: 'openEditor								| rules |								rules := self failedRules.								^rules foo: self').  self assert: ((refactoring model classNamed: #Collection) parseTreeFor: #foo:) equals: (self parseMethod: 'foo: asdf								self isEmpty ifTrue: [^asdf].								self size == 1 ifTrue: [^self first viewResults].								^asdf').  self assert: class selectors size equals: selectorsSizeonSystemDictionary  ^onSystemDictionaryshouldnt: aBlock raise: anExceptionalEvent whoseDescriptionIncludes: substring description: aString  ^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionContaining: substring) not description: aStringtheMetaClass  ^selftransform  class addInstanceVariable: variableNamecode: aString from: aSelector in: aClassName  self className: aClassName.  selector := aSelector.  sourceCode := aStringtestRefactoring  | refactoring class |  refactoring := (RBAddMethodTransformation sourceCode: 'foo										| temp bar |										bar := 5.										temp := bar * bar.										Transcript show: temp printString; cr.										^temp * temp' in: #RBRemoveTemporaryVariableTransformationTest withProtocol: #accessing) asRefactoring transform.  refactoring := (RBRemoveTemporaryVariableTransformation model: refactoring model variable: 'temp' inMethod: #foo inClass: #RBRemoveTemporaryVariableTransformationTest) asRefactoring transform.  self assert: refactoring model changes changes size equals: 2.  class := refactoring model classNamed: #RBRemoveTemporaryVariableTransformationTest.  self assert: (class directlyDefinesMethod: #foo).  self assert: (class parseTreeFor: #foo) temporaries size equals: 1perform: aChange do: aBlock  | undo |  ^SystemAnnouncer uniqueInstance suspendAllWhile: [ undo := aChange execute.        aBlock ensure: [ undo execute ] ]returnsIfTrue  ^self isNil ifTrue: [ 4 ]testRemoveReferenced  self shouldFail: (RBRemoveMethodRefactoring removeMethods: #(#checkClass:) from: RBBasicLintRuleTestData)returnsBooleanAndOther  self isVariable ifTrue: [ ^false ].  self printStringremoveMockClass  testingEnvironment removeClassNamed: #RBRefactoringChangeMockdeny: aBooleanOrBlock description: aString resumable: resumableBoolean  self assert: aBooleanOrBlock value not description: aString resumable: resumableBooleanactionBlock  ^actionBlockreorderParametersToMatch: aSelector  | tree dictionary |  tree := class parseTreeFor: aSelector.  dictionary := Dictionary new.  tree body equalTo: extractedParseTree body withMapping: dictionary.  parameters := tree arguments collect: [:each |  dictionary at: each name ifAbsent: [ self refactoringFailure: 'An internal error occured, please report this error.' ] ]removeMockClass  testingEnvironment removeClassNamed: #RBRefactoringChangeMockcontroller: aController  controller := aControllermodel  ^modelstoreOn: aStream  aStream nextPut: $(.  super storeOn: aStream.  aStream nextPutAll: ' classes: (('.  classes asArray storeOn: aStream.  aStream nextPutAll: ' inject: OrderedCollection new into: [:sum :each | 				| class |				class := Smalltalk at: each ifAbsent: [nil].				class notNil ifTrue: [sum add: class].				sum]) , ('.  metaClasses asArray storeOn: aStream.  aStream nextPutAll: ' inject: OrderedCollection new into: [:sum :each | 				| class |				class := Smalltalk at: each ifAbsent: [nil].				class notNil ifTrue: [sum add: class class].				sum])))'shouldRemoveExtensions: anObject  shouldRemoveExtensions := anObjecthasCreatedClassFor: aBehavior  | className |  className := self classNameFor: aBehavior.  ^(newClasses includesKey: className) or: [ changedClasses includesKey: className ]replaceArgument: sourceNode with: replacementNode  | rewriter |  rewriter := RBParseTreeRewriter new.  rewriter replaceTree: sourceNode withTree: replacementNode.  (rewriter executeTree: inlineParseTree body) ifTrue: [ inlineParseTree body: rewriter tree ]methodBlock: aBlock  methodBlock := aBlockundoOperation  undo ifEmpty: [ ^self ].  self ignoreChangesWhile: [ | change |        change := undo removeLast.        redo add: change execute ]testExistingName  self     shouldFail: (RBChildrenToSiblingsRefactoring name: #Object class: RBLintRuleTestData subclasses: (Array with: RBBasicLintRuleTestData with: RBCompositeLintRuleTestData));     shouldFail: (RBChildrenToSiblingsRefactoring name: #Processor class: RBLintRuleTestData subclasses: (Array with: RBBasicLintRuleTestData with: RBCompositeLintRuleTestData))testReturnDoesNotExist  self shouldFail: (RBRemoveReturnStatementTransformation return: '^ variable' inMethod: #methodAfter inClass: #RBRemoveReturnStatementTransformationTest) asRefactoringcategory: aString for: aClass  ^changes addChange: (RBClassCategoryChange category: aString for: aClass)testTransform  | transformation method |  transformation := (RBAddMethodCommentTransformation comment: 'New comment for method' inMethod: #one inClass: self changeMock name) transform.  self assert: transformation model changes changes size equals: 1.  method := (transformation model classNamed: self changeMock name) methodFor: #one.  self assert: method ast comments first contents equals: 'New comment for method'testMetaclass  | class |  class := model metaclassNamed: #Foo.  class addInstanceVariable: 'foo'.  class compile: 'zzz ^foo := foo + foo * 2' classified: #(#testing).  (RBProtectVariableTransformation model: model instanceVariable: 'foo' class: class) asRefactoring transform.  self assert: (class parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 ^foo').  self assert: (class parseTreeFor: #foo:) equals: (self parseMethod: 'foo: anObject foo := anObject').  self assert: (class parseTreeFor: #zzz) equals: (self parseMethod: 'zzz ^self foo: self foo1 + self foo1 * 2')testDefineClassChange  | st |  st := modelFactory rbNamespace new.  st defineClass: 'RefactoringBrowserTest subclass: #SmalltalkTestXXX				instanceVariableNames: ''''				classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Testing'''.  self assert: (st includesClassNamed: #SmalltalkTestXXX).  self assert: (st classNamed: #SmalltalkTestXXX) notNilasUndoOperation  ^self copy     comment: self changeClass organization classComment;     yourselfgetterMethod  ^getterMethodaddClassVariable: aString  self privateClassVariableNames add: aString asSymbol.  model addClassVariable: aString to: selfprintOn: aStream  name ifNil: [ super printOn: aStream ] ifNotNil: [ aStream nextPutAll: name ]labelFor: aBrowserEnvironment  self deny: aBrowserEnvironment label isNil.  self deny: aBrowserEnvironment label isEmpty.  self deny: aBrowserEnvironment defaultLabel isNil.  self deny: aBrowserEnvironment defaultLabel isEmptygetterMethod  ^getterMethod ifNil: [ getterMethod := (self definingClass getterMethodFor: variableName) ifNil: [ variableName uncapitalized asSymbol ] ]className: aName newName: aNewName  className := aName asSymbol.  deprecatedClass := self model classNamed: className.  newName := aNewName asSymbolexampleCall  ^self rename: 1 two: 2newName  ^newNameunexpectedIdentityEqualityStringBetween: actual and: expected  ^String streamContents: [:stream |  stream           nextPutAll: 'Unexpected identity equality of ';           nextPutAll: actual fullPrintString;           nextPutAll: ' and ';           nextPutAll: expected fullPrintString;           nextPutAll: '.' ]moveComments  inlineParseTree nodesDo: [:each |  each comments: (each comments collect: [:aComment |  | start source |                    source := sourceParseTree source.                    start := source size + 1.                    source := source , (inlineParseTree source copyFrom: aComment start to: aComment stop).                    sourceParseTree source: source.                    RBComment with: aComment contents at: start ]) ]transform  | replacement |  self model allClassesDo: [:class |  (class isNil or: [ class isMeta ]) ifFalse: [ replacement := self execute: class category.              replacement = class category asString ifFalse: [ class category: replacement.                    self model defineClass: class definitionString ] ] ]definitionString  ^String streamContents: [:definitionStream |  definitionStream           nextPutAll: self superclass printString;           nextPutAll: ' subclass: #';           nextPutAll: self name;           nextPutAll: '	instanceVariableNames: '''.        self instanceVariableNames do: [:each |  definitionStream                 nextPutAll: each;                 nextPut: $  ].        definitionStream nextPutAll: '''	classVariableNames: '''.        self classVariableNames do: [:each |  definitionStream                 nextPutAll: each;                 nextPut: $  ].        definitionStream nextPutAll: '''	poolDictionaries: '''.        self sharedPoolNames do: [:each |  definitionStream                 nextPutAll: each;                 nextPut: $  ].        definitionStream nextPutAll: '''	category: #'''.        definitionStream nextPutAll: self category asString.        definitionStream nextPut: $' ]testModelAddClassVariable  | refactoring |  refactoring := RBAddClassVariableRefactoring model: model variable: #ClassVarName3 class: (model classNamed: #Bar).  self executeRefactoring: refactoring.  self assert: ((model classNamed: #Bar) directlyDefinesClassVariable: #ClassVarName3)literalArrayContainsComma  ^#(#,)computePoolsToMove  | poolVariables searcher |  poolVariables := self poolVariableNamesFor: fromClass.  pools := Set new.  searcher := self parseTreeSearcher.  searcher matches: '`var' do: [:aNode :answer |  | varName pool |        varName := aNode name.        (aNode whoDefines: varName) ifNil: [ (poolVariables includes: varName) ifTrue: [ pool := self whichPoolDefines: varName.                    pool ifNotNil: [ pools add: pool ] ] ] ].  searcher executeTree: parseTreetestInlineLiteralArray  | refactoring class |  refactoring := RBInlineParameterRefactoring inlineParameter: 'aSymbol' in: RBRefactoryTestDataApp selector: ('inline' , 'ParameterMethod:') asSymbol.  self proceedThroughWarning: [ self executeRefactoring: refactoring ].  class := refactoring model classNamed: #RBRefactoryTestDataApp.  self assert: (class parseTreeFor: #inlineParameterMethod) equals: (self parseMethod: 'inlineParameterMethod | aSymbol | aSymbol := #(asdf). ^aSymbol isSymbol').  self assert: (class parseTreeFor: #sendInlineParameterMethod) equals: (self parseMethod: 'sendInlineParameterMethod ^self inlineParameterMethod').  self deny: (class directlyDefinesMethod: ('inline' , 'ParameterMethod:') asSymbol)literalArrayCharacters  ^#($a $b $c) includes: $afailedRules  ^rules inject: OrderedCollection new into: [:oc :each |  oc           addAll: each failedRules;           yourself ]testParseFailure  self shouldFail: (RBReplaceSubtreeTransformation replace: 'selector := aSelector' to: ':= 123' inMethod: #selector:from: inClass: #RBRemoveMethodTransformation) asRefactoringopenEditor  | rules |  rules := self failedRules.  rules isEmpty ifTrue: [ ^self ].  rules size == 1 ifTrue: [ ^rules first viewResults ]problemCount  ^self result problemCountcalled: anObject on: aBlock  self traceCr: anObject printString.  aBlock valueisMeta  ^isMetatestCompositeLintRuleTypes  | typer types |  typer := RBRefactoryTyper new runOn: RBCompositeLintRuleTestData.  types := typer guessTypesFor: 'rules'.  self assert: (types includes: (typer model classFor: Collection)).  types := typer typesFor: '-rules-'.  self assert: (types includes: (typer model classFor: RBLintRuleTestData)).  self assertEmpty: (typer guessTypesFor: 'asdf').  typer printStringselectors  ^Array streamContents: [:stream |  self selectorsDo: [:selector |  stream nextPut: selector ] ]withClassesFixedForNautilus  hasConflicts  ^truecheckClass: aSmalllintContext  setUp  super setUp.  model := self abstractVariableTestDatafileBlocks  | file |  ^[ file := 'asdf' asFileReference readStream.  file contents ] ensure: [ file close ]setupMethodNameFor: aRefactoring toReturn: aSelector  | options |  options := aRefactoring options copy.  options at: #methodName put: [:ref :aMethodName |  aMethodName           selector: aSelector;           yourself ].  aRefactoring options: optionstestPushDownInstanceVariable  | refactoring |  refactoring := RBPushDownInstanceVariableRefactoring variable: 'foo1' class: RBLintRuleTestData.  self executeRefactoring: refactoring.  (refactoring model classNamed: #RBLintRuleTestData) subclasses do: [:each |  self assert: (each directlyDefinesInstanceVariable: 'foo1') ]privateTransform  | methodTree pragmaNode |  methodTree := self definingMethod.  pragmaNode := self parserClass parsePragma: pragma.  methodTree addPragma: pragmaNode.  self definingClass compileTree: methodTreenormalizeReturns  | rewriter |  rewriter := RBParseTreeRewriter new.  rewriter     replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]' with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';     replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]' with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';     replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]' with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';     replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]' with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';     replace: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]' with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';     replace: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]' with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]';     replace: '``@boolean ifTrue: [| `@t1 | `@.Stmts1. ^``@r1] ifFalse: [| `@t2 | `@.Stmts2. ^``@r2]' with: '^``@boolean ifTrue: [| `@t1 | `@.Stmts1. ``@r1] ifFalse: [| `@t2 | `@.Stmts2. ``@r2]';     replace: '``@boolean ifFalse: [| `@t1 | `@.Stmts1. ^``@r1] ifTrue: [| `@t2 | `@.Stmts2. ^``@r2]' with: '^``@boolean ifFalse: [| `@t1 | `@.Stmts1. ``@r1] ifTrue: [| `@t2 | `@.Stmts2. ``@r2]'.  [ rewriter executeTree: inlineParseTree ] whileTrue: [ inlineParseTree := rewriter tree ]denyCollection: actual equals: expected  ^self deny: expected = actual description: [ self unexpectedEqualityStringBetween: actual and: expected ]selector: aString  super selector: aString.  labelGroup extent x > self extent x ifTrue: [ self extent: (labelGroup extent x + 20) @ labelGroup extent y ]testAlreadyExistingName  self     shouldFail: (RBAddClassVariableRefactoring variable: #RecursiveSelfRule class: RBTransformationRuleTestData);     shouldFail: (RBAddClassVariableRefactoring variable: self objectClassVariable class: RBTransformationRuleTestData)matcher  ^matcherprocessAssignmentNode: aNode  | varName |  varName := aNode variable name.  ignore = varName ifTrue: [ ^self ].  (aNode whoDefines: varName) ifNotNil: [ ^self ].  (self instanceVariableNames includes: varName) ifTrue: [ instVarWriters add: varName ].  (self classVariableNames includes: varName) ifTrue: [ classVarWriters add: varName ]testMetaclass  | refactoring |  refactoring := RBAddClassVariableRefactoring variable: #ClassVarName3 class: (model classNamed: #Object) classSide.  refactoring model: model.  self shouldFail: refactoringcompile: aString withAttributesFrom: aRBMethod  | change method |  change := model compile: aString in: self classified: aRBMethod protocols.  method := modelFactory rbMethod for: self source: aString selector: change selector.  self addMethod: method.  ^changeonError: aBlock do: errorBlock  ^aBlock on: self class preconditionSignal do: [:ex |  errorBlock value.        ex return: nil ]existingMethodsThatReferTo: aSymbol  | existingMethods |  existingMethods := self realClass thoroughWhichSelectorsReferTo: aSymbol.  (newMethods isNil and: [ removedMethods isNil ]) ifTrue: [ ^existingMethods ].  ^existingMethods reject: [:each |  (self hasRemoved: each) or: [ self newMethods includesKey: each ] ]defaultLabel  ^'some methods'testRefactoring  | refactoring class |  refactoring := (RBRemoveReturnStatementTransformation return: '^ variable' inMethod: #methodBefore inClass: #RBRemoveReturnStatementTransformationTest) asRefactoring transform.  self assert: refactoring model changes changes size equals: 1.  class := refactoring model classNamed: #RBRemoveReturnStatementTransformationTest.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) bodyabstractReferences  | replacer |  replacer := RBParseTreeRewriter variable: variableName getter: self accessorsRefactoring getterMethod setter: self accessorsRefactoring setterMethod.  self convertClasses: class withAllSubclasses select: [:aClass |  (aClass whichSelectorsReferToInstanceVariable: variableName) reject: [:each |  aClass == class and: [ each == self accessorsRefactoring getterMethod or: [ each == self accessorsRefactoring setterMethod ] ] ] ] using: replacertransform  self createAccessors.  self abstractInstanceReferences.  self abstractClassReferenceshierarchyDefinesPoolDictionary: aString  (self definesPoolDictionary: aString) ifTrue: [ ^true ].  ^self allSubclasses anySatisfy: [:each |  each directlyDefinesPoolDictionary: aString ]postCopy  super postCopy.  instanceVariables := self copyDictionary: instanceVariables.  instanceVariableReaders := self copyDictionary: instanceVariableReaders.  instanceVariableWriters := self copyDictionary: instanceVariableWriters.  classVariables := self copyDictionary: classVariables.  selectorCache := nilprotocol  ^self selectedClass whichCategoryIncludesSelector: self selectortestMethod1  ^self testMethod1 , ([:each |  each testMethod1 ] value: #(#(#testMethod1) 2 #testMethod1))preconditions  ^RBCondition emptypackages  self shouldBeImplementednodesOf: methodNode  | visitor node |  visitor := RBCombinatorVisitor new.  node := methodNode copy.  node acceptVisitor: visitor.  ^visitor combinationsstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' inline: '.  sourceInterval storeOn: aStream.  aStream     nextPutAll: ' inMethod: #';     nextPutAll: sourceSelector;     nextPutAll: ' forClass: '.  class storeOn: aStream.  aStream nextPut: $)storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' extract: '.  sourceInterval storeOn: aStream.  aStream     nextPutAll: ' to: ''';     nextPutAll: newVariableName;     nextPutAll: ''' from: #';     nextPutAll: selector;     nextPutAll: ' in: '.  class storeOn: aStream.  aStream nextPut: $)parseTreeRewriter  ^RBParseTreeRewriter newtestModelInlineMethodWithSameVariableNames2  | class refactoring |  model := RBClassModelFactory rbNamespace new.  class := model classNamed: self class name.  class compile: 'a9: a b9: b ^self + a + b' classified: #(#accessing).  (model classNamed: #Object) compile: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^c a9: b b9: a' classified: #(#accessing).  self proceedThroughWarning: [ refactoring := RBInlineMethodFromComponentRefactoring model: model inline: (72 to: 84) inMethod: #foo forClass: (model classNamed: #Object).        self setupInlineExpressionFor: refactoring toReturn: false.        self executeRefactoring: refactoring ].  self assert: ((refactoring model classNamed: #Object) parseTreeFor: #foo) equals: (self parseMethod: 'foo | a b c | a := InlineMethodFromComponentTest new. b := 1. c := 2. ^c + b + a')textToDisplay  self printStringsetUp  super setUp.  model := self abstractVariableTestDatastoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' removeMethods: '.  selectors asArray storeOn: aStream.  aStream nextPutAll: ' from: '.  class storeOn: aStream.  aStream nextPut: $)setupInlineExpressionFor: aRefactoring toReturn: aBoolean  | options |  options := aRefactoring options copy.  options at: #inlineExpression put: [:ref :string |  aBoolean ].  aRefactoring options: optionstranscriptMentioned  Transcript show: 'message'preconditionChecking: aBoolean  preconditionChecking := aBooleanstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' class: '.  class storeOn: aStream.  aStream     nextPutAll: ' selector: #';     nextPutAll: selector;     nextPutAll: ' variable: ''';     nextPutAll: temporaryVariableName;     nextPut: $'.  aStream nextPut: $)replace: temp with: aString  | definingNode |  definingNode := temp whoDefines: temp name.  (RBParseTreeRewriter rename: temp name to: aString) executeTree: definingNodeisAbstract: aClass  ^(aClass isMeta or: [ (self literals includes: aClass name) or: [ self literals includes: (Smalltalk globals associationAt: aClass name) ] ]) notkeys  | keys |  keys := Set new.  self systemDictionary keysAndValuesDo: [:key :value |  | class |        value isBehavior ifTrue: [ (self includesClass: value) ifTrue: [ keys add: key ] ].        class := value class.        (self includesClass: class) ifTrue: [ keys add: key ] ].  ^keysisEmpty  self subclassResponsibilitysetUp  super setUp.  model := self abstractVariableTestDatatestRefactoring  | refactoring class |  refactoring := (RBRemoveDirectAccessToVariableTransformation instanceVariable: 'environment' class: #RBNamespace) asRefactoring transform.  self assert: refactoring model changes changes size equals: 6.  class := refactoring model classNamed: #RBNamespace.  self assert: (class parseTreeFor: #includesGlobal:) equals: (self parseMethod: 'includesGlobal: aSymbol 			(self hasRemoved: aSymbol) ifTrue: [^false].			(self includesClassNamed: aSymbol) ifTrue: [^true].			self environment at: aSymbol ifAbsent: [^false].			^ true').  self assert: (class parseTreeFor: #initialize) equals: (self parseMethod: 'initialize			super initialize.			changes := changeFactory compositeRefactoryChange.			self environment: RBBrowserEnvironment new.			newClasses := IdentityDictionary new.			changedClasses := IdentityDictionary new.			removedClasses := Set new.			implementorsCache := IdentityDictionary new.			sendersCache := IdentityDictionary new')abstractVariableReferences  instanceVariables do: [:instVar |  self abstractReferenceTo: instVar ]testTransform  | transformation newClass superclass |  transformation := (RBRemoveClassTransformation className: self changeMock name) transform.  self assert: transformation model changes changes size equals: 1.  newClass := transformation model classNamed: self changeMock name asSymbol.  superclass := transformation model classNamed: #Object.  self assert: newClass isNil.  newClass := self changeMock name.  self assert: ((superclass subclasses collect: #name) includes: newClass) not.  self assert: ((superclass theMetaClass subclasses collect: #name) includes: newClass) notaddClass  transformations add: (RBAddClassTransformation model: self model addClass: newClassName superclass: #Object subclasses: #() category: class category)caller  | anObject |  anObject := 5.  self called: anObject + 1 on: [ ^anObject ]senders  senders ifNil: [ senders := Set new.        self model allReferencesTo: oldSelector do: [:each |  senders add: each modelClass ] ].  ^sendersmyConditions  self getNewSelector.  expressions := self allExpressionsToInline.  ^(RBCondition definesSelector: oldSelector in: class) & ((RBCondition withBlock: [ expressions isNotEmpty ]) errorMacro: 'No callers. Use Remove Method instead.') & ((RBCondition withBlock: [ expressions size = 1 ]) errorMacro: 'All values passed as this argument must be identical.') & ((RBCondition withBlock: [ expressions first isLiteralNode ]) errorMacro: 'All values passed must be literal.')testRefactoring  | refactoring class |  refactoring := (RBAddTemporaryVariableTransformation variable: 'variable2' inMethod: #methodBefore inClass: #RBAddReturnStatementTransformationTest) asRefactoring transform.  self assert: refactoring model changes changes size equals: 1.  class := refactoring model classNamed: #RBAddReturnStatementTransformationTest.  self assert: (class directlyDefinesMethod: #methodBefore).  self assert: (class parseTreeFor: #methodBefore) temporaries size equals: 2equalNotUsed  | string |  string = '' yourself.  (1 to: 10) do: [:i |  string := i printString ].  ^stringtestTransform  | transformation class |  transformation := (RBAddMethodTransformation sourceCode: 'foo									| temp bar |									bar := 5.									temp := bar * bar.									Transcript show: temp printString; cr.									^temp * temp' in: self changeMock name withProtocol: #accessing) transform.  transformation := (RBRenameTemporaryVariableTransformation model: transformation model rename: #temp to: #temp2 in: self changeMock name selector: #foo) transform.  self assert: transformation model changes changes size equals: 2.  class := transformation model classNamed: self changeMock name.  self assert: (class directlyDefinesMethod: #foo).  self assert: (class parseTreeFor: #foo) temporaries size equals: 2.  self assert: ((class parseTreeFor: #foo) temporaries anySatisfy: [:e |  e name = #temp2 ])testAllClassesDo  | model classes |  classes := 0.  model := modelFactory rbNamespace new.  model allClassesDo: [:each |  each name = #Object ifTrue: [ each allSubclasses ].        classes := classes + 1 ].  RBBrowserEnvironment new classesDo: [:each |  classes := classes - 1 ].  self assert: classes equals: 0testPushDownClassVariable  | refactoring |  refactoring := RBPushDownClassVariableRefactoring variable: #Foo1 class: RBLintRuleTestData.  self assert: ((refactoring model classNamed: #RBLintRuleTestData) directlyDefinesClassVariable: #Foo1).  self executeRefactoring: refactoring.  (refactoring model classNamed: #RBLintRuleTestData) withAllSubclasses do: [:each |  self deny: (each directlyDefinesClassVariable: #Foo1) ]transform  target compile: (class sourceCodeFor: selector) classified: (class protocolsFor: selector).  class removeMethod: selectorchanges  ^#()processCollectionMessagesFor: variableName in: aParseTree  | parent block |  aParseTree isMessage ifFalse: [ ^self ].  (#(anyOne at: #at:ifAbsent: #at:ifAbsentPut: atPin: atRandom atRandom: atWrap: eight fifth first fourth last middle ninth second seventh sixth third) includes: aParseTree selector) ifTrue: [ parent := aParseTree parent.        (parent notNil and: [ parent isMessage ]) ifFalse: [ ^self ].        aParseTree == parent receiver ifFalse: [ ^self ].        (variableMessages at: (self collectionNameFor: variableName) ifAbsentPut: [ Set new ]) add: parent selector.        self processCollectionMessagesFor: (self collectionNameFor: variableName) in: parent ].  (#(allSatisfy: anySatisfy: collect: #collect:as: detect: #detect:ifNone: detectMax: detectMin: detectSum: do: #do:displayingProgress: #do:separatedBy: #flatCollect: noneSatisfy: reject: select:) includes: aParseTree selector) ifTrue: [ block := aParseTree arguments first.        block isBlock ifFalse: [ ^self ].        self processCollectionFor: variableName messagesTo: block arguments first name in: block ].  (#(reduce: reduceLeft: reduceRight:) includes: aParseTree selector) ifTrue: [ block := aParseTree arguments last.        block isBlock ifFalse: [ ^self ].        block arguments do: [:node |  self processCollectionFor: variableName messagesTo: node name in: block ] ].  #inject:into: = aParseTree selector ifTrue: [ block := aParseTree arguments last.        block isBlock ifFalse: [ ^self ].        self processCollectionFor: variableName messagesTo: block arguments last name in: block ]deleteSelectors  selectors do: [:selector |  class withAllSubclasses do: [:aClass |  self delete: selector in: aClass ] ]includesClass: aClass  ^(environment includesClass: aClass) and: [ aClass selectors anySatisfy: [:each |  self includesSelector: each in: aClass ] ]copyEmpty  ^self class newtestPragmaDoesNotExist  self shouldFail: (RBRemovePragmaTransformation pragma: '<gtPresentationOrder: 34>' inMethod: #methodBefore inClass: #RBRemovePragmaTransformationTest) asRefactoringincludesClassNamed: aSymbol  ^(self classNamed: aSymbol) notNilat: aKey  ^self at: aKey ifAbsent: [ self error: aKey printString , ' not found' ]errorBlockFor: aBoolean  ^aBoolean ifTrue: [ nil ] ifFalse: [ failed = #leftFailed ifTrue: [ left errorBlock ] ifFalse: [ right errorBlock ] ]testRenameClass  | change |  change := changes renameClass: self class to: self class name , 'Plus'.  self assert: change oldName equals: self class name.  self assert: change newName equals: self class name , 'Plus'.  self assert: change changeClass equals: self class.  self universalTestFor: changestoreOn: aStream  aStream     nextPut: $(;     nextPutAll: self class name;     nextPutAll: ' onEnvironment: '.  environment storeOn: aStream.  aStream nextPutAll: ' packageNames: '.  self packageNames asArray storeOn: aStream.  aStream nextPut: $)removeClassVariable: aString  self privateClassVariableNames remove: aString asSymbol.  model removeClassVariable: aString from: selfprintOn: aStream  aStream nextPutAll: self displayStringsetUp  super setUp.  universalEnvironment := RBBrowserEnvironment newsetUp  super setUp.  workingEnvironment := Smalltalk globals.  self createMockClass.  changeFactory := RBRefactoryChangeManager changeFactory.  changes := changeFactory compositeRefactoryChangeNamed: 'testing'smallLintCritics  ^self asSelectorEnvironment smallLintCriticsisMultiEnvironment  ^falseliteralArrayWithTrueFalseOrNil2  | b c |  b := #(#true #false #nil).  c := #(#true #(#true #false #nil) #false #nil).  ^bdefiningBlock  | node definingNode |  node := self definingMethod ifNil: [ self refactoringError: 'Method does not exist' ] ifNotNil: [:methodNode |  methodNode variableWith: variableName ].  node ifNil: [ self refactoringError: 'Unable to locate temporary variable in parse tree' ].  definingNode := node whoDefines: variableName.  definingNode ifNil: [ self refactoringError: 'Cannot locate variable definition' ].  definingNode isSequence ifFalse: [ self refactoringError: 'Variable is an argument' ].  ^definingNoderun  ^Object printOn: selfselector: aSymbol  selector := aSymbolmethodBefore  | variable |  variable := 'String'.  variable byteAt: 1testMethodIsReferenced  self shouldFail: (RBRemoveMethodTransformation selector: #checkClass: from: #RBBasicLintRuleTestData) asRefactoringisComposite  ^falseviewResults  self subclassResponsibilitymessageSendWith: aMethodName and: newArguments needsReturn: aBoolean  ^String streamContents: [:string |  aBoolean ifTrue: [ string nextPutAll: '^ ' ].        assignments size = 1 ifTrue: [ string                 nextPutAll: assignments first asString;                 nextPutAll: ' := ' ].        string nextPutAll: 'self '.        aMethodName arguments ifEmpty: [ string nextPutAll: aMethodName selector asString ] ifNotEmpty: [ aMethodName selector keywords size = aMethodName arguments size ifTrue: [ aMethodName selector keywords with: aMethodName arguments do: [:key :arg |  string                             nextPutAll: key asString;                             nextPut: $ .                          (newArguments includesKey: arg asString) ifTrue: [ string nextPutAll: (newArguments at: arg asString) ] ifFalse: [ string nextPutAll: arg asString ].                          string nextPut: $  ] ] ] ]category: aString for: aClass  ^self addChange: (RBClassCategoryChange category: aString for: aClass)setUp  super setUp.  model := self abstractVariableTestDataname: aSymbol  name := aSymbolcheckBrowseOccurrenceIn: aRBMethod  self refactoringError: ('Possible call to <2s> in <1p><n>Browse references?' expandMacrosWith: aRBMethod modelClass with: selector) with: [ self openBrowserOn: (RBBrowserEnvironment new referencesTo: selector) ]hash  ^self changeClassName hashsharedPoolNames  ^poolDictionaryNamesisMeta  ^trueifTrueBlocks  ^true ifFalse: self fooaddSearchStringFrom: aCritique in: aSourceCode  aCritique sourceAnchor providesInterval ifTrue: [ | interval |        interval := aCritique sourceAnchor interval.        result addSearchString: (aSourceCode copyFrom: interval first to: interval last) ]testTransform  | transformation class |  transformation := (RBRenameAndDeprecateClassTransformation rename: self changeMock name to: #RBRefactoringChangeMock2) transform.  self assert: transformation model changes changes size equals: 7.  class := transformation model classNamed: self changeMock name asSymbol.  self deny: class isNil.  self assertEmpty: class selectors.  self assert: class superclass name equals: #RBRefactoringChangeMock2.  self assert: class comment equals: 'Deprecated!!! Use superclass'.  class := transformation model classNamed: #RBRefactoringChangeMock2.  self denyEmpty: class selectors.  class := transformation model classNamed: #TmpSubclass , self changeMock name asSymbol.  self assert: class isNilspecialSelectors  | answer |  answer := IdentityDictionary new.  (Smalltalk specialSelectors select: [:sel |  sel isSymbol ]) do: [:sel |  answer at: sel put: nil ].  ^answeraddInstanceVariable: aString to: aRBClass  ^changes addInstanceVariable: aString to: aRBClassmsg3  ^Var1initialize  super initialize.  shouldFixSubclasses := true.  shouldCopyExtensions := true.  shouldRemoveExtensions := truetestExistingName  self shouldFail: (RBRenameClassTransformation rename: self class to: #Object) asRefactoringcategory: anObject  category := anObjectprintOn: aStream  aStream     nextPutAll: class name;     cr.  class instanceVariableNames do: [:each |  aStream           tab;           nextPutAll: each;           tab;           nextPut: $<.        self printTypeFor: each on: aStream.        aStream           nextPut: $>;           cr ]calculateArguments  | allVariables accesses assigned |  allVariables := parseTree allDefinedVariables difference: subtree allDefinedVariables.  accesses := allVariables select: [:each |  subtree references: each ].  assigned := allVariables select: [:each |  subtree assigns: each ].  ^accesses asOrderedCollection difference: assignedtextToDisplay  ^self definitionassociationIndex  ^selectedAssociationIndex ifNil: [ selectedAssociationIndex := 0 ]returnsBooleanAndOther  self isVariable ifTrue: [ ^false ].  self printStringcheckInstVars  selectors do: [:each |  self checkInstVarsFor: each ]includesClass: aClass  | doesntHaveSelectors |  (environment includesClass: aClass) ifFalse: [ ^false ].  (andedEnvironment includesClass: aClass) ifFalse: [ ^false ].  doesntHaveSelectors := true.  environment selectorsForClass: aClass do: [:each |  doesntHaveSelectors := false.        (andedEnvironment includesSelector: each in: aClass) ifTrue: [ ^true ] ].  ^doesntHaveSelectorsprivateTransform  | methodTree messageNode |  methodTree := self definingMethod.  messageNode := self parserClass parseExpression: returnValue.  methodTree body addNode: messageNode.  self definingClass compileTree: methodTreeisOverridden  | selector |  selector := self inlineSelector.  self inlineClass allSubclassesDo: [:each |  (each directlyDefinesMethod: selector) ifTrue: [ ^true ] ].  ^falsetestVariableDoesNotExist  self shouldFail: (RBMoveTemporaryVariableDefinitionTransformation variable: #temp inMethod: #displayName inClass: #RBDummyLintRuleTest).  self shouldFail: (RBMoveTemporaryVariableDefinitionTransformation variable: #temp inMethod: #displayName inClass: #RBDummyLintRuleTest) asRefactoringasOrderedCollectionNotNeeded  self foo addAll: (1 to: 10) asOrderedCollectionisSelectorEnvironment  ^truesymbolReference  ^#(#renameThisMethod: #(4 #renameThisMethod:))preconditions  class := self model classObjectFor: className.  ^isClassVariable ifTrue: [ RBCondition definesClassVariable: variableName asSymbol in: class ] ifFalse: [ RBCondition definesInstanceVariable: variableName in: class ]testRecursiveMethod  | class |  model := RBClassModelFactory rbNamespace new.  class := model classNamed: self class name.  class     compile: 'foo ^self foo' classified: #(#accessing);     compile: 'bar ^self foo' classified: #(#accessing).  self executeRefactoring: (RBInlineAllSendersRefactoring model: model sendersOf: #foo in: class).  self assert: (class parseTreeFor: #foo) equals: (self parseMethod: 'foo ^self foo').  self assert: (class parseTreeFor: #bar) equals: (self parseMethod: 'bar ^self foo')includesProtocol: aProtocol in: aClass  ^(environment includesProtocol: aProtocol in: aClass) and: [ self packages anySatisfy: [:package |  package includesMethodCategory: aProtocol ofClass: aClass ] ]implementorsCanBePrimitives  ^falseselector  ^selectorfoo  ^6placeholderNode  | node |  node := self parseTreeSearcherClass treeMatching: self methodDelimiter in: modifiedParseTree.  node ifNil: [ self refactoringFailure: 'Cannot extract code' ].  ^nodetempVarOverridesInstVar  | temporaryVariable |  temporaryVariable := 4.  ^temporaryVariablemetaclassNamed: aSymbol  | class |  aSymbol ifNil: [ ^nil ].  (self hasRemoved: aSymbol) ifTrue: [ ^nil ].  (newClasses includesKey: aSymbol) ifTrue: [ ^(newClasses at: aSymbol) last ].  (changedClasses includesKey: aSymbol) ifTrue: [ ^(changedClasses at: aSymbol) last ].  class := environment at: aSymbol ifAbsent: [ nil ].  (class isBehavior or: [ class isTrait ]) ifTrue: [ ^(self createNewClassFor: class) last ].  ^nildeprecatedClass  ^deprecatedClassmodel: aRBNamespace  model := aRBNamespaceselfSendIn: aTree  | searcher |  searcher := self parseTreeSearcher.  searcher matches: self messagePattern do: [:aNode :answer |  ^aNode ].  ^searcher executeTree: aTree initialAnswer: nilprintOn: aStream  environment printOn: aStream.  aStream nextPutAll: ' & '.  andedEnvironment printOn: aStreamremoveAssociation  [ | association argument value |  association := argsAndValues associations at: self associationIndex.  argument := association key.  value := association value.  tree := RBParseTreeRewriter replace: argument with: value in: tree.  argsAndValues removeKey: argument.  argumentsList add: argument.  valuesList add: value.  sourceCodeMorph contents: self sourceCode.  self     changed: #associations;     changed: #arguments;     changed: #values;     changed: #isOkEnabled ] on: Error do: [ self inform: 'Please select one association to remove.' ]addStatementNode: aNode  aNode isMessage ifTrue: [ ^statementNodes add: aNode ].  aNode isCascade ifTrue: [ ^statementNodes addAll: aNode messages ].  self refactoringFailure: aNode formattedCode , ' is not a valid message'buildTransformations  subtree := self calculateSubtree.  ^(parseTree isNil or: [ subtree isNil ]) ifTrue: [ OrderedCollection new ] ifFalse: [ | tempsToRemove |        arguments := self calculateArguments.        temporaries := self calculateTemporaries.        assignments := self calculateAssignments.        tempsToRemove := self calculateTemporariesToRemove.        assignments size > 1 ifTrue: [ OrderedCollection new ] ifFalse: [ | newMethodName newArguments messageSend needsReturn |              newMethodName := self newMethodName.              newMethodName ifNil: [ ^OrderedCollection new ].              needsReturn := self calculateIfReturnIsNeeded.              newMethod := self generateNewMethodWith: newMethodName.              newArguments := self calculateNewArgumentsIn: newMethodName.              messageSend := self messageSendWith: newMethodName and: newArguments needsReturn: needsReturn.              OrderedCollection new                 add: (RBAddMethodTransformation model: self model sourceCode: newMethod newSource in: class withProtocol: Protocol unclassified);                 add: (RBReplaceSubtreeTransformation model: self model replace: sourceCode to: messageSend inMethod: selector inClass: class);                 addAll: (tempsToRemove collect: [:temporary |  RBRemoveTemporaryVariableTransformation model: self model variable: temporary inMethod: selector inClass: class ]);                 yourself ] ]testModelExtractMethodWithTemporariesSelected  | class refactoring |  model := RBClassModelFactory rbNamespace new.  class := model classNamed: self class name.  class compile: 'foo [| temp | temp := 5. temp * temp] value' classified: #(#accessing).  refactoring := RBExtractMethodRefactoring model: model extract: (6 to: 36) from: #foo in: class.  self setupMethodNameFor: refactoring toReturn: #foobar.  self executeRefactoring: refactoring.  self assert: (class parseTreeFor: #foo) equals: (self parseMethod: 'foo [self foobar] value').  self assert: (class parseTreeFor: #foobar) equals: (self parseMethod: 'foobar |temp | temp := 5. ^temp * temp')printOn: aStream  aStream     nextPutAll: self displayClassName;     nextPutAll: ' removeProtocolNamed: ';     print: self displayProtocolName;     nextPutAll: ' stamp: ';     print: self changeStamp;     nextPutAll: '!'calls1  ^self rewriteRule10: (self rewriteRule10: self calls)storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' className ''';     nextPutAll: className;     nextPutAll: ''' newClassName: ''';     nextPutAll: newClassName.  aStream nextPut: $)testPushDownNonExistantMenu  | refactoring |  refactoring := RBPushDownMethodRefactoring pushDown: #(#someMethodThatDoesNotExist) from: RBLintRuleTestData.  self shouldFail: refactoringwhileTrue  | i |  i := 1.  [ i < self size ] whileTrue: [ (self at: i) printString.        i := i + 1 ]endTrueFalse  self isVariable ifTrue: [ self printString.        self isVariable printString ] ifFalse: [ self printString.        ^4 ]smallLintCritics  | array |  array := OrderedCollection new.  self classes do: [:cl |  self selectorsForClass: cl do: [:sel |  array add: cl >> sel ] ].  ^arraydescription  ^self changes nameisEmpty  ^(rules detect: [:each |  each isEmpty not ] ifNone: [ nil ]) isNilrenameThisMethod: anArg  ^selftestAPI  | incompleteTransformations |  incompleteTransformations := RBTransformation allSubclasses select: [:each |  | selectors |        selectors := each methods collect: #selector.        each subclasses isEmpty and: [ (selectors includes: #privateTransform) not and: [ (selectors includes: #storeOn:) not ] ] ].  self assertEmpty: incompleteTransformations.  incompleteTransformations := RBCompositeTransformation allSubclasses select: [:each |  | selectors |        selectors := each methods collect: #selector.        each subclasses isEmpty and: [ (selectors includes: #buildTransformations) not ] ].  self assertEmpty: incompleteTransformationsmoveMethod  | variable refactoring |  variable := self selectVariableToMoveMethodTo: extractedMethodSelector class: class.  variable ifNil: [ self refactoringFailure: 'Did not extract method' ].  refactoring := RBMoveMethodRefactoring model: self model selector: extractedMethodSelector class: class variable: variable.  self performComponentRefactoring: refactoringmultipleCalls  self caller2.  self caller2whichSelectorsReferToInstanceVariable: aString  | selectors |  selectors := Set new.  newMethods ifNotNil: [ newMethods do: [:each |  (each refersToVariable: aString) ifTrue: [ selectors add: each selector ] ] ].  self isDefined ifTrue: [ selectors addAll: (self existingMethodsThatReferToInstanceVariable: aString) ].  ^selectorsthreeElementPoint  ^(5 @ 5 + 6) @ 6buildSimpleLiteralSearch  | search |  search := self parseTreeSearcher.  search matchesAnyTreeOf: (Array with: (RBParser parseExpression: '#(''bugs'' ''possible bugs'' ''unnecessary code'' ''intention revealing'' ''miscellaneous'')')) do: [:aNode :answer |  answer           remove: self currentSelector ifAbsent: [ self error: 'failed' ];           yourself ].  search answer: #(#protocolsToCheck) asBag.  (classSearches at: RBBasicLintRuleTestData class ifAbsentPut: [ Set new ]) add: searchasUndoOperation  ^self class definition: self changeClass class oldDefinitionrewriteCascadedMessage  | index messages |  messages := sourceMessage parent messages.  index := (1 to: messages size) detect: [:i |  sourceMessage == (messages at: i) ] ifNone: [ 0 ].  inlineParseTree body addNodesFirst: (messages copyFrom: 1 to: index - 1).  self removeReturns.  inlineParseTree body addNodes: (messages copyFrom: index + 1 to: messages size).  inlineParseTree addReturntestAddClassInstanceVariable  | change |  change := changes addInstanceVariable: 'instVar' to: self class class.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class class.  self assert: change isMeta.  self assert: change variable equals: 'instVar'.  self universalTestFor: changepullUpPoolVariables  | newSuperclass |  newSuperclass := self abstractSuperclass.  parent sharedPoolNames do: [:each |  newSuperclass addPoolDictionary: each ]consistencyCheck  ^(1 to: 10) size > 0inlineFoo: aBlock  | bar baz asdf |  bar := aBlock value: self.  baz := bar + bar.  asdf := baz + bar.  ^asdfstoreOn: aStream  aStream nextPut: $(.  super storeOn: aStream.  aStream nextPutAll: ' categories: '.  categories asArray storeOn: aStream.  aStream nextPut: $)pushDown: aSelector  | code protocols refactoring |  code := class sourceCodeFor: aSelector.  protocols := class protocolsFor: aSelector.  refactoring := RBExpandReferencedPoolsRefactoring model: self model forMethod: (class parseTreeFor: aSelector) fromClass: class toClasses: class subclasses.  self performComponentRefactoring: refactoring.  class subclasses do: [:each |  (each directlyDefinesMethod: aSelector) ifFalse: [ each compile: code classified: protocols ] ]testRemoveClass  | change |  change := changes removeClass: self class.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self universalTestFor: changeleaves  ^rules flatCollect: [:rule |  rule leaves ]checkReferences  | occurrences |  occurrences := OrderedCollection new.  self model allReferencesTo: selector do: [:aRBMethod |  selector = aRBMethod selector ifFalse: [ occurrences add: selector -> aRBMethod ] ].  occurrences ifEmpty: [ ^self ].  ^self checkBrowseOccurrences: occurrencescategory: anObject  category := anObjecttestExtractFailure  self     shouldFail: (RBExtractMethodRefactoring extract: (80 to: 269) from: #subclassOf:overrides: in: RBBasicLintRuleTestData class);     shouldFail: (RBExtractMethodRefactoring extract: (53 to: 56) from: #subclassOf:overrides: in: RBBasicLintRuleTestData class);     shouldFail: (RBExtractMethodRefactoring extract: (77 to: 222) from: #subclassResponsibilityNotDefined in: RBBasicLintRuleTestData class)execute: aString  ^matchers inject: aString asString into: [:string :assoc |  self execute: string replace: assoc key with: assoc value ]classVariableNames  ^classVariableNamestestNonExistantName  self     shouldFail: (RBTemporaryToInstanceVariableRefactoring class: RBBasicLintRuleTestData selector: #checkClass: variable: 'asdf');     shouldFail: (RBTemporaryToInstanceVariableRefactoring class: RBBasicLintRuleTestData selector: #checkClass1: variable: 'aSmalllintContext')testRenameInstVar  | refactoring class |  refactoring := RBRenameInstanceVariableRefactoring rename: 'classBlock' to: 'asdf' in: RBBasicLintRuleTestData.  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBBasicLintRuleTestData.  self assert: (class directlyDefinesInstanceVariable: 'asdf').  self deny: (class directlyDefinesInstanceVariable: 'classBlock').  self assert: (class parseTreeFor: #checkClass:) equals: (self parseMethod: 'checkClass: aSmalllintContext 								^asdf value: aSmalllintContext value: result').  self assert: (class parseTreeFor: #initialize) equals: (self parseMethod: 'initialize	super initialize.	self anInstVar: 1.	asdf := [:context :aResult | ].	methodBlock := [:context :aResult | ].	self resultClass: RBSelectorEnvironment')replaceClassNameIn: definitionString to: aSymbol  | parseTree |  parseTree := self parserClass parseExpression: definitionString.  parseTree receiver: (RBVariableNode named: aSymbol).  ^parseTree formattedCodemodelClass: aRBClass  class := aRBClassincludesCategory: aCategory  ^(super includesCategory: aCategory) and: [ self packages anySatisfy: [:package |  package includesSystemCategory: aCategory ] ]usesTrue  ^TrueproblemCount  ^rules inject: 0 into: [:count :each |  count + each problemCount ]errorStringFor: aBoolean  ^self errorMacro expandMacrosWith: aBooleanprivateTransform  isClassVariable ifTrue: [ self definingClass theNonMetaClass removeClassVariable: variableName ] ifFalse: [ self definingClass removeInstanceVariable: variableName ]transform  self refactorings do: [:each |  self performComponentRefactoring: each ]testRenameClassInstanceVariable  | change |  change := changes renameInstanceVariable: 'instVar1' to: 'instVar2' in: self class class.  self assert: change changeClassName equals: self class name.  self assert: change oldName equals: 'instVar1'.  self assert: change newName equals: 'instVar2'.  self universalTestFor: changestoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' pullUp: '.  selectors asArray storeOn: aStream.  aStream nextPutAll: ' from: '.  class storeOn: aStream.  aStream nextPut: $)skipAction: aBlock  skipAction := aBlockinlineSelfSends  class withAllSubclasses do: [:each |  | selectors |        selectors := each selectors.        selectors remove: selector ifAbsent: [  ].        selectors do: [:sel |  self inlineMessagesInClass: each andSelector: sel ] ]testMetaclassInstanceVariables  | refactoring class |  class := model metaclassNamed: #Foo.  class addInstanceVariable: 'foo'.  class compile: 'zzz ^foo := foo + foo * 2' classified: #(#testing).  refactoring := RBAbstractInstanceVariableRefactoring model: model variable: 'foo' class: class.  self executeRefactoring: refactoring.  self assert: (class parseTreeFor: #foo1) equals: (self parseMethod: 'foo1						^foo').  self assert: (class parseTreeFor: #foo:) equals: (self parseMethod: 'foo: anObject						^foo := anObject').  self assert: (class parseTreeFor: #zzz) equals: (self parseMethod: 'zzz ^self foo: self foo1 + self foo1 * 2')checkAllBlocksIn: aParseTree  | searcher |  searcher := self parseTreeSearcher.  searcher matches: '[:`@blockTemps | | `@temps | `@.Statements]' do: [:aNode :answer |  (aNode references: variableName) ifTrue: [ answer add: aNode ].        answer ].  ^searcher executeTree: aParseTree initialAnswer: OrderedCollection newrewriteRule10  ^rewriteRule10renameClass: aRBClass to: aSymbol around: aBlock  | change value dict |  change := changeFactory renameClass: aRBClass to: aSymbol.  self performChange: change around: aBlock.  self flushCaches.  dict := (newClasses includesKey: aRBClass name) ifTrue: [ newClasses ] ifFalse: [ changedClasses ].  self markAsRemoved: aRBClass name.  self unmarkAsRemoved: aSymbol.  value := dict at: aRBClass name.  dict removeKey: aRBClass name.  dict at: aSymbol put: value.  value first name: aSymbol.  value last name: aSymbol.  value first subclasses do: [:each |  each superclass: value first ].  value last subclasses do: [:each |  each superclass: value last ].  ^changeremoveMethod: aSelector from: aClass  ^RBRemoveMethodChange remove: aSelector from: aClassincludesClass: aClass  (environment includesClass: aClass) ifFalse: [ ^true ].  ^falsecategory: aSymbol  category := aSymbolenvironmentWithReferencesTo: aClass  ^RBBrowserEnvironment new referencesTo: (self environment associationAt: aClass ifAbsent: [ aClass ])changeSymbol  self subclassResponsibilitynewTree  ^treetoDoWithIncrement  | counter |  counter := 0.  1 to: 10 by: 2 do: [:i |  counter := counter + 2 ].  ^countertestModelAddMethod  | refactoring class |  class := model metaclassNamed: #Bar.  refactoring := RBAddMethodRefactoring model: model addMethod: 'printString1 ^super printString' toClass: class inProtocols: #(#accessing).  self executeRefactoring: refactoring.  self assert: (class parseTreeFor: #printString1) equals: (self parseMethod: 'printString1 ^super printString')on: aDictionary  aDictionary keysAndValuesDo: [:class :selectors |  class isMeta ifTrue: [ metaClassSelectors at: class soleInstance name put: selectors asIdentitySet ] ifFalse: [ classSelectors at: class name put: selectors asIdentitySet ] ]getArgumentNameForSelf  self needsToReplaceSelfReferences ifFalse: [ ^self ].  [ selfVariableName := self requestSelfArgumentName.  (self checkInstanceVariableName: selfVariableName in: class) ifTrue: [ self verifyTemporaryVariableDoesNotOverride ifFalse: [ self refactoringWarning: 'The variable is already defined in one of the classes you''re moving the method to.<n>Try another?' expandMacros.              selfVariableName := nil ] ] ifFalse: [ self refactoringWarning: 'The variable name is not a valid Smalltalk temporary variable name<n>Try again?' expandMacros.        selfVariableName := nil ].  selfVariableName isNil ] whileTrue: [  ]testRemoveClassInstanceVariable  | change |  change := changes removeInstanceVariable: 'instVar' from: self class class.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class class.  self assert: change isMeta.  self assert: change variable equals: 'instVar'.  self universalTestFor: changedirectlyDefinesClassVariable: aString  ^self instanceSide directlyDefinesClassVariable: aStringhasPoolsToMove  ^pools isNotEmptychangeIsKindOfReferences  | replacer |  replacer := RBParseTreeRewriter new.  replacer replace: '``@object isKindOf: ' , parent name with: '``@object isKindOf: ' , className.  self convertAllReferencesToClass: parent using: replacerlongMethods  self printString.  self printString.  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ]addClass: aClass selector: aSymbol into: aValue  (environmentDictionaries at: aValue ifAbsentPut: [ RBSelectorEnvironment new ]) addClass: aClass selector: aSymbolcontext: aSmalllintContext  context := aSmalllintContextsymbolReference  ^#RBDummyClassToRenamecompileHash  | method statement hash |  method := self parserClass parseMethod: 'hash		"Answer an integer value that is related to the identity of the receiver."'.  statement := nil.  variables reversed do: [:each |  hash := RBMessageNode receiver: (RBVariableNode named: each) selector: #hash.        statement := statement ifNil: [ hash ] ifNotNil: [ RBMessageNode receiver: hash selector: #bitXor: arguments: (Array with: statement) ] ].  method     addNode: statement;     addReturn.  self theClass compile: method formattedCode classified: #(comparing)allClassesAndTraits  | allClassesAndTraits |  allClassesAndTraits := OrderedCollection new: 4096.  self allClassesAndTraitsDo: [:each |  allClassesAndTraits add: each ].  ^allClassesAndTraits asArraytestExtractFailure  self shouldFail: (RBReplaceSubtreeTransformation replace: ':= aSelector' to: '^ selector' inMethod: #selector:from: inClass: #RBRemoveMethodTransformation) asRefactoringinlineForwarder  | refactoring |  refactoring := RBInlineAllSendersRefactoring model: self model sendersOf: extractedMethodSelector in: class.  refactoring setOption: #inlineExpression toUse: [:ref :string |  true ].  self performComponentRefactoring: refactoringcheckMethod: aMethod  rules do: [:each |  each checkMethod: aMethod ]testEmptyCode  | transformation |  transformation := (RBRemoveSubtreeTransformation code: '' from: #one in: self changeMock name) transform.  self assertEmpty: transformation model changes changes.  self shouldFail: (RBRemoveSubtreeTransformation code: '' from: #selector:from: in: #RBRemoveMethodTransformation) asRefactoringtestMethod1  ^self testMethod1 , ([:each |  each testMethod1 ] value: #(#(#testMethod1) 2 #testMethod1))printOn: aStream  aStream     nextPutAll: self displayClassName;     nextPutAll: ' removeClassVarName: ';     print: self oldName;     nextPut: $!;     cr.  aStream     nextPutAll: self displayClassName;     nextPutAll: ' addClassVarName: ';     print: self newName;     nextPut: $!parseTreeRewriter  | rewriteRule oldString newString |  rewriteRule := RBParseTreeRewriter new.  oldString := self buildSelectorString: oldSelector.  newString := self buildSelectorString: newSelector withPermuteMap: permutation.  rewriteRule replace: '``@object ' , oldString with: '``@object ' , newString.  ^rewriteRulecalls1  ^self rewriteRule1: (self rewriteRule1: self calls)removePoolDictionary: aString  self privatePoolDictionaryNames remove: aString asSymboltestRenameInstanceVariable  | change |  change := changes renameInstanceVariable: 'instVar1' to: 'instVar2' in: self class.  self assert: change changeClassName equals: self class name.  self assert: change oldName equals: 'instVar1'.  self assert: change newName equals: 'instVar2'.  self universalTestFor: changeaddClass: aClass instanceVariableReader: aString  (instanceVariableReaders at: aClass name ifAbsentPut: [ Set new ]) add: aString.  self flushCachesFor: aClass.  self addSearchString: aStringtestNewInstanceVariableAccessors  | refactoring class |  refactoring := (RBAddVariableAccessorTransformation instanceVariable: 'foo1' class: #RBDummyLintRuleTest) asRefactoring transform.  class := refactoring model classNamed: #RBDummyLintRuleTest.  self denyEmpty: refactoring changes changes.  self assert: (class parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 ^foo1').  self assert: (class parseTreeFor: #foo1:) equals: (self parseMethod: 'foo1: anObject foo1 := anObject')disconnectFromChanges  SystemAnnouncer uniqueInstance unsubscribe: selftestCompileInMetaclass  | change |  change := changes compile: 'new' in: self class class.  self assert: change controller isNil.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class class.  self assert: change isMeta.  self assert: change selector equals: #new.  self assert: change source equals: 'new'.  self assert: change protocol equals: #accessing.  self universalTestFor: changetransform  self     abstractVariables;     addSelfReturn;     replaceSelfReferences;     replaceVariableReferences;     compileNewMethods;     compileDelegatorMethodtheClass  ^(self classObjectFor: className) instanceSideverifyTemporaryVariableDoesNotOverride  (parseTree allDefinedVariables includes: selfVariableName) ifTrue: [ ^false ].  ^moveToClasses noneSatisfy: [:each |  each definesVariable: selfVariableName ]storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' variable: ''';     nextPutAll: variableName;     nextPutAll: ''' inInterval: ''';     nextPutAll: interval;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: aStream.  aStream nextPut: $)hasReferencesToTemporaryIn: each  | tree |  tree := each parseTreeFor: oldSelector.  tree ifNil: [ self refactoringFailure: 'Cannot parse sources.' ].  ^tree references: (tree argumentNames at: parameterIndex)testInlineMethod4  | refactoring |  refactoring := RBInlineMethodRefactoring inline: (31 to: 112) inMethod: #inlineJunk forClass: RBRefactoryTestDataApp.  self setupInlineExpressionFor: refactoring toReturn: false.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineJunk) equals: (self parseMethod: 'inlineJunk										| asdf bar1 baz1 asdf1 |										bar1 := 												[:each | 												| temp |												temp := each.												temp , temp] value: self.										baz1 := bar1 + bar1.										asdf1 := baz1 + bar1.										asdf := asdf1.										^asdf foo: 												[:bar | 												| baz |												baz := bar.												baz * baz]')protocol  ^protocol ifNil: [ UIManager default chooseOrRequestFrom: self definingClass protocols title: 'Class name was not defined to perform ' , self class baseClass name , '. Please select a class to resume this transformation.' ]replaceAllAction: aBlock  replaceAllAction := aBlockcontroller  ^controllerguessTypesFor: anInstVarName in: aClass  class = aClass ifFalse: [ self runOn: aClass ].  ^bestGuesses at: anInstVarName ifAbsent: [ self typesFor: anInstVarName in: aClass ]selectedClass  ^classdisplayCategoryName  ^categorypreconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ (self definingMethod allChildren select: #isMessage) anySatisfy: [:messageNode |  messageNode selector = message asSymbol ] ] errorString: ('Method named <1s> does not implement this message send <2s>' expandMacrosWith: selector with: message))privateTransform  | parseTree newNode |  parseTree := self definingClass parseTreeFor: selector.  parseTree ifNil: [ ^self ].  newNode := self parserClass parseExpression: sourceCode onError: [:string :pos |  ^self ].  parseTree body statements ifEmpty: [ parseTree addNode: newNode.        ^self ].  parseTree := parseTree allSequenceNodes detect: [:sequence |  sequence intersectsInterval: interval ] ifFound: [:sequence |  self addNode: newNode toSequence: sequence ] ifNone: [ parseTree body addNodeLast: newNode.        parseTree ].  self definingClass compileTree: parseTreechangeClassName: aSymbol  className := aSymbol.  isMeta ifNil: [ isMeta := false ]referencesConditionFor: aClass  | environment association |  ^(RBCondition withBlock: [ association := Smalltalk associationAt: aClass name ifAbsent: [ self refactoringError: 'Could not find class' ].        environment := (self environment referencesTo: association) | (self environment referencesTo: aClass name).        environment isEmpty ])     errorMacro: aClass , ' is referenced.<n>Browse references?';     errorBlock: [ environment openEditor ];     yourselfremovePool: aPoolVariable from: aClass  ^self addChange: (changeFactory removePoolVariable: aPoolVariable from: aClass)asRBRule  ^selfunknownFailed  ^(left errorStringFor: false) , ' OR ' , (right errorStringFor: false)addClass  self performComponentRefactoring: (RBAddClassRefactoring model: self model addClass: newClassName superclass: Object subclasses: #() category: class category).  newClass := self model classNamed: newClassName asSymboltestRefactoring  | refactoring class |  refactoring := (RBRemoveVariableTransformation instanceVariable: 'foo1' class: #RBDummyLintRuleTest) asRefactoring.  class := refactoring model classNamed: #RBDummyLintRuleTest.  self assert: (class definesInstanceVariable: 'foo1').  refactoring transform.  self deny: (class definesInstanceVariable: 'foo1')removeClassNamed: aSymbol  (self classNamed: aSymbol) subclasses do: [:each |  self removeClassNamed: each name ].  removedClasses     add: aSymbol;     add: aSymbol , ' class'.  newClasses removeKey: aSymbol ifAbsent: [  ].  changedClasses removeKey: aSymbol ifAbsent: [  ].  self flushCaches.  ^changes removeClassNamed: aSymbolcopyDownMethods  selectors do: [:each |  self copyDownMethod: each ]allInstanceVariableNames  | sprClass |  sprClass := self superclass.  ^sprClass ifNil: [ self instanceVariableNames ] ifNotNil: [ sprClass allInstanceVariableNames , self instanceVariableNames ]allClassesDo: aBlock  self systemDictionaryClassesDo: aBlocktransform  class removeClassVariable: variableName.  destinationClass ifNil: [ ^self ].  destinationClass addClassVariable: variableNamevariableDefinitionsInHierarchy  self flag: #pharoTodo.  ^isClassVariable ifTrue: [ self definingClass allSubclasses reject: [:each |  (each whichSelectorsReferToClassVariable: variableName) isEmpty and: [ (each theMetaClass whichSelectorsReferToClassVariable: variableName) isEmpty ] ] ] ifFalse: [ self definingClass subclasses ]shouldntRaiseError  self shouldnt: [ 0 / 1 ] raise: ErrorliteralArrayWithTrueFalseOrNil  | a b c |  a := #(true false nil).  b := #(#true #false #nil).  c := {true .   false .   nil}.  ^{a .   b .   c}consistencyCheck  ^(1 to: 10) size > 0sizeCheck  self isEmpty ifFalse: [ self do: [:each |  Transcript                 show: each;                 cr ] ]myConditions  | imps |  imps := self model allImplementorsOf: oldSelector.  self getNewSelector.  ^imps inject: (RBCondition definesSelector: oldSelector in: class) into: [:cond :each |  cond & (RBCondition withBlock: [ (self hasReferencesToTemporaryIn: each) not ] errorString: 'This argument is still referenced in at least one implementor!!') ]testRemoveClassWithBadNameRaisesRBRefactoringError  self shouldFail: (RBRemoveClassRefactoring classNames: #(#RecursiveSelfRule))shouldnt: aBlock  self deny: aBlock valuevariable: aVariableName fromClass: fromClassName toClass: toClassName  variableName := aVariableName.  className := toClassName.  oldClass := fromClassNamecheckPackage: aRPackage  (environment includesPackage: aRPackage) ifTrue: [ rule checkPackage: aRPackage ]removeInstanceVariable: aString from: aRBClass  ^changes removeInstanceVariable: aString from: aRBClasstestRefactoring  | refactoring class |  refactoring := (RBRemoveAssignmentTransformation variable: 'variable' value: '1 asString' inMethod: #methodBefore inClass: #RBRemoveAssignmentTransformationTest) asRefactoring transform.  self assert: refactoring model changes changes size equals: 1.  class := refactoring model classNamed: #RBRemoveAssignmentTransformationTest.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) bodysubclassRedefines: aSelector  ^self allSubclasses anySatisfy: [:each |  each directlyDefinesMethod: aSelector ]testRefactoring  | refactoring |  refactoring := (RBAddMethodTransformation sourceCode: 'printString1 ^super printString' in: #RBBasicDummyLintRuleTest withProtocol: #accessing) asRefactoring transform.  self assert: ((refactoring model classNamed: #RBBasicDummyLintRuleTest) parseTreeFor: #printString1) equals: (self parseMethod: 'printString1 ^super printString')instVarNames  ^self selectedClass allInstVarNamesprintOn: aStream  super printOn: aStream.  self selectedClass ifNotNil: [ aStream           nextPut: $ ;           nextPutAll: self selectedClass name.        self selector ifNotNil: [ aStream                 nextPutAll: '>>';                 print: self selector ] ]= aRenameVariableChange  self class = aRenameVariableChange class ifFalse: [ ^false ].  ^className = aRenameVariableChange changeClassName and: [ isMeta = aRenameVariableChange isMeta and: [ oldName = aRenameVariableChange oldName and: [ newName = aRenameVariableChange newName ] ] ]checkMethod: aSmalllintContext  class := aSmalllintContext selectedClass.  (rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: [ (RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) ifFalse: [ builder compile: rewriteRule tree printString in: class classified: aSmalllintContext protocols ] ]allClassVariableNames  ^self instanceSide allClassVariableNamescreateSetterAccessor  (self definingClass setterMethodFor: variableName) ifNil: [ self defineSetterMethod ]classes: classArray metaClasses: metaArray  classSelectors := IdentityDictionary new.  metaClassSelectors := IdentityDictionary new.  classArray do: [:each |  classSelectors at: each first put: each last asIdentitySet ].  metaArray do: [:each |  metaClassSelectors at: each first put: each last asIdentitySet ]transform  self preconditionChecking ifTrue: [ self checkPreconditions ].  self privateTransformwhichSelectorsReferToSymbol: aSymbol  | selectors |  selectors := Set new.  newMethods ifNotNil: [ newMethods do: [:each |  (each refersToSymbol: aSymbol) ifTrue: [ selectors add: each selector ] ] ].  self isDefined ifTrue: [ selectors addAll: (self existingMethodsThatReferTo: aSymbol) ].  ^selectorscomment: aString in: aClass  ^self addChange: (changeFactory comment: aString in: aClass)getClassForGlobalOrClassVariable  | definingClass type |  definingClass := class whoDefinesClassVariable: (variable ifNil: [ '' ]).  definingClass ifNil: [ type := self model classNamed: variable.        type ifNil: [ type := self model classNamed: #Object ] ] ifNotNil: [ type := definingClass typeOfClassVariable: variable ].  moveToClasses := self selectVariableTypesFrom: (Array with: type) selected: (Array with: type).  moveToClasses ifNil: [ self refactoringFailure: 'Method not moved' ]initialize  super initialize.  renameAccessors := falsetestTransform  | transformation class |  transformation := (RBAddPragmaTransformation new pragma: '<gtInspectorPresentationOrder: 56>' inMethod: #methodBefore inClass: self class name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self class name.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) bodyprintOn: aStream  super printOn: aStream.  aStream nextPutAll: ' class'environment  ^environmentremovedMethods  ^removedMethods ifNil: [ removedMethods := Set new ] ifNotNil: [ removedMethods ]preconditionIsNotMetaclass: aClass  ^((RBCondition isMetaclass: aClass) errorMacro: 'Cannot remove just the metaclass') notaddCategory: aSymbol  categories add: aSymbolreferencesFor: aClass  ^isClassVariable ifTrue: [ aClass whichSelectorsReferToClassVariable: variableName ] ifFalse: [ aClass whichSelectorsReferToInstanceVariable: variableName ]renameClass: class to: newName  ^self addChange: (changeFactory renameClass: class to: newName)testExistingVariable  | transformation |  transformation := (RBAddMethodTransformation sourceCode: 'foo									| temp bar |									bar := 5.									temp := bar * bar.									Transcript show: temp printString; cr.									^temp * temp' in: self changeMock name withProtocol: #accessing) transform.  self shouldFail: (RBRenameTemporaryVariableTransformation model: transformation model rename: #temp to: #bar in: self changeMock name selector: #foo)refactoringError: aString with: aBlock  ^RBRefactoringError signal: aString with: aBlocksetUp  super setUp.  model := self abstractVariableTestDataprintOn: aStream  name ifNil: [ ^super printOn: aStream ].  aStream nextPutAll: namedefinitionString  ^String streamContents: [:definitionStream |  definitionStream           nextPutAll: self superclass printString;           nextPutAll: ' subclass: #';           nextPutAll: self name;           nextPutAll: ' instanceVariableNames: '''.        self instanceVariableNames do: [:each |  definitionStream                 nextPutAll: each;                 nextPut: $  ].        definitionStream nextPutAll: ''' classVariableNames: '''.        self classVariableNames do: [:each |  definitionStream                 nextPutAll: each;                 nextPut: $  ].        definitionStream nextPutAll: ''' poolDictionaries: '''.        self poolDictionaryNames do: [:each |  definitionStream                 nextPutAll: each;                 nextPut: $  ].        definitionStream nextPutAll: ''' category: #'''.        definitionStream nextPutAll: self category asString.        definitionStream nextPut: $' ]text  ^'method ^1'orEnvironment: aBrowserEnvironment  orEnvironment := aBrowserEnvironmenttestWithTemporaryVariable2  | refactoring class |  refactoring := (RBExtractMethodTransformation extract: (self sourceCodeAt: (78 to: 197) forMethod: #displayName in: RBDummyLintRuleTest) from: #displayName to: #foo: in: #RBDummyLintRuleTest) asRefactoring transform.  self assert: refactoring model changes changes size equals: 2.  class := refactoring model classNamed: #RBDummyLintRuleTest.  self assert: (class parseTreeFor: #displayName) equals: (self parseMethod: 'displayName					| nameStream |					nameStream := WriteStream on: (String new: 64).					self foo: nameStream.					^nameStream contents').  self assert: (class parseTreeFor: #foo:) equals: (self parseMethod: 'foo: nameStream					nameStream nextPutAll: self name;								nextPutAll: '' (''.					self problemCount printOn: nameStream.					nameStream nextPut: $).')renameClassVariable: oldName to: newName in: aClass  ^self addChange: (changeFactory renameClassVariable: oldName to: newName in: aClass)basicCheck: aMethod  aMethod isFromTrait ifTrue: [ ^false ].  (self rewriteRule canMatchMethod: aMethod) ifFalse: [ ^false ].  class := aMethod methodClass.  ^(self rewriteRule executeTree: aMethod ast copy) and: [ (self class recursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) not ]definition  ^definitionprintOn: aStream  aStream nextPutAll: type asStringtestClassDoesNotExist  self shouldFail: (RBRemoveTemporaryVariableTransformation variable: 'temp' inMethod: #foo inClass: #RBTemporaryVariableTransformationTest) asRefactoringisMovingToArgument  ^(parseTree arguments collect: [:each |  each name ]) includes: variablepossibleSetterSelectors  ^self methodsReferencingVariable select: [:each |  each numArgs == 1 ]transform  | replacement refactoring |  self model allClassesDo: [:class |  (class isNil or: [ class isMeta ]) ifFalse: [ replacement := self execute: class name.              replacement = class name asString ifFalse: [ refactoring := self perform: mode with: class with: replacement asSymbol.                    (refactoring notNil and: [ refactoring preconditions check ]) ifTrue: [ refactoring transform ] ] ] ]renameInstanceVariable: oldName to: newName in: aClass  ^self addChange: (changeFactory renameInstanceVariable: oldName to: newName in: aClass)renameAccessors: anObject  renameAccessors := anObjecttestDoesNotUnderstandAccessors  self     shouldFail: (RBRemoveDirectAccessToVariableTransformation model: model instanceVariable: 'instVarName1' class: #Foo) asRefactoring;     shouldFail: (RBRemoveDirectAccessToVariableTransformation classVariable: 'RecursiveSelfRule' class: #RBTransformationRuleTestData) asRefactoringstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' split: '.  selectedInterval storeOn: aStream.  aStream     nextPutAll: ' inMethod: #';     nextPutAll: selector;     nextPutAll: ' forClass: '.  class storeOn: aStream.  aStream nextPut: $)testMethodDoesNotExist  self shouldFail: (RBAddMessageSendTransformation messageSend: 'variable byteAt: 1' inMethod: #method inClass: #RBAddMessageSendTransformationTest) asRefactoringuncommonMessageSend  true falseenvironmentWithReferencesTo: aClass  ^RBBrowserEnvironment new referencesTo: (Smalltalk globals associationAt: aClass ifAbsent: [ aClass ])name  ^'Guarding clauses'privateInstanceVariableNames  instanceVariableNames ifNil: [ self isDefined ifTrue: [ self instanceVariableNames: self realClass instVarNames ] ifFalse: [ instanceVariableNames := OrderedCollection new ] ].  ^instanceVariableNamesasUndoOperation  ^changeFactory addPoolVariable: self variable to: self changeClasspackages  ^self classes collect: #packageminMax  ^3 < 5 ifTrue: [ 3 ] ifFalse: [ 5 ]hasConflicts  ^falsedefinesClass: aClass  ^environment definesClass: aClassselector: aSymbol class: aClass variable: aVariableName  selector := aSymbol.  class := self classObjectFor: aClass.  variable := aVariableNamenot  ^environmenttestBadName  self     shouldFail: (RBRenameClassTransformation rename: #RBDummyLintRuleTest to: self objectClassVariable) asRefactoring;     shouldFail: (RBRenameClassTransformation rename: #RBDummyLintRuleTest to: #'Ob ject') asRefactoringaddMethod: aRBMethod  self newMethods at: aRBMethod selector put: aRBMethod.  removedMethods notNil ifTrue: [ removedMethods remove: aRBMethod selector ifAbsent: [  ] ]testIsValid  | rbmethod |  rbmethod := RBMethodName selector: #foo: arguments: #('x').  self assert: rbmethod isValid.  rbmethod := RBMethodName selector: #foo:arg: arguments: #('x' 'y').  self assert: rbmethod isValid.  rbmethod := RBMethodName selector: #foo:arg: arguments: #('x').  self deny: rbmethod isValid.  rbmethod := RBMethodName selector: #foo: arguments: #('x' 'y').  self deny: rbmethod isValid.  rbmethod := RBMethodName selector: 'fggfg gg g ' arguments: #('x').  self deny: rbmethod isValidrenameNode: aParseTree  (aParseTree whoDefines: newName) ifNotNil: [ self refactoringError: newName asString , ' is already defined' ].  (aParseTree allDefinedVariables includes: newName) ifTrue: [ self refactoringError: newName asString , ' is already defined' ].  (RBParseTreeRewriter rename: oldName to: newName) executeTree: aParseTreecollectSelectNotUsed  (1 to: 10) select: [:each |  each = 4 ]testClassDoesNotExist  self shouldFail: (RBRemoveMessageSendTransformation messageSend: #byteAt: inMethod: #methodBefore inClass: #RBMessageSendTransformationTest) asRefactoringrealName: aSymbol  self realClass: (self class environment at: aSymbol)basicCheck: anEntity  ^(self leaves select: [:rule |  rule class perform: (anEntity isCompiledMethod ifTrue: [ #checksMethod ] ifFalse: [ #checksClass ]) ]) anySatisfy: [:rule |  rule basicCheck: anEntity ]fillOutDefinition: aDictionary  className := (aDictionary at: '`className') asSymbol.  classInstanceVariableNames := self namesIn: (aDictionary at: '`#instanceVariableNames' ifAbsent: [ String new ])transform  self extractReceiver.  self splitCascadeaddPool: aPoolVariable to: aClass  ^self addChange: (changeFactory addPoolVariable: aPoolVariable to: aClass)preconditions  class := self definingClass.  ^(isClassVariable ifTrue: [ (RBCondition isMetaclass: class) & (RBCondition isValidClassVarName: variableName for: class) ] ifFalse: [ (RBCondition isMetaclass: class) not & (RBCondition isValidInstanceVariableName: variableName for: class) ]) & (RBCondition hierarchyOf: class definesVariable: variableName asString) not & (RBCondition isGlobal: variableName in: self model) nottestPragmaAlreadyExists  self shouldFail: (RBAddPragmaTransformation pragma: '<gtInspectorPresentationOrder: 56>' inMethod: #methodAfter inClass: #RBAddPragmaTransformationTest) asRefactoringviewResults  result openEditortestTransform  | transformation class |  transformation := (RBAddAccessorsForClassTransformation className: self changeMock name) transform.  self assert: transformation model changes changes size equals: 2.  class := transformation model classNamed: self changeMock name asSymbol.  self assert: (class parseTreeFor: #instVar) equals: (self parseMethod: 'instVar ^instVar').  self assert: (class parseTreeFor: #instVar:) equals: (self parseMethod: 'instVar: anObject instVar := anObject')equalsTrue  ^true == selfgetterSetterMethods  | matcher |  matcher := self parseTreeSearcher.  matcher     answer: Set new;     matchesAnyMethodOf: (Array with: '`method ^' , variableName with: ('`method: `arg <1s> := `arg' expandMacrosWith: variableName) with: ('`method: `arg ^<1s> := `arg' expandMacrosWith: variableName)) do: [:aNode :answer |  (class subclassRedefines: aNode selector) ifFalse: [ answer add: aNode selector ].        answer ].  (class whichSelectorsReferToInstanceVariable: variableName) do: [:each |  self checkClass: class selector: each using: matcher ].  ^matcher answerrelease  self printStringcheckVariableName  (class whoDefinesInstanceVariable: newVariableName) ifNotNil: [ self refactoringError: ('<1p> defines an instance variable named <2s>' expandMacrosWith: class with: newVariableName) ].  (class whoDefinesClassVariable: newVariableName) ifNotNil: [ self refactoringError: ('<1p> defines a class variabled named <2s>' expandMacrosWith: class with: newVariableName) ].  (self parseTree allDefinedVariables includes: newVariableName) ifTrue: [ self refactoringError: ('<1s> is already a temporary variable name' expandMacrosWith: newVariableName) ]selectorCacheFor: aClass  ^self selectorCache at: aClass name ifAbsentPut: [ self computeSelectorCacheFor: aClass ]model  ^modeldeleteSelectorInSubclasses  class withAllSubclasses do: [:each |  each implements: selectors ]addMethod: aMethod  self addClass: aMethod methodClass selector: aMethod selectorstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' variable: ''';     nextPutAll: variableName;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: aStream.  aStream nextPut: $)includesCategory: aCategory  ^(self classNamesFor: aCategory) isNotEmptypackagesWithContributors  ^self classes flatCollect: #packages as: SetreplaceClassAccesses  | replacer |  replacer := self parseTreeRewriterClass variable: variableName getter: self getterMethod setter: self setterMethod receiver: self receiver.  self model convertClasses: self definingClass theMetaClass withAllSubclasses select: [:aClass |  (aClass whichSelectorsReferToClassVariable: variableName) reject: [:each |  aClass == self definingClass theMetaClass and: [ each == self getterMethod or: [ each == self setterMethod ] ] ] ] using: replacer.  replacer := self parseTreeRewriterClass variable: variableName getter: 'class ' , self getterMethod setter: 'class ' , self setterMethod.  self model convertClasses: self definingClass theNonMetaClass withAllSubclasses select: [:aClass |  aClass whichSelectorsReferToClassVariable: variableName ] using: replacerlongDescription  self deprecated: 'Please use #rationale  instead' transformWith: '`@receiver longDescription' -> '`@receiver rationale'.  ^self rationalecopyFrom: aSourceClass to: aTargetClass  aSourceClass instanceVariableNames do: [:each |  aTargetClass addInstanceVariable: each ].  aSourceClass isMeta ifFalse: [ aSourceClass allClassVariableNames do: [:each |  aTargetClass addClassVariable: each ].        aSourceClass sharedPoolNames do: [:each |  aTargetClass addPoolDictionary: each ] ].  aSourceClass selectors do: [:each |  aTargetClass compile: (aSourceClass sourceCodeFor: each) classified: (aSourceClass protocolsFor: each) ]resultClass: aClass  result := aClass newprintOn: aStream  aStream     nextPutAll: self displayClassName;     nextPutAll: ' classComment: ';     print: (self comment copyReplaceAll: '!' with: '!!');     nextPutAll: ' stamp: ';     print: self changeStamp;     nextPutAll: '!'associationAt: aKey ifAbsent: aBlock  | association class |  association := self systemDictionary associationAt: aKey ifAbsent: [ ^aBlock value ].  class := association value isBehavior ifTrue: [ association value ] ifFalse: [ association value class ].  ^((self includesClass: class) or: [ self includesClass: class class ]) ifTrue: [ association ] ifFalse: [ nil ]tearDown  self removeMockClass.  super tearDownaddSearchString: aString  searchStrings ifNil: [ searchStrings := SortedCollection sortBlock: [:a :b |  (a indexOf: $: ifAbsent: [ a size ]) > (b indexOf: $: ifAbsent: [ b size ]) ] ].  (searchStrings includes: aString) ifFalse: [ searchStrings add: aString ]toDoCollect  | array |  array := Array new: 10.  1 to: 10 do: [:i |  array at: i put: i * i ].  ^arrayrefactorings  | class |  class := self classObjectFor: className asSymbol.  ^class instanceVariableNames collect: [:each |  RBCreateAccessorsForVariableRefactoring variable: each class: class classVariable: false ]checkReferencesToSuperSendsToAnyOf: superMessages  [ superMessages isEmpty ] whileFalse: [ self refactoringWarning: ('Although <1s> is equivalent to a superclass method,<n>it contains a super send so it might modify behavior.' expandMacrosWith: superMessages first).        superMessages remove: superMessages first ]initialize  super initialize.  matcher := RBParseTreeSearcher newtestPullUpWithMethodThatCannotBePushedDown  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model classNamed: #SomeClass) compile: 'yourself ^54' classified: #(#accessing).  self shouldFail: (RBPullUpMethodRefactoring model: model pullUp: #(#yourself) from: (model classNamed: #SomeClass))yourselfNotUsed  self     printString;     printString;     yourselfnewUnclassifiedMethod  setUp  super setUp.  model := RBClassModelFactory rbNamespace newrename: this two: argumentMethod  ^self printString , this , argumentMethodfail  ^self assert: falsebuildMethodSearch  self createMethodSearchWith: '`@methodName: `@args ^`@object `@methodName: `@args' selectors: #(#problemCount #isEmpty) inClass: RBTransformationRuleTestDatainitialize  super initialize.  classSelectors := IdentityDictionary new.  metaClassSelectors := IdentityDictionary newtestRefactoring  | refactoring |  refactoring := (RBPullUpVariableTransformation instanceVariable: 'result' class: #RBDummyLintRuleTest) asRefactoring.  [ refactoring transform ] on: RBRefactoringError do: [:e |  e resume ].  self assert: ((refactoring model classNamed: #RBDummyLintRuleTest) directlyDefinesInstanceVariable: 'result').  self deny: ((refactoring model classNamed: #RBBasicDummyLintRuleTest) directlyDefinesInstanceVariable: 'result').  self deny: ((refactoring model classNamed: #RBFooDummyLintRuleTest) directlyDefinesInstanceVariable: 'result')testBadName  self shouldFail: (RBChildrenToSiblingsRefactoring name: #'Obje ct' class: RBLintRuleTestData subclasses: (Array with: RBBasicLintRuleTestData with: RBCompositeLintRuleTestData))forClass: aClass selectors: selectorCollection  ^(RBSelectorEnvironment onMethods: selectorCollection forClass: aClass in: self)     label: aClass name , '>>' , (selectorCollection detect: [:each |  true ] ifNone: [ '' ]);     yourselffullBlocks  ^[ thisContext ]class: aClassName  className := aClassName= anObject  ^self == anObject or: [ self species == anObject species ]resetResult  classNames  | names |  names := IdentitySet new: 4096.  self classesDo: [:each |  names add: each instanceSide name ].  ^namesrewriteRule10: anObject  rewriteRule10 := anObjectpoolDictionaryNames: aCollectionOfStrings  poolDictionaryNames := (aCollectionOfStrings collect: [:each |  each asSymbol ]) asOrderedCollectiontestProtectInstanceVariable  | refactoring class |  refactoring := RBProtectInstanceVariableRefactoring variable: 'rewrite' , 'Rule1' class: RBSubclassOfClassToRename.  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBSubclassOfClassToRename.  self assert: (class parseTreeFor: #calls1) equals: (self parseMethod: 'calls1								^rewriteRule1 := (rewriteRule1 := self calls)').  self assert: (class parseTreeFor: #calls) equals: (self parseMethod: 'calls								^rewriteRule1 := rewriteRule1 , rewriteRule1').  self deny: (class directlyDefinesMethod: ('rewrite' , 'Rule1') asSymbol).  self deny: (class directlyDefinesMethod: ('rewrite' , 'Rule1:') asSymbol)testMetaclassFailure  self shouldFail: (RBProtectVariableTransformation classVariable: #RecursiveSelfRule class: RBTransformationRuleTestData class) asRefactoringclass: aClass protocols: aCollection  class := aClass.  protocols := aCollectionpreconditionEmptyOrHasNoSubclasses: aClass  ^(RBCondition hasSubclasses: aClass excluding: classNames) not | ((RBCondition isEmptyClass: aClass) & ((RBCondition withBlock: [ aClass superclass notNil ])                 errorMacro: 'Cannot remove top level class<n>when it has subclasses';                 yourself))testAllSearches  classSearches keysAndValuesDo: [:class :searches |  class selectors do: [:sel |  currentSelector := sel.              searches do: [:each |  each executeTree: (class parseTreeFor: sel) initialAnswer: each answer ] ] ].  classSearches do: [:searches |  searches do: [:each |  self assertEmpty: each answer ] ]findSelectedMessage  sourceParseTree := class parseTreeFor: sourceSelector.  sourceParseTree ifNil: [ self refactoringFailure: 'Could not parse sources' ].  sourceMessage := sourceParseTree whichNodeIsContainedBy: sourceInterval.  sourceMessage ifNil: [ self refactoringFailure: 'The selection doesn''t appear to be a message send' ].  sourceMessage isCascade ifTrue: [ sourceMessage := sourceMessage messages last ].  sourceMessage isMessage ifFalse: [ self refactoringFailure: 'The selection doesn''t appear to be a message send' ]setUp  super setUp.  classSearches := Dictionary new.  self     buildMethodSearch;     buildSimpleVariableSearch;     buildSimpleLiteralSearch;     buildMessageSearch;     buildStatementSearch;     buildArgumentSearch;     buildMethodTitleSearch;     buildMethodArgumentSearchincludesClass: aClass  ^(super includesClass: aClass) and: [ environmentDictionaries anySatisfy: [:env |  env includesClass: aClass ] ]hasSelfReferences  | searcher |  searcher := self parseTreeSearcher.  searcher matches: 'self' do: [:aNode :answer |  true ].  self hasOnlySelfReturns ifTrue: [ searcher matches: '^self' do: [:aNode :answer |  answer ] ].  ^searcher executeTree: parseTree initialAnswer: falsereplaceArgumentsByPattern: sourceCode  | newSource |  newSource := sourceCode copyWithRegex: 'tempMatch*' matchesReplacedWith: '`@tempMatch'.  newSource := newSource copyWithRegex: 'argMatch*' matchesReplacedWith: '`@argMatch'.  ^newSourceinstanceVariableSelectorsFor: aClass  | selectors |  selectors := Set new.  #(#instanceVariables #instanceVariableReaders #instanceVariableWriters) with: #(#whichSelectorsAccess: #whichSelectorsRead: #whichSelectorsStoreInto:) do: [:var :sel |  | instVars |        instVars := Set new.        (self perform: var) keysDo: [:each |  | cls |              cls := self classForName: each.              (cls notNil and: [ aClass includesBehavior: cls ]) ifTrue: [ instVars addAll: ((self perform: var) at: each) ] ].        instVars do: [:each |  selectors addAll: (aClass perform: sel with: each) ] ].  ^selectorsdirectlyDefinesPoolDictionary: aString  self subclassResponsibilityprintType: aClass for: aString on: aStream  | name colTypes |  colTypes := #().  name := self collectionNameFor: aString.  (aClass includesClass: (model classFor: Collection)) ifTrue: [ colTypes := self guessTypesFor: name ].  colTypes ifNotEmpty: [ aStream nextPut: $( ].  aClass printOn: aStream.  colTypes ifNotEmpty: [ aStream nextPutAll: ' of: '.        colTypes size > 1 ifTrue: [ aStream nextPut: $( ].        self printTypeFor: name on: aStream.        colTypes size > 1 ifTrue: [ aStream nextPut: $) ] ].  colTypes ifNotEmpty: [ aStream nextPut: $) ]testCheckValidMethodName  self assert: (RBCondition checkMethodName: 'foo').  self assert: (RBCondition checkMethodName: #foo).  self assert: (RBCondition checkMethodName: #+)refactoringFailure: aString with: aBlock  ^RBRefactoringFailure signal: aString with: aBlockinlineFoo: aBlock  | bar baz asdf |  bar := aBlock value: self.  baz := bar + bar.  asdf := baz + bar.  ^asdfperform: aChange do: aBlock  | undo |  ^SystemAnnouncer uniqueInstance suspendAllWhile: [ undo := aChange execute.        aBlock ensure: [ undo execute ] ]packageAt: aName ifAbsent: absentBlock  | package |  package := self packageOrganizer packageNamed: aName ifAbsent: absentBlock.  ^(self includesCategory: aName) ifTrue: [ package ] ifFalse: absentBlocksendsDifferentSuper  super printStringtransform  self     extractMethod;     moveMethod;     inlineForwarderasUndoOperation  | classChanges |  classChanges := changeFactory compositeRefactoryChange.  self changeClass withAllSubclasses do: [:each |  classChanges defineClass: each oldDefinition.        each class instVarNames do: [:varName |  classChanges addInstanceVariable: varName to: each class ].        each selectors do: [:selector |  classChanges compile: (each sourceCodeAt: selector) in: each ].        each class selectors do: [:selector |  classChanges compile: (each class sourceCodeAt: selector) in: each class ] ].  ^classChangescopyOldValuesToNewVariable  | newIndex oldIndex |  oldIndex := self changeClass allInstVarNames indexOf: oldName asString.  newIndex := self changeClass allInstVarNames indexOf: newName asString.  self changeClass withAllSubclasses do: [:class |  class allInstances do: [:each |  each instVarAt: newIndex put: (each instVarAt: oldIndex) ] ]selectionIntervalFor: aString  | interval |  interval := super selectionIntervalFor: aString.  ^interval ifNotNil: [ interval ] ifNil: [ environment selectionIntervalFor: aString ]directlyDefinesClassVariable: aString  ^self classVariableNames includes: aString asSymbolprimitiveExecute  definedClass := self definitionClass compiler     source: self definition;     requestor: self controller;     logged: true;     evaluateremoveClass: aClass  aClass isMeta ifTrue: [ metaClassSelectors removeKey: aClass soleInstance name ifAbsent: [  ] ] ifFalse: [ classSelectors removeKey: aClass name ifAbsent: [  ] ]testRefactoring  | refactoring class |  refactoring := (RBAddVariableAccessorTransformation instanceVariable: 'foo1' class: #RBDummyLintRuleTest) asRefactoring transform.  class := refactoring model classNamed: #RBDummyLintRuleTest.  self denyEmpty: refactoring changes changes.  self assert: (class parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 ^foo1').  self assert: (class parseTreeFor: #foo1:) equals: (self parseMethod: 'foo1: anObject foo1 := anObject')testRefactoring  | refactoring |  model := RBNamespace2 new.  model name: 'Add instance variable'.  model defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''fdsa'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.  refactoring := (RBAddVariableTransformation model: model instanceVariable: 'asdf' class: (model classNamed: #FOOBAR)) asRefactoring transform.  self assert: ((refactoring model classNamed: #FOOBAR) directlyDefinesInstanceVariable: 'asdf')directlyDefinesClassVariable: aString  self subclassResponsibilitydefinesClass: aClass  ^(super definesClass: aClass) and: [ self packages anySatisfy: [:package |  package includesClass: aClass ] ]accessorForVariable: aString  | refactoring |  refactoring := RBCreateAccessorsForVariableRefactoring model: self model variable: aString class: self theClass classVariable: false.  refactoring createGetterAccessor.  ^refactoring getterMethodsafeVariableNameFor: aClass temporaries: allTempVars basedOn: aString  | baseString i newString |  newString := baseString := aString.  i := 0.  [ (allTempVars includes: newString) or: [ aClass definesInstanceVariable: newString ] ] whileTrue: [ i := i + 1.        newString := baseString , i printString ].  ^newStringliterals  literalSemaphore ifNil: [ literals ifNil: [ self computeLiterals.              literalSemaphore wait ] ] ifNotNil: [ literalSemaphore wait ].  ^literalsrun  environment classesAndTraits do: [:class |  self checkClass: class.        self checkMethodsForClass: class.        self checkClass: class classSide.        self checkMethodsForClass: class classSide ] displayingProgress: [:class |  'Running critics on: ' , class name ].  environment packages do: [:package |  self checkPackage: package ] displayingProgress: [:package |  'Running critics on: ' , package name ]hash  ^self parseTree hashtestInstanceVariable  | class |  (RBRemoveDirectAccessToVariableTransformation model: model instanceVariable: 'instVarName2' class: #Foo) asRefactoring transform.  class := model classNamed: #Foo.  self assert: (class parseTreeFor: #foo) equals: (self parseMethod: 'foo ^ self instVarName2: 3')storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' rename: '.  deprecatedClass storeOn: aStream.  aStream     nextPutAll: ' to: #';     nextPutAll: newName;     nextPut: $)theClass  ^(self classObjectFor: className) instanceSideparseTreeSearcher  ^self parseTreeSearcherClass newtestReplaceMethod  | refactoring count |  count := (model allReferencesTo: #newResultClass:) size.  model allReferencesTo: #anInstVar: do: [:method |  count := count + 1 ].  refactoring := RBReplaceMethodRefactoring model: model replaceMethod: #anInstVar: in: RBBasicLintRuleTestData to: #newResultClass: permutation: (1 to: 1).  self proceedThroughWarning: [ refactoring primitiveExecute ].  model allReferencesTo: #newResultClass: do: [:method |  count := count - 1 ].  self assert: count equals: (model allReferencesTo: #anInstVar:) sizetestModelExistingSelector  | refactoring |  refactoring := RBAddMethodRefactoring model: model addMethod: 'classVarName1 ^super printString' toClass: (model classNamed: #Bar) inProtocols: #(#accessing).  self shouldFail: refactoringprintOn: aStream  aStream     print: left;     nextPutAll: ' & ';     print: rightinlineMethodTestData  ^'| m |(m := RBNamespace 			onEnvironment: ((RBClassEnvironment onEnvironment: RBBrowserEnvironment new) 					classes: (#(#RBRenameClassVariableChange #RBVariableCompositeRefactoryChange #RBRenameInstanceVariableChange #RBCompositeRefactoryChange #RBRenameVariableChange #RBRefactoryChange) 							inject: OrderedCollection new							into: 								[:sum :each | 								| class |								class := Smalltalk at: each ifAbsent: [nil].								class notNil ifTrue: [sum add: class].								sum]) 								, (#() inject: OrderedCollection new										into: 											[:sum :each | 											| class |											class := Smalltalk at: each ifAbsent: [nil].											class notNil ifTrue: [sum add: class class].											sum])) 						not) 		name: ''Test''.#(''Object subclass: #RBRefactoryChange	instanceVariableNames: ''''name ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RBRefactoryChange subclass: #RBCompositeRefactoryChange	instanceVariableNames: ''''changes ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RBCompositeRefactoryChange subclass: #RBVariableCompositeRefactoryChange	instanceVariableNames: ''''className isMeta ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RBVariableCompositeRefactoryChange subclass: #RBRenameVariableChange	instanceVariableNames: ''''oldName newName ''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RBRenameVariableChange subclass: #RBRenameClassVariableChange	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''' ''RBRenameVariableChange subclass: #RBRenameInstanceVariableChange	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Refactory-Support'''''') 	do: [:each | m defineClass: each].#(#(#RBRenameClassVariableChange #(#(''removeOldVariable	(RBRemoveClassVariableChange remove: oldName from: self changeClass) execute'' #private) #(''addNewVariable	(RBAddClassVariableChange add: newName to: self changeClass) execute'' #private) #(''executeNotifying: aBlock 	| undo |	self addNewVariable.	self copyOldValuesToNewVariable.	undo := super executeNotifying: aBlock.	self removeOldVariable.	^undo'' #private) #(''copyOldValuesToNewVariable	| oldValue |	oldValue := self changeClass classPool at: oldName ifAbsent: [].	self changeClass at: newName asSymbol put: oldValue'' #private))) #(#RBVariableCompositeRefactoryChange #(#(''displayClassName	^isMeta 		ifTrue: [self changeClassName , '''' class'''']		ifFalse: [self changeClassName asString]'' #printing) #(''isMeta	^isMeta'' #private) #(''changeClass: aBehavior 	isMeta := aBehavior isMeta.	className := isMeta 				ifTrue: [aBehavior soleInstance name]				ifFalse: [aBehavior name]'' #accessing) #(''hash	^self changeClassName hash'' #comparing) #(''changeClassName: aSymbol 	className := aSymbol.	isMeta isNil ifTrue: [isMeta := false]'' #accessing) #(''changeClass	| class |	class := Smalltalk at: self changeClassName ifAbsent: [^nil].	^isMeta ifTrue: [class class] ifFalse: [class]'' #accessing) #(''printOn: aStream	aStream nextPutAll: self displayString'' #printing) #(''changeClassName	^className'' #accessing) #(''= aRefactoryClassChange 	self class = aRefactoryClassChange class ifFalse: [^false].	^className = aRefactoryClassChange changeClassName 		and: [isMeta = aRefactoryClassChange isMeta]'' #comparing))) #(#RBRenameInstanceVariableChange #(#(''removeOldVariable	(RBRemoveInstanceVariableChange remove: oldName from: self changeClass) 		execute'' #private) #(''addNewVariable	(RBAddInstanceVariableChange add: newName to: self changeClass) execute'' #private) #(''executeNotifying: aBlock 	| undo |	self addNewVariable.	self copyOldValuesToNewVariable.	undo := super executeNotifying: aBlock.	self removeOldVariable.	^undo'' #private) #(''copyOldValuesToNewVariable	| newIndex oldIndex |	oldIndex := self changeClass allInstVarNames indexOf: oldName asString.	newIndex := self changeClass allInstVarNames indexOf: newName asString.	self changeClass withAllSubclasses do: 			[:each | 			each allInstances 				do: [:inst | each instVarAt: newIndex put: (each instVarAt: oldIndex)]]'' #private))) #(#RBCompositeRefactoryChange #(#(''compile: source in: class 	^self addChange: (RBAddMethodChange compile: source in: class)'' #''refactory-changes'') #(''addClassVariable: variableName to: aClass 	^self addChange: (RBAddClassVariableChange add: variableName to: aClass)'' #''refactory-changes'') #(''addChangeFirst: aRefactoryChange 	changes addFirst: aRefactoryChange.	^aRefactoryChange'' #accessing) #(''removeChange: aChange 	changes remove: aChange ifAbsent: []'' #''private-inspector accessing'') #(''addPool: aPoolVariable to: aClass 	^self addChange: (RBAddPoolVariableChange add: aPoolVariable to: aClass)'' #''refactory-changes'') #(''initialize	super initialize.	changes := OrderedCollection new'' #''initialize-release'') #(''defineClass: aString 	^self addChange: (RBAddClassChange definition: aString)'' #''refactory-changes'') #(''changeForClass: aRBClass selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForClass: aRBClass selector: aSelector.			change notNil ifTrue: [^change]].	^nil'' #accessing) #(''removeInstanceVariable: variableName from: aClass 	^self 		addChange: (RBRemoveInstanceVariableChange remove: variableName from: aClass)'' #''refactory-changes'') #(''printOn: aStream 	aStream nextPutAll: name'' #printing) #(''inspect	RefactoryBuilderInspector openOn: self'' #''user interface'') #(''flattenOnto: aCollection 	changes do: [:each | each flattenOnto: aCollection]'' #private) #(''hash	^changes size'' #comparing) #(''= aRefactoryBuilder 	self class = aRefactoryBuilder class ifFalse: [^false].	changes size = aRefactoryBuilder changes size ifFalse: [^false].	changes with: aRefactoryBuilder changes		do: [:each :change | each = change ifFalse: [^false]].	^true'' #comparing) #(''renameClass: class to: newName 	^self addChange: (RenameClassChange rename: class name to: newName)'' #''refactory-changes'') #(''renameChangesForClass: aClassName to: newClassName 	^(self copy)		changes: (self changes 					collect: [:each | each renameChangesForClass: aClassName to: newClassName]);		yourself'' #accessing) #(''postCopy	super postCopy.	changes := changes collect: [:each | each copy]'' #copying) #(''changes: aCollection 	changes := aCollection'' #''private-inspector accessing'') #(''addInstanceVariable: variableName to: aClass 	^self addChange: (RBAddInstanceVariableChange add: variableName to: aClass)'' #''refactory-changes'') #(''compile: source in: class classified: aProtocol 	^self addChange: (RBAddMethodChange 				compile: source				in: class				classified: aProtocol)'' #''refactory-changes'') #(''changeForMetaclass: aSymbol selector: aSelector 	changes reverseDo: 			[:each | 			| change |			change := each changeForMetaclass: aSymbol selector: aSelector.			change notNil ifTrue: [^change]].	^nil'' #accessing) #(''removeClassVariable: variableName from: aClass 	^self 		addChange: (RBRemoveClassVariableChange remove: variableName from: aClass)'' #''refactory-changes'') #(''executeNotifying: aBlock 	| undos undo |	undos := changes collect: [:each | each executeNotifying: aBlock].	undo := self copy.	undo changes: undos reverse.	^undo'' #private) #(''changes	^changes'' #''private-inspector accessing'') #(''removeMethod: aSelector from: aClass 	^self addChange: (RBRemoveMethodChange remove: aSelector from: aClass)'' #''refactory-changes'') #(''removeClass: aClass 	^self addChange: (RBRemoveClassChange removeClassName: aClass)'' #''refactory-changes'') #(''addChange: aRefactoryChange 	changes add: aRefactoryChange.	^aRefactoryChange'' #accessing) #(''changesSize	^changes inject: 0 into: [:sum :each | sum + each changesSize]'' #accessing) #(''displayString	^super displayString asText allBold'' #printing) #(''problemCount	^self changesSize'' #accessing))) #(#RBRenameVariableChange #(#(''oldName: aString	oldName := aString'' #private) #(''executeNotifying: aBlock 	| undo |	undo := super executeNotifying: aBlock.	undo		oldName: newName;		newName: oldName.	^undo'' #private) #(''newName: aString 	newName := aString'' #private) #(''changeString	^''''Rename '''' , oldName , '''' to '''' , newName'' #printing))) #(#RBRefactoryChange #(#(''flattenedChanges	| changes |	changes := OrderedCollection new.	self flattenOnto: changes.	^changes'' #private) #(''name: aString	name := aString'' #''initialize-release'') #(''initialize'' #''initialize-release'') #(''changeForMetaclass: aSymbol selector: aSelector 	^nil'' #accessing) #(''changeString	^self class name'' #printing) #(''changeForClass: aRBClass selector: aSelector 	^nil'' #accessing) #(''executeWithMessage: aString 	| tally controller m done |	m := 0 asValue.	done := 0.	tally := self changesSize.	controller := aString isNil 				ifTrue: [nil]				ifFalse: [ProgressWidgetView progressOpenOn: m label: aString].	m value: 0.	^	[self executeNotifying: 			[done := done + 1.			m value: done asFloat / tally]] 			ensure: [controller notNil ifTrue: [controller closeAndUnschedule]]'' #''performing-changes'') #(''executeNotifying: aBlock 	self subclassResponsibility'' #private) #(''changes	^Array with: self'' #accessing) #(''execute	^self executeNotifying: []'' #''performing-changes'') #(''inspect	^((RBCompositeRefactoryChange new)		changes: (Array with: self);		yourself) inspect'' #''user interface'') #(''flattenOnto: aCollection 	aCollection add: self'' #private) #(''name	^name isNil ifTrue: [self changeString] ifFalse: [name]'' #accessing) #(''changesSize	^1'' #accessing) #(''displayString	^name isNil ifTrue: [self changeString] ifFalse: [name]'' #printing) #(''renameChangesForClass: aClassName to: newClassName 	"We are in the middle of performing a rename operation. If we stored 	the class name, we need to change the class name to the new 	name to perform the compiles."	self subclassResponsibility'' #accessing)))) 	do: 		[:each | 		| class |		class := m classNamed: each first.		each last do: [:meth | class compile: meth first classified: meth last]].m'privateTransform  | parseTree definingNode variableNode |  parseTree := self definingMethod.  variableNode := parseTree variableWith: variableName.  self checkExistingVariable: variableNode.  definingNode := variableNode whoDefines: variableName.  self checkNewVariable: definingNode.  (self parseTreeRewriterClass rename: variableName to: newVariableName) executeTree: definingNode.  class compileTree: parseTreeallNonMetaClasses  | allNonMetaClasses |  allNonMetaClasses := OrderedCollection new: 4096.  self classesDo: [:each |  each isMeta ifFalse: [ allNonMetaClasses add: each ] ].  ^allNonMetaClasses asArrayremoveEmptyIfTrues  | rewriter |  rewriter := RBParseTreeRewriter new.  rewriter     replace: '``@boolean ifTrue: [] ifFalse: [| `@temps | ``@.Stmts]' with: '``@boolean ifFalse: [|`@temps | ``@.Stmts]';     replace: '``@boolean ifFalse: [] ifTrue: [| `@temps | ``@.Stmts]' with: '``@boolean ifTrue: [|`@temps | ``@.Stmts]';     replace: '``@boolean ifTrue: [| `@temps | ``@.Stmts] ifFalse: []' with: '``@boolean ifTrue: [|`@temps | ``@.Stmts]';     replace: '``@boolean ifFalse: [| `@temps | ``@.Stmts] ifTrue: []' with: '``@boolean ifFalse: [|`@temps | ``@.Stmts]'.  (rewriter executeTree: sourceParseTree) ifTrue: [ sourceParseTree := rewriter tree ]modelClass  ^classcheckTemporaryVariableNames  | varNames |  varNames := parseTree allDefinedVariables.  selfVariableName ifNotNil: [ varNames add: selfVariableName ].  varNames do: [:name |  moveToClasses do: [:each |  (self canReferenceVariable: name in: each) ifTrue: [ self refactoringError: ('<1p> already defines a variable called <2s>' expandMacrosWith: each with: name) ] ] ]postCopy  super postCopy.  packages := packages copyincludesCategory: aCategory  ^(self classNamesFor: aCategory) isNotEmptytestRefactoring  | refactoring class |  refactoring := (RBAddPragmaTransformation pragma: '<gtInspectorPresentationOrder: 56>' inMethod: #methodBefore inClass: #RBAddPragmaTransformationTest) asRefactoring transform.  self assert: refactoring model changes changes size equals: 1.  class := refactoring model classNamed: #RBAddPragmaTransformationTest.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) bodychangeString  ^'Remove ' , self displayClassNametestRemoveEmptySuperclass  | refactoring |  refactoring := RBRemoveClassRefactoring classNames: (Array with: ('RBFoo' , 'LintRuleTestData1') asSymbol).  self executeRefactoring: refactoring.  self assert: (refactoring model classNamed: ('RBFoo' , 'LintRuleTestData1') asSymbol) isNil.  self assert: (refactoring model classNamed: #RBTransformationRuleTestData1) superclass equals: (refactoring model classNamed: #RBLintRuleTestData)hasVariablesToAbstract  ^instVarReaders notEmpty or: [ instVarWriters notEmpty or: [ classVarReaders notEmpty or: [ classVarWriters notEmpty ] ] ]storeOn: aStream  aStream     nextPutAll: self class name;     nextPutAll: ' new'testNowhereToMove  | transformation |  transformation := RBMoveTemporaryVariableDefinitionTransformation variable: #temp inMethod: #noMoveDefinition inClass: #RBDummyRefactoryTestDataApp.  self assert: transformation model changes changes size equals: 0.  self shouldFail: (RBMoveTemporaryVariableDefinitionTransformation variable: #temp inMethod: #noMoveDefinition inClass: #RBDummyRefactoryTestDataApp) asRefactoringcomputeSubclassSupersOf: aClass  | selectors |  selectors := Set new.  aClass subclasses do: [:each |  each selectors do: [:sel |  selectors addAll: (each parseTreeFor: sel) superMessages ] ].  ^selectorspreconditionHasNoUsers: aClassOrTrait  ^(RBCondition withBlock: [ aClassOrTrait realClass users isEmpty ])     errorMacro: aClassOrTrait name , ' Trait is used.<n>Browse classes using it?';     errorBlock: [ self openBrowserOn: (self environmentWithUsersOf: aClassOrTrait) ];     yourselftestMethodDoesNotExist  self shouldFail: (RBRemoveTemporaryVariableTransformation variable: 'temp' inMethod: #foofoo inClass: #RBRemoveTemporaryVariableTransformationTest) asRefactoringsmallLintCritics  ^self packagesmsg2  ^Var1addNewVariable  self flag: #todo.  (RBAddInstanceVariableChange add: newName to: self changeClass) executeinlineMessagesInClass: aClass andSelector: aSelector  | messagesToInline previousCountOfMessages |  previousCountOfMessages := 4294967295.  [ messagesToInline := self numberOfSelfSendsIn: (aClass parseTreeFor: aSelector).  messagesToInline > 0 and: [ previousCountOfMessages > messagesToInline ] ] whileTrue: [ | node |        previousCountOfMessages := messagesToInline.        node := self selfSendIn: (aClass parseTreeFor: aSelector).        self onError: [ self performComponentRefactoring: (RBInlineMethodRefactoring model: self model inline: node sourceInterval inMethod: aSelector forClass: aClass).              numberReplaced := numberReplaced + 1 ] do: [  ] ].  numberNotReplaced := numberNotReplaced + messagesToInlinetestNewHierarchyExistingName  | refactoring |  model := RBClassModelFactory rbNamespace new.  model name: 'Add instance variable'.  model defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.  model defineClass: 'FOOBAR subclass: #BARFOO 				instanceVariableNames: '''' 					classVariableNames: ''''				poolDictionaries: ''''				category: ''Refactory-Test data'''.  refactoring := RBAddInstanceVariableRefactoring model: model variable: 'asdf' class: (model classNamed: #BARFOO).  self shouldFail: refactoringcollectionProtocol  | newCollection |  newCollection := OrderedCollection new.  (1 to: 10) asOrderedCollection do: [:each |  | new |        new := each * 2.        newCollection add: new ].  ^newCollectionstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' variable: '.  variableName storeOn: aStream.  aStream nextPutAll: ' class: '.  class storeOn: aStream.  aStream nextPutAll: ' classVariable: '.  isClassVariable storeOn: aStream.  aStream nextPut: $)atIfAbsent  ^Smalltalk at: #MyTest ifAbsent: [ | collection |        collection := #().        Smalltalk at: #MyTest put: collection ]compile: aString in: aRBClass classified: aSymbol  | change |  change := changes compile: aString in: aRBClass classified: aSymbol.  self flushCaches.  ^changepreconditions  class := self model classObjectFor: className.  ^(isClassVariable ifTrue: [ (RBCondition isMetaclass: class) not & (RBCondition directlyDefinesClassVariable: variableName asSymbol in: class) & ((RBCondition withBlock: [ (#(#Object #Behavior #ClassDescription #Class) includes: class name) not ]) errorMacro: 'This refactoring does not work for Object, Behavior, ClassDescription, or Class') ] ifFalse: [ RBCondition directlyDefinesInstanceVariable: variableName in: class ]) & (RBCondition canUnderstand: self getterMethod in: self definingClass) & (RBCondition canUnderstand: self setterMethod in: self definingClass)variable  ^variableprivateTransform  self definingClass comment: commenttestAbstractWithDefaultNamesUsed  | refactoring class |  class := model classNamed: #Foo.  refactoring := RBAbstractInstanceVariableRefactoring model: model variable: 'instVarName1' class: class.  self executeRefactoring: refactoring.  self assert: (class parseTreeFor: #bar) equals: (self parseMethod: 'bar						"Add one to instVarName1"						self instVarName11: self instVarName11 + 1').  self assert: (class parseTreeFor: #instVarName11:) equals: (self parseMethod: 'instVarName11: anObject						instVarName1 := anObject').  self assert: (class parseTreeFor: #instVarName11) equals: (self parseMethod: 'instVarName11						^instVarName1').  self assert: ((model classNamed: #Bar) parseTreeFor: #foo) equals: (self parseMethod: 'foo						self instVarName11: self instVarName11 + instVarName2 + ClassVarName1')convertAllReferencesTo: aSymbol using: searchReplacer  self model allReferencesTo: aSymbol do: [:method |  self convertMethod: method selector for: method modelClass using: searchReplacer ]selector: aSelector in: aClass classified: aProtocol  ^changes selector: aSelector in: aClass classified: aProtocolstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' inlineParameter: ''';     nextPutAll: argument;     nextPutAll: ''' in: '.  class storeOn: aStream.  aStream     nextPutAll: ' selector: #';     nextPutAll: oldSelector;     nextPut: $)changeString  ^'Rename ' , oldName , ' to ' , newNamepackageAt: aName  ^self packageAt: aName ifAbsent: [ NotFound signalFor: aName in: self ]preconditions  ^(RBCondition isMetaclass: class) notchangeForMetaclass: aClassName selector: aSelector  ^nilwhoDefinesInstanceVariable: aString  | sprClass |  (self directlyDefinesInstanceVariable: aString) ifTrue: [ ^self ].  sprClass := self superclass.  ^sprClass ifNil: [ nil ] ifNotNil: [ sprClass whoDefinesInstanceVariable: aString ]storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' protocol ''';     nextPutAll: protocol;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: aStream.  aStream nextPut: $)isResumable  ^truesoleInstance  ^self instanceSidetestTransform  | transformation class |  transformation := (RBAddSubtreeTransformation interval: (0 to: 1) with: 'self printString' from: #one in: self changeMock name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self changeMock name asSymbol.  self assert: (class directlyDefinesMethod: #one).  self assert: (class parseTreeFor: #one) body statements size equals: 2oldVersionTextToDisplay  ^String streamContents: [:s |  self changes do: [:c |  s                 << c oldVersionTextToDisplay;                 cr ] ]changes  ^self model changestestInlineBlockFailure  self shouldFail: (RBInlineParameterRefactoring inlineParameter: 'aBlock' in: RBRefactoryTestDataApp selector: ('inline' , 'Foo:') asSymbol)testIncludesClass  self assert: (modelFactory rbNamespace new includesClassNamed: #Object).  self deny: (modelFactory rbNamespace new includesClassNamed: #Object1).  self deny: ((modelFactory rbNamespace onEnvironment: (RBClassEnvironment onEnvironment: RBBrowserEnvironment new classes: (Array with: Object))) includesClassNamed: #OrderedCollection)initialize  super initialize.  onSystemDictionary := Smalltalk globals.  changeFactory := RBRefactoryChangeManager changeFactorytestModelAlreadyExistingName  | refactoring |  refactoring := RBAddInstanceVariableRefactoring model: model variable: 'instVarName1' class: (model classNamed: #Bar).  self shouldFail: refactoringpreconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition definesSelector: selector in: target) not & (RBCondition withBlock: [ self checkInstVars.              true ])sizeCheck  self isEmpty ifFalse: [ self do: [:each |  self traceCr: each ] ]addProtocolNamed: aString  model addProtocolNamed: aString in: selftestRefactoring  | refactoring class |  refactoring := (RBAddAccessorsForClassTransformation className: #RBVariableTransformation) asRefactoring transform.  self assert: refactoring model changes changes size equals: 4.  class := refactoring model classNamed: #RBVariableTransformation.  self assert: (class parseTreeFor: #variableName) equals: (self parseMethod: 'variableName ^variableName').  self assert: (class parseTreeFor: #variableName:) equals: (self parseMethod: 'variableName: anObject variableName := anObject')getterMethodFor: aVariableName  | matcher candidateGetters |  matcher := self parseTreeSearcherClass getterMethod: aVariableName.  candidateGetters := (self definesInstanceVariable: aVariableName) ifTrue: [ self whichSelectorsReferToInstanceVariable: aVariableName ] ifFalse: [ self whichSelectorsReferToClassVariable: aVariableName ].  candidateGetters := candidateGetters select: [:each |  each numArgs == 0 ].  ^candidateGetters detect: [:each |  (self checkSelector: each using: matcher) notNil and: [ (self subclassRedefines: each) not ] ] ifNone: [ nil ]getNewMethodName  | newSelector parameters alreadyDefined methodName newMethodName |  self removeArgument.  parameters := parseTree argumentNames asOrderedCollection.  self needsToReplaceSelfReferences ifTrue: [ parameters add: selfVariableName ].  methodName := RBMethodName selector: (self uniqueMethodNameFor: parameters size) arguments: parameters.  [ newMethodName := self requestMethodNameFor: methodName.  newMethodName ifNil: [ self refactoringFailure: 'Did not move method' ].  newMethodName isValid ifTrue: [ newSelector := newMethodName selector ] ifFalse: [ self refactoringWarning: 'Invalid method name' ].  parameters := newMethodName arguments.  (self checkMethodName: newSelector in: class) ifFalse: [ self refactoringWarning: newSelector , ' is not a valid selector name.'.        newSelector := nil ].  alreadyDefined := moveToClasses detect: [:each |  each hierarchyDefinesMethod: newSelector ] ifNone: [ nil ].  alreadyDefined ifNotNil: [ self refactoringWarning: ('<1s> is already defined by <2p> or a super/subclass<n>Try another?' expandMacrosWith: newSelector with: alreadyDefined).        newSelector := nil ].  newSelector isNil ] whileTrue: [  ].  parseTree renameSelector: newSelector andArguments: (parameters collect: [:each |  RBVariableNode named: each ]) asArrayanInstVar: anObject  anInstVar := anObjectasOrderedCollectionNotNeeded  self foo addAll: (1 to: 10) asOrderedCollectioncheckPackage: aPackage  rules do: [:each |  each checkPackage: aPackage ]assert: actual equals: expected  ^self assert: actual = expected description: [ self comparingStringBetween: actual and: expected ]testAddTraitPattern  self exampleTraits do: [:trait |  | change |        change := changes defineClass: trait definition.        self assert: (change isKindOf: RBAddTraitChange).        self assert: change changeClassName equals: trait name.        self assert: change category equals: trait category.        self universalTestFor: change ]constructAssignmentFrom: aNode  | valueNode |  valueNode := RBVariableNode named: newVariableName.  ^RBAssignmentNode variable: valueNode value: aNodeparseTreeSearcher  ^self parseTreeSearcherClass newclassesDo: aBlock  | enumerated enumerator |  enumerated := IdentitySet new.  enumerator := [:each |  (enumerated includes: each) ifFalse: [ (environment includesClass: each) ifTrue: [ aBlock value: each ].        (environment includesClass: each classSide) ifTrue: [ aBlock value: each classSide ].        enumerated add: each ] ].  packages do: [:package |  package classes do: enumerator.        package extendedClasses do: enumerator ]check  self subclassResponsibilitywhatToDisplayIn: aBrowser  ^self changes changes flatCollect: [:e |  e whatToDisplayIn: aBrowser ]buildTransformations  transformations := OrderedCollection new.  self     createNewClass;     createReference;     abstractVariableReferences.  ^transformationsprivatePoolDictionaryNames  (self isDefined and: [ poolDictionaryNames isNil ]) ifTrue: [ self poolDictionaryNames: (self realClass sharedPools collect: [:each |  self realClass environment keyAtValue: each ]) ].  ^poolDictionaryNamescheckExistingVariable: variableNode  (variableNode isNil or: [ variableNode isVariable not ]) ifTrue: [ self refactoringError: ('Temporary variable named {1} does not exist.' format: {variableName asString}) ].  variableNode name = variableName ifFalse: [ self refactoringError: 'Selected interval should include variable declaration' ]checkPreconditions  | conditions block |  conditions := self preconditions.  conditions check ifFalse: [ block := conditions errorBlock.        block ifNotNil: [ self refactoringError: conditions errorString with: block ] ifNil: [ self refactoringError: conditions errorString ] ]proceedThroughWarning: aBlock  aBlock on: RBRefactoringError do: [:ex |  ex resume ]privateTransform  self definingClass removeProtocolNamed: protocolcheckSuperSendsFromSiblings  | siblings |  siblings := targetSuperclass subclasses reject: [:each |  each = class ].  siblings do: [:aRBClass |  self checkSiblingSuperSendsFrom: aRBClass ]checkIsAbstractMethod  method isAbstract ifTrue: [ self refactoringError: ('<1p> method is abstract' expandMacrosWith: sourceSelector) ]addTemporary: sourceNode assignedTo: replacementNode  | newName |  newName := self renameConflictingTemporary: sourceNode name.  inlineParseTree body     addTemporaryNamed: newName;     addNodeFirst: (RBAssignmentNode variable: (RBVariableNode named: newName) value: replacementNode)preconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ self definingMethod lastIsReturn not ] errorString: ('Method named <1s> already has a return statement' expandMacrosWith: selector)) & (RBCondition withBlock: [ | returnNode |              returnNode := self parserClass parseExpression: returnValue.              returnNode allVariables allSatisfy: [:e |  (self definingMethod hasArgumentNamed: e name) or: [ self definingMethod hasTemporaryNamed: e name ] ] ] errorString: ('Some variables in this return statement are not defined in method named <1s>.' expandMacrosWith: selector))propagateTransformation  self renameReferenceslongMethods  self printString.  self printString.  self printString.  self printString.  self printString.  self printString.  self printString.  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ].  self isVariable ifTrue: [ self printString ]testRemoveClassWithSubclasses  self shouldFail: (RBRemoveClassTransformation className: #RBFooLintRuleTestData1) asRefactoringfindDestinationClass  | classes |  classes := class withAllSubclasses reject: [:each |  (each whichSelectorsReferToClassVariable: variableName) isEmpty and: [ (each classSide whichSelectorsReferToClassVariable: variableName) isEmpty ] ].  destinationClass := classes ifEmpty: [ nil ] ifNotEmpty: [ classes asOrderedCollection first ].  classes do: [:each |  (destinationClass includesClass: each) ifTrue: [ destinationClass := each ] ifFalse: [ (each includesClass: destinationClass) ifFalse: [ self signalMultipleReferenceError ] ] ].  destinationClass = class ifTrue: [ self signalStillReferencedError ].  ^destinationClasssystemDictionaryClassesDo: aBlock  self systemDictionary allClassesDo: [:class |  aBlock           value: class;           value: class classSide ]transform  | definingNode variableNode |  parseTree := class parseTreeFor: selector.  variableNode := self whichVariableNode: parseTree inInterval: interval name: oldName.  (variableNode isNil or: [ variableNode isVariable not ]) ifTrue: [ self refactoringFailure: oldName asString , ' isn''t a valid variable' ].  variableNode name = oldName ifFalse: [ self refactoringFailure: 'Invalid selection' ].  definingNode := variableNode whoDefines: oldName.  definingNode ifNil: [ self refactoringFailure: oldName asString , ' isn''t defined by the method' ].  self renameNode: definingNode.  class compileTree: parseTreetestExistingInstanceVariableAccessors  | ref |  ref := RBCreateAccessorsForVariableRefactoring variable: 'name' class: RBLintRuleTestData classVariable: false.  self executeRefactoring: ref.  self assertEmpty: ref changes changes.  self assert: ref setterMethod identicalTo: #name:.  self assert: ref getterMethod identicalTo: #namecheckClassVarsFor: aSelector  class instanceSide classVariableNames do: [:each |  ((class whichSelectorsReferToClassVariable: each) includes: aSelector) ifTrue: [ self refactoringError: ('<1p> refers to <2s> which is defined in <3p>' expandMacrosWith: aSelector with: each with: class) ] ]testInlineMethodForSuperSend  | refactoring |  model := Smalltalk compiler evaluate: self inlineMethodTestData.  (model classNamed: #RBRenameVariableChange) removeMethod: #executeNotifying:.  refactoring := RBInlineMethodRefactoring model: model inline: (102 to: 131) inMethod: #executeNotifying: forClass: (model classNamed: #RBRenameInstanceVariableChange).  self executeRefactoring: refactoring.  self assert: ((model classNamed: #RBRenameInstanceVariableChange) parseTreeFor: #executeNotifying:) equals: (self parseMethod: 'executeNotifying: aBlock 									| undo undos undo1 |									self addNewVariable.									self copyOldValuesToNewVariable.									undos := changes collect: [:each | each executeNotifying: aBlock].									undo1 := self copy.									undo1 changes: undos reverse.									undo := undo1.									self removeOldVariable.									^undo')withClassesFixedForNautilus  classes ifEmpty: [ metaClasses do: [:each |  classes add: each ] ]transform  class removeClassVariable: variableNamerewriteInlinedTree  sourceMessage parent isReturn ifTrue: [ (sourceParseTree isLast: sourceMessage parent) ifFalse: [ self addSelfReturn ] ] ifFalse: [ self           writeGuardClauses;           normalizeIfTrues;           normalizeReturns;           addSelfReturn ]removeDuplicatesOf: aSelector  | tree |  tree := targetSuperclass parseTreeFor: aSelector.  targetSuperclass allSubclasses do: [:each |  ((each directlyDefinesMethod: aSelector) and: [ (tree equalTo: (each parseTreeFor: aSelector) exceptForVariables: #()) and: [ (each superclass whoDefinesMethod: aSelector) == targetSuperclass ] ]) ifTrue: [ removeDuplicates ifFalse: [ removeDuplicates := self refactoringConfirmWarning: 'Do you want to remove duplicate subclass methods?' ].              removeDuplicates ifTrue: [ each removeMethod: aSelector ] ] ]superMessages  ^self parseTree superMessagestestRemoveClassVar  | refactoring class |  refactoring := RBRemoveClassVariableRefactoring variable: 'Foo1' class: RBLintRuleTestData.  class := refactoring model classNamed: #RBLintRuleTestData.  self assert: (class definesClassVariable: 'Foo1').  self executeRefactoring: refactoring.  self deny: (class definesClassVariable: 'Foo1')isComposite  ^falsepreconditions  ^subclasses inject: ((RBCondition isMetaclass: parent) errorMacro: 'Superclass must not be a metaclass') not & (RBCondition isValidClassName: className) & (RBCondition isGlobal: className in: self model) not into: [:sub :each |  sub & ((RBCondition isMetaclass: each) errorMacro: 'Subclass must <1?not :>be a metaclass') not & (RBCondition isImmediateSubclass: each of: parent) ]renameClassVariable: oldName to: newName in: aRBClass around: aBlock  self deprecated: 'Use RBClass2 instead'testReferencesPrintOnAfterRemove  | hasFoundObject hasFoundSelf smalltalk |  hasFoundObject := false.  hasFoundSelf := false.  smalltalk := modelFactory rbNamespace new.  (smalltalk classNamed: #Object) removeMethod: #printString.  (smalltalk classNamed: self class name) removeMethod: #testReferencesPrintOnAfterRemove.  smalltalk allReferencesTo: #printOn: do: [:each |  hasFoundObject := hasFoundObject or: [ each selector = #printString and: [ each modelClass = (smalltalk classNamed: #Object) ] ].        hasFoundSelf := hasFoundSelf or: [ each selector = #testReferencesPrintOnAfterRemove and: [ each modelClass = (smalltalk classNamed: self class name) ] ] ].  self deny: hasFoundObject.  self deny: hasFoundSelf| aCondition  ^(self not & aCondition not) notnewOKButton  ^self newOKButtonFor: self getEnabled: #isOkEnableddemoRenameMethod: arg1 PermuteArgs: arg2  self do: arg1.  self do: arg2.  ^arg1 > arg2exampleTraits  < sampleInstance>  ^{TSortable .   TAssertable}result  ^resulttransform  self subclassResponsibilityincludesSelector: aSelector in: aClass  ^(environment includesSelector: aSelector in: aClass) and: [ self privateIncludesSelector: aSelector inClass: aClass ]deprecatedClass: anObject  deprecatedClass := anObjectpreconditionsForInstanceVariable  ^(RBCondition definesInstanceVariable: variableName in: self definingClass) & (RBCondition accessesInstanceVariable: variableName in: self definingClass showIn: self)storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' sendersOf: #';     nextPutAll: selector;     nextPutAll: ' in: '.  class storeOn: aStream.  aStream nextPut: $)buildSelectorString: aSelector  aSelector numArgs = 0 ifTrue: [ ^aSelector ].  ^self buildSelectorString: aSelector withPermuteMap: (1 to: aSelector numArgs)badMessage  self become: String newtestLintRuleTypes  | typer types |  typer := RBRefactoryTyper new.  types := typer guessTypesFor: 'name' in: RBLintRuleTestData.  self assert: types size equals: 1.  self assert: (types includes: (typer model classFor: String))testAddClassInteractively  | change |  change := changeFactory addClassDefinition: 'AbstractEnvironmentTestCase subclass: #' , self class name , '	instanceVariableNames: ''instVar''	classVariableNames: ''ClassVar''	poolDictionaries: ''PoolDict''	package: ''' , self class category , '''' for: self.  self assert: change controller equals: self.  self assert: change superclassName equals: self class superclass name.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self assert: change instanceVariableNames size equals: 1.  self assert: change instanceVariableNames first equals: 'instVar'.  self assert: change classVariableNames size equals: 1.  self assert: change classVariableNames first equals: 'ClassVar'.  self assert: change sharedPoolNames size equals: 1.  self assert: change sharedPoolNames first equals: 'PoolDict'.  self assert: change category equals: self class category.  self universalTestFor: changepreconditions  ^RBCondition canUnderstand: selector in: classpreconditions  | rbMethod |  rbMethod := self parserClass parseMethod: sourceCode onError: [:string :position |  ^RBCondition withBlock: [ self refactoringError: 'The content of this method cannot be parsed.' ] ].  rbMethod selector ifNil: [ self refactoringError: 'The method has no selector.' ].  ^(RBCondition canUnderstand: rbMethod selector in: self definingClass) notrightFailed  ^right errorStringFor: falseprivateTransform  | methodTree parseTree |  methodTree := self definingMethod.  parseTree := methodTree body.  interval ifNotNil: [ | nodeInInterval |        nodeInInterval := methodTree bestNodeFor: interval.        nodeInInterval isSequence ifTrue: [ parseTree := nodeInInterval ] ].  parseTree addTemporaryNamed: variableName.  class compileTree: methodTreeclassModelOf: aClass  | classModel |  classModel := aClass isMeta ifTrue: [ RBClassModelFactory rbMetaclass named: aClass name ] ifFalse: [ RBClassModelFactory rbClass named: aClass name ].  classModel model: self model.  ^classModelremovePulledUpMethods  selectors do: [:each |  class removeMethod: each ]changeForClass: aClassName selector: aSelector  ^(isMeta not and: [ self selector = aSelector and: [ className = aClassName ] ]) ifTrue: [ self ] ifFalse: [ nil ]whatToDisplayIn: aBrowser  ^self changes changes flatCollect: [:e |  e whatToDisplayIn: aBrowser ]extract: aString from: aSelector to: aNewSelector in: aClassName  class := aClassName.  selector := aSelector.  newSelector := aNewSelector.  sourceCode := aStringincludesClass: aClass  ^aClass == class and: [ super includesClass: aClass ]instanceVariableReaders  ^instanceVariableReadersinstanceVariableNames  ^fromClass allInstanceVariableNames asSetandedEnvironment  ^andedEnvironmentreturnInEnsure  [ self error: 'asdf' ] ensure: [ ^4 ]booleanPrecedence  ^(true & 4) = 45refersToClassNamed: aSymbol  | searcher |  searcher := self parserTreeSearcher.  searcher matches: aSymbol asString do: [:node :answer |  true ].  ^(searcher executeTree: self parseTree initialAnswer: false) or: [ self refersToSymbol: aSymbol ]removeSubclass: aRBClass  self subclasses remove: aRBClass ifAbsent: [  ]defaultEnvironment  ^RBBrowserEnvironment newreference  ^RBRemoveClassTesttestRemoveClassChange  | st |  st := modelFactory rbNamespace new.  st removeClassNamed: self class name.  self deny: (st includesClassNamed: self class name).  self assert: (st classNamed: self class name) isNilvisitSequenceNode: aSequenceNode  | isMethod |  isMethod := aSequenceNode parent isMethod.  aSequenceNode temporaries do: [:temp |  isMethod ifTrue: [ difference := difference + (('tempMatch' , temporaries asString) size - temp name asString size + 2) ].        self replace: temp with: 'tempMatch' , temporaries asString.        temporaries := temporaries + 1 ].  super visitSequenceNode: aSequenceNodetestSplitCascadeRefactoring  | refactoring |  refactoring := RBSplitCascadeRefactoring split: (54 to: 55) from: #methodWithCascades in: self class.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBSplitCascadeRefactoringTest) parseTreeFor: #methodWithCascades) equals: (self parseMethod: 'methodWithCascades	| a receiver |	receiver := Object new.	receiver initialize.	a := receiver asString.	^ a')inlineMax  | x y q |  x := 5.  y := 10.  q := x + 1 max: y.  ^qcheckParseTree  | node |  blockNodes := OrderedCollection new.  node := self whichVariableNode: parseTree inInterval: interval name: name.  node ifNil: [ self refactoringFailure: 'Unable to locate node in parse tree' ].  definingNode := node whoDefines: name.  definingNode ifNil: [ self refactoringFailure: 'Cannot locate variable definition' ].  definingNode isSequence ifFalse: [ self refactoringFailure: 'Variable is an argument' ].  (self usesDirectly: definingNode) ifTrue: [ self refactoringFailure: 'Variable already bound tightly as possible' ].  (self checkNodes: (self subblocksIn: definingNode)) ifFalse: [ self refactoringError: 'Variable is possibly read before written' ]setOption: aSymbol toUse: aBlock  | dict |  dict := self options.  dict == self class refactoringOptions ifTrue: [ dict := dict copy ].  dict at: aSymbol put: aBlock.  self options: dictstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' variable: '.  variableName storeOn: aStream.  aStream nextPutAll: ' class: '.  class storeOn: aStream.  aStream nextPutAll: ' classVariable: '.  classVariable storeOn: aStream.  aStream nextPut: $)testDoesNotDefineVariable  self     shouldFail: (RBRemoveDirectAccessToVariableTransformation model: model instanceVariable: 'instVarName1' class: #Bar) asRefactoring;     shouldFail: (RBRemoveDirectAccessToVariableTransformation classVariable: 'Foo1' class: #RBFooLintRuleTestData) asRefactoringyourselfNotUsed  self     printString;     printString;     yourselftransform  self     addSuperclass;     pushUpVariables;     pullUpMethods;     changeIsKindOfReferences;     reparentSubclassespreconditions  ^(RBCondition withBlock: [ | methodSource |        interval first > interval last ifTrue: [ self refactoringFailure: 'You must select a variable name' ].        methodSource := class sourceCodeFor: selector.        methodSource size >= interval last ifFalse: [ self refactoringFailure: 'Invalid range for variable' ].        oldName := methodSource copyFrom: interval first to: interval last.        true ]) & (RBCondition isValidInstanceVariableName: newName for: class) & (RBCondition definesSelector: selector in: class) & (RBCondition definesInstanceVariable: newName in: class) not & (RBCondition definesClassVariable: newName in: class) notaddMethodSource: sourceCode in: aClass  ^RBAddMethodChange compile: sourceCode in: aClasschangeClass: aBehavior  super changeClass: aBehavior.  isMeta := falseinstanceVariablesFor: aClass  | vars name |  vars := Set new.  name := aClass name.  vars     addAll: (instanceVariables at: name ifAbsent: [ #() ]);     addAll: (instanceVariableReaders at: name ifAbsent: [ #() ]);     addAll: (instanceVariableWriters at: name ifAbsent: [ #() ]).  ^varsnameToDisplay  ^self printStringallSuperclasses  | supers sprClass |  supers := OrderedCollection new.  sprClass := self superclass.  [ sprClass notNil ] whileTrue: [ supers add: sprClass.        sprClass := sprClass superclass ].  ^superscanUnderstand: aSelector  ^self definesMethod: aSelectorpackageNames  ^self packages collect: [:each |  each packageName ]testReceiverDoesNotExist  self shouldFail: (RBAddMessageSendTransformation messageSend: 'variable2 byteAt: 1' inMethod: #methodBefore inClass: #RBAddMessageSendTransformationTest) asRefactoringprivateTransform  self definingClass compile: sourceCode classified: (Array with: protocol)guessTypesFor: anInstVarName  ^bestGuesses at: anInstVarName ifAbsent: [ self typesFor: anInstVarName ]includesPackage: packageName  ^truestoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' selector: #';     nextPutAll: selector;     nextPutAll: ' class: '.  class storeOn: aStream.  aStream     nextPutAll: ' variable: ''';     nextPutAll: variable;     nextPutAll: ''')'transform  | original replacement |  self model allClassesDo: [:class |  class selectors do: [:selector |  original := (class realClass whichCategoryIncludesSelector: selector) asString.              original ifNotNil: [ replacement := self execute: original.                    replacement = original ifFalse: [ class compile: (class sourceCodeFor: selector) classified: replacement ] ] ] ]testVariableAlreadyExists  self shouldFail: (RBAddTemporaryVariableTransformation variable: 'variable' inMethod: #methodBefore inClass: #RBAddReturnStatementTransformationTest) asRefactoringtestAlreadyExistingName  self     shouldFail: (RBAddVariableTransformation instanceVariable: 'class' class: #RBTransformationRuleTestData) asRefactoring;     shouldFail: (RBAddVariableTransformation instanceVariable: 'name' class: #RBTransformationRuleTestData) asRefactoring;     shouldFail: (RBAddVariableTransformation classVariable: #RecursiveSelfRule class: #RBTransformationRuleTestData) asRefactoring;     shouldFail: (RBAddVariableTransformation classVariable: self objectClassVariable class: #RBTransformationRuleTestData) asRefactoringaddClassDefinition: definition  ^RBAddClassChange definition: definitiontestRenameClassVarInSharedPool  | refactoring class userClass |  refactoring := RBRenameClassVariableRefactoring rename: #Var1 to: #VarOne in: RBSharedPoolForTestData.  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBSharedPoolForTestData.  userClass := refactoring model classNamed: #RBClassUsingSharedPoolForTestData.  self assert: (class parseTreeFor: #msg1) equals: (self parseMethod: 'msg1 ^ VarOne').  self assert: (class parseTreeFor: #msg2) equals: (self parseMethod: 'msg2 ^ VarOne').  self assert: (userClass parseTreeFor: #msg3) equals: (self parseMethod: 'msg3 ^ VarOne')testExistingName  self shouldFail: (RBAddClassRefactoring addClass: #Object superclass: self class subclasses: #() category: #'Refactory-Testing')rationale  ^self class commentrealClass  ^realClassincludesSelector: aSelector in: aClass  ^(environment includesSelector: aSelector in: aClass) and: [ self packages anySatisfy: [:package |  package includesSelector: aSelector ofClass: aClass ] ]protocols  ^self modelClass protocolsFor: self selectorpreconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition definesSelector: selector in: self definingClass)storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' extract: '.  extractionInterval storeOn: aStream.  aStream     nextPutAll: ' from: #';     nextPutAll: selector;     nextPutAll: ' in: '.  class storeOn: aStream.  aStream nextPut: $)compileMethod  class compileTree: sourceParseTreetestRenameClassVariable  | change |  change := changes renameClassVariable: 'ClassVar1' to: 'ClassVar2' in: self class.  self assert: change changeClassName equals: self class name.  self assert: change oldName equals: 'ClassVar1'.  self assert: change newName equals: 'ClassVar2'.  self universalTestFor: changetestPrimitive  self shouldFail: (RBInlineMethodRefactoring inline: (14 to: 23) inMethod: #testMethod forClass: RBRefactoryTestDataApp)rootClasses  ^model rootClassestestRenameClassVar  | refactoring class |  refactoring := RBRenameClassVariableRefactoring rename: #RecursiveSelfRule to: #RSR in: RBTransformationRuleTestData.  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBTransformationRuleTestData.  self assert: (class directlyDefinesClassVariable: #RSR).  self deny: (class directlyDefinesClassVariable: #RecursiveSelfRule).  self assert: (class classSide parseTreeFor: #initializeAfterLoad1) equals: (self parseMethod: 'initializeAfterLoad1								RSR := RBParseTreeSearcher new.								RSR									addMethodSearches: #(''`@methodName: `@args | `@temps | self `@methodName: `@args'' ''`@methodName: `@args | `@temps | ^self `@methodName: `@args'')											-> [:aNode :answer | true]').  self assert: (class classSide parseTreeFor: #nuke) equals: (self parseMethod: 'nuke								RSR := nil').  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 								class := aSmalllintContext selectedClass.								(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 										[(RSR executeTree: rewriteRule tree initialAnswer: false)											ifFalse: 												[builder compile: rewriteRule tree printString													in: class													classified: aSmalllintContext protocols]]')canReferenceVariable: aString in: aClass  (aClass definesVariable: aString) ifTrue: [ ^true ].  (self model includesGlobal: aString asSymbol) ifTrue: [ ^true ].  ^(self poolVariableNamesFor: aClass) includes: aStringtestRemoveMethod  | change |  change := changes removeMethod: #setUp from: self class.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self assert: change selector equals: #setUp.  self universalTestFor: changegenerateNewMethodWith: aMethodName  | args newMethodNode |  args := aMethodName arguments collect: [:p |  RBVariableNode named: p ].  newMethodNode := RBMethodNode selector: aMethodName selector arguments: args asArray body: (subtree isSequence ifTrue: [ subtree ] ifFalse: [ RBSequenceNode temporaries: #() statements: (OrderedCollection with: subtree) ]).  temporaries do: [:each |  newMethodNode body addTemporaryNamed: each ].  ((parseTree parentOfSubtree: subtree) uses: subtree) ifTrue: [ newMethodNode addReturn ].  assignments size = 1 ifTrue: [ newMethodNode addNode: (RBReturnNode value: (RBVariableNode named: assignments first asString)) ].  ^newMethodNodesetUp  super setUp.  model := self abstractVariableTestDatatestRemoveClassesWithReferencesBetweenThem  | refactoring |  refactoring := RBRemoveClassRefactoring classNames: {#RBRemoveClassTest .         #RBSharedPoolForTestData2}.  self executeRefactoring: refactoring.  self assert: (refactoring model classNamed: #RBRemoveClassTest) isNil.  self assert: (refactoring model classNamed: #RBSharedPoolForTestData2) isNilcreateNewClassFor: aBehavior  | nonMeta meta className |  className := aBehavior instanceSide name.  nonMeta := (modelFactory rbClass existingNamed: className)     model: self;     yourself.  meta := (modelFactory rbMetaclass existingNamed: className)     model: self;     yourself.  ^changedClasses at: className put: (Array with: nonMeta with: meta)storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' rename: '.  class storeOn: aStream.  aStream     nextPutAll: ' to: #';     nextPutAll: newName;     nextPut: $)rewriteRule  ^rewriteRulechangesSize  ^1transform: aCritic  | changeCode |  changeCode := (self changes detect: [:ch |  ch isMeta = aCritic methodClass isMeta & (ch changeClassName = aCritic criticTheNonMetaclassClass name) & (ch selector = aCritic selector) ]) source.  aCritic methodClass compile: changeCodetargetClass  ^classtestMetaClassFailure  self shouldFail: (RBAddClassVariableRefactoring variable: #VariableName class: RBTransformationRuleTestData class)whatToDisplayIn: aChangeBrowser  | result |  result := OrderedCollection with: self.  ^result , (self changes flatCollect: [:e |  e changes ])privateTransform  transformationBlock value: self modelchangeSymbol  ^#removeInstVarNamed:implementorsOf: aSelector  | classes |  classes := OrderedCollection new.  self rootClasses do: [:each |  self implementorsOf: aSelector in: each storeIn: classes ].  ^classesresult  ^self subclassResponsibilityprotocolsFor: aSelector  | change |  change := self isMeta ifTrue: [ model changes changeForMetaclass: name selector: aSelector ] ifFalse: [ model changes changeForClass: name selector: aSelector ].  ^change ifNil: [ self isDefined ifTrue: [ Array with: (RBBrowserEnvironment new whichProtocolIncludes: aSelector in: self realClass) ] ifFalse: [ #(#accessing) ] ] ifNotNil: [ change protocols ]storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' renameMethod: #';     nextPutAll: oldSelector;     nextPutAll: ' in: '.  class storeOn: aStream.  aStream     nextPutAll: ' to: #';     nextPutAll: newSelector;     nextPutAll: ' permutation: '.  permutation storeOn: aStream.  aStream nextPut: $)existingSelector  | existSelector |  existSelector := self requestExistingSelector.  existSelector ifNotNil: [ ^existSelector ] ifNil: [ ^class allSelectors detect: [:each |  self isMethodEquivalentTo: each ] ifNone: [ nil ] ]model: aRBNamespace  model := aRBNamespacesuperSends  | rule |  rule := RBParseTreeRewriter new.  rule addSearch: 'super `@message: ``@args' -> ([:aNode |  (class withAllSubclasses detect: [:each |  each includesSelector: aNode selector ] ifNone: [ nil ]) isNil ] -> 'self `@message: ``@args').  self rewriteUsing: ruleprecedence  ^self isArray ifFalse: [ (self block + 5) * 34 ] ifTrue: [ self printString = 10 ]currentSelector  ^currentSelector| anEnvironment  self isSystem ifTrue: [ ^self ].  anEnvironment isSystem ifTrue: [ ^anEnvironment ].  ^RBOrEnvironment onEnvironment: self or: anEnvironmenttestModelExtractMethodWithTemporaryAssigned  | class refactoring |  model := RBClassModelFactory rbNamespace new.  class := model classNamed: self class name.  class compile: 'foo 				| temp bar | 				bar := 5. 				temp := bar * bar. 				Transcript show: temp printString; cr. 				^temp * temp' classified: #(#accessing).  refactoring := RBExtractMethodRefactoring model: model extract: (26 to: 102) from: #foo in: class.  self setupMethodNameFor: refactoring toReturn: #foobar.  self executeRefactoring: refactoring.  self assert: (class parseTreeFor: #foo) equals: (self parseMethod: 'foo | temp | temp := self foobar. ^temp * temp').  self assert: (class parseTreeFor: #foobar) = (self parseMethod: 'foobar | bar temp | bar := 5. temp := bar * bar. Transcript show: temp printString; cr. ^temp.') | ((class parseTreeFor: #foobar) = (self parseMethod: 'foobar | temp bar | bar := 5. temp := bar * bar. Transcript show: temp printString; cr. ^temp.'))displayProtocolName  ^protocolonlyReadOrWrittenTemporary  | a |  a := 1comment: aComment in: aRBClass  ^RBCommentChange comment: aComment in: aRBClassremovePoolVariable: variableName from: aClass  ^RBRemovePoolVariableChange remove: variableName from: aClasserrorString  ^self errorStringFor: falsepreconditions  ^RBCondition emptytestNotEnvironment  | notPrintStringEnvironment printStringEnvironment kernelEnvironment notKernelEnvironment |  printStringEnvironment := universalEnvironment referencesTo: #printString.  notPrintStringEnvironment := printStringEnvironment not.  kernelEnvironment := RBPackageEnvironment packageName: 'Kernel'.  notKernelEnvironment := kernelEnvironment not.  self universalTestFor: notPrintStringEnvironment.  self assertEmpty: (notPrintStringEnvironment referencesTo: #printString).  self assert: (notPrintStringEnvironment not includesClass: RBBrowserEnvironmentTest).  self assert: (notPrintStringEnvironment not includesSelector: #testNotEnvironment in: RBBrowserEnvironmentTest).  self assert: (notKernelEnvironment includesPackage: 'Kernel' asPackage) not.  self assertEmpty: (notKernelEnvironment & kernelEnvironment) packagescategories: aCollection  categories addAll: aCollectionselectorsForClass: aClass do: aBlock  environment selectorsForClass: aClass do: [:each |  (andedEnvironment includesSelector: each in: aClass) ifTrue: [ aBlock value: each ] ]update: anEvent  isPerformingRefactoring ifFalse: [ self clearUndoRedoList ]testInvalidSubclass  self shouldFail: (RBAddClassTransformation addClass: #Foo superclass: #RBCompositeLintRuleTestData subclasses: (Array with: RBBasicLintRuleTestData) category: #'Refactory-Tesing') asRefactoringwithClassesFixedForNautilus  classSelectors ifEmpty: [ metaClassSelectors keysAndValuesDo: [:class :selectors |  classSelectors at: class ifAbsentPut: [ IdentitySet new ] ] ]definingMethod  ^method ifNil: [ method := (self definingClass methodFor: selector asSymbol) ast ]buildTransformations  ^OrderedCollection new     add: (RBRemoveVariableTransformation model: self model variable: variableName class: className classVariable: isClassVariable);     addAll: (self variableDefinitionsInHierarchy collect: [:each |  RBAddVariableTransformation model: self model variable: variableName class: each classVariable: isClassVariable ]);     yourselfcreateNewClass  self     addClass;     addInstanceVariablespackages  ^self classes collect: #packagecheckBrowseAllOccurences: anCollectionOfOccurrences  | methods callers |  methods := anCollectionOfOccurrences collect: [:c |  c key ] as: Set.  callers := anCollectionOfOccurrences collect: [:v |  v value ].  methods size = 1 ifTrue: [ self refactoringError: ('Possible call to <2s> in <1p> methods.<n>Browse references?' expandMacrosWith: anCollectionOfOccurrences size with: methods anyOne) with: [ self openBrowserOn: (RBBrowserEnvironment new referencesTo: methods anyOne) ] ] ifFalse: [ self refactoringError: ('Possible call to the <2p> selectors in <1p> methods.<n>Browse references?' expandMacrosWith: callers size with: methods size) with: [ | env |              env := RBSelectorEnvironment new.              callers do: [:d |  env addMethod: d method ].              self openBrowserOn: env ] ]renameAccessorsReferences  | methods senders |  methods := (class allSelectors select: [:each |  (class methodFor: each) isNotNil ] thenCollect: [:each |  each ]) asOrderedCollection.  senders := (methods select: [:each |  (class methodFor: each) source includesSubstring: variableName asString ] thenCollect: [:each |  class methodFor: each ]) asOrderedCollection.  senders do: [:each |  each source: (each source copyReplaceAll: variableName asString with: newName asString asTokens: false) ].  senders do: [:each |  (each selector = newName or: [ each selector asString = (newName asString , ':') ]) ifFalse: [ (model classNamed: class name) compile: each source classified: each protocols ] ]asUndoOperation  ^RBRemoveProtocolChange removeProtocolNamed: protocol in: self changeClassprimitiveExecute  definedSelector := self changeClass compile: self source classified: self protocol notifying: self controllerrenameMessageSends  self convertAllReferencesTo: oldSelector using: self parseTreeRewriterimplements: aSelector  ^self selectors includes: aSelectorrenameInstanceVariable: oldName to: newName around: aBlock  self privateInstanceVariableNames at: (self privateInstanceVariableNames indexOf: oldName asString) put: newName asString.  ^self model performChange: (RBRenameInstanceVariableChange rename: oldName to: newName in: self) around: aBlockaddChange: aRefactoryChange  changes add: aRefactoryChange.  ^aRefactoryChangecompileNewMethod  class compileTree: self parseTreeexecuteSearch: searcher  class withAllSubclasses do: [:each |  each selectors do: [:sel |  | parseTree |              methodName := sel.              parseTree := each parseTreeFor: sel.              parseTree notNil ifTrue: [ searcher executeTree: parseTree ] ] ]checkVariableReferencesIn: aParseTree  | searcher |  searcher := self parseTreeSearcher.  searcher matches: '`var' do: [:aNode :answer |  | name |        name := aNode name.        (aNode whoDefines: name) ifNil: [ self checkSendersAccessTo: name ] ].  searcher executeTree: aParseTreeprintOn: aStream  aStream nextPutAll: self labelshouldFixSubclasses  ^shouldFixSubclassescopyOptionsFrom: aDictionary  | dict |  dict := self options.  dict == self class refactoringOptions ifTrue: [ ^self options: aDictionary copy ].  dict keysAndValuesDo: [:key :value |  value == (self class refactoringOptions at: key) ifTrue: [ dict at: key put: (aDictionary at: key) ] ].  self options: dictrefersToClass  ^RBSmalllintTestObjectrenameClasses  mode := #rename:name:renameAllParameters  parameterMap ifNotNil: [ parameterMap keysAndValuesDo: [:key :value |  key ~= value ifTrue: [ self renameParameterWith: key to: value ] ] ]environmentWithUsersOf: aTrait  ^RBClassEnvironment onEnvironment: RBBrowserEnvironment new classes: aTrait realClass usersinstanceVariables: anObject  instanceVariables := anObjectvariable: aVariableName inMethod: aSelector inClass: aClass  class := aClass.  selector := aSelector.  variableName := aVariableNameaddAssociation  [ | argument value |  argument := argumentsList at: self argumentIndex.  value := valuesList at: self valueIndex.  tree := RBParseTreeRewriter replace: value with: argument in: tree.  argsAndValues at: argument put: value.  argumentsList removeAt: self argumentIndex.  valuesList removeAt: self valueIndex.  sourceCodeMorph contents: self sourceCode.  self     changed: #associations;     changed: #arguments;     changed: #values;     changed: #isOkEnabled ] on: Error do: [ self inform: 'Please select one argument and one value.' ]classInstanceVariableNames  ^classInstanceVariableNamestestRefactoring  | transformation class |  transformation := (RBRemoveSubtreeTransformation code: 'selector := aSelector' from: #selector:from: in: #RBRemoveMethodTransformation) asRefactoring transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: #RBRemoveMethodTransformation.  self assert: (class directlyDefinesMethod: #selector:from:).  self assert: (class parseTreeFor: #selector:from:) body statements size equals: 1testMethodDoesNotExist  self shouldFail: (RBRemoveReturnStatementTransformation return: '^ variable' inMethod: #method inClass: #RBRemoveReturnStatementTransformationTest) asRefactoringshouldnt: aBlock raise: anExceptionalEvent whoseDescriptionDoesNotInclude: substring description: aString  ^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionNotContaining: substring) not description: aStringrun  ^RBSmalllintChecker runRule: selfshould: aBlock notTakeMoreThanMilliseconds: anInteger  self should: aBlock notTakeMoreThan: (Duration milliSeconds: anInteger)instanceVariableNames  ^self privateInstanceVariableNames copytestPerformRenameClassInstanceVariable  | change |  change := changes renameInstanceVariable: 'classInstVar' to: 'classInstVarPlus' in: self changeMock class.  self perform: change do: [ self deny: (change changeClass instVarNames includes: change oldName).        self assert: (change changeClass instVarNames includes: change newName) ].  self assert: (change changeClass instVarNames includes: change oldName).  self deny: (change changeClass instVarNames includes: change newName)includesCategory: aCategory  ^(environment includesCategory: aCategory) or: [ orEnvironment includesCategory: aCategory ]junk  ^RBRefactoryTestDataApp printString copyFrom: 1 to: CRobjectClassVariable  ^Object classPool keys detect: [:each |  true ]initialize  super initialize.  instanceVariables := Dictionary new.  classVariables := Dictionary new.  instanceVariableReaders := Dictionary new.  instanceVariableWriters := Dictionary newviewResults  self subclassResponsibilitybuildSelectorString: aSelector withPermuteMap: anIntegerCollection  | stream keywords |  aSelector numArgs == 0 ifTrue: [ ^aSelector asString ].  stream := WriteStream on: String new.  keywords := aSelector keywords.  keywords with: anIntegerCollection do: [:each :i |  stream           nextPutAll: each;           nextPutAll: ' ``@arg';           nextPutAll: i printString;           nextPut: $  ].  ^stream contentswithAllSuperclasses  ^self allSuperclasses     add: self;     yourselfbuildTransformations  | class |  class := self model classObjectFor: className.  ^class instanceVariableNames collect: [:variable |  RBAddVariableAccessorTransformation model: self model instanceVariable: variable class: class ]testExistingName  self shouldFail: (RBAddClassTransformation addClass: #Object superclass: self class name subclasses: #() category: #'Refactory-Testing') asRefactoringcombineMessages  | expression |  transformedNode := RBCascadeNode messages: (statementNodes collect: [:each |  each copy ]).  expression := statementNodes last parent.  [ expression isAssignment ] whileTrue: [ transformedNode := RBAssignmentNode variable: expression variable value: transformedNode.        expression := expression parent ]preconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition withBlock: [ self verifySelectedInterval.              true ])poolDictionaryNames: aCollectionOfStrings  poolDictionaryNames := (aCollectionOfStrings collect: [:each |  each asSymbol ]) asOrderedCollectionnoMoveDefinition  | temp |  ^(self collect: [:each |  temp := each printString.        temp , temp ]) select: [:each |  temp := each size + temp ]testSelectorsNotHaveSameNumberOfArgs  self shouldFail: (RBReplaceMethodRefactoring replaceCallMethod: #checkClass: in: RBBasicLintRuleTestData to: #checkMethod23 permutation: (1 to: 1))testAddParameterThatReferencesGlobalAndLiteral  | refactoring class |  refactoring := RBAddParameterRefactoring addParameterToMethod: ('test' , 'Foo:') asSymbol in: RBRefactoryTestDataApp newSelector: #testFoo:bar: initializer: 'OrderedCollection new: 5'.  self proceedThroughWarning: [ self executeRefactoring: refactoring ].  class := refactoring model classNamed: #RBRefactoryTestDataApp.  self assert: (class parseTreeFor: #testFoo:bar:) equals: (self parseMethod: 'testFoo: anObject bar: anObject1								^self class + anObject').  self assert: (class parseTreeFor: #callFoo) equals: (self parseMethod: 'callFoo ^self testFoo: 5 bar: (OrderedCollection new: 5)').  self deny: (class directlyDefinesMethod: ('test' , 'Foo:') asSymbol)setUp  super setUp.  model := self abstractVariableTestDatatestBadInterval  self shouldFail: (RBExtractMethodTransformation extract: 'whatever' from: #testMethod to: #bla in: #RBRefactoryTestDataApp) asRefactoring.  self shouldFail: (RBExtractMethodTransformation extract: (self sourceCodeAt: (80 to: 147) forMethod: #subclassOf:overrides: in: RBBasicLintRuleTestData class) from: #subclassOf:overrides: to: #bla in: #'RBBasicLintRuleTestData class') asRefactoringtestParseFailure  | transformation |  transformation := (RBAddSubtreeTransformation interval: (0 to: 1) with: ':= 123' from: #one in: self changeMock name) transform.  self assertEmpty: transformation model changes changesincludesCategory: aCategory  ^(self classNamesFor: aCategory) isNotEmptytestComposite  changes     compile: 'method ^ 1' in: self class classified: #utilities;     compile: 'method ^ 2' in: self class class classified: #utilities.  self assert: changes changesSize equals: 2.  self assert: changes problemCount equals: 2.  self assert: (changes changeForClass: self class name selector: #method) notNil.  self assert: (changes changeForMetaclass: self class name selector: #method) notNil.  self universalTestFor: changesclassNames  ^IdentitySet new     addAll: classes;     addAll: metaClasses;     yourselfisArchitecturalRule  ^truerenameChangesForClass: oldClassName to: newClassName  self subclassResponsibilityrootClass: aClass  rootClass := aClass instanceSidechangeClass: aBehavior  super changeClass: aBehavior.  isMeta := falserenameThisMethod: anArg  ^selfcalculateTemporaries  ^temporaries ifNil: [ | allVariables accesses |        allVariables := parseTree allDefinedVariables difference: subtree allDefinedVariables.        accesses := allVariables select: [:each |  subtree references: each ].        temporaries := accesses select: [:each |  subtree assigns: each ] ]compileTree: aRBMethodNode  ^(self methodFor: aRBMethodNode selector) compileTree: aRBMethodNodetestClassDoesNotExist  self shouldFail: (RBAddPragmaTransformation pragma: '<gtInspectorPresentationOrder: 56>' inMethod: #methodBefore inClass: #RBPragmaTransformationTest) asRefactoring= anObject  ^self == anObject or: [ self species == anObject species ]compile: source in: class  ^self addChange: (changeFactory addMethodSource: source in: class)replaceAssignment  assignmentNode parent isSequence ifTrue: [ assignmentNode parent removeNode: assignmentNode ] ifFalse: [ assignmentNode replaceWith: assignmentNode value ]testExistingName  self shouldFail: (RBRenameClassRefactoring rename: self class to: #Object)packages  ^environment packages | orEnvironment packagesstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' addClass: #';     nextPutAll: className;     nextPutAll: ' superclass: '.  superclass storeOn: aStream.  aStream nextPutAll: ' subclasses: '.  subclasses asArray storeOn: aStream.  aStream nextPutAll: ' category: '.  category storeOn: aStream.  aStream nextPut: $)isVariableEnvironment  ^falsetestWithAssignment  | refactoring class |  refactoring := (RBProtectVariableTransformation model: model instanceVariable: 'instVarName2' class: #Foo) asRefactoring transform.  class := model classNamed: #Foo.  self assert: (class parseTreeFor: #instVarName2:) equals: (self parseMethod: 'instVarName2: anObject instVarName2 := anObject').  self assert: (class parseTreeFor: #instVarName2) equals: (self parseMethod: 'instVarName2 ^instVarName2').  self assert: (class parseTreeFor: #foo) equals: (self parseMethod: 'foo ^self instVarName2: 3').  self assert: ((model classNamed: #Bar) parseTreeFor: #foo) equals: (self parseMethod: 'foo			instVarName1 := instVarName1 + self instVarName2 + ClassVarName1')displayName  | nameStream |  nameStream := WriteStream on: (String new: 64).  nameStream     nextPutAll: self name;     nextPutAll: ' ('.  self problemCount printOn: nameStream.  nameStream nextPut: $).  ^nameStream contentsdefiningClass  ^self model classObjectFor: classtestModelRemoveUnusedVariable  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: ''foo'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  self executeRefactoring: (RBPushDownInstanceVariableRefactoring model: model variable: 'foo' class: (model classNamed: #SomeClass)).  self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: 'foo').  self assert: ((model classNamed: #Subclass) directlyDefinesVariable: 'foo')check: anEntity  ^self check: anEntity ifNoCritiques: [  ]visitMethodNode: aMethodNode  aMethodNode arguments do: [:arg |  difference := difference + (('argMatch' , arguments asString) size - arg name asString size + 2).        self replace: arg with: 'argMatch' , arguments asString.        arguments := arguments + 1 ].  super visitMethodNode: aMethodNodecategory  ^category ifNil: [ self isDefined ifTrue: [ category := self realClass category ] ifFalse: [ model environment whichCategoryIncludes: self name ] ] ifNotNil: [ category ]fillOutDefinition: aDictionary  superclassName := (aDictionary at: '`@superclass') ifNotNil: [:value |  value asSymbol ].  className := (aDictionary at: '`#className') asSymbol.  instanceVariableNames := self namesIn: (aDictionary at: '`#instanceVariableNames' ifAbsent: [ String new ]).  classVariableNames := self namesIn: (aDictionary at: '`#classVariableNames' ifAbsent: [ String new ]).  poolDictionaryNames := self namesIn: (aDictionary at: '`#poolDictionaries' ifAbsent: [ String new ]).  category := (aDictionary at: '`#category' ifAbsent: [ #Unclassified ]) asSymboltestOrEnvironment  | env1 env2 orEnvironment |  env2 := #printOn:.  env2 := universalEnvironment forClass: Object selectors: #(#fullPrintString).  env1 := universalEnvironment forClass: Object selectors: #(#printOn:).  self assert: (env1 | env2) numberSelectors equals: 2.  self assert: (env2 | env1) numberSelectors equals: 2.  self universalTestFor: env1 | env2.  self assert: (env1 | env1) numberSelectors equals: 1.  orEnvironment := env1 | env1 not.  self assert: (env2 | env1) packages size equals: 1.  self universalTestFor: orEnvironment.  self assert: orEnvironment numberSelectors equals: universalEnvironment numberSelectors.  self assert: orEnvironment classNames asSortedCollection equals: universalEnvironment classNames asSortedCollection.  self assert: (orEnvironment protocolsFor: Object) equals: ((universalEnvironment protocolsFor: Object) reject: [:each |  (Object allSelectorsInProtocol: each) isEmpty ])defineClass: aString  | change newClass newClassName |  change := changes defineClass: aString.  newClassName := change changeClassName.  newClass := self classNamed: newClassName.  newClass ifNil: [ | newMetaclass |        self unmarkAsRemoved: newClassName.        newClass := modelFactory rbClass named: newClassName.        newMetaclass := modelFactory rbMetaclass named: newClassName.        newClass model: self.        newMetaclass model: self.        newClasses at: newClassName put: (Array with: newClass with: newMetaclass) ].  newClass superclass: (self classNamed: change superclassName).  newClass superclass ifNil: [ self rootClasses add: newClass.        newClass classSide superclass: (self classFor: Object class superclass) ] ifNotNil: [ newClass classSide superclass: newClass superclass classSide ].  newClass instanceVariableNames: change instanceVariableNames.  newClass classVariableNames: change classVariableNames.  newClass poolDictionaryNames: change sharedPoolNames.  newClass category: change category.  ^changeincludesPragma: aPragma  ^(keywords includes: aPragma selector) and: [ condition value: aPragma ]source  ^source ifNil: [ source := (class realClass sourceCodeAt: selector) asString ]addKeyword: aSymbol  keywords add: aSymbolasUndoOperation  ^changeFactory addMethodSource: (self methodSourceFor: selector) in: self changeClasstestRaisesRBRefactoringErrorWhenRemovingNonEmptySuperclass  self shouldFail: (RBRemoveClassRefactoring classNames: (Array with: ('RBFoo' , 'LintRuleTest') asSymbol))associations  ^argsAndValues associations collect: #asStringtextToDisplay  ^self namerealName: aSymbol  self realClass: (Smalltalk globals at: aSymbol) classSiderewriteRule1: anObject  ^rewriteRule1 := anObjecterrorBlockFor: aBoolean  ^errorBlockchangeClass  ^(onSystemDictionary classNamed: oldName) ifNil: [ onSystemDictionary classNamed: newName ]rationale  ^renrakuRule rationalemyConditions  ^RBCondition withBlock: [ oldSelector numArgs = newSelector numArgs ] errorString: newSelector printString , ' doesn''t have the correct number of arguments.'problemCount  ^self changesSizeaddDependentSends  self     addDependent: #one;     addDependent: #twoprivateTransform  | methodTree nodesToRemove |  methodTree := self definingMethod.  nodesToRemove := (methodTree allChildren removeDuplicates select: #isReturn) select: [:node |  node sourceCode = returnValue ].  nodesToRemove ifEmpty: [ methodTree removeLast ] ifNotEmpty: [ nodesToRemove do: [:node |  node parent removeNode: node ] ].  self definingClass compileTree: methodTreegtInspectorTreeIn: composite  < gtInspectorPresentationOrder: 0>  composite tree     title: 'Tree';     display: [ {self} ];     children: [:each |  each gtInspectorChildren ];     when: [ self gtInspectorChildren notEmpty ]includesClass: aClass  ^(super includesClass: aClass) and: [ categories includes: aClass instanceSide category ]privateTransform  | methodTree messageNode assignments variables previousNode |  methodTree := self definingMethod.  messageNode := self parserClass parseExpression: message.  variables := messageNode allVariables.  assignments := (methodTree allChildren select: #isAssignment) select: [:each |  variables includes: each variable ].  previousNode := assignments detectMax: #stop.  previousNode ifNil: [ methodTree body addNodeFirst: messageNode ] ifNotNil: [ previousNode parent addNode: messageNode after: previousNode ].  class compileTree: methodTreesplitCascade  ancestorNode parent addNode: (beforeNodes size > 1 ifTrue: [ RBCascadeNode messages: beforeNodes ] ifFalse: [ beforeNodes first ]) before: ancestorNode.  afterNodes size > 1 ifTrue: [ cascadeNode messages: afterNodes ] ifFalse: [ cascadeNode replaceWith: afterNodes first ].  class compileTree: ancestorNode methodNodechangeObject  ^self variabletestAddClassVariable  | refactoring |  refactoring := RBAddClassVariableRefactoring variable: 'Asdf' class: RBTransformationRuleTestData.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBTransformationRuleTestData) directlyDefinesClassVariable: #Asdf)selectors  ^selectorspreconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition withBlock: [ self extractMethod.              self checkSpecialExtractions.              self checkReturn.              needsReturn ifTrue: [ extractedParseTree addReturn ].              self checkTemporaries.              true ])floatEqualityComparison  ^1.0 = 1displayClassName  ^isMeta ifTrue: [ self changeClassName , ' class' ] ifFalse: [ self changeClassName asString ]selectorsForClass: aClass do: aBlock  ^(self privateSelectorsForClass: aClass) do: [:each |  (aClass includesSelector: each) ifTrue: [ aBlock value: each ] ]checkLiteral: aLiteral  (aLiteral isSymbol or: [ aLiteral isVariableBinding ]) ifTrue: [ literals add: aLiteral ] ifFalse: [ aLiteral class == Array ifTrue: [ aLiteral do: [:each |  self checkLiteral: each ] ] ]checkSuperclass  | overrideSelectors |  overrideSelectors := selectors select: [:each |  targetSuperclass directlyDefinesMethod: each ].  overrideSelectors := overrideSelectors reject: [:each |  | myTree superTree |        myTree := class parseTreeFor: each.        superTree := targetSuperclass parseTreeFor: each.        superTree equalTo: myTree exceptForVariables: #() ].  overrideSelectors ifEmpty: [ ^self ].  targetSuperclass isAbstract ifFalse: [ self refactoringError: ('Non-abstract class <2p> already defines <1p>' expandMacrosWith: overrideSelectors asArray first with: targetSuperclass) ].  overrideSelectors do: [:each |  self checkBackReferencesTo: each ]preconditions  ^RBCondition emptyremoveImmediateBlocks  | rewriter |  rewriter := RBParseTreeRewriter new.  rewriter replace: '[``.object] value' with: '``.object' when: [:aNode |  aNode parent isCascade not ].  rewriter replace: '| `@temps | ``@.Stmts1. [| `@bTemps | ``@.bStmts] value. ``@.Stmts2' with: '| `@temps `@bTemps | ``@.Stmts1. ``@.bStmts. ``@.Stmts2'.  (rewriter executeTree: sourceParseTree) ifTrue: [ sourceParseTree := rewriter tree ]testMoveDefinitionIntoBlockThatIsAReceiverOfACascadedMessage  | refactoring |  refactoring := RBMoveVariableDefinitionRefactoring bindTight: (48 to: 58) in: RBRefactoryTestDataApp selector: #referencesConditionFor:.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #referencesConditionFor:) equals: (self parseMethod: 'referencesConditionFor: aClass 								| environment  |								^(RBCondition withBlock: 										[| association |association := Smalltalk globals associationAt: aClass name													ifAbsent: [self refactoringError: ''Could not find class''].										environment := (self environment referencesTo: association) 													| (self environment referencesTo: aClass name).										environment isEmpty])									errorMacro: aClass , '' is referenced.<n>Browse references?'';									errorBlock: [environment openEditor];									yourself')asEpiceaEvent  ^(EpGenericRefactoring canAccept: self) ifTrue: [ EpGenericRefactoring for: self ] ifFalse: [ EpUnknownRefactoring for: self ]testModelInvalidSubclass  | refactoring |  refactoring := RBAddClassRefactoring model: model addClass: #Foo2 superclass: Object subclasses: (Array with: (model classNamed: #Bar)) category: #'Refactory-Tesing'.  self shouldFail: refactoringassignmentInIfTrue  | variable |  self isVariable ifTrue: [ variable := self ] ifFalse: [ variable := self printString ].  ^variableerrorBlock: anObject  errorBlock := anObjectparseMethod: aString  ^self parserClass parseMethod: aStringshould: aBlock description: aString  self assert: aBlock value description: aStringfoo  ^6deny: actual identicalTo: expected  ^self deny: expected == actual description: [ self unexpectedIdentityEqualityStringBetween: actual and: expected ]guardingClause  self isSymbol ifFalse: [ self printString.        self isSymbol printString ]findStatementNodes  statementNodes := OrderedCollection new.  sequenceNode statements do: [:each |  (sequenceNode isLast: each) ifFalse: [ self addStatementNode: each ] ifTrue: [ | current |              current := each.              [ current isReturn or: [ current isAssignment ] ] whileTrue: [ current := current value ].              self addStatementNode: current ] ]preconditions  ^(RBCondition isMetaclass: class) not & (RBCondition definesClassVariable: variableName in: class) & (RBCondition withBlock: [ | block |              block := [:each |  (each whichSelectorsReferToClassVariable: variableName) isEmpty ifFalse: [ class realClass ifNil: [ self refactoringError: ('<1s> is referenced.' expandMacrosWith: variableName) ] ifNotNil: [ self refactoringError: ('<1s> is referenced.<n>Browse references?' expandMacrosWith: variableName) with: [ self openBrowserOn: (RBVariableEnvironment referencesToClassVariable: variableName in: class realClass) ] ] ] ].              class withAllSubclasses do: block.              class classSide withAllSubclasses do: block.              true ])initialize  super initialize.  self matcher matchesAnyMethodOf: #('`@MethodName: `@args 				| `@temps | 				`@.Statements. 				`@condition ifTrue: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]' '`@MethodName: `@args 				| `@temps | 				`@.Statements. 				`@condition ifFalse: [| `@BlockTemps | `.Statement1. `.Statement2. `@.BStatements]') do: [:node :answer |  answer ifNil: [ node body statements last ] ifNotNil: [ answer ] ]asEpiceaEvent  ^EpRenameInstanceVariableRefactoring rename: variableName to: newName in: class namefillOutDefinition: aDictionary  self subclassResponsibilityselectionIntervalFor: aString  | interval |  self searchStrings ifEmpty: [ ^nil ].  interval := self selectionParseTreeIntervalFor: aString.  interval ifNotNil: [ ^interval ].  self searchStrings do: [:each |  | search index |        search := each isSymbol ifTrue: [ each keywords first ] ifFalse: [ each ].        index := aString indexOfSubCollection: search startingAt: 1.        index > 0 ifTrue: [ ^index to: index + search size - 1 ] ].  ^niltestPushDownMethodThatReferencesPoolDictionary  | refactoring class parseTree |  parseTree := RBLintRuleTestData parseTreeFor: #junk.  self proceedThroughWarning: [ refactoring := RBPushDownMethodRefactoring pushDown: #(#junk) from: RBLintRuleTestData.        self executeRefactoring: refactoring ].  class := refactoring model classNamed: #RBLintRuleTestData.  self deny: (class directlyDefinesMethod: #junk).  class subclasses do: [:each |  self assert: (each parseTreeFor: #junk) equals: parseTree.        self assert: (each directlyDefinesPoolDictionary: 'TextConstants' asSymbol) ]rules  ^rulestestClassDoesNotExist  self shouldFail: (RBRemovePragmaTransformation pragma: '<gtInspectorPresentationOrder: 34>' inMethod: #methodBefore inClass: #RBPragmaTransformationTest) asRefactoringisEmpty  ^self result isEmptyprivateTransform  self model renameClass: self definingClass to: newClassName around: [ self renameReferences ]testModelAbstractClassVariableOverridenMethodsInSubclass  | refactoring meta class |  class := model classNamed: #Foo.  meta := class classSide.  refactoring := RBAbstractClassVariableRefactoring model: model variable: 'ClassVarName2' class: class.  self executeRefactoring: refactoring.  self assert: (meta parseTreeFor: #classVarName21) equals: (self parseMethod: 'classVarName21 ^ClassVarName2').  self assert: (meta parseTreeFor: #classVarName21:) equals: (self parseMethod: 'classVarName21: anObject ClassVarName2 := anObject')andedEnvironment: aBrowserEnvironment  andedEnvironment := aBrowserEnvironmentgtInspectorChildren  ^#()extract: anInterval from: aSelector in: aClass  class := self classObjectFor: aClass.  selector := aSelector.  extractionInterval := anIntervalthreeElementPoint  ^(5 @ 5 + 6) @ 6testInlineTemporaryMutlipleAssignment  self shouldFail: (RBInlineTemporaryRefactoring inline: (60 to: 83) from: #moveDefinition in: RBRefactoryTestDataApp)testPerformAddRemoveClassVariable  | change |  change := changes addClassVariable: 'Foo' to: self changeMock.  self perform: change do: [ self assert: (change changeClass classVarNames includes: 'Foo') ].  self deny: (change changeClass classVarNames includes: 'Foo')parseInlineMethod  self inlineClass ifNil: [ self refactoringFailure: ('<1p> or its superclasses don''t contain method <2s>' expandMacrosWith: class with: self inlineSelector) ].  inlineParseTree := self inlineClass parseTreeFor: self inlineSelector.  inlineParseTree ifNil: [ self refactoringFailure: 'Could not parse sources' ].  inlineParseTree lastIsReturn ifFalse: [ inlineParseTree addSelfReturn ]renameInstanceVariable: oldName to: newName in: aClass  ^RBRenameInstanceVariableChange rename: oldName to: newName in: aClassrewriteRule: aRule  rewriteRule := aRuleisEmpty  ^rules allSatisfy: [:each |  each isEmpty ]initialize  name := ''copyFor: aBrowserEnvironment  | newEnvironment |  newEnvironment := aBrowserEnvironment copy.  self assert: newEnvironment numberSelectors equals: aBrowserEnvironment numberSelectors.  self assert: (newEnvironment not & aBrowserEnvironment) numberSelectors equals: 0testVariableDoesNotExistInOldClass  self shouldFail: (RBMoveInstanceVariableToClassTransformation model: model variable: 'abc' fromClass: #RBFooLintRuleTestData toClass: #RBBasicLintRuleTestData) asRefactoringtestTransform  | transformation class |  transformation := (RBAddTemporaryVariableTransformation variable: 'variable' inMethod: #one inClass: self changeMock name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self changeMock name asSymbol.  self assert: (class directlyDefinesMethod: #one).  self assert: (class parseTreeFor: #one) temporaries size equals: 1privateClassVariableNames  (self isDefined and: [ classVariableNames isNil ]) ifTrue: [ self classVariableNames: self realClass classVarNames ].  ^classVariableNamesarguments  ^argumentsList ifNil: [ argumentsList := arguments asOrderedCollection ]methodWithCascades  | a |  a := Object new     initialize;     asString.  ^atestPerformChangeMetaclass  | change |  change := changes defineClass: self changeMock name , ' class 	instanceVariableNames: '''''.  self perform: change do: [ self assertEmpty: change changeClass class instVarNames ].  self denyEmpty: change changeClass class instVarNames.  self assert: change definedClass equals: self changeMock classtestClassVariableToMultipleSubclasses  | class |  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''''			classVariableNames: ''Foo''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  class := model classNamed: #Subclass.  class compile: 'foo ^Foo' classified: #(#accessing).  model defineClass: 'Subclass subclass: #AnotherSubclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model metaclassNamed: #AnotherSubclass) compile: 'bar ^Foo' classified: #(#accessing).  (RBPushDownVariableTransformation model: model classVariable: #Foo class: #SomeClass) asRefactoring transform.  self deny: (class superclass directlyDefinesClassVariable: #Foo).  self assert: (class directlyDefinesClassVariable: #Foo)storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' comment: ''';     nextPutAll: comment;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: aStream.  aStream nextPut: $)guessTypeFromAssignment: aNode  | type set newType |  type := nil.  aNode value isAssignment ifTrue: [ ^self guessTypeFromAssignment: (RBAssignmentNode variable: aNode variable value: aNode value value) ].  aNode value isBlock ifTrue: [ type := model classFor: [  ] class ].  aNode value isLiteralNode ifTrue: [ aNode value value ifNil: [ ^self ].        type := model classFor: (self typeFor: aNode value value) ].  aNode value isMessage ifTrue: [ aNode value receiver isVariable ifTrue: [ type := model classNamed: aNode value receiver name asSymbol ].        aNode value selector = #asValue ifTrue: [ type := model classNamed: #ValueHolder ].        (#(#and: #or: #= #== #~= #~~ #<= #< #~~ #> #>=) includes: aNode value selector) ifTrue: [ type := model classFor: Boolean ] ].  type ifNil: [ ^self ].  set := variableTypes at: aNode variable name.  newType := set detect: [:each |  type includesClass: each ] ifNone: [ nil ].  newType ifNil: [ ^self ].  ((self rootClasses includes: newType) or: [ newType = (model classFor: Object) ]) ifTrue: [ newType := type ].  (bestGuesses at: aNode variable name ifAbsentPut: [ Set new ]) add: newTypeaddClassDefinition: definition for: aController  ^RBAddClassChange definition: definition for: aControllerprivateTransform  self     reparentSubclasses;     removeClassfoobar  ^#(true false)comment  ^comment = LookupComment ifTrue: [ comment := self isDefined ifTrue: [ self realClass comment ] ifFalse: [ nil ] ] ifFalse: [ comment ]defaultLabel  | stream |  stream := String new writeStream.  classes do: [:each |  stream           nextPutAll: each;           nextPut: $  ].  ^stream contentsclassVariableWriter  ClassVariable := nilnoMoveDefinition  | temp |  ^(self collect: [:each |  temp := each printString.        temp , temp ]) select: [:each |  temp := each size + temp ]definesClass: aClass  ^(environment definesClass: aClass) notreferencesTo: aLiteral in: aClass  | classes |  classes := aClass withAllSuperclasses asSet.  classes     addAll: aClass allSubclasses;     addAll: aClass class withAllSuperclasses;     addAll: aClass class allSubclasses.  ^(self forClasses: classes) referencesTo: aLiteralsubclasses  ^subclasses ifNil: [ subclasses := self isDefined ifTrue: [ ((self realClass subclasses collect: [:each |  model classFor: each ]) reject: [:each |  each isNil ]) asOrderedCollection ] ifFalse: [ OrderedCollection new ] ] ifNotNil: [ subclasses ]postCopy  super postCopy.  classes := classes copy.  metaClasses := metaClasses copyprotocols  ^protocolsincludesPackage: aRPackage  ^(environment includesPackage: aRPackage) notrenameParameterWith: oldName to: newName  self renameNode: extractedParseTree withOldName: oldName toWithName: newNameaddClass: aClass  aClass isMeta ifTrue: [ metaClasses add: aClass soleInstance name ] ifFalse: [ classes add: aClass name ]comment: aString  comment := aStringpreconditions  self requestSuperClass.  ^(selectors inject: (RBCondition hasSuperclass: class) into: [:cond :each |  cond & (RBCondition definesSelector: each in: class) ]) & (RBCondition withBlock: [ self checkInstVars.              self checkClassVars.              self checkSuperclass.              self checkSuperMessages.              true ])addInstanceVariable: aString  self privateInstanceVariableNames add: aString.  model addInstanceVariable: aString to: selfsymbolReference  ^#RBClassToRenamecheckSuperSendsFromPushedUpMethods  selectors do: [:each |  | parseTree |        parseTree := class parseTreeFor: each.        parseTree superMessages detect: [:sup |  targetSuperclass directlyDefinesMethod: sup ] ifFound: [ self refactoringError: ('Cannot pull up <1s> since it sends a super message that is defined in the superclass.' expandMacrosWith: each) ] ]remove  | newArguments |  newArguments := self argumentList.  newArguments removeAt: self argumentIndex.  self methodName arguments: newArguments.  self updateprivateTransform  | methodTree nodesToModify |  methodTree := self definingMethod.  nodesToModify := (methodTree allChildren removeDuplicates select: #isMessage) select: [:node |  node selector = message asSymbol ].  nodesToModify ifNotEmpty: [ nodesToModify do: #removeFromTree.        self definingClass compileTree: methodTree ]someDemoMethod  ^self junkshouldFixSubclasses: anObject  shouldFixSubclasses := anObjecttestRemoveClassWithBadName  self shouldFail: (RBRemoveClassTransformation className: #RecursiveSelfRule) asRefactoringstoreOn: aStream  environment storeOn: aStream.  aStream nextPutAll: ' not'preconditionHasNoSubclasses: aClass  ^(RBCondition withBlock: [ aClass subclasses isEmpty ])     errorMacro: self class cannotRemoveTopLevelClassErrorMesssage;     yourselfgroup  ^'Unclassified rules'isValid  ^selector isString and: [ (RBScanner isSelector: selector) and: [ selector numArgs = arguments size ] ]changeClass: aBehavior  isMeta := aBehavior isMeta.  className := aBehavior instanceSide namecreateSubclassResponsibilityFor: aSelector in: aClass  | source |  (aClass superclass definesMethod: aSelector) ifTrue: [ ^self ].  source := self subclassResponsibilityFor: aSelector in: aClass.  source ifNil: [ ^self ].  aClass superclass compile: source classified: (aClass protocolsFor: aSelector)packages  ^self packageOrganizer packages select: [:package |  self includesCategory: package name ]assignmentInBlock  [ ^self printString ] ensure: [ self close ]isMeta  ^isMetarenameInstanceVariable: oldName to: newName in: aRBClass around: aBlock  self deprecated: 'Use RBAbstractClass2 instead'displayString  ^name ifNil: [ self changeString ] ifNotNil: [ name ]errorBlock  ^self errorBlockFor: falsecombine: anInterval from: aSelector in: aClass  class := self classObjectFor: aClass.  selector := aSelector.  selectedInterval := anIntervalrunOnEnvironment: anEnvironment  ^Object printOn: self onEnvironment: anEnvironmentcomment  ^comment = LookupComment ifTrue: [ comment := self isDefined ifTrue: [ self realClass comment ] ifFalse: [ nil ] ] ifFalse: [ comment ]pullUpClassVariables  | newSuperclass |  newSuperclass := self abstractSuperclass.  parent classVariableNames do: [:each |  self performComponentRefactoring: (RBPullUpClassVariableRefactoring model: self model variable: each class: newSuperclass) ]childrenToSiblingTestData  ^'| m |(m:= RBNamespace 			onEnvironment: ((RBClassEnvironment onEnvironment: RBBrowserEnvironment new) 					classes: (#(#ConcreteSubclass #ConcreteSuperclass #NoMoveSubclass) 							inject: OrderedCollection new							into: 								[:sum :each | 								| class |								class := Smalltalk at: each ifAbsent: [nil].								class notNil ifTrue: [sum add: class].								sum]) 								, (#(#ConcreteSubclass #ConcreteSuperclass #NoMoveSubclass) 										inject: OrderedCollection new										into: 											[:sum :each | 											| class |											class := Smalltalk at: each ifAbsent: [nil].											class notNil ifTrue: [sum add: class class].											sum])) 						not) 		name: ''Test''.#(''ConcreteSuperclass subclass: #NoMoveSubclass	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Testing'''''' ''Object subclass: #ConcreteSuperclass	instanceVariableNames: ''''instVarName1 instVarName2 ''''	classVariableNames: ''''ClassVarName1 ClassVarName2 ''''	poolDictionaries: ''''''''	category: ''''Testing'''''' ''ConcreteSuperclass subclass: #ConcreteSubclass	instanceVariableNames: ''''''''	classVariableNames: ''''''''	poolDictionaries: ''''''''	category: ''''Testing'''''') 	do: [:each | m defineClass: each].(m metaclassNamed: #ConcreteSuperclass) 	addInstanceVariable: ''classInstVarName1''.#(#(#ConcreteSubclass #(#(''initialize	super initialize.	instVarName1 := nil'' #everyone) #(''different	^0'' #everyone))) #(#ConcreteSuperclass #(#(''same	^self initialize isKindOf: ConcreteSuperclass'' #''one def'') #(''different	^instVarName1 + instVarName2'' #everyone) #(''initialize	instVarName1 := instVarName2 := ClassVarName1 := ClassVarName2 := 0'' #everyone))) #(#NoMoveSubclass #(#(''same	^123'' #''one def''))) #(''ConcreteSubclass class'' #(#(''bar	^self storeString'' #testing))) #(''ConcreteSuperclass class'' #(#(''foo	^classInstVarName1 + ClassVarName1 + ClassVarName2'' #testing) #(''new	^super new initialize'' #testing) #(''bar	^self printString'' #testing))) #(''NoMoveSubclass class'' #())) 	do: 		[:each | 		| class |		class := m classNamed: each first.		each last do: [:meth | class compile: meth first classified: meth last]].m'resetResult  builder := RBRefactoryChangeManager changeFactory compositeRefactoryChangeNamed: self namebuildMethodArgumentSearch  self createMethodSearchWith: '`arg1: `arg1 `arg2: `arg2 | `@temps | `@.Stmts' selectors: #(#subclassOf:overrides: #createMatcherFor:method: #createParseTreeRule:name:) inClass: RBBasicLintRuleTestData classselectors  ^selectorsproceedThroughWarning: aBlock  aBlock on: RBRefactoringWarning do: [:ex |  ex resume ]renameReferences  | replacer |  replacer := (RBParseTreeRewriter replaceLiteral: className with: newClassName)     replace: className with: newClassName;     yourself.  self model allReferencesToClass: self definingClass do: [:method |  (method modelClass hierarchyDefinesVariable: newClassName) ifFalse: [ self convertMethod: method selector for: method modelClass using: replacer ] ]parseSelector: aSelector  ^[ self parserClass parseMethodPattern: aSelector ] on: Error do: [ nil ]returnInEnsure  [ self error: 'asdf' ] ensure: [ ^4 ]namesIn: aString  | names scanner token |  names := OrderedCollection new.  scanner := RBScanner on: (ReadStream on: aString) errorBlock: [:msg :pos |  ^names ].  [ scanner atEnd ] whileFalse: [ token := scanner next.        token isIdentifier ifTrue: [ names add: token value ] ].  ^names asArrayforPackages: aCollection  ^RBPackageEnvironment onEnvironment: self packages: aCollectionreplaceCallMethod: aSelector in: aClass to: newSel permutation: aMap  oldSelector := aSelector asSymbol.  newSelector := newSel asSymbol.  class := self classObjectFor: aClass.  permutation := aMaptestMethodDoesNotExist  self shouldFail: (RBMoveTemporaryVariableDefinitionTransformation variable: #temp inMethod: #name1 inClass: #RBDummyLintRuleTest)testUnusedInstanceVariable  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''foo''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass 			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  (RBPushDownVariableTransformation model: model instanceVariable: 'foo' class: (model classNamed: #SomeClass)) asRefactoring transform.  self deny: ((model classNamed: #SomeClass) directlyDefinesVariable: 'foo').  self assert: ((model classNamed: #Subclass) directlyDefinesVariable: 'foo')protocols  ^Array with: self protocoltestTransform  | transformation class |  transformation := (RBAddMessageSendTransformation new messageSend: 'variable byteAt: 1' inMethod: #methodBefore inClass: self class name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self class name.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) bodyprimitiveExecute  self changeClass removeFromSystemtestModelNonExistantName  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  self shouldFail: (RBPushDownClassVariableRefactoring model: model variable: #Foo class: (model classNamed: #SomeClass))createSetterAccessor  setterMethod := self findSetterMethod.  setterMethod ifNil: [ setterMethod := self defineSetterMethod ]testInlineTemporaryReadBeforeWritten  self shouldFail: (RBInlineTemporaryRefactoring inline: (48 to: 56) from: #inlineTemporary in: RBRefactoryTestDataApp)testVariableAlreadyExists  self     shouldFail: (RBRenameVariableTransformation rename: 'classBlock' to: 'name' in: #RBBasicLintRuleTestData classVariable: false) asRefactoring;     shouldFail: (RBRenameVariableTransformation rename: #RecursiveSelfRule to: self objectClassVariable in: #RBTransformationRuleTestData classVariable: true) asRefactoringaddClassVariable: aString  self privateClassVariableNames add: aString asSymbol.  model addClassVariable: aString to: selfmsg1  ^Var1suggestedCode: aCritic  ^(self changes detect: [:ch |  ch isMeta = aCritic methodClass isMeta & (ch changeClassName = aCritic criticTheNonMetaclassClass name) & (ch selector = aCritic selector) ]) sourcecallMethod  ^self renameThisMethod: 5class: aClass instanceVariables: instVars newClassName: className referenceVariableName: newVariable  class := self model classFor: aClass.  instanceVariables := instVars.  newClassName := className.  referenceVariableName := newVariabletestModelRenameSequenceClass  model defineClass: 'Object subclass: #Foo1 			instanceVariableNames: '''' 			classVariableNames: '''' poolDictionaries: ''''			category: #''Refactory-Test data'''.  (model classNamed: #Foo1)     compile: 'foo	 ^ Foo1' classified: #(accessing);     compile: 'objectName ^ #(Foo1)' classified: #(accessing).  (RBRenameClassTransformation model: model rename: #Foo1 to: #Foo2) asRefactoring transform.  (RBRenameClassTransformation model: model rename: #Foo2 to: #Foo3) asRefactoring transform.  self deny: (model includesClassNamed: #Foo1).  self deny: (model includesClassNamed: #Foo2).  self assert: (model includesClassNamed: #Foo3).  self assert: ((model classNamed: #Foo3) parseTreeFor: #foo) equals: (self parseMethod: 'foo ^ Foo3').  self assert: ((model classNamed: #Foo3) parseTreeFor: #objectName) equals: (self parseMethod: 'objectName ^ #(Foo3)')literalArrayCharacters  ^#($a $b $c) includes: $acollectionMessagesToExternalObject  self someObject collection remove: 10insertTemporary  | node statementNode nodeReferences children |  node := self parseTree whichNodeIsContainedBy: sourceInterval.  (node notNil and: [ node isValue ]) ifFalse: [ self refactoringFailure: 'Cannot assign to non-value nodes' ].  children := self parseTree body allChildren.  nodeReferences := children select: [:each |  each = node ] thenCollect: [:each |  each ].  statementNode := node statementNode.  nodeReferences do: [:each |  each replaceWith: (RBVariableNode named: newVariableName) ].  statementNode parent     addNode: (self constructAssignmentFrom: node) before: (node == statementNode ifTrue: [ RBVariableNode named: newVariableName ] ifFalse: [ statementNode ]);     addTemporaryNamed: newVariableNameremoveProtocolNamed: aString  model removeProtocolNamed: aString in: selfchangeClassName  ^classNameselectorsForClass: aClass do: aBlock  | enumerated |  enumerated := IdentitySet new.  environment selectorsForClass: aClass do: [:each |  enumerated add: each.        aBlock value: each ].  orEnvironment selectorsForClass: aClass do: [:each |  (enumerated includes: each) ifFalse: [ aBlock value: each ] ]testRenameInstVarNotAccessors  | refactoring class |  refactoring := RBRenameInstanceVariableRefactoring rename: 'result' to: 'whatever' in: RBBasicLintRuleTestData renameAccessors: false.  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBBasicLintRuleTestData.  self assert: (class directlyDefinesInstanceVariable: 'whatever').  self deny: (class directlyDefinesInstanceVariable: 'result').  self deny: (class definesMethod: #whatever).  self deny: (class definesMethod: #whatever:).  self assert: (class definesMethod: #result)collectSendersOfInstVar  | brokenSenders subclasses hasInstVar |  hasInstVar := false.  brokenSenders := OrderedCollection new.  oldClass superclass instanceVariableNames do: [:each |  each = variableName ifTrue: [ hasInstVar := true ] ].  hasInstVar ifTrue: [ ^brokenSenders ] ifFalse: [ brokenSenders := (oldClass selectors select: [:each |  (oldClass methodFor: each) source includesSubstring: variableName asString ] thenCollect: [:each |  oldClass methodFor: each ]) asOrderedCollection.        subclasses := oldClass subclasses.        subclasses do: [:subclass |  subclass selectors do: [:each |  ((subclass methodFor: each) source includesSubstring: ' ' , variableName asString , ' ') ifTrue: [ brokenSenders add: (subclass methodFor: each) ] ] ].        ^brokenSenders ]isEmpty  ^categories isEmptyassociationIndex: anInteger  selectedAssociationIndex := anInteger.  self changed: #associationIndexshould: aBlock raise: anExceptionalEvent whoseDescriptionDoesNotInclude: substring description: aString  ^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionNotContaining: substring) description: aStringpreconditions  ^RBCondition emptyselectMethods: aBlock  | env |  env := RBSelectorEnvironment onEnvironment: self.  self classesAndSelectorsDo: [:each :sel |  (aBlock value: (each compiledMethodAt: sel)) ifTrue: [ env addClass: each selector: sel ] ].  ^envselectorsForClass: aClass  | selectors |  selectors := IdentitySet new.  self selectorsForClass: aClass do: [:each |  selectors add: each ].  ^selectorsdenyCollection: actual hasSameElements: expected  self deny: ((actual difference: expected) isEmpty and: [ (expected difference: actual) isEmpty ]) description: 'Given collections match!'includesProtocol: aProtocol in: aClass  ^(super includesProtocol: aProtocol in: aClass) and: [ environmentDictionaries anySatisfy: [:env |  env includesProtocol: aProtocol in: aClass ] ]referencesConditionFor: aClass  | environment association |  ^(RBCondition withBlock: [ association := Smalltalk globals associationAt: aClass name ifAbsent: [ self refactoringError: 'Could not find class' ].        environment := (self environment referencesTo: association) | (self environment referencesTo: aClass name).        environment isEmpty ])     errorMacro: aClass , ' is referenced.<n>Browse references?';     errorBlock: [ environment openEditor ];     yourselfcomment: aString inMethod: aSelector inClass: aClassName  self className: aClassName.  selector := aSelector.  comment := aStringselectionIntervalFor: aString  ^(environment selectionIntervalFor: aString) ifNil: [ orEnvironment selectionIntervalFor: aString ]= aRemoveMethodChange  super = aRemoveMethodChange ifFalse: [ ^false ].  ^selector = aRemoveMethodChange selectorclassesAndTraitsDo: aBlock  self allClassesAndTraitsDo: [:each |  (self includesClass: each) ifTrue: [ aBlock value: each ] ]testRedefinedTemporary  | class |  class := model classNamed: #Foo.  class compile: 'someMethod | instVarName1 | instVarName1 := 4. ^instVarName1' classified: #(#accessing).  self shouldFail: (RBTemporaryToInstanceVariableRefactoring class: class selector: #someMethod variable: 'instVarName1')addInstanceVariables  instanceVariables do: [:each |  self performComponentRefactoring: (RBAddInstanceVariableRefactoring model: self model variable: each class: newClass) ]asUndoOperation  self copy     category: self changeClass category;     yourselfprintOn: aStream  aStream     nextPutAll: self oldName;     nextPutAll: ' rename: ';     print: self newName;     nextPut: $!refersToClass  ^RBRefactoryTestDataAppclass: aClass protocol: aProtocol source: aString  self changeClass: aClass.  self protocols: aProtocol.  source := aStringextractReceiver  | name |  (cascadeNode receiver isLiteralNode or: [ cascadeNode receiver isVariable ]) ifTrue: [ ^self ].  name := self safeVariableNameFor: class temporaries: self parseTree allDefinedVariables basedOn: 'receiver'.  ancestorNode parent     addTemporaryNamed: name;     addNode: (RBAssignmentNode variable: (RBVariableNode named: name) value: cascadeNode receiver) before: ancestorNode.  cascadeNode messages do: [:each |  each receiver: (RBVariableNode named: name) ]changeClass: aBehavior  super changeClass: aBehavior.  isMeta := falsepreconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: 'Class named ' , className , ' does not exist') & (RBCondition withBlock: [ ((model environment protocolsFor: self definingClass realClass) includes: protocol) not ] errorString: 'Protocol named ' , protocol , ' already exists')shouldRemoveExtensions  ^shouldRemoveExtensionsrename: aVarName to: aName in: aClass renameAccessors: aBoolean  self variable: aVarName class: aClass.  newName := aName.  renameAccessors := aBooleanpushDown: selectorCollection from: aClass  self setOption: #selectorsFromView toUse: [:ref |   ].  class := self classObjectFor: aClass.  selectors := selectorCollectioncomparingStringBetween: actual and: expected  ^String streamContents: [:stream |  stream           nextPutAll: 'Got ';           nextPutAll: actual fullPrintString;           nextPutAll: ' instead of ';           nextPutAll: expected fullPrintString;           nextPutAll: '.' ]changeClass: aBehavior  super changeClass: aBehavior.  isMeta := falsepreconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ | messageNode |              messageNode := self parserClass parseExpression: message.              messageNode allVariables allSatisfy: [:e |  (self definingMethod hasArgumentNamed: e name) or: [ self definingMethod hasTemporaryNamed: e name ] ] ] errorString: ('Some variables in this message send are not defined in method named <1s>.' expandMacrosWith: selector))theNonMetaClass  ^model classNamed: self nametestModelRemoveInstanceVariable  | class |  model defineClass: 'nil subclass: #Object instanceVariableNames: ''foo1'' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  class := model classNamed: #Object.  self assert: (class definesInstanceVariable: 'foo1').  self executeRefactoring: (RBRemoveInstanceVariableRefactoring model: model variable: 'foo1' class: class).  self deny: (class definesInstanceVariable: 'foo1')removeReturns  | rewriter |  rewriter := RBParseTreeRewriter new.  rewriter replace: '^``@object' with: '``@object'.  (rewriter executeTree: inlineParseTree) ifTrue: [ inlineParseTree := rewriter tree ]checkClass: aSmalllintContext  rules do: [:each |  each checkClass: aSmalllintContext.        Processor yield ]listToFindMatches: aCollection  listToFindMatches := aCollectionhierarchyDefinesInstanceVariable: aString  (self definesInstanceVariable: aString) ifTrue: [ ^true ].  ^self allSubclasses anySatisfy: [:each |  each directlyDefinesInstanceVariable: aString ]removeClass: aClass  environmentDictionaries keysDo: [:key |  (environmentDictionaries at: key) removeClass: aClass ]equivalentSuperclassMethods  ^self identityHashuniversalTestFor: aChange  self equalityTestFor: aChange.  self stringTestFor: aChange.  (aChange isKindOf: RBRefactoryClassChange) ifTrue: [ self undoTestFor: aChange ]execute  self primitiveExecute.  RBRefactoryChangeManager instance     performChange: self changes;     addUndoPointer: 1newModel  ^(RBNamespace2 onEnvironment: self defaultEnvironment)     name: self printString;     yourselfprimitiveExecute  self checkPreconditions.  self transformmessagesNotReplaced  ^numberNotReplacedtestNonExistantName  self     shouldFail: (RBAddVariableAccessorTransformation classVariable: #Foo class: #RBBasicLintRuleTestData) asRefactoring;     shouldFail: (RBAddVariableAccessorTransformation instanceVariable: 'foo' class: #RBBasicLintRuleTestData) asRefactoringhasUndoableOperations  ^undo isNotEmptytestMethod1  ^self testMethod1 , ([:each |  each testMethod1 ] value: #(#(#testMethod1) 2 #testMethod1))createMockClass  self class compiler evaluate: 'Object subclass: #RBRefactoringChangeMock	instanceVariableNames: ''instVar''	classVariableNames: ''ClassVar''	poolDictionaries: ''''	category: ''Refactoring-Tests-Changes'''.  self class compiler evaluate: 'RBRefactoringChangeMock class	instanceVariableNames: ''classInstVar'''.  self changeMock compile: 'one ^ 1' classified: 'accessing'refersToSymbol: aSymbol  | searcher |  searcher := self parserTreeSearcher.  searcher     matches: aSymbol printString do: [:node :answer |  true ];     matches: '`#literal' do: [:node :answer |  answer or: [ self literal: node value containsReferenceTo: aSymbol ] ].  (RBScanner isSelector: aSymbol) ifTrue: [ searcher matches: '`@object ' , (self parseTreeSearcherClass buildSelectorString: aSymbol) do: [:node :answer |  true ] ].  ^searcher executeTree: self parseTree initialAnswer: falsetestRedefineClassChange  | st |  st := modelFactory rbNamespace new.  st defineClass: 'nil subclass: #Object				instanceVariableNames: ''a''				classVariableNames: ''A''				poolDictionaries: ''TextConstants''				category: #''Refactory-Testing'''.  self assert: (st includesClassNamed: #Object).  self assert: (st classNamed: #Object) notNiltestRefactoring  | refactoring oldClass newClass |  refactoring := (RBMoveInstanceVariableToClassTransformation model: model variable: 'methodBlock' fromClass: #RBBasicLintRuleTestData toClass: #RBFooLintRuleTestData) asRefactoring.  oldClass := refactoring model classNamed: #RBBasicLintRuleTestData.  newClass := refactoring model classNamed: #RBFooLintRuleTestData.  self assert: (oldClass directlyDefinesInstanceVariable: 'methodBlock').  self deny: (newClass directlyDefinesInstanceVariable: 'methodBlock').  [ refactoring transform ] on: RBRefactoringError do: [:e |  e resume ].  self assert: refactoring model changes changes size equals: 2.  oldClass := refactoring model classNamed: #RBBasicLintRuleTestData.  newClass := refactoring model classNamed: #RBFooLintRuleTestData.  self deny: (oldClass directlyDefinesInstanceVariable: 'methodBlock').  self assert: (newClass directlyDefinesInstanceVariable: 'methodBlock')arguments: nameCollection  arguments := nameCollection.  self changed: #argumentsremoveMethod  self onError: [ self performComponentRefactoring: (RBRemoveMethodRefactoring model: self model removeMethods: (Array with: selector) from: class) ] do: [  ]superClass: anObject  (anObject allSubclasses includes: class realClass) ifFalse: [ self refactoringError: ('<1s> is not a superclass of <2p>' expandMacrosWith: anObject with: class name) ].  targetSuperclass := self classObjectFor: anObjectclassName  ^className ifNil: [ UIManager default chooseOrRequestFrom: (self environment allClasses collect: #name) title: 'Class name was not defined to perform ' , self class baseClass name , '. Please select a class to resume this transformation.' ]systemDictionary  ^Smalltalk globalsstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' protocol: ''';     nextPutAll: protocol;     nextPutAll: ''' inClass: ''';     nextPutAll: className.  aStream nextPut: $)testNonExistantName  self shouldFail: (RBAbstractInstanceVariableRefactoring variable: 'foo' class: RBBasicLintRuleTestData)asOrderedCollectionNotNeeded  self foo addAll: (1 to: 10) asOrderedCollectionproblemCount  ^result problemCountcreateMockClass  self class compiler evaluate: 'Object subclass: #RBRefactoringChangeMock	instanceVariableNames: ''instVar''	classVariableNames: ''ClassVar''	poolDictionaries: ''''	category: ''Refactoring-Tests-Changes'''.  self class compiler evaluate: 'RBRefactoringChangeMock class	instanceVariableNames: ''classInstVar'''.  self changeMock compile: 'one ^ 1' classified: 'accessing'preconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ (self definingMethod allChildren select: #isVariable thenCollect: #name) anySatisfy: [:e |  e asString = variableName ] ] errorString: ('Method named <1s> does not have an assignment for variable named <2s>' expandMacrosWith: selector with: variableName)) & (RBCondition withBlock: [ (self definingMethod allChildren select: #isAssignment thenCollect: #variable) anySatisfy: [:e |  e name asString = variableName ] ] errorString: ('Method named <1s> does not have an assignment for variable named <2s>' expandMacrosWith: selector with: variableName))calls  ^self rewriteRule10: self name , self rewriteRule10precedence  ^self isArray ifFalse: [ (self block + 5) * 34 ] ifTrue: [ self printString = 10 ]assignmentWithoutEffect  | a |  a := 1.  a := aremoveProtocolNamed: aString in: aClass  ^changes removeProtocolNamed: aString in: aClasssmallLintCritics  ^self allClassesrun  ^Object printOn: selfassertEmpty: aCollection  ^self assert: aCollection isEmpty description: aCollection asString , ' should have been empty'assert: actual identicalTo: expected  ^self assert: expected == actual description: [ self comparingIdentityStringBetween: actual and: expected ]refactoringError: aString  ^RBRefactoringError signal: aStringcheckSelfReturns  | searcher |  searcher := self parseTreeSearcher.  searcher     matches: '^self' do: [:aNode :answer |  answer ];     matches: '^`@anything' do: [:aNode :answer |  true ].  (searcher executeTree: extractedParseTree initialAnswer: false) ifTrue: [ self placeholderNode asReturn ]shouldnt: aBlock description: aString  self deny: aBlock value description: aStringtestExistingInstanceVariableAccessors  | refactoring |  refactoring := (RBAddVariableAccessorTransformation instanceVariable: 'name' class: #RBDummyLintRuleTest) asRefactoring transform.  self assertEmpty: refactoring changes changesclassNamesWithVariables  | classNames |  classNames := Set new.  classNames     addAll: instanceVariables keys;     addAll: instanceVariableReaders keys;     addAll: instanceVariableWriters keys;     addAll: classVariables keys.  ^classNamesclassVariableNames  ^self privateClassVariableNames copyprivatePoolDictionaryNames  (self isDefined and: [ poolDictionaryNames isNil ]) ifTrue: [ self poolDictionaryNames: (self realClass sharedPools collect: [:each |  self realClass environment keyAtValue: each ]) ].  ^poolDictionaryNamesleftFailed  ^left errorStringFor: falsevariable: aVariableName inMethod: aSelector inClass: aClass  self className: aClass.  selector := aSelector.  variableName := aVariableNametestMetaClassFailure  self shouldFail: (RBRenameClassTransformation rename: self class class to: #Foo) asRefactoringisEmpty  self subclassResponsibilitydemoMethodWithDuplicates  | a b result1 result2 answer |  a := 3.  b := a + 5.  result1 := a + b.  result2 := a + 5.  answer := result1 + result2 + (a + 5).  ^answertestAbstractInstanceVariable  | refactoring class |  refactoring := RBAbstractInstanceVariableRefactoring variable: 'class' class: RBTransformationRuleTestData.  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBTransformationRuleTestData.  self assert: (class parseTreeFor: #class1) equals: (self parseMethod: 'class1 ^class').  self assert: (class parseTreeFor: #class:) equals: (self parseMethod: 'class: anObject	class := anObject').  self assert: (class parseTreeFor: #superSends) equals: (self parseMethod: 'superSends	| rule |	rule := RBParseTreeRewriter new.	rule addSearch: ''super `@message: ``@args'' 				-> (					[:aNode | 					(self class1 withAllSubclasses 						detect: [:each | each includesSelector: aNode selector]						ifNone: [nil]) isNil] 							-> ''self `@message: ``@args'').	self rewriteUsing: rule').  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 	self class: aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) 		ifTrue: 			[(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) 				ifFalse: 					[builder 						compile: rewriteRule tree printString						in: self class1						classified: aSmalllintContext protocols]]')isMovingToInstVar  ^self isMovingToArgument not and: [ (class whoDefinesInstanceVariable: variable) notNil ]testParseTreeTypes  | types model |  model := RBClassModelFactory rbNamespace new.  types := RBRefactoryTyper typesFor: 'foo' in: (self parseExpression: 'foo printString; testBasicLintRuleTypes; testParseTreeTypes') model: model.  self assert: types size equals: 1.  self assert: (types includes: (model classFor: self class))selectionParseTreeIntervalFor: aString  | parseTree answerBlock |  parseTree := RBParser parseMethod: aString onError: [:str :pos |  ^nil ].  answerBlock := [:aNode :answer |  ^aNode sourceInterval ].  self searchStrings do: [:each |  | matcher tree |        matcher := RBParseTreeSearcher new.        matcher matchesTree: (RBLiteralNode value: each) do: answerBlock.        each isSymbol ifTrue: [ tree := RBParseTreeSearcher buildSelectorTree: each.              tree ifNotNil: [ matcher matchesTree: tree do: answerBlock ] ] ifFalse: [ tree := RBVariableNode named: each.              matcher                 matchesTree: tree do: answerBlock;                 matchesArgumentTree: tree do: answerBlock ].        matcher executeTree: parseTree ].  ^nilsource: aString  source := aStringinlineTemporary  | temp |  self isNil ifTrue: [ temp := 4 ].  ^tempresetResult  swapMethod: aSelector in: aClass  class := self classObjectFor: aClass.  target := self classObjectFor: (class isMeta ifTrue: [ class instanceSide ] ifFalse: [ class classSide ]).  selector := aSelectorinitialize  model := RBClassModelFactory rbNamespace new.  class := model classFor: Object.  variableTypes := Dictionary new.  variableMessages := Dictionary new.  selectorLookup := IdentityDictionary new.  bestGuesses := Dictionary new= aDefinitionChange  ^self class = aDefinitionChange class and: [ self definition = aDefinitionChange definition ]parseTreeSearcherClass  ^RBParseTreeSearchersmallLintCritics  ^self classescheckClass: aSmalllintContext  rules do: [:each |  each checkClass: aSmalllintContext.        Processor yield ]allReferencesToClass: aRBClass do: aBlock  self allClassesDo: [:each |  (each whichSelectorsReferToClass: aRBClass) do: [:sel |  aBlock value: (each methodFor: sel) ].        (each classSide whichSelectorsReferToClass: aRBClass) do: [:sel |  aBlock value: (each classSide methodFor: sel) ] ]parseTreeRewriter  | rewriteRule oldString newString |  rewriteRule := RBParseTreeRewriter new.  oldString := self buildSelectorString: oldSelector.  newString := self newSelectorString.  rewriteRule replace: '``@object ' , oldString with: '``@object ' , newString.  ^rewriteRulesearchingLiteral  ^self printString = #a or: [ #() = self printString | (#() == self printString) ]testMethodDoesNotExist  self shouldFail: (RBAddReturnStatementTransformation return: '^ variable' inMethod: #method inClass: #RBAddReturnStatementTransformationTest) asRefactoringincludesCategory: aCategory  ^(environment includesCategory: aCategory) and: [ (self classNamesFor: aCategory) notEmpty ]instVarReadersTo: instVarName in: aClass  ^RBVariableEnvironment on: self readersOfInstanceVariable: instVarName in: aClassname  ^renrakuRule namecalled: anObject on1: aBlock  | each |  each := anObject printString.  Transcript     show: each;     cr.  aBlock value: eachincludesClass: aClass  ^(self privateSelectorsForClass: aClass) isNotEmpty and: [ super includesClass: aClass ]unaryAccessingMethodWithReturn  ^selftestModelNonExistantName  | refactoring |  (model classNamed: #RBLintRuleTestData) removeMethod: #name.  refactoring := RBAddParameterRefactoring model: model addParameterToMethod: #name in: RBLintRuleTestData newSelector: #nameNew: initializer: 'nil'.  self shouldFail: refactoringtestNonExistantSelector  self shouldFail: (RBExtractToTemporaryRefactoring extract: (14 to: 23) to: 'asdf' from: #checkClass1: in: RBRefactoryTestDataApp)preconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ self definingMethod lastIsReturn ] errorString: ('Method named <1s> does not have a return statement' expandMacrosWith: selector))preconditions  self subclassResponsibilityincludesMethod: aMethod  ^self includesSelector: aMethod selector in: aMethod methodClassstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' pragma: ''';     nextPutAll: pragma;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: aStream.  aStream nextPut: $)detectContains  ^(1 to: 10) do: [:each |  each > 2 ifTrue: [ ^each ] ]preconditions  ^RBCondition withBlock: [ (class hierarchyDefinesInstanceVariable: variableName) ifTrue: [ self refactoringError: 'Already defined in hierarchy' ].        true ]testPackageEnvironment  | aPackageEnvironment |  aPackageEnvironment := universalEnvironment forPackageNames: (Array with: 'Refactoring-Tests-Environment' with: 'Refactoring-Tests-Critics').  self universalTestFor: aPackageEnvironment.  self assert: (aPackageEnvironment implementorsOf: #testPackageEnvironment) numberSelectors equals: 1refersToVariable: aString  | searcher tree |  tree := self parseTree.  ((tree defines: aString) or: [ tree body defines: aString ]) ifTrue: [ ^false ].  searcher := self parserTreeSearcher.  searcher     matches: aString do: [:node :answer |  true ];     matches: '[:`@vars | | `@temps | `@.Stmts]' do: [:node :answer |  answer or: [ ((node defines: aString) or: [ node body defines: aString ]) not and: [ searcher executeTree: node body initialAnswer: false ] ] ].  ^searcher executeTree: self parseTree initialAnswer: falseshouldOverride: aSelector in: aClass  ^(self options at: #alreadyDefined) value: self value: aClass value: aSelectorpostCopy  super postCopy.  categories := categories copytestModelBadInitializationCode  | refactoring |  model removeClassNamed: #RBRefactoring.  refactoring := RBAddParameterRefactoring model: model addParameterToMethod: #name1 in: RBLintRuleTestData newSelector: #name1: initializer: 'AddParameterRefactoring new'.  self shouldFail: refactoringprintOn: aStream  class printOn: aStream.  aStream     nextPutAll: '>>';     nextPutAll: self selectorrename: aVarName to: aName in: aClass  self rename: aVarName to: aName in: aClass renameAccessors: falseparseTree  ^parseTree ifNil: [ parseTree := self buildParseTree ] ifNotNil: [ parseTree ]transform  class allSubclasses do: [:each |  (each directlyDefinesInstanceVariable: variableName) ifTrue: [ each removeInstanceVariable: variableName ] ].  class addInstanceVariable: variableNameisMethodEquivalentTo: aSelector  selector == aSelector ifTrue: [ ^false ].  aSelector numArgs ~~ parameters size ifTrue: [ ^false ].  (self isParseTreeEquivalentTo: aSelector) ifFalse: [ ^false ].  self reorderParametersToMatch: aSelector.  ^trueclassesDo: aBlock  environment classesDo: [:each |  (self includesClass: each) ifTrue: [ aBlock value: each ] ]defaultLabel  ^'Smalltalk'renameReferences  | replacer |  replacer := (RBParseTreeRewriter replaceLiteral: className with: newName)     replace: className with: newName;     replaceArgument: newName withValueFrom: [:aNode |  self refactoringFailure: newName , ' already exists within the reference scope' ];     yourself.  self model allReferencesToClass: deprecatedClass do: [:method |  (method modelClass hierarchyDefinesVariable: newName) ifTrue: [ self refactoringFailure: newName , ' is already defined in hierarchy of ' , method modelClass printString ].        self convertMethod: method selector for: method modelClass using: replacer ]searchStrings  ^searchStrings ifNil: [ #() ] ifNotNil: [ searchStrings ]testPerformAddRemoveInstanceVariable  | change |  change := changes addInstanceVariable: 'foo' to: self changeMock.  self perform: change do: [ self assert: (change changeClass instVarNames includes: 'foo') ].  self deny: (change changeClass instVarNames includes: 'foo')testAddParameterForTwoArgumentMessage  | refactoring class |  refactoring := RBAddParameterRefactoring addParameterToMethod: ('called:' , 'on:') asSymbol in: RBRefactoryTestDataApp newSelector: #called:bar:on: initializer: '#(1.0)'.  self proceedThroughWarning: [ self executeRefactoring: refactoring ].  class := refactoring model classNamed: #RBRefactoryTestDataApp.  self assert: (class parseTreeFor: #called:bar:on:) equals: (self parseMethod: 'called: anObject bar: aBlock on: anObject1							Transcript								show: anObject printString;								cr.								aBlock value').  self assert: (class parseTreeFor: #caller) equals: (self parseMethod: 'caller							| anObject |							anObject := 5.							self 								called: anObject + 1								bar: [^anObject] on: #(1.0)').  self deny: (class directlyDefinesMethod: ('called:' , 'on:') asSymbol)testModelMetaclassAlreadyExistingName  (model metaclassNamed: #Foo) addInstanceVariable: 'instVarName1'.  self shouldFail: (RBAddVariableTransformation model: model instanceVariable: 'instVarName1' class: (model classNamed: #Bar)) asRefactoringtestBrowserEnvironment  self universalTestFor: RBBrowserEnvironment newifTrueReturns  self isSymbol ifFalse: [ ^true ].  ^falsedeny: aBooleanOrBlock description: aString  self assert: aBooleanOrBlock value not description: aStringtestClassVariable  | refactoring class |  refactoring := (RBRemoveDirectAccessToVariableTransformation classVariable: 'UndoSize' class: #RBRefactoryChangeManager) asRefactoring transform.  self assert: refactoring model changes changes size equals: 2.  class := (refactoring model classNamed: #RBRefactoryChangeManager) theMetaClass.  self assert: (class parseTreeFor: #initialize) equals: (self parseMethod: 'initialize self nuke. self undoSize: 20').  self assert: (class theNonMetaClass parseTreeFor: #addUndo:) equals: (self parseMethod: 'addUndo: aRefactoringChange				undo push: aRefactoringChange.				undo size > self class undoSize					ifTrue: [ undo removeFirst ].				redo := OrderedCollection new')testMethod  ^self classtestCategoryEnvironment  | aCategoryEnvironment |  self skip: 'Use RBPackageEnvironment instead.'.  aCategoryEnvironment := RBCategoryEnvironment onEnvironment: RBBrowserEnvironment new categories: #(#'Kernel-Objects').  self universalTestFor: aCategoryEnvironment.  self assert: (aCategoryEnvironment implementorsOf: #printString) numberSelectors equals: 1testModelExistingName  | refactoring |  refactoring := RBAddClassRefactoring model: model addClass: #Foo superclass: Object subclasses: #() category: #'Refactory-Testing'.  self shouldFail: refactoringtoDoCollect  | array |  array := Array new: 10.  1 to: 10 do: [:i |  array at: i put: i * i ].  ^arrayincludesClass: aClass  ^environment includesClass: aClasscreateGetterAccessor  (self definingClass getterMethodFor: variableName) ifNil: [ self defineGetterMethod ]unaryNonAccessingMethodWithoutReturn  testMultipleSelectors  self shouldWarn: (RBRenameMethodRefactoring renameMethod: #checkClass: in: RBBasicLintRuleTestData to: #foo: permutation: (1 to: 1))transform  self combineMessages.  self compileCodeviewResults  rules do: [:each |  each viewResults ]testPerformAddRemoveMethodInteractively  | change |  change := changeFactory addMethodSource: 'method ^ 1' in: self changeMock classified: #utilities for: self.  self perform: change do: [ self assert: (self changeMock canUnderstand: #method) ].  self deny: (self changeMock canUnderstand: #method).  self assert: change definedSelector equals: #methodtestNonExistantName  self shouldFail: (RBRenameClassVariableRefactoring rename: #foo to: #newFoo in: RBBasicLintRuleTestData)anInstVar  ^anInstVarstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' addParameterToMethod: #';     nextPutAll: oldSelector;     nextPutAll: ' in: '.  class storeOn: aStream.  aStream     nextPutAll: ' newSelector: #';     nextPutAll: newSelector;     nextPutAll: ' initializer: ''';     nextPutAll: initializer;     nextPutAll: ''')'preconditions  ^RBCondition emptyincludesPackage: aRPackage  ^self packages includes: aRPackagepackages  | pSet |  pSet := Set new.  self classes do: [:each |  each packages do: [:p |  self selectorsForClass: each do: [:s |  (p includesSelector: s ofClass: each) ifTrue: [ pSet add: p ] ] ] ].  ^pSetpreconditions  class := self definingClass theNonMetaClass.  ^isClassVariable ifTrue: [ self preconditionsForClassVariable ] ifFalse: [ self preconditionsForInstanceVariable ]= aRefactoryClassChange  self class = aRefactoryClassChange class ifFalse: [ ^false ].  ^className = aRefactoryClassChange changeClassName and: [ isMeta = aRefactoryClassChange isMeta ]processNode: aNode  (aNode isVariable and: [ class instanceVariableNames includes: aNode name ]) ifTrue: [ ^self merge: aNode name ].  (aNode isMessage and: [ aNode receiver isSelf ]) ifTrue: [ ^self merge: aNode selector ].  aNode isAssignment ifTrue: [ self           processNode: aNode value;           processNode: aNode variable ].  (aNode isMessage and: [ #(#ifTrue: #ifFalse: #ifTrue:ifFalse: #ifFalse:ifTrue:) includes: aNode selector ]) ifTrue: [ aNode arguments do: [:each |  each isBlock ifTrue: [ each body statements isEmpty ifFalse: [ self processNode: each body statements last ] ] ] ]check  left check ifFalse: [ failed := #leftFailed.        ^false ].  right check ifFalse: [ failed := #rightFailed.        ^false ].  ^trueisVariableEnvironment  ^trueremoveOldAccessors  | oldAccessors |  oldAccessors := (class allSelectors select: [:each |  each = variableName asSymbol or: [ each = (variableName , ':') asSymbol ] ] thenCollect: [:each |  class methodFor: each ]) asOrderedCollection.  oldAccessors do: [:each |  class removeMethod: each selector ]parseTree  ^self parserClass parseMethod: self source onError: [:str :pos |  ^nil ]checkOverridesSelectorInClass: each  each ~= method origin ifTrue: [ ((self model classNamed: each name asSymbol) directlyDefinesMethod: method selector) ifTrue: [ self refactoringError: ('<1p> overrides the method <2s>' expandMacrosWith: each name with: method selector) ] ]changeString  ^String streamContents: [:stream |  stream           nextPutAll: '[';           nextPutAll: self protocol;           nextPutAll: '] ';           nextPutAll: super changeString ]methodBlock: aBlock  methodBlock := aBlockrules  ^rulestestFoo: anObject  ^self class + anObjecthasRedoableOperations  ^redo isNotEmptyfindGetterMethod  | definingClass matcher |  definingClass := self definingClass.  matcher := self parseTreeSearcherClass getterMethod: variableName.  ^self possibleGetterSelectors detect: [:each |  (self checkClass: definingClass selector: each using: matcher) notNil and: [ (definingClass subclassRedefines: each) not ] ] ifNone: [ nil ]testRename  | transformation |  transformation := (RBRenameTemporaryVariableTransformation rename: #rules to: #asdf in: #RBLintRuleTestData selector: #openEditor) transform.  self assert: ((transformation model classNamed: #RBLintRuleTestData) parseTreeFor: #openEditor) equals: (self parseMethod: 'openEditor								| asdf |								asdf := self failedRules.								asdf isEmpty ifTrue: [^self].								asdf size == 1 ifTrue: [^asdf first viewResults]')rules: aCollection  rules := aCollectionnewName: anObject  newName := anObjecttestBadInitializationCode  self     shouldFail: (RBAddParameterRefactoring addParameterToMethod: #name in: RBLintRuleTestData newSelector: #name: initializer: 'foo:');     shouldFail: (RBAddParameterRefactoring addParameterToMethod: #name in: RBLintRuleTestData newSelector: #name: initializer: 'foo')instanceSide  ^selfpreconditions  ^(RBCondition isValidInstanceVariableName: variableName for: class) & (RBCondition hierarchyOf: class definesVariable: variableName) not & (RBCondition isGlobal: variableName in: self model) nottestRemoveReferenced  self shouldFail: (RBRemoveHierarchyMethodRefactoring removeMethods: #(#msg1) from: RBBasicLintRuleTestData)testNewExistingName  | refactoring |  model := RBClassModelFactory rbNamespace new.  model name: 'Add instance variable'.  model defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.  refactoring := RBAddInstanceVariableRefactoring model: model variable: 'asdf' class: (model classNamed: #FOOBAR).  self shouldFail: refactoringselectedSource  ^self parseTree source copyFrom: selectedInterval first to: selectedInterval lastallClasses  | allClasses |  allClasses := IdentitySet new: 4096.  self classesDo: [:each |  allClasses add: each instanceSide ].  ^allClasses asArrayclassBinding  ^Smalltalk globals associationAt: self nameforClasses: classCollection  | classes |  classes := OrderedCollection new: classCollection size * 2.  classCollection do: [:each |  classes           add: each instanceSide;           add: each classSide ].  ^RBClassEnvironment onEnvironment: self classes: classesdefinesMethod: aSelector  (self directlyDefinesMethod: aSelector) ifTrue: [ ^true ].  ^self superclass notNil and: [ self superclass definesMethod: aSelector ]defineSetterMethod  | selector definingClass string |  definingClass := self definingClass.  string := self needsReturnForSetter ifTrue: [ '<1s> anObject<r><t>^ <2s> := anObject' ] ifFalse: [ '<1s> anObject<r><t><2s> := anObject' ].  selector := self safeMethodNameFor: definingClass basedOn: variableName asString , ':'.  definingClass compile: (string expandMacrosWith: selector with: variableName) classified: #accessing.  ^selectorwhatToDisplayIn: aChangeBrowser  ^{self}preconditionsForInstanceVariable  ^(RBCondition definesInstanceVariable: variableName asString in: class) & (RBCondition doesNotAccessInstanceVariable: variableName inHierarchyOf: class showIn: self)subclassResponsibilityFor: aSelector in: aClass  | methodNode position source |  source := aClass sourceCodeFor: aSelector.  methodNode := self parserClass parseMethod: source onError: [:err :pos |  ^nil ].  position := methodNode arguments isEmpty ifTrue: [ methodNode keywordsIntervals last last ] ifFalse: [ methodNode arguments last stop ].  ^'<1s><n><t>self subclassResponsibility' expandMacrosWith: (source copyFrom: 1 to: position)resultClass: aClass  result := aClass newmethodAfter  | variable |  variable := 'String'.  variable := 1 asStringtextToDisplay  ^String streamContents: [:stream |  stream           nextPutAll: '"protocol: ';           nextPutAll: self protocol;           nextPutAll: '"';           nextPutAll: String cr;           nextPutAll: super textToDisplay ]genericPatternForSelector: aSymbol  ^String streamContents: [:stream |  aSymbol keywords keysAndValuesDo: [:index :value |  stream                 space;                 nextPutAll: value.              aSymbol last = $: ifTrue: [ stream                       space;                       nextPutAll: '`@object';                       print: index ] ] ]transform  class removeInstanceVariable: variableNameskipUnless: aBooleanOrBlock  aBooleanOrBlock value ifFalse: [ TestSkip signal: 'Assumption in #skipUnless: failed' ]toDo  1 to: self size do: [:i |  (self at: i) printString ]includesSelector: aSelector in: aClass  ^(environment includesSelector: aSelector in: aClass) and: [ andedEnvironment includesSelector: aSelector in: aClass ]includesProtocol: aProtocol in: aClass  ^(environment includesProtocol: aProtocol in: aClass) and: [ (self selectorsFor: aProtocol in: aClass) notEmpty ]classNames: aClassNameCollection  classNames := aClassNameCollectionclass: aClass selector: aSelector rename: anOldSymbol to: aNewSymbol  self className: aClass.  selector := aSelector.  variableName := anOldSymbol.  newVariableName := aNewSymboltestAddClassPattern  self exampleClasses do: [:class |  (class isObsolete or: [ class superclass notNil and: [ class superclass isObsolete ] ]) ifFalse: [ | change |              change := changes defineClass: class oldDefinition.              self assert: (change isKindOf: RBAddClassChange).              self assert: change changeClassName equals: class name.              class superclass ifNil: [ self assert: change definitionClass equals: ProtoObject ] ifNotNil: [ self assert: change definitionClass equals: class superclass ].              self assert: change instanceVariableNames equals: class instVarNames asArray.              self assert: change classVariableNames equals: class classVarNames asArray.              self assert: change sharedPoolNames equals: class sharedPoolNames asArray.              self assert: change category equals: class category.              self universalTestFor: change ] ]preconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ (self definingMethod allChildren select: #isVariable thenCollect: #name) anySatisfy: [:e |  e asString = variableName ] ] errorString: ('Method named <1s> does not have a variable named <2s>' expandMacrosWith: selector with: variableName))nameToDisplay  ^self nameclassSelectorDictionary  ^classes inject: (IdentityDictionary new: classes size) into: [:answer :class |  answer           at: class put: (self systemDictionary at: class) selectors;           yourself ]includesProtocol: aProtocol in: aClass  ^(self includesClass: aClass) and: [ environment includesProtocol: aProtocol in: aClass ]sizeCheck  self isEmpty ifFalse: [ self do: [:each |   ] ]checkClass: aClass  renrakuRule class checksClass ifFalse: [ ^self ].  renrakuRule check: aClass forCritiquesDo: [:crit |  result addClass: aClass.        self addSearchStringFrom: crit in: aClass definition.        ^self ]testTransform  | transformation class |  transformation := (RBRenameClassTransformation rename: 'RBDummyClassToRename' asSymbol to: 'RBNewDummyClassName' asSymbol) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: 'RBNewDummyClassName' asSymbol.  self assert: (class parseTreeFor: #method1) equals: (self parseMethod: 'method1 ^ self method2').  self deny: (transformation model includesClassNamed: 'RBDummyClassToRename' asSymbol).  class := transformation model classNamed: 'RBDummySubclassOfClassToRename' asSymbol.  self assert: class superclass equals: (transformation model classNamed: 'RBNewDummyClassName' asSymbol).  self assert: (class parseTreeFor: #symbolReference) equals: (self parseMethod: 'symbolReference ^ #RBNewDummyClassName').  self assert: (class parseTreeFor: #reference) equals: (self parseMethod: 'reference ^ RBNewDummyClassName new')merge: aName  | set1 set2 |  set1 := backpointers at: methodName ifAbsent: [ nil ].  set2 := backpointers at: aName ifAbsent: [ nil ].  (set1 isNil or: [ set2 isNil or: [ set1 == set2 ] ]) ifTrue: [ ^self ].  set1 addAll: set2.  set2 do: [:each |  backpointers at: each put: set1 ]parseTreeRewriterClass  ^RBParseTreeRewritertestPerformAddRemoveClassInstanceVariable  | change |  change := changes addInstanceVariable: 'foo' to: self changeMock class.  self perform: change do: [ self assert: (change changeClass instVarNames includes: 'foo') ].  self deny: (change changeClass instVarNames includes: 'foo')includesProtocol: aProtocol in: aClass  ^(super includesProtocol: aProtocol in: aClass) and: [ (environment selectorsFor: aProtocol in: aClass) anySatisfy: [:aSelector |  self privateIncludesSelector: aSelector inClass: aClass ] ]transform  class renameClassVariable: variableName to: newName around: [ self renameReferences ]sourceCode  ^self selectedClass sourceCodeAt: self selector ifAbsent: [ '' ]missingYourself  ^OrderedCollection new     add: 1;     add: 2;     removeFirstrename: aClass name: aSymbol  ^RBRenameClassRefactoring model: self model rename: aClass to: aSymbolcruft  < haltOrBreakpointForTesting>  self haltremoveClassVariable: aString from: aRBClass  ^changes removeClassVariable: aString from: aRBClassinitializeWith: aCollection and: anotherCollection in: aTree  arguments := aCollection.  values := anotherCollection.  tree := aTree.  argsAndValues := Dictionary new.  self initialize.  self title: 'There are extra arguments in this method. Please map a value to each extra argument.' translatedreturnsBooleanAndOther  self isVariable ifTrue: [ ^false ].  self printStringatIfAbsent  ^Smalltalk at: #MyTest ifAbsent: [ | collection |        collection := #().        Smalltalk at: #MyTest put: collection ]inlineSourceReplacing: aParseTree  | statements nodeUnderSequence |  statements := inlineParseTree body statements.  (statements size > 1 and: [ aParseTree isEvaluatedFirst not ]) ifTrue: [ self refactoringWarning: 'To inline this method, we need to move some of its statements before the original message send.<n>This could change the order of execution, which can change the behavior.<n>Do you want to proceed?' expandMacros ].  nodeUnderSequence := aParseTree.  [ nodeUnderSequence parent isSequence ] whileFalse: [ nodeUnderSequence := nodeUnderSequence parent ].  nodeUnderSequence parent     addNodes: (statements copyFrom: 1 to: (statements size - 1 max: 0)) before: nodeUnderSequence;     addTemporariesNamed: inlineParseTree body temporaryNames.  aParseTree parent replaceNode: aParseTree withNode: (statements isEmpty ifTrue: [ RBVariableNode named: 'self' ] ifFalse: [ statements last ])testComment  | change |  change := changes comment: 'Some Comment' in: self class.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self assert: change comment equals: 'Some Comment'.  self universalTestFor: changetestNotUnderstandNewSelector  self shouldFail: (RBReplaceMethodRefactoring replaceCallMethod: #checkClass: in: RBBasicLintRuleTestData to: #checkMethod23: permutation: (1 to: 1))testDefinesInstanceVariable  self deny: (objectClass definesInstanceVariable: 'instanceVariable1').  self assert: (newClass definesInstanceVariable: 'instanceVariable1').  self deny: (messageNodeClass definesInstanceVariable: 'instanceVariable1').  self assert: (messageNodeClass definesInstanceVariable: 'parent').  self assert: (messageNodeClass definesInstanceVariable: 'selector')checkMethodForBlocks  | definingNode |  definingNode := self definingBlock.  self checkBlocksIn: definingNode.  self checkLocationsIn: (self checkAllBlocksIn: definingNode)createMethodSearchWith: aCodeString selectors: selectorCollection inClass: aClass  | search |  search := self parseTreeSearcher.  search matchesAnyMethodOf: (Array with: aCodeString) do: [:aNode :answer |  answer           remove: self currentSelector ifAbsent: [ self error: 'failed' ];           yourself ].  search answer: selectorCollection asBag.  (classSearches at: aClass ifAbsentPut: [ Set new ]) add: searchdefaultLabel  | stream |  stream := String new writeStream.  categories do: [:each |  stream           nextPutAll: each;           nextPut: $  ].  ^stream contentstraitsDo: aBlock  self systemDictionary allTraitsDo: [:each |  (self includesClass: each) ifTrue: [ aBlock value: each ] ]shouldntWarn: aRefactoring  self shouldnt: [ self executeRefactoring: aRefactoring ] raise: RBRefactoringWarningallMetaClasses  | allMetaClasses |  allMetaClasses := OrderedCollection new: 4096.  self classesDo: [:each |  each isMeta ifTrue: [ allMetaClasses add: each instanceSide ] ].  ^allMetaClasses asArraysuperclass  ^superclass == LookupSuperclass ifTrue: [ model classFor: self realClass superclass ] ifFalse: [ superclass ]isEmpty  ^builder changes isEmptywithoutClasses: aListOfClasses  ^RBClassEnvironment onEnvironment: self classes: (self classes copyWithoutAll: aListOfClasses)buildMethodTitleSearch  self createMethodSearchWith: 'initialize | `@temps | `@.Stmts' selectors: #(#initialize) inClass: RBBasicLintRuleTestDatatestRefactoring  | transformation class |  transformation := (RBAddMethodTransformation sourceCode: 'foo									| temp bar |									bar := 5.									temp := bar * bar.									Transcript show: temp printString; cr.									^temp * temp' in: self changeMock name withProtocol: #accessing) transform.  transformation := (RBRenameTemporaryVariableTransformation model: transformation model rename: #temp to: #temp2 in: self changeMock name selector: #foo) asRefactoring transform.  self assert: transformation model changes changes size equals: 2.  class := transformation model classNamed: self changeMock name.  self assert: (class directlyDefinesMethod: #foo).  self assert: (class parseTreeFor: #foo) temporaries size equals: 2.  self assert: ((class parseTreeFor: #foo) temporaries anySatisfy: [:e |  e name = #temp2 ])skip: aComment  TestSkip signal: aCommentlabel  ^label ifNil: [ self defaultLabel ] ifNotNil: [ label ]storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' messageSend: ''';     nextPutAll: message asString;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: aStream.  aStream nextPut: $)extractMethod  | refactoring |  refactoring := RBExtractMethodRefactoring model: self model extract: extractionInterval from: selector in: class.  refactoring setOption: #methodName toUse: [:ref :methodName |  extractedMethodSelector := ref uniqueMethodNameFor: methodName arguments size.        methodName           selector: extractedMethodSelector;           yourself ].  self performComponentRefactoring: refactoringstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' rename: ''';     nextPutAll: variableName;     nextPutAll: ''' to: ''';     nextPutAll: newName;     nextPutAll: ''' in: '.  class storeOn: aStream.  aStream nextPut: $)fullBlocks  ^[ thisContext ]whichSelectorsReferToClass: aRBClass  | selectors |  selectors := Set new.  newMethods ifNotNil: [ newMethods do: [:each |  (each refersToClassNamed: aRBClass name) ifTrue: [ selectors add: each selector ] ] ].  (self isDefined and: [ aRBClass isDefined ]) ifTrue: [ selectors addAll: (self existingMethodsThatReferTo: aRBClass classBinding).        selectors addAll: (self existingMethodsThatReferTo: aRBClass name) ].  ^selectorsdirectlyDefinesPoolDictionary: aString  ^self instanceSide directlyDefinesPoolDictionary: aStringprimitiveExecute  self changeClass category: category.  SystemAnnouncer uniqueInstance classReorganized: self changeClasstestNonExistantName  self shouldFail: (RBRemoveClassVariableRefactoring variable: #RecursiveSelfRule1 class: RBTransformationRuleTestData)testModelPushDownVariableToMultipleClassesInSameHierarchy  | class |  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  class := model classNamed: #Subclass.  class compile: 'foo ^Foo' classified: #(#accessing).  model defineClass: 'Subclass subclass: #AnotherSubclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  (model metaclassNamed: #AnotherSubclass) compile: 'bar ^Foo' classified: #(#accessing).  self executeRefactoring: (RBPushDownClassVariableRefactoring model: model variable: #Foo class: class superclass).  self deny: (class superclass directlyDefinesClassVariable: #Foo).  self assert: (class directlyDefinesClassVariable: #Foo)testRemoveMethod  | refactoring selectors |  selectors := Array with: 'msg4' asSymbol.  refactoring := RBRemoveHierarchyMethodRefactoring removeMethods: selectors from: RBSharedPoolForTestData.  self assert: ((refactoring model classNamed: #RBSharedPoolForTestData) directlyDefinesMethod: selectors first).  self assert: ((refactoring model classNamed: #RBSharedPoolForTestData1) directlyDefinesMethod: selectors first).  self assert: ((refactoring model classNamed: #RBSharedPoolForTestData2) directlyDefinesMethod: selectors first).  self executeRefactoring: refactoring.  self deny: ((refactoring model classNamed: #RBSharedPoolForTestData) directlyDefinesMethod: selectors first).  self deny: ((refactoring model classNamed: #RBSharedPoolForTestData1) directlyDefinesMethod: selectors first).  self deny: ((refactoring model classNamed: #RBSharedPoolForTestData2) directlyDefinesMethod: selectors first)resetResult  rules do: [:each |  each resetResult ]testProtocolEnvironment  | aProtocolEnvironment size |  aProtocolEnvironment := RBProtocolEnvironment onEnvironment: RBBrowserEnvironment new class: Object protocols: #(#printing #testing).  self universalTestFor: aProtocolEnvironment.  self assert: (aProtocolEnvironment implementorsOf: #printString) numberSelectors equals: 1.  size := 0.  aProtocolEnvironment classesDo: [:each |  size := size + 1 ].  self assert: size equals: 1.  aProtocolEnvironment selectorsForClass: Object do: [:each |  self assert: (#(#printing #testing) includes: (RBBrowserEnvironment new whichProtocolIncludes: each in: Object)) ]class: aClass selector: aSelector variable: aVariableName  class := self classObjectFor: aClass.  selector := aSelector.  temporaryVariableName := aVariableNamecheckReferencesToAnyOf: aSelectorCollection  | occurrences |  occurrences := OrderedCollection new.  aSelectorCollection do: [:each |  self model allReferencesTo: each do: [:aRBMethod |  (aSelectorCollection includes: aRBMethod selector) ifFalse: [ occurrences add: each -> aRBMethod ] ] ].  occurrences ifEmpty: [ ^self ].  ^self checkBrowseOccurrences: occurrencesstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' addClass: #';     nextPutAll: className;     nextPutAll: ' superclass: '.  superclass storeOn: aStream.  aStream nextPutAll: ' subclasses: '.  subclasses asArray storeOn: aStream.  aStream nextPutAll: ' category: '.  category storeOn: aStream.  aStream nextPut: $)includesClass: aClass  ^truebackpointersDictionary  ^PluggableDictionary new     equalBlock: [:a :b |  a class == b class and: [ a = b ] ];     hashBlock: [:a |  a class identityHash bitXor: a hash ];     yourselftempsReadBeforeWritten  | temp |  self isVariable ifTrue: [ temp := 4 ].  ^tempallClassesDo: aBlock  | classes instVarBlock |  classes := Set new.  instVarBlock := [:each |  | class |  class := self classForName: each.  classes addAll: class withAllSubclasses ].  instanceVariables keysDo: instVarBlock.  instanceVariableReaders keysDo: instVarBlock.  instanceVariableWriters keysDo: instVarBlock.  classVariables keysDo: [:each |  | class |        class := self classForName: each.        class notNil ifTrue: [ classes                 addAll: class withAllSubclasses;                 addAll: class class withAllSubclasses ] ].  classes do: aBlocktoDoWithIncrement  | counter |  counter := 0.  1 to: 10 by: 2 do: [:i |  counter := counter + 2 ].  ^counteraddSelfReturn  inlineParseTree addSelfReturntestAlreadyExistingName  self shouldFail: (RBRenameClassVariableRefactoring rename: #RecursiveSelfRule to: self objectClassVariable in: RBTransformationRuleTestData)printOn: aStream  aStream     nextPutAll: self displayClassName;     nextPut: $ ;     nextPutAll: self changeSymbol;     nextPut: $ ;     print: self variable;     nextPut: $!storeStringFor: aBrowserEnvironment  | newEnvironment |  newEnvironment := Smalltalk compiler evaluate: aBrowserEnvironment storeString.  self assert: newEnvironment numberSelectors equals: aBrowserEnvironment numberSelectors.  self assert: (newEnvironment not & aBrowserEnvironment) numberSelectors equals: 0searchStrings: aCollection  searchStrings := aCollectiontestClassDoesNotExist  self shouldFail: (RBAddAssignmentTransformation variable: 'variable' value: '1 asString' inMethod: #methodBefore inClass: #RBAssignmentTransformationTest) asRefactoringcheckMethod: aMethod  renrakuRule class checksNode ifTrue: [ ^self byNodeCheckMethod: aMethod ].  renrakuRule class checksMethod ifFalse: [ ^self ].  renrakuRule check: aMethod forCritiquesDo: [:crit |  result addMethod: aMethod.        self addSearchStringFrom: crit in: aMethod definition.        ^self ]addInstanceVariable: variableName to: aClass  ^RBAddInstanceVariableChange add: variableName to: aClassmyConditions  allClassesDo: aBlock  | seen evalBlock |  seen := Set new.  evalBlock := [:each |  seen add: each first name.  aBlock     value: each first;     value: each last ].  newClasses do: evalBlock.  changedClasses do: evalBlock.  environment classesDo: [:each |  each isObsolete ifFalse: [ | class |              class := each instanceSide.              ((seen includes: class name) or: [ self hasRemoved: (self classNameFor: class) ]) ifFalse: [ (class := self classFor: each) ifNotNil: [ seen add: class name.                          aBlock                             value: class;                             value: class classSide ] ] ] ]addDependentSends  self     addDependent: #one;     addDependent: #tworemoveMethod: aSelector  self newMethods removeKey: aSelector ifAbsent: [  ].  model removeMethod: aSelector from: self.  self removedMethods add: aSelectorparseTreeRewriter  | rewriteRule oldString newString |  oldString := self buildSelectorString: oldSelector.  newString := self buildSelectorString: newSelector withPermuteMap: permutation.  rewriteRule := self hasPermutedArguments ifTrue: [ RBParseTreeRewriter new ] ifFalse: [ RBParseTreeRewriter replaceLiteral: oldSelector with: newSelector ].  rewriteRule replace: '``@object ' , oldString with: '``@object ' , newString.  ^rewriteRulefindOcurrencesInClasses  listToFindMatches do: [:aClass |  [ (self preconditionsOf: aClass) check.        self findOcurrencesIn: aClass methods ] on: Exception do: [:e |  e messageText isEmptyOrNil ifFalse: [ UIManager default alert: e messageText ] ] ]poolDictionaryNames  ^self privatePoolDictionaryNames copyjustSendsSuper: aSelector  | matcher parseTree superclass |  matcher := self parseTreeSearcherClass justSendsSuper.  parseTree := self definingClass parseTreeFor: aSelector.  (matcher executeTree: parseTree initialAnswer: false) ifFalse: [ ^false ].  parseTree lastIsReturn ifTrue: [ ^true ].  superclass := self definingClass superclass whichClassIncludesSelector: aSelector.  superclass ifNil: [ ^true ].  parseTree := superclass parseTreeFor: aSelector.  matcher := self parseTreeSearcherClass new.  matcher matches: '^``@object' do: [:aNode :answer |  answer           add: aNode value;           yourself ].  matcher executeTree: parseTree initialAnswer: Set new.  ^matcher answer allSatisfy: [:each |  each isVariable and: [ each name = 'self' ] ]methodFor: aSelector  ^self newMethods at: aSelector ifAbsent: [ | compiledMethod class |        (self hasRemoved: aSelector) ifTrue: [ ^nil ].        class := self realClass.        class ifNil: [ ^nil ].        compiledMethod := class compiledMethodAt: aSelector ifAbsent: [ nil ].        compiledMethod ifNil: [ nil ] ifNotNil: [ modelFactory rbMethod for: self fromMethod: compiledMethod andSelector: aSelector ] ]testInlineMethod2  | refactoring |  refactoring := RBInlineMethodRefactoring inline: (40 to: 120) inMethod: #caller1 forClass: RBRefactoryTestDataApp.  self setupInlineExpressionFor: refactoring toReturn: false.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #caller1) equals: (self parseMethod: 'caller1 								| anObject each1 anObject1 | 								anObject := 5.								anObject1 := anObject + 1.								each1 := anObject1 printString.								Transcript									show: each1;									cr.								[:each | each printString. ^anObject] value: each1')selector: aSelector in: aClass classified: aProtocol  self flag: #todo.  ^self addChange: (RBMethodProtocolChange selector: aSelector in: aClass classified: aProtocol)name  ^nameaddSuperclass  self performComponentRefactoring: (RBAddClassRefactoring model: self model addClass: className superclass: parent superclass subclasses: (Array with: parent) category: parent category)unclassifiedMethods  contains  ^((1 to: 10) detect: [:each |  each > 2 ] ifNone: [ nil ]) isNiltestTransform  | transformation newClass superclass |  transformation := (RBAddClassTransformation addClass: self changeMock name , 'Temporary' superclass: #Object subclasses: OrderedCollection new category: self class category) transform.  self assert: transformation model changes changes size equals: 1.  newClass := transformation model classNamed: (self changeMock name , 'Temporary') asSymbol.  superclass := transformation model classNamed: #Object.  self assert: newClass superclass equals: superclass.  self assert: (superclass subclasses includes: newClass).  self assert: newClass theMetaClass superclass equals: superclass theMetaClass.  self assert: (superclass theMetaClass subclasses includes: newClass theMetaClass)testNotUnderstandSelector  self shouldFail: (RBReplaceMethodRefactoring replaceCallMethod: #checkClass123: in: RBBasicLintRuleTestData to: #checkMethod: permutation: (1 to: 1))undoChange  ^undo poptestInlineMethodForSuperSendThatAlsoSendsSuper  | refactoring |  model := Smalltalk compiler evaluate: self inlineMethodTestData.  refactoring := RBInlineMethodRefactoring inline: (102 to: 131) inMethod: #executeNotifying: forClass: (model classNamed: #RBRenameInstanceVariableChange).  self shouldFail: refactoringstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' code: ''';     nextPutAll: sourceCode;     nextPutAll: ''' from: ''';     nextPutAll: selector;     nextPutAll: ''' in: '.  class storeOn: aStream.  aStream nextPut: $)abstractVariablesIn: aBRProgramNode from: fromBehavior toAll: behaviorCollection ignoring: aVariableName  | poolRefactoring |  tree := aBRProgramNode.  fromClass := self classObjectFor: fromBehavior.  toClasses := behaviorCollection collect: [:each |  self classObjectFor: each ].  ignore := aVariableName.  poolRefactoring := RBExpandReferencedPoolsRefactoring model: self model forMethod: tree fromClass: fromClass toClasses: toClasses.  self performComponentRefactoring: poolRefactoring.  self computeVariablesToAbstractcreateAccessors  self performComponentRefactoring: self accessorsRefactoringcalculateIfReturnIsNeeded  | searcher |  searcher := RBParseTreeSearcher new.  searcher     matches: '^self' do: [:aNode :answer |  answer ];     matches: '^`@anything' do: [:aNode :answer |  true ].  ^searcher executeTree: subtree initialAnswer: falsetestTransform  | transformation |  transformation := (RBAddProtocolTransformation protocol: 'transforming' inClass: #RBDummyEmptyClass) transform.  transformation := (RBRemoveProtocolTransformation model: transformation model protocol: 'transforming' inClass: #RBDummyEmptyClass) transform.  self assert: transformation model changes changes size equals: 2name: aString  name := aStringtransform  definingNode removeTemporaryNamed: name.  blockNodes do: [:each |  each body addTemporaryNamed: name ].  class compileTree: parseTreemsg4  ^Var1isTransformationRule  ^falsecomparingCollectionBetween: left and: right  | additionalLeft additionalRight sortBlock |  sortBlock := [:a :b |  a asString <= b asString ].  additionalLeft := (left difference: right) sorted: sortBlock.  additionalRight := (right difference: left) sorted: sortBlock.  ^String streamContents: [:stream |  stream           nextPutAll: 'Given Collections do not match. Got ';           lf;           tab;           nextPutAll: 'left := ';           print: left;           nextPut: $.;           lf;           nextPutAll: ' instead of ';           tab;           nextPutAll: ' right :=';           print: left;           nextPut: $.;           lf.        left size = right size ifFalse: [ stream                 nextPutAll: 'Collection size does not match: left=';                 print: left size;                 nextPutAll: ' vs. right=';                 print: right size;                 lf ].        additionalLeft isEmpty ifFalse: [ stream                 nextPutAll: 'Got ';                 print: additionalLeft size;                 nextPutAll: ' additional element(s) in the left collection: ';                 tab;                 print: additionalLeft ].        additionalRight isEmpty ifFalse: [ stream                 nextPutAll: 'Got ';                 print: additionalRight size;                 nextPutAll: ' additional element(s) in the right collection: ';                 tab;                 print: additionalRight ] ]isMeta  self subclassResponsibilityprintOn: aStream  aStream     nextPutAll: 'NOT ';     print: conditionshouldnt: aBlock raise: anExceptionalEvent description: aString  ^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) not description: aStringclassNamed: aSymbol  | class classes index |  aSymbol ifNil: [ ^nil ].  (self hasRemoved: aSymbol) ifTrue: [ ^nil ].  (newClasses includesKey: aSymbol) ifTrue: [ ^(newClasses at: aSymbol) first ].  (changedClasses includesKey: aSymbol) ifTrue: [ ^(changedClasses at: aSymbol) first ].  class := environment at: aSymbol ifAbsent: [ nil ].  (class isBehavior or: [ class isTrait ]) ifTrue: [ classes := self createNewClassFor: class.        ^class isMeta ifTrue: [ classes last ] ifFalse: [ classes first ] ].  index := aSymbol indexOfSubCollection: ' class' startingAt: 1 ifAbsent: [ ^nil ].  class := self classNamed: (aSymbol copyFrom: 1 to: index - 1) asSymbol.  ^class ifNil: [ nil ] ifNotNil: [ class classSide ]moveDefinition  | temp |  ^(self collect: [:each |  temp := each printString.        temp , temp ]) select: [:each |  temp := each size.        temp odd ]printOn: aStream  aStream     nextPutAll: self displayClassName;     nextPutAll: ' removeInstVarName: ';     print: self oldName;     nextPut: $!;     cr.  aStream     nextPutAll: self displayClassName;     nextPutAll: ' addInstVarName: ';     print: self newName;     nextPut: $!calculateSubtree  ^subtree ifNil: [ subtree := self calculateTree ifNotNil: [ parseTree extractSubtreeWith: sourceCode ] ]renameChangesForClass: oldClassName to: newClassName  | change |  change := super renameChangesForClass: oldClassName to: newClassName.  oldName asSymbol = oldClassName ifTrue: [ change rename: newClassName to: newName ].  ^changeyourselfNotUsed  self     printString;     printString;     yourselfcalculateTemporariesToRemove  | newParseTree |  newParseTree := parseTree copy removeSubtree: subtree.  ^newParseTree allDefinedVariables reject: [:var |  newParseTree references: var ]asSelectorEnvironment  ^selftestTransform  | transformation class |  transformation := (RBAddClassCommentTransformation comment: 'New comment for class' in: self changeMock name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self changeMock name.  self assert: class comment equals: 'New comment for class'createClasses  mode := #create:name:executeNotifying: aBlock  | undos |  self changeClass rename: newName.  undos := changes collect: [:each |  (each renameChangesForClass: oldName asSymbol to: newName asSymbol) executeNotifying: aBlock ].  ^self copy     changes: undos reverse;     rename: newName to: oldName;     yourselfbuildTransformations  blockNodes ifNil: [ self checkMethodForBlocks ].  ^(OrderedCollection withAll: ((blockNodes sorted: [:a :b |  a start > b start ]) collect: [:blockNode |  RBAddTemporaryVariableTransformation variable: variableName inInterval: blockNode body sourceInterval inMethod: selector inClass: class ]))     add: (RBRemoveTemporaryVariableTransformation variable: variableName inMethod: selector inClass: class);     yourselfremoveClass: aClass instanceVariableReader: aString  | vars |  vars := instanceVariableReaders at: aClass name ifAbsent: [ Set new ].  vars remove: aString ifAbsent: [  ].  vars ifEmpty: [ instanceVariableReaders removeKey: aClass name ifAbsent: [  ] ].  self flushCachesFor: aClasspackageOrganizer  ^RPackageOrganizer defaultpreconditions  ^(RBCondition definesSelector: selector in: self definingClass) & (RBCondition withBlock: [ self checkSuperMethods.              true ])name  ^rewriteRule1abstractInstanceVariables  | variables |  (instVarReaders isEmpty and: [ instVarWriters isEmpty ]) ifTrue: [ ^self ].  variables := Set new.  variables     addAll: instVarReaders;     addAll: instVarWriters.  variables do: [:each |  self abstractInstanceVariable: each ]testTransform  | transformation class |  transformation := (RBAddAssignmentTransformation new variable: 'variable' value: '1 asString' inMethod: #methodBefore inClass: self class name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self class name.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) bodyinlineComponent  | a |  a := 5.  ^a class     superclass;     hasImmediateInstances;     yourselfremoveClass: aClass  ^self addChange: (changeFactory removeClassNamed: aClass name)rootEnvironment  ^environment rootEnvironmenttestReferencesPrintOnAfterAddition  | hasFoundObject hasFoundSelf smalltalk |  hasFoundObject := false.  hasFoundSelf := false.  smalltalk := modelFactory rbNamespace new.  (smalltalk classNamed: #Object) compile: 'someTestReference self printOn: nil' classified: #(testing).  (smalltalk classNamed: self class name) compile: 'someTestReference ^ #printOn:' classified: #(testing).  smalltalk allReferencesTo: #printOn: do: [:each |  hasFoundObject := hasFoundObject or: [ each selector = #someTestReference and: [ each modelClass = (smalltalk classNamed: #Object) ] ].        hasFoundSelf := hasFoundSelf or: [ each selector = #someTestReference and: [ each modelClass = (smalltalk classNamed: self class name) ] ] ].  self assert: hasFoundObject.  self assert: hasFoundSelfchangeClass: aBehavior  super changeClass: aBehavior.  isMeta := falsetestTransform  | transformation class |  transformation := (RBRemoveMethodTransformation selector: #one from: self changeMock name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self changeMock name asSymbol.  self deny: (class directlyDefinesMethod: #one)printOn: aStream  aStream nextPutAll: self displayStringcompiledMethod  ^compiledMethod notNil ifTrue: [ compiledMethod ] ifFalse: [ compiledMethod := class compiledMethodAt: selector ]transform  self model     defineClass: ('<1p> subclass: #<2s> instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: <3p>' expandMacrosWith: superclass with: className with: category asString);     reparentClasses: subclasses to: (self model classNamed: className asSymbol)changeSymbol  ^#addClassVarNamed:someOtherDemoMethod  | temp |  temp := self new.  ^temp junkcheckLocationsIn: candidateBlocks  (candidateBlocks detect: [:each |  RBReadBeforeWrittenTester isVariable: variableName readBeforeWrittenIn: each ] ifNone: [ nil ]) notNil ifTrue: [ ^false ].  blockNodes ifNil: [ blockNodes := OrderedCollection new ].  candidateBlocks do: [:each |  (self checkBlocksIn: each body) ifTrue: [ blockNodes add: each ] ifFalse: [ (self checkLocationsIn: (self checkAllBlocksIn: each body)) ifFalse: [ blockNodes add: each ] ] ].  ^trueaddParameterToMethod: aSelector in: aClass newSelector: newSel initializer: init  self renameMethod: aSelector in: aClass to: newSel permutation: (1 to: newSel numArgs).  initializer := inittransform  | protocol deprecatedSource |  protocol := (class methodFor: newSelector) protocols.  deprecatedSource := self formOldName , String cr , String tab , 'self 		deprecated: ''Use ' , newSelector asString , ' instead''		on: 	''' , Date today asString , ''' 		in: ''' , SystemVersion current imageVersionString , '''.	^ self ' , self formNewName.  (model classNamed: class realClass name) compile: deprecatedSource classified: protocolprivateImplementorsOf: aSelector  | classes |  classes := Set new.  self allClassesDo: [:class |  (class directlyDefinesLocalMethod: aSelector) ifTrue: [ classes add: class ].        (class classSide directlyDefinesLocalMethod: aSelector) ifTrue: [ classes add: class classSide ] ].  ^classesprintOn: aStream  aStream nextPutAll: self namenewNameForSelf  | variableName index originalName nonMetaClass |  nonMetaClass := inlineClass instanceSide.  variableName := originalName := (nonMetaClass name first isVowel ifTrue: [ 'an' ] ifFalse: [ 'a' ]) , nonMetaClass name.  index := 1.  [ variableName := self safeVariableNameBasedOn: variableName.  inlineParseTree allDefinedVariables includes: variableName ] whileTrue: [ variableName := originalName , index printString.        index := index + 1 ].  ^variableNamevalidateRenameOf: oldName to: newName  self validateRenameNode: extractedParseTree withOldName: oldName toWithName: newNamecheckSpecialExtractions  | node |  node := self placeholderNode parent.  node ifNil: [ ^self ].  (node isAssignment and: [ node variable = self placeholderNode ]) ifTrue: [ self refactoringFailure: 'Cannot extract left hand side of an assignment' ].  node isCascade ifTrue: [ self refactoringError: 'Cannot extract first message of a cascaded message' ]collectSelectNotUsed  (1 to: 10) select: [:each |  each = 4 ]accept: aText notifying: aController  | compiler |  compiler := self changeClass ifNil: [ Object compiler ] ifNotNil: [:changeClass |  changeClass compiler ].  compiler     source: aText asString;     class: self changeClass;     requestor: aController;     failBlock: [ ^false ];     compile.  self class: self changeClass protocol: self protocol source: aText asString.  ^truetestTransform  | transformation class |  transformation := (RBRemoveVariableTransformation instanceVariable: 'instVar' class: self changeMock name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self changeMock name asSymbol.  self deny: (class directlyDefinesInstanceVariable: 'instVar')callFoo  ^self testFoo: 5typeFor: anObject  anObject isString ifTrue: [ ^String ].  anObject isInteger ifTrue: [ ^Integer ].  ^(anObject == true or: [ anObject == false ]) ifTrue: [ Boolean ] ifFalse: [ anObject class ]selectors: aList  selectors := aListcopyDictionary: aDictionary  | copy |  copy := Dictionary new: aDictionary size.  aDictionary keysAndValuesDo: [:key :value |  copy at: key put: value ].  ^copymethodBefore  | variable |  variable := 'String'.  variable := 1 asStringresetResult  builder := RBRefactoryChangeManager changeFactory compositeRefactoryChangemessages  ^(self parseTree sendNodes collect: [:node |  node selector ]) asSettestNonExistantSelector  self shouldFail: (RBExtractMethodToComponentRefactoring extract: (10 to: 20) from: #checkClass1: in: RBBasicLintRuleTestData)unaryAccessingMessageStatementMethodWithoutReturn  self valueprivateTransform  | parseTree |  parseTree := self definingClass parseTreeFor: selector.  parseTree ifNil: [ ^self ].  (parseTree extractSubtreeWith: sourceCode) ifNotNil: [:subtree |  parseTree removeSubtree: subtree.        self definingClass compileTree: parseTree ] ifNil: [ ^self ]oldName: aString  oldName := aStringenvironment: aBrowserEnvironment  environment := aBrowserEnvironmentselectorCache  ^selectorCache ifNil: [ selectorCache := Dictionary new ] ifNotNil: [ selectorCache ]testMoveMethodIntoInstanceVariable  | refactoring class |  self proceedThroughWarning: [ refactoring := RBMoveMethodRefactoring selector: #checkMethod: class: RBTransformationRuleTestData variable: 'rewriteRule'.        self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.        self setupVariableTypesFor: refactoring toReturn: (Array with: (refactoring model classNamed: #RBParseTreeRewriter)).        self setupMethodNameFor: refactoring toReturn: #foo:foo: withArguments: #('transformationRule' 'aSmalllintContext').        self executeRefactoring: refactoring ].  class := refactoring model classNamed: #RBTransformationRuleTestData.  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext rewriteRule foo: self foo: aSmalllintContext').  self assert: ((refactoring model classNamed: #RBParseTreeRewriter) parseTreeFor: #foo:foo:) equals: (self parseMethod: 'foo: transformationRule foo: aSmalllintContext	transformationRule class: aSmalllintContext selectedClass.	(self executeTree: aSmalllintContext parseTree) ifTrue: 			[(transformationRule class recursiveSelfRule executeTree: self tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: self tree printString						in: transformationRule class1						classified: aSmalllintContext protocols]]').  self assert: (class parseTreeFor: #class1) equals: (self parseMethod: 'class1 ^class').  self assert: (class parseTreeFor: #class:) equals: (self parseMethod: 'class: anObject class := anObject').  self assert: (class classSide parseTreeFor: #recursiveSelfRule:) equals: (self parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').  self assert: (class classSide parseTreeFor: #recursiveSelfRule) equals: (self parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').  self assert: (class parseTreeFor: #builder) equals: (self parseMethod: 'builder ^builder').  self assert: (class parseTreeFor: #builder:) equals: (self parseMethod: 'builder: anObject builder := anObject')testClassVariable  | refactoring class |  refactoring := (RBRenameVariableTransformation rename: #RecursiveSelfRule to: #RSR in: #RBTransformationRuleTestData classVariable: true) asRefactoring transform.  class := refactoring model classNamed: #RBTransformationRuleTestData.  self assert: (class directlyDefinesClassVariable: #RSR).  self deny: (class directlyDefinesClassVariable: #RecursiveSelfRule).  self assert: (class theMetaClass parseTreeFor: #initializeAfterLoad1) equals: (self parseMethod: 'initializeAfterLoad1					RSR := RBParseTreeSearcher new.					RSR addMethodSearches: #(''`@methodName: `@args | `@temps | self `@methodName: `@args'' ''`@methodName: `@args | `@temps | ^self `@methodName: `@args'')						-> [:aNode :answer | true]').  self assert: (class theMetaClass parseTreeFor: #nuke) equals: (self parseMethod: 'nuke RSR := nil').  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 					class := aSmalllintContext selectedClass.					(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 						[(RSR executeTree: rewriteRule tree initialAnswer: false)						ifFalse: [builder compile: rewriteRule tree printString										in: class										classified: aSmalllintContext protocols]]')insertInlinedMethod  | node |  node := sourceMessage.  self moveComments.  node parent isCascade ifTrue: [ self rewriteCascadedMessage.        node := node parent ].  node parent isReturn ifTrue: [ node := node parent ] ifFalse: [ self removeReturns ].  self replaceArguments.  self inlineSourceReplacing: node.  sourceParseTree removeDeadCode.  self removeEmptyIfTrues.  self removeImmediateBlockstestMoveMethodIntoClassVariable  | refactoring class |  self proceedThroughWarning: [ refactoring := RBMoveMethodRefactoring selector: #checkMethod: class: RBTransformationRuleTestData variable: 'RecursiveSelfRule'.        self setupSelfArgumentNameFor: refactoring toReturn: 'transformationRule'.        self setupVariableTypesFor: refactoring toReturn: (Array with: (refactoring model classNamed: #RBParseTreeSearcher)).        self setupMethodNameFor: refactoring toReturn: #foo:foo: withArguments: #('transformationRule' 'aSmalllintContext').        self executeRefactoring: refactoring ].  class := refactoring model classNamed: #RBTransformationRuleTestData.  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext RecursiveSelfRule foo: self foo: aSmalllintContext').  self assert: ((refactoring model classNamed: #RBParseTreeSearcher) parseTreeFor: #foo:foo:) equals: (self parseMethod: 'foo: transformationRule foo: aSmalllintContext	transformationRule class: aSmalllintContext selectedClass.	(transformationRule rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 			[(self executeTree: transformationRule rewriteRule tree initialAnswer: false)				ifFalse: 					[transformationRule builder compile: transformationRule rewriteRule tree printString						in: transformationRule class1						classified: aSmalllintContext protocols]]').  self assert: (class parseTreeFor: #class1) equals: (self parseMethod: 'class1 ^class').  self assert: (class parseTreeFor: #class:) equals: (self parseMethod: 'class: anObject class := anObject').  self assert: (class parseTreeFor: #builder) equals: (self parseMethod: 'builder ^builder').  self assert: (class parseTreeFor: #builder:) equals: (self parseMethod: 'builder: anObject builder := anObject').  self assert: (class parseTreeFor: #rewriteRule) equals: (self parseMethod: 'rewriteRule ^rewriteRule').  self assert: (class parseTreeFor: #rewriteRule:) equals: (self parseMethod: 'rewriteRule: anObject rewriteRule := anObject')method: aMethod  method := aMethod.  class := method originpostCopy  super postCopy.  changes := changes collect: [:each |  each copy ]checkClass: aSmalllintContext  ^classBlock value: aSmalllintContext value: resulttestExtractFailure  | transformation |  transformation := (RBRemoveSubtreeTransformation code: ':= anInterval' from: #one in: self changeMock name) transform.  self assertEmpty: transformation model changes changes.  self shouldFail: (RBRemoveSubtreeTransformation code: ':= aSelector' from: #selector:from: in: #RBRemoveMethodTransformation) asRefactoringtestNonExistantSelector  self shouldFail: (RBExtractMethodRefactoring extract: (10 to: 20) from: #checkClass1: in: RBBasicLintRuleTestData)testExtractFailure  self     shouldFail: (RBExtractMethodToComponentRefactoring extract: (80 to: 269) from: #subclassOf:overrides: in: RBBasicLintRuleTestData class);     shouldFail: (RBExtractMethodToComponentRefactoring extract: (53 to: 56) from: #subclassOf:overrides: in: RBBasicLintRuleTestData class);     shouldFail: (RBExtractMethodToComponentRefactoring extract: (77 to: 222) from: #subclassResponsibilityNotDefined in: RBBasicLintRuleTestData class)redoChange  ^redo lasttypesFor: variableName in: aParseTree model: aRBSmalltalk  | searcher messages |  searcher := self parseTreeSearcher.  searcher matches: variableName , ' `@message: ``@args' do: [:aNode :answer |  answer           add: aNode selector;           yourself ].  messages := searcher executeTree: aParseTree initialAnswer: Set new.  ^self     model: aRBSmalltalk;     findTypeFor: messages;     yourselfbyNodeCheckMethod: aMethod  aMethod ast nodesDo: [:node |  renrakuRule check: node forCritiquesDo: [:crit |  result addMethod: aMethod.              self addSearchStringFrom: crit in: aMethod definition.              ^self ] ]hierarchyDefinesClassVariable: aString  (self definesClassVariable: aString) ifTrue: [ ^true ].  ^self allSubclasses anySatisfy: [:each |  each directlyDefinesClassVariable: aString ]changeString  ^'Comment ' , self displayClassNameremoveRenamedImplementors  oldSelector = newSelector ifTrue: [ ^self ].  self implementors do: [:each |  each removeMethod: oldSelector ]shouldWarn: aRefactoring  self should: [ self executeRefactoring: aRefactoring ] raise: RBRefactoringWarningchanges  ^rules flatCollect: [:each |  each changes ]includesCategory: aCategory  ^(super includesCategory: aCategory) and: [ (self classNamesFor: aCategory) anySatisfy: [:className |  (classSelectors includesKey: className) or: [ metaClassSelectors includesKey: className ] ] ]whileTrue  | i |  i := 1.  [ i < self size ] whileTrue: [ (self at: i) printString.        i := i + 1 ]reparentSubclasses  classNames do: [:each |  | class |        class := self model classNamed: each.        self model reparentClasses: class subclasses copy to: class superclass ]parameterMap: aDictionary  parameterMap := aDictionaryselector  ^self methodName ifNotNil: [:method |  method selector ]includesClass: aClass  ^(super includesClass: aClass) and: [ self packages anySatisfy: [:package |  (package includesClass: aClass) or: [ (package extensionCategoriesForClass: aClass) notEmpty ] ] ]testTransform  | transformation class |  transformation := (RBAddVariableTransformation instanceVariable: 'asdf' class: self changeMock name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self changeMock name asSymbol.  self assert: (class directlyDefinesInstanceVariable: 'asdf')problemCount  ^rules inject: 0 into: [:count :each |  count + each problemCount ]allBehaviorsDo: aBlock  | seen evalBlock |  seen := Set new.  evalBlock := [:each |  seen add: each first name.  aBlock     value: each first;     value: each last ].  newClasses do: evalBlock.  changedClasses do: evalBlock.  environment classesDo: [:each |  each isObsolete ifFalse: [ | class |              class := each instanceSide.              ((seen includes: class name) or: [ self hasRemoved: (self classNameFor: class) ]) ifFalse: [ (class := self classFor: each) ifNotNil: [ seen add: class name.                          aBlock                             value: class;                             value: class classSide ] ] ] ]protocols: aCollectionOrString  protocols := aCollectionOrString isString ifTrue: [ aCollectionOrString = Protocol unclassified ifTrue: [ protocols := #(accessing) ] ifFalse: [ Array with: aCollectionOrString ] ] ifFalse: [ aCollectionOrString ]theNonMetaClass  ^selfcompile: aString classified: aSymbolCollection  | change method |  change := model compile: aString in: self classified: aSymbolCollection.  method := modelFactory rbMethod for: self source: aString selector: change selector.  self addMethod: method.  ^changetestMethodDoesNotExist  self shouldFail: (RBReplaceSubtreeTransformation replace: 'selector := aSelector' to: '^ selector' inMethod: #selector:for: inClass: #RBRemoveMethodTransformation) asRefactoringwriteGuardClauses  | rewriter |  rewriter := RBParseTreeRewriter new.  rewriter     replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2. ^`@r2' with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1] ifFalse: [`@.s2. ^`@r2]';     replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2. ^`@r2' with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [`@.s2. ^`@r2] ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]';     replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2' with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [| `@t1 | `@.Stmts1. ^`@r1] ifFalse: [`@.s2. ^self]';     replaceMethod: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]. `@.s2' with: '`@methodName: `@args | `@temps | `@.s1. `@boolean ifTrue: [`@.s2. ^self] ifFalse: [| `@t1 | `@.Stmts1. ^`@r1]'.  [ rewriter executeTree: inlineParseTree ] whileTrue: [ inlineParseTree := rewriter tree ]method  ^class realClass >> selectorremoveClass: aClass into: aValue  (environmentDictionaries at: aValue ifAbsent: [ RBSelectorEnvironment new ]) removeClass: aClasspreconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition withBlock: [ self buildParseTree.              self checkForPrimitiveMethod.              self checkForSuperReferences.              self checkAssignmentsToVariable.              self getClassesToMoveTo.              self getArgumentNameForSelf.              self checkTemporaryVariableNames.              self getNewMethodName.              true ])checkClass: aClass  (environment includesClass: aClass) ifTrue: [ rule checkClass: aClass ]class: aClass protocol: aProtocol source: aString controller: aController  self changeClass: aClass.  self protocols: aProtocol.  source := aString.  controller := aControllerenvironment: aBrowserEnvironment  environment := aBrowserEnvironmenttargetClass  ^classstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' renameTemporary: ';     nextPutAll: variableName;     nextPutAll: ' to: ''';     nextPutAll: newVariableName;     nextPutAll: ''' in: '.  class storeOn: aStream.  aStream     nextPutAll: ' selector: #';     nextPutAll: selector.  aStream nextPut: $)transform  self     insertTemporary;     compileNewMethodshould: aBlock raise: anExceptionalEvent description: aString  ^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent) description: aStringundoPointers  ^undoPointerstestWithTemporaryVariable  | refactoring class |  refactoring := (RBExtractMethodTransformation extract: (self sourceCodeAt: (22 to: 280) forMethod: #superSends in: RBTransformationRuleTestData) from: #superSends to: #foo1 in: #RBTransformationRuleTestData) asRefactoring transform.  self assert: refactoring model changes changes size equals: 2.  class := refactoring model classNamed: #RBTransformationRuleTestData.  self assert: (class parseTreeFor: #superSends) equals: (self parseMethod: 'superSends				| rule |				rule := self foo1.				self rewriteUsing: rule').  self assert: (class parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 | rule |				rule := RBParseTreeRewriter new.				rule addSearch: ''super `@message: ``@args''					-> ([:aNode | 					(class withAllSubclasses						detect: [:each | each includesSelector: aNode selector]						ifNone: [nil]) isNil]							-> ''self `@message: ``@args'').				^rule')badMessage  self become: String newtestPerformChangeMethod  | change source |  change := changes compile: 'one ^ 2' in: self changeMock.  source := change changeClass sourceCodeAt: #one.  self perform: change do: [ self assert: (change changeClass sourceCodeAt: #one) equals: 'one ^ 2' ].  self assert: (change changeClass sourceCodeAt: #one) equals: sourcetestCommentChange  | st cl |  st := modelFactory rbNamespace new.  cl := st classNamed: self class name.  self assert: cl comment isString.  cl comment: 'a comment'.  self assert: cl comment equals: 'a comment'.  self assert: st changes changes size equals: 1.  self assert: st changes changes first comment equals: 'a comment'.  cl comment: nil.  self assert: cl comment isNil.  self assert: st changes changes size equals: 2.  self assert: st changes changes last comment isNildirectlyDefinesLocalMethod: aSelector  self isDefined ifTrue: [ (self hasRemoved: aSelector) ifTrue: [ ^false ].        (self realClass includesLocalSelector: aSelector) ifTrue: [ ^true ] ].  ^newMethods notNil and: [ newMethods includesKey: aSelector ]asEpiceaEvent  ^EpRenameClassRefactoring rename: className to: newNamechangeMock  ^testingEnvironment at: #RBRefactoringChangeMockvariable: aVariableName class: aClassName classVariable: aBoolean  variableName := aVariableName.  isClassVariable := aBoolean.  className := aClassNameparseTree  parseTree ifNil: [ parseTree := class parseTreeFor: selector.        parseTree ifNil: [ self refactoringFailure: 'Could not parse sources' ] ].  ^parseTreewhatToDisplayIn: aBrowser  ^self changes flatCollect: [:each |  each whatToDisplayIn: aBrowser ]isResumable  ^falsevariable: aVariableName inInterval: anInterval inMethod: aSelector inClass: aClass  self className: aClass.  interval := anInterval.  selector := aSelector.  variableName := aVariableNameparseTree  parseTree ifNil: [ parseTree := class parseTreeFor: selector.        parseTree ifNil: [ self refactoringFailure: 'Could not parse sources' ] ].  ^parseTreeinitialize  super initialize.  classes := IdentitySet new.  metaClasses := IdentitySet newcheckMethod: aSmalllintContext  systemDictionary  ^environment systemDictionaryselectors  literalSemaphore ifNil: [ selectors ifNil: [ self computeLiterals.              literalSemaphore wait ] ] ifNotNil: [ literalSemaphore wait ].  ^selectorspackages: aCollection  packages addAll: aCollectionoldClass: aClass  oldClass := self classObjectFor: aClasstestRefactoring  | refactoring class |  refactoring := (RBRemovePragmaTransformation pragma: '<gtInspectorPresentationOrder: 34>' inMethod: #methodBefore inClass: #RBRemovePragmaTransformationTest) asRefactoring transform.  self assert: refactoring model changes changes size equals: 1.  class := refactoring model classNamed: #RBRemovePragmaTransformationTest.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) bodyallPoolDictionaryNames  ^self subclassResponsibilitymodifyImplementorParseTree: parseTree in: aClass  | name newArg allTempVars |  allTempVars := parseTree allDefinedVariables.  name := self safeVariableNameFor: aClass temporaries: allTempVars.  newArg := RBVariableNode named: name.  parseTree renameSelector: newSelector andArguments: parseTree arguments , (Array with: newArg)justSendsSuper  super justSendsSupertransform  self shouldFixSubclasses ifTrue: [ self renameSuperclassOfSubclasses ].  self renameReferences.  self shouldCopyExtensions ifTrue: [ self copyExtensionMethods ].  self shouldRemoveExtensions ifTrue: [ self removeExtensionMethods ]environment  ^environmentstringTestFor: aChange  self assert: (aChange name isString and: [ aChange name notEmpty ]).  self assert: (aChange printString isString and: [ aChange printString notEmpty ]).  self assert: (aChange changeString isString and: [ aChange changeString notEmpty ]).  self assert: (aChange displayString isString and: [ aChange displayString notEmpty ])testClassDoesNotExist  self shouldFail: (RBAddTemporaryVariableTransformation variable: 'variable2' inMethod: #methodBefore inClass: #RBReturnStatementTransformationTest) asRefactoringoldProtocol  | oldProtocol |  oldProtocol := RBBrowserEnvironment new whichProtocolIncludes: self selector in: self changeClass.  ^oldProtocol ifNil: [ oldProtocol := #accessing ]transform  | method |  method := self parserClass parseMethod: 'printOn: aStream		"Append a sequence of characters to aStream that identify the receiver."				super printOn: aStream'.  variables do: [:each |  method body addNode: (self parserClass parseExpression: ('aStream nextPutAll: '' <1s>: ''; print: <1s>' expandMacrosWith: each)) ].  self theClass compile: method formattedCode classified: #(printing)testClassDoesNotExist  self shouldFail: (RBMethodProtocolTransformation protocol: 'empty protocol 2' inMethod: #someMethod inClass: #RBDummyEmptyClass123) asRefactoringinstanceSideExtensionMethodsOf: anRBClass  ^anRBClass realClass instanceSide localMethods select: #isExtension thenCollect: [:each |  anRBClass instanceSide methodFor: each selector ]transform  self compileHash.  self compileEqualnumberSelectorsFor: aBrowserEnvironment  | numberSelectors numberSelectorsNot |  numberSelectors := aBrowserEnvironment numberSelectors.  numberSelectorsNot := aBrowserEnvironment not numberSelectors.  self assert: numberSelectors + numberSelectorsNot equals: universalEnvironment numberSelectors.  self assert: (aBrowserEnvironment & aBrowserEnvironment not) numberSelectors equals: 0.  self assert: (universalEnvironment & aBrowserEnvironment) numberSelectors equals: numberSelectors.  self assert: (aBrowserEnvironment & universalEnvironment) numberSelectors equals: numberSelectorscomparingIdentityStringBetween: actual and: expected  ^String streamContents: [:stream |  stream           nextPutAll: actual fullPrintString;           nextPutAll: ' is not identical to ';           nextPutAll: expected fullPrintString;           nextPutAll: '.' ]transform  self hasVariablesToAbstract ifTrue: [ self refactoringWarning: 'This method has direct variable references which<n>will need to be converted to getter/setters.' expandMacros ].  self abstractInstanceVariables.  self abstractClassVariablesprivateRootClasses  | classes |  classes := OrderedCollection new.  Class rootsOfTheWorld do: [:each |  | class |        class := self classFor: each.        (class notNil and: [ class superclass isNil ]) ifTrue: [ classes add: class ] ].  ^classesrbMethod  ^self class rbMethodcheckPackage: aPackage  renrakuRule class checksPackage ifFalse: [ ^self ].  renrakuRule check: aPackage forCritiquesDo: [:crit |  ^result addPackage: aPackage ]formNewName  ^self formNameFor: newSelectortestAddPool  | change |  change := changes addPool: 'PoolDict' to: self class.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self assert: change variable equals: 'PoolDict'.  self universalTestFor: changelongMacro  ^'(' , left errorMacro , ') <1?AND:OR> (' , right errorMacro , ')'atIfAbsent  ^Smalltalk at: #MyTest ifAbsent: [ | collection |        collection := #().        Smalltalk at: #MyTest put: collection ]printTypeFor: aString on: aStream  | types |  types := (self guessTypesFor: aString) asSortedCollection: [:a :b |  a name < b name ].  1 to: types size do: [:i |  i == 1 ifFalse: [ aStream nextPutAll: ' | ' ].        self printType: (types at: i) for: aString on: aStream ]name  self subclassResponsibilityinlineParameterMethod: aSymbol  ^aSymbol isSymbolenvironment  ^environmentclassName: anObject  className := anObjectrequestSelectors  ^(self options at: #selectorsFromView) value: selfassertCollection: actual hasSameElements: expected  | missingElements additionalElements |  additionalElements := actual difference: expected.  missingElements := expected difference: (actual intersection: expected).  self assert: (additionalElements isEmpty and: [ missingElements isEmpty ]) description: (String streamContents: [:stream |  stream                 nextPutAll: 'Given Collections do not match!';                 lf;                 tab;                 nextPutAll: 'additions : ';                 print: additionalElements asArray;                 lf;                 tab;                 nextPutAll: 'missing: ';                 print: missingElements asArray;                 lf ])hash  ^self species identityHashextraBlock  ^[:arg |  arg + 43 ] value: 45theNonMetaClass  ^selfundoTestFor: aChange  | undo |  undo := aChange asUndoOperation.  self assert: (undo isKindOf: RBRefactoryChange)assert: aBooleanOrBlock description: aStringOrBlock  aBooleanOrBlock value ifFalse: [ | message |        message := aStringOrBlock value.        self classForTestResult failure signal: message ]checkMethodName: aName in: aClass  ^RBCondition checkMethodName: aName in: aClassmethodBlock: aBlock  methodBlock := aBlockcomputeMessagesSentToVariables  | searcher |  variableMessages := Dictionary new.  class instanceVariableNames do: [:each |  variableMessages at: each put: Set new ].  searcher := self parseTreeSearcher.  class instanceVariableNames do: [:each |  | block |        block := [:aNode :answer |  (variableMessages at: each ifAbsentPut: [ Set new ]) add: aNode selector.        self processCollectionMessagesFor: each in: aNode ].        searcher matches: each , ' `@messageName: ``@args' do: block.        (backpointers at: each) do: [:sel |  sel isSymbol ifTrue: [ searcher matches: ('(self <1s>) `@messageName: ``@args' expandMacrosWith: (self parseTreeSearcherClass buildSelectorString: sel)) asString do: block ] ] ].  searcher answer: variableMessages.  self executeSearch: searcherunexpectedEqualityStringBetween: actual and: expected  ^String streamContents: [:stream |  stream           nextPutAll: 'Unexpected equality of ';           nextPutAll: actual fullPrintString;           nextPutAll: ' and ';           nextPutAll: expected fullPrintString;           nextPutAll: '.' ]testModelRecursiveMethodThatIsNotReferencedFromOtherMethods  | class otherClass |  class := model classNamed: #Object.  class compile: 'someMethodThatIsNotReferenced ^2' classified: #(#accessing).  self assert: (class definesMethod: #someMethodThatIsNotReferenced).  otherClass := model metaclassNamed: self class superclass name.  otherClass compile: 'someMethodThatIsNotReferenced ^3 someMethodThatIsNotReferenced' classified: #(#accessing).  model removeClassNamed: self class name.  self executeRefactoring: (RBRemoveMethodRefactoring model: model removeMethods: #(#someMethodThatIsNotReferenced) from: class).  self deny: (class definesMethod: #someMethodThatIsNotReferenced)traits  | traits |  traits := IdentitySet new: 4096.  self traitsDo: [:each |  traits add: each ].  ^traitsprivateTransform  oldCategory := self definingClass category.  self definingClass category: category.  self model category: category for: self definingClasscreateAccessors  self performComponentRefactoring: self accessorsRefactoringnewMethods  ^newMethods ifNil: [ newMethods := IdentityDictionary new ] ifNotNil: [ newMethods ]allReferencesTo: aSymbol  ^sendersCache at: aSymbol ifAbsentPut: [ self privateReferencesTo: aSymbol ]viewResults  result openEditormodel: aRBSmalltalk  model := aRBSmalltalkchangeClassName: aSymbol  className := aSymbol.  isMeta ifNil: [ isMeta := false ]inlineClass  ^inlineClass ifNil: [ inlineClass := (sourceMessage receiver name = 'super' ifTrue: [ class superclass ] ifFalse: [ class ]) whoDefinesMethod: self inlineSelector ] ifNotNil: [ inlineClass ]changeMock  ^testingEnvironment at: #RBRefactoringChangeMockinitialize  super initialize.  changes := changeFactory compositeRefactoryChange.  environment := RBBrowserEnvironment new.  newClasses := IdentityDictionary new.  changedClasses := IdentityDictionary new.  removedClasses := Set new.  implementorsCache := IdentityDictionary new.  sendersCache := IdentityDictionary newtestHierarchy  | meta |  meta := objectClass classSide.  self assert: (objectClass withAllSubclasses includes: meta).  self assert: (meta withAllSuperclasses includes: objectClass)testFindOcurrencesInOf  | refactoring |  refactoring := RBFindAndReplaceMethodRefactoring find: RBRefactoryTestDataApp >> #textInput:name:symbol:.  self assert: (refactoring findOcurrencesIn: #renderContentOn: of: RBRefactoryTestDataApp) size equals: 4methodAfter  | variable |  variable := 'String'defaultLabel  | stream |  stream := String new writeStream.  stream     nextPutAll: class name;     nextPut: $>.  protocols do: [:each |  stream           nextPutAll: each;           nextPut: $  ].  ^stream contentsclassName: aClassName newClassName: aNewClassName  className := aClassName.  newClassName := aNewClassNamecreateArgumentSearchWith: aCodeString selectors: selectorCollection inClass: aClass  | search |  search := self parseTreeSearcher.  search matchesAnyArgumentOf: (Array with: aCodeString) do: [:aNode :answer |  answer           remove: self currentSelector ifAbsent: [ self error: 'failed' ];           yourself ].  search answer: selectorCollection asBag.  (classSearches at: aClass ifAbsentPut: [ Set new ]) add: searchincludesSelector: aSelector in: aClass  ^(environment includesSelector: aSelector in: aClass) or: [ orEnvironment includesSelector: aSelector in: aClass ]result  | environment |  environment := RBParseTreeEnvironment new.  environment matcher: self rewriteRule.  environment label: self name.  self changes do: [:change |  (change isKindOf: RBAddMethodChange) ifTrue: [ environment addClass: change changeClass selector: change selector ] ].  ^environmentinlineJunk  | asdf |  asdf := self inlineFoo: [:each |  | temp |        temp := each.        temp , temp ].  ^asdf foo: [:bar |  | baz |        baz := bar.        baz * baz ]guardingClause  self isSymbol ifFalse: [ self printString.        self isSymbol printString ]compileTree: aBRMethodNode  | method sourceCode change |  sourceCode := aBRMethodNode newSource.  change := self modelClass model compile: sourceCode in: self modelClass classified: self protocols.  method := self class for: self modelClass source: sourceCode selector: aBRMethodNode selector.  self modelClass addMethod: method.  ^changetestMetaclassFailure  self shouldFail: (RBRenameVariableTransformation rename: #RecursiveSelfRule to: #Foo in: RBTransformationRuleTestData class classVariable: true) asRefactoringrules: aCollection  rules := aCollectionwhoDefinesClassVariable: aString  | sprClass |  (self directlyDefinesClassVariable: aString) ifTrue: [ ^self ].  sprClass := self superclass.  ^sprClass ifNil: [ nil ] ifNotNil: [ sprClass whoDefinesClassVariable: aString ]addSubclass: aRBClass  self subclasses add: aRBClassparseTreeSearcherClass  ^RBParseTreeSearcherpreconditions  class := self definingClass.  ^(RBCondition isValidClassName: newClassName) & (RBCondition isGlobal: newClassName in: self model) not & (RBCondition isValidInstanceVariableName: referenceVariableName for: class) & (RBCondition hierarchyOf: class definesVariable: referenceVariableName) not & (RBCondition isGlobal: referenceVariableName in: self model) not & (RBCondition definesTemporaryVariable: referenceVariableName in: class) notnot  self isSystem ifTrue: [ ^RBSelectorEnvironment new ].  ^RBNotEnvironment onEnvironment: selfcheckInstVars  class instanceVariableNames do: [:each |  (target instanceVariableNames includes: each) ifFalse: [ ((class whichSelectorsReferToInstanceVariable: each) includes: selector) ifTrue: [ self refactoringError: ('<1p> refers to <2s>, which is not defined in <3p>' expandMacrosWith: selector with: each with: target) ] ] ]privateTransform  | methodTree pragmaNode nodesToRemove |  methodTree := self definingMethod.  pragmaNode := self parserClass parsePragma: pragma.  nodesToRemove := (methodTree allChildren removeDuplicates select: #isPragma) select: [:node |  node selector = pragmaNode selector ].  nodesToRemove do: [:node |  node parent removePragma: node ].  self definingClass compileTree: methodTreepreconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: ('Class named <1s> does not exist' expandMacrosWith: className)) & (RBCondition withBlock: [ self definingClass canUnderstand: selector ] errorString: ('Method named <1s> does not exist' expandMacrosWith: selector)) & (RBCondition withBlock: [ | pragmaNode |              pragmaNode := self parserClass parsePragma: pragma.              self definingMethod pragmas anySatisfy: [:e |  e selector = pragmaNode selector ] ] errorString: ('Method named <1s> does not have a pragma named <2s>' expandMacrosWith: selector with: (self parserClass parsePragma: pragma) selector))addNewAccessors  | refactoring |  refactoring := RBCreateAccessorsForVariableRefactoring model: self variable: newName asString class: class classVariable: false.  refactoring     createGetterAccessor;     createSetterAccessorclassName: aClassName  className := aClassNametestExtractMethodThatMovesTemporaryVariable  | refactoring class |  refactoring := RBExtractMethodRefactoring extract: (22 to: 280) from: #superSends in: RBTransformationRuleTestData.  self setupMethodNameFor: refactoring toReturn: #foo1.  self executeRefactoring: refactoring.  class := refactoring model classNamed: #RBTransformationRuleTestData.  self assert: (class parseTreeFor: #superSends) equals: (self parseMethod: 'superSends	| rule |	rule := self foo1.	self rewriteUsing: rule').  self assert: (class parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 | rule | 	rule := RBParseTreeRewriter new.	rule addSearch: ''super `@message: ``@args''				-> (					[:aNode | 					(class withAllSubclasses						detect: [:each | each includesSelector: aNode selector]						ifNone: [nil]) isNil]							-> ''self `@message: ``@args'').		^rule')preconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: 'Class named ' , className , ' does not exist') & (RBCondition withBlock: [ (model environment protocolsFor: self definingClass realClass) includes: protocol ] errorString: 'Protocol named ' , protocol , ' does not exist') & (RBCondition withBlock: [ (self definingClass realClass organization protocolNamed: protocol) canBeRemoved ] errorString: 'Protocol named ' , protocol , ' is a virtual protocol and it cannot be removed') & (RBCondition withBlock: [ (self definingClass realClass organization protocolNamed: protocol) isEmpty ] errorString: 'Protocol named ' , protocol , ' is not empty and it cannot be removed')typesFor: anInstVarName in: aClass  class = aClass ifFalse: [ self runOn: aClass ].  ^variableTypes at: anInstVarName ifAbsent: [ Set new ]replaceSelfReferences  | replacer |  self needsToReplaceSelfReferences ifTrue: [ replacer := RBParseTreeRewriter new.        replacer replace: 'self' with: selfVariableName.        self hasOnlySelfReturns ifTrue: [ replacer replace: '^self' with: '^self' ].        replacer executeTree: parseTree.        parseTree := replacer tree ]classObjectFor: anObject  (anObject isBehavior or: [ anObject isTrait ]) ifTrue: [ ^self model classFor: anObject ].  anObject isSymbol ifTrue: [ ^self model classNamed: anObject ].  ^anObjecttestModelMetaclassAlreadyExistingName  | refactoring |  (model metaclassNamed: #Foo) addInstanceVariable: 'instVarName1'.  refactoring := RBAddInstanceVariableRefactoring model: model variable: 'instVarName1' class: (model classNamed: #Bar).  self shouldFail: refactoringdefinesClass: aClass  ^trueprimitiveExecute  ^self changeClass removeSelector: selectorremoveClass: aClass selector: aSelector into: aValue  (environmentDictionaries at: aValue ifAbsentPut: [ RBSelectorEnvironment new ]) removeClass: aClass selector: aSelectorcalled: anObject on1: aBlock  | each |  each := anObject printString.  self traceCr: each.  aBlock value: eachbuildStatementSearch  self createSearchWith: '| `@temps | ``@.Stmts1. ``.Stmt1. ``@.Stmts2. ``.Stmt2. ``@.Stmts3' selectors: #(#checkMethod: #rewriteUsing: #viewResults #superSends) inClass: RBTransformationRuleTestDatachangeString  ^'Remove instance variable <1s> from <2s>' expandMacrosWith: self variable with: self displayClassNameshould: aBlock raise: anExceptionalEvent  ^self assert: (self executeShould: aBlock inScopeOf: anExceptionalEvent)findOcurrencesIn: aList  aList do: [:aMethod |  positionIndex := 1.        [ self findAndReplaceOcurrencesIn: aMethod ] on: Exception do: [:e |  e messageText isEmptyOrNil ifFalse: [ UIManager default alert: e messageText ] ] ]classesAndSelectorsDo: aBlock  packages do: [:package |  package methods do: [:method |  (environment includesSelector: method selector in: method methodClass) ifTrue: [ aBlock value: method methodClass value: method selector ] ] ]parseTree  parseTree ifNil: [ parseTree := class parseTreeFor: selector.        parseTree ifNil: [ self refactoringFailure: 'Could not parse method' ] ].  ^parseTreeasUndoOperation  ^changeFactory addClassVariable: self variable to: self changeClassdefiningClass  ^self model classObjectFor: classNamemovePoolVariables  pools do: [:poolDict |  toClasses do: [:each |  self movePool: poolDict toClass: each ] ]renameImplementors  self implementors do: [:each |  | parseTree |        parseTree := each parseTreeFor: oldSelector.        parseTree ifNil: [ self refactoringFailure: 'Could not parse source code.' ].        self implementorsCanBePrimitives ifFalse: [ parseTree isPrimitive ifTrue: [ self refactoringFailure: ('<1p>''s implementation of #<2s> is a primitive' expandMacrosWith: each with: oldSelector) ] ].        self modifyImplementorParseTree: parseTree in: each.        (each methodFor: oldSelector) compileTree: parseTree ]storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' class: '.  className storeOn: aStream.  aStream nextPut: $)universalTestFor: aBrowserEnvironment  self labelFor: aBrowserEnvironment.  self uniqueClassesIn: aBrowserEnvironment.  self numberSelectorsFor: aBrowserEnvironment.  self storeStringFor: aBrowserEnvironment.  self classNamesFor: aBrowserEnvironment.  self copyFor: aBrowserEnvironment.  self categoriesFor: aBrowserEnvironment.  self protocolsFor: aBrowserEnvironment.  self classesFor: aBrowserEnvironment.  self keysFor: aBrowserEnvironment.  self assert: aBrowserEnvironment problemCount = 0 equals: aBrowserEnvironment isEmptyclassesFor: aBrowserEnvironment  | allClasses |  allClasses := aBrowserEnvironment classes asSet.  allClasses addAll: aBrowserEnvironment not classes.  RBBrowserEnvironment new allClassesDo: [:each |  allClasses remove: each ].  self assertEmpty: allClassesliteral: anObject containsReferenceTo: aSymbol  anObject = aSymbol ifTrue: [ ^true ].  anObject class = Array ifFalse: [ ^false ].  ^anObject anySatisfy: [:each |  self literal: each containsReferenceTo: aSymbol ]poolVariableNamesFor: aClass  | pools |  pools := Set new.  aClass withAllSuperclasses do: [:each |  each allPoolDictionaryNames do: [:pool |  pools addAll: ((Smalltalk globals at: pool asSymbol) classPool keys collect: [:name |  name asString ]) ] ].  ^poolsvariable: aVariableName class: aClassName classVariable: aBoolean  self className: aClassName.  variableName := aVariableName.  isClassVariable := aBooleantestModelInlineRecursiveMethod  | refactoring class |  class := model classNamed: #Object.  class compile: 'foo self bar. self foo. self bar' classified: #(#accessing).  refactoring := RBInlineMethodRefactoring model: model inline: (15 to: 23) inMethod: #foo forClass: class.  self proceedThroughWarning: [ self executeRefactoring: refactoring ].  self assert: (class parseTreeFor: #foo) equals: (self parseMethod: 'foo self bar. self bar. self foo. self bar. self bar')testMoveWithoutSelfReference  | refactoring class selectorsSize |  refactoring := RBExtractMethodToComponentRefactoring extract: (118 to: 286) from: #copyDictionary: in: RBReadBeforeWrittenTester.  self setupMethodNameFor: refactoring toReturn: #copyWithAssociations.  self setupVariableToMoveToFor: refactoring toReturn: 'aDictionary'.  self setupVariableTypesFor: refactoring toReturn: (Array with: (refactoring model classNamed: #Dictionary)).  class := refactoring model classNamed: #RBReadBeforeWrittenTester.  selectorsSize := class selectors size.  self executeRefactoring: refactoring.  self assert: (class parseTreeFor: #copyDictionary:) equals: (self parseMethod: 'copyDictionary: aDictionary ^aDictionary copyWithAssociations').  self assert: ((refactoring model classNamed: #Dictionary) parseTreeFor: #copyWithAssociations) equals: (self parseMethod: 'copyWithAssociations 							| newDictionary |							newDictionary := Dictionary new: self size.							self								keysAndValuesDo: [:key :value | newDictionary at: key put: value].							^newDictionary').  self assert: class selectors size equals: selectorsSizerunOnEnvironment: anEnvironment  ^RBSmalllintChecker runRule: self onEnvironment: anEnvironmenttextInput: html name: aString symbol: aSymbol  html text: aString.  html textInput on: aSymbol of: self contact.  html breakprivateTransform  self definingClass addProtocolNamed: protocolremoveOldVariable  self subclassResponsibilitytestVariableEnvironmentClassVars  | classRefs |  classRefs := RBVariableEnvironment referencesToClassVariable: 'ClassSideOnlyVariable' in: self class.  self universalTestFor: classRefs.  self denyEmpty: classRefs methodsprotocol: aString inMethod: aSelector inClass: aClassName  self className: aClassName.  selector := aSelector.  protocol := aStringassignmentInBlock  [ ^self printString ] ensure: [ self close ]testBadName  self     shouldFail: (RBRenameClassRefactoring rename: RBLintRuleTestData to: self objectClassVariable);     shouldFail: (RBRenameClassRefactoring rename: RBLintRuleTestData to: #'Ob ject')testRemoveSelectorByAndAndNot  | aBrowserEnvironment objectPrintString |  aBrowserEnvironment := RBBrowserEnvironment new.  objectPrintString := RBSelectorEnvironment onEnvironment: aBrowserEnvironment.  objectPrintString addClass: Object selector: #printString.  self assert: aBrowserEnvironment numberSelectors - 1 equals: (aBrowserEnvironment & objectPrintString not) numberSelectors.  self universalTestFor: aBrowserEnvironment & objectPrintString notsetUp  | st |  super setUp.  st := RBClassModelFactory rbNamespace new.  objectClass := st classNamed: #Object.  messageNodeClass := st classNamed: #RBMessageNode.  st defineClass: 'Object subclass: #SomeClassName	instanceVariableNames: ''instanceVariable1 instanceVariable2''	classVariableNames: ''ClassVariable1''	poolDictionaries: ''TextConstants''	category: #''Refactory-Testing'''.  newClass := st classNamed: #SomeClassNametestClassVariable  self shouldFail: (RBSplitClassTransformation class: #RBDummyLintRuleTest instanceVariables: #(Foo1) newClassName: #RBDummyLintRuleTest123 referenceVariableName: #receiver) asRefactoringmatcher: aParseTreeSearcher  matcher := aParseTreeSearcherstringConcatenation  | string |  string := '' yourself.  (1 to: 10) do: [:i |  string := string , i printString ].  ^stringisTransformationRule  ^truetestRoots  | model |  model := modelFactory rbNamespace new.  self assert: (model rootClasses asSortedCollection: [:a :b |  a name < b name ]) asArray equals: ((Class rootsOfTheWorld collect: [:each |  model classFor: each ]) asSortedCollection: [:a :b |  a name < b name ]) asArraypullUpMethods  selectors do: [:each |  self pullUp: each ]preconditionsForClassVariable  ^(RBCondition isMetaclass: class) not & (RBCondition definesClassVariable: variableName in: class) & (RBCondition accessesClassVariable: variableName in: class showIn: self)testPerformRenameClassVariable  | change |  change := changes renameClassVariable: 'ClassVar' to: 'ClassVarPlus' in: self changeMock.  self perform: change do: [ self deny: (change changeClass classVarNames includes: change oldName).        self assert: (change changeClass classVarNames includes: change newName) ].  self assert: (change changeClass classVarNames includes: change oldName).  self deny: (change changeClass classVarNames includes: change newName)abstractClassVariable: aString  | refactoring rewriter nonMetaClass |  nonMetaClass := fromClass instanceSide.  refactoring := RBCreateAccessorsForVariableRefactoring model: self model variable: aString class: nonMetaClass classVariable: true.  self performComponentRefactoring: refactoring.  rewriter := RBParseTreeRewriter new.  fromClass isMeta ifTrue: [ rewriter           replace: aString , ' := ``@object' with: ('self <1s> ``@object' expandMacrosWith: refactoring setterMethod);           replace: aString with: 'self ' , refactoring getterMethod ] ifFalse: [ rewriter           replace: aString , ' := ``@object' with: ('self class <1s> ``@object' expandMacrosWith: refactoring setterMethod);           replace: aString with: 'self class ' , refactoring getterMethod ].  (rewriter executeTree: tree) ifTrue: [ tree := rewriter tree ]testModelChildrenToSibling  | refactoring class subclass superclass |  class := model classNamed: #ConcreteSuperclass.  subclass := model classNamed: #ConcreteSubclass.  refactoring := RBChildrenToSiblingsRefactoring model: model name: #AbstractSuperclass class: class subclasses: (Array with: subclass).  self executeRefactoring: refactoring.  superclass := refactoring model classNamed: #AbstractSuperclass.  self assert: class superclass equals: superclass.  self assert: class classSide superclass equals: superclass classSide.  self assert: subclass superclass equals: superclass.  self assert: subclass classSide superclass equals: superclass classSide.  self assert: (superclass parseTreeFor: #same) equals: (self parseMethod: 'same ^self initialize isKindOf: AbstractSuperclass').  self assert: (superclass parseTreeFor: #different) equals: (self parseMethod: 'different self subclassResponsibility').  self assert: (superclass parseTreeFor: #initialize) equals: (self parseMethod: 'initialize							instVarName1 := instVarName2 := ClassVarName1 := ClassVarName2 := 0').  self assert: (superclass directlyDefinesInstanceVariable: 'instVarName1').  self assert: (superclass directlyDefinesInstanceVariable: 'instVarName2').  self assert: (superclass directlyDefinesClassVariable: 'ClassVarName1').  self assert: (superclass directlyDefinesClassVariable: 'ClassVarName2').  self assert: (superclass classSide directlyDefinesInstanceVariable: 'classInstVarName1').  self assert: (superclass classSide parseTreeFor: #foo) equals: (self parseMethod: 'foo							^classInstVarName1 + ClassVarName1 + ClassVarName2').  self assert: (superclass classSide parseTreeFor: #new) equals: (self parseMethod: 'new							^super new initialize').  self assert: (superclass classSide parseTreeFor: #bar) equals: (self parseMethod: 'bar							self subclassResponsibility').  self deny: (class directlyDefinesInstanceVariable: 'instVarName1').  self deny: (class directlyDefinesInstanceVariable: 'instVarName2').  self deny: (class directlyDefinesClassVariable: 'ClassVarName1').  self deny: (class directlyDefinesClassVariable: 'ClassVarName2').  self deny: (class classSide directlyDefinesInstanceVariable: 'classInstVarName1').  self deny: (class directlyDefinesMethod: #same).  self deny: (class directlyDefinesMethod: #initialize).  self deny: (class classSide directlyDefinesMethod: #new).  self assert: (class parseTreeFor: #different) equals: (self parseMethod: 'different							^instVarName1 + instVarName2').  self assert: (class classSide parseTreeFor: #bar) equals: (self parseMethod: 'bar							^self printString')findAndReplaceOcurrencesIn: aMethod  | ocurrences |  ocurrences := self findOcurrencesIn: aMethod selector of: aMethod origin.  ocurrences ifNotEmpty: [ self replaceOcurrences: ocurrences on: aMethod ]printOn: aStream  self storeOn: aStreamabstractVariableTestData  | newModel classEnvironment classes |  classes := #(#Bar #Foo) inject: OrderedCollection new into: [:sum :each |  testingEnvironment at: each ifPresent: [:class |  sum                 add: class;                 add: class class ].        sum ].  classEnvironment := RBClassEnvironment classes: classes.  newModel := RBClassModelFactory rbNamespace onEnvironment: classEnvironment not.  newModel name: 'Test'.  #('Object subclass: #Foo		instanceVariableNames: ''instVarName1 instVarName2''		classVariableNames: ''ClassVarName1 ClassVarName2 ''		poolDictionaries: ''''		category: ''Testing'' ' 'Foo subclass: #Bar		instanceVariableNames: ''''		classVariableNames: ''''		poolDictionaries: ''''		category: ''Testing'' ') do: [:each |  newModel defineClass: each ].  #(#(#Bar #(#('instVarName1			^1242321' #tests) #('foo			instVarName1 := instVarName1 + instVarName2 + ClassVarName1' #tests))) #(#Foo #(#('foo			^instVarName2 := 3' #tests) #('bar			"Add one to instVarName1"			instVarName1 := instVarName1 + 1' #tests) #('classVarName1			^ClassVarName1' #tests) #('instVarName1: anObject			^anObject' #tests) #('asdf			^self classVarName1: (ClassVarName1 := ClassVarName1 + 1)' #tests) #('instVarName2			^instVarName2' #tests) #('instVarName2: anObject			instVarName2 := anObject' #tests) #('classVarName1: anObject			^ClassVarName1 := anObject' #tests))) #('Bar class' #(#('classVarName2: anObject			ClassVarName2 := anObject' #tests) #('classVarName2			^ClassVarName2' #tests))) #('Foo class' #(#('foo			^ClassVarName1 := ClassVarName1 * ClassVarName1 * ClassVarName1' #tests)))) do: [:each |  | class |        class := newModel classNamed: each first.        each last do: [:methodPair |  class compile: methodPair first classified: methodPair last ] ].  ^newModeltestAddToModel  | refactoring |  model := RBClassModelFactory rbNamespace new.  model name: 'Add instance variable'.  model defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''fdsa'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.  refactoring := RBAddInstanceVariableRefactoring model: model variable: 'asdf' class: (model classNamed: #FOOBAR).  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #FOOBAR) directlyDefinesInstanceVariable: 'asdf')addUndoPointer: aNumber  undoPointers push: aNumber& anEnvironment  self isSystem ifTrue: [ ^anEnvironment ].  anEnvironment isSystem ifTrue: [ ^self ].  ^RBAndEnvironment onEnvironment: self and: anEnvironmentmodel  ^model ifNil: [ model := self newModel ]check  ^block valuetestNonExistantName  self shouldFail: (RBAddParameterRefactoring addParameterToMethod: #name1 in: RBLintRuleTestData newSelector: #name1: initializer: 'nil')changes  ^self model changesreplaceArguments  sourceMessage arguments reversed with: inlineParseTree arguments reversed do: [:replacement :source |  (replacement isImmediateNode or: [ self shouldInlineExpression: replacement newSource ]) ifTrue: [ self replaceArgument: source with: replacement ] ifFalse: [ self addTemporary: source assignedTo: replacement ] ]setUp  super setUp.  self createMockClass.  model := RBNamespace2 newtestInlineEmptyComponentMethod  | refactoring |  self proceedThroughWarning: [ refactoring := RBInlineMethodFromComponentRefactoring inline: (35 to: 91) inMethod: #inlineComponent forClass: RBRefactoryTestDataApp.        self setupInlineExpressionFor: refactoring toReturn: false.        self setupImplementorToInlineFor: refactoring toReturn: (refactoring model classNamed: #Object).        self executeRefactoring: refactoring ].  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineComponent) equals: (self parseMethod: 'inlineComponent	| a anObject |	a := 5.	anObject := a class.	anObject superclass.	anObject hasImmediateInstances.	^anObject')instanceVariableNames  ^instanceVariableNamesseverity  ^#informationstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' replace: ''';     nextPutAll: oldSourceCode;     nextPutAll: ''' to: ''';     nextPutAll: newSourceCode;     nextPutAll: ''' inMethod: #';     nextPutAll: selector;     nextPutAll: ' inClass: '.  class storeOn: aStream.  aStream nextPut: $)name: aString  ^changes name: aStringpreconditions  ^(RBCondition definesSelector: selector in: self definingClass) & (RBCondition withBlock: [ | tree |              tree := self parserClass parseExpression: sourceCode onError: [:string :pos |  self refactoringError: 'Invalid source to extract - ' , string ].              tree ifNil: [ self refactoringError: 'Invalid source to extract - ' , sourceCode ].              (tree isSequence and: [ tree statements isEmpty ]) ifTrue: [ self refactoringError: 'Selected code to extract is empty' ].              tree := ((self definingClass parseTreeFor: selector) extractSubtreeWith: sourceCode) ifNil: [ self refactoringError: 'Could not extract code from method ' , selector ].              true ])changesSize  ^changes inject: 0 into: [:sum :each |  sum + each changesSize ]propagateTransformation  self renameMessageSendsnumberClasses  ^self classNames sizetestReturn  self shouldFail: (RBInlineMethodRefactoring inline: (418 to: 485) inMethod: #utilityMethods forClass: RBBasicLintRuleTestData class)reference  ^RBClassToRename newexistingMethodsThatReferToClassVariable: aString  | binding existingMethods |  binding := (self bindingOf: aString) ifNil: [ ^#() ].  existingMethods := self realClass whichSelectorsReferTo: binding.  (newMethods isNil and: [ removedMethods isNil ]) ifTrue: [ ^existingMethods ].  ^existingMethods reject: [:each |  (self hasRemoved: each) or: [ self newMethods includesKey: each ] ]preconditionHasNoUsers: aClassOrTrait  ^(RBCondition withBlock: [ (aClassOrTrait realClass users copyWithoutAll: classNames) isEmpty ])     errorMacro: aClassOrTrait name , ' Trait is used.<n>Browse classes using it?';     errorBlock: [ self openBrowserOn: (self environmentWithUsersOf: aClassOrTrait) ];     yourselfnameToDisplay  ^'Rename ' , self oldName , ' into ' , self newNametestRemoveClassNamed  | change |  change := changes removeClassNamed: self class name.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self universalTestFor: changedefiningClass  ^class ifNil: [ class := self model classObjectFor: self className ]preconditionsForClassVariable  ^(RBCondition definesClassVariable: variableName in: self definingClass) & (RBCondition withBlock: [ | numSubclassesAccessing |              numSubclassesAccessing := self definingClass subclasses count: [:subclass |  subclass withAllSubclasses anySatisfy: [:e |  (e whichSelectorsReferToClassVariable: variableName) isNotEmpty or: [ (e theMetaClass whichSelectorsReferToClassVariable: variableName) isNotEmpty ] ] ].              numSubclassesAccessing < 2 ])selector  ^selectorcategories  ^self systemDictionary organization categories select: [:each |  self includesCategory: each ]preconditions  | conditions |  conditions := self myConditions & (RBCondition definesSelector: oldSelector in: class) & (RBCondition isValidMethodName: newSelector for: class).  conditions := self implementors inject: conditions into: [:condition :each |  condition & (RBCondition hierarchyOf: each canUnderstand: newSelector) not ].  ^conditions & (RBCondition withBlock: [ self implementors size > 1 ifTrue: [ self refactoringWarning: ('This will modify all <1p> implementors.' expandMacrosWith: self implementors size) ].              true ])replaceVariableReferences  | replacer |  replacer := RBParseTreeRewriter new.  replacer replace: variable with: 'self'.  replacer executeTree: parseTree.  parseTree := replacer treedefinitionClass  ^self changeClass= aRefactoryVariableChange  ^super = aRefactoryVariableChange and: [ self variable = aRefactoryVariableChange variable ]setupMethodNameFor: aRefactoring toReturn: aSelector withArguments: stringCollection  | options |  options := aRefactoring options copy.  options at: #methodName put: [:ref :aMethodName |  aMethodName           selector: aSelector;           arguments: stringCollection;           yourself ].  aRefactoring options: optionscompiledMethod  ^self compiledMethodIn: class realClasscheckSiblingSuperSendsFrom: aRBClass  aRBClass selectors do: [:each |  | tree |        tree := aRBClass parseTreeFor: each.        tree ifNotNil: [ tree superMessages do: [:aSelector |  (selectors includes: aSelector) ifTrue: [ | definer |                          definer := aRBClass superclass whoDefinesMethod: aSelector.                          (definer notNil and: [ class includesClass: definer ]) ifTrue: [ self refactoringError: ('Cannot pull up <1s> since <2p>>><3s> sends a super message to it.' expandMacrosWith: aSelector with: aRBClass with: each) ] ] ] ] ].  aRBClass allSubclasses do: [:each |  self checkSiblingSuperSendsFrom: each ]ifTrueReturns  self isSymbol ifFalse: [ ^true ].  ^falsenewClass  ^self model classNamed: newNamerenameChangesForClass: oldClassName to: newClassName  ^self changeClassName = oldClassName ifFalse: [ self ] ifTrue: [ self copy           changeClassName: newClassName;           yourself ]newName: aString  newName := aStringprotocol  ^self protocols firstrenameReferences  | replacer |  replacer := (RBParseTreeRewriter replaceLiteral: className with: newName)     replace: className with: newName;     replaceArgument: newName withValueFrom: [:aNode |  self refactoringFailure: newName , ' already exists within the reference scope' ];     yourself.  self model allReferencesToClass: class do: [:method |  (method modelClass hierarchyDefinesVariable: newName) ifTrue: [ self refactoringFailure: newName , ' is already defined in hierarchy of ' , method modelClass printString ].        self convertMethod: method selector for: method modelClass using: replacer ]storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' variable: '.  variableName storeOn: aStream.  aStream nextPutAll: ' class: '.  className storeOn: aStream.  aStream nextPutAll: ' classVariable: '.  isClassVariable storeOn: aStream.  aStream nextPut: $)parseTreeSearcher  ^RBParseTreeSearcher newselectVariableToMoveMethodTo: aSelector class: aClass  ^(self options at: #selectVariableToMoveTo) value: self value: aClass value: aSelectordefinesClass: aClass  ^(environment definesClass: aClass) and: [ andedEnvironment definesClass: aClass ]refineTypes: aClassCollection with: anotherClassCollection  | classSet |  classSet := Set new.  aClassCollection do: [:each |  anotherClassCollection do: [:cls |  (cls includesClass: each) ifTrue: [ classSet add: cls ] ifFalse: [ (each includesClass: cls) ifTrue: [ classSet add: each ] ] ] ].  ^classSetopenBrowserOn: anEnvironment  ^(self options at: #openBrowser) value: self value: anEnvironmentcopyOldValuesToNewVariable  | oldValue |  oldValue := self changeClass classPool at: oldName ifAbsent: [ nil ].  self changeClass classPool at: newName asSymbol put: oldValueparseTreeFor: aSelector  | class |  class := self whoDefinesMethod: aSelector.  class ifNil: [ ^nil ].  ^(class methodFor: aSelector) parseTreereplaceOcurrences: ocurrences on: aMethod  ocurrences ifNotEmpty: [ | refactoring dialog ocurrencesSize |        ocurrencesSize := ocurrences size.        replaceAll ifTrue: [ self extract: (self orderOcurrences: ocurrences) of: aMethod executing: #execute.              ocurrencesSize := ocurrencesSize - 1 ] ifFalse: [ refactoring := self extract: (self orderOcurrences: ocurrences) of: aMethod executing: #primitiveExecute.              dialog := (RBReplacePreview change: refactoring)                 cancelAction: [:presenter |  listToFindMatches := Array new.                    ocurrencesSize := -1.                    presenter                       beCancel;                       close ];                 skipAction: [:presenter |  positionIndex := positionIndex + 1.                    ocurrencesSize := ocurrencesSize + 1.                    presenter                       beOk;                       close ];                 replaceAllAction: [:presenter |  replaceAll := true.                    presenter                       beOk;                       close ];                 open.              dialog cancelled ifFalse: [ ocurrencesSize := ocurrencesSize - 1 ] ].        ocurrencesSize >= positionIndex ifTrue: [ self findAndReplaceOcurrencesIn: aMethod ] ]method: aMethod class: aClass  method := aMethod.  class := self classObjectFor: aClassmethodsUsingClassVariableNamed: aClassVariableName  ^(self realClass classVariableNamed: aClassVariableName) usingMethods collect: [:aMethod |  | modelClass |        modelClass := self model classNamed: aMethod methodClass name.        modelClass methodFor: aMethod selector ]accessorMethods  ^#(#instanceVariables #instanceVariableReaders #instanceVariableWriters #classVariables)primitiveExecute  self changeClass classComment: comment stamp: self changeStamp.  SystemAnnouncer uniqueInstance classCommented: self changeClasstestPullUpAndCopyDown  | class |  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #Foo1 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'Subclass subclass: #Foo2 instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  class := model classNamed: #Foo1.  class compile: 'yourself ^1' classified: #(#accessing).  self proceedThroughWarning: [ self executeRefactoring: (RBPullUpMethodRefactoring model: model pullUp: #(#yourself) from: class) ].  self assert: (class superclass parseTreeFor: #yourself) equals: (self parseMethod: 'yourself ^1').  self deny: (class directlyDefinesMethod: #yourself).  class := model classNamed: #Foo2.  self assert: (class directlyDefinesMethod: #yourself).  self assert: (class parseTreeFor: #yourself) equals: ((model classNamed: #Object) parseTreeFor: #yourself)changeString  ^'Add pool variable <1s> to <2s>' expandMacrosWith: self variable with: self displayClassNamechangeClass: aBehavior  isMeta := aBehavior isMeta.  className := isMeta ifTrue: [ aBehavior soleInstance name ] ifFalse: [ aBehavior name ]flagged  self flag: #pharoTodohasConflicts  ^falseprotocolsFor: aBrowserEnvironment  aBrowserEnvironment classesAndSelectorsDo: [:class :selector |  | protocol |        protocol := aBrowserEnvironment whichProtocolIncludes: selector in: class.        self assert: (aBrowserEnvironment includesProtocol: protocol in: class) ]checkMethod: aMethod  (self basicCheck: aMethod) ifTrue: [ self builder compile: rewriteRule tree newSource in: class classified: aMethod protocol ]newSelectorString  | stream keywords |  stream := WriteStream on: String new.  keywords := newSelector keywords.  1 to: keywords size do: [:i |  stream nextPutAll: (keywords at: i).        i == keywords size ifTrue: [ stream                 nextPut: $(;                 nextPutAll: initializer;                 nextPut: $) ] ifFalse: [ stream                 nextPutAll: ' ``@arg';                 nextPutAll: i printString ].        stream nextPut: $  ].  ^stream contentsstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' className: '.  className storeOn: aStream.  aStream nextPut: $)addClass: aClass instanceVariable: aString  (instanceVariables at: aClass name ifAbsentPut: [ Set new ]) add: aString.  self flushCachesFor: aClass.  self addSearchString: aStringtransform  | parseTree matcher method |  method := class methodFor: selector.  parseTree := method parseTree.  parseTree ifNil: [ self refactoringFailure: 'Could not parse method' ].  class addInstanceVariable: temporaryVariableName.  (matcher := RBParseTreeRewriter removeTemporaryNamed: temporaryVariableName) executeTree: parseTree.  method compileTree: matcher treetestNeedsReturn  | refactoring class |  refactoring := (RBExtractMethodTransformation extract: 'rules isEmpty ifTrue: [^self].						rules size == 1 ifTrue: [^rules first viewResults]' from: #openEditor to: #foo: in: #RBDummyLintRuleTest) asRefactoring transform.  self assert: refactoring model changes changes size equals: 2.  class := refactoring model classNamed: #RBDummyLintRuleTest.  self assert: (class parseTreeFor: #openEditor) equals: (self parseMethod: 'openEditor				| rules |				rules := self failedRules.				^self foo: rules').  self assert: (class parseTreeFor: #foo:) equals: (self parseMethod: 'foo: rules				rules isEmpty ifTrue: [^self].				rules size == 1 ifTrue: [^rules first viewResults]')oldName  ^oldNamestoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' className: '.  className storeOn: aStream.  aStream nextPut: $)findSetterMethod  | definingClass matcher |  definingClass := self definingClass.  matcher := self needsReturnForSetter ifTrue: [ self parseTreeSearcherClass returnSetterMethod: variableName ] ifFalse: [ self parseTreeSearcherClass setterMethod: variableName ].  ^self possibleSetterSelectors detect: [:each |  (self checkClass: definingClass selector: each using: matcher) notNil and: [ (definingClass subclassRedefines: each) not ] ] ifNone: [ nil ]instanceSide  ^model classNamed: self namerenameClassVariable: oldName to: newName around: aBlock  self privateClassVariableNames at: (self privateClassVariableNames indexOf: oldName asSymbol) put: newName asSymbol.  ^self model performChange: (changeFactory renameClassVariable: oldName to: newName in: self) around: aBlockcaller1  | anObject |  anObject := 5.  self called: anObject + 1 on1: [:each |  each printString.        ^anObject ]verifySelectedInterval  sourceTree := class parseTreeFor: selector.  sourceTree ifNil: [ self refactoringFailure: 'Could not parse source' ].  assignmentNode := sourceTree whichNodeIsContainedBy: sourceInterval.  assignmentNode isAssignment ifFalse: [ self refactoringFailure: 'The selected node is not an assignment statement' ].  definingNode := assignmentNode whoDefines: assignmentNode variable name.  self hasOnlyOneAssignment ifFalse: [ self refactoringError: 'There are multiple assignments to the variable' ].  (RBReadBeforeWrittenTester isVariable: assignmentNode variable name writtenBeforeReadIn: definingNode) ifFalse: [ self refactoringError: 'The variable is possible read before it is assigned' ]collectionMessagesToExternalObject  self someObject collection remove: 10nonUnaryAccessingBranchingStatementMethodWithoutReturn: anObject  self value isString ifTrue: [ self value ] ifFalse: [ '' ]testRenameTemporary  | refactoring |  refactoring := RBRenameTemporaryRefactoring renameTemporaryFrom: (15 to: 19) to: 'asdf' in: RBLintRuleTestData selector: #openEditor.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBLintRuleTestData) parseTreeFor: #openEditor) equals: (self parseMethod: 'openEditor								| asdf |								asdf := self failedRules.								asdf isEmpty ifTrue: [^self].								asdf size == 1 ifTrue: [^asdf first viewResults]')checksPreconditions  self preconditionChecking: truenotifyUserOfCommand: aCommand  | answer title |  title := 'Warning. Want to proceed?'.  answer := UIManager default confirm: self messageText label: title.  answer ifTrue: [ self resume: true ]classNamesFor: aCategoryName  ^(self systemDictionary organization listAtCategoryNamed: aCategoryName) select: [:each |  | class |        class := self systemDictionary at: each ifAbsent: [ nil ].        class notNil and: [ (self includesClass: class) or: [ self includesClass: class class ] ] ]requestSuperClass  ^(self options at: #superClass) value: selfchanges  ^self builder changesremoveChange: aChange  ^changes remove: aChange ifAbsent: [ nil ]inlineClass  | imps |  inlineClass ifNotNil: [ ^inlineClass ].  imps := (self model allImplementorsOf: self inlineSelector) asOrderedCollection.  imps size = 1 ifTrue: [ ^inlineClass := imps first ].  imps ifEmpty: [ self refactoringFailure: 'Nobody defines a method named ' , self inlineSelector ].  inlineClass := self requestImplementorToInline: imps.  inlineClass ifNil: [ self refactoringFailure: 'No implementor selected' ].  ^inlineClasschangeString  ^self displayClassName , '>>' , self selectorhash  ^selector hashtransformations  ^transformations ifNil: [ transformations := self buildTransformations ]categoriesFor: anEnvironment  | allCategories |  allCategories := IdentitySet withAll: universalEnvironment categories.  allCategories removeAll: anEnvironment categories.  anEnvironment not categories do: [:each |  allCategories remove: each ifAbsent: [  ] ].  allCategories do: [:each |  self assertEmpty: (universalEnvironment classNamesFor: each) ]assert: aBooleanOrBlock description: aStringOrBlock resumable: resumableBoolean  | exception |  aBooleanOrBlock value ifFalse: [ | aString |        aString := aStringOrBlock value.        exception := resumableBoolean ifTrue: [ self classForTestResult resumableFailure ] ifFalse: [ self classForTestResult failure ].        exception signal: aString ]isMeta  ^falsecheckSuperMethods  | superMessages nonSupers |  nonSupers := OrderedCollection new.  superMessages := OrderedCollection new.  (selectors reject: [:each |  self justSendsSuper: each ]) do: [:each |  (self superclassEquivalentlyDefines: each) ifTrue: [ (class parseTreeFor: each) superMessages isEmpty ifFalse: [ superMessages add: each ] ] ifFalse: [ nonSupers add: each ] ].  nonSupers isEmpty & superMessages isEmpty ifTrue: [ ^self ].  self checkReferencesToAnyOf: nonSupers.  self checkReferencesToSuperSendsToAnyOf: superMessagesfindSelectedMessage  sourceParseTree := class parseTreeFor: sourceSelector.  sourceParseTree ifNil: [ self refactoringFailure: 'Could not parse sources' ].  sourceMessage := sourceParseTree whichNodeIsContainedBy: sourceInterval.  sourceMessage ifNil: [ self refactoringFailure: 'The selection doesn''t appear to be a message send' ].  sourceMessage isCascade ifTrue: [ sourceMessage := sourceMessage messages last ].  sourceMessage isMessage ifFalse: [ self refactoringFailure: 'The selection doesn''t appear to be a message send' ].  sourceMessage receiver isSelfOrSuper ifFalse: [ self refactoringError: 'Cannot inline non-self messages' ]testPerformAddRemoveClassMethod  | change |  change := changes compile: 'method ^ 1' in: self changeMock class classified: #utilities.  self perform: change do: [ self assert: (self changeMock respondsTo: #method) ].  self deny: (self changeMock respondsTo: #method).  self assert: change definedSelector equals: #methodasRefactoring  ^super asRefactoring     delegatesPreconditions: false;     yourselfselectEnvironment: aValue  environment := environmentDictionaries at: aValue ifAbsent: [ RBSelectorEnvironment new ]testAddParameterThatReferencesSelf  | refactoring class |  refactoring := RBAddParameterRefactoring addParameterToMethod: ('test' , 'Foo:') asSymbol in: RBRefactoryTestDataApp newSelector: #testFoo:bar: initializer: 'self printString'.  self proceedThroughWarning: [ self executeRefactoring: refactoring ].  class := refactoring model classNamed: #RBRefactoryTestDataApp.  self assert: (class parseTreeFor: #testFoo:bar:) equals: (self parseMethod: 'testFoo: anObject bar: anObject1								^self class + anObject').  self assert: (class parseTreeFor: #callFoo) equals: (self parseMethod: 'callFoo ^self testFoo: 5 bar: (self printString)').  self deny: (class directlyDefinesMethod: ('test' , 'Foo:') asSymbol)testInvalidSubclass  self shouldFail: (RBChildrenToSiblingsRefactoring name: #Foo class: RBRefactoringTest subclasses: (Array with: RBBasicLintRuleTestData with: RBCompositeLintRuleTestData))parserClass  ^RBParsertestMoveDefinitionIntoBlockThatIsAReceiverOfACascadedMessage  | transformation class |  transformation := (RBMoveTemporaryVariableDefinitionTransformation variable: #association inMethod: #referencesConditionFor: inClass: #RBDummyRefactoryTestDataApp) asRefactoring transform.  class := transformation model classNamed: #RBDummyRefactoryTestDataApp.  self assert: (class parseTreeFor: #referencesConditionFor:) equals: (self parseMethod: 'referencesConditionFor: aClass 						| environment  |						^(RBCondition withBlock: 								[| association |association := Smalltalk associationAt: aClass name											ifAbsent: [self refactoringError: ''Could not find class''].								environment := (self environment referencesTo: association) 											| (self environment referencesTo: aClass name).								environment isEmpty])							errorMacro: aClass , '' is referenced.<n>Browse references?'';							errorBlock: [environment openEditor];							yourself')asUndoOperation  ^(self changeClass includesSelector: self selector) ifTrue: [ | oldProtocol |        oldProtocol := RBBrowserEnvironment new whichProtocolIncludes: self selector in: self changeClass.        oldProtocol ifNil: [ oldProtocol := #accessing ].        changeFactory addMethodSource: (self methodSourceFor: self selector) in: self changeClass classified: oldProtocol ] ifFalse: [ changeFactory removeMethod: selector from: self changeClass ]testConstructedClassEnvironment  | environment |  environment := RBClassEnvironment new.  environment     addClass: Object;     addClass: OrderedCollection;     addClass: Collection.  self assert: (environment includesClass: Object).  self assert: (environment includesClass: OrderedCollection).  self assert: (environment includesClass: Collection).  self deny: (environment includesClass: Object class).  environment removeClass: Collection.  self assert: (environment includesClass: Object).  self assert: (environment includesClass: OrderedCollection).  self deny: (environment includesClass: Collection).  self assert: environment numberClasses equals: 2.  environment addClass: Object class.  self assert: environment numberClasses equals: 2.  self assert: (environment includesClass: Object class).  environment removeClass: self class.  self assert: environment numberClasses equals: 2preconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition hierarchyOf: class definesVariable: temporaryVariableName asString) not & (RBCondition withBlock: [ self checkForValidTemporaryVariable.              true ])collectSelectNotUsed  (1 to: 10) select: [:each |  each = 4 ]pullUp: aSelector  | source refactoring |  source := class sourceCodeFor: aSelector.  source ifNil: [ self refactoringFailure: 'Source for method not available' ].  refactoring := RBExpandReferencedPoolsRefactoring model: self model forMethod: (class parseTreeFor: aSelector) fromClass: class toClasses: (Array with: targetSuperclass).  self performComponentRefactoring: refactoring.  targetSuperclass compile: source classified: (class protocolsFor: aSelector)gtInspectorChildren  ^{left .   right}resetResult  builder := RBRefactoryChangeManager changeFactory compositeRefactoryChangepreconditions  ^classNames inject: RBCondition empty into: [:sum :each |  | aClassOrTrait |        aClassOrTrait := self model classNamed: each asSymbol.        aClassOrTrait ifNil: [ self refactoringFailure: 'No such class or trait' ].        sum & ((self preconditionIsNotMetaclass: aClassOrTrait) & (self preconditionHasNoReferences: each) & (self preconditionEmptyOrHasNoSubclasses: aClassOrTrait) & (self preconditionHasNoUsers: aClassOrTrait)) ]openEditor  | rules |  rules := self failedRules.  rules isEmpty ifTrue: [ ^self ].  rules size == 1 ifTrue: [ ^rules first viewResults ]sourceCode  ^tree formattedCodetestTransform  | transformation class |  transformation := (RBRemoveReturnStatementTransformation new return: '^ variable' inMethod: #methodBefore inClass: self class name) transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self class name.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) bodyrenameClassVariable: oldName to: newName around: aBlock  self privateClassVariableNames at: (self privateClassVariableNames indexOf: oldName asSymbol) put: newName asSymbol.  model renameClassVariable: oldName to: newName in: self around: aBlocksetUp  super setUp.  model := self abstractVariableTestDatabuilder  ^builder ifNil: [ self resetResult.        builder ]objectClassVariable  ^Object classPool keys detect: [:each |  true ]testModelAddClassVariable  | refactoring |  refactoring := (RBAddVariableTransformation model: model classVariable: #ClassVarName3 class: (model classNamed: #Bar)) asRefactoring transform.  self assert: ((model classNamed: #Bar) directlyDefinesClassVariable: #ClassVarName3)selector: aSelector from: aClassName  self className: aClassName.  selector := aSelectorargumentList  ^self methodName ifNil: [ OrderedCollection new ] ifNotNil: [:method |  method arguments copy ]testPullUpClassVariable  | refactoring |  refactoring := RBPullUpClassVariableRefactoring variable: #RecursiveSelfRule class: RBLintRuleTestData.  self executeRefactoring: refactoring.  self assert: ((refactoring model classNamed: #RBLintRuleTestData) directlyDefinesClassVariable: #RecursiveSelfRule).  self deny: ((refactoring model classNamed: #RBTransformationRuleTestData) directlyDefinesClassVariable: #RecursiveSelfRule)oldVersionTextToDisplay  | class |  class := (onSystemDictionary classNamed: className) ifNil: [ ^super oldVersionTextToDisplay ].  isMeta ifTrue: [ class := class classSide ].  ^class methodDict at: self selector ifPresent: [:method |  method sourceCode ] ifAbsent: [ super oldVersionTextToDisplay ]postCopy  super postCopy.  keywords := keywords copypreconditions  ^(RBCondition definesSelector: method selector in: class) nottestRemoveClassWithReferencesRaisesRBRefactoringError  self shouldFail: (RBRemoveClassRefactoring classNames: #(#RBBasicLintRuleTestData))initialize  super initialize.  self anInstVar: 1.  classBlock := [:context :aResult |   ].  methodBlock := [:context :aResult |   ].  self resultClass: RBSelectorEnvironmentprivateTransform  | methodTree modifiedNode |  methodTree := self definingMethod.  modifiedNode := (methodTree allChildren select: [:each |  each isSequence ]) detect: [:sequence |  sequence defines: variableName ] ifNone: [ nil ].  modifiedNode ifNotNil: [ modifiedNode removeTemporaryNamed: variableName ].  class compileTree: methodTreetestRenameTestMethod1  | refactoring class |  refactoring := RBRenameMethodRefactoring renameMethod: 'testMethod1' asSymbol in: RBRefactoryTestDataApp to: #testMethod2 permutation: (1 to: 0).  self proceedThroughWarning: [ self executeRefactoring: refactoring ].  class := refactoring model classNamed: #RBRefactoryTestDataApp.  self assert: (class parseTreeFor: #testMethod2) equals: (self parseMethod: 'testMethod2	^self testMethod2 , ([:each | each testMethod2] value: #(#(#testMethod2) 2 #testMethod2))').  self assert: ((refactoring model classNamed: #RBBasicLintRuleTestData) parseTreeFor: #classBlock:) equals: (self parseMethod: 'classBlock: aBlock	classBlock := aBlock testMethod2').  self deny: (class directlyDefinesMethod: ('test' , 'Method1') asSymbol)isAbstract  (self whichSelectorsReferToSymbol: #subclassResponsibility) ifNotEmpty: [ ^true ].  model allReferencesToClass: self do: [:each |  ^false ].  ^trueinitialize  name := ''addNewVariable  self subclassResponsibilityviewResults  rules do: [:each |  each viewResults ]transform  class addClassVariable: variableNametestNoMoveDefinition  self shouldFail: (RBMoveVariableDefinitionRefactoring bindTight: (21 to: 24) in: RBRefactoryTestDataApp selector: #noMoveDefinition)executeShould: aBlock inScopeOf: anException withExceptionDo: anotherBlock  ^[ aBlock value.  false ] on: anException do: [:exception |  anotherBlock value: exception.        exception return: true ]inlineMax  | x y q |  x := 5.  y := 10.  q := x + 1 max: y.  ^qdeny: aBooleanOrBlock  self assert: aBooleanOrBlock value notchanges  ^changestestAddInstanceVariable  | change |  change := changes addInstanceVariable: 'instVar' to: self class.  self assert: change changeClassName equals: self class name.  self assert: change changeClass equals: self class.  self assert: change isMeta not.  self assert: change variable equals: 'instVar'.  self universalTestFor: changeaddClass: aName superclass: aClass category: aSymbol  self addClass: aName superclass: aClass asSymbol subclasses: OrderedCollection new category: aSymboltestRenamePrimitive  | refactoring count |  count := 0.  model allReferencesTo: #basicAt:put: do: [:method |  count := count + 1 ].  refactoring := RBRenameMethodRefactoring model: model renameMethod: #basicAt:put: in: Object to: ('at:' , 'bar:') asSymbol permutation: (1 to: 2).  self proceedThroughWarning: [ self executeRefactoring: refactoring ].  model allReferencesTo: #basicAt:put: do: [:method |  count := count - 1.        self assert: method source isNil ].  model allReferencesTo: ('at:' , 'bar:') asSymbol do: [:method |  count := count - 1 ].  self assert: count equals: 0testAssignmentDoesNotExist  | refactoring |  refactoring := (RBAddTemporaryVariableTransformation variable: 'variable2' inMethod: #methodBefore inClass: #RBRemoveAssignmentTransformationTest) asRefactoring transform.  self shouldFail: (RBRemoveAssignmentTransformation model: refactoring model variable: 'variable2' value: '1 asString' inMethod: #methodBefore inClass: #RBRemoveAssignmentTransformationTest) asRefactoringusesAdd  ^(1 to: 10) asOrderedCollection addAll: (11 to: 20)testPerformAddRemoveMethod  | change |  change := changes compile: 'method ^ 1' in: self changeMock classified: #utilities.  self perform: change do: [ self assert: (self changeMock canUnderstand: #method) ].  self deny: (self changeMock canUnderstand: #method).  self assert: change definedSelector equals: #methodclassBlock: aBlock  classBlock := aBlock testMethod1selectVariableTypesFrom: initialTypeCollection selected: selectedTypeCollection  ^(self options at: #variableTypes) value: self value: initialTypeCollection value: selectedTypeCollectiontransform  self deleteSelectorsallClassesAndTraitsDo: aBlock  self systemDictionary allClassesAndTraitsDo: aBlockcheckSendersAccessTo: name  (#('self' 'super') includes: name) ifTrue: [ ^self ].  self senders detect: [:each |  (self canReferenceVariable: name in: each) not ] ifFound: [:violatorClass |  self refactoringError: ('<1s> doesn''t appear to be defined in <2p>' expandMacrosWith: name with: violatorClass) ]callMethod  ^self renameThisMethod: 5methodAfter  | variable |  variable := 'String'.  ^variabledefinitionClass  ^self changeClassmessageSend: aMessageSend inMethod: aSelector inClass: aClassName  self className: aClassName.  selector := aSelector.  message := aMessageSendtestModelExistingName  self shouldFail: (RBAddClassTransformation model: model addClass: #Foo superclass: #Object subclasses: #() category: #'Refactory-Testing') asRefactoringparserClass  ^RBParserpossibleGetterSelectors  ^self methodsReferencingVariable select: [:each |  each numArgs == 0 ]testBadCategoryName  self shouldFail: (RBMoveClassTransformation move: self class name to: #'Refactoring2-Transformations-Test') asRefactoringisArchitecturalRule  ^falsefindTypeFor: selectorCollection  ^selectorCollection inject: self rootClasses into: [:classes :each |  self refineTypes: classes with: (selectorLookup at: each ifAbsentPut: [ self implementorsOf: each ]) ]initialize: aRule  renrakuRule := aRule.  self initializeinstanceVariableNames: aCollectionOfStrings  instanceVariableNames := aCollectionOfStrings asOrderedCollectiontestUnmarkRemovedClassIfRenameTargetClass  | addClass renameClass classA classB classC |  classA := ('RBClass' , 'ToRename') asSymbol.  classB := 'TestUnmarkClassRenameSource' asSymbol.  classC := 'TestUnmarkClassRenameTarget' asSymbol.  addClass := RBAddClassRefactoring model: model addClass: classB superclass: Object subclasses: {} category: self class package name.  self executeRefactoring: addClass.  self assert: (model includesClassNamed: classA).  renameClass := RBRenameClassRefactoring new     model: model;     className: classA newName: classC;     yourself.  self executeRefactoring: renameClass.  self deny: (model includesClassNamed: classA).  self assert: (model includesClassNamed: classC).  renameClass := RBRenameClassRefactoring new     model: model;     className: classB newName: classA;     yourself.  self executeRefactoring: renameClass.  self deny: (model includesClassNamed: classB).  self assert: (model includesClassNamed: classC).  self assert: (model includesClassNamed: classA)preconditions  ^(RBCondition withBlock: [ self definingClass notNil and: [ self definingClass isMeta not ] ]) & (RBCondition isValidClassName: newClassName) & (RBCondition isGlobal: newClassName in: self model) not & (RBCondition withBlock: [ | replacer |              replacer := (self parseTreeRewriterClass replaceLiteral: className with: newClassName)                 replace: className with: newClassName;                 replaceArgument: newClassName withValueFrom: [:aNode |  self refactoringError: newClassName , ' already exists within the reference scope' ];                 yourself.              self model allReferencesToClass: self definingClass do: [:method |  (method modelClass hierarchyDefinesVariable: newClassName) ifTrue: [ self refactoringError: newClassName , ' is already defined in hierarchy of ' , method modelClass printString ].                    self convertMethod: method selector for: method modelClass using: replacer ].              true ]) | (RBCondition withBlock: [ self refactoringError: newClassName , ' is not a valid class name' ])addPool: aString to: aRBClass  ^changes addPool: aString to: aRBClassextraBlock  ^[:arg |  arg + 43 ] value: 45not  ^RBNegationCondition on: selfrelease  literalProcess ifNotNil: [ literalProcess terminate ].  super releaseincludesSelector: aSelector in: aClass  ^truetestImplementors  | st |  st := modelFactory rbNamespace new.  self assert: ((st allImplementorsOf: #printString) includes: (st classNamed: #Object)).  (st classNamed: #Object) removeMethod: #printString.  self deny: ((st allImplementorsOf: #printString) includes: (st classNamed: #Object))transform  self     renameConflictingTemporaries;     insertInlinedMethod;     compileMethodinitialize  super initialize.  packages := Set newrenameNode: aParseTree withOldName: oldName toWithName: newName  (RBParseTreeRewriter rename: oldName to: newName) executeTree: aParseTreecheckClass: aClass  rules do: [:each |  each checkClass: aClass ]isOkEnabled  ^self methodName isNotNil and: [ self methodName isValid ]addPoolDictionary: aString  self privatePoolDictionaryNames add: aString asSymbol.  model addPool: aString to: selfopenEditor  | rules |  rules := self failedRules.  rules isEmpty ifTrue: [ ^self ].  rules size == 1 ifTrue: [ ^rules first viewResults ]unaryAccessingBranchingStatementMethodWithoutReturn  self value isString ifTrue: [ self value ] ifFalse: [ '' ]testAndEnvironmentWithStoreOn  | originalEnvironment objectPrintStringEnvironment andEnvironment |  originalEnvironment := universalEnvironment referencesTo: #storeOn:.  objectPrintStringEnvironment := universalEnvironment forClass: Object selectors: #(#storeString).  andEnvironment := objectPrintStringEnvironment & originalEnvironment.  self universalTestFor: andEnvironment.  self assert: andEnvironment numberSelectors equals: 1.  self assert: andEnvironment classNames asArray equals: #(#Object).  self assert: (andEnvironment protocolsFor: Object) size equals: 1.  self assert: (objectPrintStringEnvironment & objectPrintStringEnvironment) packages equals: objectPrintStringEnvironment packages.  andEnvironment := originalEnvironment & (universalEnvironment referencesTo: #printString).  self assert: andEnvironment numberSelectors equals: (originalEnvironment referencesTo: #printString) numberSelectors.  self assert: andEnvironment classNames asSortedCollection equals: (originalEnvironment referencesTo: #printString) classNames asSortedCollectiontestClassVariable  | refactoring class |  refactoring := (RBProtectVariableTransformation classVariable: 'RecursiveSelfRule' class: #RBTransformationRuleTestData) asRefactoring transform.  class := (refactoring model classNamed: #RBTransformationRuleTestData) theMetaClass.  self assert: (class parseTreeFor: #recursiveSelfRule) equals: (self parseMethod: 'recursiveSelfRule ^RecursiveSelfRule').  self assert: (class parseTreeFor: #recursiveSelfRule:) equals: (self parseMethod: 'recursiveSelfRule: anObject RecursiveSelfRule := anObject').  self assert: (class parseTreeFor: #nuke) equals: (self parseMethod: 'nuke self recursiveSelfRule: nil').  self assert: (class parseTreeFor: #initializeAfterLoad1) equals: (self parseMethod: 'initializeAfterLoad1				self recursiveSelfRule: RBParseTreeSearcher new.				self recursiveSelfRule					addMethodSearches: #(''`@methodName: `@args | `@temps | self `@methodName: `@args'' ''`@methodName: `@args | `@temps | ^self `@methodName: `@args'')					-> [:aNode :answer | true]').  self assert: ((refactoring model classNamed: #RBTransformationRuleTestData) parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 				class := aSmalllintContext selectedClass.				(rewriteRule executeTree: aSmalllintContext parseTree) ifTrue: 					[(self class recursiveSelfRule executeTree: rewriteRule tree initialAnswer: false)						ifFalse: 							[builder compile: rewriteRule tree printString								in: class								classified: aSmalllintContext protocols]]')isComposite  ^truerules: aCollection  rules := aCollectiondefiningClass  ^isClassVariable ifTrue: [ super definingClass theMetaClass ] ifFalse: [ super definingClass ]preconditionHasNoReferences: aClass  | env |  env := self environmentWithReferencesTo: aClass.  ^(RBCondition withBlock: [ (env classNames copyWithoutAll: classNames) isEmpty ])     errorMacro: aClass , ' is referenced.<n>Browse references?';     errorBlock: [ self openBrowserOn: env ];     yourselfparseTreeSearcherClass  ^RBParseTreeSearchertestTransform  | transformation oldClass newClass |  model := RBNamespace2 new.  model defineClass: 'Object subclass: #FOOBAR 				instanceVariableNames: ''asdf'' 					classVariableNames: ''''				poolDictionaries: ''''				category: #''Refactory-Test data'''.  transformation := RBMoveInstanceVariableToClassTransformation model: model variable: 'asdf' fromClass: #FOOBAR toClass: self changeMock name.  oldClass := transformation model classNamed: #FOOBAR.  newClass := transformation model classNamed: self changeMock name asSymbol.  self assert: (oldClass directlyDefinesInstanceVariable: 'asdf').  self deny: (newClass directlyDefinesInstanceVariable: 'asdf').  transformation transform.  self assert: transformation model changes changes size equals: 3.  oldClass := transformation model classNamed: #FOOBAR.  newClass := transformation model classNamed: self changeMock name asSymbol.  self deny: (oldClass directlyDefinesInstanceVariable: 'asdf').  self assert: (newClass directlyDefinesInstanceVariable: 'asdf')argumentIndex: anInteger  selectedArgumentIndex := anInteger.  self changed: #argumentIndexmovePool: aSymbol toClass: aClass  | nonMetaClass |  nonMetaClass := aClass instanceSide.  (nonMetaClass definesPoolDictionary: aSymbol) ifFalse: [ nonMetaClass addPoolDictionary: aSymbol ]release  self printStringclassVariableSelectorsFor: aClass  | selectors classVars |  selectors := Set new.  classVars := Set new.  classVariables keysDo: [:each |  | cls |        cls := self classForName: each.        (cls notNil and: [ aClass instanceSide includesBehavior: cls ]) ifTrue: [ classVars addAll: (classVariables at: each) ] ].  classVars do: [:each |  | binding |        binding := aClass bindingOf: each.        binding ifNotNil: [ selectors addAll: (aClass whichSelectorsReferTo: binding) ] ].  ^selectorstestConstructedSelectorEnvironment  | environment newEnvironment |  environment := RBSelectorEnvironment new.  environment     addClass: Object selector: #printString;     addClass: OrderedCollection selector: #add:;     addClass: Collection.  self assert: (environment includesClass: Object).  self assert: (environment selectorsForClass: Object) size equals: 1.  self assert: (environment includesClass: OrderedCollection).  self assert: (environment selectorsForClass: OrderedCollection) size equals: 1.  self assert: (environment includesClass: Collection).  self assert: (environment selectorsForClass: Collection) size equals: Collection selectors size.  self deny: (environment includesClass: Object class).  newEnvironment := environment copy.  newEnvironment     removeClass: OrderedCollection;     addClass: Object selector: #printOn:;     removeClass: Object selector: #printString.  self assert: (newEnvironment includesClass: Object).  self deny: (newEnvironment includesSelector: #printString in: Object).  self deny: (newEnvironment includesClass: OrderedCollection).  self assert: (newEnvironment includesClass: Collection).  self assert: newEnvironment numberClasses equals: 2.  self assert: newEnvironment numberSelectors + 1 equals: environment numberSelectors.  newEnvironment addClass: Object class.  self assert: newEnvironment numberClasses equals: 2.  self assert: (newEnvironment includesClass: Object class).  newEnvironment removeClass: self class.  self assert: newEnvironment numberClasses equals: 2testPrimitiveMethods  | refactoring |  (model classNamed: #Object) compile: 'foo <primitive: 100> ^#() primitiveFailed' classified: #(#accessing).  refactoring := RBAddParameterRefactoring model: model addParameterToMethod: #foo in: Object newSelector: #foo123124321s: initializer: '1'.  self shouldFail: refactoring.  refactoring := RBAddParameterRefactoring addParameterToMethod: #at: in: Object newSelector: #at:foo: initializer: '1'.  self shouldFail: refactoringname  ^nameequalNotUsed  | string |  string = '' yourself.  (1 to: 10) do: [:i |  string := i printString ].  ^stringrenameConflictingTemporaries  inlineParseTree allDefinedVariables do: [:each |  self renameConflictingTemporary: each ]isClassEnvironment  ^falseasUndoOperation  ^self subclassResponsibilitycopyClasses  mode := #copy:name:referencesConditionFor: aClass  | environment association |  ^(RBCondition withBlock: [ association := Smalltalk globals associationAt: aClass name ifAbsent: [ self refactoringError: 'Could not find class' ].        environment := (self environment referencesTo: association) | (self environment referencesTo: aClass name).        environment isEmpty ])     errorMacro: aClass , ' is referenced.<n>Browse references?';     errorBlock: [ environment openEditor ];     yourselfmethod2  ^self method1transform  renameAccessors ifTrue: [ self removeOldAccessors ].  class renameInstanceVariable: variableName to: newName around: [ self renameReferences ].  renameAccessors ifTrue: [ self addNewAccessors.        self renameAccessorsReferences ]methodBefore  < gtInspectorPresentationOrder: 34>  | variable |  variable := 'String'.  variable byteAt: 1checkInlinedMethods  numberReplaced = 0 ifTrue: [ self refactoringFailure: 'Could not inline any senders' ]addLiteralsFor: aCompiledMethod  2 to: aCompiledMethod numLiterals - 1 do: [:index |  self checkLiteral: (aCompiledMethod objectAt: index) ]problemCount  ^self numberVariablestestMethodDoesNotExist  self shouldFail: (RBAddAssignmentTransformation variable: 'variable' value: '1 asString' inMethod: #method inClass: #RBAddAssignmentTransformationTest) asRefactoringmethodBefore  | variable |  variable := 'String'asUndoOperation  ^self class definition: self changeClass classTrait oldDefinitionimplementorsOf: aSelector in: aClass storeIn: classes  (aClass directlyDefinesMethod: aSelector) ifTrue: [ classes add: aClass.        ^self ].  aClass subclasses do: [:each |  self implementorsOf: aSelector in: each storeIn: classes ]testModelMetaclass  | refactoring |  refactoring := RBAddClassVariableRefactoring model: model variable: #ClassVarName3 class: (model classNamed: #Bar) classSide.  self shouldFail: refactoringtestAddMetaclassPattern  self exampleClasses do: [:class |  (class isObsolete or: [ class superclass notNil and: [ class superclass isObsolete ] ]) ifFalse: [ | change |              change := changes defineClass: class class definition.              self assert: (change isKindOf: RBAddMetaclassChange).              self assert: change changeClassName equals: class name.              self assert: change classInstanceVariableNames equals: class class instVarNames.              self universalTestFor: change ] ]allClassVariableNames  | sprClass |  sprClass := self superclass.  ^sprClass ifNil: [ self classVariableNames ] ifNotNil: [ sprClass allClassVariableNames , self classVariableNames ]testReplaceArgumentsByPattern  | code patternCode |  code := 'foo: argMatch0 bar: argMatch1 	|tempMatch0| 	tempMatch0 := 4.	^ argMatch0, argMatch1, tempMatch0 asString'.  patternCode := 'foo: `@argMatch0 bar: `@argMatch1 	|`@tempMatch0| 	`@tempMatch0 := 4.	^ `@argMatch0, `@argMatch1, `@tempMatch0 asString'.  self assert: (RBFindAndReplaceMethodRefactoring new replaceArgumentsByPattern: code) equals: patternCodeinlineFailed  | x y q |  x := 5.  y := 10.  q := x + 1 fooMax: y.  ^qreplace: aFindString with: aReplaceString  self replace: aFindString with: aReplaceString ignoreCase: falseerrorBlockFor: aBoolean  ^condition errorBlockFor: aBoolean notinitialize  super initialize.  self matcher matchesAnyOf: #('`@object 				ifTrue: [| `@temps1 | `@.Statements1. `.Statement] 				ifFalse: [| `@temps2 | `@.Statements2. `.Statement]' '`@object 				ifTrue: [| `@temps1 | `.Statement. `@.Statements1] 				ifFalse: [| `@temps2 | `.Statement. `@.Statements2]' '`@object 				ifFalse: [| `@temps1 | `@.Statements1. `.Statement] 				ifTrue: [| `@temps2 | `@.Statements2. `.Statement]' '`@object 				ifFalse: [| `@temps1 | `.Statement. `@.Statements1] 				ifTrue: [| `@temps2 | `.Statement. `@.Statement2]') do: [:node :answer |  answer ifNil: [ | statement |              statement := node arguments first body statements last.              (statement isVariable and: [ statement = node arguments last body statements last ]) ifFalse: [ node ] ifTrue: [ nil ] ] ifNotNil: [ answer ] ]findAncestorNode  ancestorNode := cascadeNode.  [ ancestorNode parent isSequence not and: [ ancestorNode parent isAssignment ] ] whileTrue: [ ancestorNode := ancestorNode parent ].  [ ancestorNode parent isSequence not and: [ ancestorNode parent isReturn ] ] whileTrue: [ ancestorNode := ancestorNode parent ].  ancestorNode parent isSequence ifFalse: [ self refactoringFailure: 'To split this cascade, you must extract it to a temporary first' ]instVarRefsTo: instVarName in: aClass  ^RBVariableEnvironment on: self referencesToInstanceVariable: instVarName in: aClassaddPoolVariable: variableName to: aClass  ^RBAddPoolVariableChange add: variableName to: aClassstoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' with: '.  transformationBlock storeOn: aStream.  aStream nextPut: $)changeString  ^'Remove <1s>>>#<2s>' expandMacrosWith: self displayClassName with: selectorsetOption: aSymbol toUse: aBlock  self options at: aSymbol put: aBlockincludesCategory: aCategory  ^(super includesCategory: aCategory) and: [ (environment classNamesFor: aCategory) inject: false into: [:bool :each |  bool or: [ | aClass |                    aClass := self systemDictionary at: each ifAbsent: [ nil ].                    aClass == class or: [ aClass class == class ] ] ] ]printOn: aStream  aStream     nextPutAll: self displayClassName;     nextPutAll: ' removeFromSystem';     nextPut: $!whichVariableNode: aParseTree inInterval: anInterval name: aName  | matcher block |  matcher := self parseTreeSearcher.  block := [:aNode :answer |  (aNode intersectsInterval: anInterval) ifTrue: [ aNode ] ifFalse: [ answer ] ].  matcher     matches: aName do: block;     matchesArgument: aName do: block.  ^matcher executeTree: aParseTree initialAnswer: nilhierarchyDefinesMethod: aSelector  (self definesMethod: aSelector) ifTrue: [ ^true ].  ^self subclassRedefines: aSelectorcheckNodes: sequenceNodes  (sequenceNodes anySatisfy: [:each |  RBReadBeforeWrittenTester isVariable: name readBeforeWrittenIn: each ]) ifTrue: [ ^false ].  sequenceNodes do: [:each |  (self usesDirectly: each body) ifTrue: [ blockNodes add: each ] ifFalse: [ (self checkNodes: (self subblocksIn: each body)) ifFalse: [ blockNodes add: each ] ] ].  ^truechangeClass: aBehavior  super changeClass: aBehavior.  isMeta := falsedefineClass: aString  ^self addChange: (changeFactory addClassDefinition: aString)executeShould: aBlock inScopeOf: anExceptionalEvent withDescriptionNotContaining: aString  ^[ aBlock value.  false ] on: anExceptionalEvent do: [:ex |  ex return: (ex description includesSubstring: aString) not ]model: aRBSmalltalk  model := aRBSmalltalkextract: anInterval from: aSelector in: aClass  class := self classObjectFor: aClass.  selector := aSelector.  extractionInterval := anIntervaltoDoWithIncrement  | counter |  counter := 0.  1 to: 10 by: 2 do: [:i |  counter := counter + 2 ].  ^counterprotocols  ^(self allMethods flatCollect: [:each |  self protocolsFor: each selector ]) asOrderedCollectionneedsToReplaceSelfReferences  ^self hasSelfReferences or: [ self abstractVariablesRefactoring hasVariablesToAbstract ]compile: source in: class classified: aProtocol  ^self addChange: (changeFactory addMethodSource: source in: class classified: aProtocol)defaultLabel  | stream |  stream := String new writeStream.  keywords do: [:each |  stream           nextPut: $<;           nextPutAll: each;           nextPut: $>;           nextPut: $  ].  ^stream contentsoldVersionTextToDisplay  ^''abstractInstanceReferences  | replacer |  replacer := RBParseTreeRewriter variable: variableName getter: 'class ' , self accessorsRefactoring getterMethod setter: 'class ' , self accessorsRefactoring setterMethod.  self convertClasses: class withAllSubclasses select: [:aClass |  aClass whichSelectorsReferToClassVariable: variableName ] using: replacertestModel  | class |  model defineClass: 'Object subclass: #SomeClass			instanceVariableNames: ''''			classVariableNames: ''Foo'' 			poolDictionaries: ''''			category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass			instanceVariableNames: ''''			classVariableNames: ''''			poolDictionaries: ''''			category: #''Refactory-Test data'''.  class := model classNamed: #Subclass.  class compile: 'foo ^Foo' classified: #(#accessing).  (RBPushDownVariableTransformation model: model classVariable: #Foo class: class superclass) asRefactoring transform.  self deny: (class superclass directlyDefinesClassVariable: #Foo).  self assert: (class directlyDefinesClassVariable: #Foo)testNewInstanceVariableAccessors  | ref class |  ref := RBCreateAccessorsForVariableRefactoring variable: 'foo1' class: RBLintRuleTestData classVariable: false.  self executeRefactoring: ref.  class := ref model classNamed: #RBLintRuleTestData.  self denyEmpty: ref changes changes.  self assert: ref setterMethod identicalTo: #foo1:.  self assert: ref getterMethod identicalTo: #foo1.  self assert: (class parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 ^foo1').  self assert: (class parseTreeFor: #foo1:) equals: (self parseMethod: 'foo1: anObject foo1 := anObject')checkForValidTemporaryVariable  | parseTree |  parseTree := class parseTreeFor: selector.  (parseTree allTemporaryVariables includes: temporaryVariableName) ifFalse: [ self refactoringFailure: temporaryVariableName , ' isn''t a valid temporary variable name' ].  (parseTree allArgumentVariables includes: temporaryVariableName) ifTrue: [ self refactoringFailure: temporaryVariableName , ' is a block parameter' ].  (RBReadBeforeWrittenTester isVariable: temporaryVariableName readBeforeWrittenIn: parseTree) ifTrue: [ self refactoringWarning: ('<1s> is read before it is written.<n>Proceed anyway?' expandMacrosWith: temporaryVariableName) ]transformations: anObject  transformations := anObjectinlineFailed  | x y q |  x := 5.  y := 10.  q := x + 1 fooMax: y.  ^qincludesClass: aClass  (environment includesClass: aClass) ifTrue: [ ^true ].  (orEnvironment includesClass: aClass) ifTrue: [ ^true ].  (environment selectorsForClass: aClass) ifNotEmpty: [ ^true ].  (orEnvironment selectorsForClass: aClass) ifNotEmpty: [ ^true ].  ^falseduplicate: aClass name: aSymbol deep: aBoolean  | superclass superclassName name class |  (self model includesClassNamed: aSymbol) ifTrue: [ ^nil ].  superclass := aClass superclass ifNil: [ self rootClass ].  superclassName := (self model includesClassNamed: superclass name) ifFalse: [ superclass name ] ifTrue: [ (name := self execute: superclass name) = superclass name ifFalse: [ self duplicate: superclass name: name deep: aBoolean ].        name ].  self model defineClass: ('<1s>		subclass: #<2s>		instanceVariableNames: ''''		classVariableNames: ''''		poolDictionaries: ''''		category: <3p>' expandMacrosWith: superclassName with: aSymbol with: aClass category asString).  aBoolean ifTrue: [ (class := self model classNamed: aSymbol) ifNil: [ ^self ].        self copyFrom: aClass to: class.        self copyFrom: aClass classSide to: class classSide ].  ^nilrealName: aSymbol  self realClass: (Smalltalk globals at: aSymbol) classSidedefinesVariable: aVariableName  ^(self definesClassVariable: aVariableName) or: [ self definesInstanceVariable: aVariableName ]name: aClassName class: aClass subclasses: subclassCollection  className := aClassName asSymbol.  parent := self model classFor: aClass.  subclasses := subclassCollection collect: [:each |  self model classFor: each ]storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' inline: '.  sourceInterval storeOn: aStream.  aStream     nextPutAll: ' from: #';     nextPutAll: selector;     nextPutAll: ' in: '.  class storeOn: aStream.  aStream nextPut: $)setUp  super setUp.  model := self abstractVariableTestDatanumberVariables  ^self accessorMethods inject: 0 into: [:sum :each |  sum + ((self perform: each) inject: 0 into: [:s :e |  s + e size ]) ]superclassEquivalentlyDefines: aSelector  | superTree myTree |  self definingClass superclass ifNil: [ ^false ].  superTree := self definingClass superclass parseTreeFor: aSelector.  myTree := self definingClass parseTreeFor: aSelector.  (superTree isNil or: [ myTree isNil ]) ifTrue: [ ^false ].  ^superTree equalTo: myTree exceptForVariables: #()stringConcatenation  | string |  string := '' yourself.  (1 to: 10) do: [:i |  string := string , i printString ].  ^stringcaller2  ^(1 to: 10) inject: 1 into: [:sum :each |  sum * (self foo: each) ]flushCachesFor: aClass  selectorCache ifNil: [ ^self ].  aClass instanceSide withAllSubclasses do: [:each |  selectorCache           removeKey: each name ifAbsent: [  ];           removeKey: each classSide name ifAbsent: [  ] ]sourceCodeFor: aSelector  | class |  class := self whoDefinesMethod: aSelector.  class ifNil: [ ^nil ].  ^(class methodFor: aSelector) sourceliteralArrayWithTrueFalseOrNil  | a b c |  a := #(true false nil).  b := #(#true #false #nil).  c := {true .   false .   nil}.  ^{a .   b .   c}storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' extract: '''.  sourceCode storeOn: aStream.  aStream     nextPutAll: ''' from: #';     nextPutAll: selector asString;     nextPutAll: ' to: #';     nextPutAll: newSelector asString;     nextPutAll: ' in: '.  class storeOn: aStream.  aStream nextPut: $)storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' variable: '.  variableName storeOn: aStream.  aStream nextPutAll: ' class: '.  className storeOn: aStream.  aStream nextPutAll: ' classVariable: '.  isClassVariable storeOn: aStream.  aStream nextPut: $)abstractReferenceTo: instVar  transformations add: (RBAddVariableAccessorTransformation model: self model instanceVariable: instVar class: newClassName).  transformations add: ((RBRemoveDirectAccessToVariableTransformation model: self model instanceVariable: instVar class: class) receiver: referenceVariableName).  transformations add: (RBRemoveVariableTransformation model: self model instanceVariable: instVar class: class)testNewClassVariableAccessors  | ref class |  ref := RBCreateAccessorsForVariableRefactoring variable: 'Foo1' class: RBLintRuleTestData classVariable: true.  self executeRefactoring: ref.  class := ref model metaclassNamed: #RBLintRuleTestData.  self denyEmpty: ref changes changes.  self assert: ref setterMethod identicalTo: #foo1:.  self assert: ref getterMethod identicalTo: #foo1.  self assert: (class parseTreeFor: #foo1) equals: (self parseMethod: 'foo1 ^Foo1').  self assert: (class parseTreeFor: #foo1:) equals: (self parseMethod: 'foo1: anObject Foo1 := anObject')printOn: aStream  aStream     nextPutAll: definition;     nextPut: $!missingYourself  ^OrderedCollection new     add: 1;     add: 2;     removeFirsttestVariableDoesNotExist  self shouldFail: (RBAddAssignmentTransformation variable: 'variable1' value: '1 asString' inMethod: #methodBefore inClass: #RBAddAssignmentTransformationTest) asRefactoringincludesClass: aClass  ^(aClass isMeta ifTrue: [ metaClasses includes: aClass soleInstance name ] ifFalse: [ classes includes: aClass name ]) and: [ super includesClass: aClass ]addClass: aClass selector: aSymbol  (aClass isMeta ifTrue: [ metaClassSelectors at: aClass soleInstance name ifAbsentPut: [ IdentitySet new ] ] ifFalse: [ classSelectors at: aClass name ifAbsentPut: [ IdentitySet new ] ]) add: aSymbolpackages  ^self classes collect: #packagestoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream nextPutAll: ' class: '.  class storeOn: aStream.  aStream nextPutAll: ' instanceVariables: '.  instanceVariables asArray storeOn: aStream.  aStream     nextPutAll: ' newClassName: #';     nextPutAll: newClassName;     nextPutAll: ' referenceVariableName: ''';     nextPutAll: referenceVariableName;     nextPutAll: ''')'sendersOf: aSelector in: aClass  class := self classObjectFor: aClass.  selector := aSelector.  numberReplaced := numberNotReplaced := 0preconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition withBlock: [ self                 findSequenceNode;                 findStatementNodes;                 findReceiverNode.              true ])category  ^category ifNil: [ self isDefined ifTrue: [ category := self realClass category ] ifFalse: [ model environment whichCategoryIncludes: self name ] ]storeOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' return: ''';     nextPutAll: returnValue;     nextPutAll: ''' inMethod: ''';     nextPutAll: selector;     nextPutAll: ''' inClass: '.  class storeOn: aStream.  aStream nextPut: $)subclassDefiningVariable  | subclasses |  subclasses := class allSubclasses select: [:each |  each isMeta not and: [ each directlyDefinesClassVariable: variableName ] ].  subclasses ifEmpty: [ self refactoringFailure: 'Could not find a class defining ' , variableName ].  subclasses size > 1 ifTrue: [ self refactoringError: 'Multiple subclasses define ' , variableName ].  ^subclasses asArray firstdefinesPoolDictionary: aSymbol  (self directlyDefinesPoolDictionary: aSymbol) ifTrue: [ ^true ].  ^self inheritsPoolDictionaries and: [ self superclass notNil and: [ self superclass definesPoolDictionary: aSymbol ] ]className: aClassName newClassName: aNewClassName  self className: aClassName.  newClassName := aNewClassNamestoreOn: aStream  aStream nextPut: $(.  self class storeOn: aStream.  aStream     nextPutAll: ' rename: ''';     nextPutAll: variableName;     nextPutAll: ''' to: ''';     nextPutAll: newName;     nextPutAll: ''' in: '.  class storeOn: aStream.  aStream nextPut: $)isComposite  ^trueremoveClass: aRBClass  self removeClassNamed: aRBClass nametestMethodAlreadyExists  self     shouldFail: (RBAddMethodTransformation sourceCode: 'printString ^super printString' in: #RBBasicLintRuleTestData withProtocol: #accessing) asRefactoring;     shouldFail: (RBAddMethodTransformation model: model sourceCode: 'classVarName1 ^super printString' in: (model classNamed: #Bar) withProtocol: #accessing) asRefactoring;     shouldFail: (RBAddMethodTransformation model: model sourceCode: 'printString ^super printString' in: (model classNamed: #Bar) withProtocol: #accessing) asRefactoringextractMethodRefactoring  ^RBExtractMethodRefactoring new     setOption: #useExistingMethod toUse: [:ref :selector |  UIManager default confirm: 'Do you want use existing method ' , selector printString , '?' label: 'Warninig' ];     yourselftestInlineComponentIntoCascadedMessage  | refactoring |  self proceedThroughWarning: [ refactoring := RBInlineMethodFromComponentRefactoring inline: (35 to: 79) inMethod: #inlineComponent forClass: RBRefactoryTestDataApp.        (refactoring model classNamed: #Behavior) compile: 'hasImmediateInstances ^self format = 0' classified: #(#accessing).        self setupInlineExpressionFor: refactoring toReturn: false.        self executeRefactoring: refactoring ].  self assert: ((refactoring model classNamed: #RBRefactoryTestDataApp) parseTreeFor: #inlineComponent) equals: (self parseMethod: 'inlineComponent	| a aBehavior |	a := 5.	aBehavior := a class.	aBehavior superclass.	aBehavior format = 0.	^aBehavior yourself')method2  ^self method1executeShould: aBlock inScopeOf: anExceptionalEvent  ^[ aBlock value.  false ] on: anExceptionalEvent do: [:ex |  ex return: true ]testAddParameterThatReferencesModelGlobal  | refactoring class |  refactoring := RBAddParameterRefactoring model: model addParameterToMethod: ('test' , 'Foo:') asSymbol in: RBRefactoryTestDataApp newSelector: #testFoo:bar: initializer: 'Bar new'.  self proceedThroughWarning: [ self executeRefactoring: refactoring ].  class := refactoring model classNamed: #RBRefactoryTestDataApp.  self assert: (class parseTreeFor: #testFoo:bar:) equals: (self parseMethod: 'testFoo: anObject bar: anObject1								^self class + anObject').  self assert: (class parseTreeFor: #callFoo) equals: (self parseMethod: 'callFoo ^self testFoo: 5 bar: (Bar new)').  self deny: (class directlyDefinesMethod: ('test' , 'Foo:') asSymbol)buildTransformations  ^transformations ifNil: [ transformations := OrderedCollection with: (RBAddClassTransformation addClass: self tmpName superclass: className asSymbol subclasses: #() category: (self model classNamed: className) category) with: (RBRenameClassTransformation new className: className newClassName: newClassName) with: (RBRenameClassTransformation new className: self tmpName newClassName: className) with: (RBDeprecateClassTransformation class: className) ]testRefactoring  | refactoring class |  refactoring := (RBProtectVariableTransformation instanceVariable: 'builder' class: #RBTransformationRuleTestData) asRefactoring transform.  class := refactoring model classNamed: #RBTransformationRuleTestData.  self assert: (class parseTreeFor: #builder) equals: (self parseMethod: 'builder ^builder').  self assert: (class parseTreeFor: #builder:) equals: (self parseMethod: 'builder: anObject	builder := anObject').  self assert: (class parseTreeFor: #viewResults) equals: (self parseMethod: 'viewResults		self builder inspect.		self resetResult').  self assert: (class parseTreeFor: #checkMethod:) equals: (self parseMethod: 'checkMethod: aSmalllintContext 	class := aSmalllintContext selectedClass.	(rewriteRule executeTree: aSmalllintContext parseTree) 		ifTrue: 			[(RecursiveSelfRule executeTree: rewriteRule tree initialAnswer: false) 				ifFalse: 					[self builder 						compile: rewriteRule tree printString						in: class						classified: aSmalllintContext protocols]]')name: aString  name := aStringpullUp: selectorCollection from: aClass  self pullUp: selectorCollection from: aClass to: aClass superclassreparentSubclasses  self model reparentClasses: subclasses to: self abstractSuperclasscodeCruftLeftInMethods  < haltOrBreakpointForTesting>  | a b c |  a := b := c := 2.  self halt.  ^a > 0 ifTrue: [ b ] ifFalse: [ c ]extraBlock  ^[:arg |  arg + 43 ] value: 45testDefinesPoolDictionary  self deny: (objectClass definesPoolDictionary: #OpcodePool).  self assert: (newClass definesPoolDictionary: #TextConstants).  self deny: (messageNodeClass definesPoolDictionary: #OpcodePool).  self assert: ((RBClassModelFactory rbNamespace new classNamed: #Text) definesPoolDictionary: #TextConstants)problemCount  ^self numberClassesexecute: aString replace: aRegex with: aReadStream  | stream |  ^aRegex copy: aString translatingMatchesUsing: [:match |  stream := WriteStream on: (String new: 2 * aString size).        [ aReadStream atEnd ] whileFalse: [ stream nextPutAll: (aReadStream upTo: $$).              aReadStream atEnd ifFalse: [ aReadStream peek isDigit ifFalse: [ stream nextPut: aReadStream next ] ifTrue: [ stream nextPutAll: (aRegex subexpression: aReadStream next asInteger - $0 asInteger + 1) ] ] ].        aReadStream reset.        stream contents ]comment: aString in: aClassName  self className: aClassName.  comment := aStringtestMethodDoesNotExist  | transformation |  transformation := (RBRemoveSubtreeTransformation code: 'selector := aSelector' from: #two in: self changeMock name) transform.  self assertEmpty: transformation model changes changes.  self shouldFail: (RBRemoveSubtreeTransformation code: 'selector := aSelector' from: #selector:for: in: #RBRemoveMethodTransformation) asRefactoringdefaultEnvironment  ^RBBrowserEnvironment newfullBlocks  ^[ thisContext ]preconditions  ^RBCondition directlyDefinesInstanceVariable: variableName in: classtestVariableAlreadyExists  self shouldFail: (RBMoveInstanceVariableToClassTransformation model: model variable: 'result' fromClass: #RBFooLintRuleTestData toClass: #RBBasicLintRuleTestData) asRefactoringprivateIncludesSelector: aSelector inClass: aClass  ^(self privateSelectorsForClass: aClass) includes: aSelectorselector: aSymbol  selector := aSymbol asSymbol.  self changed: #selectorcondition: aBlock  condition := aBlockcopyExtensionMethods  (self instanceSideExtensionMethodsOf: deprecatedClass) do: [:each |  self newClass instanceSide compile: each source classified: each protocols ].  (self classSideExtensionMethodsOf: deprecatedClass) do: [:each |  self newClass classSide compile: each source classified: each protocols ]instanceVariablesFor: aClass  ^aClass instVarNamestestNonExistantName  self shouldFail: (RBPullUpClassVariableRefactoring variable: #Foo class: RBLintRuleTestData)parseTree  ^self parserClass parseMethod: self source onError: [:str :pos |  ^nil ]parserTreeSearcher  ^self parseTreeSearcherClass newchangeString  ^'Remove pool variable <1s> from <2s>' expandMacrosWith: self variable with: self displayClassNametestInvalidSubclass  self shouldFail: (RBAddClassRefactoring addClass: #Foo superclass: RBCompositeLintRuleTestData subclasses: (Array with: RBBasicLintRuleTestData) category: #'Refactory-Tesing')preconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition isValidInstanceVariableName: newVariableName for: class) & (RBCondition withBlock: [ self verifySelectedInterval.              self checkVariableName.              true ])preconditions  ^(RBCondition isMetaclass: class) not & (RBCondition directlyDefinesClassVariable: variableName asSymbol in: class) & ((RBCondition withBlock: [ (#(#Object #Behavior #ClassDescription #Class) includes: class name) not ]) errorMacro: 'This refactoring does not work for Object, Behavior, ClassDescription, or Class')addClassVariable: variableName to: aClass  ^self addChange: (changeFactory addClassVariable: variableName to: aClass)testRefactoring  | refactoring class |  refactoring := (RBRemoveMessageSendTransformation messageSend: #byteAt: inMethod: #methodBefore inClass: #RBRemoveMessageSendTransformationTest) asRefactoring transform.  self assert: refactoring model changes changes size equals: 1.  class := refactoring model classNamed: #RBRemoveMessageSendTransformationTest.  self assert: (class parseTreeFor: #methodBefore) body equals: (class parseTreeFor: #methodAfter) bodyusesAdd  ^(1 to: 10) asOrderedCollection addAll: (11 to: 20)preconditions  ^(RBCondition withBlock: [ self definingClass isNotNil ] errorString: 'No such class or trait named ' , class asString) & (RBCondition definesSelector: selector in: self definingClass) & (RBCondition withBlock: [ self definingMethod allTemporaryVariables includes: variableName ] errorString: 'Method named ' , selector , ' does not define a temporary variable named ' , variableName) & (RBCondition withBlock: [ (self definingMethod allArgumentVariables includes: variableName) not ] errorString: 'Variable named ' , variableName , ' cannot be removed because it is an argument in this method') & (RBCondition withBlock: [ (self checkBlocksIn: self definingBlock) not ] errorString: 'Variable named ' , variableName , ' is already bound tightly as possible.') & (RBCondition withBlock: [ self checkLocationsIn: (self checkAllBlocksIn: self definingBlock) ] errorString: 'Variable named ' , variableName , ' is used in an outside block.')computeVariablesToAbstract  | searcher |  instVarReaders := Set new.  instVarWriters := Set new.  classVarReaders := Set new.  classVarWriters := Set new.  searcher := self parseTreeSearcher.  searcher     matches: '`var := ``@anything' do: [:aNode :answer |  self processAssignmentNode: aNode ];     matches: '`var' do: [:aNode :answer |  self processReferenceNode: aNode ].  searcher executeTree: tree.  self removeDefinedClassVariablestestFoo: anObject  ^self class + anObjectresult: aResult  result := aResult copyEmptyasSelectorEnvironment  | s |  s := RBSelectorEnvironment new.  s label: self label.  environmentDictionaries do: [:each |  | env |        env := each asSelectorEnvironment.        env classesDo: [:cls |  env selectorsForClass: cls do: [:sel |  s addClass: cls selector: sel ] ] ].  ^screateNewClass  self     addClass;     addInstanceVariablesjustSendsSuper  super justSendsSuperclass: aClass instanceVariables: instVars newClassName: className referenceVariableName: newVariable  class := self model classObjectFor: aClass.  instanceVariables := instVars.  newClassName := className.  referenceVariableName := newVariablechangeForClass: aClassName selector: aSelector  ^nilsetUp  super setUp.  model := self abstractVariableTestDatasetUp  super setUp.  model := self abstractVariableTestDataskip  TestSkip signaltestMethodAlreadyDefined  | method someClass |  someClass := model classNamed: #RBFooLintRuleTestData.  method := RBClassModelFactory rbMethod for: someClass source: 'foo' , String cr , String tab , '^ 6' selector: #foo.  self shouldFail: (RBMoveMethodToClassRefactoring method: method class: someClass)parseMethod: aString  ^[ self parserClass parseMethod: aString ] on: Error do: [:err |  nil ]difference  ^differencepoolVariableNamesIn: poolName  ^(Smalltalk globals at: poolName ifAbsent: [ Dictionary new ]) classPool keys collect: [:name |  name asString ]findOcurrencesIn: aMethod of: aClass  | methodNode matches sourceCode |  methodNode := (aClass >> aMethod) sourceNode.  sourceCode := methodNode sourceCode.  matches := Set new.  (self nodesOf: methodNode) do: [:each |  each first < each last ifTrue: [ self match: (RBPatternParser parseExpression: (sourceCode copyFrom: each first to: each last)) with: each first and: each last in: matches ] ].  methodNode body nodesDo: [:node |  self match: node with: node start and: node stop in: matches ].  ^matchespreconditions  ^(RBCondition definesSelector: selector in: self definingClass) & (RBCondition withBlock: [ | tree |              tree := self parserClass parseExpression: oldSourceCode onError: [:string :pos |  self refactoringError: 'Invalid source to extract - ' , string ].              tree ifNil: [ self refactoringError: 'Invalid source to extract - ' , oldSourceCode ].              (tree isSequence and: [ tree statements isEmpty ]) ifTrue: [ self refactoringError: 'Selected code to extract is empty' ].              tree := ((self definingClass parseTreeFor: selector) extractSubtreeWith: oldSourceCode) ifNil: [ self refactoringError: 'Could not extract code from method ' , selector ].              true ]) & (RBCondition withBlock: [ self parserClass parseExpression: newSourceCode onError: [:string :pos |  self refactoringError: 'Invalid source to add - ' , string ].              true ])packages  ^environment packages & andedEnvironment packagesshould: aBlock  self assert: aBlock valuemsg4  ^Var1options  ^options ifNil: [ self class refactoringOptions ] ifNotNil: [ options ]addNewVariable  (RBAddClassVariableChange add: newName to: self changeClass) executesharedPools  ^self allPoolDictionaryNames collect: [:each |  Smalltalk globals at: each asSymbol ifAbsent: [ Dictionary new ] ]method: anObject1 with: anObject2 lots: anObject3 of: anObject4 arguments: anObject5  ^anObject5 + anObject1 > (anObject4 - anObject2 + anObject3)valueIndex  ^selectedValueIndex ifNil: [ selectedValueIndex := 0 ]removeClass: aClass  aClass isMeta ifTrue: [ metaClasses remove: aClass soleInstance name ifAbsent: [  ] ] ifFalse: [ classes remove: aClass name ifAbsent: [  ] ]removeOldVariable  self flag: #todo.  (RBRemoveClassVariableChange remove: oldName from: self changeClass) executeprintOn: aStream  aStream     nextPut: $!;     nextPutAll: self displayClassName;     nextPutAll: ' methodsFor: ''';     nextPutAll: self protocol;     nextPutAll: ''' stamp: ';     print: self changeStamp;     nextPut: $!;     cr;     nextPutAll: (source copyReplaceAll: '!' with: '!!');     nextPutAll: '! !'fileBlocks  | file |  ^[ file := 'asdf' asFileReference readStream.  file contents ] ensure: [ file close ]checkClass: aClass  sharedPoolNames  ^self privatePoolDictionaryNames copydefinitionClass  self subclassResponsibilitytestMethodDoesNotExist  self shouldFail: (RBRemoveMessageSendTransformation messageSend: #byteAt: inMethod: #method inClass: #RBRemoveMessageSendTransformationTest) asRefactoringisMeta  ^falsetestModelAddClass  | refactoring newClass superClass subclass |  subclass := model classNamed: #Bar.  superClass := model classNamed: #Foo.  refactoring := RBAddClassRefactoring model: model addClass: #FooTest superclass: superClass subclasses: (Array with: subclass) category: #'Refactory-Testing'.  self executeRefactoring: refactoring.  newClass := model classNamed: #FooTest.  self assert: newClass superclass equals: superClass.  self assert: (superClass subclasses includes: newClass).  self assert: newClass classSide superclass equals: superClass classSide.  self assert: (superClass classSide subclasses includes: newClass classSide).  self assert: subclass superclass equals: newClass.  self assert: (newClass subclasses includes: subclass).  self assert: subclass classSide superclass equals: newClass classSide.  self assert: (newClass classSide subclasses includes: subclass classSide)anInstVar  ^anInstVarprivateTransform  self     createGetterAccessor;     createSetterAccessorthreeElementPoint  ^(5 @ 5 + 6) @ 6isEmpty  self subclassResponsibilitypreconditions  ^(RBCondition definesSelector: selector in: class) & (RBCondition withBlock: [ self                 findCascadeNode;                 findAncestorNode;                 findMessageNodes.              true ])defineGetterMethod  | selector |  selector := self safeMethodNameFor: self definingClass basedOn: variableName asString.  self definingClass compile: ('<1s><r><t>^ <2s>' expandMacrosWith: selector with: variableName) classified: #(#accessing).  ^selectorname  ^nameisEmpty  ^falsetemporaryVariableCapitalization  | Capital |  Capital := 'Bern'.  ^Capitaltransform  self createAccessors.  self abstractReferencesinstanceVariables  ^instanceVariablestestMetaclassFailure  self shouldFail: (RBRemoveDirectAccessToVariableTransformation classVariable: #RecursiveSelfRule class: RBTransformationRuleTestData class) asRefactoringpreconditionsOf: aClass  ^(RBCondition withBlock: [ self checkIsSubclass: aClass.        true ]) & (RBCondition withBlock: [ self checkIsAbstractMethod.              true ]) & (RBCondition withBlock: [ self checkOverridesSelectorInClass: aClass.              true ])match: node with: first and: last in: matches  self matchNodes do: [:matchNode |  [ matchNode match: node onSuccess: [:map |  matches add: (first to: last) -> map ] onFailure: [  ] ] on: Exception do: [:e |  e ] ]methodName  ^String streamContents: [:s |  self printOn: s ]combinations  ^combinationsselectorsDo: aBlock  self allClassesDo: [:each |  self selectorsForClass: each do: aBlock ]testMetaClassFailure  self shouldFail: (RBPullUpClassVariableRefactoring variable: #RecursiveSelfRule class: RBLintRuleTestData class)testInlineTemporaryBadInterval  self shouldFail: (RBInlineTemporaryRefactoring inline: (29 to: 100) from: #moveDefinition in: RBRefactoryTestDataApp)renameConflictingTemporary: aName  | allNames newName index seqNode |  allNames := Set new     addAll: inlineParseTree allDefinedVariables;     yourself.  allNames remove: aName ifAbsent: [  ].  seqNode := sourceMessage.  [ seqNode isSequence ] whileFalse: [ seqNode := seqNode parent ].  allNames addAll: seqNode allDefinedVariables.  newName := aName.  index := 0.  [ (sourceMessage whoDefines: newName) notNil or: [ (class hierarchyDefinesVariable: newName) or: [ allNames includes: newName ] ] ] whileTrue: [ index := index + 1.        newName := aName , index printString ].  newName = aName ifFalse: [ self renameTemporary: aName to: newName ].  ^newNamenotifyUserOfCommand: aCommand  UIManager default abort: self messageTextshouldCopyExtensions  ^shouldCopyExtensionstempsReadBeforeWritten  | temp |  self isVariable ifTrue: [ temp := 4 ].  ^tempsomeMethod  ^'a String'hasOnlySelfReturns  ^hasOnlySelfReturns ifNil: [ | searcher |        searcher := self parseTreeSearcher.        searcher           matches: '^self' do: [:aNode :answer |  answer ];           matches: '^`@object' do: [:aNode :answer |  false ].        hasOnlySelfReturns := searcher executeTree: parseTree initialAnswer: true ] ifNotNil: [ hasOnlySelfReturns ]tempVarOverridesInstVar  | temporaryVariable |  temporaryVariable := 4.  ^temporaryVariableliteralArrayCharacters  ^#($a $b $c) includes: $aoptions: aDictionary  options := aDictionarypreconditions  ^variables inject: RBCondition empty into: [:condition :variable |  condition & (RBCondition definesInstanceVariable: variable in: self theClass) ]isEmpty  ^result isEmptytestBadInterval  self     shouldFail: (RBExtractToTemporaryRefactoring extract: (24 to: 30) to: 'asdf' from: #testMethod in: RBRefactoryTestDataApp);     shouldFail: (RBExtractToTemporaryRefactoring extract: (14 to: 105) to: 'asdf' from: #testMethod1 in: RBRefactoryTestDataApp);     shouldFail: (RBExtractToTemporaryRefactoring extract: (61 to: 101) to: 'asdf' from: #noMoveDefinition in: RBRefactoryTestDataApp)definesClass: aClass  ^environment definesClass: aClasspreconditions  ^RBCondition emptyproblemCount  ^builder problemCountinheritsPoolDictionaries  ^falseclass: aClass source: aString contoller: aController  self changeClass: aClass.  source := aString.  self protocols: (RBBrowserEnvironment new whichProtocolIncludes: self selector in: aClass).  controller := aControllertestModelPushDownVariable  | class |  model defineClass: 'Object subclass: #SomeClass instanceVariableNames: '''' classVariableNames: ''Foo'' poolDictionaries: '''' category: #''Refactory-Test data'''.  model defineClass: 'SomeClass subclass: #Subclass instanceVariableNames: '''' classVariableNames: '''' poolDictionaries: '''' category: #''Refactory-Test data'''.  class := model classNamed: #Subclass.  class compile: 'foo ^Foo' classified: #(#accessing).  self executeRefactoring: (RBPushDownClassVariableRefactoring model: model variable: #Foo class: class superclass).  self deny: (class superclass directlyDefinesClassVariable: #Foo).  self assert: (class directlyDefinesClassVariable: #Foo)renameMethod: aSelector in: aClass to: newSel permutation: aMap  oldSelector := aSelector asSymbol.  newSelector := newSel asSymbol.  class := self classObjectFor: aClass.  permutation := aMapinlineLast  5 = 3 ifTrue: [ ^self caller ] ifFalse: [ ^self caller2 ]renameTemporary: oldName to: newName  | rewriter |  rewriter := RBParseTreeRewriter new.  rewriter     replace: oldName with: newName;     replaceArgument: oldName with: newName.  (rewriter executeTree: inlineParseTree) ifTrue: [ inlineParseTree := rewriter tree ]parseTreeSearcherClass  ^RBParseTreeSearchertestTransform  | transformation class |  self assert: self changeMock category equals: #'Refactoring-Tests-Changes'.  transformation := (RBMoveClassTransformation move: self changeMock name to: #'Refactoring2-Transformations-Test') transform.  self assert: transformation model changes changes size equals: 1.  class := transformation model classNamed: self changeMock name asSymbol.  self assert: class category equals: #'Refactoring2-Transformations-Test'includesCategory: aCategory  ^(super includesCategory: aCategory) and: [ (environment classNamesFor: aCategory) inject: false into: [:bool :each |  bool or: [ | class |                    class := self systemDictionary at: each ifAbsent: [ nil ].                    class notNil and: [ (self includesClass: class) or: [ self includesClass: class class ] ] ] ] ]methodBefore  | variable |  variable := 'String'comment: aString  self model changes comment: (comment := aString) in: selftearDown  self removeMockClass.  super tearDownpreconditions  ^(RBCondition definesClassVariable: variableName in: class) & (RBCondition withBlock: [ self findDestinationClass.              true ])isMultiEnvironment  ^trueonSystemDictionary: anObject  onSystemDictionary := anObject