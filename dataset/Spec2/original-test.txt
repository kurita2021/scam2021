method: aMethod  method := aMethod-=JUAMPI=-taskbarIcon  ^self windowIcon ifNil: [ self presenter ifNil: [ super taskbarIcon ] ifNotNil: #taskbarIcon ]-=JUAMPI=-label  ^self presenter label-=JUAMPI=-selectedItems  | wrappers items |  wrappers := listPresenter listItems.  items := wrappers collect: [:e |  | value |        value := associationsWrapperToItem at: e ifAbsent: [ nil ].        (value isNil or: [ e state not ]) ifTrue: [ nil ] ifFalse: [ value ] ] thenSelect: [:e |  e notNil ].  ^items-=JUAMPI=-whenSelectedItemsChanged: aBlock  self deprecated: 'Use #whenSelectionChangedDo: instead' transformWith: '`@receiver whenSelectedItemsChanged: `@argument' -> '`@receiver whenSelectionChangedDo: [ :selection | `@argument cull: selection selectedItems ]'.  self selection whenChangedDo: [:selection |  aBlock cull: selection selectedItems ]-=JUAMPI=-adoptMenuItemModel: item accumulator: controls  item subMenu ifNil: [ | button |        button := self buildButtonFor: item.        controls add: button ] ifNotNil: [ self emptyAccumulator: controls.        widget addMorphBack: (self theme newToolSpacerIn: widget).        widget add: item name font: self theme menuBarFont icon: item icon help: item description subMenu: item subMenu buildWithSpecAsPopup.        widget addMorphBack: (self theme newToolSpacerIn: widget) ]-=JUAMPI=-addPage: each to: aNotebook  aNotebook addLazyPage: [ self buildContentForPage: each ] label: (self buildLabelForPage: each).  aNotebook pages last model: each-=JUAMPI=-spec: anObject  spec := anObject-=JUAMPI=-widget  ^self adapter widget-=JUAMPI=-display: aBlock  ^self list display: aBlock-=JUAMPI=-listModel  self deprecated: 'It is not wise to allow external user access the content of a sub presenter. If this is accessed directly, the behavior should probably be moved to the MessageBrowser.'.  ^messageList listModel-=JUAMPI=-hasContentToShow  ^self nodeModel hasContentToShow-=JUAMPI=-testSelectPresenterItemSetsSelectedIndexInWidget  presenter selectItem: 20.  self assert: (self adapter selectedIndexes includes: 2)-=JUAMPI=-testSubscriptionsAreTransfered  | count |  count := 0.  presenter beMultipleSelection.  presenter whenSelectionChangedDo: [ count := count + 1 ].  presenter beSingleSelection.  presenter selectIndex: 2.  self assert: count equals: 1-=JUAMPI=-rememberMe: anObject  rememberMe := anObject-=JUAMPI=-isOverlay  ^overlay = true-=JUAMPI=-testStartsWithoutSelection  self assert: self adapter selectedItem equals: nil-=JUAMPI=-fileOutClass: aClass from: aChangeSet  | aSet |  aSet := ChangeSet newChangeSet: aClass name.  aSet ifNil: [ ^self ].  aSet absorbClass: aClass name from: aChangeSet.  aSet fileOut.  ChangeSet removeChangeSet: aSet-=JUAMPI=-open  self presenter windowIsOpening-=JUAMPI=-leftOffset  ^layoutFrame leftOffset-=JUAMPI=-testSelectManyIndexesKeepsLastSelectionInWidget  presenter selectIndex: 1.  presenter selectIndex: 2.  self assert: self adapter selectedIndexes equals: #(2)-=JUAMPI=-testInitialSelectedTab  self assert: presenter selectedTab equals: nil.  presenter addTab: redTab.  self assert: presenter selectedTab equals: redTab.  presenter addTab: self redMorphTab.  self assert: presenter selectedTab equals: redTab-=JUAMPI=-whenSelectionIndexChanged: aBlock  self list whenSelectionIndexChanged: aBlock-=JUAMPI=-testDayBeforeMonthOf  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 9 day: 1)) equals: 6.  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 9 day: 14)) equals: 6.  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 9 day: 30)) equals: 6.  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 10 day: 1)) equals: 1.  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 10 day: 17)) equals: 1.  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 10 day: 30)) equals: 1-=JUAMPI=-testSelectPathSetsSelectedItem  presenter selectPath: #(1 3).  self assert: presenter selection selectedItem equals: 10-=JUAMPI=-initializeWindow  self presenter initializeWindow: self-=JUAMPI=-morph  ^self widget-=JUAMPI=-applyTo: aMorph  -=JUAMPI=-selectedPaths  ^selection-=JUAMPI=-newText  ^self instantiate: SpTextPresenter-=JUAMPI=-wantsVisualFeedback  ^wantsVisualFeedback-=JUAMPI=-setFocus  self focusOrder     add: changesListPresenter;     add: classesListPresenter;     add: methodsListPresenter;     add: textPresenter-=JUAMPI=-testActivationOnDoubleClickShouldActivateOnDoubleClick  | activatedItem |  activatedItem := nil.  presenter     activateOnDoubleClick;     whenActivatedDo: [:selection |  activatedItem := selection selectedItem ].  presenter doubleClickAtIndex: 1.  self assert: activatedItem equals: 10-=JUAMPI=-aboutToStyle: aBoolean  self deprecated: 'Use #withSyntaxHighlight, #withoutSyntaxHighlight or #syntaxHighlight: instead.' transformWith: '`@receiver aboutToStyle: `@argument' -> '`@receiver syntaxHighlight: `@argument'.  self syntaxHighlight: aBoolean-=JUAMPI=-execute  self evaluateSelectionAndDo: [:result |  self inspectObject: result ]-=JUAMPI=-contextMenu  ^contextMenu-=JUAMPI=-updatePresenter  self modelChanged-=JUAMPI=-testIconNameFrom  self assert: command iconProvider equals: Smalltalk ui icons.  command iconName: #banana from: self.  self assert: command iconProvider equals: self.  self assert: command icon equals: self banana-=JUAMPI=-resizerWidth  ^self model resizerWidth-=JUAMPI=-whenCurrentActivatedChanged: aBlock  self deprecated: 'Use #whenCurrentActivatedChangedDo: instead.' transformWith: '`@receiver whenCurrentActivatedChanged: `@statements' -> '`@receiver whenCurrentActivatedChangedDo: `@statements'.  self whenCurrentActivatedChangedDo: aBlock-=JUAMPI=-menuColumn: column row: rowIndex  | menuPresenter |  menuPresenter := self model contextMenu.  menuPresenter ifNil: [ ^nil ].  ^SpBindings value: self model application adapterBindings during: [ menuPresenter value buildWithSpec ]-=JUAMPI=-resizingSetSelector  ^layout isHorizontal ifTrue: [ #hResizing: ] ifFalse: [ #vResizing: ]-=JUAMPI=-leftLabel  ^leftLabel-=JUAMPI=-whenNumberTypeChangedDo: aBlock  self property: #numberType whenChangedDo: aBlock-=JUAMPI=-setSelectedItem: anItem  self deprecated: 'Use #selectedItem: instead' transformWith: '`@receiver setSelectedItem: `@argument' -> '`@receiver selectedItem:`@argument'.  ^self selectedItem: anItem-=JUAMPI=-oldPage: anObject  oldPage := anObject-=JUAMPI=-registerClassShortcuts: aWidget  aWidget bindKeyCombination: PharoShortcuts current browseShortcut toAction: [ self selectedClass ifNotNil: [ self browseMethodFull ] ].  aWidget bindKeyCombination: $d meta toAction: [ self selectedClass ifNotNil: [ self forgetClass ] ].  aWidget bindKeyCombination: PharoShortcuts current removeShortcut toAction: [ self selectedClass ifNotNil: [ self removeClass ] ]-=JUAMPI=-action: aBlock  action := aBlock-=JUAMPI=-presenterAt: aName  ^self basicPresenters at: aName-=JUAMPI=-initialize  super initialize.  self withSyntaxHighlight.  self registerEventsForStyling.  self contextMenu: self buildCodeMenu.  self contextKeyBindings: self buildCodeKeyBindings-=JUAMPI=-y: anObject  y := anObject-=JUAMPI=-iconName: aSymbol  self icon: (self iconNamed: aSymbol)-=JUAMPI=-pages  ^layout presenters-=JUAMPI=-isMultipleSelection  ^true-=JUAMPI=-whenCurrentlyActivatedChanged: aBlock  self deprecated: 'Use #whenCurrentlyActivatedChangedDo: instead.' transformWith: '`@receiver whenCurrentlyActivatedChanged: `@statements' -> '`@receiver whenCurrentlyActivatedChangedDo: `@statements'.  self whenCurrentlyActivatedChangedDo: aBlock-=JUAMPI=-passenger  ^[ self model passenger ]-=JUAMPI=-objectClassPage  ^SpNotebookPage title: 'Object class' icon: (self iconNamed: #nautilusIcon) provider: [ MessageBrowser new messages: Object methods ]-=JUAMPI=-pathOfItem: anItem root: aRoot  aRoot isExpanded ifFalse: [ ^#() ].  (aRoot children includes: anItem) ifTrue: [ ^{(aRoot children indexOf: anItem)} ].  aRoot children withIndexDo: [:aChild :index |  | aSubPath |        aSubPath := self pathOfItem: anItem root: aChild.        aSubPath ifNotEmpty: [ ^{index} , aSubPath ] ].  ^#()-=JUAMPI=-askOkToClose  ^askOkToClose-=JUAMPI=-expandAll  self changed: #expandAll with: #()-=JUAMPI=-configureButton: aButton item: aToolbarItem  self subclassResponsibility-=JUAMPI=-buildWidget  ^SpTransferMorph new     model: self;     passenger: self passenger;     source: self source;     yourself-=JUAMPI=-value  ^self presenter value-=JUAMPI=-buildWidget  ^SpStubTreeView new-=JUAMPI=-drawOn: aCanvas  | area |  area := self innerBounds.  aCanvas fillRectangle: area fillStyle: self fillStyle.  value > 0 ifTrue: [ cachedWidth := self completedWidth.        area := (area left + (cachedWidth - (area width / 2.5))) @ area top corner: area origin + (cachedWidth @ area height).        aCanvas fillRectangle: area fillStyle: self barFillStyle ].  self borderStyle frameRectangle: self bounds on: aCanvas-=JUAMPI=-askBeforeChanging  ^self model askBeforeChanging-=JUAMPI=-isEmpty  ^self items isEmpty-=JUAMPI=-content  ^'I am a modal demo with default actions buttons. I set closeOnBackdropClick to true (which is the default value) to close the modal if the user click on the backdrop of the modal. This will trigger the cancel action of the modal.'-=JUAMPI=-headerTitle: aString  headerTitle := aString-=JUAMPI=-maxWidth: aNumber  self maxExtent: aNumber @ self maxExtentOrDefault y-=JUAMPI=-includesIndex: anIndex  ^self selectedIndexes includes: anIndex-=JUAMPI=-addItemLeft: aMorph  leftPanel addMorphBack: (aMorph           vResizing: #spaceFill;           yourself)-=JUAMPI=-selectPaths: pathArray  self subclassResponsibility-=JUAMPI=-isStyleProperty  ^true-=JUAMPI=-selectionMode  ^selectionMode-=JUAMPI=-contextMenuFromCommandsGroup: aValuable  self contextMenu: [ aValuable value beRoot asMenuPresenter ]-=JUAMPI=-displayedIcon  self model hasIcons ifFalse: [ ^nil ].  ^self widget currentIcon-=JUAMPI=-step  self model step-=JUAMPI=-whenChangedDo: aBlock  self announcer when: ValueChanged do: [:ann |  aBlock cull: ann newValue cull: ann oldValue cull: ann ]-=JUAMPI=-apply  fromPort attachTransmission: self-=JUAMPI=-onActivation: anObject  onActivation := anObject-=JUAMPI=-manualFractionComputation  | delta |  delta := numberOfProportionals isZero ifTrue: [ 0 ] ifFalse: [ 1 / numberOfProportionals ].  self commands doWithIndex: [:e :idx |  e layoutFrame hasNoOffsets ifTrue: [ self setWidgetLayoutWithNoOffset: e at: idx delta: delta ] ifFalse: [ self setWidgetLayoutWithOffset: e at: idx ] ]-=JUAMPI=-methodsListPresenter  ^methodsListPresenter-=JUAMPI=-removeRootsSuchAs: aBlock  self widgetDo: [:w |  w model rootNodes removeAllSuchThat: [:node |  aBlock value: node nodeModel ] ]-=JUAMPI=-initializePresenters  super initializePresenters.  textModel := self newCode.  textModel whenBuiltDo: [:ann |  ann widget font: self codeFont ].  refreshingBlock := [:item |  true ].  self     initializeDropList;     setFocus-=JUAMPI=-buildWidget  widget := FTTableMorph new     hResizing: #spaceFill;     vResizing: #spaceFill;     intercellSpacing: self class intercellSpacing;     yourself.  self addModelTo: widget.  ^widget-=JUAMPI=-checkboxLabel: anObject  checkboxLabel := anObject-=JUAMPI=-addModelItemsToWindowMenu: aMenu  self presenter addModelItemsToWindowMenu: aMenu-=JUAMPI=-leftFraction: aNumber  ^0-=JUAMPI=-beep  widget flash-=JUAMPI=-initialize  super initialize.  bottomFraction := 1.  bottomOffset := 0.  leftFraction := 0.  leftOffset := 0.  rightFraction := 1.  rightOffset := 0.  topFraction := 0.  topOffset := 0-=JUAMPI=-borderWidth: aNumber  borderWidth := aNumber-=JUAMPI=-object: anObject  object := anObject-=JUAMPI=-whenSelectedItemChanged: aBlock  self list whenSelectedItemChanged: aBlock-=JUAMPI=-propertyAt: aKey ifPresent: aBlock ifAbsent: absentBlock  ^self properties at: aKey ifPresent: aBlock ifAbsent: absentBlock-=JUAMPI=-startWithoutSelection  startsWithSelection := false-=JUAMPI=-model: anObject  model := anObject-=JUAMPI=-testWhenMaximumChangedDo  | count result |  count := 0.  presenter whenMaximumChangedDo: [:value |  count := count + 1.        result := value ].  presenter maximum: 10.  self assert: count equals: 1.  self assert: result equals: 10-=JUAMPI=-testSelectItemSetsSelectedIndex  presenter selectItem: 20.  self assert: presenter selection selectedIndex equals: 2-=JUAMPI=-includesPath: aPath  ^selection includes: aPath-=JUAMPI=-application  ^self hasOwner ifTrue: [ self owner application ] ifFalse: [ application ifNil: [ self flag: #TODO.              application := SpApplication defaultApplication ] ]-=JUAMPI=-property: aName rawValue: anObject  (self observablePropertyNamed: aName) rawValue: anObject-=JUAMPI=-descriptionPresenter: anObject  descriptionPresenter := anObject-=JUAMPI=-checkThatSidesDiffer: escapeBlock  changeSorterLeft selectedChangeSet == changeSorterRight selectedChangeSet ifFalse: [ ^self ].  self inform: 'This command requires that thechange sets selected on the twosides of the change sorter *not*be the same.'.  ^escapeBlock value-=JUAMPI=-send: aSelector withArguments: arguments  self commands add: (SpLayoutSend selector: aSelector)-=JUAMPI=-buildWidget  | instance |  instance := SpAthensMorph new.  self presenter whenDrawBlockChangedDo: [:newBlock |  instance drawBlock: newBlock ].  self presenter whenExtentChangedDo: [:newExtent |  instance extent: newExtent ].  instance extent: self presenter surfaceExtent.  instance drawBlock: self presenter drawBlock.  instance setBalloonText: self model help.  self presenter whenHelpChangedDo: [ instance setBalloonText: self model help ].  ^instance-=JUAMPI=-shortcuts  | collection |  collection := OrderedCollection new.  KMRepository default categories do: [:cat |  cat keymaps do: [:keymapping |  collection add: (KMShortcutDeclaration new                       shortcutName: keymapping name;                       categoryName: cat name;                       yourself) ] ].  ^collection sorted: #categoryName ascending-=JUAMPI=-buildAdapterWithSpecLayout: aSpecLayout  ^SpBindings value: self application adapterBindings during: [ self basicBuildAdapterWithSpecLayout: aSpecLayout ]-=JUAMPI=-children  ^childrenBlock-=JUAMPI=-instantiateModels: aCollectionOfPairs  self deprecated: 'Use #instantiatePresenters: instead' transformWith: '`@receiver instantiateModels: `@statement' -> '`@receiver instantiatePresenters: `@statement'.  ^self instantiatePresenters: aCollectionOfPairs-=JUAMPI=-pushMessage: message to: aMorph  pushedMessages add: message.  aMorph     removeAllMorphs;     addMorph: message asStringMorph-=JUAMPI=-defaultDate  ^Date today-=JUAMPI=-presenter: aPresenter  presenter := aPresenter-=JUAMPI=-addConstraits: constraints toChild: childMorph  | theMorph |  theMorph := childMorph.  theMorph setProperty: #constraints toValue: constraints.  ^theMorph-=JUAMPI=-addModelTo: tableMorph  self model columns do: [:each |  tableMorph addColumn: (self newColumnFrom: each) ].  self ensureAtLeastOneColumnIn: tableMorph.  self isResizable ifTrue: [ tableMorph beResizable ] ifFalse: [ tableMorph beNotResizable ].  tableMorph setMultipleSelection: self model isMultipleSelection.  self refreshShowColumnHeaders.  self refreshWidgetSelection.  self presenter whenShowColumnHeadersChangedDo: [:showColumns |  self refreshShowColumnHeaders ].  self presenter whenModelChangedDo: [ widget refresh ].  self presenter whenColumnsChangedDo: [ self refreshColumnsInWidget ].  tableMorph setBalloonText: self help.  self configureScrolling.  tableMorph     onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self;     onAnnouncement: FTStrongSelectionChanged send: #strongSelectionChanged: to: self.  tableMorph dataSource: self newDataSource.  self presenter whenItemFilterBlockChangedDo: [:block |  self updateItemFilterBlockWith: block ].  self presenter whenSearchChangedDo: [ self updateSearch ].  self updateItemFilterBlockWith: self itemFilter-=JUAMPI=-addColumn: aTableColumn  columns add: aTableColumn-=JUAMPI=-submitButton  ^submitButton-=JUAMPI=-enabled: aBoolean  ^self subclassResponsibility-=JUAMPI=-addItemsFromContext: aContext  self flag: #TODO-=JUAMPI=-hasCustomSearch  ^searchBlock notNil-=JUAMPI=-unregisterShortcut: oldShortcut  | receiver |  receiver := self window.  (receiver isNil or: [ oldShortcut isNil ]) ifTrue: [ ^self ].  receiver model removeKeyCombination: oldShortcut-=JUAMPI=-inspectValue  ^self value inspect-=JUAMPI=-columns  ^widget columns-=JUAMPI=-testSmokeTestForDemoPages  self timeLimit: 1 minute.  SpDemoPage availablePages do: [:demoPage |  [ [ window := demoPage new openWithSpec ] on: Error do: [:e |  self fail: 'Broken demo page: ' , demoPage asString , '' , e signalerContext shortStack ] ] ensure: [ window ifNotNil: #close ] ]-=JUAMPI=-buildWidget  ^SpStubGridView new-=JUAMPI=-objectAsUnicodeCodePoint  ^String streamContents: [:stream |  stream << 'U+'.        self object codePoint printOn: stream base: 16 nDigits: 4 ]-=JUAMPI=-classToTest  ^SpMethodToolbar-=JUAMPI=-initialize  self flag: #pharoTodo.  super initialize.  oddPassage := true-=JUAMPI=-initializeTestedInstance  presenter     min: 1;     max: 100;     quantum: 1;     value: 20-=JUAMPI=-taskbarIcon  ^self model taskbarIcon-=JUAMPI=-defineInputPorts  ^{SpTextPort new}-=JUAMPI=-whenMenuChangedDo: aBlock  self property: #menu whenChangedDo: aBlock-=JUAMPI=-hasButtonWithLabel: aString  ^self widget leftPanel submorphs , self widget rightPanel submorphs detect: [:e |  (e isKindOf: SpToolBarButtonMorph) and: [ e label = aString ] ] ifFound: [ true ] ifNone: [ false ]-=JUAMPI=-visiblePages  ^visiblePages-=JUAMPI=-vShrinkWrap  self subclassResponsibility-=JUAMPI=-show  self widgetDo: #show-=JUAMPI=-selectedElement  ^self list selection selectedItem ifNil: [ self list selectedIndex ifNotNil: [:currentIndex |  currentIndex = 0 ifTrue: [ ^nil ].              self list listItems ifNotEmpty: [:aList |  aList at: currentIndex ] ] ]-=JUAMPI=-initializePresenters  super initializePresenters.  self content: SpInputTextDropList-=JUAMPI=-testSelectInvalidPathsIsEmpty  presenter selectPaths: {#(40) .         #(10 20)}.  self assert: presenter selection isEmpty-=JUAMPI=-add: aBlock withSpec: aSpec left: left right: right  self add: aBlock withSpec: aSpec top: nil bottom: nil left: left right: right-=JUAMPI=-exploreValue  ^self value inspect-=JUAMPI=-enabled  ^self presenter isEnabled-=JUAMPI=-basicSelectIndex: indexToSelect  selectedIndex := indexToSelect-=JUAMPI=-acceptDroppingMorph: draggedMorph event: event inMorph: source  | item |  item := self widget ifNotNil: [:w |  w scrollerSubMorphFromPoint: event position ].  item ifNil: [ ^self ].  ^self acceptDropBlock valueWithEnoughArguments: {draggedMorph model model .         event .         source model model model .         item model nodeModel}-=JUAMPI=-observablePropertyNamed: aName  | slot |  slot := self class slotNamed: aName.  slot isObservableSlot ifFalse: [ SpNonObservableSlotError signal: aName ].  ^slot rawRead: self-=JUAMPI=-page: anObject  page := anObject-=JUAMPI=-step  | oldAngle transform |  oldAngle := transformationMorph rotationDegrees.  transform := transformationMorph transform withAngle: (oldAngle + 15) degreesToRadians negated.  transformationMorph     transform: transform;     invalidRect: transformationMorph fullBounds-=JUAMPI=-testShortcutKey  self should: [ command shortcutKey ] raise: CmNoShortcutIsDefined.  command shortcutKey: $a asKeyCombination.  self assert: command shortcutKey equals: $a asKeyCombination-=JUAMPI=-addPaneSplitters  self removePaneSplitters.  self addPaneVSplitters.  self addPaneHSplitters.  self linkSplittersToSplitters-=JUAMPI=-rebuildWithSpecLayout: aSpec  | sub |  sub := self model window submorphs copy.  self model window removeAllMorphs.  sub allButLast do: [:e |  self model window addMorphBack: e ].  self model addPresenterIn: self widget withSpecLayout: aSpec.  self widget model: self-=JUAMPI=-label  ^label-=JUAMPI=-initialize  super initialize.  name := 'some name'.  surname := ''.  number1 := 1.  number2 := 12.009.  scale := 42.  password := 'password'.  rememberMe := true.  date := '2018-01-01' asDate.  gender := #male.  selectedItems := {(self items at: 3) .   (self items at: 4)}-=JUAMPI=-shortcut  ^shortcut-=JUAMPI=-labelClickable: aBoolean  labelClickableHolder value: aBoolean-=JUAMPI=-menuColumn: column row: rowIndex  | menuPresenter |  menuPresenter := self model contextMenu.  menuPresenter ifNil: [ ^nil ].  ^SpBindings value: self model application adapterBindings during: [ | m |        m := menuPresenter value.        m isMorph ifTrue: [ m ] ifFalse: [ m buildWithSpec ] ]-=JUAMPI=-target  ^self owner ifNotNil: [:aMorph |  aMorph submorphs before: self ]-=JUAMPI=-limit2  ^10-=JUAMPI=-prepareAsStandaloneApplication  -=JUAMPI=-open  ^self openWithSpec-=JUAMPI=-whenQuantumChangedDo: aBlock  self property: #quantum whenChangedDo: aBlock-=JUAMPI=-testTextWithStyle  | text |  presenter     behavior: nil;     doItReceiver: Object;     type: 'self asString.'.  text := self adapter textWithStyle.  self assertText: text atInterval: (1 to: 4) isStyle: #self.  self assertText: text atInterval: (6 to: 13) isStyle: #unary.  presenter type: '10 + 42.0'.  text := self adapter textWithStyle.  self assertText: text atInterval: (1 to: 2) isStyle: #integer.  self assertText: text atInterval: (4 to: 4) isStyle: #binary.  self assertText: text atInterval: (6 to: 9) isStyle: #number.  presenter behavior: Object.  presenter type: 'm1 ^ "test" 42'.  text := self adapter textWithStyle.  self assertText: text atInterval: (1 to: 2) isStyle: #patternKeyword.  self assertText: text atInterval: (4 to: 4) isStyle: #return.  self assertText: text atInterval: (6 to: 11) isStyle: #comment.  self assertText: text atInterval: (13 to: 14) isStyle: #number-=JUAMPI=-testRightClickShowsMenu  | menu |  presenter contextMenu: (menu := SpMockMenuPresenter new).  self deny: menu shown.  self emulateRightClick.  self assert: menu shown-=JUAMPI=-spacing  ^spacing-=JUAMPI=-buildAdapterFor: aPresenter bindings: bindings  adapter := (aPresenter needRebuild or: [ aPresenter adapter isNil ]) ifTrue: [ (bindings adapterClass: self adapterName) adapt: aPresenter ] ifFalse: [ aPresenter adapter           removeSubWidgets;           yourself ].  aPresenter needRebuild: true.  adapter layout: self.  children keysAndValuesDo: [:presenterNameOrLayout :constraints |  adapter add: (self resolvePresenter: presenterNameOrLayout presenter: aPresenter bindings: bindings) constraints: constraints ].  ^adapter-=JUAMPI=-oldPage  ^oldPage-=JUAMPI=-asMenuPresenterWith: aBlock  | builder |  builder := SpMenuPresenterBuilder new.  aBlock value: builder menuPresenter.  ^builder     visit: self;     menuPresenter-=JUAMPI=-newNumberInput  ^self instantiate: SpNumberInputFieldPresenter-=JUAMPI=-redMorphTab  presenter     label: 'Red Morph';     icon: (presenter iconNamed: #smallBackIcon);     contents: (Morph new           color: Color red;           yourself)-=JUAMPI=-topologicSort: anObject  topologySort := anObject-=JUAMPI=-presenter  ^presenter-=JUAMPI=-label  ^label-=JUAMPI=-shown  ^shown-=JUAMPI=-newListColumn  ^SpMorphicTableColumn new     model: (SpStringTableColumn title: self presenter headerTitle evaluated: self presenter display);     yourself-=JUAMPI=-classToTest  ^SpTextInputFieldPresenter-=JUAMPI=-surnameTextInput: anObject  surnameTextInput := anObject-=JUAMPI=-buildLabel: text withIcon: icon  icon ifNil: [ ^text ifNil: [ '' ] ifNotNil: [ text ] ].  ^IconicListItem text: text icon: icon-=JUAMPI=-fromSpec: aSpec  | grps subgroup |  grps := OrderedCollection new.  aSpec label ifNotNil: [:label |  self title: label ].  subgroup := OrderedCollection new.  aSpec items do: [:each |  subgroup add: each.        each separator ifTrue: [ grps add: subgroup copy.              subgroup removeAll ] ].  subgroup ifNotEmpty: [ grps add: subgroup copy ].  grps do: [:each |  self addGroup: [:group |  each do: [:spec |  group addItem: [:item |  item fromSpec: spec ] ] ] ]-=JUAMPI=-initialize: anInteger  text label: anInteger asString-=JUAMPI=-initialize  super initialize.  borderWidth := 0.  borderColor := Color transparent.  enabled := true.  dragEnabled := false.  dropEnabled := false.  dragTransformationBlock := [:item :source |  item ].  wantDropBlock := [:draggedItem :event :source |  self dropEnabled ].  acceptDropBlock := [:draggedItem :event :source |   ].  transferBlock := [:passenger :source |  self defaultTransferFor: passenger from: source ].  color := self defaultColor.  self whenHelpChangedDo: [:string |  self withAdapterDo: [:w |  w update: #setBalloonText: with: {string} ] ].  self whenBorderWidthChangedDo: [:int |  self withWidgetDo: [:w |  w update: #borderWidth: with: {int} ] ].  self whenBorderColorChangedDo: [:newColor |  self withWidgetDo: [:w |  w update: #borderColor: with: {newColor} ] ].  self property: #color whenChangedDo: [:newColor |  self withAdapterDo: [:w |  w update: #color: with: {newColor} ] ].  self whenEnabledChangedDo: [:b |  self withAdapterDo: [:w |  w update: #enabled: with: {b} ] ].  self property: #dragEnabled whenChangedDo: [:b |  self withWidgetDo: [:w |  w update: #dragEnabled: with: {b} ] ].  self property: #dropEnabled whenChangedDo: [:b |  self withWidgetDo: [:w |  w update: #dropEnabled: with: {b} ] ].  styles := #()-=JUAMPI=-menu  ^menuBlockHolder value-=JUAMPI=-assertText: text at: index isStyle: styleName  | tag |  tag := SpCodeStyleForTest new.  text attributesAt: index do: [:each |  self fillTag: tag withAttribute: each ].  self assert: tag equals: (self style: styleName)-=JUAMPI=-newMultiColumnList  self deprecated: 'Use newTable instead' on: '2019-02-05' in: #Pharo8.  ^self instantiate: SpMultiColumnListPresenter-=JUAMPI=-actionArguments  ^[ Array with: self ]-=JUAMPI=-whenSelectionChanged: aBlock  self deprecated: 'Use #whenSelectionChangedDo: instead' transformWith: '`@receiver whenSelectionChanged: `@argument' -> '`@receiver whenSelectionChangedDo: `@argument'.  ^self whenSelectionChangedDo: aBlock-=JUAMPI=-testModelSettingValueHolderToModel  | model point valueHolder presenter |  point := 1 @ 0.  model := SpTestingPointModel x: 1 y: 2.  valueHolder := NewValueHolder value: point.  presenter := SpTestingPresenterWithModel on: model.  self assert: presenter announcingObject isSpAnnouncingObject.  self deny: presenter announcingObject isValueHolder.  self assert: valueHolder isSpAnnouncingObject.  self assert: valueHolder isValueHolder.  presenter model: valueHolder.  self assert: presenter announcingObject isSpAnnouncingObject.  self assert: presenter announcingObject isValueHolder.  self assert: presenter announcingObject == valueHolder.  self assert: presenter announcingObject announcer numberOfSubscriptions > 0-=JUAMPI=-resizeCursor  ^Cursor resizeForEdge: self edgeName-=JUAMPI=-createNullPresenters: anInteger  nullPresentersInstVarNames := self generateNullPresentersInstVarNames: anInteger.  dynamicPresenter instantiatePresenters: self nullPresentersInstVarNamesAndPresenterNamesArray-=JUAMPI=-block: aBlock layoutFrame: aLayoutFrame  | column |  column := SpColumnLayout composed.  aBlock value: column.  subwidget := column.  self layoutFrame: aLayoutFrame-=JUAMPI=-addInstancesVariable: elements  -=JUAMPI=-number: aNumber  self text: aNumber asString-=JUAMPI=-currentlyActivated  ^currentlyActivated-=JUAMPI=-whenCanDeselectByClickChangedDo: aBlock  self deprecated: 'It is not clear what option to select if deselected'-=JUAMPI=-newTextInput  ^self instantiate: SpTextInputFieldPresenter-=JUAMPI=-testDaysAfterMonthOf  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 9 day: 1)) equals: 6.  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 9 day: 14)) equals: 6.  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 9 day: 30)) equals: 6.  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 10 day: 1)) equals: 10.  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 10 day: 17)) equals: 10.  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 10 day: 30)) equals: 10-=JUAMPI=-testIsDisplayed  windowPresenter := SpTextPresenter new openWithSpec.  self assert: windowPresenter isDisplayed.  windowPresenter window minimize.  self assert: windowPresenter isDisplayed.  windowPresenter window close.  self assert: windowPresenter isDisplayed not-=JUAMPI=-calculateHomogeneousColumnWidths  | columnWidth |  columnWidth := 0.  morphs do: [:each |  columnWidth := columnWidth max: (self minWidthOf: each) ].  ^Array new: numColumns withAll: (self baseColumnWidth max: columnWidth)-=JUAMPI=-theme  ^theme-=JUAMPI=-forgetSelector: selector inClass: aClass fromChangeSet: aChangeSet  aChangeSet removeSelectorChanges: selector class: aClass-=JUAMPI=-dateInput: anObject  dateInput := anObject-=JUAMPI=-testRemoveHeaderTitleInPresenterRemovesColumnHeaderMorph  self flag: #pharo7.  SystemVersion current major < 8 ifTrue: [ self skip ].  self presenter headerTitle: 'test'.  self presenter hideHeaderTitle.  backendForTest denyHasHeader: self adapter-=JUAMPI=-initialize  self class initializeSlots: self.  super initialize-=JUAMPI=-commands: anObject  commands := anObject-=JUAMPI=-initialize  super initialize.  self spec: #defaultSpec-=JUAMPI=-initializeWindow: aWindowPresenter  aWindowPresenter     title: self title;     initialExtent: 500 @ 350-=JUAMPI=-ensureHeightPosition: aMorph in: aRect  | firstMorph |  self position ifNil: [ ^self ].  firstMorph := aMorph submorphs first.  firstMorph vResizing = #rigid ifFalse: [ firstMorph vResizing: #rigid ].  firstMorph privateBounds: (firstMorph bounds withHeight: (self heightPositionIn: aRect extent))-=JUAMPI=-takeKeyboardFocus  ^self inspector takeKeyboardFocus-=JUAMPI=-resetArrayComputation  super resetArrayComputation.  currentOffset := 0.  currentProportional := 0.  numberOfProportionals := 0.  lastFractionIndex := 0.  autoFractionComputation := true.  size := self commands size-=JUAMPI=-fillItem: aMenuItem with: aCommand  aMenuItem     name: aCommand name;     description: aCommand description;     icon: aCommand icon;     action: [ aCommand execute ].  aCommand hasShortcutKey ifTrue: [ aMenuItem shortcut: aCommand shortcutKey ].  ^aMenuItem-=JUAMPI=-surnameLabel  ^surnameLabel-=JUAMPI=-valueAtColumn: aColumn row: aRow  ^(columns at: aColumn) readObject: (self model items at: aRow)-=JUAMPI=-testActivateRaisesActivatedEvent  presenter state: false.  self assertEvent: #whenActivatedDo: isRaisedInPresenter: presenter whenDoing: [ presenter state: true ]-=JUAMPI=-hSpaceFill  self subclassResponsibility-=JUAMPI=-isDisplayed  self flag: #TODO.  ^self hasWindow ifTrue: [ self root isDisplayed ] ifFalse: [ false ]-=JUAMPI=-beIcons  self displayMode: SpToolBarDisplayMode modeIcon-=JUAMPI=-whenHelpChangedDo: aBlock  self property: #help whenChangedDo: aBlock-=JUAMPI=-menu  self deprecated: 'Use #contextMenu instead.' transformWith: '`@receiver menu' -> '`@receiver contextMenu'.  ^self contextMenu-=JUAMPI=-mainIcon  ^mainIcon-=JUAMPI=-fileOutMessage  self selectedSelector ifNotNil: [:selector |  Cursor write showWhile: [ self model fileOutSelector: selector from: self selectedClass ] ]-=JUAMPI=-resetTo: anIndex  self presenters copy withIndexDo: [:presenter :index |  index <= anIndex ifFalse: [ layout remove: presenter ] ]-=JUAMPI=-property: aName whenChangedDo: aBlockClosure  (self observablePropertyNamed: aName) whenChangedDo: aBlockClosure-=JUAMPI=-browseMessages  self currentMethod ifNotNil: [:method |  model browseMessagesFrom: method selector ]-=JUAMPI=-menuGroups  ^self model menuGroups reject: [:e |  e isEmpty ]-=JUAMPI=-testObservableSlotWorksAsNormalSlot  point x: 17.  point y: 299.  self assert: point x equals: 17.  self assert: point y equals: 299-=JUAMPI=-childrenBlock  ^tree childrenBlock-=JUAMPI=-layout: aLayout  layout := aLayout-=JUAMPI=-selector  ^self selection asSymbol-=JUAMPI=-refreshWidgetSelection  | rowIndexes |  rowIndexes := self presenter selection selectedIndexes.  rowIndexes = self widget selectedIndexes ifTrue: [ ^self ].  rowIndexes isEmpty ifTrue: [ self widget basicSelectIndexes: #() ] ifFalse: [ self widget basicSelectIndexes: rowIndexes ].  ^self widget refresh-=JUAMPI=-aboutTitle  (self presenter respondsTo: #aboutTitle) ifTrue: [ ^self presenter aboutTitle ].  ^self presenter toolName-=JUAMPI=-namesOfDaysLabels  ^namesOfDaysLabels-=JUAMPI=-activate  activationBlock value: (SpMillerActivation on: 1)-=JUAMPI=-fixedAt: aNumber  self state: (SpProgressBarFixed value: aNumber)-=JUAMPI=-adapter  ^self-=JUAMPI=-emptyList  self dropList emptyList-=JUAMPI=-whenExtentForPreviewChanged: aBlock  extentForPreview whenChangedDo: aBlock-=JUAMPI=-save: aValue  saveBlock value: aValue-=JUAMPI=-compareToCurrentVersion  self compareTo: rgMethod withLabel: 'Current version'-=JUAMPI=-performHeaderActionSelector  ^self headerAction ifNil: [ nil ] ifNotNil: [ #performHeaderAction ]-=JUAMPI=-initializeTestedInstance  super initializeTestedInstance.  presenter addColumn: (SpStringTableColumn evaluated: [:e |  e displayString ])-=JUAMPI=-whenSelectedItemChanged: aBlock  messageList whenSelectedItemChanged: aBlock-=JUAMPI=-selectedItem: anItem  self deprecated: 'Use #selectItem: instead' transformWith: '`@receiver selectedItem: `@arg' -> '`@receiver selectItem: `@arg'.  self selectItem: anItem-=JUAMPI=-subMenu: aMenuPresenter  aMenuPresenter ifNotNil: [ aMenuPresenter owner: self ].  subMenu := aMenuPresenter-=JUAMPI=-model  ^model-=JUAMPI=-rowSpan  ^self span y-=JUAMPI=-surnameLabel: anObject  surnameLabel := anObject-=JUAMPI=-initializeWindow: aWindowPresenter  aWindowPresenter     title: 'Transmission example browser';     initialExtent: 800 @ 600-=JUAMPI=-rootMenu  ^self owner isMenuPresenter ifTrue: [ self owner rootMenu ] ifFalse: [ self ]-=JUAMPI=-object  ^self inspector object-=JUAMPI=-cacheHierarchyForClasses: aCollection  cachedHierarchy := self buildHierarchyForMessages: aCollection-=JUAMPI=-testWhenStateChangedDo  presenter whenStateChangedDo: [:new :old |  self deny: old.        self assert: new ].  self deny: presenter state.  self openInstance.  presenter state: true.  self assert: presenter state-=JUAMPI=-testRightClickShowsMenu  | menu |  presenter contextMenu: (menu := SpMockMenuPresenter new).  self deny: menu shown.  self emulateRightClick.  self assert: menu shown-=JUAMPI=-url: aString  self action: [ WebBrowser openOn: aString ].  self label ifNil: [ self label: aString ]-=JUAMPI=-beColumnHomogeneous  self columnHomogeneous: true-=JUAMPI=-clicked  | evt |  evt := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent redButton buttons: MouseButtonEvent redButton hand: nil stamp: nil.  (widget handlesMouseDown: evt) ifTrue: [ widget mouseDown: evt.        widget mouseUp: evt ]-=JUAMPI=-classToTest  ^SpRGBSliders-=JUAMPI=-whenMaximumChangedDo: aBlock  self property: #maximum whenChangedDo: aBlock-=JUAMPI=-whenSyntaxHighlightChangedDo: aBlock  self property: #syntaxHighlight whenChangedDo: aBlock-=JUAMPI=-displayBlock: aBlock  displayBlock value: aBlock-=JUAMPI=-newButton  ^PluggableButtonMorph on: self getState: #state action: #action label: #label menu: #menu:-=JUAMPI=-layoutSpec  ^layoutSpec-=JUAMPI=-eventKeyStrokesForPreviousFocus  ^{Character tab shift asKeyCombination}-=JUAMPI=-isEmpty  ^self subclassResponsibility-=JUAMPI=-whenValueChangedDo: aBlock  slider whenValueChangedDo: aBlock-=JUAMPI=-newColumnFrom: aTableColumn  ^(SpMorphicTableColumn on: aTableColumn)     width: aTableColumn width;     yourself-=JUAMPI=-encrypted: aBoolean  ^self input encrypted: aBoolean-=JUAMPI=-testShowPresenterShowsWidget  self skip-=JUAMPI=-initialize  super initialize.  paneMorphs := OrderedCollection new-=JUAMPI=-classToTest  ^SpSliderPresenter-=JUAMPI=-assertEvent: anEventName isRaisedInPresenter: aPresenter whenDoing: aBlock  self assertWith: [:times |  times > 0 ] timesRaisedEvent: anEventName inPresenter: aPresenter whenDoing: aBlock-=JUAMPI=-initializePresenters  fieldNormal := self newTextInput.  fieldDisabled := self newTextInput enabled: false.  fieldPlaceholderText := self newTextInput placeholder: 'Placeholder text'.  fieldEncrypted := self newTextInput     text: 'Password';     bePassword-=JUAMPI=-autoRefresh: aBoolean  autoRefresh := aBoolean-=JUAMPI=-okAction  ^okAction-=JUAMPI=-testChangingHelpAffectTheWidget  ^self skip-=JUAMPI=-whenCurrentActivatedChangedDo: aBlock  currentActivated whenChangedDo: aBlock-=JUAMPI=-testUnselectWidgetIndexRaisesSelectionIndexChangeEventOnce  | counter |  counter := 0.  self adapter selectPath: #(1).  presenter selection whenChangedDo: [:selection |  counter := counter + 1 ].  self adapter selectPath: #().  self assert: counter equals: 1-=JUAMPI=-methodBrowser  ^methodBrowser-=JUAMPI=-show  visible := true-=JUAMPI=-initializePresenters  listModel := self instantiate: SpListPresenter.  textModel := self newCode.  toolbarModel := self instantiate: SpMethodToolbar.  self focusOrder     add: listModel;     add: toolbarModel;     add: textModel-=JUAMPI=-maxHeight: aNumber  self maxExtent: self maxExtentOrDefault x @ aNumber-=JUAMPI=-updateClassesList  | sel |  sel := self selectedClass.  self selectedChangeSet ifNil: [ classesListPresenter items: {} ] ifNotNil: [:change |  classesListPresenter items: (change changedClasses sort: [:a :b |  a name < b name ]) ].  sel ifNotNil: [ classesListPresenter selectItem: sel ]-=JUAMPI=-addLazyPage: aBlock label: aStringOrMorph action: anActionMorphOrNil  | newPage label |  newPage := SpNotebookPageMorph new.  newPage lazyPageMorphCreation: aBlock.  label := self buildLabelFrom: aStringOrMorph withAction: anActionMorphOrNil.  newPage labelMorph: label.  self addPage: newPage label: label-=JUAMPI=-label: aStringOrImageMorph  self button label: aStringOrImageMorph-=JUAMPI=-testSelectWidgetIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | selectedIndex |  presenter selection whenChangedDo: [:selection |  selectedIndex := selection selectedIndexes ].  self adapter selectIndex: 1.  self assert: (selectedIndex includes: 1)-=JUAMPI=-selectedItems: anObject  selectedItems := anObject asArray-=JUAMPI=-label  ^label-=JUAMPI=-layout: aMorph in: layoutBounds  aMorph submorphsDo: [:m |  | constraints |        constraints := m valueOfProperty: #constraints.        (m visible and: [ constraints isOverlay not ]) ifTrue: [ m bounds: layoutBounds ].        (m visible and: [ constraints isOverlay ]) ifTrue: [ | morphBounds left top newBounds |              morphBounds := layoutBounds area > (0 @ 0 corner: m extent) area ifTrue: [ layoutBounds origin corner: layoutBounds origin + m extent ] ifFalse: [ layoutBounds ].              left := layoutBounds width / 2 - (morphBounds width / 2).              top := layoutBounds height / 2 - (morphBounds height / 2).              newBounds := layoutBounds origin + (left @ top) corner: layoutBounds corner + (left @ top).              m bounds: newBounds ].        m visible ifFalse: [ m bounds: (0 @ 0 corner: 0 @ 0) ] ]-=JUAMPI=-openWithSpec  self layout ifNil: [ ^super openWithSpec ].  ^self application open: self withSpecLayout: self layout-=JUAMPI=-classToTest  ^SpLabelPresenter-=JUAMPI=-updateText  textRefreshingProcess ifNotNil: [ textRefreshingProcess terminate ].  textRefreshingProcess := [ | indexes items |  indexes := listModel selection selectedIndexes sort collect: [:i |  i printString ].  indexes := indexes joinUsing: '; '.  items := listModel selectedItems collect: [:i |  i printString ].  items := items sort joinUsing: '; '.  UIManager default defer: [ textModel1 text: indexes.        textModel2 text: items ] ] fork-=JUAMPI=-enableSearch  searchEnabled := true-=JUAMPI=-traversePresentersDo: aBlock  self traversePresentersDo: aBlock excluding: Set new-=JUAMPI=-eventKeyStrokesForNextFocus  ^{Character arrowRight command ctrl asKeyCombination}-=JUAMPI=-selector: anObject  selector := anObject-=JUAMPI=-popUpInWorld: aWorld  self shown: true-=JUAMPI=-wantsVisualFeedback  ^self model wantsVisualFeedback-=JUAMPI=-getText  ^self model text-=JUAMPI=-display: aBlock  tree display: aBlock-=JUAMPI=-implementorsMethod  self method ifNotNil: [:aMethod |  self model browseMessagesFrom: aMethod selector ]-=JUAMPI=-testSmokeOpenEmptyPresenter  window := presenter openWithSpec-=JUAMPI=-scrollingChanged  widget container updateAllRows.  self presenter verticalAlignment     firstVisibleRowIndex: widget firstVisibleRowIndex;     lastVisibleRowIndex: widget lastVisibleRowIndex-=JUAMPI=-computeNumberOfRowsAndColumns  numRows := 0.  numColumns := 0.  self allGridConstraints do: [:each |  numRows := numRows max: each row + each rowSpan - 1.        numColumns := numColumns max: each column + each columnSpan - 1 ]-=JUAMPI=-list1  ^list1-=JUAMPI=-newMenuBar  ^self instantiate: SpMenuBarPresenter-=JUAMPI=-vRigid  self subclassResponsibility-=JUAMPI=-preferedPaneColor  ^preferedPaneColor value-=JUAMPI=-whenTextChanged: aBlock  self deprecated: 'Use #whenTextChangedDo: instead.' transformWith: '`@receiver whenTextChanged: `@statement' -> '`@receiver whenTextChangedDo: `@statement'.  self whenTextChangedDo: aBlock-=JUAMPI=-setX: xValue setY: yValue  x := xValue.  y := yValue-=JUAMPI=-contextMenu: aValuable  contextMenu := aValuable-=JUAMPI=-initializePresenters  element11 := self newMorph morph: (Morph new color: Color red).  element21 := self newMorph morph: (Morph new color: Color green).  element12 := self newMorph morph: (Morph new color: Color blue).  element22 := self newMorph morph: (Morph new color: Color yellow).  borderWidth := self newSlider     beHorizontal;     min: 0;     max: 100.  columnSpacing := self newSlider     beHorizontal;     min: 0;     max: 100.  rowSpacing := self newSlider     beHorizontal;     min: 0;     max: 100.  columnHomogeneous := self newCheckBox label: 'Column is homogeneous'.  rowHomogeneous := self newCheckBox label: 'Row is homogeneous'.  self announcer when: SpWidgetBuilt send: #widgetBuilt: to: self-=JUAMPI=-classToTest  ^SpNumberInputFieldPresenter-=JUAMPI=-classToTest  ^SpCodePresenter-=JUAMPI=-chooseDateButton  ^chooseDateButton-=JUAMPI=-testDoesNotUnderstand  | block |  themeDecorator property: #foo returnsValueOf: 42.  self assert: themeDecorator foo equals: 42.  block := [ 42 ].  themeDecorator property: #fooBlock returnsValueOf: block.  self assert: themeDecorator fooBlock equals: 42.  block := [:x |  x + 42 ].  themeDecorator property: #fooBlock: returnsValueOf: block.  self assert: (themeDecorator fooBlock: 3) equals: 45-=JUAMPI=-pageClass  ^SpDemoDynamicMemoryGamePresenter-=JUAMPI=-selectItem: anItem  self selectionMode selectItem: anItem-=JUAMPI=-heterogeneousDropList  ^heterogeneousDropList-=JUAMPI=-action  ^self model action-=JUAMPI=-testWhenTextChangesRaisesSingleEvent  self assertWith: [:times |  times = 1 ] timesRaisedEvent: #whenTextChangedDo: inPresenter: presenter whenDoing: [ presenter text: 'test' ]-=JUAMPI=-setIndex: anIndex  ^self dropList setIndex: anIndex-=JUAMPI=-listSize  ^self model listSize-=JUAMPI=-bePassword: aBoolean  isPassword := aBoolean-=JUAMPI=-initialize  self class initializeSlots: self.  super initialize.  ticks := 0.  highestValue := Float negativeInfinity.  lowestValue := Float infinity.  stepBy := 1-=JUAMPI=-keyStroke: aKeyStroke  keyStroke value cull: aKeyStroke-=JUAMPI=-performSearch: item matching: pattern  ^searchBlock value: item value: pattern-=JUAMPI=-observablePropertyNamed: aName  | slot |  slot := self class slotNamed: aName.  slot isObservableSlot ifFalse: [ SpNonObservableSlotError signal: aName ].  ^slot rawRead: self-=JUAMPI=-add: aPresenter constraints: constraints  self widgetDo: [:aPanel |  self basicAdd: aPresenter constraints: constraints to: aPanel ]-=JUAMPI=-type: aString  aString do: [:each |  self keyPressed: each asciiValue shift: each isUppercase meta: false control: false option: false ]-=JUAMPI=-notifyError: aSpecNotification  GrowlMorph openWithLabel: 'Error' contents: aSpecNotification message backgroundColor: GrowlMorph theme dangerBackgroundColor labelColor: GrowlMorph theme textColor-=JUAMPI=-addSplitter  self commands add: (SpSplitterVertical commands: self commands)-=JUAMPI=-testPresentersBlockReceivesAthensCanvas  | receivedCanvas |  self presenter drawBlock: [:canvas |  receivedCanvas := canvas ].  self adapter redraw.  self openInstance.  1 second wait.  self assert: receivedCanvas isNotNil.  self assert: (receivedCanvas isKindOf: AthensCanvas)-=JUAMPI=-protocolListAction  protocolList transmitTo: methodList transform: [:selectedProtocol |  selectedProtocol ifNotNil: [ (selectedProtocol methodSelectors collect: [:methodSelector |  self methodNamed: methodSelector ]) asOrderedCollection ] ifNil: [ #() ] ] postTransmission: [:methodPresenter |  methodPresenter selectIndex: 1 ]-=JUAMPI=-visiblePages  ^layout visiblePages-=JUAMPI=-selectedClass  ^self selectedMethod origin-=JUAMPI=-classToTest  ^SpTreeTablePresenter-=JUAMPI=-initializePresenters  menu := self mainMenu.  list := self newList.  page := self instantiate: (selectedPage := self availablePages first).  menu applyTo: self.  list     items: self availablePages;     display: [:item |  item pageName ];     contextMenu: (self newMenu           addItem: [:item |  item                 name: 'Browse';                 icon: (self iconNamed: #smallHelp);                 action: [ list selectedItem browse ] ];           addItem: [:item |  item                 name: 'Browse presenter';                 icon: (self iconNamed: #smallHelp);                 action: [ list selectedItem new pageClass browse ] ];           yourself).  self focusOrder     add: list;     add: page-=JUAMPI=-searchText: aString  | search |  aString isEmptyOrNil ifTrue: [ ^#() ].  search := aString trimBoth asLowercase.  ^Array streamContents: [:stream |  self elements withIndexDo: [:each :rowIndex |  (self model performSearch: each matching: search) ifTrue: [ stream nextPut: rowIndex ] ] ]-=JUAMPI=-whenActionPerformedDo: aBlock  self property: #actionPerformed whenChangedDo: aBlock-=JUAMPI=-testSelectAll  self initializationText.  self openInstance.  presenter selectAll.  self assert: presenter selectionInterval equals: (1 to: 15)-=JUAMPI=-explore: anObject  ^self class explore: anObject-=JUAMPI=-displayMode  ^displayMode-=JUAMPI=-doItContext  self deprecated: 'This has been moved to specific presenters (check children)' on: '2019-04-15' in: #Pharo8-=JUAMPI=-initializePresenters  listModel := self newTable.  listModel     sortingBlock: [:a :b |  self sortClassesInCachedHierarchy: a b: b ];     addColumn: (SpStringTableColumn title: 'Location' evaluated: [:item |  self locationOf: item ]);     addColumn: (SpStringTableColumn title: 'Selector' evaluated: [:item |  self selectorOf: item ]);     addColumn: (SpStringTableColumn title: 'Package' evaluated: [:item |  self packageOf: item ]);     beResizable.  self contextMenu: self messageListMenu-=JUAMPI=-content: aWidgetClass  subwidget := self instantiate: aWidgetClass.  self focusOrder add: subwidget-=JUAMPI=-initialize  | isChanging |  super initialize.  isHorizontal := true.  marks := OrderedCollection new.  max := 100.  min := 0.  quantum := 1.  value := 0.  absoluteValue := 0.  label := ''.  isChanging := false.  self whenMaxChangedDo: [:m |  self changed: {#max: .               m} ].  self whenMinChangedDo: [:m |  self changed: {#min: .               m} ].  self whenQuantumChangedDo: [:m |  self changed: {#quantum: .               m} ].  self whenValueChangedDo: [:v |  isChanging ifFalse: [ isChanging := true.              self absoluteValue: (self valueToAbsoluteValue: v).              self changed: {#scaledValue: .                     v}.              isChanging := false ].        self changed: #value ].  self whenAbsoluteValueChangedDo: [:v |  isChanging ifFalse: [ isChanging := true.              self value: (self absoluteValueToValue: v).              self changed: {#value: .                     v}.              isChanging := false ] ].  self whenLabelChangedDo: [:v |  self changed: #label ]-=JUAMPI=-testPresenterTextIsSetInWidget  presenter text: 'something'.  self assert: self widget text equals: 'something'-=JUAMPI=-fieldPlaceholderText: anObject  fieldPlaceholderText := anObject-=JUAMPI=-hasFilter  ^self widget hasFilter-=JUAMPI=-initialize  super initialize.  onlyStrong := false-=JUAMPI=-indeterminated: anObject  indeterminated := anObject-=JUAMPI=-title: aString  self widgetDo: [:w |  w setLabel: aString ]-=JUAMPI=-icon  ^self presenter icon ifNil: [ self defaultIcon ]-=JUAMPI=-setUp  super setUp.  presentersBuilder := SpDynamicPresentersListBuilder new     modelObjects: (1 to: 14);     presenter: SpButtonPresenter configuredAs: [:button :i |   ];     buildDynamicPresenter;     yourself.  layout := SpDynamicLeftToRightColumnsLayout columns: 7-=JUAMPI=-action: anObject  action := anObject-=JUAMPI=-applyTo: aModel  aModel applyMenuModel: self-=JUAMPI=-browseValue  ^self value browse-=JUAMPI=-testSettingNilResetsSelection  self presenter selectItem: 10.  self presenter selectItem: nil.  self assert: self presenter selectedItem equals: nil.  self assert: self adapter selectedIndexes isEmpty-=JUAMPI=-isComposite  ^true-=JUAMPI=-headerColumn: column  | headerMorph |  column id ifNil: [ ^nil ].  headerMorph := SpHeaderCellMorph new     addMorph: column id asMorph asReadOnlyMorph;     yourself.  column isSortable ifTrue: [ headerMorph eventHandler: (MorphicEventHandler new on: #click send: #sortByColumn:event:morph: to: self withValue: column) ].  ^headerMorph-=JUAMPI=-ghostText: aText  self deprecated: 'This API is too tight to Morph. Use #placeholder: instead.' transformWith: '`@receiver ghostText: `@statement' -> '`@receiver placeholder: `@statement'.  self placeholder: aText-=JUAMPI=-openInstance  backendForTest openInstanceOf: self-=JUAMPI=-testUnselectSelectedItemRemovesItFromSelectionList  presenter     selectItem: 10;     unselectItem: 10.  self assert: presenter selection isEmpty-=JUAMPI=-execute  self editor paste-=JUAMPI=-externalIndex: anObject  externalIndex := anObject-=JUAMPI=-update: aParameter  self changed: aParameter-=JUAMPI=-= anObject  ^super = anObject and: [ instVarName = anObject instVarName ]-=JUAMPI=-testSelectIndexesOutsideRangeHasNoSelectedItems  presenter selectIndexes: {4 .         5}.  self assert: presenter selection selectedItems isEmpty-=JUAMPI=-whenMenuChangedDo: aBlock  self property: #contextMenu whenChangedDo: aBlock-=JUAMPI=-maximize  self changed: #maximize with: #()-=JUAMPI=-sortingBlock: aBlock  listModel sortingBlock: aBlock-=JUAMPI=-textConverter: aTextConverter  textConverter := aTextConverter method: self textConverter method-=JUAMPI=-menu: aMenu shifted: aBoolean  | menu |  (self allowMenuOnNoItem not and: [ self selectedItems isEmpty ]) ifTrue: [ ^nil ].  menuBlockHolder value ifNil: [ ^nil ].  menuBlockHolder value isBlock ifFalse: [ ^menuBlockHolder value ].  menu := SpMenuPresenter new.  menuBlockHolder value cull: menu cull: aBoolean.  ^menu-=JUAMPI=-ensureKeyBindingsFor: widget  super ensureKeyBindingsFor: widget.  self shortcut ifNotNil: [:s |  self registerShortcut: s ]-=JUAMPI=-cellColumn: column row: rowIndex  | displayValue cell item |  item := self model itemAt: rowIndex.  displayValue := column readObject: item.  cell := FTCellMorph new     cellInset: 5;     yourself.  self model hasIcons ifTrue: [ (self model iconFor: item) ifNotNil: [:icon |  cell addMorphBack: icon asMorph ] ].  cell addMorphBack: displayValue asMorph asReadOnlyMorph.  ^cell-=JUAMPI=-giveFocusToNextFrom: aModel  ^self model giveFocusToNextFrom: aModel-=JUAMPI=-properties  ^self styles select: [:each |  each isStyleProperty ]-=JUAMPI=-emptyList  ^self dropList emptyList-=JUAMPI=-open: anObject  object := anObject.  self open-=JUAMPI=-testTickIncrementsOne  timeline tick.  self assert: timeline ticks equals: 1-=JUAMPI=-childrenWidgets  ^widget submorphs first submorphs , widget submorphs second submorphs-=JUAMPI=-copyClass: aClass from: source to: destination  destination absorbClass: aClass name from: source-=JUAMPI=-methodModified: anAnnouncement  UIManager default defer: [ self handleMethodModified: anAnnouncement ]-=JUAMPI=-action: aBlock  action := aBlock-=JUAMPI=-listElementAt: anIndex  ^self model at: anIndex ifAbsent: [ nil ]-=JUAMPI=-testUnselectAllUnselectsSingleSelection  presenter     selectPath: #(1 1);     unselectAll.  self assert: presenter selection isEmpty-=JUAMPI=-items  ^items value-=JUAMPI=-model  ^model-=JUAMPI=-valueToAbsoluteValue: v  ^((v - self min) / (self max - self min)) asFloat-=JUAMPI=-testSelectItemSetsSelectedPath  presenter selectItem: 20.  self assert: presenter selection selectedPath equals: #(1 1 3)-=JUAMPI=-initialize  super initialize-=JUAMPI=-label  ^self presenter label-=JUAMPI=-testWhenDaySelectedBlock  | blockExecuted d |  blockExecuted := false.  d := Date year: 2018 month: 9 day: 15.  calendar     adaptToDate: d;     whenDaySelectedBlock: [ blockExecuted := true ].  self deny: blockExecuted.  calendar daysButtons basicPresenters value values first performAction.  self assert: blockExecuted-=JUAMPI=-propertyAt: aKey put: aValue  ^self properties at: aKey put: aValue-=JUAMPI=-testSelectItemAddsPathToSelectedPathList  presenter selectItem: 10.  self assert: (presenter selection includesPath: #(1 3))-=JUAMPI=-adapterName: anObject  adapterName := anObject-=JUAMPI=-testSetSelectIndexRaisesSelectionChangeEventWithSelectedIndex  | selectedIndexes |  presenter whenSelectionChangedDo: [:selection |  selectedIndexes := selection selectedIndexes ].  presenter selectIndex: 1.  self assert: (selectedIndexes includes: 1)-=JUAMPI=-testRebuildPresenterBeforeOpeningWorks  self assert: presenter label label equals: ''.  self shouldnt: [ presenter selectFirstElement.        self openInstance ] raise: Error.  self assert: presenter label label equals: '1'-=JUAMPI=-calculateExtentFor: aMorph constraint: constraint computation: computation  | cellExtent height width |  cellExtent := computation cellExtentAt: constraint position.  width := self calculateWidthFor: aMorph base: cellExtent x.  height := self calculateHeightFor: aMorph base: cellExtent y.  ^width @ height-=JUAMPI=-buildWidget  ^SpTickingSpecWindow new     model: self;     isResizeable: self isResizeable;     yourself-=JUAMPI=-placeholder  ^self model placeholder-=JUAMPI=-testSelectInvalidPathHasNoSelectedPaths  presenter selectPath: #(4).  self assert: presenter selection selectedPaths isEmpty-=JUAMPI=-testSelectMultipleIndexesAddsAllToSelectedIndexList  presenter selectIndex: 1.  presenter selectIndex: 3.  self assert: (presenter selection includesIndex: 1).  self assert: (presenter selection includesIndex: 3)-=JUAMPI=-canResize  ^resize-=JUAMPI=-extent: aPoint  | newExtent |  newExtent := aPoint rounded.  (bounds extent closeTo: newExtent) ifTrue: [ ^self ].  self invalidRect: bounds.  bounds := bounds topLeft extent: newExtent.  self layoutChanged.  self invalidRect: bounds-=JUAMPI=-testSelectPresenterItemSetsSelectedIndexInWidget  self skip-=JUAMPI=-dispatchTo: aNotificationCenter  ^aNotificationCenter notify: self-=JUAMPI=-add: aName withConstraints: aBlock  | constraints |  constraints := self constraintsClass new.  aBlock value: constraints.  children at: aName put: constraints-=JUAMPI=-differentCardsCountSlider  ^differentCardsCountSlider-=JUAMPI=-initialize  needRecalculatePages := false.  super initialize-=JUAMPI=-testRemovePage  | page |  presenter addPage: (page := SpNotebookPage title: 'Mock3' provider: [ SpLabelPresenter new ]).  self assert: self adapter numberOfTabs equals: 3.  presenter removePage: page.  self assert: self adapter numberOfTabs equals: 2-=JUAMPI=-initialize  super initialize.  self     name: 'Inspect';     description: 'Inspect the context of this command.'-=JUAMPI=-activateOnSingleClick  activateOnSingleClick := true-=JUAMPI=-refreshPrintDescription  self printDescription: self selectedElement-=JUAMPI=-clicked  widget toggleSelected-=JUAMPI=-sliceButton  ^sliceButton-=JUAMPI=-defaultWindowPresenterClass  ^SpTickingWindowPresenter-=JUAMPI=-initialize  super initialize.  type := #SpContainerPresenter.  self commands: OrderedCollection new-=JUAMPI=-displaySymbol  ^displaySymbol ifNil: [ #printString ]-=JUAMPI=-initializeWindow: aWindowPresenter  aWindowPresenter     title: 'Grid layout example';     initialExtent: 300 @ 400-=JUAMPI=-itemNamed: aString  ^self items detect: [:e |  e label = aString ]-=JUAMPI=-fieldPlaceholderText  ^fieldPlaceholderText-=JUAMPI=-icon: anIcon  icon := anIcon-=JUAMPI=-addVariableFields: elements  self tempNames withIndexDo: [:name :index |  elements add: (ContextTempEyeElement host: self object tempName: name tempIndex: index) ]-=JUAMPI=-shown: anObject  ^shown := anObject-=JUAMPI=-presenterProvider: aBlock  presenterProvider := aBlock-=JUAMPI=-classToTest  ^SpListPresenter-=JUAMPI=-add: aBlock withSpec: aSpec left: aNumber  self add: aBlock withSpec: aSpec top: nil bottom: nil left: aNumber right: nil-=JUAMPI=-preview  ^preview-=JUAMPI=-initializeDialogWindow: aDialog  super initializeDialogWindow: aDialog.  aDialog     initialExtent: 600 @ 400;     title: 'Select a method';     closeOnBackdropClick: false-=JUAMPI=-deselect  self widgetDo: [:w |  w changed: #deselect.        w model selectionChanged.        w dependents do: [:e |  e changed ] ]-=JUAMPI=-newTable  ^self instantiate: SpTablePresenter-=JUAMPI=-newColumnFrom: aTableColumn  ^(SpMorphicTableColumn on: aTableColumn)     width: aTableColumn width;     yourself-=JUAMPI=-extent  ^transformationMorph extent-=JUAMPI=-runCase  self resources do: [:each |  each availableFor: self ].  [ super setUp.  self performTest ] ensure: [ self tearDown.        self cleanUpInstanceVariables ]-=JUAMPI=-listModel  ^listModel-=JUAMPI=-badgeColor  ^self theme badgeColor-=JUAMPI=-whenSelectionChangedDo: aBlock  selection whenChangedDo: aBlock-=JUAMPI=-initialize  super initialize.  action := [  ].  displayBlock := [:e |  e asString ]-=JUAMPI=-presenterAt: aName ifAbsent: aBlock  ^self basicPresenters at: aName ifAbsent: [ [ self readSlotNamed: aName ] on: SlotNotFound do: aBlock ]-=JUAMPI=-classToTest  ^SpToolBarPresenter-=JUAMPI=-password  ^password-=JUAMPI=-styles  ^styles-=JUAMPI=-isEnabled  ^enabled-=JUAMPI=-setUp  super setUp.  timeline := SpTimeline new-=JUAMPI=-initializeTestedInstance  presenter-=JUAMPI=-testUnselectSelectedItemRaisesSingleEvent  | counter |  counter := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectItem: 10.  self assert: counter equals: 1-=JUAMPI=-bindKeyCombination: aKMCombination toAction: aBlock  -=JUAMPI=-connectPresenters  self packageListAction.  self classListAction.  self protocolListAction.  self radioButtonsAction.  packageList selectIndex: 1-=JUAMPI=-testSetRootModelPushesPresenterToList  self presenter presenterBlock: [:model |  SpNullMillerPresenter on: (SpLabelPresenter new label: model asString) ].  self presenter setRootModel: 1.  self assert: self presenter size equals: 1-=JUAMPI=-addModelItemsToWindowMenu: aMenu  self model addMenuItemsToWindowMenu: aMenu-=JUAMPI=-initializeTestedInstance  presenter items: #(10 20 30)-=JUAMPI=-value  ^self host tempNamed: self tempName-=JUAMPI=-addVariableFields: elements  self variableFieldsToShow do: [:index |  elements add: (IndexedEyeElement host: self object index: index) ]-=JUAMPI=-addItemTo: aGroup  aGroup addItem: [:item |  item           name: 'Dynamic';           icon: (self iconNamed: #delete);           action: [ aGroup menuItems remove: item.              self needRebuild: false.              self buildWithSpec ] ].  self needRebuild: false.  self buildWithSpec-=JUAMPI=-setUp  super setUp.  presenter items: #(10 20 30)-=JUAMPI=-basicAdd: aPresenter constraints: constraints to: aPanel  self subclassResponsibility-=JUAMPI=-numberType  ^numberType-=JUAMPI=-placeholder  ^placeholder-=JUAMPI=-traverseInFocusOrderDo: aBlock excluding: excludes  self canTakeKeyboardFocus ifFalse: [ ^self ].  excludes add: self.  aBlock value: self-=JUAMPI=-color  ^color-=JUAMPI=-buildPushMessageToolBarItem  ^SpToolBarButton new     label: 'Push';     icon: (self iconNamed: #glamorousUp);     help: 'Push a new status bar message';     action: [ self pushMessage ];     yourself-=JUAMPI=-testActivateSubPresenterPushesElementToList  | mock |  self presenter presenterBlock: [:model |  mock := SpMockMillerPresenter new ].  self presenter setRootModel: 1.  mock activate.  self assert: self presenter size equals: 2-=JUAMPI=-rightClicked  | evt |  evt := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent yellowButton buttons: MouseButtonEvent yellowButton hand: nil stamp: nil.  (widget handlesMouseDown: evt) ifTrue: [ widget mouseDown: evt.        widget mouseUp: evt ]-=JUAMPI=-initializeTestedInstance  super initializeTestedInstance.  presenter addColumn: (SpStringTableColumn evaluated: [:e |  e ])-=JUAMPI=-refresh  self needRebuild: false.  self buildWithSpec-=JUAMPI=-testSubscriptionsAreTransfered  | count |  count := 0.  presenter beSingleSelection.  presenter whenSelectionChangedDo: [ count := count + 1 ].  presenter beMultipleSelection.  presenter selectIndex: 2.  self assert: count equals: 1-=JUAMPI=-styles  ^styles-=JUAMPI=-buildWidget  | newWidget |  newWidget := super buildWidget.  self presenter whenTextStylerChangedDo: [ self applyTextStyle ].  ^newWidget-=JUAMPI=-initializePresenter  self property: #object whenChangedDo: [ self objectChanged ].  text whenBuiltDo: [:w |  self text behavior: self object class ].  self initializeShortcuts-=JUAMPI=-connectPresenters  -=JUAMPI=-foundIcon  ^self iconNamed: #glamorousAccept-=JUAMPI=-whenReadSelectionIsChangedDo: aBlock  self property: #readSelection whenChangedDo: aBlock-=JUAMPI=-isSplitter  ^true-=JUAMPI=-selected  ^selected value-=JUAMPI=-classToTest  ^SpButtonPresenter-=JUAMPI=-triggerOkAction  -=JUAMPI=-title  ^'Pointers to: ' , self object printString-=JUAMPI=-color  ^color ifNil: [ Color transparent ]-=JUAMPI=-canDeselectByClick: aBoolean  self deprecated: 'It is not clear what option to select if deselected'-=JUAMPI=-window  ^window-=JUAMPI=-behavior: aClass  self deprecated: 'This method is an horrible hack because the VersionBrowser was using Code or Diff presenter but was only using the API of the Code presenter... This method and other methods from the CodePresenter API will be removed.'.  self contextClass: aClass-=JUAMPI=-onDesactivation: anObject  onDesactivation := anObject-=JUAMPI=-menu  ^tree menu-=JUAMPI=-itemAtPath: aPath expanding: shouldExpandItems  | item |  (aPath isNil or: [ aPath isEmpty ]) ifTrue: [ ^nil ].  item := self rootItem.  aPath do: [:index |  (shouldExpandItems and: [ item isRoot not ]) ifTrue: [ item expand ].        item children size < index ifTrue: [ ^nil ].        item := item children at: index ].  ^item-=JUAMPI=-testUnselectNonSelectedItemRaisesNoEvent  | counter |  counter := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectItem: 20.  self assert: counter equals: 0-=JUAMPI=-topLeftOffset: aPoint  topOffset := aPoint y.  leftOffset := aPoint x-=JUAMPI=-initializeAnnouncements  SystemAnnouncer uniqueInstance weak when: ClassAdded , ClassCommented , ClassRecategorized , ClassModifiedClassDefinition , ClassRemoved , ClassRenamed , ClassReorganized , MethodAdded , MethodModified , MethodRecategorized , MethodRemoved , ProtocolAdded , ProtocolRemoved send: #updateClassesList to: self-=JUAMPI=-inspectionMenu: aMenu  self hasSelectedObject ifFalse: [ ^aMenu ].  ^super inspectionMenu: aMenu-=JUAMPI=-connectPresenters  button1 whenActivatedDo: [ self updateLabel ].  button1 whenDeactivatedDo: [ self updateLabel ].  button2 whenChangedDo: [ self updateLabel ].  button3 whenChangedDo: [ self updateLabel ]-=JUAMPI=-testHideColumnHeadersInPresenterHidesThemInWidget  self presenter hideColumnHeaders.  self deny: self adapter isShowColumnHeaders-=JUAMPI=-method4  -=JUAMPI=-initializeSemaphore  uiWaitingSemaphore := Semaphore new-=JUAMPI=-isResizeable  ^self model isResizeable-=JUAMPI=-testReplaceItemList  | changed |  changed := false.  presenter whenModelChangedDo: [ changed := true ].  presenter items: #(a b c).  self assert: (presenter model collection collect: #label) equals: #(a b c).  self assert: changed-=JUAMPI=-testColumnNotHomogeneousDiferentRowsAndColumns  | layout |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 2.  self place: label2 at: 3 @ 3.  self place: morph2 at: 4 @ 4.  layout := self newLayout.  layout layout beColumnNotHomogeneous.  (self styleExtent: 30 @ 20) applyTo: label1.  (self styleExtent: 40 @ 20) applyTo: morph1.  (self styleExtent: 50 @ 20) applyTo: label2.  (self styleExtent: 60 @ 20) applyTo: morph2.  layout layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 30 @ 20).  self assert: morph1 bounds equals: (30 @ 20 corner: 70 @ 40).  self assert: label2 bounds equals: (70 @ 40 corner: 120 @ 60).  self assert: morph2 bounds equals: (120 @ 60 corner: 180 @ 80)-=JUAMPI=-testAddPresenterToComponentListShouldNotBeEmpty  presenter addPresenter: SpButtonPresenter new.  self deny: presenter isEmpty-=JUAMPI=-removeAll  pagesHolder removeAll-=JUAMPI=-testSetSelectItemRaisesSelectionChangeEventWithSelectedPath  | selectedPath |  presenter whenSelectionChangedDo: [:selection |  selectedPath := selection selectedPath ].  presenter selectItem: 20.  self assert: selectedPath equals: #(1 1 3)-=JUAMPI=-initializePresenters  text := self newText.  sideRuler := self newMorph.  sideRuler morph: (Morph new           color: Color yellow;           extent: 50 @ 500;           useGradientFill;           hResizing: #spaceFill;           vResizing: #spaceFill;           yourself).  text whenScrollValueChangedDo: [:newPosition |  self syncMorphPosition ].  text text: self loremIpsum-=JUAMPI=-buildWidget  | panelMorph |  panelMorph := SpToolBarMorph new.  self addModelTo: panelMorph.  ^panelMorph-=JUAMPI=-testContextMenu  | menu changed |  self assert: presenter contextMenu isNil.  menu := SpMenuPresenter new.  changed := false.  presenter whenMenuChangedDo: [ changed := true ].  presenter contextMenu: menu.  self assert: presenter contextMenu equals: menu.  self assert: changed-=JUAMPI=-width  ^width-=JUAMPI=-transferSubscriptionsTo: anotherSelectionMode  self selectionHolder transferSubscriptionsTo: anotherSelectionMode selectionHolder-=JUAMPI=-addPresenter: newSubPresenter  newSubPresenter whenActivatedDo: [:selection |  self changeSelection: selection selectedItem from: newSubPresenter ].  newSubPresenter owner: self.  layout add: newSubPresenter-=JUAMPI=-asArray  ^specArray-=JUAMPI=-testFocusRotationForward  mock := SpMockFocusOrderPresenter new     openWithSpec;     yourself.  self takeKeyboardFocus: mock.  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenter.  self pressTab.  self assert: (mock presenterAt: #secondPresenter) equals: self focusedPresenter.  self pressTab.  self assert: (mock presenterAt: #thirdPresenter) equals: self focusedPresenter.  self pressTab.  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenter-=JUAMPI=-whenMarksChangedDo: aBlock  self property: #marks whenChangedDo: aBlock-=JUAMPI=-whenSelectionChanged: aBlock  self dropList whenSelectionChanged: aBlock-=JUAMPI=-font  ^self model font-=JUAMPI=-id  ^self model title-=JUAMPI=-initializePresenters  classListPresenter := self newList.  methodListPresenter := self newList.  textPresenter := self newCode.  textPresenter acceptBlock: [:t |  methodListPresenter selectedItem inspect ].  methodListPresenter display: #selector.  self focusOrder     add: classListPresenter;     add: methodListPresenter;     add: textPresenter-=JUAMPI=-initialize  super initialize.  maxLength := 0.  acceptOnCR := true.  isPassword := false.  self whenAcceptOnCRChangedDo: [:bool |  self changed: #acceptOnCR: with: {bool} ]-=JUAMPI=-text  ^text-=JUAMPI=-itemFilterBlock: aBlock  self deprecated: 'Use #itemFilter: instead' transformWith: '`@receiver itemFilterBlock: `@statements1' -> '`@receiver itemFilter: `@statements1'.  ^self itemFilter: aBlock-=JUAMPI=-testNotPasswordIsSetInWidget  presenter bePassword: false.  self deny: self adapter isPassword-=JUAMPI=-toolbarItemFont  ^toolbarItemFont ifNil: [ toolbarItemFont := self newToolbarItemFont ]-=JUAMPI=-testUnselectWidgetIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | selectedIndex |  self adapter selectIndex: 1.  presenter selection whenChangedDo: [:selection |  selectedIndex := selection selectedIndex ].  self adapter selectIndex: 0.  self assert: selectedIndex equals: 0-=JUAMPI=-setText: text to: aWidget  super setText: (self presenter textStyler applyStyleTo: text) to: aWidget-=JUAMPI=-openChangeSetBrowser  | cs |  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  cs := self selectedChangeSet ifNil: [ ^self ].  ^Smalltalk tools messageList browseClasses: (RBBrowserEnvironment new forClasses: cs changedClasses)-=JUAMPI=-action  ^action-=JUAMPI=-rightText  ^rightText-=JUAMPI=-isMultipleSelection  ^selectionMode isMultipleSelection-=JUAMPI=-widget: anObject  widget := anObject-=JUAMPI=-displayBlock  ^self model displayBlock-=JUAMPI=-contextKeyBindings: aKMCategory  contextKeyBindings := aKMCategory-=JUAMPI=-label: aString  ^label := aString-=JUAMPI=-showAllInstVars  ^self class showAllInstVars-=JUAMPI=-testSelectWidgetIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | selectedIndex |  presenter selection whenChangedDo: [:selection |  selectedIndex := selection selectedIndex ].  self adapter selectIndex: 1.  self assert: selectedIndex equals: 1-=JUAMPI=-normalFillStyle  ^Color transparent-=JUAMPI=-clearFilterButton: anObject  clearFilterButton := anObject-=JUAMPI=-daysToDisplayCount  ^self maxNumberOfWeeksToDisplay * self daysInAWeek-=JUAMPI=-open: aPresenter withSpecLayout: aSpecLayout  ^self open: aPresenter withSpecLayout: aSpecLayout using: aPresenter defaultWindowPresenterClass-=JUAMPI=-styleName  ^'toolBar.label'-=JUAMPI=-handlesDoubleClick: aBoolean  handlesDoubleClick := aBoolean-=JUAMPI=-adaptToDate: aDate  self monthYearLabel label: aDate month asString.  self previousMonthButton action: [ self adaptToDate: aDate onPreviousMonth ].  self nextMonthButton action: [ self adaptToDate: aDate onNextMonth ].  self newDynamicPresentersListIn: #namesOfDaysLabels usingBuilder: self daysLabelsBuilder.  self newDynamicPresentersListIn: #daysButtons usingBuilder: (self daysButtonsBuilderFrom: aDate)-=JUAMPI=-autoAccept: aBoolean  ^self sliderInput autoAccept: aBoolean-=JUAMPI=-applyTo: aMorph  self color ifNotNil: [:aColor |  aMorph color: aColor ].  self backgroundColor ifNotNil: [:aColor |  aMorph backgroundColor: aColor ]-=JUAMPI=-testUnselectAllInWidgetNotRaisesEmptySelectionChangeEvent  | gotSelection |  presenter selection whenChangedDo: [:selection |  gotSelection := selection ].  self adapter selectIndex: 0.  self assert: gotSelection isNil-=JUAMPI=-application: anApplication  application := anApplication-=JUAMPI=-initializePresenters  form := (self instantiate: SpDemoLabeledContainer)     label: 'form';     subwidget: (self instantiate: SpDemoStandaloneFormPresenter on: self announcingObject).  resultPane := (self instantiate: SpDemoLabeledContainer)     label: 'result';     subwidget: (table := self newTable).  table     addColumn: (SpStringTableColumn title: 'Name' evaluated: #key);     addColumn: (SpStringTableColumn title: 'Value' evaluated: #value);     items: self model elements;     beResizable.  self focusOrder     add: form;     add: table-=JUAMPI=-doActivateAtIndex: index  self presenters at: index ifAbsent: [ ^self ].  activationBlock cull: ((SpSingleSelectionMode on: self)           basicSelectIndex: index;           yourself)-=JUAMPI=-from: aPresenter port: aSymbol to: anotherPresenter transform: aValuable  self from: aPresenter port: aSymbol to: anotherPresenter transform: aValuable postTransmission: nil-=JUAMPI=-sliders  ^sliders-=JUAMPI=-newSplitter  ^SpPanedResizerMorph newVertical-=JUAMPI=-presenterAt: aName ifAbsent: aBlock  ^self basicPresenters at: aName ifAbsent: [ [ self readSlotNamed: aName ] on: SlotNotFound do: aBlock ]-=JUAMPI=-add: aBlock withSpec: aSpec top: top bottom: bottom  self add: aBlock withSpec: aSpec top: top bottom: bottom left: nil right: nil-=JUAMPI=-whenResizingDo: aBlock  self announcer when: WindowResizing do: aBlock-=JUAMPI=-searchValueOf: item  ^self displayValueOf: item-=JUAMPI=-specInitializationStrategy: aStrategy  specInitializationStrategy := aStrategy-=JUAMPI=-step  self objectChanged-=JUAMPI=-updateText  self text: self text-=JUAMPI=-whenAutoDeselectChangedDo: aBlock  self deprecated: 'Should not use. This feature is not supported anymore'.  self property: #autoDeselect whenChangedDo: aBlock-=JUAMPI=-allSelectedItems  | result |  result := OrderedCollection new.  self selected ifTrue: [ result add: self ].  self children value do: [:e |  result addAll: e allSelectedItems ].  ^result-=JUAMPI=-beForText  self deprecated: 'The forCode functionality has moved to TextCodePresenter, please use it instead TextPresenter.' on: '2019-04-05' in: #Pharo8-=JUAMPI=-strongSelectionChanged: aFTStrongSelectionChanged  self presenter activatesOnDoubleClick ifFalse: [ ^self ].  self presenter doubleClickAtIndex: aFTStrongSelectionChanged selectedIndex-=JUAMPI=-testSelectMultipleIndexesRaisesSelectionChangeEventMultipleTimes  | events |  events := 0.  presenter whenSelectionChangedDo: [:selection |  events := events + 1 ].  presenter selectIndex: 1.  presenter selectIndex: 3.  self assert: events equals: 2-=JUAMPI=-whenBorderWidthChanged: aBlock  self deprecated: 'Use #whenBorderWidthChangedDo: instead.' transformWith: '`@receiver whenBorderWidthChanged: `@statements' -> '`@receiver whenBorderWidthChangedDo: `@statements'.  self whenBorderWidthChangedDo: aBlock-=JUAMPI=-selectedIndexes  | selectedIndex |  selectedIndex := self widget getCurrentSelectionIndex.  ^selectedIndex = 0 ifTrue: [ #() ] ifFalse: [ {selectedIndex} ]-=JUAMPI=-searchMatching: aBlock  searchBlock := aBlock.  self enableSearch-=JUAMPI=-adapterName  ^#GridAdapter-=JUAMPI=-preserveLayoutPosition  self owner layoutPolicy preservePositionProportionOn: self owner-=JUAMPI=-selectedContacts  ^table selectedItems-=JUAMPI=-beUnselected  self setSelection: false-=JUAMPI=-classToTest  ^SpLabelledDropList-=JUAMPI=-thumbnailMorph  ^self object taskThumbnailOfSize: self thumbnailSize-=JUAMPI=-radioButtonInstanceSide  ^radioButtonInstanceSide-=JUAMPI=-genderLabel: anObject  genderLabel := anObject-=JUAMPI=-selectPage: aPage  self widgetDo: [:w |  w page: (w pageWithModel: aPage) ]-=JUAMPI=-whenActivatedDo: aBlock  activationBlock := aBlock-=JUAMPI=-defaultInitialExtent  ^400 @ 300-=JUAMPI=-close  self widget ifNotNil: [:w |  w close ]-=JUAMPI=-addLazyPage: aBlock label: aStringOrMorph  self addLazyPage: aBlock label: aStringOrMorph collapsable: false-=JUAMPI=-rightClicked  | evt |  evt := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent yellowButton buttons: MouseButtonEvent yellowButton hand: nil stamp: nil.  self widget click: evt-=JUAMPI=-state  ^state-=JUAMPI=-whenIconChangedDo: aBlock  self property: #icon whenChangedDo: aBlock-=JUAMPI=-doubleClickFirstRowAndColumn: anAdapter  self waitUntilUIRedrawed.  anAdapter widget doubleClick: (MouseEvent new           setPosition: anAdapter widget submorphs first submorphs first bounds center;           yourself)-=JUAMPI=-notifyPropertyChanged: aName  self flag: #todo.  (self observablePropertyNamed: aName) valueChanged-=JUAMPI=-initializeWidgets  input := self instantiate: SpTextInputFieldPresenter.  dropList := self instantiate: SpDropListPresenter.  self focusOrder     add: input;     add: dropList-=JUAMPI=-modelChanged  table items: self model elements-=JUAMPI=-browseSubMenu: aMenu  aMenu addGroup: [:aGroup |  aGroup addItem: [:anItem |  anItem                 name: 'Browse Full';                 action: [ self browseSelectedObject ];                 shortcut: PharoShortcuts current browseShortcut ].        aGroup addItem: [:anItem |  anItem                 name: 'Browse Class';                 action: [ self browseSelectedObjectClass ] ].        aGroup addItem: [:anItem |  anItem                 name: 'Browse Hierarchy';                 action: [ self browseSelectedObjectClassHierarchy ];                 shortcut: $h meta ] ]-=JUAMPI=-presentersInFocusOrder  ^self presenters-=JUAMPI=-unselectPath: aPath  self selection unselectPath: aPath-=JUAMPI=-windowIsOpening  isClosed := false-=JUAMPI=-size  ^self presenters size-=JUAMPI=-extent  ^self widget extent-=JUAMPI=-onActivation  ^onActivation-=JUAMPI=-pageClass  ^SpDemoRadioButtonsPresenter-=JUAMPI=-testShowColumnHeadersRaisesOneEventOnly  | count |  count := 0.  presenter whenShowColumnHeadersChangedDo: [ count := count + 1 ].  presenter showColumnHeaders.  self assert: count equals: 1-=JUAMPI=-initializePresenters  layout := SpMillerLayout newHorizontal-=JUAMPI=-property: aName whenChangedDo: aBlockClosure  (self observablePropertyNamed: aName) whenChangedDo: aBlockClosure-=JUAMPI=-connectPresenters  textField acceptBlock: [:text |  self class environment at: text asSymbol ifPresent: [:class |  methodBrowser messages: class methods ] ifAbsent: [ methodBrowser messages: #() ] ]-=JUAMPI=-calculateHomogeneousRowHeights  | rowHeight |  rowHeight := 0.  morphs do: [:each |  rowHeight := rowHeight max: (self minHeightOf: each) ].  ^Array new: numRows withAll: (self baseRowHeight max: rowHeight)-=JUAMPI=-accept: text notifying: notifyer  ^self selectedMessage ifNotNil: [:message |  message methodClass compile: text classified: message protocol notifying: notifyer ]-=JUAMPI=-initializePresenters  < script: 'self new openWithSpec'>  (button := self newButton)     label: 'Choice';     action: [ text text: text text , button label , String cr ].  menu := self newMenuButton     help: 'An example menu.';     menu: [ self newExampleMenu ];     yourself.  text := self newText-=JUAMPI=-traverseInFocusOrderDo: aBlock excluding: excludes  self presentersInFocusOrder do: [:each |  each traverseInFocusOrderDo: aBlock excluding: excludes ]-=JUAMPI=-= anObject  ^super = anObject and: [ index = anObject index ]-=JUAMPI=-beExpand  self expand: true-=JUAMPI=-stateSelector  ^self state ifNil: [ nil ] ifNotNil: [ #state ]-=JUAMPI=-to: aPresenter  self toPort: aPresenter inputPortDefault-=JUAMPI=-testSelectItemOutsideRangeUnsetsSelectedItem  presenter selectItem: 40.  self assert: presenter selection selectedItem equals: nil-=JUAMPI=-setFocusOrder  self focusOrder     add: changeSorterLeft;     add: changeSorterRight-=JUAMPI=-inspect: anObject  self object: anObject.  self list selectIndex: 1.  self refresh-=JUAMPI=-updateMenu  -=JUAMPI=-model: anObject  model := anObject.  model isSortable ifTrue: [ self sortableUsing: model sortFunction ]-=JUAMPI=-newSearchInput  ^self instantiate: SpSearchInputFieldPresenter-=JUAMPI=-icon  ^icon-=JUAMPI=-aboutText  ^self model model ifNotNil: [:m |  m aboutText ]-=JUAMPI=-footnoteIcon  ^footnoteIcon-=JUAMPI=-updateView  table items: contactBook contents-=JUAMPI=-shouldRefreshItem: item fromAnnouncement: anAnnouncement  ^refreshingBlock cull: item cull: anAnnouncement cull: self-=JUAMPI=-includesPaths: aListOfPaths  ^selection includesAll: aListOfPaths-=JUAMPI=-window  ^self hasWindow ifTrue: [ self root ] ifFalse: [ nil ]-=JUAMPI=-leftFraction  ^layoutFrame leftFraction-=JUAMPI=-selectedBehavior  self flag: #TODO.  ^self behavior-=JUAMPI=-isShowColumnHeaders  ^widget isShowColumnHeaders-=JUAMPI=-useProportionalLayout  -=JUAMPI=-build  ^self buildDynamicPresenter     layout: self buildLayout;     yourself-=JUAMPI=-testUnselectUnselectedPathRaisesNoSelectionEvent  | counter |  counter := 0.  presenter     selectPath: #(1 2);     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectPath: #(2 2).  self assert: counter equals: 0-=JUAMPI=-incomingTransmission: anObject from: outPort  self subclassResponsibility-=JUAMPI=-testWhenNumberTypeChangedDo  | count result |  count := 0.  presenter whenNumberTypeChangedDo: [:value |  count := count + 1.        result := value ].  presenter beFloat.  self assert: count equals: 1.  self assert: result equals: Float-=JUAMPI=-encrypted  ^self model isPassword-=JUAMPI=-minus  ^minus-=JUAMPI=-bottomFraction: anObject  bottomFraction := anObject-=JUAMPI=-