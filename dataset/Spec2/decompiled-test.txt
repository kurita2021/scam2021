method: arg1  method := arg1-=JUAMPI=-taskbarIcon  ^self windowIcon ifNil: [ self presenter ifNil: [ super taskbarIcon ] ifNotNil: #taskbarIcon ]-=JUAMPI=-label  ^self presenter label-=JUAMPI=-selectedItems  | tmp1 tmp2 |  tmp1 := listPresenter listItems.  tmp2 := tmp1 collect: [:arg1 |  | tmp3 |        tmp3 := associationsWrapperToItem at: arg1 ifAbsent: [ nil ].        (tmp3 isNil or: [ arg1 state not ]) ifTrue: [ nil ] ifFalse: [ tmp3 ] ] thenSelect: [:arg1 |  arg1 notNil ].  ^tmp2-=JUAMPI=-whenSelectedItemsChanged: arg1  self deprecated: 'Use #whenSelectionChangedDo: instead' transformWith: '`@receiver whenSelectedItemsChanged: `@argument' -> '`@receiver whenSelectionChangedDo: [ :selection | `@argument cull: selection selectedItems ]'.  self selection whenChangedDo: [:arg2 |  arg1 cull: arg2 selectedItems ]-=JUAMPI=-adoptMenuItemModel: arg1 accumulator: arg2  arg1 subMenu ifNil: [ | tmp1 |        tmp1 := self buildButtonFor: arg1.        arg2 add: tmp1 ] ifNotNil: [ self emptyAccumulator: arg2.        widget addMorphBack: (self theme newToolSpacerIn: widget).        widget add: arg1 name font: self theme menuBarFont icon: arg1 icon help: arg1 description subMenu: arg1 subMenu buildWithSpecAsPopup.        widget addMorphBack: (self theme newToolSpacerIn: widget) ]-=JUAMPI=-addPage: arg1 to: arg2  arg2 addLazyPage: [ self buildContentForPage: arg1 ] label: (self buildLabelForPage: arg1).  arg2 pages last model: arg1-=JUAMPI=-spec: arg1  spec := arg1-=JUAMPI=-widget  ^self adapter widget-=JUAMPI=-display: arg1  ^self list display: arg1-=JUAMPI=-listModel  self deprecated: 'It is not wise to allow external user access the content of a sub presenter. If this is accessed directly, the behavior should probably be moved to the MessageBrowser.'.  ^messageList listModel-=JUAMPI=-hasContentToShow  ^self nodeModel hasContentToShow-=JUAMPI=-testSelectPresenterItemSetsSelectedIndexInWidget  presenter selectItem: 20.  self assert: (self adapter selectedIndexes includes: 2)-=JUAMPI=-testSubscriptionsAreTransfered  | tmp1 |  tmp1 := 0.  presenter beMultipleSelection.  presenter whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ].  presenter beSingleSelection.  presenter selectIndex: 2.  self assert: tmp1 equals: 1-=JUAMPI=-rememberMe: arg1  rememberMe := arg1-=JUAMPI=-isOverlay  ^overlay = true-=JUAMPI=-testStartsWithoutSelection  self assert: self adapter selectedItem equals: nil-=JUAMPI=-fileOutClass: arg1 from: arg2  | tmp1 |  tmp1 := ChangeSet newChangeSet: arg1 name.  tmp1 ifNil: [ ^self ].  tmp1 absorbClass: arg1 name from: arg2.  tmp1 fileOut.  ChangeSet removeChangeSet: tmp1-=JUAMPI=-open  self presenter windowIsOpening-=JUAMPI=-leftOffset  ^layoutFrame leftOffset-=JUAMPI=-testSelectManyIndexesKeepsLastSelectionInWidget  presenter selectIndex: 1.  presenter selectIndex: 2.  self assert: self adapter selectedIndexes equals: #(2)-=JUAMPI=-testInitialSelectedTab  self assert: presenter selectedTab equals: nil.  presenter addTab: redTab.  self assert: presenter selectedTab equals: redTab.  presenter addTab: self redMorphTab.  self assert: presenter selectedTab equals: redTab-=JUAMPI=-whenSelectionIndexChanged: arg1  self list whenSelectionIndexChanged: arg1-=JUAMPI=-testDayBeforeMonthOf  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 9 day: 1)) equals: 6.  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 9 day: 14)) equals: 6.  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 9 day: 30)) equals: 6.  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 10 day: 1)) equals: 1.  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 10 day: 17)) equals: 1.  self assert: (calendar dayBeforeMonthOf: (Date year: 2018 month: 10 day: 30)) equals: 1-=JUAMPI=-testSelectPathSetsSelectedItem  presenter selectPath: #(1 3).  self assert: presenter selection selectedItem equals: 10-=JUAMPI=-initializeWindow  self presenter initializeWindow: self-=JUAMPI=-morph  ^self widget-=JUAMPI=-applyTo: arg1  -=JUAMPI=-selectedPaths  ^selection-=JUAMPI=-newText  ^self instantiate: SpTextPresenter-=JUAMPI=-wantsVisualFeedback  ^wantsVisualFeedback-=JUAMPI=-setFocus  self focusOrder     add: changesListPresenter;     add: classesListPresenter;     add: methodsListPresenter;     add: textPresenter-=JUAMPI=-testActivationOnDoubleClickShouldActivateOnDoubleClick  | tmp1 |  tmp1 := nil.  presenter     activateOnDoubleClick;     whenActivatedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter doubleClickAtIndex: 1.  self assert: tmp1 equals: 10-=JUAMPI=-aboutToStyle: arg1  self deprecated: 'Use #withSyntaxHighlight, #withoutSyntaxHighlight or #syntaxHighlight: instead.' transformWith: '`@receiver aboutToStyle: `@argument' -> '`@receiver syntaxHighlight: `@argument'.  self syntaxHighlight: arg1-=JUAMPI=-execute  self evaluateSelectionAndDo: [:arg1 |  self inspectObject: arg1 ]-=JUAMPI=-contextMenu  ^contextMenu-=JUAMPI=-updatePresenter  self modelChanged-=JUAMPI=-testIconNameFrom  self assert: command iconProvider equals: Smalltalk ui icons.  command iconName: #banana from: self.  self assert: command iconProvider equals: self.  self assert: command icon equals: self banana-=JUAMPI=-resizerWidth  ^self model resizerWidth-=JUAMPI=-whenCurrentActivatedChanged: arg1  self deprecated: 'Use #whenCurrentActivatedChangedDo: instead.' transformWith: '`@receiver whenCurrentActivatedChanged: `@statements' -> '`@receiver whenCurrentActivatedChangedDo: `@statements'.  self whenCurrentActivatedChangedDo: arg1-=JUAMPI=-menuColumn: arg1 row: arg2  | tmp1 |  tmp1 := self model contextMenu.  tmp1 ifNil: [ ^nil ].  ^SpBindings value: self model application adapterBindings during: [ tmp1 value buildWithSpec ]-=JUAMPI=-resizingSetSelector  ^layout isHorizontal ifTrue: [ #hResizing: ] ifFalse: [ #vResizing: ]-=JUAMPI=-leftLabel  ^leftLabel-=JUAMPI=-whenNumberTypeChangedDo: arg1  self property: #numberType whenChangedDo: arg1-=JUAMPI=-setSelectedItem: arg1  self deprecated: 'Use #selectedItem: instead' transformWith: '`@receiver setSelectedItem: `@argument' -> '`@receiver selectedItem:`@argument'.  ^self selectedItem: arg1-=JUAMPI=-oldPage: arg1  oldPage := arg1-=JUAMPI=-registerClassShortcuts: arg1  arg1 bindKeyCombination: PharoShortcuts current browseShortcut toAction: [ self selectedClass ifNotNil: [ self browseMethodFull ] ].  arg1 bindKeyCombination: $d meta toAction: [ self selectedClass ifNotNil: [ self forgetClass ] ].  arg1 bindKeyCombination: PharoShortcuts current removeShortcut toAction: [ self selectedClass ifNotNil: [ self removeClass ] ]-=JUAMPI=-action: arg1  action := arg1-=JUAMPI=-presenterAt: arg1  ^self basicPresenters at: arg1-=JUAMPI=-initialize  super initialize.  self withSyntaxHighlight.  self registerEventsForStyling.  self contextMenu: self buildCodeMenu.  self contextKeyBindings: self buildCodeKeyBindings-=JUAMPI=-y: arg1  y := arg1-=JUAMPI=-iconName: arg1  self icon: (self iconNamed: arg1)-=JUAMPI=-pages  ^layout presenters-=JUAMPI=-isMultipleSelection  ^true-=JUAMPI=-whenCurrentlyActivatedChanged: arg1  self deprecated: 'Use #whenCurrentlyActivatedChangedDo: instead.' transformWith: '`@receiver whenCurrentlyActivatedChanged: `@statements' -> '`@receiver whenCurrentlyActivatedChangedDo: `@statements'.  self whenCurrentlyActivatedChangedDo: arg1-=JUAMPI=-passenger  ^[ self model passenger ]-=JUAMPI=-objectClassPage  ^SpNotebookPage title: 'Object class' icon: (self iconNamed: #nautilusIcon) provider: [ MessageBrowser new messages: Object methods ]-=JUAMPI=-pathOfItem: arg1 root: arg2  arg2 isExpanded ifFalse: [ ^#() ].  (arg2 children includes: arg1) ifTrue: [ ^{(arg2 children indexOf: arg1)} ].  arg2 children withIndexDo: [:arg3 :arg4 |  | tmp1 |        tmp1 := self pathOfItem: arg1 root: arg3.        tmp1 ifNotEmpty: [ ^{arg4} , tmp1 ] ].  ^#()-=JUAMPI=-askOkToClose  ^askOkToClose-=JUAMPI=-expandAll  self changed: #expandAll with: #()-=JUAMPI=-configureButton: arg1 item: arg2  self subclassResponsibility-=JUAMPI=-buildWidget  ^SpTransferMorph new     model: self;     passenger: self passenger;     source: self source;     yourself-=JUAMPI=-value  ^self presenter value-=JUAMPI=-buildWidget  ^SpStubTreeView new-=JUAMPI=-drawOn: arg1  | tmp1 |  tmp1 := self innerBounds.  arg1 fillRectangle: tmp1 fillStyle: self fillStyle.  value > 0 ifTrue: [ cachedWidth := self completedWidth.        tmp1 := (tmp1 left + (cachedWidth - (tmp1 width / 2.5))) @ tmp1 top corner: tmp1 origin + (cachedWidth @ tmp1 height).        arg1 fillRectangle: tmp1 fillStyle: self barFillStyle ].  self borderStyle frameRectangle: self bounds on: arg1-=JUAMPI=-askBeforeChanging  ^self model askBeforeChanging-=JUAMPI=-isEmpty  ^self items isEmpty-=JUAMPI=-content  ^'I am a modal demo with default actions buttons. I set closeOnBackdropClick to true (which is the default value) to close the modal if the user click on the backdrop of the modal. This will trigger the cancel action of the modal.'-=JUAMPI=-headerTitle: arg1  headerTitle := arg1-=JUAMPI=-maxWidth: arg1  self maxExtent: arg1 @ self maxExtentOrDefault y-=JUAMPI=-includesIndex: arg1  ^self selectedIndexes includes: arg1-=JUAMPI=-addItemLeft: arg1  leftPanel addMorphBack: (arg1           vResizing: #spaceFill;           yourself)-=JUAMPI=-selectPaths: arg1  self subclassResponsibility-=JUAMPI=-isStyleProperty  ^true-=JUAMPI=-selectionMode  ^selectionMode-=JUAMPI=-contextMenuFromCommandsGroup: arg1  self contextMenu: [ arg1 value beRoot asMenuPresenter ]-=JUAMPI=-displayedIcon  self model hasIcons ifFalse: [ ^nil ].  ^self widget currentIcon-=JUAMPI=-step  self model step-=JUAMPI=-whenChangedDo: arg1  self announcer when: ValueChanged do: [:arg2 |  arg1 cull: arg2 newValue cull: arg2 oldValue cull: arg2 ]-=JUAMPI=-apply  fromPort attachTransmission: self-=JUAMPI=-onActivation: arg1  onActivation := arg1-=JUAMPI=-manualFractionComputation  | tmp1 |  tmp1 := numberOfProportionals isZero ifTrue: [ 0 ] ifFalse: [ 1 / numberOfProportionals ].  self commands doWithIndex: [:arg1 :arg2 |  arg1 layoutFrame hasNoOffsets ifTrue: [ self setWidgetLayoutWithNoOffset: arg1 at: arg2 delta: tmp1 ] ifFalse: [ self setWidgetLayoutWithOffset: arg1 at: arg2 ] ]-=JUAMPI=-methodsListPresenter  ^methodsListPresenter-=JUAMPI=-removeRootsSuchAs: arg1  self widgetDo: [:arg2 |  arg2 model rootNodes removeAllSuchThat: [:arg3 |  arg1 value: arg3 nodeModel ] ]-=JUAMPI=-initializePresenters  super initializePresenters.  textModel := self newCode.  textModel whenBuiltDo: [:arg1 |  arg1 widget font: self codeFont ].  refreshingBlock := [:arg2 |  true ].  self     initializeDropList;     setFocus-=JUAMPI=-buildWidget  widget := FTTableMorph new     hResizing: #spaceFill;     vResizing: #spaceFill;     intercellSpacing: self class intercellSpacing;     yourself.  self addModelTo: widget.  ^widget-=JUAMPI=-checkboxLabel: arg1  checkboxLabel := arg1-=JUAMPI=-addModelItemsToWindowMenu: arg1  self presenter addModelItemsToWindowMenu: arg1-=JUAMPI=-leftFraction: arg1  ^0-=JUAMPI=-beep  widget flash-=JUAMPI=-initialize  super initialize.  bottomFraction := 1.  bottomOffset := 0.  leftFraction := 0.  leftOffset := 0.  rightFraction := 1.  rightOffset := 0.  topFraction := 0.  topOffset := 0-=JUAMPI=-borderWidth: arg1  borderWidth := arg1-=JUAMPI=-object: arg1  object := arg1-=JUAMPI=-whenSelectedItemChanged: arg1  self list whenSelectedItemChanged: arg1-=JUAMPI=-propertyAt: arg1 ifPresent: arg2 ifAbsent: arg3  ^self properties at: arg1 ifPresent: arg2 ifAbsent: arg3-=JUAMPI=-startWithoutSelection  startsWithSelection := false-=JUAMPI=-model: arg1  model := arg1-=JUAMPI=-testWhenMaximumChangedDo  | tmp1 tmp2 |  tmp1 := 0.  presenter whenMaximumChangedDo: [:arg1 |  tmp1 := tmp1 + 1.        tmp2 := arg1 ].  presenter maximum: 10.  self assert: tmp1 equals: 1.  self assert: tmp2 equals: 10-=JUAMPI=-testSelectItemSetsSelectedIndex  presenter selectItem: 20.  self assert: presenter selection selectedIndex equals: 2-=JUAMPI=-includesPath: arg1  ^selection includes: arg1-=JUAMPI=-application  ^self hasOwner ifTrue: [ self owner application ] ifFalse: [ application ifNil: [ self flag: #TODO.              application := SpApplication defaultApplication ] ]-=JUAMPI=-property: arg1 rawValue: arg2  (self observablePropertyNamed: arg1) rawValue: arg2-=JUAMPI=-descriptionPresenter: arg1  descriptionPresenter := arg1-=JUAMPI=-checkThatSidesDiffer: arg1  changeSorterLeft selectedChangeSet == changeSorterRight selectedChangeSet ifFalse: [ ^self ].  self inform: 'This command requires that thechange sets selected on the twosides of the change sorter *not*be the same.'.  ^arg1 value-=JUAMPI=-send: arg1 withArguments: arg2  self commands add: (SpLayoutSend selector: arg1)-=JUAMPI=-buildWidget  | tmp1 |  tmp1 := SpAthensMorph new.  self presenter whenDrawBlockChangedDo: [:arg1 |  tmp1 drawBlock: arg1 ].  self presenter whenExtentChangedDo: [:arg2 |  tmp1 extent: arg2 ].  tmp1 extent: self presenter surfaceExtent.  tmp1 drawBlock: self presenter drawBlock.  tmp1 setBalloonText: self model help.  self presenter whenHelpChangedDo: [ tmp1 setBalloonText: self model help ].  ^tmp1-=JUAMPI=-shortcuts  | tmp1 |  tmp1 := OrderedCollection new.  KMRepository default categories do: [:arg1 |  arg1 keymaps do: [:arg2 |  tmp1 add: (KMShortcutDeclaration new                       shortcutName: arg2 name;                       categoryName: arg1 name;                       yourself) ] ].  ^tmp1 sorted: #categoryName ascending-=JUAMPI=-buildAdapterWithSpecLayout: arg1  ^SpBindings value: self application adapterBindings during: [ self basicBuildAdapterWithSpecLayout: arg1 ]-=JUAMPI=-children  ^childrenBlock-=JUAMPI=-instantiateModels: arg1  self deprecated: 'Use #instantiatePresenters: instead' transformWith: '`@receiver instantiateModels: `@statement' -> '`@receiver instantiatePresenters: `@statement'.  ^self instantiatePresenters: arg1-=JUAMPI=-pushMessage: arg1 to: arg2  pushedMessages add: arg1.  arg2     removeAllMorphs;     addMorph: arg1 asStringMorph-=JUAMPI=-defaultDate  ^Date today-=JUAMPI=-presenter: arg1  presenter := arg1-=JUAMPI=-addConstraits: arg1 toChild: arg2  | tmp1 |  tmp1 := arg2.  tmp1 setProperty: #constraints toValue: arg1.  ^tmp1-=JUAMPI=-addModelTo: arg1  self model columns do: [:arg2 |  arg1 addColumn: (self newColumnFrom: arg2) ].  self ensureAtLeastOneColumnIn: arg1.  self isResizable ifTrue: [ arg1 beResizable ] ifFalse: [ arg1 beNotResizable ].  arg1 setMultipleSelection: self model isMultipleSelection.  self refreshShowColumnHeaders.  self refreshWidgetSelection.  self presenter whenShowColumnHeadersChangedDo: [:arg3 |  self refreshShowColumnHeaders ].  self presenter whenModelChangedDo: [ widget refresh ].  self presenter whenColumnsChangedDo: [ self refreshColumnsInWidget ].  arg1 setBalloonText: self help.  self configureScrolling.  arg1     onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self;     onAnnouncement: FTStrongSelectionChanged send: #strongSelectionChanged: to: self.  arg1 dataSource: self newDataSource.  self presenter whenItemFilterBlockChangedDo: [:arg4 |  self updateItemFilterBlockWith: arg4 ].  self presenter whenSearchChangedDo: [ self updateSearch ].  self updateItemFilterBlockWith: self itemFilter-=JUAMPI=-addColumn: arg1  columns add: arg1-=JUAMPI=-submitButton  ^submitButton-=JUAMPI=-enabled: arg1  ^self subclassResponsibility-=JUAMPI=-addItemsFromContext: arg1  self flag: #TODO-=JUAMPI=-hasCustomSearch  ^searchBlock notNil-=JUAMPI=-unregisterShortcut: arg1  | tmp1 |  tmp1 := self window.  (tmp1 isNil or: [ arg1 isNil ]) ifTrue: [ ^self ].  tmp1 model removeKeyCombination: arg1-=JUAMPI=-inspectValue  ^self value inspect-=JUAMPI=-columns  ^widget columns-=JUAMPI=-testSmokeTestForDemoPages  self timeLimit: 1 minute.  SpDemoPage availablePages do: [:arg1 |  [ [ window := arg1 new openWithSpec ] on: Error do: [:arg2 |  self fail: 'Broken demo page: ' , arg1 asString , '' , arg2 signalerContext shortStack ] ] ensure: [ window ifNotNil: #close ] ]-=JUAMPI=-buildWidget  ^SpStubGridView new-=JUAMPI=-objectAsUnicodeCodePoint  ^String streamContents: [:arg1 |  arg1 << 'U+'.        self object codePoint printOn: arg1 base: 16 nDigits: 4 ]-=JUAMPI=-classToTest  ^SpMethodToolbar-=JUAMPI=-initialize  self flag: #pharoTodo.  super initialize.  oddPassage := true-=JUAMPI=-initializeTestedInstance  presenter     min: 1;     max: 100;     quantum: 1;     value: 20-=JUAMPI=-taskbarIcon  ^self model taskbarIcon-=JUAMPI=-defineInputPorts  ^{SpTextPort new}-=JUAMPI=-whenMenuChangedDo: arg1  self property: #menu whenChangedDo: arg1-=JUAMPI=-hasButtonWithLabel: arg1  ^self widget leftPanel submorphs , self widget rightPanel submorphs detect: [:arg2 |  (arg2 isKindOf: SpToolBarButtonMorph) and: [ arg2 label = arg1 ] ] ifFound: [ true ] ifNone: [ false ]-=JUAMPI=-visiblePages  ^visiblePages-=JUAMPI=-vShrinkWrap  self subclassResponsibility-=JUAMPI=-show  self widgetDo: #show-=JUAMPI=-selectedElement  ^self list selection selectedItem ifNil: [ self list selectedIndex ifNotNil: [:arg1 |  arg1 = 0 ifTrue: [ ^nil ].              self list listItems ifNotEmpty: [:arg2 |  arg2 at: arg1 ] ] ]-=JUAMPI=-initializePresenters  super initializePresenters.  self content: SpInputTextDropList-=JUAMPI=-testSelectInvalidPathsIsEmpty  presenter selectPaths: {#(40) .         #(10 20)}.  self assert: presenter selection isEmpty-=JUAMPI=-add: arg1 withSpec: arg2 left: arg3 right: arg4  self add: arg1 withSpec: arg2 top: nil bottom: nil left: arg3 right: arg4-=JUAMPI=-exploreValue  ^self value inspect-=JUAMPI=-enabled  ^self presenter isEnabled-=JUAMPI=-basicSelectIndex: arg1  selectedIndex := arg1-=JUAMPI=-acceptDroppingMorph: arg1 event: arg2 inMorph: arg3  | tmp1 |  tmp1 := self widget ifNotNil: [:arg4 |  arg4 scrollerSubMorphFromPoint: arg2 position ].  tmp1 ifNil: [ ^self ].  ^self acceptDropBlock valueWithEnoughArguments: {arg1 model model .         arg2 .         arg3 model model model .         tmp1 model nodeModel}-=JUAMPI=-observablePropertyNamed: arg1  | tmp1 |  tmp1 := self class slotNamed: arg1.  tmp1 isObservableSlot ifFalse: [ SpNonObservableSlotError signal: arg1 ].  ^tmp1 rawRead: self-=JUAMPI=-page: arg1  page := arg1-=JUAMPI=-step  | tmp1 tmp2 |  tmp1 := transformationMorph rotationDegrees.  tmp2 := transformationMorph transform withAngle: (tmp1 + 15) degreesToRadians negated.  transformationMorph     transform: tmp2;     invalidRect: transformationMorph fullBounds-=JUAMPI=-testShortcutKey  self should: [ command shortcutKey ] raise: CmNoShortcutIsDefined.  command shortcutKey: $a asKeyCombination.  self assert: command shortcutKey equals: $a asKeyCombination-=JUAMPI=-addPaneSplitters  self removePaneSplitters.  self addPaneVSplitters.  self addPaneHSplitters.  self linkSplittersToSplitters-=JUAMPI=-rebuildWithSpecLayout: arg1  | tmp1 |  tmp1 := self model window submorphs copy.  self model window removeAllMorphs.  tmp1 allButLast do: [:arg2 |  self model window addMorphBack: arg2 ].  self model addPresenterIn: self widget withSpecLayout: arg1.  self widget model: self-=JUAMPI=-label  ^label-=JUAMPI=-initialize  super initialize.  name := 'some name'.  surname := ''.  number1 := 1.  number2 := 12.009.  scale := 42.  password := 'password'.  rememberMe := true.  date := '2018-01-01' asDate.  gender := #male.  selectedItems := {(self items at: 3) .   (self items at: 4)}-=JUAMPI=-shortcut  ^shortcut-=JUAMPI=-labelClickable: arg1  labelClickableHolder value: arg1-=JUAMPI=-menuColumn: arg1 row: arg2  | tmp1 |  tmp1 := self model contextMenu.  tmp1 ifNil: [ ^nil ].  ^SpBindings value: self model application adapterBindings during: [ | tmp2 |        tmp2 := tmp1 value.        tmp2 isMorph ifTrue: [ tmp2 ] ifFalse: [ tmp2 buildWithSpec ] ]-=JUAMPI=-target  ^self owner ifNotNil: [:arg1 |  arg1 submorphs before: self ]-=JUAMPI=-limit2  ^10-=JUAMPI=-prepareAsStandaloneApplication  -=JUAMPI=-open  ^self openWithSpec-=JUAMPI=-whenQuantumChangedDo: arg1  self property: #quantum whenChangedDo: arg1-=JUAMPI=-testTextWithStyle  | tmp1 |  presenter     behavior: nil;     doItReceiver: Object;     type: 'self asString.'.  tmp1 := self adapter textWithStyle.  self assertText: tmp1 atInterval: (1 to: 4) isStyle: #self.  self assertText: tmp1 atInterval: (6 to: 13) isStyle: #unary.  presenter type: '10 + 42.0'.  tmp1 := self adapter textWithStyle.  self assertText: tmp1 atInterval: (1 to: 2) isStyle: #integer.  self assertText: tmp1 atInterval: (4 to: 4) isStyle: #binary.  self assertText: tmp1 atInterval: (6 to: 9) isStyle: #number.  presenter behavior: Object.  presenter type: 'm1 ^ "test" 42'.  tmp1 := self adapter textWithStyle.  self assertText: tmp1 atInterval: (1 to: 2) isStyle: #patternKeyword.  self assertText: tmp1 atInterval: (4 to: 4) isStyle: #return.  self assertText: tmp1 atInterval: (6 to: 11) isStyle: #comment.  self assertText: tmp1 atInterval: (13 to: 14) isStyle: #number-=JUAMPI=-testRightClickShowsMenu  | tmp1 |  presenter contextMenu: (tmp1 := SpMockMenuPresenter new).  self deny: tmp1 shown.  self emulateRightClick.  self assert: tmp1 shown-=JUAMPI=-spacing  ^spacing-=JUAMPI=-buildAdapterFor: arg1 bindings: arg2  adapter := (arg1 needRebuild or: [ arg1 adapter isNil ]) ifTrue: [ (arg2 adapterClass: self adapterName) adapt: arg1 ] ifFalse: [ arg1 adapter           removeSubWidgets;           yourself ].  arg1 needRebuild: true.  adapter layout: self.  children keysAndValuesDo: [:arg3 :arg4 |  adapter add: (self resolvePresenter: arg3 presenter: arg1 bindings: arg2) constraints: arg4 ].  ^adapter-=JUAMPI=-oldPage  ^oldPage-=JUAMPI=-asMenuPresenterWith: arg1  | tmp1 |  tmp1 := SpMenuPresenterBuilder new.  arg1 value: tmp1 menuPresenter.  ^tmp1     visit: self;     menuPresenter-=JUAMPI=-newNumberInput  ^self instantiate: SpNumberInputFieldPresenter-=JUAMPI=-redMorphTab  presenter     label: 'Red Morph';     icon: (presenter iconNamed: #smallBackIcon);     contents: (Morph new           color: Color red;           yourself)-=JUAMPI=-topologicSort: arg1  topologySort := arg1-=JUAMPI=-presenter  ^presenter-=JUAMPI=-label  ^label-=JUAMPI=-shown  ^shown-=JUAMPI=-newListColumn  ^SpMorphicTableColumn new     model: (SpStringTableColumn title: self presenter headerTitle evaluated: self presenter display);     yourself-=JUAMPI=-classToTest  ^SpTextInputFieldPresenter-=JUAMPI=-surnameTextInput: arg1  surnameTextInput := arg1-=JUAMPI=-buildLabel: arg1 withIcon: arg2  arg2 ifNil: [ ^arg1 ifNil: [ '' ] ifNotNil: [ arg1 ] ].  ^IconicListItem text: arg1 icon: arg2-=JUAMPI=-fromSpec: arg1  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  arg1 label ifNotNil: [:arg2 |  self title: arg2 ].  tmp2 := OrderedCollection new.  arg1 items do: [:arg3 |  tmp2 add: arg3.        arg3 separator ifTrue: [ tmp1 add: tmp2 copy.              tmp2 removeAll ] ].  tmp2 ifNotEmpty: [ tmp1 add: tmp2 copy ].  tmp1 do: [:arg3 |  self addGroup: [:arg4 |  arg3 do: [:arg5 |  arg4 addItem: [:arg6 |  arg6 fromSpec: arg5 ] ] ] ]-=JUAMPI=-initialize: arg1  text label: arg1 asString-=JUAMPI=-initialize  super initialize.  borderWidth := 0.  borderColor := Color transparent.  enabled := true.  dragEnabled := false.  dropEnabled := false.  dragTransformationBlock := [:arg1 :arg2 |  arg1 ].  wantDropBlock := [:arg3 :arg4 :arg2 |  self dropEnabled ].  acceptDropBlock := [:arg3 :arg4 :arg2 |   ].  transferBlock := [:arg5 :arg2 |  self defaultTransferFor: arg5 from: arg2 ].  color := self defaultColor.  self whenHelpChangedDo: [:arg6 |  self withAdapterDo: [:arg7 |  arg7 update: #setBalloonText: with: {arg6} ] ].  self whenBorderWidthChangedDo: [:arg8 |  self withWidgetDo: [:arg7 |  arg7 update: #borderWidth: with: {arg8} ] ].  self whenBorderColorChangedDo: [:arg9 |  self withWidgetDo: [:arg7 |  arg7 update: #borderColor: with: {arg9} ] ].  self property: #color whenChangedDo: [:arg9 |  self withAdapterDo: [:arg7 |  arg7 update: #color: with: {arg9} ] ].  self whenEnabledChangedDo: [:arg10 |  self withAdapterDo: [:arg7 |  arg7 update: #enabled: with: {arg10} ] ].  self property: #dragEnabled whenChangedDo: [:arg10 |  self withWidgetDo: [:arg7 |  arg7 update: #dragEnabled: with: {arg10} ] ].  self property: #dropEnabled whenChangedDo: [:arg10 |  self withWidgetDo: [:arg7 |  arg7 update: #dropEnabled: with: {arg10} ] ].  styles := #()-=JUAMPI=-menu  ^menuBlockHolder value-=JUAMPI=-assertText: arg1 at: arg2 isStyle: arg3  | tmp1 |  tmp1 := SpCodeStyleForTest new.  arg1 attributesAt: arg2 do: [:arg4 |  self fillTag: tmp1 withAttribute: arg4 ].  self assert: tmp1 equals: (self style: arg3)-=JUAMPI=-newMultiColumnList  self deprecated: 'Use newTable instead' on: '2019-02-05' in: #Pharo8.  ^self instantiate: SpMultiColumnListPresenter-=JUAMPI=-actionArguments  ^[ Array with: self ]-=JUAMPI=-whenSelectionChanged: arg1  self deprecated: 'Use #whenSelectionChangedDo: instead' transformWith: '`@receiver whenSelectionChanged: `@argument' -> '`@receiver whenSelectionChangedDo: `@argument'.  ^self whenSelectionChangedDo: arg1-=JUAMPI=-testModelSettingValueHolderToModel  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := 1 @ 0.  tmp1 := SpTestingPointModel x: 1 y: 2.  tmp3 := NewValueHolder value: tmp2.  tmp4 := SpTestingPresenterWithModel on: tmp1.  self assert: tmp4 announcingObject isSpAnnouncingObject.  self deny: tmp4 announcingObject isValueHolder.  self assert: tmp3 isSpAnnouncingObject.  self assert: tmp3 isValueHolder.  tmp4 model: tmp3.  self assert: tmp4 announcingObject isSpAnnouncingObject.  self assert: tmp4 announcingObject isValueHolder.  self assert: tmp4 announcingObject == tmp3.  self assert: tmp4 announcingObject announcer numberOfSubscriptions > 0-=JUAMPI=-resizeCursor  ^Cursor resizeForEdge: self edgeName-=JUAMPI=-createNullPresenters: arg1  nullPresentersInstVarNames := self generateNullPresentersInstVarNames: arg1.  dynamicPresenter instantiatePresenters: self nullPresentersInstVarNamesAndPresenterNamesArray-=JUAMPI=-block: arg1 layoutFrame: arg2  | tmp1 |  tmp1 := SpColumnLayout composed.  arg1 value: tmp1.  subwidget := tmp1.  self layoutFrame: arg2-=JUAMPI=-addInstancesVariable: arg1  -=JUAMPI=-number: arg1  self text: arg1 asString-=JUAMPI=-currentlyActivated  ^currentlyActivated-=JUAMPI=-whenCanDeselectByClickChangedDo: arg1  self deprecated: 'It is not clear what option to select if deselected'-=JUAMPI=-newTextInput  ^self instantiate: SpTextInputFieldPresenter-=JUAMPI=-testDaysAfterMonthOf  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 9 day: 1)) equals: 6.  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 9 day: 14)) equals: 6.  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 9 day: 30)) equals: 6.  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 10 day: 1)) equals: 10.  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 10 day: 17)) equals: 10.  self assert: (calendar daysAfterMonthOf: (Date year: 2018 month: 10 day: 30)) equals: 10-=JUAMPI=-testIsDisplayed  windowPresenter := SpTextPresenter new openWithSpec.  self assert: windowPresenter isDisplayed.  windowPresenter window minimize.  self assert: windowPresenter isDisplayed.  windowPresenter window close.  self assert: windowPresenter isDisplayed not-=JUAMPI=-calculateHomogeneousColumnWidths  | tmp1 |  tmp1 := 0.  morphs do: [:arg1 |  tmp1 := tmp1 max: (self minWidthOf: arg1) ].  ^Array new: numColumns withAll: (self baseColumnWidth max: tmp1)-=JUAMPI=-theme  ^theme-=JUAMPI=-forgetSelector: arg1 inClass: arg2 fromChangeSet: arg3  arg3 removeSelectorChanges: arg1 class: arg2-=JUAMPI=-dateInput: arg1  dateInput := arg1-=JUAMPI=-testRemoveHeaderTitleInPresenterRemovesColumnHeaderMorph  self flag: #pharo7.  SystemVersion current major < 8 ifTrue: [ self skip ].  self presenter headerTitle: 'test'.  self presenter hideHeaderTitle.  backendForTest denyHasHeader: self adapter-=JUAMPI=-initialize  self class initializeSlots: self.  super initialize-=JUAMPI=-commands: arg1  commands := arg1-=JUAMPI=-initialize  super initialize.  self spec: #defaultSpec-=JUAMPI=-initializeWindow: arg1  arg1     title: self title;     initialExtent: 500 @ 350-=JUAMPI=-ensureHeightPosition: arg1 in: arg2  | tmp1 |  self position ifNil: [ ^self ].  tmp1 := arg1 submorphs first.  tmp1 vResizing = #rigid ifFalse: [ tmp1 vResizing: #rigid ].  tmp1 privateBounds: (tmp1 bounds withHeight: (self heightPositionIn: arg2 extent))-=JUAMPI=-takeKeyboardFocus  ^self inspector takeKeyboardFocus-=JUAMPI=-resetArrayComputation  super resetArrayComputation.  currentOffset := 0.  currentProportional := 0.  numberOfProportionals := 0.  lastFractionIndex := 0.  autoFractionComputation := true.  size := self commands size-=JUAMPI=-fillItem: arg1 with: arg2  arg1     name: arg2 name;     description: arg2 description;     icon: arg2 icon;     action: [ arg2 execute ].  arg2 hasShortcutKey ifTrue: [ arg1 shortcut: arg2 shortcutKey ].  ^arg1-=JUAMPI=-surnameLabel  ^surnameLabel-=JUAMPI=-valueAtColumn: arg1 row: arg2  ^(columns at: arg1) readObject: (self model items at: arg2)-=JUAMPI=-testActivateRaisesActivatedEvent  presenter state: false.  self assertEvent: #whenActivatedDo: isRaisedInPresenter: presenter whenDoing: [ presenter state: true ]-=JUAMPI=-hSpaceFill  self subclassResponsibility-=JUAMPI=-isDisplayed  self flag: #TODO.  ^self hasWindow ifTrue: [ self root isDisplayed ] ifFalse: [ false ]-=JUAMPI=-beIcons  self displayMode: SpToolBarDisplayMode modeIcon-=JUAMPI=-whenHelpChangedDo: arg1  self property: #help whenChangedDo: arg1-=JUAMPI=-menu  self deprecated: 'Use #contextMenu instead.' transformWith: '`@receiver menu' -> '`@receiver contextMenu'.  ^self contextMenu-=JUAMPI=-mainIcon  ^mainIcon-=JUAMPI=-fileOutMessage  self selectedSelector ifNotNil: [:arg1 |  Cursor write showWhile: [ self model fileOutSelector: arg1 from: self selectedClass ] ]-=JUAMPI=-resetTo: arg1  self presenters copy withIndexDo: [:arg2 :arg3 |  arg3 <= arg1 ifFalse: [ layout remove: arg2 ] ]-=JUAMPI=-property: arg1 whenChangedDo: arg2  (self observablePropertyNamed: arg1) whenChangedDo: arg2-=JUAMPI=-browseMessages  self currentMethod ifNotNil: [:arg1 |  model browseMessagesFrom: arg1 selector ]-=JUAMPI=-menuGroups  ^self model menuGroups reject: [:arg1 |  arg1 isEmpty ]-=JUAMPI=-testObservableSlotWorksAsNormalSlot  point x: 17.  point y: 299.  self assert: point x equals: 17.  self assert: point y equals: 299-=JUAMPI=-childrenBlock  ^tree childrenBlock-=JUAMPI=-layout: arg1  layout := arg1-=JUAMPI=-selector  ^self selection asSymbol-=JUAMPI=-refreshWidgetSelection  | tmp1 |  tmp1 := self presenter selection selectedIndexes.  tmp1 = self widget selectedIndexes ifTrue: [ ^self ].  tmp1 isEmpty ifTrue: [ self widget basicSelectIndexes: #() ] ifFalse: [ self widget basicSelectIndexes: tmp1 ].  ^self widget refresh-=JUAMPI=-aboutTitle  (self presenter respondsTo: #aboutTitle) ifTrue: [ ^self presenter aboutTitle ].  ^self presenter toolName-=JUAMPI=-namesOfDaysLabels  ^namesOfDaysLabels-=JUAMPI=-activate  activationBlock value: (SpMillerActivation on: 1)-=JUAMPI=-fixedAt: arg1  self state: (SpProgressBarFixed value: arg1)-=JUAMPI=-adapter  ^self-=JUAMPI=-emptyList  self dropList emptyList-=JUAMPI=-whenExtentForPreviewChanged: arg1  extentForPreview whenChangedDo: arg1-=JUAMPI=-save: arg1  saveBlock value: arg1-=JUAMPI=-compareToCurrentVersion  self compareTo: rgMethod withLabel: 'Current version'-=JUAMPI=-performHeaderActionSelector  ^self headerAction ifNil: [ nil ] ifNotNil: [ #performHeaderAction ]-=JUAMPI=-initializeTestedInstance  super initializeTestedInstance.  presenter addColumn: (SpStringTableColumn evaluated: [:arg1 |  arg1 displayString ])-=JUAMPI=-whenSelectedItemChanged: arg1  messageList whenSelectedItemChanged: arg1-=JUAMPI=-selectedItem: arg1  self deprecated: 'Use #selectItem: instead' transformWith: '`@receiver selectedItem: `@arg' -> '`@receiver selectItem: `@arg'.  self selectItem: arg1-=JUAMPI=-subMenu: arg1  arg1 ifNotNil: [ arg1 owner: self ].  subMenu := arg1-=JUAMPI=-model  ^model-=JUAMPI=-rowSpan  ^self span y-=JUAMPI=-surnameLabel: arg1  surnameLabel := arg1-=JUAMPI=-initializeWindow: arg1  arg1     title: 'Transmission example browser';     initialExtent: 800 @ 600-=JUAMPI=-rootMenu  ^self owner isMenuPresenter ifTrue: [ self owner rootMenu ] ifFalse: [ self ]-=JUAMPI=-object  ^self inspector object-=JUAMPI=-cacheHierarchyForClasses: arg1  cachedHierarchy := self buildHierarchyForMessages: arg1-=JUAMPI=-testWhenStateChangedDo  presenter whenStateChangedDo: [:arg1 :arg2 |  self deny: arg2.        self assert: arg1 ].  self deny: presenter state.  self openInstance.  presenter state: true.  self assert: presenter state-=JUAMPI=-testRightClickShowsMenu  | tmp1 |  presenter contextMenu: (tmp1 := SpMockMenuPresenter new).  self deny: tmp1 shown.  self emulateRightClick.  self assert: tmp1 shown-=JUAMPI=-url: arg1  self action: [ WebBrowser openOn: arg1 ].  self label ifNil: [ self label: arg1 ]-=JUAMPI=-beColumnHomogeneous  self columnHomogeneous: true-=JUAMPI=-clicked  | tmp1 |  tmp1 := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent redButton buttons: MouseButtonEvent redButton hand: nil stamp: nil.  (widget handlesMouseDown: tmp1) ifTrue: [ widget mouseDown: tmp1.        widget mouseUp: tmp1 ]-=JUAMPI=-classToTest  ^SpRGBSliders-=JUAMPI=-whenMaximumChangedDo: arg1  self property: #maximum whenChangedDo: arg1-=JUAMPI=-whenSyntaxHighlightChangedDo: arg1  self property: #syntaxHighlight whenChangedDo: arg1-=JUAMPI=-displayBlock: arg1  displayBlock value: arg1-=JUAMPI=-newButton  ^PluggableButtonMorph on: self getState: #state action: #action label: #label menu: #menu:-=JUAMPI=-layoutSpec  ^layoutSpec-=JUAMPI=-eventKeyStrokesForPreviousFocus  ^{Character tab shift asKeyCombination}-=JUAMPI=-isEmpty  ^self subclassResponsibility-=JUAMPI=-whenValueChangedDo: arg1  slider whenValueChangedDo: arg1-=JUAMPI=-newColumnFrom: arg1  ^(SpMorphicTableColumn on: arg1)     width: arg1 width;     yourself-=JUAMPI=-encrypted: arg1  ^self input encrypted: arg1-=JUAMPI=-testShowPresenterShowsWidget  self skip-=JUAMPI=-initialize  super initialize.  paneMorphs := OrderedCollection new-=JUAMPI=-classToTest  ^SpSliderPresenter-=JUAMPI=-assertEvent: arg1 isRaisedInPresenter: arg2 whenDoing: arg3  self assertWith: [:arg4 |  arg4 > 0 ] timesRaisedEvent: arg1 inPresenter: arg2 whenDoing: arg3-=JUAMPI=-initializePresenters  fieldNormal := self newTextInput.  fieldDisabled := self newTextInput enabled: false.  fieldPlaceholderText := self newTextInput placeholder: 'Placeholder text'.  fieldEncrypted := self newTextInput     text: 'Password';     bePassword-=JUAMPI=-autoRefresh: arg1  autoRefresh := arg1-=JUAMPI=-okAction  ^okAction-=JUAMPI=-testChangingHelpAffectTheWidget  ^self skip-=JUAMPI=-whenCurrentActivatedChangedDo: arg1  currentActivated whenChangedDo: arg1-=JUAMPI=-testUnselectWidgetIndexRaisesSelectionIndexChangeEventOnce  | tmp1 |  tmp1 := 0.  self adapter selectPath: #(1).  presenter selection whenChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  self adapter selectPath: #().  self assert: tmp1 equals: 1-=JUAMPI=-methodBrowser  ^methodBrowser-=JUAMPI=-show  visible := true-=JUAMPI=-initializePresenters  listModel := self instantiate: SpListPresenter.  textModel := self newCode.  toolbarModel := self instantiate: SpMethodToolbar.  self focusOrder     add: listModel;     add: toolbarModel;     add: textModel-=JUAMPI=-maxHeight: arg1  self maxExtent: self maxExtentOrDefault x @ arg1-=JUAMPI=-updateClassesList  | tmp1 |  tmp1 := self selectedClass.  self selectedChangeSet ifNil: [ classesListPresenter items: {} ] ifNotNil: [:arg1 |  classesListPresenter items: (arg1 changedClasses sort: [:arg2 :arg3 |  arg2 name < arg3 name ]) ].  tmp1 ifNotNil: [ classesListPresenter selectItem: tmp1 ]-=JUAMPI=-addLazyPage: arg1 label: arg2 action: arg3  | tmp1 tmp2 |  tmp1 := SpNotebookPageMorph new.  tmp1 lazyPageMorphCreation: arg1.  tmp2 := self buildLabelFrom: arg2 withAction: arg3.  tmp1 labelMorph: tmp2.  self addPage: tmp1 label: tmp2-=JUAMPI=-label: arg1  self button label: arg1-=JUAMPI=-testSelectWidgetIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | tmp1 |  presenter selection whenChangedDo: [:arg1 |  tmp1 := arg1 selectedIndexes ].  self adapter selectIndex: 1.  self assert: (tmp1 includes: 1)-=JUAMPI=-selectedItems: arg1  selectedItems := arg1 asArray-=JUAMPI=-label  ^label-=JUAMPI=-layout: arg1 in: arg2  arg1 submorphsDo: [:arg3 |  | tmp1 |        tmp1 := arg3 valueOfProperty: #constraints.        (arg3 visible and: [ tmp1 isOverlay not ]) ifTrue: [ arg3 bounds: arg2 ].        (arg3 visible and: [ tmp1 isOverlay ]) ifTrue: [ | tmp2 tmp3 tmp4 tmp5 |              tmp2 := arg2 area > (0 @ 0 corner: arg3 extent) area ifTrue: [ arg2 origin corner: arg2 origin + arg3 extent ] ifFalse: [ arg2 ].              tmp3 := arg2 width / 2 - (tmp2 width / 2).              tmp4 := arg2 height / 2 - (tmp2 height / 2).              tmp5 := arg2 origin + (tmp3 @ tmp4) corner: arg2 corner + (tmp3 @ tmp4).              arg3 bounds: tmp5 ].        arg3 visible ifFalse: [ arg3 bounds: (0 @ 0 corner: 0 @ 0) ] ]-=JUAMPI=-openWithSpec  self layout ifNil: [ ^super openWithSpec ].  ^self application open: self withSpecLayout: self layout-=JUAMPI=-classToTest  ^SpLabelPresenter-=JUAMPI=-updateText  textRefreshingProcess ifNotNil: [ textRefreshingProcess terminate ].  textRefreshingProcess := [ | tmp1 tmp2 |  tmp1 := listModel selection selectedIndexes sort collect: [:arg1 |  arg1 printString ].  tmp1 := tmp1 joinUsing: '; '.  tmp2 := listModel selectedItems collect: [:arg1 |  arg1 printString ].  tmp2 := tmp2 sort joinUsing: '; '.  UIManager default defer: [ textModel1 text: tmp1.        textModel2 text: tmp2 ] ] fork-=JUAMPI=-enableSearch  searchEnabled := true-=JUAMPI=-traversePresentersDo: arg1  self traversePresentersDo: arg1 excluding: Set new-=JUAMPI=-eventKeyStrokesForNextFocus  ^{Character arrowRight command ctrl asKeyCombination}-=JUAMPI=-selector: arg1  selector := arg1-=JUAMPI=-popUpInWorld: arg1  self shown: true-=JUAMPI=-wantsVisualFeedback  ^self model wantsVisualFeedback-=JUAMPI=-getText  ^self model text-=JUAMPI=-display: arg1  tree display: arg1-=JUAMPI=-implementorsMethod  self method ifNotNil: [:arg1 |  self model browseMessagesFrom: arg1 selector ]-=JUAMPI=-testSmokeOpenEmptyPresenter  window := presenter openWithSpec-=JUAMPI=-scrollingChanged  widget container updateAllRows.  self presenter verticalAlignment     firstVisibleRowIndex: widget firstVisibleRowIndex;     lastVisibleRowIndex: widget lastVisibleRowIndex-=JUAMPI=-computeNumberOfRowsAndColumns  numRows := 0.  numColumns := 0.  self allGridConstraints do: [:arg1 |  numRows := numRows max: arg1 row + arg1 rowSpan - 1.        numColumns := numColumns max: arg1 column + arg1 columnSpan - 1 ]-=JUAMPI=-list1  ^list1-=JUAMPI=-newMenuBar  ^self instantiate: SpMenuBarPresenter-=JUAMPI=-vRigid  self subclassResponsibility-=JUAMPI=-preferedPaneColor  ^preferedPaneColor value-=JUAMPI=-whenTextChanged: arg1  self deprecated: 'Use #whenTextChangedDo: instead.' transformWith: '`@receiver whenTextChanged: `@statement' -> '`@receiver whenTextChangedDo: `@statement'.  self whenTextChangedDo: arg1-=JUAMPI=-setX: arg1 setY: arg2  x := arg1.  y := arg2-=JUAMPI=-contextMenu: arg1  contextMenu := arg1-=JUAMPI=-initializePresenters  element11 := self newMorph morph: (Morph new color: Color red).  element21 := self newMorph morph: (Morph new color: Color green).  element12 := self newMorph morph: (Morph new color: Color blue).  element22 := self newMorph morph: (Morph new color: Color yellow).  borderWidth := self newSlider     beHorizontal;     min: 0;     max: 100.  columnSpacing := self newSlider     beHorizontal;     min: 0;     max: 100.  rowSpacing := self newSlider     beHorizontal;     min: 0;     max: 100.  columnHomogeneous := self newCheckBox label: 'Column is homogeneous'.  rowHomogeneous := self newCheckBox label: 'Row is homogeneous'.  self announcer when: SpWidgetBuilt send: #widgetBuilt: to: self-=JUAMPI=-classToTest  ^SpNumberInputFieldPresenter-=JUAMPI=-classToTest  ^SpCodePresenter-=JUAMPI=-chooseDateButton  ^chooseDateButton-=JUAMPI=-testDoesNotUnderstand  | tmp1 |  themeDecorator property: #foo returnsValueOf: 42.  self assert: themeDecorator foo equals: 42.  tmp1 := [ 42 ].  themeDecorator property: #fooBlock returnsValueOf: tmp1.  self assert: themeDecorator fooBlock equals: 42.  tmp1 := [:arg1 |  arg1 + 42 ].  themeDecorator property: #fooBlock: returnsValueOf: tmp1.  self assert: (themeDecorator fooBlock: 3) equals: 45-=JUAMPI=-pageClass  ^SpDemoDynamicMemoryGamePresenter-=JUAMPI=-selectItem: arg1  self selectionMode selectItem: arg1-=JUAMPI=-heterogeneousDropList  ^heterogeneousDropList-=JUAMPI=-action  ^self model action-=JUAMPI=-testWhenTextChangesRaisesSingleEvent  self assertWith: [:arg1 |  arg1 = 1 ] timesRaisedEvent: #whenTextChangedDo: inPresenter: presenter whenDoing: [ presenter text: 'test' ]-=JUAMPI=-setIndex: arg1  ^self dropList setIndex: arg1-=JUAMPI=-listSize  ^self model listSize-=JUAMPI=-bePassword: arg1  isPassword := arg1-=JUAMPI=-initialize  self class initializeSlots: self.  super initialize.  ticks := 0.  highestValue := Float negativeInfinity.  lowestValue := Float infinity.  stepBy := 1-=JUAMPI=-keyStroke: arg1  keyStroke value cull: arg1-=JUAMPI=-performSearch: arg1 matching: arg2  ^searchBlock value: arg1 value: arg2-=JUAMPI=-observablePropertyNamed: arg1  | tmp1 |  tmp1 := self class slotNamed: arg1.  tmp1 isObservableSlot ifFalse: [ SpNonObservableSlotError signal: arg1 ].  ^tmp1 rawRead: self-=JUAMPI=-add: arg1 constraints: arg2  self widgetDo: [:arg3 |  self basicAdd: arg1 constraints: arg2 to: arg3 ]-=JUAMPI=-type: arg1  arg1 do: [:arg2 |  self keyPressed: arg2 asciiValue shift: arg2 isUppercase meta: false control: false option: false ]-=JUAMPI=-notifyError: arg1  GrowlMorph openWithLabel: 'Error' contents: arg1 message backgroundColor: GrowlMorph theme dangerBackgroundColor labelColor: GrowlMorph theme textColor-=JUAMPI=-addSplitter  self commands add: (SpSplitterVertical commands: self commands)-=JUAMPI=-testPresentersBlockReceivesAthensCanvas  | tmp1 |  self presenter drawBlock: [:arg1 |  tmp1 := arg1 ].  self adapter redraw.  self openInstance.  1 second wait.  self assert: tmp1 isNotNil.  self assert: (tmp1 isKindOf: AthensCanvas)-=JUAMPI=-protocolListAction  protocolList transmitTo: methodList transform: [:arg1 |  arg1 ifNotNil: [ (arg1 methodSelectors collect: [:arg2 |  self methodNamed: arg2 ]) asOrderedCollection ] ifNil: [ #() ] ] postTransmission: [:arg3 |  arg3 selectIndex: 1 ]-=JUAMPI=-visiblePages  ^layout visiblePages-=JUAMPI=-selectedClass  ^self selectedMethod origin-=JUAMPI=-classToTest  ^SpTreeTablePresenter-=JUAMPI=-initializePresenters  menu := self mainMenu.  list := self newList.  page := self instantiate: (selectedPage := self availablePages first).  menu applyTo: self.  list     items: self availablePages;     display: [:arg1 |  arg1 pageName ];     contextMenu: (self newMenu           addItem: [:arg1 |  arg1                 name: 'Browse';                 icon: (self iconNamed: #smallHelp);                 action: [ list selectedItem browse ] ];           addItem: [:arg1 |  arg1                 name: 'Browse presenter';                 icon: (self iconNamed: #smallHelp);                 action: [ list selectedItem new pageClass browse ] ];           yourself).  self focusOrder     add: list;     add: page-=JUAMPI=-searchText: arg1  | tmp1 |  arg1 isEmptyOrNil ifTrue: [ ^#() ].  tmp1 := arg1 trimBoth asLowercase.  ^Array streamContents: [:arg2 |  self elements withIndexDo: [:arg3 :arg4 |  (self model performSearch: arg3 matching: tmp1) ifTrue: [ arg2 nextPut: arg4 ] ] ]-=JUAMPI=-whenActionPerformedDo: arg1  self property: #actionPerformed whenChangedDo: arg1-=JUAMPI=-testSelectAll  self initializationText.  self openInstance.  presenter selectAll.  self assert: presenter selectionInterval equals: (1 to: 15)-=JUAMPI=-explore: arg1  ^self class explore: arg1-=JUAMPI=-displayMode  ^displayMode-=JUAMPI=-doItContext  self deprecated: 'This has been moved to specific presenters (check children)' on: '2019-04-15' in: #Pharo8-=JUAMPI=-initializePresenters  listModel := self newTable.  listModel     sortingBlock: [:arg1 :arg2 |  self sortClassesInCachedHierarchy: arg1 b: arg2 ];     addColumn: (SpStringTableColumn title: 'Location' evaluated: [:arg3 |  self locationOf: arg3 ]);     addColumn: (SpStringTableColumn title: 'Selector' evaluated: [:arg3 |  self selectorOf: arg3 ]);     addColumn: (SpStringTableColumn title: 'Package' evaluated: [:arg3 |  self packageOf: arg3 ]);     beResizable.  self contextMenu: self messageListMenu-=JUAMPI=-content: arg1  subwidget := self instantiate: arg1.  self focusOrder add: subwidget-=JUAMPI=-initialize  | tmp1 |  super initialize.  isHorizontal := true.  marks := OrderedCollection new.  max := 100.  min := 0.  quantum := 1.  value := 0.  absoluteValue := 0.  label := ''.  tmp1 := false.  self whenMaxChangedDo: [:arg1 |  self changed: {#max: .               arg1} ].  self whenMinChangedDo: [:arg1 |  self changed: {#min: .               arg1} ].  self whenQuantumChangedDo: [:arg1 |  self changed: {#quantum: .               arg1} ].  self whenValueChangedDo: [:arg2 |  tmp1 ifFalse: [ tmp1 := true.              self absoluteValue: (self valueToAbsoluteValue: arg2).              self changed: {#scaledValue: .                     arg2}.              tmp1 := false ].        self changed: #value ].  self whenAbsoluteValueChangedDo: [:arg2 |  tmp1 ifFalse: [ tmp1 := true.              self value: (self absoluteValueToValue: arg2).              self changed: {#value: .                     arg2}.              tmp1 := false ] ].  self whenLabelChangedDo: [:arg2 |  self changed: #label ]-=JUAMPI=-testPresenterTextIsSetInWidget  presenter text: 'something'.  self assert: self widget text equals: 'something'-=JUAMPI=-fieldPlaceholderText: arg1  fieldPlaceholderText := arg1-=JUAMPI=-hasFilter  ^self widget hasFilter-=JUAMPI=-initialize  super initialize.  onlyStrong := false-=JUAMPI=-indeterminated: arg1  indeterminated := arg1-=JUAMPI=-title: arg1  self widgetDo: [:arg2 |  arg2 setLabel: arg1 ]-=JUAMPI=-icon  ^self presenter icon ifNil: [ self defaultIcon ]-=JUAMPI=-setUp  super setUp.  presentersBuilder := SpDynamicPresentersListBuilder new     modelObjects: (1 to: 14);     presenter: SpButtonPresenter configuredAs: [:arg1 :arg2 |   ];     buildDynamicPresenter;     yourself.  layout := SpDynamicLeftToRightColumnsLayout columns: 7-=JUAMPI=-action: arg1  action := arg1-=JUAMPI=-applyTo: arg1  arg1 applyMenuModel: self-=JUAMPI=-browseValue  ^self value browse-=JUAMPI=-testSettingNilResetsSelection  self presenter selectItem: 10.  self presenter selectItem: nil.  self assert: self presenter selectedItem equals: nil.  self assert: self adapter selectedIndexes isEmpty-=JUAMPI=-isComposite  ^true-=JUAMPI=-headerColumn: arg1  | tmp1 |  arg1 id ifNil: [ ^nil ].  tmp1 := SpHeaderCellMorph new     addMorph: arg1 id asMorph asReadOnlyMorph;     yourself.  arg1 isSortable ifTrue: [ tmp1 eventHandler: (MorphicEventHandler new on: #click send: #sortByColumn:event:morph: to: self withValue: arg1) ].  ^tmp1-=JUAMPI=-ghostText: arg1  self deprecated: 'This API is too tight to Morph. Use #placeholder: instead.' transformWith: '`@receiver ghostText: `@statement' -> '`@receiver placeholder: `@statement'.  self placeholder: arg1-=JUAMPI=-openInstance  backendForTest openInstanceOf: self-=JUAMPI=-testUnselectSelectedItemRemovesItFromSelectionList  presenter     selectItem: 10;     unselectItem: 10.  self assert: presenter selection isEmpty-=JUAMPI=-execute  self editor paste-=JUAMPI=-externalIndex: arg1  externalIndex := arg1-=JUAMPI=-update: arg1  self changed: arg1-=JUAMPI=-= arg1  ^super = arg1 and: [ instVarName = arg1 instVarName ]-=JUAMPI=-testSelectIndexesOutsideRangeHasNoSelectedItems  presenter selectIndexes: {4 .         5}.  self assert: presenter selection selectedItems isEmpty-=JUAMPI=-whenMenuChangedDo: arg1  self property: #contextMenu whenChangedDo: arg1-=JUAMPI=-maximize  self changed: #maximize with: #()-=JUAMPI=-sortingBlock: arg1  listModel sortingBlock: arg1-=JUAMPI=-textConverter: arg1  textConverter := arg1 method: self textConverter method-=JUAMPI=-menu: arg1 shifted: arg2  | tmp1 |  (self allowMenuOnNoItem not and: [ self selectedItems isEmpty ]) ifTrue: [ ^nil ].  menuBlockHolder value ifNil: [ ^nil ].  menuBlockHolder value isBlock ifFalse: [ ^menuBlockHolder value ].  tmp1 := SpMenuPresenter new.  menuBlockHolder value cull: tmp1 cull: arg2.  ^tmp1-=JUAMPI=-ensureKeyBindingsFor: arg1  super ensureKeyBindingsFor: arg1.  self shortcut ifNotNil: [:arg2 |  self registerShortcut: arg2 ]-=JUAMPI=-cellColumn: arg1 row: arg2  | tmp1 tmp2 tmp3 |  tmp3 := self model itemAt: arg2.  tmp1 := arg1 readObject: tmp3.  tmp2 := FTCellMorph new     cellInset: 5;     yourself.  self model hasIcons ifTrue: [ (self model iconFor: tmp3) ifNotNil: [:arg3 |  tmp2 addMorphBack: arg3 asMorph ] ].  tmp2 addMorphBack: tmp1 asMorph asReadOnlyMorph.  ^tmp2-=JUAMPI=-giveFocusToNextFrom: arg1  ^self model giveFocusToNextFrom: arg1-=JUAMPI=-properties  ^self styles select: [:arg1 |  arg1 isStyleProperty ]-=JUAMPI=-emptyList  ^self dropList emptyList-=JUAMPI=-open: arg1  object := arg1.  self open-=JUAMPI=-testTickIncrementsOne  timeline tick.  self assert: timeline ticks equals: 1-=JUAMPI=-childrenWidgets  ^widget submorphs first submorphs , widget submorphs second submorphs-=JUAMPI=-copyClass: arg1 from: arg2 to: arg3  arg3 absorbClass: arg1 name from: arg2-=JUAMPI=-methodModified: arg1  UIManager default defer: [ self handleMethodModified: arg1 ]-=JUAMPI=-action: arg1  action := arg1-=JUAMPI=-listElementAt: arg1  ^self model at: arg1 ifAbsent: [ nil ]-=JUAMPI=-testUnselectAllUnselectsSingleSelection  presenter     selectPath: #(1 1);     unselectAll.  self assert: presenter selection isEmpty-=JUAMPI=-items  ^items value-=JUAMPI=-model  ^model-=JUAMPI=-valueToAbsoluteValue: arg1  ^((arg1 - self min) / (self max - self min)) asFloat-=JUAMPI=-testSelectItemSetsSelectedPath  presenter selectItem: 20.  self assert: presenter selection selectedPath equals: #(1 1 3)-=JUAMPI=-initialize  super initialize-=JUAMPI=-label  ^self presenter label-=JUAMPI=-testWhenDaySelectedBlock  | tmp1 tmp2 |  tmp1 := false.  tmp2 := Date year: 2018 month: 9 day: 15.  calendar     adaptToDate: tmp2;     whenDaySelectedBlock: [ tmp1 := true ].  self deny: tmp1.  calendar daysButtons basicPresenters value values first performAction.  self assert: tmp1-=JUAMPI=-propertyAt: arg1 put: arg2  ^self properties at: arg1 put: arg2-=JUAMPI=-testSelectItemAddsPathToSelectedPathList  presenter selectItem: 10.  self assert: (presenter selection includesPath: #(1 3))-=JUAMPI=-adapterName: arg1  adapterName := arg1-=JUAMPI=-testSetSelectIndexRaisesSelectionChangeEventWithSelectedIndex  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedIndexes ].  presenter selectIndex: 1.  self assert: (tmp1 includes: 1)-=JUAMPI=-testRebuildPresenterBeforeOpeningWorks  self assert: presenter label label equals: ''.  self shouldnt: [ presenter selectFirstElement.        self openInstance ] raise: Error.  self assert: presenter label label equals: '1'-=JUAMPI=-calculateExtentFor: arg1 constraint: arg2 computation: arg3  | tmp1 tmp2 tmp3 |  tmp1 := arg3 cellExtentAt: arg2 position.  tmp3 := self calculateWidthFor: arg1 base: tmp1 x.  tmp2 := self calculateHeightFor: arg1 base: tmp1 y.  ^tmp3 @ tmp2-=JUAMPI=-buildWidget  ^SpTickingSpecWindow new     model: self;     isResizeable: self isResizeable;     yourself-=JUAMPI=-placeholder  ^self model placeholder-=JUAMPI=-testSelectInvalidPathHasNoSelectedPaths  presenter selectPath: #(4).  self assert: presenter selection selectedPaths isEmpty-=JUAMPI=-testSelectMultipleIndexesAddsAllToSelectedIndexList  presenter selectIndex: 1.  presenter selectIndex: 3.  self assert: (presenter selection includesIndex: 1).  self assert: (presenter selection includesIndex: 3)-=JUAMPI=-canResize  ^resize-=JUAMPI=-extent: arg1  | tmp1 |  tmp1 := arg1 rounded.  (bounds extent closeTo: tmp1) ifTrue: [ ^self ].  self invalidRect: bounds.  bounds := bounds topLeft extent: tmp1.  self layoutChanged.  self invalidRect: bounds-=JUAMPI=-testSelectPresenterItemSetsSelectedIndexInWidget  self skip-=JUAMPI=-dispatchTo: arg1  ^arg1 notify: self-=JUAMPI=-add: arg1 withConstraints: arg2  | tmp1 |  tmp1 := self constraintsClass new.  arg2 value: tmp1.  children at: arg1 put: tmp1-=JUAMPI=-differentCardsCountSlider  ^differentCardsCountSlider-=JUAMPI=-initialize  needRecalculatePages := false.  super initialize-=JUAMPI=-testRemovePage  | tmp1 |  presenter addPage: (tmp1 := SpNotebookPage title: 'Mock3' provider: [ SpLabelPresenter new ]).  self assert: self adapter numberOfTabs equals: 3.  presenter removePage: tmp1.  self assert: self adapter numberOfTabs equals: 2-=JUAMPI=-initialize  super initialize.  self     name: 'Inspect';     description: 'Inspect the context of this command.'-=JUAMPI=-activateOnSingleClick  activateOnSingleClick := true-=JUAMPI=-refreshPrintDescription  self printDescription: self selectedElement-=JUAMPI=-clicked  widget toggleSelected-=JUAMPI=-sliceButton  ^sliceButton-=JUAMPI=-defaultWindowPresenterClass  ^SpTickingWindowPresenter-=JUAMPI=-initialize  super initialize.  type := #SpContainerPresenter.  self commands: OrderedCollection new-=JUAMPI=-displaySymbol  ^displaySymbol ifNil: [ #printString ]-=JUAMPI=-initializeWindow: arg1  arg1     title: 'Grid layout example';     initialExtent: 300 @ 400-=JUAMPI=-itemNamed: arg1  ^self items detect: [:arg2 |  arg2 label = arg1 ]-=JUAMPI=-fieldPlaceholderText  ^fieldPlaceholderText-=JUAMPI=-icon: arg1  icon := arg1-=JUAMPI=-addVariableFields: arg1  self tempNames withIndexDo: [:arg2 :arg3 |  arg1 add: (ContextTempEyeElement host: self object tempName: arg2 tempIndex: arg3) ]-=JUAMPI=-shown: arg1  ^shown := arg1-=JUAMPI=-presenterProvider: arg1  presenterProvider := arg1-=JUAMPI=-classToTest  ^SpListPresenter-=JUAMPI=-add: arg1 withSpec: arg2 left: arg3  self add: arg1 withSpec: arg2 top: nil bottom: nil left: arg3 right: nil-=JUAMPI=-preview  ^preview-=JUAMPI=-initializeDialogWindow: arg1  super initializeDialogWindow: arg1.  arg1     initialExtent: 600 @ 400;     title: 'Select a method';     closeOnBackdropClick: false-=JUAMPI=-deselect  self widgetDo: [:arg1 |  arg1 changed: #deselect.        arg1 model selectionChanged.        arg1 dependents do: [:arg2 |  arg2 changed ] ]-=JUAMPI=-newTable  ^self instantiate: SpTablePresenter-=JUAMPI=-newColumnFrom: arg1  ^(SpMorphicTableColumn on: arg1)     width: arg1 width;     yourself-=JUAMPI=-extent  ^transformationMorph extent-=JUAMPI=-runCase  self resources do: [:arg1 |  arg1 availableFor: self ].  [ super setUp.  self performTest ] ensure: [ self tearDown.        self cleanUpInstanceVariables ]-=JUAMPI=-listModel  ^listModel-=JUAMPI=-badgeColor  ^self theme badgeColor-=JUAMPI=-whenSelectionChangedDo: arg1  selection whenChangedDo: arg1-=JUAMPI=-initialize  super initialize.  action := [  ].  displayBlock := [:arg1 |  arg1 asString ]-=JUAMPI=-presenterAt: arg1 ifAbsent: arg2  ^self basicPresenters at: arg1 ifAbsent: [ [ self readSlotNamed: arg1 ] on: SlotNotFound do: arg2 ]-=JUAMPI=-classToTest  ^SpToolBarPresenter-=JUAMPI=-password  ^password-=JUAMPI=-styles  ^styles-=JUAMPI=-isEnabled  ^enabled-=JUAMPI=-setUp  super setUp.  timeline := SpTimeline new-=JUAMPI=-initializeTestedInstance  presenter-=JUAMPI=-testUnselectSelectedItemRaisesSingleEvent  | tmp1 |  tmp1 := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectItem: 10.  self assert: tmp1 equals: 1-=JUAMPI=-bindKeyCombination: arg1 toAction: arg2  -=JUAMPI=-connectPresenters  self packageListAction.  self classListAction.  self protocolListAction.  self radioButtonsAction.  packageList selectIndex: 1-=JUAMPI=-testSetRootModelPushesPresenterToList  self presenter presenterBlock: [:arg1 |  SpNullMillerPresenter on: (SpLabelPresenter new label: arg1 asString) ].  self presenter setRootModel: 1.  self assert: self presenter size equals: 1-=JUAMPI=-addModelItemsToWindowMenu: arg1  self model addMenuItemsToWindowMenu: arg1-=JUAMPI=-initializeTestedInstance  presenter items: #(10 20 30)-=JUAMPI=-value  ^self host tempNamed: self tempName-=JUAMPI=-addVariableFields: arg1  self variableFieldsToShow do: [:arg2 |  arg1 add: (IndexedEyeElement host: self object index: arg2) ]-=JUAMPI=-addItemTo: arg1  arg1 addItem: [:arg2 |  arg2           name: 'Dynamic';           icon: (self iconNamed: #delete);           action: [ arg1 menuItems remove: arg2.              self needRebuild: false.              self buildWithSpec ] ].  self needRebuild: false.  self buildWithSpec-=JUAMPI=-setUp  super setUp.  presenter items: #(10 20 30)-=JUAMPI=-basicAdd: arg1 constraints: arg2 to: arg3  self subclassResponsibility-=JUAMPI=-numberType  ^numberType-=JUAMPI=-placeholder  ^placeholder-=JUAMPI=-traverseInFocusOrderDo: arg1 excluding: arg2  self canTakeKeyboardFocus ifFalse: [ ^self ].  arg2 add: self.  arg1 value: self-=JUAMPI=-color  ^color-=JUAMPI=-buildPushMessageToolBarItem  ^SpToolBarButton new     label: 'Push';     icon: (self iconNamed: #glamorousUp);     help: 'Push a new status bar message';     action: [ self pushMessage ];     yourself-=JUAMPI=-testActivateSubPresenterPushesElementToList  | tmp1 |  self presenter presenterBlock: [:arg1 |  tmp1 := SpMockMillerPresenter new ].  self presenter setRootModel: 1.  tmp1 activate.  self assert: self presenter size equals: 2-=JUAMPI=-rightClicked  | tmp1 |  tmp1 := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent yellowButton buttons: MouseButtonEvent yellowButton hand: nil stamp: nil.  (widget handlesMouseDown: tmp1) ifTrue: [ widget mouseDown: tmp1.        widget mouseUp: tmp1 ]-=JUAMPI=-initializeTestedInstance  super initializeTestedInstance.  presenter addColumn: (SpStringTableColumn evaluated: [:arg1 |  arg1 ])-=JUAMPI=-refresh  self needRebuild: false.  self buildWithSpec-=JUAMPI=-testSubscriptionsAreTransfered  | tmp1 |  tmp1 := 0.  presenter beSingleSelection.  presenter whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ].  presenter beMultipleSelection.  presenter selectIndex: 2.  self assert: tmp1 equals: 1-=JUAMPI=-styles  ^styles-=JUAMPI=-buildWidget  | tmp1 |  tmp1 := super buildWidget.  self presenter whenTextStylerChangedDo: [ self applyTextStyle ].  ^tmp1-=JUAMPI=-initializePresenter  self property: #object whenChangedDo: [ self objectChanged ].  text whenBuiltDo: [:arg1 |  self text behavior: self object class ].  self initializeShortcuts-=JUAMPI=-connectPresenters  -=JUAMPI=-foundIcon  ^self iconNamed: #glamorousAccept-=JUAMPI=-whenReadSelectionIsChangedDo: arg1  self property: #readSelection whenChangedDo: arg1-=JUAMPI=-isSplitter  ^true-=JUAMPI=-selected  ^selected value-=JUAMPI=-classToTest  ^SpButtonPresenter-=JUAMPI=-triggerOkAction  -=JUAMPI=-title  ^'Pointers to: ' , self object printString-=JUAMPI=-color  ^color ifNil: [ Color transparent ]-=JUAMPI=-canDeselectByClick: arg1  self deprecated: 'It is not clear what option to select if deselected'-=JUAMPI=-window  ^window-=JUAMPI=-behavior: arg1  self deprecated: 'This method is an horrible hack because the VersionBrowser was using Code or Diff presenter but was only using the API of the Code presenter... This method and other methods from the CodePresenter API will be removed.'.  self contextClass: arg1-=JUAMPI=-onDesactivation: arg1  onDesactivation := arg1-=JUAMPI=-menu  ^tree menu-=JUAMPI=-itemAtPath: arg1 expanding: arg2  | tmp1 |  (arg1 isNil or: [ arg1 isEmpty ]) ifTrue: [ ^nil ].  tmp1 := self rootItem.  arg1 do: [:arg3 |  (arg2 and: [ tmp1 isRoot not ]) ifTrue: [ tmp1 expand ].        tmp1 children size < arg3 ifTrue: [ ^nil ].        tmp1 := tmp1 children at: arg3 ].  ^tmp1-=JUAMPI=-testUnselectNonSelectedItemRaisesNoEvent  | tmp1 |  tmp1 := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectItem: 20.  self assert: tmp1 equals: 0-=JUAMPI=-topLeftOffset: arg1  topOffset := arg1 y.  leftOffset := arg1 x-=JUAMPI=-initializeAnnouncements  SystemAnnouncer uniqueInstance weak when: ClassAdded , ClassCommented , ClassRecategorized , ClassModifiedClassDefinition , ClassRemoved , ClassRenamed , ClassReorganized , MethodAdded , MethodModified , MethodRecategorized , MethodRemoved , ProtocolAdded , ProtocolRemoved send: #updateClassesList to: self-=JUAMPI=-inspectionMenu: arg1  self hasSelectedObject ifFalse: [ ^arg1 ].  ^super inspectionMenu: arg1-=JUAMPI=-connectPresenters  button1 whenActivatedDo: [ self updateLabel ].  button1 whenDeactivatedDo: [ self updateLabel ].  button2 whenChangedDo: [ self updateLabel ].  button3 whenChangedDo: [ self updateLabel ]-=JUAMPI=-testHideColumnHeadersInPresenterHidesThemInWidget  self presenter hideColumnHeaders.  self deny: self adapter isShowColumnHeaders-=JUAMPI=-method4  -=JUAMPI=-initializeSemaphore  uiWaitingSemaphore := Semaphore new-=JUAMPI=-isResizeable  ^self model isResizeable-=JUAMPI=-testReplaceItemList  | tmp1 |  tmp1 := false.  presenter whenModelChangedDo: [ tmp1 := true ].  presenter items: #(a b c).  self assert: (presenter model collection collect: #label) equals: #(a b c).  self assert: tmp1-=JUAMPI=-testColumnNotHomogeneousDiferentRowsAndColumns  | tmp1 |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 2.  self place: label2 at: 3 @ 3.  self place: morph2 at: 4 @ 4.  tmp1 := self newLayout.  tmp1 layout beColumnNotHomogeneous.  (self styleExtent: 30 @ 20) applyTo: label1.  (self styleExtent: 40 @ 20) applyTo: morph1.  (self styleExtent: 50 @ 20) applyTo: label2.  (self styleExtent: 60 @ 20) applyTo: morph2.  tmp1 layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 30 @ 20).  self assert: morph1 bounds equals: (30 @ 20 corner: 70 @ 40).  self assert: label2 bounds equals: (70 @ 40 corner: 120 @ 60).  self assert: morph2 bounds equals: (120 @ 60 corner: 180 @ 80)-=JUAMPI=-testAddPresenterToComponentListShouldNotBeEmpty  presenter addPresenter: SpButtonPresenter new.  self deny: presenter isEmpty-=JUAMPI=-removeAll  pagesHolder removeAll-=JUAMPI=-testSetSelectItemRaisesSelectionChangeEventWithSelectedPath  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedPath ].  presenter selectItem: 20.  self assert: tmp1 equals: #(1 1 3)-=JUAMPI=-initializePresenters  text := self newText.  sideRuler := self newMorph.  sideRuler morph: (Morph new           color: Color yellow;           extent: 50 @ 500;           useGradientFill;           hResizing: #spaceFill;           vResizing: #spaceFill;           yourself).  text whenScrollValueChangedDo: [:arg1 |  self syncMorphPosition ].  text text: self loremIpsum-=JUAMPI=-buildWidget  | tmp1 |  tmp1 := SpToolBarMorph new.  self addModelTo: tmp1.  ^tmp1-=JUAMPI=-testContextMenu  | tmp1 tmp2 |  self assert: presenter contextMenu isNil.  tmp1 := SpMenuPresenter new.  tmp2 := false.  presenter whenMenuChangedDo: [ tmp2 := true ].  presenter contextMenu: tmp1.  self assert: presenter contextMenu equals: tmp1.  self assert: tmp2-=JUAMPI=-width  ^width-=JUAMPI=-transferSubscriptionsTo: arg1  self selectionHolder transferSubscriptionsTo: arg1 selectionHolder-=JUAMPI=-addPresenter: arg1  arg1 whenActivatedDo: [:arg2 |  self changeSelection: arg2 selectedItem from: arg1 ].  arg1 owner: self.  layout add: arg1-=JUAMPI=-asArray  ^specArray-=JUAMPI=-testFocusRotationForward  mock := SpMockFocusOrderPresenter new     openWithSpec;     yourself.  self takeKeyboardFocus: mock.  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenter.  self pressTab.  self assert: (mock presenterAt: #secondPresenter) equals: self focusedPresenter.  self pressTab.  self assert: (mock presenterAt: #thirdPresenter) equals: self focusedPresenter.  self pressTab.  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenter-=JUAMPI=-whenMarksChangedDo: arg1  self property: #marks whenChangedDo: arg1-=JUAMPI=-whenSelectionChanged: arg1  self dropList whenSelectionChanged: arg1-=JUAMPI=-font  ^self model font-=JUAMPI=-id  ^self model title-=JUAMPI=-initializePresenters  classListPresenter := self newList.  methodListPresenter := self newList.  textPresenter := self newCode.  textPresenter acceptBlock: [:arg1 |  methodListPresenter selectedItem inspect ].  methodListPresenter display: #selector.  self focusOrder     add: classListPresenter;     add: methodListPresenter;     add: textPresenter-=JUAMPI=-initialize  super initialize.  maxLength := 0.  acceptOnCR := true.  isPassword := false.  self whenAcceptOnCRChangedDo: [:arg1 |  self changed: #acceptOnCR: with: {arg1} ]-=JUAMPI=-text  ^text-=JUAMPI=-itemFilterBlock: arg1  self deprecated: 'Use #itemFilter: instead' transformWith: '`@receiver itemFilterBlock: `@statements1' -> '`@receiver itemFilter: `@statements1'.  ^self itemFilter: arg1-=JUAMPI=-testNotPasswordIsSetInWidget  presenter bePassword: false.  self deny: self adapter isPassword-=JUAMPI=-toolbarItemFont  ^toolbarItemFont ifNil: [ toolbarItemFont := self newToolbarItemFont ]-=JUAMPI=-testUnselectWidgetIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | tmp1 |  self adapter selectIndex: 1.  presenter selection whenChangedDo: [:arg1 |  tmp1 := arg1 selectedIndex ].  self adapter selectIndex: 0.  self assert: tmp1 equals: 0-=JUAMPI=-setText: arg1 to: arg2  super setText: (self presenter textStyler applyStyleTo: arg1) to: arg2-=JUAMPI=-openChangeSetBrowser  | tmp1 |  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  tmp1 := self selectedChangeSet ifNil: [ ^self ].  ^Smalltalk tools messageList browseClasses: (RBBrowserEnvironment new forClasses: tmp1 changedClasses)-=JUAMPI=-action  ^action-=JUAMPI=-rightText  ^rightText-=JUAMPI=-isMultipleSelection  ^selectionMode isMultipleSelection-=JUAMPI=-widget: arg1  widget := arg1-=JUAMPI=-displayBlock  ^self model displayBlock-=JUAMPI=-contextKeyBindings: arg1  contextKeyBindings := arg1-=JUAMPI=-label: arg1  ^label := arg1-=JUAMPI=-showAllInstVars  ^self class showAllInstVars-=JUAMPI=-testSelectWidgetIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | tmp1 |  presenter selection whenChangedDo: [:arg1 |  tmp1 := arg1 selectedIndex ].  self adapter selectIndex: 1.  self assert: tmp1 equals: 1-=JUAMPI=-normalFillStyle  ^Color transparent-=JUAMPI=-clearFilterButton: arg1  clearFilterButton := arg1-=JUAMPI=-daysToDisplayCount  ^self maxNumberOfWeeksToDisplay * self daysInAWeek-=JUAMPI=-open: arg1 withSpecLayout: arg2  ^self open: arg1 withSpecLayout: arg2 using: arg1 defaultWindowPresenterClass-=JUAMPI=-styleName  ^'toolBar.label'-=JUAMPI=-handlesDoubleClick: arg1  handlesDoubleClick := arg1-=JUAMPI=-adaptToDate: arg1  self monthYearLabel label: arg1 month asString.  self previousMonthButton action: [ self adaptToDate: arg1 onPreviousMonth ].  self nextMonthButton action: [ self adaptToDate: arg1 onNextMonth ].  self newDynamicPresentersListIn: #namesOfDaysLabels usingBuilder: self daysLabelsBuilder.  self newDynamicPresentersListIn: #daysButtons usingBuilder: (self daysButtonsBuilderFrom: arg1)-=JUAMPI=-autoAccept: arg1  ^self sliderInput autoAccept: arg1-=JUAMPI=-applyTo: arg1  self color ifNotNil: [:arg2 |  arg1 color: arg2 ].  self backgroundColor ifNotNil: [:arg2 |  arg1 backgroundColor: arg2 ]-=JUAMPI=-testUnselectAllInWidgetNotRaisesEmptySelectionChangeEvent  | tmp1 |  presenter selection whenChangedDo: [:arg1 |  tmp1 := arg1 ].  self adapter selectIndex: 0.  self assert: tmp1 isNil-=JUAMPI=-application: arg1  application := arg1-=JUAMPI=-initializePresenters  form := (self instantiate: SpDemoLabeledContainer)     label: 'form';     subwidget: (self instantiate: SpDemoStandaloneFormPresenter on: self announcingObject).  resultPane := (self instantiate: SpDemoLabeledContainer)     label: 'result';     subwidget: (table := self newTable).  table     addColumn: (SpStringTableColumn title: 'Name' evaluated: #key);     addColumn: (SpStringTableColumn title: 'Value' evaluated: #value);     items: self model elements;     beResizable.  self focusOrder     add: form;     add: table-=JUAMPI=-doActivateAtIndex: arg1  self presenters at: arg1 ifAbsent: [ ^self ].  activationBlock cull: ((SpSingleSelectionMode on: self)           basicSelectIndex: arg1;           yourself)-=JUAMPI=-from: arg1 port: arg2 to: arg3 transform: arg4  self from: arg1 port: arg2 to: arg3 transform: arg4 postTransmission: nil-=JUAMPI=-sliders  ^sliders-=JUAMPI=-newSplitter  ^SpPanedResizerMorph newVertical-=JUAMPI=-presenterAt: arg1 ifAbsent: arg2  ^self basicPresenters at: arg1 ifAbsent: [ [ self readSlotNamed: arg1 ] on: SlotNotFound do: arg2 ]-=JUAMPI=-add: arg1 withSpec: arg2 top: arg3 bottom: arg4  self add: arg1 withSpec: arg2 top: arg3 bottom: arg4 left: nil right: nil-=JUAMPI=-whenResizingDo: arg1  self announcer when: WindowResizing do: arg1-=JUAMPI=-searchValueOf: arg1  ^self displayValueOf: arg1-=JUAMPI=-specInitializationStrategy: arg1  specInitializationStrategy := arg1-=JUAMPI=-step  self objectChanged-=JUAMPI=-updateText  self text: self text-=JUAMPI=-whenAutoDeselectChangedDo: arg1  self deprecated: 'Should not use. This feature is not supported anymore'.  self property: #autoDeselect whenChangedDo: arg1-=JUAMPI=-allSelectedItems  | tmp1 |  tmp1 := OrderedCollection new.  self selected ifTrue: [ tmp1 add: self ].  self children value do: [:arg1 |  tmp1 addAll: arg1 allSelectedItems ].  ^tmp1-=JUAMPI=-beForText  self deprecated: 'The forCode functionality has moved to TextCodePresenter, please use it instead TextPresenter.' on: '2019-04-05' in: #Pharo8-=JUAMPI=-strongSelectionChanged: arg1  self presenter activatesOnDoubleClick ifFalse: [ ^self ].  self presenter doubleClickAtIndex: arg1 selectedIndex-=JUAMPI=-testSelectMultipleIndexesRaisesSelectionChangeEventMultipleTimes  | tmp1 |  tmp1 := 0.  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter selectIndex: 1.  presenter selectIndex: 3.  self assert: tmp1 equals: 2-=JUAMPI=-whenBorderWidthChanged: arg1  self deprecated: 'Use #whenBorderWidthChangedDo: instead.' transformWith: '`@receiver whenBorderWidthChanged: `@statements' -> '`@receiver whenBorderWidthChangedDo: `@statements'.  self whenBorderWidthChangedDo: arg1-=JUAMPI=-selectedIndexes  | tmp1 |  tmp1 := self widget getCurrentSelectionIndex.  ^tmp1 = 0 ifTrue: [ #() ] ifFalse: [ {tmp1} ]-=JUAMPI=-searchMatching: arg1  searchBlock := arg1.  self enableSearch-=JUAMPI=-adapterName  ^#GridAdapter-=JUAMPI=-preserveLayoutPosition  self owner layoutPolicy preservePositionProportionOn: self owner-=JUAMPI=-selectedContacts  ^table selectedItems-=JUAMPI=-beUnselected  self setSelection: false-=JUAMPI=-classToTest  ^SpLabelledDropList-=JUAMPI=-thumbnailMorph  ^self object taskThumbnailOfSize: self thumbnailSize-=JUAMPI=-radioButtonInstanceSide  ^radioButtonInstanceSide-=JUAMPI=-genderLabel: arg1  genderLabel := arg1-=JUAMPI=-selectPage: arg1  self widgetDo: [:arg2 |  arg2 page: (arg2 pageWithModel: arg1) ]-=JUAMPI=-whenActivatedDo: arg1  activationBlock := arg1-=JUAMPI=-defaultInitialExtent  ^400 @ 300-=JUAMPI=-close  self widget ifNotNil: [:arg1 |  arg1 close ]-=JUAMPI=-addLazyPage: arg1 label: arg2  self addLazyPage: arg1 label: arg2 collapsable: false-=JUAMPI=-rightClicked  | tmp1 |  tmp1 := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent yellowButton buttons: MouseButtonEvent yellowButton hand: nil stamp: nil.  self widget click: tmp1-=JUAMPI=-state  ^state-=JUAMPI=-whenIconChangedDo: arg1  self property: #icon whenChangedDo: arg1-=JUAMPI=-doubleClickFirstRowAndColumn: arg1  self waitUntilUIRedrawed.  arg1 widget doubleClick: (MouseEvent new           setPosition: arg1 widget submorphs first submorphs first bounds center;           yourself)-=JUAMPI=-notifyPropertyChanged: arg1  self flag: #todo.  (self observablePropertyNamed: arg1) valueChanged-=JUAMPI=-initializeWidgets  input := self instantiate: SpTextInputFieldPresenter.  dropList := self instantiate: SpDropListPresenter.  self focusOrder     add: input;     add: dropList-=JUAMPI=-modelChanged  table items: self model elements-=JUAMPI=-browseSubMenu: arg1  arg1 addGroup: [:arg2 |  arg2 addItem: [:arg3 |  arg3                 name: 'Browse Full';                 action: [ self browseSelectedObject ];                 shortcut: PharoShortcuts current browseShortcut ].        arg2 addItem: [:arg3 |  arg3                 name: 'Browse Class';                 action: [ self browseSelectedObjectClass ] ].        arg2 addItem: [:arg3 |  arg3                 name: 'Browse Hierarchy';                 action: [ self browseSelectedObjectClassHierarchy ];                 shortcut: $h meta ] ]-=JUAMPI=-presentersInFocusOrder  ^self presenters-=JUAMPI=-unselectPath: arg1  self selection unselectPath: arg1-=JUAMPI=-windowIsOpening  isClosed := false-=JUAMPI=-size  ^self presenters size-=JUAMPI=-extent  ^self widget extent-=JUAMPI=-onActivation  ^onActivation-=JUAMPI=-pageClass  ^SpDemoRadioButtonsPresenter-=JUAMPI=-testShowColumnHeadersRaisesOneEventOnly  | tmp1 |  tmp1 := 0.  presenter whenShowColumnHeadersChangedDo: [ tmp1 := tmp1 + 1 ].  presenter showColumnHeaders.  self assert: tmp1 equals: 1-=JUAMPI=-initializePresenters  layout := SpMillerLayout newHorizontal-=JUAMPI=-property: arg1 whenChangedDo: arg2  (self observablePropertyNamed: arg1) whenChangedDo: arg2-=JUAMPI=-connectPresenters  textField acceptBlock: [:arg1 |  self class environment at: arg1 asSymbol ifPresent: [:arg2 |  methodBrowser messages: arg2 methods ] ifAbsent: [ methodBrowser messages: #() ] ]-=JUAMPI=-calculateHomogeneousRowHeights  | tmp1 |  tmp1 := 0.  morphs do: [:arg1 |  tmp1 := tmp1 max: (self minHeightOf: arg1) ].  ^Array new: numRows withAll: (self baseRowHeight max: tmp1)-=JUAMPI=-accept: arg1 notifying: arg2  ^self selectedMessage ifNotNil: [:arg3 |  arg3 methodClass compile: arg1 classified: arg3 protocol notifying: arg2 ]-=JUAMPI=-initializePresenters  < script: 'self new openWithSpec'>  (button := self newButton)     label: 'Choice';     action: [ text text: text text , button label , String cr ].  menu := self newMenuButton     help: 'An example menu.';     menu: [ self newExampleMenu ];     yourself.  text := self newText-=JUAMPI=-traverseInFocusOrderDo: arg1 excluding: arg2  self presentersInFocusOrder do: [:arg3 |  arg3 traverseInFocusOrderDo: arg1 excluding: arg2 ]-=JUAMPI=-= arg1  ^super = arg1 and: [ index = arg1 index ]-=JUAMPI=-beExpand  self expand: true-=JUAMPI=-stateSelector  ^self state ifNil: [ nil ] ifNotNil: [ #state ]-=JUAMPI=-to: arg1  self toPort: arg1 inputPortDefault-=JUAMPI=-testSelectItemOutsideRangeUnsetsSelectedItem  presenter selectItem: 40.  self assert: presenter selection selectedItem equals: nil-=JUAMPI=-setFocusOrder  self focusOrder     add: changeSorterLeft;     add: changeSorterRight-=JUAMPI=-inspect: arg1  self object: arg1.  self list selectIndex: 1.  self refresh-=JUAMPI=-updateMenu  -=JUAMPI=-model: arg1  model := arg1.  model isSortable ifTrue: [ self sortableUsing: model sortFunction ]-=JUAMPI=-newSearchInput  ^self instantiate: SpSearchInputFieldPresenter-=JUAMPI=-icon  ^icon-=JUAMPI=-aboutText  ^self model model ifNotNil: [:arg1 |  arg1 aboutText ]-=JUAMPI=-footnoteIcon  ^footnoteIcon-=JUAMPI=-updateView  table items: contactBook contents-=JUAMPI=-shouldRefreshItem: arg1 fromAnnouncement: arg2  ^refreshingBlock cull: arg1 cull: arg2 cull: self-=JUAMPI=-includesPaths: arg1  ^selection includesAll: arg1-=JUAMPI=-window  ^self hasWindow ifTrue: [ self root ] ifFalse: [ nil ]-=JUAMPI=-leftFraction  ^layoutFrame leftFraction-=JUAMPI=-selectedBehavior  self flag: #TODO.  ^self behavior-=JUAMPI=-isShowColumnHeaders  ^widget isShowColumnHeaders-=JUAMPI=-useProportionalLayout  -=JUAMPI=-build  ^self buildDynamicPresenter     layout: self buildLayout;     yourself-=JUAMPI=-testUnselectUnselectedPathRaisesNoSelectionEvent  | tmp1 |  tmp1 := 0.  presenter     selectPath: #(1 2);     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectPath: #(2 2).  self assert: tmp1 equals: 0-=JUAMPI=-incomingTransmission: arg1 from: arg2  self subclassResponsibility-=JUAMPI=-testWhenNumberTypeChangedDo  | tmp1 tmp2 |  tmp1 := 0.  presenter whenNumberTypeChangedDo: [:arg1 |  tmp1 := tmp1 + 1.        tmp2 := arg1 ].  presenter beFloat.  self assert: tmp1 equals: 1.  self assert: tmp2 equals: Float-=JUAMPI=-encrypted  ^self model isPassword-=JUAMPI=-minus  ^minus-=JUAMPI=-bottomFraction: arg1  bottomFraction := arg1-=JUAMPI=-