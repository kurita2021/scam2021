setLayoutSizing  self     hResizing: #rigid;     vResizing: #spaceFillapplyStyleTo: arg1  ^self withAdapterDo: [:arg2 |  arg2 applyStyleTo: arg1 ]accept: arg1 notifying: arg2  super accept: arg1 asString notifying: arg2classToTest  ^SpToolBarPresenterinspectorTypes  ^self inspector variantsgetImage  ^self model imageresetSelection  listPresenter resetSelectionnotifyPropertyChanged: arg1  self flag: #todo.  (self observablePropertyNamed: arg1) valueChangedselectFileTitle: arg1  ^UIManager default chooseExistingFileReference: arg1 extensions: nil path: ''title: arg1  titleHolder := arg1registerEvents  super registerEvents.  self property: #handlesDoubleClick whenChangedDo: [:arg1 |  self changed: {#handlesDoubleClick .               arg1} ]spacing  ^layout spacingmin: arg1  slider min: arg1.  input text: arg1 asStringselectAll  self widgetDo: [:arg1 |  arg1 selectAll ]id: arg1  id := arg1testBorderWidthHomogeneous  | tmp1 |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1.  self place: label2 at: 1 @ 2.  self place: morph2 at: 2 @ 2.  (tmp1 := self newLayout) layout     beColumnHomogeneous;     beRowHomogeneous;     borderWidth: 5.  tmp1 layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (5 @ 5 corner: 50 @ 50).  self assert: morph1 bounds equals: (50 @ 5 corner: 95 @ 50).  self assert: label2 bounds equals: (5 @ 50 corner: 50 @ 95).  self assert: morph2 bounds equals: (50 @ 50 corner: 95 @ 95)buttons  ^buttonsaddPresenterIn: arg1 withSpecLayout: arg2  self presenter ifNil: [ ^self ].  widget := self presenter buildWithSpecLayout: arg2.  arg1 addMorph: widget fullFrame: LayoutFrame identityinitialize  super initialize.  action := [  ].  state := false.  askBeforeChanging := false.  self whenFontChangedDo: [ self changed: #font ].  self whenStateChangedDo: [ self changed: #state ].  self whenMenuChangedDo: [ self withAdapterDo: #updateMenu ].  self property: #askBeforeChanging whenChangedDo: [:arg1 |  self changed: {#askBeforeChanging: .               arg1} ].  self property: #shortcut whenChangedDo: [:arg2 :arg3 |  self unregisterShortcut: arg3.        self registerShortcut: arg2.        self changed: #label ].  self color: nilcontextMenu  ^contextMenuwhenSearchChangedDo: arg1  self property: #searchEnabled whenChangedDo: arg1initializePresenters  previousMonthButton := self newButton.  previousMonthButton label: '<'.  nextMonthButton := self newButton.  nextMonthButton label: '>'.  monthYearLabel := self newLabel.  monthYearLabel label: '-'.  namesOfDaysLabels := self newNullPresenter.  daysButtons := self newNullPresentercalculateNotHomogeneousRowHeights  | tmp1 |  tmp1 := Array new: numRows withAll: 0.  morphs do: [:arg1 |  | tmp2 |        tmp2 := (arg1 valueOfProperty: #gridConstraints) row.        tmp1 at: tmp2 put: ((tmp1 at: tmp2) max: arg1 height) ].  ^tmp1initializePresenters  packageList := self newList.  classList := self newList.  methodList := self newList.  radioButtonClassSide := self newRadioButton.  radioButtonInstanceSide := self newRadioButton.  protocolList := self newList.  packageList     items: RPackageOrganizer default packages;     display: #name;     sortingBlock: #name ascending;     icons: [:arg1 |  self iconNamed: #package ].  classList     sortingBlock: #name ascending;     icons: [:arg1 |  self iconNamed: arg1 systemIconName ].  protocolList     display: #name;     sortingBlock: #name ascending.  methodList     sortingBlock: #name ascending;     display: #selector.  radioButtonClassSide label: 'class side'.  radioButtonInstanceSide     label: 'instance side';     state: true.  radioButtonInstanceSide associatedRadioButtons: {radioButtonClassSide}.  self focusOrder     add: packageList;     add: classList;     add: methodListcontainer  ^self model containerhShrinkWrap  newBadgeFont  | tmp1 |  tmp1 := StandardFonts codeFont.  ^(LogicalFont familyName: tmp1 familyName pointSize: tmp1 pointSize - 3) weightValue: 700classToTest  ^SpPickListPresenterisCheckList: arg1  tree isCheckList: arg1buildWidget  ^SpStubButtonView newdropList  ^self inputTextDropList dropListrightClicked  self subclassResponsibilitybeResizable  resize := trueinitialize: arg1  text label: arg1 asStringwhenHighlightedItemChanged: arg1  self deprecated: 'Use #whenHighlightedItemChangedDo: instead.' transformWith: '`@receiver whenHighlightedItemChanged: `@statements' -> '`@receiver whenHighlightedItemChangedDo: `@statements'.  self whenHighlightedItemChangedDo: arg1acceptColumnVisitor: arg1  ^self subclassResponsibilityfirstIcon: arg1 secondIcon: arg2  self firstButton icon: (self iconNamed: arg1).  self secondButton icon: (self iconNamed: arg2)buildCodeMenu  ^self codeCommandGroup asMenuPresenterborderWidth  ^self lookupProperty: SpStyleContainer valueOf: #borderWidthbeforeAssertInTest: arg1  arg1 openInstancetransmission  self subclassResponsibilitydo: arg1  self toPort: (SpActionPort newAction: arg1)keepScrollPositionOf: arg1 during: arg2  | tmp1 |  arg1 adapter ifNil: [ ^arg2 value ].  tmp1 := description scrollValue.  arg2 value.  description scrollValue: tmp1selectedIndex  ^listPresenter selectedIndexnotifyPropertyChanged: arg1  self flag: #todo.  (self observablePropertyNamed: arg1) valueChangedclickItem: arg1  self selectIndex: arg1headerIcon  ^self model headerIconextent: arg1  ^extent := arg1execute  self evaluateSelectionAndDo: [:arg1 |   ]whenMenuChangedDo: arg1  self property: #contextMenu whenChangedDo: arg1widget  ^self adapter widgettestSortingBlock  | tmp1 |  tmp1 := 0.  presenter whenSortingBlockChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter items: #(3 8 1 0).  presenter sortingBlock: [:arg2 |  arg2 label asNumber ] ascending.  self assert: tmp1 equals: 1.  self assert: (presenter model at: 1) label equals: '0'layoutPresenters  layout ifNil: [ ^self presenters ].  ^layout deepPresenters select: [:arg1 |  arg1 isSymbol ] thenCollect: [:arg1 |  self presenterAt: arg1 ]whenUrlChangedDo: arg1  self property: #url whenChangedDo: arg1addSpecialFields: arg1  arg1 add: (DynamicEyeElement host: self object label: 'hex bytes' description: [ self objectAsHexBytes ] value: [ self object ]).  arg1 add: (DynamicEyeElement host: self object label: 'hex string' value: [ self objectAsHexString ]).  arg1 add: (DynamicEyeElement host: self object label: 'latin-1 string' value: [ self objectAsLatin1String ]).  arg1 add: (DynamicEyeElement host: self object label: 'utf-8 string' value: [ [ self objectAsUTF8String ] on: ZnInvalidUTF8 do: [:arg2 |  arg2 asString ] ])inputField  ^inputFieldinitialize  super initialize.  treeModel := SpTreeModel model: self.  treeModel announcer when: MorphTreeSelectionChanged send: #onMorphTreeSelectionChanged: to: selfclassTemplateFor: arg1  ^'Object subclass: #NameOfSubclass	slots: {}	classVariables: {}	package: ''' , arg1 name , ''' 'childrenItemsBlock: arg1  childrenItemsBlock := arg1whenSelectedItemChanged: arg1  self dropList whenSelectedItemChanged: arg1clearText  self widgetDo: [:arg1 |  arg1 setTextWith: '' ]setIndex: arg1  self deprecated: 'Use #selectIndex: instead' transformWith: '`@receiver setIndex: `@arg' -> '`@receiver selectIndex: `@arg'.  self selectIndex: arg1baseColumnWidth  ^(bounds width / numColumns) asIntegernewColumn: arg1 origin: arg2 corner: arg3  self newColumn: arg1 origin: arg2 corner: arg3 offsetOrigin: 0 @ 0 offsetCorner: 0 @ 0transferBlock  ^self model transferBlockenabled  | tmp1 |  tmp1 := self model isEnabled.  ^(tmp1 isBlock or: [ tmp1 isMessageSend ]) ifTrue: [ tmp1 cull: self model ] ifFalse: [ tmp1 ]addShortcutTipFor: arg1 on: arg2  | tmp1 tmp2 |  self flag: #REMOVE.  arg2 ifNil: [ ^nil ].  tmp2 := arg2 asText.  arg1 ifNil: [ ^tmp2 ].  tmp1 := arg2 asLowercase indexOf: arg1 asLowercase.  tmp1 isZero ifTrue: [ ^tmp2 ].  ^tmp2     addAttribute: TextEmphasis underlined from: tmp1 to: tmp1;     yourselfselector: arg1  selector := arg1adapt: arg1  super adapt: arg1.  widget on: #click send: #click to: selfdestinationPresenter  ^delegation ifNotNil: [ delegation value ] ifNil: [ presenter ]execute  self browserClientProvider browseAllReferencesTo: self selectorinput  ^self inputTextDropList inputtestAddLabelledButtonAddTheButton  presenter addItem: (SpToolBarButton new           label: 'a label';           iconNamed: #abstract;           action: [  ];           yourself).  self assert: (self adapter hasButtonWithLabel: 'a label').  self assert: self adapter numberOfItems equals: 1selectedClassOrMetaClass  ^self behaviorwhenHighlightedItemChangedDo: arg1  highlightedItem whenChangedDo: arg1buildWidgetWith: arg1  ^TabMorph new     model: arg1;     label: arg1 label;     icon: arg1 icon;     retrievingBlock: arg1 retrievingBlock;     morph: arg1 contents;     menu: arg1 menu;     closeable: arg1 closeable;     setActionsFrom: [ arg1 actions ];     yourselftextModel  ^textModelbuildWidget  ^SpStubLabelAdapter newvResizing: arg1  vResizing := arg1enable  self model enabled: truelazyPageMorphCreation  ^lazyPageMorphCreationnotify: arg1 on: arg2  arg2 notifyError: arg1retrieveSpec: arg1  self layout ifNil: [ ^super retrieveSpec: arg1 ].  ^self layoutpresenterAt: arg1 ifAbsent: arg2  ^[ self readSlotNamed: arg1 ] on: SlotNotFound do: arg2text: arg1  self input text: arg1displayBlock  self deprecated: 'Please use #display instead' transformWith: '`@receiver displayBlock' -> '`@receiver display'.  ^tree displaychildren  ^childrenitems: arg1  | tmp1 |  tmp1 := arg1 collect: [:arg2 |  SpDropListItem on: arg2 do: [  ] ].  model collection: tmp1.  (tmp1 isNotEmpty and: [ startsWithSelection and: [ self selection isEmpty ] ]) ifTrue: [ self selectIndex: 1 ]configureScrolling  self presenter verticalAlignment whenChangedDo: [ widget scrollToIndex: self presenter verticalAlignment desiredVisibleRow ].  self presenter whenDisplayDo: [ widget scrollToIndex: self presenter verticalAlignment desiredVisibleRow.        self scrollingChanged ].  widget onAnnouncement: FTScrollingChanged send: #scrollingChanged to: selfacceptDroppingMorph: arg1 event: arg2 inMorph: arg3  | tmp1 tmp2 |  tmp2 := arg3 rowAtLocation: arg2 position.  tmp1 := self presenter model at: tmp2 ifAbsent: [ nil ].  ^self acceptDropBlock valueWithEnoughArguments: {arg1 model model .         arg2 .         arg3 model model .         tmp1 .         tmp2}addMenuItem: arg1  arg1 owner: self.  items add: arg1.  self autoRefresh ifNotNil: [ arg1 autoRefresh: self autoRefresh ]variableFieldsToShow  | tmp1 |  tmp1 := self objectVariableSize.  ^tmp1 <= (self limit1 + self limit2) ifTrue: [ 1 to: tmp1 ] ifFalse: [ (1 to: self limit1) , (tmp1 - self limit2 + 1 to: tmp1) ]doItContext  ^doItContexttestScrollDownToNonExistingIndexScrollsBottomToLastIndex  self flag: #pharo7.  SystemVersion current major < 8 ifTrue: [ self skip ].  presenter items: (1 to: 500).  presenter verticalAlignment desiredVisibleRow: 600.  self openInstance.  self assert: presenter verticalAlignment lastVisibleRowIndex equals: 500maxExtent  ^maxExtentemphasis  ^emphasistestRadio2WidgetStartsSelected  self openInstance.  self assert: self presenter radio2 adapter statebrowseInstClassVariables  ^self systemNavigation browseClassVariables: self hostClassstatusBar  ^statusbartestSelectAClassShouldDisplayHisProtcolInProtocolList  biChooseMethod packageList selectItem: self class package.  biChooseMethod classList selectItem: SpMethodChooserMockClass.  self assertCollection: (biChooseMethod protocolList items collect: #name) hasSameElements: #(#'-- all --' #accessing)maxWidth  ^self maxExtent ifNotNil: [:arg1 |  arg1 x ]filteringBlock: arg1  self deprecated: 'This feature is now removed from Spec 2. If the visible elements of the list need to be changed, it''s the users of the lists that should manage it and update the list of items of the list.'backendForTest: arg1  backendForTest := arg1 newname  ^self class backendNametestEnabled  self assert: presenter isEnabled.  self openInstance.  self assert: self morph enabled.  presenter enabled: false.  self deny: self morph enabledleftFraction  ^leftFractioncomputeRowPositions  rowPositions := Array new: numRows.  rowPositions at: 1 put: 0.  2 to: numRows do: [:arg1 |  rowPositions at: arg1 put: (rowPositions at: arg1 - 1) + (rowHeights at: arg1 - 1) + self layout rowSpacing ]initializePresenters  image1 := self newImage.  image2 := self newImage.  image1 image: (self iconNamed: #pharo).  image2 image: self currentWorld submorphs last formtestFirstIconSecondIcon  presenter firstIcon: #thumbsUp secondIcon: #thumbsDown.  self assert: presenter firstButton icon == (self iconNamed: #thumbsUp).  self assert: presenter secondButton icon == (self iconNamed: #thumbsDown)buildLayoutFor: arg1  | tmp1 |  tmp1 := SpBoxLayout newVertical.  (self instVarNamesFrom: arg1) groupsOf: self rowsCount atATimeDo: [:arg2 |  | tmp2 |        tmp2 := SpBoxLayout newHorizontal.        arg2 do: [:arg3 |  tmp2 add: arg3 ].        tmp1 add: tmp2 ].  ^tmp1badge  ^badgeacceptBlock  ^actionToPerformgreenSlider  ^greenSlidertestVisitCommandsGroup  | tmp1 |  self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.  commandsGroup acceptVisitor: menuBuilder.  tmp1 := menuBuilder menuPresenter defaultGroup menuItems.  self assert: tmp1 size equals: 3.  self assert: tmp1 first class equals: SpMenuItemPresenter.  self assert: tmp1 first name equals: commandsGroup entries first name.  self assert: tmp1 first description equals: commandsGroup entries first description.  self assert: tmp1 first subMenu isNil.  self assert: tmp1 second class equals: SpMenuItemPresenter.  self assert: tmp1 second name equals: commandsGroup entries second name.  self assert: tmp1 second description equals: commandsGroup entries second description.  self assert: tmp1 second subMenu isNotNil.  self assert: tmp1 second subMenu class equals: SpMenuPresenter.  self assert: tmp1 second subMenu menuGroups size equals: 1.  self assert: tmp1 second subMenu menuGroups first menuItems size equals: 2.  self assert: tmp1 second subMenu menuGroups first menuItems first class equals: SpMenuItemPresenter.  self assert: tmp1 second subMenu menuGroups first menuItems first name equals: commandsGroup entries second entries first name.  self assert: tmp1 second subMenu menuGroups first menuItems first description equals: commandsGroup entries second entries first description.  self assert: tmp1 second subMenu menuGroups first menuItems second class equals: SpMenuItemPresenter.  self assert: tmp1 second subMenu menuGroups first menuItems second name equals: commandsGroup entries second entries second name.  self assert: tmp1 second subMenu menuGroups first menuItems second description equals: commandsGroup entries second entries second description.  self assert: tmp1 third class equals: SpMenuItemPresenter.  self assert: tmp1 third name equals: commandsGroup entries third name.  self assert: tmp1 third description equals: commandsGroup entries third description.  self assert: tmp1 third subMenu isNiltype: arg1  type := arg1setSelectedItem: arg1  self deprecated: 'Use #selectedItem: instead' transformWith: '`@receiver setSelectedItem: `@argument' -> '`@receiver selectedItem:`@argument'.  ^self selectItem: arg1initializeWindow: arg1  arg1 title: self titleenableItemBeginsWithFilter  self itemFilter: [:arg1 :arg2 |  arg1 asLowercase beginsWith: arg2 asLowercase ]testActivateRaisesChangedEvent  presenter state: false.  self assertEvent: #whenChangedDo: isRaisedInPresenter: presenter whenDoing: [ presenter state: true ]addVariableFields: arg1  self sortedKeys do: [:arg2 |  arg1 add: (BagEyeElement host: self object index: arg2) ]inspect: arg1  self object: arg1assertText: arg1 atInterval: arg2 isStyle: arg3  arg2 do: [:arg4 |  self assertText: arg1 at: arg4 isStyle: arg3 ]selectItem: arg1  | tmp1 |  arg1 ifNil: [ self selection unselectAll.        ^self ].  tmp1 := model collection detect: [:arg2 |  arg2 model = arg1 ].  self selection selectItem: tmp1.  tmp1 valuedelete  self widgetDo: [:arg1 |  arg1 delete.        self application windowClosed: self ]selectedItem  ^self list selectedItemtestNoClickDoesNotExecuteAction  | tmp1 |  tmp1 := false.  presenter action: [ tmp1 := true ].  self deny: tmp1remove: arg1  children removeKey: arg1.  adapter ifNotNil: [:arg2 |  arg2 remove: arg1 ]rightFraction: arg1  ^layoutFrame rightFraction: arg1columnPositions  ^columnPositionstestInterpreterCanAccessPresenterVariablesWithoutAccessor  | tmp1 |  [ self shouldnt: [ tmp1 := SpMockPesenterWithoutGetter new openWithSpec ] raise: MessageNotUnderstood ] ensure: [ tmp1 ifNotNil: #close ]index: arg1  index := arg1minHeightOf: arg1  ^(self styleOf: arg1) minHeight ifNil: [ 0 ]setUp  super setUp.  calendar := SpCalendarPresenter newpageClass  ^SpDemoToolBarPresenteraddPreambleTo: arg1  arg1 assurePreambleExistssetRefreshingBlockForImplementorsOf: arg1  self refreshingBlock: [:arg2 |  arg2 selector = arg1 ]clearSelection  selection := #()testAddColumnInPresenterAddsItToWidget  | tmp1 |  tmp1 := SpStringTableColumn title: 'Hex' evaluated: #hex.  self presenter addColumn: tmp1.  self assert: self adapter columns last id equals: tmp1 titlewantsSteps  ^truegetText  self deprecated: 'Use #text instead' transformWith: '`@receiver getText' -> '`@receiver text'.  ^self texthash  ^index hashselectedTab: arg1  selectedTab value: arg1mouseUp: arg1  (self bounds containsPoint: arg1 cursorPoint) ifFalse: [ arg1 hand showTemporaryCursor: nil ].  self adoptPaneColor: self paneColor.  self preserveLayoutPositiontestSelectWidgetIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | tmp1 |  presenter selection whenChangedDo: [:arg1 |  tmp1 := arg1 ].  self adapter selectPath: #(1).  self assert: (tmp1 includes: #(1))testShouldAcceptNegativeInteger  presenter     beInteger;     maximum: 120;     minimum: -150.  self assert: (adapter shouldAccept: '-100').  self deny: (adapter shouldAccept: '-200')testSelectItemOutsideRangeIsEmpty  presenter selectItem: 4000.  self assert: presenter selection isEmptycollection: arg1  | tmp1 |  tmp1 := collection.  collection := arg1.  self refreshList.  self announcer announce: (ValueChanged oldValue: tmp1 newValue: collection)model  ^modeltestSelectPathThenSelectInvalidPathKeepsSingleSelectedItem  presenter selectPath: #(1 3).  presenter selectPath: #(50).  self assert: presenter selection selectedItems size equals: 1button  ^buttonleftText: arg1  leftText := arg1checkboxLabel  ^checkboxLabelinitialize  self class initializeSlots: self.  super initialize.  self property: #title whenChangedDo: [ self pageTitleChanged ].  self property: #icon whenChangedDo: [ self pageTitleChanged ]sortingBlock: arg1  self model sortingBlock: arg1testDeepMultipleLookup  | tmp1 |  tmp1 := self newLookup: '.application [ 		Geometry { #width: 11 },		.other [			Geometry { #width: 22 },			.deep1 [				Geometry { #width: 33 }			],			.deep2 [				Geometry { #width: 42 }			]		]	]'.  self assert: tmp1 width equals: 42testMoveElementAtTo  presenter items: {'AAA' .         'BBB' .         'CCC'} asOrderedCollection.  presenter moveElementAt: 1 to: 3.  self assert: presenter items asArray equals: {'BBB' .         'CCC' .         'AAA'}pathOf: arg1 from: arg2  | tmp1 |  tmp1 := arg2 indexOf: arg1.  tmp1 > 0 ifTrue: [ ^{tmp1} ].  arg2 withIndexDo: [:arg3 :arg4 |  (self pathOf: arg1 from: (presenter childrenFor: arg3)) ifNotNil: [:arg5 |  ^{arg4} , arg5 ] ].  ^nilcancelAction  ^cancelActionselector  ^selectornewWidgetOn: arg1  ^self subclassResponsibilitygetAdaptorWithDefaultSpecOf: arg1  ^arg1 buildAdapterWithSpecLayout: arg1 retrieveDefaultSpecheaderIconChanged  self widgetDo: [:arg1 |  self headerIcon ifNil: [ arg1 header removeIcon ] ifNotNil: [ arg1 header icon: (ImageMorph new form: self headerIcon) ] ]selectIndex: arg1  messageList selectIndex: arg1wrapItem: arg1 index: arg2  | tmp1 |  tmp1 := self model displayForItem: arg1.  ^tmp1 asStringattachTransmission: arg1  self destinationPresenter whenActivatedDo: [:arg2 |  self transmitWith: arg1 value: arg2 ]openWithSpecLayout: arg1  ^self application open: self withSpecLayout: arg1testSelectIndexSetsSelectedItem  presenter selectIndex: 1.  self assert: presenter selection selectedItem equals: 10addContent: arg1 toWindow: arg2  | tmp1 |  tmp1 := self newContainerMorph.  tmp1 layoutFrame: arg1 layoutFrame.  self model hasMenu ifTrue: [ self addMenuTo: tmp1 ].  self model hasToolbar ifTrue: [ self addToolBarTo: tmp1 ].  tmp1 addMorphBack: arg1.  arg1     hResizing: #spaceFill;     vResizing: #spaceFill.  self model hasStatusBar ifTrue: [ self addStatusBarTo: tmp1 ].  self add: tmp1 toWindow: arg2setUp  super setUp.  specInterpreterClass := SpInterpreter.  specInterpreter := specInterpreterClass new.  specInterpreter presenter: SpTestingPresenter newisWindowPresenter  ^truebeEditable  editable := truetext  ^textcardPairsCount  ^self differentCardsCountSlider valueapplyPreTransmissionWith: arg1  self preTransmission ifNil: [ ^self ].  self preTransmission cull: self toPresenter cull: self fromPresenter cull: arg1addLast: arg1 withConstraints: arg2  self add: arg1 withConstraints: [:arg3 |  arg3 bePlacedAtEnd.        arg2 value: arg3 ]isHorizontal  ^self subclassResponsibilitytree  ^tree ifNil: [ tree := self instantiate: SpTreePresenter.        tree whenBuiltDo: [ self initializeShortcuts ].        tree           whenSelectedItemChanged: [:arg1 |  arg1 ifNotNil: [ self text doItReceiver: arg1 value ] ];           displayBlock: [:arg2 |  self labelFor: arg2 ];           menu: [:arg3 |  self inspectionMenu: arg3 ];           hasChildrenBlock: [:arg4 |  true ];           childrenBlock: [:arg2 |  self childrenFor: arg2 ];           yourself ]removeClass: arg1 from: arg2  arg2 removeClassChanges: arg1announcingObject  ^announcingObjectselectedItem  ^valuewhenDaySelectedBlock: arg1  whenDaySelectedBlock := arg1dropList  ^self subwidgetroots  ^self childrenForObject: self objecttext: arg1  text := arg1dragEnabled: arg1  model  ^modelselectedIndex  self deprecated: 'Use the #selection object instead. This method assumes single selection' transformWith: '`@receiver selectedIndex' -> '`@receiver selection selectedIndex'.  ^self selection selectedIndexbuttonWithIconOnly: arg1  buttonWithIconOnly := arg1shouldShowInTree  ^trueproperty: arg1 whenChangedDo: arg2  (self observablePropertyNamed: arg1) whenChangedDo: arg2defaultSpecLayout  < spec>  ^SpLayout composed     add: #sideRuler origin: 0 @ (1 - self currentVerticalScrollPosition) corner: 0 @ (1 - self currentVerticalScrollPosition) offsetOrigin: 0 @ -250 offsetCorner: 50 @ 250;     add: #text origin: 0 @ 0 corner: 1 @ 1 offsetOrigin: 50 @ 0 offsetCorner: 0 @ 0;     yourselfpresenters  ^children keyshasContentToShow: arg1  hasContentToShow value: arg1testFontAffectsTheWidget  backendForTest canChangeFonts ifFalse: [ self skip ].  presenter label: 'ALabel'.  presenter font: StandardFonts codeFont.  self assert: self widget label equals: 'ALabel'.  self assert: self widget font equals: StandardFonts codeFontshowOnlyDestination: arg1  self widgetDo: [:arg2 |  arg2 showOnlyDestination: arg1 ]initialize  super initialize.  label := ''.  emphasis := #().  self whenLabelChangedDo: [ self changed: #getText ]basicMenuPopUp  ^MenuMorph new     addIfNeededTitle: self title andIcon: self icon;     yourselfabsoluteValue: arg1  ^self sliderInput absoluteValue: arg1asSpLayout  ^selfentryCompletion: arg1  self input entryCompletion: arg1configureButton: arg1 item: arg2  arg1 getLabelSelector: #label.  arg1 getIconSelector: #icon.  arg1 badgeSelector: #badgeinstantiateMorphs  morph1 := Morph new     color: Color red;     width: 60;     height: 20.  morph2 := Morph new     color: Color blue;     width: 20;     height: 60.  morph3 := Morph new     color: Color green;     width: 50;     height: 50withScrollBars  wrapScrollBars := trueinstVarName  ^instVarNameisOpen  ^self isClosed notinitialize  super initialize.  self beColumnHomogeneous.  self beRowHomogeneous.  columnConstraints := Dictionary new.  rowConstraints := Dictionary newtestFirstLabelSecondLabel  presenter firstLabel: 'label 1' secondLabel: 'label 2'.  self assert: presenter firstButton label asString equals: 'label 1'.  self assert: presenter secondButton label asString equals: 'label 2'layoutSpec: arg1  layoutSpec := arg1methodRecategorized: arg1  labelClickable  ^self model labelClickablelistSize  ^self dropList listSizewhenValueChangedDo: arg1  self property: #currentValue whenChangedDo: arg1testWhenLabelChangedDo  | tmp1 tmp2 |  tmp1 := 0.  presenter whenLabelChangedDo: [:arg1 |  tmp1 := tmp1 + 1.        tmp2 := arg1 ].  presenter label: 'Test'.  self assert: tmp2 equals: 'Test'.  self assert: tmp1 equals: 1label  ^self model labelunselectPath: arg1  self subclassResponsibilitystyleMinExtent: arg1  | tmp1 |  tmp1 := SpStyleSTONReader fromString: ('.application [ Geometry \{ #minWidth: {1}, #minHeight: {2} \} ]' format: {arg1 x .               arg1 y}).  ^SpMorphStyle newStyles: tmp1 flattenClassestestUnselectWidgetIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | tmp1 |  self adapter selectPath: #(1).  presenter selection whenChangedDo: [:arg1 |  tmp1 := arg1 ].  self adapter selectPath: #().  self assertEmpty: tmp1pageTitleChanged  self owner ifNil: [ ^self ].  self owner pageTitleChanged: selfselectedItems  ^self selectedItemsAtIndexes: self selection selectedIndexesasToolBarPresenterWith: arg1  self deprecated: 'Use #asToolbarPresenterWith: instead.' transformWith: '`@receiver asToolBarPresenterWith: `@arg' -> '`@receiver asToolbarPresenterWith: `@arg'.  ^self asToolbarPresenterWith: arg1min  ^minupdate: arg1 with: arg2  self perform: arg1 withArguments: arg2setUp  super setUp.  super setUp.  presenter     addColumn: (SpStringTableColumn title: 'Value' evaluated: #printString);     beSingleSelection;     roots: #(1 2 3);     children: [:arg1 |  arg1 < 100 ifTrue: [ {(arg1 * 2) .               (arg1 * 3) .               (arg1 * 10)} ] ifFalse: [ #() ] ];     yourselfmax: arg1  slider max: arg1readSelection  ^self model readSelectiontitle  ^titletestContextMenu  | tmp1 tmp2 |  self assert: presenter contextMenu isNil.  tmp1 := SpMenuPresenter new.  tmp2 := false.  presenter whenMenuChangedDo: [ tmp2 := true ].  presenter contextMenu: tmp1.  self assert: presenter contextMenu equals: tmp1.  self assert: tmp2classToTest  self subclassResponsibilitycenteredRelativeTo: arg1  self deprecated: 'This feature is to tight to Morphic to be in Spec. If you want this feature in a Morphic specific Spec application you should apply it yourself on the widget.		aWindow			fullBounds;			center: self adatper widget center' on: '2019-06-25' in: #Pharo8toolbarPresenter: arg1  toolbarPresenter := arg1guessTypeForName: arg1  ^niladdItemLabeled: arg1 do: arg2  self addItemLabeled: arg1 do: arg2 icon: nilstyleTableAt: arg1 do: arg2  | tmp1 |  tmp1 := (SHRBTextStyler initialTextAttributesForPixelHeight: 1) at: arg1.  tmp1 do: arg2owner: arg1  owner := arg1cancelled  ^cancellednotifyError: arg1  self subclassResponsibilitybuildWidget  ^SpStubBoxView newaddItem: arg1 position: arg2  arg1 owner: self.  arg2 addItem: arg1 into: selfinitializePresenters  redSlider := self instantiate: SpSliderInput.  greenSlider := self instantiate: SpSliderInput.  blueSlider := self instantiate: SpSliderInput.  redSlider     min: 0;     max: 255;     label: 'Red' translated.  greenSlider     min: 0;     max: 255;     label: 'Green' translated.  blueSlider     min: 0;     max: 255;     label: 'Blue' translated.  self focusOrder     add: redSlider;     add: greenSlider;     add: blueSlidercontentArea  ^contentAreawhenSelectedItemChanged: arg1  self dropList whenSelectedItemChanged: arg1specInitializationStrategy: arg1  specInitializationStrategy := arg1setTargetLayoutSizing  self target vResizing = #rigid ifTrue: [ ^self ].  self target vResizing: #rigid.  self targetAfter vResizing: #spaceFillasMenuBarPresenter  ^SpMenuBarPresenterBuilder new     visit: self;     menuPresenterdefinedFont  | tmp1 |  tmp1 := LogicalFont familyName: self name pointSize: self size.  self isItalic ifTrue: [ tmp1 forceItalicOrOblique ].  self isBold ifTrue: [ tmp1 forceBold ].  ^tmp1addItem: arg1 into: arg2  arg2 addItemRight: arg1testSelectManyIndexesKeepsAllSelected  presenter selectIndex: 1.  presenter selectIndex: 2.  self assert: self adapter selectedIndexes asArray equals: #(1 2)classToTest  ^SpTablePresentertoolbarItemFont: arg1  toolbarItemFont := arg1testOpenDialogWindowWithDifferentApplicationShouldFail  | tmp1 tmp2 |  tmp1 := SpApplication new.  tmp2 := tmp1 newPresenter: SpButtonPresenter.  self should: [ application openDialog: tmp2 ] raise: SpInvalidApplicationErrorcopyAllFrom: arg1 to: arg2  self checkThatSidesDiffer: [ ^self ].  self model copyAllChangesFrom: arg1 selectedChangeSet to: arg2 selectedChangeSet.  arg2 updateClassesListinitializePresenters  labelPresenter := self newLabel.  descriptionPresenter := self newNullPresentertitle  ^titleHoldertestUnselectSelectedItemRaisesSelectionEventOnce  | tmp1 |  tmp1 := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectItem: 10.  self assert: tmp1 equals: 1beInfo  self type: SpNotificationType infoclassToTest  ^SpSearchableListtestClickActivatedCheckboxDectivatesIt  presenter state: true.  self emulateLeftClick.  self deny: presenter statewhenSelectedItemChangedDo: arg1  selection whenChangedDo: [ arg1 cull: self selectedItem ]giveFocusToNextFrom: arg1  ^self presenter giveFocusToNextFrom: arg1roots: arg1  roots := arg1 asOrderedCollection.  tree roots: arg1 asOrderedCollectiontestSelectPathTwiceAddsPathToSelectedPathListOnlyOnce  presenter selectPath: #(1 3).  presenter selectPath: #(1 3).  self assert: presenter selection selectedPaths equals: #(#(1 3))dateLabel: arg1  dateLabel := arg1performMenuActionWith: arg1  | tmp1 |  tmp1 := self isEnabled.  tmp1 isBlock ifTrue: [ tmp1 := tmp1 value ].  tmp1 ifFalse: [ ^self ].  self action cull: arg1displayBlock  ^displayBlock valuetransmitWith: arg1 value: arg2  arg1 applyPreTransmissionWith: arg2.  arg1 toPort incomingTransmission: (arg1 transformed: arg2) from: self.  arg1 applyPostTransmissionWith: arg2selectIndex: arg1  self presenter selection selectPath: {arg1}setPackageButton  packageButton     state: false;     label: '+Package';     help: 'Add a new package and make it the working copy';     action: [ self createPackage ]withText: arg1  withText := arg1arguments  ^{(self commands identityIndexOf: self)}changesListPresenter  ^changesListPresenterinstantiate: arg1  ^arg1 owner: selfmodel: arg1  self deprecated: 'Use #presenter: instead' transformWith: '`@receiver model: `@statment1' -> '`@receiver presenter: `@statment1'.  self presenter: arg1classesMenu: arg1  classesListPresenter contextMenu: arg1wrap: arg1 at: arg2  | tmp1 |  associationsIndexToWrapper at: arg2 ifPresent: [:arg3 |  ^arg3 ].  tmp1 := self instantiate: SpCheckBoxPresenter.  blockToPerformOnWrappers value value: tmp1.  tmp1 label: (wrapHolder value cull: arg1 cull: self).  tmp1 whenActivatedDo: [ self addPicked: arg1.        listPresenter setSelectedItem: tmp1.        listPresenter takeKeyboardFocus ].  tmp1 whenDeactivatedDo: [ self removePicked: arg1.        listPresenter selectItem: tmp1.        listPresenter takeKeyboardFocus ].  tmp1     state: self defaultValue;     labelClickable: self labelClickable.  associationsWrapperToItem at: tmp1 put: arg1.  associationsItemToWrapper at: arg1 put: tmp1.  associationsIndexToWrapper at: arg2 put: tmp1.  ^tmp1basicAdd: arg1 constraints: arg2 to: arg3  testAddPresenterToComponentListIsInPresenterCollection  | tmp1 |  tmp1 := SpButtonPresenter new.  presenter addPresenter: tmp1.  self assert: (presenter includes: tmp1)refreshList  ^self widget refreshsubwidget: arg1  subwidget := arg1selectedItem  self deprecated: 'Use #selectedMessage instead' transformWith: '`@receiver selectedItem' -> '`@receiver selectedMessage'.  ^self selectedMessagebePlacedAtStart  placedAtStart := trueremoveMessage  self okToChange ifFalse: [ ^self ].  self selectedSelector ifNotNil: [:arg1 |  | tmp1 tmp2 |        tmp1 := self selectedClass.        (tmp1 includesSelector: arg1) ifFalse: [ ^self ].        tmp2 := tmp1 >> arg1.        (self model removeMethod: tmp2 inClass: tmp1) ifTrue: [ self updateMessagesList ] ]presenter: arg1  presenter := arg1buildWidget  ^SpStubMenuView newtestShouldAcceptIntegerWithoutMinMax  presenter     beInteger;     maximum: nil;     minimum: nil.  self assert: (adapter shouldAccept: '').  self assert: (adapter shouldAccept: '100').  self deny: (adapter shouldAccept: '100.10').  self assert: (adapter shouldAccept: '80').  self assert: (adapter shouldAccept: '150').  self deny: (adapter shouldAccept: 'string').  self deny: (adapter shouldAccept: '10string')span  ^spanrename  | tmp1 |  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  tmp1 := self model rename: self selectedChangeSet.  changesListPresenter     updateList;     setSelectedItem: tmp1.  self updateWindowTitletestBorderWidthNotHomogeneous  | tmp1 |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1.  self place: label2 at: 1 @ 2.  self place: morph2 at: 2 @ 2.  (tmp1 := self newLayout) layout     beRowNotHomogeneous;     beColumnNotHomogeneous;     borderWidth: 5.  tmp1 layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (5 @ 5 corner: 55 @ 25).  self assert: morph1 bounds equals: (55 @ 5 corner: 105 @ 25).  self assert: label2 bounds equals: (5 @ 25 corner: 55 @ 45).  self assert: morph2 bounds equals: (55 @ 25 corner: 105 @ 45)browseModel  ^browseModelchildrenBlock  ^childrenBlockHolder valuetestSelectIndexesThenSelectOutsideRangeKeepsIndexes  presenter selectIndexes: {1 .         2}.  presenter selectIndexes: {50 .         60}.  self assert: (presenter selection includesIndexes: {1 .               2})whenCanDeselectByClickChanged: arg1  self deprecated: 'Use #whenCanDeselectByClickChangedDo: instead.' transformWith: '`@receiver whenCanDeselectByClickChanged: `@statements' -> '`@receiver whenCanDeselectByClickChangedDo: `@statements'.  self whenCanDeselectByClickChangedDo: arg1styleSheet  ^self propertyAt: #styleSheet ifAbsent: [ SpStyle defaultStyleSheet ]addPresenterIn: arg1 withSpecLayout: arg2  self addContent: (self model presenter buildWithSpecLayout: arg2) toWindow: arg1whenGhostTextChanged: arg1  self deprecated: 'This API is too tight to Morph. Use #whenPlaceholderChanged: instead.' transformWith: '`@receiver whenGhostTextChanged: `@statement' -> '`@receiver whenPlaceholderChangedDo: `@statement'.  self whenPlaceholderChangedDo: arg1customMenuActions  ^customMenuActions ifNil: [ customMenuActions := [  ] ]testOpenPresenterRaisesDisplayEvent  | tmp1 |  tmp1 := false.  presenter whenDisplayDo: [ tmp1 := true ].  self openInstance.  self assert: tmp1backgroundColorFor: arg1 at: arg2  ^self model backgroundColorFor: arg1 at: arg2classToTest  ^SpCheckBoxPresentertestFromStylesheetAdapter  | tmp1 tmp2 |  tmp2 := SpLabelPresenter new     buildWithSpec;     adapter.  tmp1 := SpMorphStyle fromStylesheet: (SpStyleSTONReader fromString: '.application [	.label [		Geometry { #width: 42 }		]	]') adapter: tmp2.  self assert: tmp1 width equals: 42.  tmp1 := SpMorphStyle fromStylesheet: (SpStyleSTONReader fromString: '.application [	Geometry { #width: 42 },	.label [ ]	]') adapter: tmp2.  self assert: tmp1 width equals: 42.  tmp1 := SpMorphStyle fromStylesheet: (SpStyleSTONReader fromString: '.application [	.label [		Geometry { #width: 42 }	],	.other [ 		.label [ 			Geometry { #width: 22 } 		] 	]]') adapter: tmp2toolName  ^self class toolNametestWhenClosedDo  | tmp1 |  tmp1 := false.  presenter whenClosedDo: [ tmp1 := true ].  self openInstance.  presenter close.  self assert: tmp1classToTest  ^SpDatePresenterbuildWidget  ^SpStubNumberInputFieldView newtargetAfter  ^self owner submorphs after: selftestDeepLookup  | tmp1 |  tmp1 := self newLookup: '.application [ 		Geometry { #width: 11 },		.other [			Geometry { #width: 22 },			.deep [				Geometry { #width: 42 }			]		]	]'.  self assert: tmp1 width equals: 42testExplicitNotificationRaisesEventOnlyOnce  | tmp1 |  tmp1 := 0.  point property: #x whenChangedDo: [ tmp1 := tmp1 + 1 ].  point notifyPropertyChanged: #x.  self assert: tmp1 equals: 1width  ^widthborderColor  ^self model borderColortestMethodListContentWhenInstanceSideIsSelected  biChooseMethod radioButtonInstanceSide click.  biChooseMethod packageList selectItem: SpMethodChooserMockClass package.  biChooseMethod classList selectItem: SpMethodChooserMockClass.  self denyEmpty: biChooseMethod methodList items.  self assert: biChooseMethod methodList selection selectedIndex equals: 1.  self assertCollection: SpMethodChooserMockClass methods hasSameElements: biChooseMethod methodList itemsrestore  self modelChangedtransmission  self subclassResponsibilitybasicAdd: arg1 constraints: arg2 to: arg3  | tmp1 |  tmp1 := self buildMorph: arg1 constraints: arg2.  arg3 addMorphBack: tmp1.  ^tmp1labelPresenter: arg1  labelPresenter := arg1protocolList  ^protocolListmenu: arg1  menuBlockHolder value: arg1copyClassFrom: arg1 to: arg2  | tmp1 |  self checkThatSidesDiffer: [ ^self ].  self okToChange ifFalse: [ ^self inform: 'Can''t discard edits.' ].  arg1 selectedClass ifNil: [ ^self inform: 'Selected class is nil.' ].  tmp1 := arg2 selectedChangeSet.  self model copyClass: arg1 selectedClass from: arg1 selectedChangeSet to: tmp1.  arg2 setSelectedChangeSet: tmp1initializePresenters  menu := self newMenuBar     addGroup: [:arg1 |  arg1 addItem: [:arg2 |  arg2                 name: 'File';                 icon: (self iconNamed: #openIcon);                 subMenu: self subMenu ].        arg1 addItem: [:arg2 |  arg2                 name: '';                 description: 'Open file';                 icon: (self iconNamed: #openIcon);                 action: [ self inform: 'Open File' ] ].        arg1 addItem: [:arg2 |  arg2                 name: '';                 description: 'Save File';                 icon: (self iconNamed: #smallSaveIcon);                 action: [ self inform: 'Save File' ] ].        arg1 addItem: [:arg2 |  arg2                 name: '';                 description: 'Print file';                 icon: (self iconNamed: #smallPrintIcon);                 action: [ self inform: 'Print file' ] ] ];     addGroup: [:arg1 |  arg1 addItem: [:arg2 |  arg2                 name: '';                 description: 'Undo';                 icon: (self iconNamed: #smallUndoIcon);                 action: [ self inform: 'Undo' ] ].        arg1 addItem: [:arg2 |  arg2                 name: '';                 description: 'Redo';                 icon: (self iconNamed: #smallRedoIcon);                 action: [ self inform: 'Redo' ] ] ];     addGroup: [:arg1 |  arg1 addItem: [:arg2 |  arg2                 name: '';                 description: 'Add menu item';                 icon: (self iconNamed: #add);                 action: [ self addItemTo: arg1 ] ] ].  menu applyTo: self.  text := self newText.  self focusOrder add: textheight  ^heightobjectVariableSize  ^[ self object size ] on: Error do: [ self object basicSize ]basicPresenters  ^presenters ifNil: [ presenters := OrderedDictionary new ]phone: arg1  phone := arg1form  ^formwithWidgetDo: arg1  ^self adapter ifNotNil: arg1realMenu: arg1  realMenu := arg1testAddManyPresentersPushesThemToPresenterList  3 timesRepeat: [ self presenter addPresenter: (SpNullMillerPresenter on: SpLabelPresenter new) ].  self assert: self presenter size equals: 3initialize  super initialize.  selector := #newHSplitterAt:.  layoutFrame := (0 @ 0 corner: 0 @ 0) asSpLayoutFrame bottomOffset: 1placeAtEnd  placeAtStart := falseaction  ^actionchildren  ^children valuepreTransmission  ^preTransmissionlist  ^liststate  ^statesetImplementorsModel  implementorsModel     state: false;     label: 'Implementors';     action: [ self implementorsMethod ]testSetColumnTitleInPresenterShowsThemInWidget  self presenter headerTitle: 'test'.  self assert: self adapter isShowColumnHeadersadd: arg1  self add: arg1 withConstraints: [:arg2 |   ]suspendAnnouncementsDuring: arg1  | tmp1 |  tmp1 := self announcer subscriptions subscriptions.  tmp1 do: [:arg2 |  self announcer unsubscribe: arg2 ].  arg1 value.  tmp1 do: [:arg2 |  self announcer basicSubscribe: arg2 ]initialize  super initialize.  self actionBarPresenter: SpActionBarPresenter newbuildWithSpec: arg1  ^self buildWithSpecLayout: (self retrieveSpec: arg1)testSelecting2ElementsUpdatesThePresenterCorrectly  selectOnlyLastHighlighted  ^removeOnlyLastSelected valueinstantiatePresenters: arg1  (arg1 anySatisfy: [:arg2 |  arg2 isKindOf: Association ]) ifTrue: [ arg1 do: [:arg3 |  | tmp1 tmp2 |              tmp1 := arg3 key.              tmp2 := arg3 value.              self instVarNamed: tmp1 asString put: (self createInstanceFor: tmp2) ] ] ifFalse: [ arg1 pairsDo: [:arg4 :arg5 |  self instVarNamed: arg4 asString put: (self createInstanceFor: arg5) ] ]buildDynamicPresenter  dynamicPresenter := SpDynamicPresenter new.  dynamicPresenter instantiatePresenters: self instVarNamesAndPresenterNamesArray.  self instVarToModelObjectDo: [:arg1 :arg2 |  self configurationBlock value: (arg1 value: dynamicPresenter) value: arg2 ].  ^dynamicPresenterinitialize  super initialize.  visible := true.  self initializePrivateAnnouncer.  self initializePrivateValueHolders.  self initializePrivateHooks.  self initializePrivateAnnouncementsinitializePresenters  radio1 := self newRadioButton     label: 'radio1';     yourself.  radio2 := self newRadioButton     label: 'radio2';     yourself.  radio3 := self newRadioButton     label: 'radio3';     yourself.  radio1 associatedRadioButtons: {radio2 .         radio3}testExplicitNotifyUnexistentPropertyChangedRaisesError  self should: [ point notifyPropertyChanged: #z ] raise: SlotNotFoundslider  ^slidericon  ^icondoubleClick: arg1  doubleClick value: arg1testUnselectSelectedPathRemovesSelection  presenter     selectPath: #(1 1);     unselectPath: #(1 1).  self assert: presenter selection isEmptyemulateRightClick  self emulateClick: MouseButtonEvent yellowButtoncolumnWidths  ^columnWidthswithText  ^withTexthasMenu  ^self menu notNilselectedItemsSorted  ^self selectedItemsAtIndexes: self selection selectedIndexes sortinternalGetText  ^TextDiffBuilder buildDisplayPatchFrom: (self priorVersionOfAMethod: method) sourceCode to: method sourceCode inClass: method classNameplaceholder: arg1  placeholder := arg1whenAutoDeselectChanged: arg1  self deprecated: 'Use #whenAutoDeselectChangedDo: instead.' transformWith: '`@receiver whenAutoDeselectChanged: `@statements' -> '`@receiver whenAutoDeselectChangedDo: `@statements'.  self whenAutoDeselectChangedDo: arg1testSetRootModelWithPresenterDoesNotFail  self presenter presenterBlock: [:arg1 |  SpNullMillerPresenter on: (SpLabelPresenter new label: arg1 asString) ].  self shouldnt: [ self presenter setRootModel: 1 ] raise: ErrormessageListMenu  ^self newMenu     addGroup: [:arg1 |  arg1           addItem: [:arg2 |  arg2                 name: 'Compare to current';                 help: 'Compare selected version to the current version';                 action: [ self compareToCurrentVersion ] ];           addItem: [:arg2 |  arg2                 name: 'Compare to version...';                 help: 'Compare selected version to another selected version';                 action: [ self compareToOtherVersion ] ];           addItem: [:arg2 |  arg2                 name: 'Revert to selected version';                 help: 'Resubmit the selected version, so that it becomes the current version';                 action: [ self revert: self selectedMessage ] ];           addItem: [:arg2 |  arg2                 name: 'Senders';                 shortcut: $n meta;                 action: [ self browseSenders ] ];           addItem: [:arg2 |  arg2                 name: 'Implementors';                 shortcut: $m meta;                 action: [ self browseImplementors ] ] ];     yourselfisMorphicAdapter  ^truesetRootModel: arg1  self resetTo: 0.  self pushModel: arg1color: arg1  color := arg1content  ^self nodeModel contentadd: arg1  whenAutoAcceptChanged: arg1  self deprecated: 'Use #whenAutoAcceptChangedDo: instead.' transformWith: '`@receiver whenAutoAcceptChanged: `@statements' -> '`@receiver whenAutoAcceptChangedDo: `@statements'.  self whenAutoAcceptChangedDo: arg1methodClassNameForItem: arg1  ^arg1 methodClass ifNotNil: [:arg2 |  arg2 name ] ifNil: [ '' ]setHeaderButtonLabel: arg1 font: arg2 icon: arg3 target: arg4 actionSelector: arg5  (arg1 isNil and: [ arg3 isNil and: [ arg4 isNil or: [ arg5 isNil ] ] ]) ifTrue: [ ^self ].  self headerButton.  arg1 ifNil: [ self header label: '' font: nil ] ifNotNil: [ self header label: arg1 font: arg2 ].  arg3 ifNotNil: [ self header icon: (ImageMorph new form: arg3) ].  (arg5 notNil and: [ arg4 notNil ]) ifFalse: [ ^self ].  self header actionSelector: arg5.  self header target: arg4table  ^tableselection  ^selectionModeupdateAccordingTo: arg1  self widgetDo: [:arg2 |  arg2 contents do: [:arg3 |  arg3 nodeModel updateAccordingTo: arg1 ].        arg2 contents removeAllSuchThat: [:arg3 |  (arg1 keepTreeNode: arg3 nodeModel) not and: [ arg3 nodeModel isEmpty ] ] ]menu: arg1 shifted: arg2  self deprecated: 'Use #contextMenu: instead. The old way to create a MenuPresenter was this method taking a MenuMorph as parameter. This will not work with other backend and will be totally removed in Pharo7. Now you should use #contextMenu takin a MenuPresenter (or a block returning a menu presenter) as parameter.' on: '2019-03-07' in: #Pharo8.  self contextMenu: [ arg1 cull: (MenuMorph new                 defaultTarget: self;                 yourself) cull: true ]bindKeyCombination: arg1 toAction: arg2  self widgetDo: [:arg3 |  arg3 bindKeyCombination: arg1 toAction: arg2 ]rowInset: arg1  rowInset value: arg1childNodeClassFor: arg1  ^childNodeClass valuenumberType: arg1  numberType := arg1testReplaceItemList  | tmp1 |  tmp1 := false.  presenter whenModelChangedDo: [ tmp1 := true ].  presenter items: #(a b c).  self assert: presenter model collection equals: #(a b c).  self assert: tmp1defer: arg1  self application defer: arg1eventKeyStrokesForPreviousFocus  ^{Character arrowLeft asKeyCombination .   Character tab shift asKeyCombination}buildLayoutFor: arg1  | tmp1 |  tmp1 := SpBoxLayout newHorizontal.  (self instVarNamesFrom: arg1) groupsOf: self columnsCount atATimeDo: [:arg2 |  | tmp2 |        tmp2 := SpBoxLayout newVertical.        arg2 do: [:arg3 |  tmp2 add: arg3 ].        tmp1 add: tmp2 ].  ^tmp1backendForTest: arg1  backendForTest := arg1 newnewIndex  ^newIndexclassToTest  ^SpVersatileDialogPresenteractivationAction: arg1  actionWhenActivated := arg1whenSortingBlockChangedDo: arg1  self model whenSortingBlockChangedDo: arg1openWithSpecLayout: arg1  self buildWithSpecLayout: arg1.  self updateTitlerowsCount: arg1  (arg1 isInteger and: [ arg1 > 0 ]) ifFalse: [ self error: 'A positive integer is expected as parameter.' ].  rowsCount := arg1add: arg1  self widgetDo: [:arg2 |  arg2 spEnsureLayoutAndAddMorph: arg1 widget ]accessorCode  ^self instVarNametraversePresentersDo: arg1  self traversePresentersDo: arg1 excluding: Set newdisplayBlock: arg1  listModel displayBlock: arg1whenTextChanged: arg1  self input whenTextChanged: arg1testPlaceholderIsSet  presenter placeholder: 'enter something...'.  self assert: presenter placeholder equals: 'enter something...'aboutToStyle: arg1  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8hideColumnHeaders  showColumnHeaders := falseselectionHolder  ^self observablePropertyNamed: #selectedIndexrefreshColumnsInWidget  widget columns: (self model columns collect: [:arg1 |  self newColumnFrom: arg1 ]).  self ensureAtLeastOneColumnIn: widgettoolbarPresenter  ^toolbarPresentertestAsButtonPresenterExecutesOnClick  | tmp1 tmp2 |  tmp1 := false.  command := CmBlockCommand new     block: [ tmp1 := true ];     yourself.  tmp2 := command asSpecCommand asButtonPresenter.  tmp2 click.  self assert: tmp1 equals: truewrite: arg1 to: arg2  (super read: arg2) ifNotNil: [:arg3 |  arg3 value: arg1 ].  ^arg1dropListItems: arg1  model collection: arg1initializePresenters  label := self instantiate: SpLabelPresenterenabled: arg1  self presentersDo: [:arg2 |  arg2 enabled: arg1 ]testRemoveTabFromManager  self openInstance.  presenter addTab: redTab.  self assertCollection: presenter tabs hasSameElements: {redTab}.  self assertCollection: (self morphicTabsFor: presenter) hasSameElements: {redTab adapter widget}.  redTab adapter widget delete.  self assertCollection: presenter tabs hasSameElements: #().  self assertCollection: (self morphicTabsFor: presenter) hasSameElements: #()denyEvent: arg1 isRaisedInPresenter: arg2 whenDoing: arg3  self assertWith: [:arg4 |  arg4 = 0 ] timesRaisedEvent: arg1 inPresenter: arg2 whenDoing: arg3intervalOf: arg1 inCode: arg2 of: arg3  arg3 compiledMethod ifNil: [ ^0 to: 0 ].  ^(self sourceIntervalOf: arg1 in: arg3 ast) ifEmpty: [ self searchedString: arg1 asString in: arg2 ]newCheckBox  ^self instantiate: SpCheckBoxPresentertestSelectIndexesThenSelectOutsideRangeKeepsElements  presenter selectIndexes: {1 .         2}.  presenter selectIndexes: {50 .         60}.  self assert: (presenter selection includesItems: {10 .               20})addCellColumn: arg1  self addCell: (arg1 readObject: self item) column: arg1testModelSettingModelToValueHolder  | tmp1 tmp2 tmp3 |  tmp1 := 40 @ 54.  tmp3 := SpTestingPresenterWithModel on: tmp1.  tmp2 := SpTestingPointModel x: 1 y: 2.  self assert: tmp3 announcingObject isSpAnnouncingObject.  self assert: tmp3 announcingObject isValueHolder.  self assert: tmp2 isSpAnnouncingObject.  self deny: tmp2 isValueHolder.  tmp3 model: tmp2.  self assert: tmp3 announcingObject isSpAnnouncingObject.  self deny: tmp3 announcingObject isValueHolder.  self assert: tmp3 announcingObject == tmp2.  self assert: tmp3 announcingObject announcer numberOfSubscriptions > 0initialize: arg1  label label: arg1.  input text: arg1.  textToReset := arg1state: arg1  (arg1 not and: [ associatedRadioButtons noneSatisfy: [:arg2 |  arg2 state ] ]) ifTrue: [ ^self ].  super state: arg1.  arg1 ifTrue: [ associatedRadioButtons do: [:arg2 |  arg2 state: false ] ]rowHeights  ^rowHeightsadapter  ^nilallUnselectedItems  | tmp1 |  tmp1 := OrderedCollection new.  self selected ifFalse: [ tmp1 add: self ].  self children value do: [:arg1 |  tmp1 addAll: arg1 allUnselectedItems ].  ^tmp1ensureExtentFor: arg1  self extent ifNil: [ self initialExtent ifNotNil: [:arg2 |  (arg1 respondsTo: #extent:) ifTrue: [ arg1 extent: arg2 ] ] ] ifNotNil: [:arg2 |  (arg1 respondsTo: #extent:) ifTrue: [ arg1 extent: arg2 ] ]acceptDroppingMorph: arg1 event: arg2 inMorph: arg3  ^self acceptDropBlock cull: arg1 model model cull: arg2 cull: arg3 cull: arg3 modelacceptBlock: arg1  textModel acceptBlock: arg1buildWidget  ^SpStubSpacerView newwidth  ^self extent ifNotNil: [:arg1 |  arg1 x ]selectPaths: arg1  self selection selectPaths: arg1emptyAccumulator: arg1  arg1 do: [:arg2 |  widget addMorphBack: arg2 ].  arg1 removeAlllabel  ^self presenter labelassertList: arg1 displayItems: arg2  | tmp1 tmp2 |  self waitUntilUIRedrawed.  tmp1 := arg1 widget submorphs first.  tmp2 := tmp1 submorphs collect: [:arg3 |  | tmp3 |        tmp3 := arg3 submorphs first.        (tmp3 submorphs detect: [:arg4 |  arg4 isKindOf: StringMorph ]) contents ].  self assert: tmp2 first = arg2 first.  self assert: tmp2 second = arg2 second.  self assert: tmp2 third = arg2 thirdmodelChanged  workingModel := self model copy.  self fillFormWithWorkingModelstep  | tmp1 |  super step.  tmp1 := end - start.  self value: self value + (tmp1 / self indeterminateStepIncrease).  self value > tmp1 ifFalse: [ ^self ].  self value: start.  oddPassage := oddPassage notwhenTextIsAcceptedDo: arg1  self property: #actionPerformed whenChangedDo: arg1wantsDroppedMorph: arg1 event: arg2 inMorph: arg3  ^self model wantsDroppedMorph: arg1 event: arg2 inMorph: arg3hasProperty: arg1  ^themeOverrideDict includesKey: arg1adapterName  ^#BoxAdapterbuildButtonBar  | tmp1 |  tmp1 := (SpButtonBarPresenter owner: self model) placeAtEnd.  self model buttons do: [:arg1 |  tmp1 add: arg1 ].  ^tmp1initialExtent  ^200 @ 25topologicSort: arg1  ^messageList topologicSort: arg1beforeTest: arg1  arg1 openInstanceselectItem: arg1  self selection selectItem: arg1connectPresenters  labelClickableHolder whenChangedDo: [:arg1 |  associationsWrapperToItem keysDo: [:arg2 |  arg2 labelClickable: arg1 ] ].  defaultValueHolder whenChangedDo: [:arg3 |  associationsWrapperToItem keysDo: [:arg4 |  arg4 state: arg3 ] ]isPresenter  ^trueinitialize  super initialize.  lock := false.  subscriptions := OrderedCollection newaboutText  ^aboutTextabsoluteValue: arg1  ^self presenter absoluteValue: arg1constraintsClass  ^SpBoxConstraintsiconFor: arg1  ((arg1 includesBehavior: (Smalltalk globals at: #TestCase ifAbsent: [ false ])) and: [ arg1 isAbstract not ]) ifTrue: [ arg1 hasPassedTest ifTrue: [ ^self iconNamed: #testGreenIcon ].        arg1 hasFailedTest ifTrue: [ ^self iconNamed: #testYellowIcon ].        arg1 hasErrorTest ifTrue: [ ^self iconNamed: #testRedIcon ].        ^self iconNamed: #testNotRunIcon ].  arg1 organization classComment ifEmpty: [ ^self iconNamed: #uncommentedClassIcon ].  ((arg1 includesBehavior: (Smalltalk globals at: #TestCase ifAbsent: [ false ])) and: [ arg1 isAbstract not ]) ifTrue: [ arg1 hasPassedTest ifTrue: [ ^self iconNamed: #testGreenIcon ].        arg1 hasFailedTest ifTrue: [ ^self iconNamed: #testYellowIcon ].        arg1 hasErrorTest ifTrue: [ ^self iconNamed: #testRedIcon ].        ^self iconNamed: #testNotRunIcon ].  arg1 organization classComment ifEmpty: [ ^self iconNamed: #uncommentedClassIcon ].  ^arg1 systemIconhelpText  ^widget balloonTextadapter: arg1  adapter := arg1strongSelectionChanged: arg1  self presenter activatesOnDoubleClick ifTrue: [ self presenter doubleClickAtIndex: arg1 selectedIndex ]maxExtent: arg1  maxExtent := arg1onLayoutChange: arg1  layoutChangeAction := arg1whenScrollValueChangedDo: arg1  self property: #scrollValue whenChangedDo: arg1isHorizontal  ^(properties listDirection == #topToBottom or: [ properties listDirection == #bottomToTop ]) nottoolbar  ^toolbarselectPath: arg1  self selection selectPath: arg1accept: arg1  self model accept: arg1addTab: arg1  self widgetDo: [:arg2 |  arg2 addTab: (self buildTab: arg1) ]testSelectIndexesOutsideRangeHasNoSelectedIndexes  presenter selectIndexes: {4 .         5}.  self assert: presenter selection selectedIndexes isEmptytestSelectPathThenSelectInvalidPathKeepsFirstPath  presenter selectPath: #(1 3).  presenter selectPath: #(50).  self assert: (presenter selection includesPath: #(1 3))childrenFor: arg1  ^self children value: arg1tabSelectedActionHolder  ^tabSelectedActionHolderselectAllChildren  self children value do: [:arg1 |  arg1 selected: true.        arg1 selectAllChildren ]extent  ^45 @ 25placeholder: arg1  placeholder := arg1.  entityText placeholder: arg1activatesOnSingleClick  ^activateOnSingleClickconvertSymbolOfClassToInstance: arg1  | tmp1 |  tmp1 := self bindings translateSymbol: arg1.  ^(Smalltalk at: tmp1 ifAbsent: [ ^tmp1 ]) owner: self presentersetFocus  self focusOrder     add: messageList;     add: toolbarPresenter;     add: textModelassertListHeaderOf: arg1 equals: arg2  | tmp1 tmp2 tmp3 |  self waitUntilUIRedrawed.  tmp1 := arg1 widget submorphs first.  tmp2 := tmp1 submorphs first.  tmp3 := tmp2 submorphs.  self assert: (tmp3 collect: [:arg3 |  arg3 submorphs first contents ]) asArray = arg2 asArrayfullFrame: arg1  layout := arg1elements  ^self model ifNotNil: #items ifNil: [ #() ]itemNotFoundAction  self clearSelectionstyle: arg1  | tmp1 |  tmp1 := SpCodeStyleForTest new.  self styleTableAt: arg1 do: [:arg2 |  self fillTag: tmp1 withAttribute: arg2 ].  ^tmp1minWidthOf: arg1  ^(self styleOf: arg1) minWidth ifNil: [ 0 ]whenActivationActionChangedDo: arg1  self property: #actionWhenActivated whenChangedDo: arg1showBoth  self widgetDo: [:arg1 |  arg1 showBoth ]daysInAWeek  ^self dayNames sizetestSelectMultipleItemsRaisesSelectionChangeEventMultipleTimes  | tmp1 |  tmp1 := 0.  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter selectItem: 10.  presenter selectItem: 30.  self assert: tmp1 equals: 2refreshList  ^self widget refreshdisplayBlock: arg1  self deprecated: 'Please use #display: instead' transformWith: '`@receiver displayBlock: `@arg' -> '`@receiver display: `@arg'.  tree display: arg1scaleLabel  ^scaleLabelbuttonAt: arg1  ^buttons at: arg1enableSearch  searchEnabled := truetext  ^textexpandRoots  self changed: #expandRoots with: #()pageClass  ^SpDemoFormPresenterhAlign  ^hAlignclicked  widget toggleSelectedinitializePresenters  label := self newLabel.  list := self newList.  addButton := self newButton.  removeButton := self newButton.  upButton := self newButton.  downButton := self newButton.  topButton := self newButton.  bottomButton := self newButton.  addButton     addStyle: 'small';     icon: (self iconNamed: #addIcon);     help: 'Add a new item to the list'.  removeButton     addStyle: 'small';     icon: (self iconNamed: #removeIcon);     help: 'Remove a item from the list'.  upButton     addStyle: 'small';     icon: (self iconNamed: #upIcon);     help: 'Move this item up from one element'.  downButton     addStyle: 'small';     icon: (self iconNamed: #downIcon);     help: 'Move this item down from one element'.  topButton     addStyle: 'small';     icon: (self iconNamed: #topIcon);     help: 'Move this item on the first position of the list'.  bottomButton     addStyle: 'small';     icon: (self iconNamed: #bottomIcon);     help: 'Move this item on the last position of the list'checkboxDisabled  ^checkboxDisabledhasChildrenBlock: arg1  hasChildrenBlockHolder value: arg1okAction: arg1  okBlock := arg1initialize  self class initializeSlots: self.  super initialize.  currentValue := 0beVertical  direction := SpLayoutDirection verticalwindowIsOpening  self model windowIsOpeningproperty: arg1 rawValue: arg2  (self observablePropertyNamed: arg1) rawValue: arg2generateElements  | tmp1 |  tmp1 := OrderedCollection new.  self addSelf: tmp1.  self showClass ifTrue: [ self addClass: tmp1 ].  self showAllInstVars ifTrue: [ self addAllInstVars: tmp1 ].  self addSpecialFields: tmp1.  self addInstancesVariable: tmp1.  self addVariableFields: tmp1.  ^tmp1newDropList  ^self instantiate: SpDropListPresentermodel: arg1  model := arg1progression  ^progressionlabel  ^'all inst vars'textStyler: arg1  textStyler := arg1hasContentToShow  ^hasContentToShow valuedisplay  ^tree displaytestCustomFocusOrder  mock := SpMockFocusOrderPresenter new.  mock focusOrder     add: (mock presenterAt: #thirdPresenter);     add: (mock presenterAt: #firstPresenter);     add: (mock presenterAt: #secondPresenter).  mock openWithSpec.  self takeKeyboardFocus: mock.  self assert: (mock presenterAt: #thirdPresenter) equals: self focusedPresenter.  self pressTab.  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenter.  self pressTab.  self assert: (mock presenterAt: #secondPresenter) equals: self focusedPresenter.  self pressTab.  self assert: (mock presenterAt: #thirdPresenter) equals: self focusedPresentertestRemovingIconsAfterAddingThem  #(pharo add book) do: [:arg1 |  self presenter addItemLabeled: arg1 do: [  ] icon: (self iconNamed: arg1) ].  self presenter selectItem: nil.  self presenter model removeAll.  #(pharo add book) do: [:arg1 |  self presenter addItemLabeled: arg1 do: [  ] icon: nil ].  self assert: self adapter selectedIndexes equals: #(1).  backendForTest assertIcon: self adapter displayedIcon equals: nilprogressBarMorph  ^SpIndeterminatedProgressBarMorphnewHSplitterAt: arg1  self widgetDo: [:arg2 |  arg2 newHSplitterAt: arg1 ]ownerChanged  super ownerChanged.  self expandRootselementAt: arg1  ^self listModel at: arg1presenterProvider  ^presenterProviderbottomFraction  ^bottomFractionunselectIndex: arg1  self selectIndexes: (self selectedIndexes copyWithout: arg1)strongSelectionChanged: arg1  self presenter activatesOnDoubleClick ifFalse: [ ^self ].  self presenter doubleClickAtPath: self selectedPathfootnoteArea: arg1  footnoteArea := arg1transmission  ^self selectedItemresetSelection  ^self dropList resetSelectionbeMultipleSelection  self selectionMode: (SpTreeMultipleSelectionMode on: self)sortByColumn: arg1 event: arg2 morph: arg3  arg1 sortDataSource: selfclick  self toggleStateallowToSelect: arg1  self deprecated: 'Should not use. Use #selectionMode: instead'.  allowToSelect := arg1.  arg1 ifFalse: [ self resetSelection ]whenSortingBlockChangedDo: arg1  self model whenSortingBlockChangedDo: arg1selectedItem  ^associationsWrapperToItem at: listPresenter selectedItem ifAbsent: [ nil ]vAlign  ^vAlignwhenSearchChangedDo: arg1  self property: #searchEnabled whenChangedDo: arg1application  ^self owner applicationinitializePresenter  self property: #extent whenChangedDo: [:arg1 |  self withAdapterDo: [:arg2 |  (arg2 respondsTo: #extent:) ifTrue: [ arg2 extent: arg1 ] ] ]color  ^Color r: redSlider value g: greenSlider value b: blueSlider value range: 255initializePrivateAnnouncements  self property: #titleHolder whenChangedDo: [ self updateTitle ]initializePresenters  listPresenter := self newList.  searchPresenter := self newTextInput.  searchPresenter     autoAccept: true;     placeholder: 'Filter'openModalWithSpec  ^self application openModal: self withSpecLayout: self retrieveDefaultSpecshortcutText  | tmp1 |  tmp1 := self shortcut.  tmp1 isString ifTrue: [ tmp1 := self defaultModifierShortcut ].  ^tmp1 ifNotNil: [ KMShortcutPrinter toString: tmp1 ] ifNil: [ nil ]when: arg1 do: arg2  self widgetDo: [:arg3 |  arg3 announcer when: arg1 do: arg2 ]selectedContact  ^table selection selectedItemwithinRangeIndex: arg1  | tmp1 |  tmp1 := arg1.  self model at: tmp1 ifAbsent: [ tmp1 := 0 ].  ^tmp1testIncreasedValueFrom  presenter     beInteger;     maximum: 100;     climbRate: 2.  self assert: (adapter increasedValueFrom: '85') equals: '87'.  self assert: (adapter increasedValueFrom: '99') equals: '100'.  self assert: (adapter increasedValueFrom: '100') equals: '100'.  presenter     beFloat;     climbRate: 2.5;     digits: 1.  self assert: (adapter increasedValueFrom: '85') equals: '87.5'.  self assert: (adapter increasedValueFrom: '99') equals: '100.0'initializeTestedInstance  presenter roots: #(10 20 30)whenTabSelected: arg1  tabSelectedActionHolder value: arg1selectedObject  ^self selectedElement valueindexOfItem: arg1  ^self model indexOf: arg1 ifAbsent: [ 0 ]pageAt: arg1  ^self pages at: arg1isContactSelected  ^table selection selectedItem notNilpageChanged: arg1  self model selectPage: arg1 page modelpassword: arg1  password := arg1testUnselectAllInWidgetRaisesEmptySelectionChangeEvent  | tmp1 |  self adapter selectPath: #(1).  presenter selection whenChangedDo: [:arg1 |  tmp1 := arg1 ].  self adapter selectPath: #().  self assertEmpty: tmp1leftOffset  ^leftOffsettestSmokeVerticalTest  self presenter beVerticalwhenPickedItemsChanged: arg1  pickedItemsHolder whenChangedDo: arg1testSelectIndexThenSelectOutsideRangeKeepsFirstIndex  presenter selectIndex: 1.  presenter selectIndex: 50.  self assert: (presenter selection includesIndex: 1)name: arg1  name := arg1accessorCode  ^'(self at: ' , self index asString , ')'selectedMethod  self selectedMessage ifNil: [ ^nil ].  ^self selectedMessage compiledMethodrightClickAtIndex: arg1  self clickItem: arg1.  self halt.  ^self menu: nil shifted: falsegetTabs  ^[ self model tabs collect: [:arg1 |  self buildTab: arg1 ] ]whenAcceptOnCRChanged: arg1  self deprecated: 'Use #whenAcceptOnCRChangedDo: instead.' transformWith: '`@receiver whenAcceptOnCRChanged: `@statements' -> '`@receiver whenAcceptOnCRChangedDo: `@statements'.  self whenAcceptOnCRChangedDo: arg1bottomOffset: arg1  layoutFrame bottomOffset: arg1selectedClassIndex  ^classesListPresenter selectedIndexnewTab  self deprecated: 'Use newNotebook instead' on: '2019-01-24' in: #Pharo8.  ^self instantiate: SpTabPresentershowOnlyDestination  ^showOnlyDestinationinitialExtent  ^nilcolumns  ^columnscreateDevelopmentVersion  self hasAnyBaseline ifFalse: [ UIManager default inform: 'Please, define a baseline first'.        ^self ].  ^self createVersionForBlessing: #developmentperformDefaultSearch: arg1 matching: arg2  | tmp1 |  tmp1 := (self searchValueOf: arg1) trimBoth asLowercase.  ^tmp1 beginsWith: arg2add: arg1 left: arg2  self add: arg1 top: nil bottom: nil left: arg2 right: nilremoveContact: arg1  | tmp1 |  tmp1 := self confirm: ('Are you sure you want to remove {1} contact' format: {arg1 name}) label: 'Remove the contact'.  tmp1 ifTrue: [ self contactBook removeContact: arg1 ]helpText  ^nodeModel helpselectItems: arg1  self selection selectItems: arg1initialize  super initialize.  closeOnBackdropClick := truetestContent  presenter content: SpListPresenter.  self assert: presenter subwidget class equals: SpListPresentertestPresentersBlockReceivesAthensCanvas  | tmp1 |  self presenter drawBlock: [:arg1 |  tmp1 := arg1 ].  self adapter redraw.  self openInstance.  1 second wait.  self assert: tmp1 isNotNil.  self assert: (tmp1 isKindOf: AthensCanvas)step  self presenter stepincomingTransmission: arg1 from: arg2  self destinationPresenter label: arg1testBePasswordIsSet  presenter bePassword.  self assert: presenter isPasswordpresentersDo: arg1  self basicPresenters valuesDo: arg1value  ^valueopenInstance: arg1  window := presenter openWithSpec: arg1isSplitter  ^falseprintOn: arg1  super printOn: arg1.  arg1 << '(' << self name << ')'explanation  ^explanationcentered  self withWindowDo: #centerednormalFillStyle  ^self theme splitterNormalFillStyleFor: selfcancelButton  ^windowPresenter addButton: 'Cancel' do: [:arg1 |  arg1 triggerCancelAction.        arg1 close ]buildWidget  | tmp1 |  tmp1 := (SpToolBarButtonMorph on: self model getState: nil action: #execute)     helpText: self model help;     beIconTop;     hResizing: #rigid;     vResizing: #spaceFill;     borderWidth: 0;     borderColor: Color transparent;     cellPositioning: #center;     yourself.  ^tmp1checkboxWithColor: arg1  checkboxWithColor := arg1contactBook  ^self contactBookPresenter contactBookwrappedObject  ^wrappeddisplayBlock: arg1  displayBlock := arg1unselectPath: arg1  selection = arg1 ifFalse: [ ^self ].  self clearSelectiontestSortingBlock  | tmp1 |  tmp1 := 0.  presenter whenSortingBlockChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter items: #(3 8 1 0).  presenter sortingBlock: [:arg2 :arg3 |  arg2 model < arg3 model ].  self assert: tmp1 equals: 1.  self assert: (presenter model at: 1) model equals: 0updateTitle  self window title: self titletestSelectPresenterIndexSetsSelectedIndexInWidget  presenter selectIndex: 1.  self assert: (self adapter selectedIndexes includes: 1)beVerticalAlignmentEnd  self vAlign: SpGridAlignment endtestAddingColumnUpdatesWidget  self presenter addColumn: (SpStringTableColumn title: 'Value' evaluated: #printString).  self assert: self adapter columnCount equals: 3removePostscript  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  self model removePostscriptFrom: self selectedChangeSet.  changesListPresenter setSelectedItem: self selectedChangeSetsubwidget: arg1  subwidget := arg1setSelectedIndex: arg1  listPresenter setSelectedIndex: arg1testContextMenu  | tmp1 tmp2 |  self assert: presenter contextMenu isNil.  tmp1 := SpMenuPresenter new.  tmp2 := false.  presenter whenMenuChangedDo: [ tmp2 := true ].  presenter contextMenu: tmp1.  self assert: presenter contextMenu equals: tmp1.  self assert: tmp2getLabelSelector: arg1  getLabelSelector := arg1.  self update: getLabelSelectorx  ^xbeCancel  cancelled := truetext: arg1  | tmp1 |  tmp1 := self maxLength = 0 ifTrue: [ arg1 ] ifFalse: [ arg1 first: (self maxLength min: arg1 size) ].  super text: tmp1installIconStylerFor: arg1  ((self isMethodDefinition: arg1) or: [ isShowingDiff not ]) ifFalse: [ ^self ].  IconStyler styleText: sourcePresenter withAst: arg1 astdynamicPresenter: arg1  dynamicPresenter := arg1countNumberOfProportionals  self commands do: [:arg1 |  arg1 layoutFrame hasNoOffsets ifTrue: [ (arg1 layoutFrame topFraction == 0 and: [ arg1 layoutFrame bottomFraction == 1 ]) ifFalse: [ autoFractionComputation := false ].              numberOfProportionals := numberOfProportionals + 1 ] ]rootMenu  ^self owner rootMenunewPanelMorph  ^PanelMorph new     changeTableLayout;     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #spaceFill;     cellInset: self class defaultItemSeparation @ 0;     extent: 0 @ 0;     color: self color;     yourselfwhenMenuChangedDo: arg1  menuBlockHolder whenChangedDo: arg1refreshList  self sortingBlock ifNotNil: [:arg1 |  collection sort: arg1 ]execute  self flag: 'Suspicious: is there not an more obvious/clean way of doing that?'.  self context adapter widget cancelinitialExtent  ^self model ifNil: [ super initialExtent ] ifNotNil: [:arg1 |  arg1 initialExtent ifNil: [ super initialExtent ] ]isDialog  ^falsenewLink  ^self instantiate: SpLinkPresenterstate  ^stateselectIndex: arg1  self presenter selection selectIndex: arg1morphHolder  ^morphHolderupdateAccordingTo: arg1  (arg1 keepTreeNode: self) ifFalse: [ self changed: #updateAccordingTo: with: {arg1} ]configButton  ^configButtoninitializeTestedInstance  super initializeTestedInstance.  presenter items: #(10 20 30)columnsCount: arg1  (arg1 isInteger and: [ arg1 > 0 ]) ifFalse: [ self error: 'A positive integer is expected as parameter.' ].  columnsCount := arg1testRightClickShowsMenu  | tmp1 |  presenter contextMenu: (tmp1 := SpMockMenuPresenter new).  self deny: tmp1 shown.  self emulateRightClick.  self assert: tmp1 shownbrowseClass: arg1  arg1 browsetestAbsoluteValueToValueScales  self initMinMax.  self assert: (presenter absoluteValueToValue: 0.5) equals: 50messages: arg1  self cacheHierarchyForClasses: arg1.  listModel items: cachedHierarchy keys asOrderedCollection.  listModel listSize > 0 ifTrue: [ listModel selectIndex: 1 ]contents: arg1  contents := arg1mouseDownAction  ^mouseDownAction valueconnectPresenters  listModel whenSelectionChangedDo: [:arg1 |  arg1 isEmpty ifTrue: [ textModel text: ''.              textModel behavior: nil.              toolbarModel method: nil ] ifFalse: [ | tmp1 |              tmp1 := arg1 selectedItem.              textModel text: tmp1 sourceCode.              textModel behavior: tmp1 methodClass.              toolbarModel method: tmp1 ] ].  self acceptBlock: [:arg2 |  self listModel selectedItem inspect ].  self wrapWith: [:arg3 |  arg3 methodClass name , '>>#' , arg3 selector ]addRadioButton: arg1  self linkRadioButton: arg1.  buttons add: arg1.  arg1     privateSetState: false;     owner: self.  self focusOrder add: arg1.  self rebuildWidgetvisitImageColumn: arg1  self addCellColumn: arg1clearUndoManager  self withAdapterDo: #clearUndoManageronAcceptEdition: arg1  acceptAction := arg1getSelectionStateFor: arg1  self deprecated: 'This method from the old API will be removed.'.  ^self model getSelectionStateFor: arg1initializePresenters  dropList := self instantiate: SpDropListPresenter.  button := self instantiate: SpButtonPresenter.  self focusOrder     add: dropList;     add: buttontestSelectingOutOfRangeKeepOldSelection  self presenter selection selectPath: #(2 3).  self presenter selection selectPath: #(7 3).  self assert: self adapter selectedItem equals: 20findClassFromSelection  ^self findClassFrom: self selectionOrLine trimmedsplitterNewSelector  ^layout isHorizontal ifTrue: [ #newHorizontal ] ifFalse: [ #newVertical ]whenReadSelectionIsChanged: arg1  self deprecated: 'Use #whenReadSelectionIsChangedDo: instead.' transformWith: '`@receiver whenReadSelectionIsChanged: `@statements' -> '`@receiver whenReadSelectionIsChangedDo: `@statements'.  self whenReadSelectionIsChangedDo: arg1revert: arg1  arg1 ifNil: [ ^self inform: 'nothing selected, so nothing done' ] ifNotNil: [ rgMethod realClass compile: arg1 sourceCode classified: arg1 category withStamp: arg1 stamp notifying: nil ].  self setRGMethodFrom: rgMethod realClass >> rgMethod selector.  messageList     messages: self buildChangeList;     selectIndex: 1newDynamicPresentersListIn: arg1 usingBuilder: arg2  | tmp1 tmp2 |  tmp1 := (arg1 , ':') asSymbol.  (self perform: arg1) ifNotNil: [:arg3 |  arg3 owner: nil ].  tmp2 := arg2 build.  self perform: tmp1 with: tmp2.  tmp2 owner: self.  self needRebuild: false.  self buildWithSpeccontents  ^morphHolder valuewithoutScrollBars  wrapScrollBars := falsepage  ^pagecontextMenu: arg1  contextMenu := arg1currentActivated: arg1  currentActivated value: arg1initialize  super initialize.  token := ''notifyPropertyChanged: arg1  self flag: #todo.  (self observablePropertyNamed: arg1) valueChangedtestGenerateUniqueInstanceVariableName  1 to: 10 do: [:arg1 |  self assert: builder generateUniqueInstanceVariableName equals: (#var , arg1 asString) asSymbol ]rightClicked  | tmp1 |  tmp1 := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent yellowButton buttons: MouseButtonEvent yellowButton hand: nil stamp: nil.  self widget click: tmp1setWidgetLayoutWithNoOffset: arg1 at: arg2 delta: arg3  arg1 layoutFrame: ((currentProportional @ 0 corner: (currentProportional + arg3) @ 1) asSpLayoutFrame leftOffset: currentOffset).  currentOffset := 0.  currentProportional := currentProportional + arg3.  lastFractionIndex := arg2isSelected: arg1  iconHolder  self deprecated: 'Use iconBlock instead' transformWith: '`@receiver iconHolder' -> '`@receiver iconBlock'.  ^self iconBlockconfigureButton: arg1 item: arg2  arg1 getLabelSelector: #label.  arg1 badgeSelector: #badgeitemsInput: arg1  itemsInput := arg1headerAction  ^self model headerActionsetHasUnacceptedEdits: arg1  self widgetDo: [:arg2 |  arg2 basicHasUnacceptedEdits: arg1 ]isResizeable: arg1  ^self widgetDo: [:arg2 |  arg2 isResizeable: arg1 ]adapterName  ^#MillerAdapterregisterEventsForStyling  self whenBehaviorChangedDo: [:arg1 |  self changed: #classOrMetaClass: with: {arg1}.        self changed: #getText ]add: arg1 withConstraints: arg2  | tmp1 |  children size = 2 ifTrue: [ self error: 'You can not add more than two paned presenters.' ].  tmp1 := self constraintsClass new.  arg2 value: tmp1.  children at: arg1 put: tmp1includesItem: arg1  ^self selectedItem = arg1updateListSelectionIndex  currentIcon ifNotNil: [ self removeMorph: currentIcon ].  super updateListSelectionIndex.  self selectedItem ifNotNil: [:arg1 |  (self getIconFor: arg1) ifNotNil: [:arg2 |  currentIcon := arg2 asMorph.              self addMorphFront: currentIcon ] ]pageClass  ^SpDemoListsPresenternewRichText  ^self instantiate: SpRichTextPresenteraccessorCode  ^self labeladd: arg1  (items at: #start ifAbsentPut: [ OrderedCollection new ]) add: arg1menu  ^menumouseClick: arg1 onBackdrop: arg2  self closeOnBackdropClick ifFalse: [ ^self ].  self model triggerCancelAction.  self model close.  arg2 deletetestUnselectSelectedItemRaisesSingleEvent  | tmp1 |  tmp1 := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectItem: 10.  self assert: tmp1 equals: 1rightClicked  | tmp1 |  tmp1 := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent yellowButton buttons: MouseButtonEvent yellowButton hand: nil stamp: nil.  self widget click: tmp1initializePresenter  super initializePresenter.  description whenTextIsAcceptedDo: [:arg1 |  self saveElement: arg1.        self refreshDescription ]testSelectItemsOutsideRangeHasNoSelectedItems  presenter selectItems: {3000 .         4000}.  self assert: presenter selection selectedItems isEmptyuseInspectorAt: arg1  | tmp1 |  tmp1 := self inspectorTypes.  self inspectorType: (tmp1 at: (arg1 min: tmp1 size max: 1))kmTable: arg1  kmTable := arg1buildWidgetPopup  ^self buildWidgetvalue  self action cull: self label cull: selfdefaultButtonId: arg1  defaultButtonId := arg1whenDisplayBlockChangedDo: arg1  self property: #display whenChangedDo: arg1newContentMorph  ^PanelMorph new     roundedCorners: #(2 3 4);     changeTableLayout;     layoutInset: 4;     cellInset: 8;     vResizing: #spaceFill;     hResizing: #spaceFill;     borderStyle: (self theme tabPanelBorderStyleFor: self);     yourselfmenu: arg1 shifted: arg2  (arg1 add: 'Refresh' target: self selector: #collectAllShortcuts) icon: (self iconNamed: #smallUpdateIcon).  self kmTable selection selectedItem ifNil: [ ^arg1 ].  (arg1 add: 'Browse Definition' target: self selector: #browseDefinitionOfSelectedShortcut) icon: (self iconNamed: #smallSystemBrowserIcon).  (arg1 add: 'Inspect Action' target: self selector: #inspectActionOfSelectedShortcut) icon: (self iconNamed: #smallInspectItIcon).  ^arg1initialize  super initialize.  dragHand := ActiveHandaction  self presenter menu ifNotNil: [:arg1 |  arg1 value ifNotNil: [:arg2 |  arg2 owner: self presenter.              self showSubMenu: arg2 ] ].  self widget ifNotNil: [:arg3 |  arg3 takeKeyboardFocus ]checkboxWithLabelOnLeft  ^checkboxWithLabelOnLeftstyle  ^self styleExtent: 50 @ 20beResizable  self isResizable: truetestContextMenu  | tmp1 tmp2 |  self assert: presenter contextMenu isNotNil.  tmp1 := SpMenuPresenter new.  tmp2 := false.  presenter whenMenuChangedDo: [ tmp2 := true ].  presenter contextMenu: tmp1.  self assert: presenter contextMenu equals: tmp1.  self assert: tmp2borderWidth  ^borderWidthselectedItem  ^self subclassResponsibilitybindKeyCombination: arg1 toAction: arg2  testChangingRootsUpdateWidget  self presenter roots: #(10 11 12).  backendForTest assertList: self adapter displayItems: #('10' '11' '12')searchValueOf: arg1  ^arg1 asStringshortcutKey  ^self class defaultShortcutKeychildren: arg1  childrenBlock := arg1pressShiftTab  self keyPressed: Character tab asciiValue shift: true meta: false control: false option: false.  self waitUntilUIRedrawedtestChangeInInstanceVariableRaisesEventOnlyOnce  | tmp1 |  tmp1 := 0.  point property: #x whenChangedDo: [ tmp1 := tmp1 + 1 ].  point x: 17.  self assert: tmp1 equals: 1item  ^self dataSource elementAt: self rowIndextestColumnSpacing  | tmp1 |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1.  self place: label2 at: 1 @ 2.  self place: morph2 at: 2 @ 2.  (tmp1 := self newLayout) layout columnSpacing: 5.  tmp1 layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 50 @ 20).  self assert: morph1 bounds equals: (55 @ 0 corner: 105 @ 20).  self assert: label2 bounds equals: (0 @ 20 corner: 50 @ 40).  self assert: morph2 bounds equals: (55 @ 20 corner: 105 @ 40)icons  ^icontestWhenIconsChangedDo  | tmp1 tmp2 |  tmp2 := 0.  presenter whenIconsChangedDo: [:arg1 |  tmp1 := arg1 cull: #add.        tmp2 := tmp2 + 1 ].  presenter icons: [:arg2 |  Smalltalk ui icons iconNamed: arg2 asSymbol ].  self assert: tmp1 equals: (Smalltalk ui icons iconNamed: #add).  self assert: tmp2 equals: 1basicAdd: arg1 constraints: arg2 to: arg3  | tmp1 |  tmp1 := self buildMorph: arg1 constraints: arg2.  arg3 addMorphBack: tmp1.  self addSplitterIn: arg3 for: tmp1.  ^tmp1button1  ^button1testSetSelectIndexOutsideRangeRaisesSelectionChangeEventWithUnsetIndex  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedIndex ].  presenter selectIndex: 4.  self assert: tmp1 equals: 0initialize  self class initializeSlots: self.  super initialize.  shown := falsemainMessage  ^mainMessagegenderLabel  ^genderLabelstyles: arg1  styles := arg1 asArrayhasScrollBars  ^wrapScrollBarscloseOnBackdropClick  ^self model closeOnBackdropClickentryCompletion  ^self model entryCompletionmenusRegistration  self menusRegistrationFrom: changeSorterLeft to: changeSorterRight.  self menusRegistrationFrom: changeSorterRight to: changeSorterLeftbuildWidget  ^SpWindow new     model: model;     isResizeable: self isResizeable;     in: [:arg1 |  self subscribeToAnnouncements: arg1 ];     yourselftestNullPresentersNeededFor  self assert: (layout nullPresentersNeededFor: presentersBuilder) equals: 0action  ^actionselectedItems  ^self list selectedItemsisNonEditableRow: arg1 column: arg2  ^truedisplayBlock: arg1  self deprecated: 'Please use #display: instead' transformWith: '`@receiver displayBlock: `@arg' -> '`@receiver display: `@arg'.  display := arg1shortcutsRegistration  self shortcutsRegistrationFrom: changeSorterLeft to: changeSorterRight.  self shortcutsRegistrationFrom: changeSorterRight to: changeSorterLeftbuildWidget  | tmp1 |  tmp1 := CheckboxMorph on: self selected: #state changeSelected: #state:.  tmp1     label: self label;     beCheckbox;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     setBalloonText: self help;     getEnabledSelector: #enabled;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     labelClickable: self labelClickable.  self presenter whenLabelChangedDo: [:arg1 |  tmp1 label: arg1 ].  self presenter whenChangedDo: [ tmp1 updateSelection ].  ^tmp1subwidgetArguments  ^subwidget asArraywindows  ^windows ifNil: [ windows := Set new ]isRendered  ^actualPageMorph notNilpropertyAt: arg1 ifPresent: arg2  ^self properties at: arg1 ifPresent: arg2selectedIndex  ^self presenter selection selectedIndexselectionHolder  ^self subclassResponsibilitybuttonWithDifferentFont: arg1  buttonWithDifferentFont := arg1visitCommand: arg1  arg1 positionStrategy addButton: (SpToolBarButton new           label: arg1 name;           help: arg1 description;           icon: arg1 icon;           action: [ arg1 execute ];           yourself) toToolbar: self toolbarPresenterselectionInterval: arg1  selection := arg1traverseInFocusOrderDo: arg1 excluding: arg2  self presentersInFocusOrder do: [:arg3 |  arg3 traverseInFocusOrderDo: arg1 excluding: arg2 ]model  ^modeldoItReceiver  ^self model doItReceiverfirstVisibleRowIndex  ^firstVisibleRowIndexstrongSelectionChanged: arg1  self presenter activatesOnDoubleClick ifFalse: [ ^self ].  self presenter doubleClickAtIndex: arg1 selectedIndexleftItems  ^leftItemsclassListAction  classList transmitTo: methodList transform: [:arg1 |  arg1 ifNotNil: [ self methodsFromClass: arg1 ] ifNil: [ #() ] ] postTransmission: [:arg2 |  arg2 selectIndex: 1 ].  classList transmitTo: protocolList transform: [:arg1 |  arg1 ifNotNil: [ self isInstanceSideSelected ifTrue: [ arg1 organization allProtocols as: OrderedCollection ] ifFalse: [ arg1 class organization allProtocols as: OrderedCollection ] ] ifNil: [ #() ] ] postTransmission: [:arg3 |  protocolList selectIndex: ((arg3 items collect: #name) indexOf: '-- all --') ]source: arg1  source := arg1 valuesetModal: arg1  self deprecated: 'Do not use this directly. Use #openModalWithSpec (and family) instead.' on: '2019-02-26' in: #Pharo8.  self changed: #setModal: with: {arg1}testAddTabUnopened  self assertCollection: presenter tabs hasSameElements: #().  presenter addTab: redTab.  self assertCollection: presenter tabs hasSameElements: {redTab}execute  Smalltalk tools transcript open.  self contactBook contents do: [:arg1 |  self traceCr: arg1 name , ' - ' , arg1 name ]extent: arg1  extent := arg1ensureKeyBindingsFor: arg1  super ensureKeyBindingsFor: arg1.  self registerChangeSetShortcuts: changesListPresenter.  self registerClassShortcuts: classesListPresenter.  self registerMethodShortcuts: methodsListPresentertestSetSelectPathRaisesSelectionChangeEventWithSelectedItem  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedItems ].  presenter selectPath: #(1 3).  self assert: (tmp1 includes: 10)testSubscribeToExistentNonObservablePropertyRaisesError  self should: [ point property: #y whenChangedDo: [ self fail: 'This event shouldnt have been subscribed at all' ] ] raise: SpNonObservableSlotErrortestJulianDaysIntervalFor3  | tmp1 |  tmp1 := calendar julianDaysIntervalFor: (Date year: 2018 month: 9 day: 1).  self     assert: tmp1 size equals: calendar daysToDisplayCount;     assert: tmp1 equals: ((Date year: 2018 month: 8 day: 26) julianDayNumber to: (Date year: 2018 month: 10 day: 6) julianDayNumber)entitiesEntryCompletion  ^EntryCompletion new     dataSourceBlock: [:arg1 |  self possibleEntities collect: [:arg2 |  arg2 perform: self displaySymbol ] ];     chooseBlock: [:arg3 |  self entity: (self possibleEntities detect: [:arg2 |  (arg2 perform: self displaySymbol) = arg3 ]) ];     filterBlock: [:arg4 :arg1 |  arg4 asUppercase includesSubstring: arg1 asString asUppercase ]testVisitCommandThatCantBeRunWithDisableStrategy  self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.  (CmBlockCommand new     name: 'c';     description: 'desc';     context: [ 41 ];     canBeExecutedBlock: [:arg1 |  arg1 = 42 ];     block: [:arg1 |  42 ];     yourself) asSpecCommand acceptVisitor: menuBuilder.  self assert: menuBuilder menuPresenter defaultGroup menuItems size equals: 1radio3  ^radio3testSelectIndexOutsideRangeUnsetsSelectedIndex  presenter selectIndex: 4.  self assert: (presenter selection includesIndex: 0)topOffset: arg1  topOffset := arg1basicSelectIndex: arg1  self subclassResponsibilityadd: arg1 expand: arg2  ^self add: arg1 withConstraints: [:arg3 |  arg3 expand: arg2 ]focusOrder: arg1  ^focusOrder := arg1columns: arg1  tree columns: arg1beHorizontal  direction := SpLayoutDirection horizontalimplementorsModel  ^implementorsModelsetModelBeforeInitialization: arg1  super setModelBeforeInitialization: arg1.  contactBook := arg1whenSelectionChangedDo: arg1  self selection whenChangedDo: [ arg1 cull: selectionMode ]value  ^self host classcolumns: arg1  columns value: arg1buildWidget  ^SpStubImageView newadd: arg1 at: arg2  ^self add: arg1 at: arg2 span: 1 @ 1title  ^self class title , ' [' , messageList numberOfElements printString , ']'hasChildrenBlock  ^self model hasChildrenicon: arg1  icon := arg1helpText  ^self widget helpTextclassToTest  ^SpListPresenterupdateTree  self treeModel resetRootNodes.  self treeModel changed: #rootNodesmodel: arg1  model := arg1nullPresentersInstVarNamesAndPresenterNamesArray  ^(self nullPresentersInstVarNames inject: OrderedCollection new into: [:arg1 :arg2 |  arg1           add: arg2;           add: SpNullPresenter name;           yourself ]) asArraytraversePresentersDo: arg1 excluding: arg2  (arg2 includes: self) ifTrue: [ ^self ].  arg2 add: self.  arg1 value: self.  self class allSlots do: [:arg3 |  | tmp1 |        tmp1 := self readSlot: arg3.        (tmp1 isKindOf: SpAbstractPresenter) ifTrue: [ tmp1 traversePresentersDo: arg1 excluding: arg2 ] ]isFirstColumn: arg1  ^(table columns indexOf: arg1) = 1initializePresenters  kmTable := self newTable.  kmTable     addColumn: (SpStringTableColumn title: 'Shortcut' evaluated: [:arg1 |  arg1 realValue shortcut asString ]);     addColumn: (SpStringTableColumn title: 'Name' evaluated: #shortcutName);     addColumn: (SpStringTableColumn title: 'Category' evaluated: #categoryName);     beResizable;     menu: [:arg2 :arg3 |  self menu: arg2 shifted: arg3 ].  filterField := self newTextInput.  filterField     removeEntryCompletion;     placeholder: 'Filter';     autoAccept: true.  clearFilterButton := self newButton.  clearFilterButton     icon: (self iconNamed: #smallCancelIcon);     enabled: false.  self collectAllShortcutstestSetRootModelResetsToSinglePresenter  self presenter presenterBlock: [:arg1 |  SpNullMillerPresenter on: (SpLabelPresenter new label: arg1 asString) ].  3 timesRepeat: [ self presenter addPresenter: (SpNullMillerPresenter on: SpLabelPresenter new) ].  self presenter setRootModel: 1.  self assert: self presenter size equals: 1initialize  super initialize.  items := OrderedCollection new asValueHolder.  self property: #autoRefresh whenChangedDo: [:arg1 |  self menuItems do: [:arg2 |  arg2 autoRefresh: arg1 ] ]leftLabel: arg1  leftLabel := arg1objectAsHexString  ^String streamContents: [:arg1 |  self object do: [:arg2 |  arg1 << (arg2 printPaddedWith: $0 to: 2 base: 16) ] ] limitedTo: 5000initializeTestedInstance  observablePropertyNamed: arg1  | tmp1 |  tmp1 := self class slotNamed: arg1.  tmp1 isObservableSlot ifFalse: [ SpNonObservableSlotError signal: arg1 ].  ^tmp1 rawRead: selfshortcutCharacter  ^nilinitialize  super initialize.  self beResizable.  self beShrinkableclassToTest  ^SpLabelledTextInputencrypted: arg1  self deprecated: 'Use #bePassword: instead' transformWith: '`@receiver encrypted: `@arg' -> '`@receiver bePassword: `@arg'.  self bePassword: arg1defineInputPorts  ^{SpListItemsPort new}performSearch: arg1 matching: arg2  ^searchBlock value: arg1 value: arg2prepareAsSortableColumn: arg1  menu: arg1  self deprecated: 'Use #contextMenu: instead. The old way to create a MenuPresenter was this method taking a MenuMorph as parameter. This will not work with other backend and will be totally removed in Pharo7. Now you should use #contextMenu takin a MenuPresenter (or a block returning a menu presenter) as parameter.' on: '2019-03-07' in: #Pharo8.  self contextMenu: [ arg1 cull: (MenuMorph new                 defaultTarget: self;                 yourself) cull: false ]diveInto: arg1  self owner ifNotNil: [:arg2 |  (arg2 respondsTo: #diveInto:) ifTrue: [ ^arg2 diveInto: arg1 ] ].  self inspectInNewWindow: arg1backgroundColorBlock: arg1  self deprecated: 'Should not use. This feature is not supported anymore. This feature depends on the theme'hasImageAutoscaled  ^self widget layout = #scaledAspecttestHasProperty  self     assert: (themeDecorator hasProperty: #buttonNormalFillStyleFor:);     assert: (themeDecorator hasProperty: #buttonMouseOverFillStyleFor:);     assert: (themeDecorator hasProperty: #buttonPressedFillStyleFor:);     deny: (themeDecorator hasProperty: #controlButtonSelectedDisabledFillStyleFor:);     deny: (themeDecorator hasProperty: #scrollbarMouseOverBorderStyleFor:);     deny: (themeDecorator hasProperty: #scrollbarThumbCornerStyleIn:)acquireWidth: arg1  ^self widthOrUndefined min: arg1denyHasHeader: arg1  | tmp1 |  self waitUntilUIRedrawed.  tmp1 := arg1 widget submorphs first.  self assert: tmp1 submorphs size = 3takeKeyboardFocus  self presenter presentersInFocusOrder ifNotEmpty: [:arg1 |  arg1 first takeKeyboardFocus ]updateMenu  objectAtProperty: arg1  ^themeOverrideDict at: arg1parseSimpleValue  | tmp1 |  readStream atEnd ifFalse: [ tmp1 := readStream peek.        (self isStyleClassChar: tmp1) ifTrue: [ ^self parseStyleClass ] ].  ^super parseSimpleValuetestNewPresenterIsNotBuilt  self deny: presenter isBuiltrestoreButton: arg1  restoreButton := arg1buildWidget  currentMorph := self presenter morph ifNil: [ Morph new color: Color transparent ].  self presenter whenMorphChangedDo: [:arg1 |  self applyStyle: arg1.        currentMorph owner ifNotNil: [:arg2 |  arg2 replaceSubmorph: currentMorph by: arg1 ] ].  ^currentMorphselected: arg1  self nodeModel selected: arg1whenMenuChanged: arg1  self deprecated: 'Use #whenMenuChangedDo: instead.' transformWith: '`@receiver whenMenuChanged: `@statements' -> '`@receiver whenMenuChangedDo: `@statements'.  self whenMenuChangedDo: arg1absoluteValue  ^self presenter absoluteValueaddConstraits: arg1 toChild: arg2  | tmp1 |  tmp1 := arg2.  tmp1 setProperty: #constraints toValue: arg1.  ^tmp1buildWidgetNoRefresh  ^ToggleMenuItemMorph new     contents: self name;     target: self;     selector: #performMenuActionWith:;     subMenu: self subMenu;     argumentsBlock: self actionArguments;     getStateSelector: self stateSelector;     icon: self icon;     enablementSelector: #enabled;     balloonText: self balloonText;     keyText: self shortcutText;     yourselfcolumnConstraintsAt: arg1  ^layout columnConstraintsAt: arg1window  ^windowdoubleClick: arg1  tree doubleClick: arg1buildWidget  ^SpTreeNodeModel new     setItemFromBlock: self itemBlock;     icon: self icon;     setChildren: self childrenBlock;     hasContents: self hasChildrenBlock;     model: self container;     nodeModel: self modelwhenLabelChangedDo: arg1  self property: #label whenChangedDo: arg1addButton: arg1 do: arg2  ^self addButton: (SpButtonPresenter new           owner: self;           label: arg1;           action: [ arg2 cull: self ];           yourself)presenterBlock: arg1  newPresenterBlock := arg1backgroundColorBlock  self deprecated: 'Should not use. This feature is not supported anymore. This feature depends on the theme'delete  self withAdapterDo: #deletewhenActivationActionChanged: arg1  self deprecated: 'Use #whenActivationActionChangedDo: instead.' transformWith: '`@receiver whenActivationActionChanged: `@statements' -> '`@receiver whenActivationActionChangedDo: `@statements'.  self whenActivationActionChangedDo: arg1transmission  ^self selectedItemevenRowColor: arg1  ^self widget rowColorForEven: arg1transferFor: arg1 from: arg2  ^(self model transferFor: arg1 from: self table) buildWithSpechShrinkWrap  self widgetDo: [:arg1 |  arg1 hResizing: #shrinkWrap ]sortedKeys  ^[ [ self object valuesAndCounts keys sorted ] on: Error do: [ self object valuesAndCounts keys ] ] on: Error do: [ #() ]matchTokenFilterBlock  ^matchTokenFilter valueselectedPageIndex  | tmp1 |  tmp1 := self selectedPage.  tmp1 ifNil: [ ^0 ].  ^self pages indexOf: tmp1defaultIconName  ^self class defaultIconNameimage2  ^image2actionBarPresenter  ^actionBarPresentertestHasShortcutKey  self deny: command hasShortcutKey.  command shortcutKey: $a asKeyCombination.  self assert: command hasShortcutKeyaddButton: arg1 text: arg2 value: arg3  ^self addButton: arg1 text: arg2 value: arg3 condition: truecolumns  ^columnsconfigureMorph: arg1 item: arg2  arg1 configureWith: self item: arg2presenterAt: arg1  ^self basicPresenters at: arg1isExecutable  ^truefilteringBlock: arg1  self deprecated: 'This feature is now removed from Spec 2. If the visible elements of the list need to be changed, it''s the users of the lists that should manage it and update the list of items of the list.'announceDisplayed  self announcer announce: (SpWidgetDisplayed new           presenter: self;           widget: (adapter ifNotNil: [ adapter widget ]);           yourself)whenSelectionChanged: arg1  listPresenter whenSelectionChanged: arg1refreshingBlock: arg1  refreshingBlock := arg1performDefaultSearch: arg1 matching: arg2  | tmp1 |  tmp1 := (self searchValueOf: arg1) trimBoth asLowercase.  ^tmp1 beginsWith: arg2items: arg1  list items: arg1classToTest  ^SpDynamicWidgetChangewhenSelectionChanged: arg1  self dropList whenSelectionChanged: arg1updatePageContent: arg1  self changed: #updatePageContent: with: {arg1}askOkToClose: arg1  askOkToClose := arg1testColumnNotHomogeneousPairedRowsAndColumns  | tmp1 |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1.  self place: label2 at: 1 @ 2.  self place: morph2 at: 2 @ 2.  tmp1 := self newLayout.  tmp1 layout beColumnNotHomogeneous.  (self styleExtent: 30 @ 20) applyTo: label1.  (self styleExtent: 50 @ 20) applyTo: morph1.  (self styleExtent: 40 @ 20) applyTo: label2.  (self styleExtent: 60 @ 20) applyTo: morph2.  tmp1 layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 40 @ 20).  self assert: morph1 bounds equals: (40 @ 0 corner: 100 @ 20).  self assert: label2 bounds equals: (0 @ 20 corner: 40 @ 40).  self assert: morph2 bounds equals: (40 @ 20 corner: 100 @ 40)initialize  super initialize.  model := ChangeSorterModel new.  isRefreshing := false.  SystemAnnouncer uniqueInstance weak when: CurrentChangeSetChanged send: #updateTitle to: selfaddLast: arg1 expand: arg2 fill: arg3 padding: arg4  self addLast: arg1 withConstraints: [:arg5 |  arg5           expand: arg2;           fill: arg3;           padding: arg4 ]setUp  super setUp.  self error: 'Do not override me.... use #initializeTestedInstance'performDefaultSearch: arg1 matching: arg2  | tmp1 |  tmp1 := (self searchValueOf: arg1) trimBoth asLowercase.  ^tmp1 beginsWith: arg2icon  ^widget label iconlayout  | tmp1 tmp2 |  tmp1 := SpBoxLayout newVertical.  contentArea ifNotNil: [ mainMessage ifNotNil: [ mainMessagePresenter := (mainMessage isString or: [ mainMessage isText ]) ifTrue: [ self newLabel label: mainMessage ] ifFalse: [ mainMessage ].              tmp1 add: #mainMessagePresenter ] ].  tmp2 := SpBoxLayout newHorizontal.  mainIcon ifNotNil: [ mainIconPresenter := self newImage image: self mainIcon.        tmp2 add: #mainIconPresenter withConstraints: [:arg1 |  arg1 width: self mainIcon width * 2 ] ].  contentArea ifNotNil: [ contentAreaPresenter := (contentArea isString or: [ contentArea isText ]) ifTrue: [ self newLabel label: contentArea ] ifFalse: [ contentArea ].        tmp2 add: #contentAreaPresenter ] ifNil: [ mainMessage ifNotNil: [ mainMessagePresenter := (mainMessage isString or: [ mainMessage isText ]) ifTrue: [ self newLabel label: mainMessage ] ifFalse: [ mainMessage ].              tmp2 add: #mainMessagePresenter ] ].  tmp1 add: tmp2.  tmp2 := SpBoxLayout newHorizontal.  moreOptionsArea ifNotNil: [ moreOptionsButton label: (moreOptionsVisible ifFalse: [ self moreOptionsText ] ifTrue: [ self lessOptionsText ]).        moreOptionsButton icon: (self iconNamed: (moreOptionsVisible ifFalse: [ #arrowDown ] ifTrue: [ #arrowUp ])).        tmp2 add: #moreOptionsButton.        moreOptionsAreaPresenter := (moreOptionsArea isString or: [ moreOptionsArea isText ]) ifTrue: [ self newLabel label: moreOptionsArea ] ifFalse: [ moreOptionsArea ] ].  buttons keysAndValuesDo: [:arg2 :arg3 |  tmp2 add: arg2 ].  tmp1 add: tmp2.  moreOptionsVisible ifTrue: [ tmp1 add: #moreOptionsAreaPresenter ].  footnoteArea ifNotNil: [ tmp2 := SpBoxLayout newHorizontal.        footnoteIcon ifNotNil: [ footnoteIconPresenter := self newImage image: footnoteIcon.              tmp2 add: #footnoteIconPresenter withConstraints: [:arg1 |  arg1 width: self footnoteIcon width * 2 ] ].        footnoteAreaPresenter := (footnoteArea isString or: [ footnoteArea isText ]) ifTrue: [ self newLabel label: footnoteArea ] ifFalse: [ footnoteArea ].        tmp2 add: #footnoteAreaPresenter ].  tmp1 add: tmp2.  defaultButtonId ifNotNil: [ (self buttonAt: defaultButtonId) takeKeyboardFocus ].  ^tmp1hasPortNamed: arg1  ^(self defineOutputPorts anySatisfy: [:arg2 |  arg2 name = arg1 ]) or: [ self defineInputPorts anySatisfy: [:arg2 |  arg2 name = arg1 ] ]initialize  super initialize.  activationBlock := [  ].  verticalAlignment := SpVerticalAlignment new.  self withScrollBars.  self model: self newEmptyModel.  self beSingleSelection.  self activateOnDoubleClick.  self registerEventsselectPageIndex: arg1  self selectPage: (self pages at: arg1)testAddButtonToActionBar  | tmp1 tmp2 |  tmp1 := SpActionBarPresenter new.  tmp2 := SpButtonPresenter new.  self assertEmpty: tmp1 items.  CmUIRightPositionStrategy new addButton: tmp2 toActionBar: tmp1.  self assert: tmp1 items size equals: 1.  self assert: (tmp1 items includesKey: #end).  self assert: (tmp1 items at: #end) size equals: 1.  self assert: (tmp1 items at: #end) anyOne equals: tmp2action  ^actionnewToggleButton  ^self instantiate: SpToggleButtonPresentertestOnDateChosen  | tmp1 |  tmp1 := ChoseDate new.  tmp1     calendar: StandardWindow new;     date: Date tomorrow.  presenter onDateChosen: tmp1.  self assert: presenter date equals: Date tomorrowautoAccept  ^self model autoAcceptblock: arg1  block := arg1vShrinkWrap  self widgetDo: [:arg1 |  arg1 vResizing: #shrinkWrap ]selectionChanged: arg1  | tmp1 |  self presenter selection isMultipleSelection ifTrue: [ self presenter selection selectIndexes: (arg1 newSelectedIndexes reject: [:arg2 |  arg2 = 0 ]) ].  self presenter selection isMultipleSelection ifFalse: [ self presenter selection selectIndex: (arg1 newSelectedIndexes ifNotEmpty: [:arg3 |  arg3 first ] ifEmpty: [ 0 ]) ].  tmp1 := arg1 newSelectedIndexes difference: arg1 oldSelectedIndexes.  (tmp1 notEmpty and: [ self presenter activatesOnSingleClick ]) ifTrue: [ self presenter doActivateAtIndex: tmp1 last ].  arg1 newSelectedIndexes ifNotEmpty: [ ^self ].  self presenter selection unselectAllokAction: arg1  okAction := arg1collectAllShortcuts  self kmTable items: self shortcutssetInvokingView: arg1  registerChangeSetShortcuts: arg1  arg1 bindKeyCombination: PharoShortcuts current browseShortcut toAction: [ self selectedChangeSet ifNotNil: [ self browseChangeSet ] ].  arg1 bindKeyCombination: $b meta shift toAction: [ self selectedChangeSet ifNotNil: [ self openChangeSetBrowser ] ].  arg1 bindKeyCombination: $m meta toAction: [ self selectedChangeSet ifNotNil: [ self setCurrentChangeSet ] ].  arg1 bindKeyCombination: $n meta toAction: [ self selectedChangeSet ifNotNil: [ self newSet ] ].  arg1 bindKeyCombination: $o meta toAction: [ self selectedChangeSet ifNotNil: [ self fileOut ] ].  arg1 bindKeyCombination: $r meta toAction: [ self selectedChangeSet ifNotNil: [ self rename ] ].  arg1 bindKeyCombination: $p meta toAction: [ self selectedChangeSet ifNotNil: [ self addPreamble ] ].  arg1 bindKeyCombination: PharoShortcuts current removeShortcut toAction: [ self selectedChangeSet ifNotNil: [ self remove ] ].  arg1 bindKeyCombination: $f meta toAction: [ self findChangeSet ]badgeFont  ^badgeFont ifNil: [ badgeFont := self newBadgeFont ]connectPresenters  changeSorterLeft whenChangesListChanges: [ self refeshedChangeSet: changeSorterRight ].  changeSorterRight whenChangesListChanges: [ self refeshedChangeSet: changeSorterLeft ]testUnselectSelectedItemRemovesSelection  presenter     selectItem: 10;     unselectItem: 10.  self assert: presenter selection isEmptyupdate: arg1  self changed: arg1isMenuPresenter  ^falseinitialize  super initialize.  newPresenterBlock := [:arg1 |  Error signal: 'should provide a new presenter block' ]testSelectIndexOutsideRangeIsEmpty  presenter selectIndex: 4.  self assert: presenter selection isEmptyverticalAlignment  ^verticalAlignmenthasWidget: arg1  ^self widget hasWidget: arg1 widgetupdateModelToMoment: arg1  updateBlock cull: arg1.  self adapter ifNotNil: [ self adapter updateModelToMoment: arg1 ]offsets  self flag: #fix.  ^layoutFrame leftOffset @ layoutFrame topOffset corner: layoutFrame rightOffset @ layoutFrame bottomOffsettestLayoutIn  (self class localSelectors reject: [:arg1 |  arg1 = #testLayoutIn ]) select: [:arg1 |  arg1 beginsWith: 'test' ] thenDo: [:arg1 |  self setUp.        self perform: arg1.        self tearDown ]updateModelToMoment: arg1  self widget changednumber2: arg1  number2 := arg1styleSheet: arg1  ^self propertyAt: #styleSheet put: arg1contextClass: arg1  self widgetDo: [:arg2 |  arg2           contextClass: arg1;           updateText ]contents: arg1  morphHolder value: arg1buildWidget  | tmp1 |  tmp1 := SpToolBarMorph new.  self addModelTo: tmp1.  ^tmp1horizontalAlignment  ^hAlignwhenTextStylerChangedDo: arg1  self property: #textStyler whenChangedDo: arg1testClearContent  self initializationText.  self denyEmpty: presenter text.  presenter clearContent.  self assertEmpty: presenter textdaysButtons: arg1  daysButtons := arg1lookupClass: arg1  ^classes at: arg1 ifAbsentPut: [ SpStyle allSubclasses , Color withAllSubclasses detect: [:arg2 |  arg2 isMeta not and: [ arg2 stonName = arg1 ] ] ifNone: [ NotFound signalFor: arg1 ] ]click  self isEnabled ifFalse: [ ^self ].  ^self performActionproperty: arg1 whenChangedDo: arg2  (self observablePropertyNamed: arg1) whenChangedDo: arg2beDecrypted  self deprecated: 'Use #beText instead' transformWith: '`@receiver beDecrypted' -> '`@receiver beText'.  self beTextwhenNumberChangedDo: arg1  self whenTextChangedDo: [:arg2 |  arg1 value: self number ]buildFor: arg1  arg1 createNullPresenters: (self nullPresentersNeededFor: arg1).  ^self buildLayoutFor: arg1addButton: arg1 text: arg2 value: arg3 condition: arg4  | tmp1 |  tmp1 := self newButton label: arg2.  tmp1 action: [ arg4 value ifTrue: [ self return: arg3 ] ].  buttons at: arg1 put: tmp1.  self presenterAt: arg1 put: tmp1setUp  super setUp.  presenter     roots: #(1 2 3);     children: [:arg1 |  arg1 < 100 ifTrue: [ (arg1 * 10 to: arg1 * 10 + 10) asArray ] ifFalse: [ #() ] ]autoAccept: arg1  ^self model autoAccept: arg1when: arg1 do: arg2  self subclassResponsibilitywhenSelectionIndexesChanged: arg1  self deprecated: 'Use #whenSelectionChangedDo: instead' transformWith: '`@receiver whenSelectionIndexesChanged: `@argument' -> '`@receiver whenSelectionChangedDo: [ :selection | `@argument value: selection selectedIndexes ]'.  self whenSelectionChangedDo: [:arg2 |  arg1 value: arg2 selectedIndexes ]testChangingIconAffectTheWidget  presenter iconName: #pharo.  self assertIcon: self adapter icon equals: (self iconNamed: #pharo)selection  ^selectionwhenSelectedIndexChangedDo: arg1  self deprecated: 'Use #selection whenChangedDo: instead' transformWith: '`@receiver whenSelectedIndexChangedDo: `@argument' -> '`@receiver selection whenChangedDo: [ :selection | `@argument value: selection selectedIndex ]'.  ^self selection whenChangedDo: [:arg2 |  arg1 value: arg2 selectedIndex ]initializeTSearchable  self searchMatching: [:arg1 :arg2 |  self performDefaultSearch: arg1 matching: arg2 ]isMultipleSelection  ^falsestyleClass  ^SpStyleClassaddStyle: arg1  styles := styles copyWith: arg1isForSmalltalkCode: arg1  testUnselectNonSelectedPathDoesNotRemovesSelection  presenter     selectPath: #(1 1);     unselectPath: #(1 3).  self assert: presenter selection selectedPath equals: #(1 1)addColumn: arg1  columns := columns copyWith: arg1whenSelectedItemChanged: arg1  self deprecated: 'Use #whenSelectedItemChangedDo: instead.' transformWith: '`@receiver whenSelectedItemChanged: `@statements' -> '`@receiver whenSelectedItemChangedDo: `@statements'.  self whenSelectedItemChangedDo: arg1adapter  ^adaptercreateNewSet  ^ChangeSet newChangeSetelements  ^#()interpretASpec: arg1  arg1 ifNil: [ ^nil ].  (self extractArrayToInterpretFrom: arg1) ifNotNil: [:arg2 |  ^arg2 ].  (self retrieveSpecFrom: arg1) ifNotNil: [:arg3 |  ^arg3 ].  index := 2.  [ index <= arrayToInterpret size ] whileTrue: [ | tmp1 |        tmp1 := self performNextSelectorAndIncrementIndex.        index > arrayToInterpret size ifTrue: [ ^self returnInterpretationOf: tmp1 ].        spec := tmp1 ].  self assert: arrayToInterpret size < 2.  self presenter spec: spec.  ^specselectItems: arg1  self subclassResponsibilityvalueChanged: arg1  subscriptions do: [:arg2 |  arg2 cull: self value cull: arg1 ]basicPresenters  ^presenters ifNil: [ presenters := OrderedDictionary new ]modelObjects  ^instVarToModelObject collect: #valuebeText  self displayMode: SpToolBarDisplayMode modeLabelhost: arg1  host := EyePointerWrapper wrap: arg1label  ^labelbeHorizontal  isHorizontal := truebuildWidget  | tmp1 |  self presenter isInitialStateSet ifFalse: [ self presenter property: #state rawValue: false.        self presenter associatedRadioButtons do: [:arg1 |  arg1 property: #state rawValue: false ] ].  tmp1 := CheckboxMorph new     on: self selected: #state changeSelected: #state:;     getEnabledSelector: #enabled;     label: self label;     labelClickable: self labelClickable;     beRadioButton;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     setBalloonText: self help;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     yourself.  self presenter whenLabelChangedDo: [:arg2 |  tmp1 label: arg2 ].  self presenter whenChangedDo: [ tmp1 updateSelection ].  ^tmp1newRow: arg1 origin: arg2 corner: arg3  self newRow: arg1 origin: arg2 corner: arg3 offsetOrigin: 0 @ 0 offsetCorner: 0 @ 0classToTest  ^self subclassResponsibilityopenOnInteger: arg1  ui := SpOpenOnIntExample new: arg1.  ui     extent: 100 @ 100;     openWithSpecaccessorCode  ^self descriptiontestSetSelectItemOutsideRangeRaisesSelectionChangeEventWithUnsetItem  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter selectItem: 4000.  self assert: tmp1 equals: nilwithScrollBars  wrapScrollBars := truedate  ^dateupdateTree  self changed: #updateTree with: {}.  treeUpdated value: nilinitializeDialogWindow: arg1  arg1 initialExtent: 400 @ 200initializePresenters  super initializePresenters.  self content: SpDropListButtonreferencesToInstanceVariable  ^self systemNavigation browseAllAccessesTo: self instVarName from: self hostClassgetIconFor: arg1  ^self model getIconFor: arg1hasEditingConflicts  ^self widget ifNil: [ false ] ifNotNil: [:arg1 |  arg1 hasEditingConflicts ]save: arg1  elements  ^self model itemstestChangeListInPresenterUpdatesWidget  self presenter items: #('1' '2' '3').  backendForTest assertList: self adapter displayItems: #('1' '2' '3')transmission  ^self selectedItemsactForSpec  self subclassResponsibilityemptyList  ^self dropList emptyListwhenActionChangedDo: arg1  self property: #action whenChangedDo: arg1testClickExecuteAction  | tmp1 |  tmp1 := false.  presenter action: [ tmp1 := true ].  self emulateLeftClick.  self assert: tmp1initialize  super initialize.  editable := falselabel: arg1  label label: ' - ' , arg1 , ' - 'browseConfiguration  self configurationClass browsetestVisibilityWithBlockThatReturnsFalse  presenter visibleIf: [ false ].  self deny: self adapter isVisiblefirstVisibleRowIndex: arg1  firstVisibleRowIndex := arg1addSpecialFields: arg1  arg1 add: (DynamicEyeElement host: self object label: 'ast' value: [ self object ast ]).  arg1 add: (DynamicEyeElement host: self object label: 'ir' description: [:arg2 |  | tmp1 |              tmp1 := arg2 longPrintString.              tmp1 copyFrom: 2 to: tmp1 size ] value: [ self object ir ]).  arg1 add: (DynamicEyeElement host: self object label: 'all bytecodes' value: [ self object symbolic ]).  arg1 add: (DynamicEyeElement host: self object label: 'header' value: [ self object headerDescription ]).  self object literals withIndexDo: [:arg3 :arg4 |  arg1 add: (DynamicEyeElement host: self object label: 'literal ' , arg4 asString value: arg3) ]hasUnacceptedEdits: arg1  hasUnacceptedEdits := arg1dataSource  ^dataSourcerightOffset: arg1  layoutFrame rightOffset: arg1classToTest  ^SpAthensAnimatedPresentertoPort: arg1  toPort := arg1addColumn: arg1  columns := self columns copyWith: arg1isExpanded  ^self nodeModel isExpandednumber1: arg1  number1 := arg1initialize  self class initializeSlots: self.  super initializemessage: arg1  message := arg1refreshWidgetSelection  emptyList  self dropList emptyListshortcutsRegistrationFrom: arg1 to: arg2  arg1 changesPresenterOn: $c meta do: [ self copyAllFrom: arg1 to: arg2 ].  arg1 changesPresenterOn: $- meta do: [ self subtractFrom: arg1 to: arg2 ]maxHeight  ^self lookupProperty: SpStyleGeometry valueOf: #maxHeightrightClicked  | tmp1 |  tmp1 := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent yellowButton buttons: MouseButtonEvent yellowButton hand: nil stamp: nil.  self widget click: tmp1initializeDefaultActions  self okAction: [ cancelled := false.        self close ].  self cancelAction: [ cancelled := true.        self close ]initialize  super initialize.  contents := OrderedCollection newicon: arg1  icon := arg1selection  self deprecated: '#selection was used to return an interval, and did not convey the correct meaning. Use #selectionInterval instead.' transformWith: '`@receiver selection' -> '`@receiver selectionInterval'.  ^self selectionIntervalspec: arg1  self flag: #TODO.  self adapter: arg1fieldNormal  ^fieldNormalicons  ^iconcurrentText  ^textPresenter getTexttoString: arg1  ^super toString: arg1 databuttonWithColor  ^buttonWithColorinitialize  super initialize.  isUpdating := falseclassToTest  ^SpDropListPresenterchangeToList  self instantiatePresenters: #(bottom #SpListPresenter).  button font: (LogicalFont familyName: 'Source Sans Pro' pointSize: 10).  bottom items: (1 to: 100) asOrderedCollectionevaluateSelectionAndDo: arg1  | tmp1 |  tmp1 := self selectionOrLine.  tmp1 ifEmpty: [ ^'' ].  ^self evaluate: tmp1 andDo: arg1contextKeyBindings  self flag: #TODO.  ^contextKeyBindingsquantum  ^self model quantumtestNextMonthButton  | tmp1 |  tmp1 := Date year: 2018 month: 9 day: 15.  calendar adaptToDate: tmp1.  self assert: calendar monthYearLabel label equals: tmp1 month asString.  calendar nextMonthButton performAction.  self assert: calendar monthYearLabel label equals: (tmp1 addMonths: 1) month asStringresizable: arg1  resizable value: arg1classToTest  ^SpApplicationWithToolbarinitialize  super initialize.  self     name: 'Remove';     description: 'Removes the selected contact from the contact book.'classToTest  ^SpTreeTablePresenterwindow  ^windowleftLabel: arg1  self widgetDo: [:arg2 |  arg2 leftLabel: arg1 rightLabel: self rightLabel ]kmCategory  ^kmCategorywhenSelectionIndexChanged: arg1  self deprecated: 'Use #whenSelectionIndexChangedDo: instead.' transformWith: '`@receiver whenSelectionIndexChanged: `@statements' -> '`@receiver whenSelectionIndexChangedDo: `@statements'.  self whenSelectionIndexChangedDo: arg1testSelectItemsAddsIndexesToSelectedIndexList  presenter selectItems: {10 .         20}.  self assert: (presenter selection includesIndexes: #(1 2))includesItem: arg1  ^self selectedItems includes: arg1selectedItem  self deprecated: 'Use the #selection object instead. This method assumes single selection' transformWith: '`@receiver selectedItem' -> '`@receiver selection selectedItem'.  ^self selection selectedItemnewPhone  | tmp1 |  tmp1 := self request: 'New phone for the contact' initialAnswer: self selectedContact phone title: 'Set new phone for contact'.  (tmp1 matchesRegex: '\d\d\d\s\d\d\d') ifFalse: [ SpInvalidUserInput signal: 'The phone number is not well formated. Should match "\d\d\d\s\d\d\d"' ].  ^tmp1initializePresenters  addMorph: arg1  paneMorphs add: arg1.  ^super addMorph: arg1afterSelectionInsertAndSelect: arg1  | tmp1 |  tmp1 := self context selection.  self context insert: arg1 at: tmp1 last + 1.  self context selection: (tmp1 last + 1 to: tmp1 last + arg1 size)newLabel  ^self instantiate: SpLabelPresenterfrom: arg1  source := arg1frame: arg1  layout := arg1 asSpLayoutFrametestClickingRadio3DeselectsRadio2  self openInstance.  self presenter radio3 adapter clicked.  self deny: self presenter radio2 stateiconFor: arg1 error: arg2  ^self iconNamed: #smallWarningIconowner  ^ownerminHeight  ^self minExtent ifNotNil: [:arg1 |  arg1 y ]cancelled  ^cancelledisCheckList: arg1  self widgetDo: [:arg2 |  arg2 isCheckList: arg1 ]testSelectMultiplePathsRaisesSelectionChangeEventMultipleTimes  | tmp1 |  tmp1 := 0.  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter selectPath: #(1).  presenter selectPath: #(1 3).  self assert: tmp1 equals: 2columnSpacing: arg1  columnSpacing := arg1add: arg1  arg1 owner: self.  items add: arg1testFocusRotationBackwards  mock := SpMockFocusOrderPresenter new     openWithSpec;     yourself.  self takeKeyboardFocus: mock.  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenter.  self pressShiftTab.  self assert: (mock presenterAt: #thirdPresenter) equals: self focusedPresenter.  self pressShiftTab.  self assert: (mock presenterAt: #secondPresenter) equals: self focusedPresenter.  self pressShiftTab.  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenterdoItContext: arg1  doItContext := arg1property: arg1 whenChangedDo: arg2  (self observablePropertyNamed: arg1) whenChangedDo: arg2layoutFrame  ^layoutFrameincludesIndex: arg1  self subclassResponsibilitytestPageAt  | tmp1 |  presenter addPage: self mockPage.  tmp1 := SpNotebookPage title: 'test' provider: [ SpButtonPresenter new ].  presenter addPage: tmp1.  self assert: (presenter pageAt: 2) equals: tmp1title  ^'Spec UI Framework Demo'addLazyPage: arg1 label: arg2 collapsable: arg3  | tmp1 tmp2 |  tmp1 := SpNotebookPageMorph new.  tmp1 lazyPageMorphCreation: arg1.  tmp2 := self buildLabelFrom: arg2 withAction: (arg3 ifTrue: [ self newCloseButtonFor: tmp1 ] ifFalse: [ nil ]).  tmp1 labelMorph: tmp2.  self addPage: tmp1 label: tmp2initializePresenters  addModelTo: arg1  arg1 displayMode: self presenter displayMode.  arg1 height: self presenter displayMode height.  arg1 setBalloonText: self presenter help.  self presenter whenItemsChangeDo: [ self updateItems: arg1 ].  self updateItems: arg1indexOfItem: arg1  ^self allShownItems indexOf: arg1takeHighlight  self changed: #takeHighlight with: #()internalGetText  | tmp1 |  tmp1 := (self priorVersionOfAMethod: method) ifNotNil: [:arg1 |  arg1 sourceCode ] ifNil: [ '' ].  ^Array with: tmp1 with: method sourceCodetestLabelLeft  self openInstance: #labelLeftunselectAll  options do: #beUnselectedadapterName  ^#ScrollableAdapterinputPorts  ^self defineInputPorts collect: [:arg1 |  arg1 presenter: self ]retrievePresenter  activePresenter := self presenterProvider value.  retrievedBlock ifNotNil: [ retrievedBlock cull: activePresenter ].  ^activePresenterdiveIntoSelectedObject  self selectedObjectDo: [:arg1 |  self diveInto: arg1 ]getSelection  self deprecated: 'Use #selection instead.' transformWith: '`@receiver getSelection' -> '`@receiver selection'.  ^self selectionhighlightedItem  ^highlightedItem valueinput  ^inputtestPresenterPlaceholderIsSetInWidget  presenter placeholder: 'something'.  self assert: self adapter placeHolderText equals: 'something'addAllInstVars: arg1  elements  ^{('name' -> self name) .   ('surname' -> self surname) .   ('number 1' -> self number1) .   ('number 2' -> self number2) .   ('scale' -> self scale) .   ('password' -> self password) .   ('rememberMe' -> self rememberMe) .   ('date' -> self date) .   ('gender' -> self gender) .   ('items' -> self selectedItems)}testDeactivateRaisesDeactivatedEvent  presenter state: true.  self assertEvent: #whenDeactivatedDo: isRaisedInPresenter: presenter whenDoing: [ presenter state: false ]buildToolBar  ^self newToolBar     addItem: self buildPushMessageToolBarItem;     addItem: self buildPopMessageToolBarItem;     addItem: self buildPopMessageToolBarItem position: SpToolBarItemPosition right;     yourselfproperty: arg1 whenChangedDo: arg2  (self observablePropertyNamed: arg1) whenChangedDo: arg2items: arg1  items := OrderedCollection new asValueHolder.  arg1 do: [:arg2 |  arg2 owner: self ].  items addAll: arg1entryCompletion: arg1  entryCompletion := arg1token  ^tokentestChangingLabelAffectTheWidget  presenter label: 'ALabel'.  self assert: self widget label equals: 'ALabel'announcer  ^announcer ifNil: [ announcer := Announcer new ]setBrowseButton  browseButton     state: false;     enabled: false;     label: 'Browse';     help: 'Browse the working copy of the selected package';     action: [ self browseWorkingCopy ]isHorizontal  ^self direction = SpLayoutDirection horizontalproperty: arg1 whenChangedDo: arg2  (self observablePropertyNamed: arg1) whenChangedDo: arg2allowToSelect  self deprecated: 'Should not use. Use #selectionMode instead'.  ^allowToSelectwindowIcon: arg1  self deprecated: 'With Spec 2, SpPresenter was refactored to move all window management to WindowPresenter.	From now on, if you want to interact with a window you need to:	- Implement #initializeWindow: method (#initializeDialog: for dialogs) to manage window elements before the presenter is opened	- Use the method #window or #withWindowDo: to interact with windows after it has been opened.'.  self window ifNil: [ windowIcon := arg1 ] ifNotNil: [:arg2 |  arg2 windowIcon: arg1 ]cell  ^cellbuildWidget  ^SpStubTextInputFieldView newwantsDroppedMorph: arg1 event: arg2 inMorph: arg3  ^self wantDropBlock cull: arg1 cull: arg2 cull: arg3isDisplayed  ^truesave: arg1  self host basicAt: self index put: arg1items: arg1  baseItems := arg1.  listPresenter items: arg1value  ^self host readSlotNamed: self instVarNamecurrentVerticalScrollPosition  ^currentVerticalScrollPositionmodel: arg1  model := arg1performHeaderAction  self headerAction cull: self model cull: selfconfigurationBlock  ^configurationBlockwhenTickDo: arg1  self property: #ticks whenChangedDo: arg1action: arg1  self button action: arg1headerColumn: arg1  arg1 id ifNil: [ ^nil ].  ^FTCellMorph new     listCentering: #left;     addMorph: arg1 id asMorph asReadOnlyMorph;     yourselfinitializePresenters  listPresenter := self newList.  listPresenter display: [:arg1 |  arg1 ].  self focusOrder add: listPresenterselectedElement  ^self subclassResponsibilityinitialPosition: arg1  initialPosition := arg1beHorizontal  direction := SpLayoutDirection horizontalaction  self showSubMenuIfPresent.  self widget ifNotNil: [:arg1 |  arg1 takeKeyboardFocus ].  self model performActioncheck  ^checktestWhenActionPerformedDo  | tmp1 tmp2 |  tmp1 := false.  tmp2 := false.  self assert: tmp1 equals: false.  self assert: tmp2 equals: false.  presenter action: [ tmp1 := true ].  presenter whenActionPerformedDo: [ tmp2 := true ].  self openInstance.  self assert: tmp1 equals: false.  self assert: tmp2 equals: false.  presenter adapter action.  self assert: tmp1 equals: true.  self assert: tmp2 equals: truetestUnselectAllRaisesSelectionEventOnce  | tmp1 |  tmp1 := 0.  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter unselectAll.  self assert: tmp1 equals: 1testDeactivatedCheckboxPresenterStartsDeactivatedCheckboxMorph  presenter state: false.  self deny: self adapter statetestSelectAllWithExistingSelectionLeavesSelection  presenter     selectIndex: 1;     selectAll.  self assert: (presenter selection includesIndex: 1)whenExtentChangedDo: arg1  self property: #surfaceExtent whenChangedDo: arg1cancelled  ^falseselectedIndex  ^self inspector selectedIndextestSelectItemThenSelectOutsideRangeKeepsSingleSelectedItem  presenter selectItem: 10.  presenter selectItem: 3000.  self assert: presenter selection selectedItems size equals: 1applyTo: arg1  arg1     width: (self geometryValueBetween: self extentOrDefault x and: arg1 width);     height: (self geometryValueBetween: self extentOrDefault y and: arg1 height).  self hResizing ifNotNil: [:arg2 |  arg1 hResizing: (self resizingStringFor: arg2) ].  self vResizing ifNotNil: [:arg2 |  arg1 vResizing: (self resizingStringFor: arg2) ]moveMethodFrom: arg1 to: arg2  self copyMethodFrom: arg1 to: arg2.  arg1 forgetMessage.  arg1 updateClassesListAndMessagesListspec  ^speclabelMorph  ^labelMorphnewImage  ^self instantiate: SpImagePresentertestValueToAbsoluteValueScales  self initMinMax.  self assert: (presenter valueToAbsoluteValue: 50) equals: 0.5changeToButton  self instantiatePresenters: #(bottom #SpButtonPresenter).  button font: (LogicalFont familyName: 'Source Sans Pro' pointSize: 9).  bottom label: 'I am useless'borderColor: arg1  borderColor := arg1rightLabel  ^rightLabelkeyStroke: arg1 fromMorph: arg2  lookupProperty: arg1 valueOf: arg2  (self propertiesLike: arg1) reverseDo: [:arg3 |  (arg3 perform: arg2) ifNotNil: [:arg4 |  ^arg4 ] ].  ^niladoptMenuGroupModel: arg1 first: arg2  | tmp1 |  arg2 ifFalse: [ widget           addMorphBack: (self theme newToolSpacerIn: widget);           addMorphBack: (self theme newToolbarHandleIn: widget);           addMorphBack: (self theme newToolSpacerIn: widget) ].  tmp1 := OrderedCollection new.  arg1 menuItems do: [:arg3 |  self adoptMenuItemModel: arg3 accumulator: tmp1 ].  self emptyAccumulator: tmp1selectionChanged: arg1  ^selectionHolder value: (arg1 selection ifNil: [ #() ] ifNotNil: [:arg2 |  arg2 selectedNodes ])setLayoutSizing  self     hResizing: #spaceFill;     vResizing: #rigidghostText  self deprecated: 'This API is too tight to Morph. Use #placeholder instead.' transformWith: '`@receiver ghostText' -> '`@receiver placeholder'.  ^self placeholdericon: arg1  icon := arg1icon  ^iconwhenEntityChanged: arg1  self property: #entity whenChangedDo: arg1initialize  super initialize.  history := NavigationHistory new.  self initializeShortcuts.  self property: #inspector whenChangedDo: [:arg1 :arg2 |  self updateInspectorFrom: arg2 ].  self announcer when: SpWidgetBuilt send: #setRefreshedToTrue to: self.  canBeRefreshed := false.  self whenWindowChanged: [:arg3 |  arg3 whenClosedDo: [ self inspector close ] ]owner  ^ownertestSelectMultiplePathsRaisesSelectionChangeEventMultipleTimes  | tmp1 |  tmp1 := 0.  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter selectPath: #(1 1).  presenter selectPath: #(3).  self assert: tmp1 equals: 2ownerChanged  self     customMenuActions: self owner customMenuActions;     takeKeyboardFocusbeSingleSelection  self selectionMode: (SpSingleSelectionMode on: self)addAllInstVars: arg1  pageClass  ^SpDemoTreeTablePresenterselectedItems  selection ifEmpty: [ ^#() ].  ^selection collect: [:arg1 |  presenter itemAtPath: arg1 ]selectAll  okAction: arg1  ^okAction := arg1position: arg1  position := arg1newColumn: arg1 right: arg2  self newColumn: arg1 left: nil right: arg2beEncrypted  ^self input beEncryptedicon: arg1  icon := arg1rightOffset: arg1  rightOffset := arg1beMultipleSelection  ^self list beMultipleSelectionsubmit  self fillModelWithFormContent.  self model: workingModel.  self announcingObject valueChangedclassToTest  ^SpComponentListPresenterdelete  self withWindowDo: #deleteinitialize  super initialize.  items := Dictionary new asValueHolderaddItem: arg1  | tmp1 |  tmp1 := self instantiate: SpMenuItemPresenter.  arg1 value: tmp1.  self addMenuItem: tmp1isSplitter  ^truetestInstanceSideRadioButtonClickIsInstanceButtonShouldbeTrue  biChooseMethod radioButtonClassSide click.  self deny: biChooseMethod isInstanceSideSelected.  biChooseMethod radioButtonInstanceSide click.  self assert: biChooseMethod isInstanceSideSelectedupdatePageIndex: arg1  | tmp1 |  arg1 = 0 ifTrue: [ ^self ].  tmp1 := self tabSelectorMorph selectedTab.  self pageMorph ifNil: [ self contentMorph addMorph: (self pageAt: arg1) ] ifNotNil: [:arg2 |  | tmp2 |        tmp2 := self pageMorph bounds.        self contentMorph replaceSubmorph: arg2 by: (self pageAt: arg1).        self flag: 'Without setting here the bounds the page moves a few pixels when refreshing the inspector'.        self pageMorph bounds: tmp2.        self pageMorph layoutChanged ].  self headerMorph layoutChanged.  self pageMorph layoutChanged.  self adoptPaneColor: (self owner ifNil: [ self ]) paneColor.  (self tabSelectorMorph tabs at: arg1) font: self tabSelectorMorph font.  self announcer announce: (SpNotebookPageChanged new           page: (self pages at: arg1);           oldPage: tmp1;           pageIndex: arg1)widget  ^widgetactions  ^actionsHolder valuestepTime  ^self model stepTimetextModel: arg1  textModel := arg1triggerOkAction  okAction ifNil: [ ^self ].  okAction cull: selfbrowserClientProvider  ^SystemNavigation defaultgetIconSelector: arg1  getIconSelector := arg1.  self update: getIconSelectormenu: arg1  menuHolder value: arg1browseChangeSet  | tmp1 |  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  tmp1 := self selectedChangeSet changedMessageList select: [:arg1 |  arg1 isValid ].  Smalltalk tools messageList browse: tmp1 title: 'Methods in Change Set ' , self selectedChangeSet namehShrinkWrap  self subclassResponsibilitywhenSelectionChanged: arg1  self dropList whenSelectionChanged: arg1transmitTo: arg1 transform: arg2 postTransmission: arg3  ^self newTransmission     from: self;     to: arg1;     transform: arg2;     postTransmission: arg3;     applychooseDate  | tmp1 tmp2 |  tmp2 := self date ifNil: [ self defaultDate ].  tmp1 := CalendarMorph openOn: tmp2.  tmp1     center: tmp1 cursorPoint;     fitInWorld;     onChoiceSend: #onDateChosen: to: selfensureKeyBindingsFor: arg1  arg1 bindKeyCombination: PharoShortcuts current browseShortcut toAction: [ self browseMethod ].  arg1 bindKeyCombination: PharoShortcuts current inspectItShortcut toAction: [ self inspectMethod ].  arg1 bindKeyCombination: PharoShortcuts current browseImplementorsShortcut toAction: [ self browseMessages ].  arg1 bindKeyCombination: PharoShortcuts current browseSendersShortcut toAction: [ self browseSendersOfMessage ].  arg1 bindKeyCombination: PharoShortcuts current browseReferencesShortcut toAction: [ self browseClassRefs ].  arg1 bindKeyCombination: PharoShortcuts current browseVersionsShortcut toAction: [ self browseVersions ].  arg1 bindKeyCombination: PharoShortcuts current removeShortcut toAction: [ self removeMethods ]disableFilter  self itemFilter: nilpasswordInput: arg1  passwordInput := arg1default: arg1  arg1 privateSetState: true.  arg1 takeKeyboardFocus.  arg1 whenBuiltDo: [ arg1 privateSetState: true ]dynamicLayout  | tmp1 |  tmp1 := SpLayout composed newColumn: [:arg1 |  self basicPresenters keysDo: [:arg2 |  arg1 newRow: [:arg3 |  arg3 add: arg2 ] ].        arg1 newRow: [:arg3 |   ] ].  self layout: tmp1.  ^tmp1receiverClass  ^self behaviorerrorPropertySelectors  ^#(icon label longLabel description)getIconSelector  ^getIconSelectorcontainerMorph  ^container morphrightFraction: arg1  rightFraction := arg1sortFunction  ^sortFunctionaddClass: arg1  arg1 add: (ClassEyeElement host: self object)newMenu  ^self instantiate: SpMenuPresentervalue  ^valueclassToTest  ^SpTreeTablePresenterrowHeight: arg1  arg1 = 0 ifTrue: [ ^super rowHeight: arg1 ].  ^(self widgetFor: (self elementAt: arg1)) heightaddPadding: arg1 toMorph: arg2 into: arg3  ^self subclassResponsibilityisColumnExpandable: arg1  ^(layout columnConstraintsAt: arg1) ifNotNil: [:arg2 |  arg2 isExpand ] ifNil: [ false ]setEditingModeFor: arg1 withBehavior: arg2  arg2 ifNotNil: [ arg1 beForSmalltalkCodeInClass: arg2 ] ifNil: [ arg1 beForSmalltalkScripting ]takeKeyboardFocus  whenMaxLengthChangedDo: arg1  self property: #maxLength whenChangedDo: arg1iconFor: arg1  ^self model iconFor: arg1classToTest  ^SpImagePresenterhelpText  ^widget balloonTextsubpresenterNamed: arg1  ^spec additionalSubpresentersMap at: arg1 ifAbsent: [ spec class allInstVarNames detect: [:arg2 |  arg2 = arg1 ] ifFound: [:arg2 |  spec instVarNamed: arg1 ] ifNone: [ self error: spec asString , ' does not implement the method ' , arg1 , '. Maybe your spec reference a presenter that does not exists.' ] ]newRow: arg1 bottom: arg2  self newRow: arg1 top: nil bottom: arg2ensureAtLeastOneColumnIn: arg1  self model columns ifNotEmpty: [ ^self ].  arg1 addColumn: (self newColumnFrom: self defaultColumn)password  ^passwordbuildWidget  ^SpStubWindowView newminimum: arg1  minimum := arg1property: arg1 rawValue: arg2  (self observablePropertyNamed: arg1) rawValue: arg2tabs: arg1  tabs := arg1unselectIndex: arg1  self subclassResponsibilitysave: arg1  self host valuesAndCounts at: self index put: arg1icon  ^self presenter iconowner  ^ownerselection: arg1  selection := arg1testFindClassFrom  self assert: (presenter findClassFrom: '') equals: nil.  self assert: (presenter findClassFrom: 'Object') equals: Object.  self assert: (presenter findClassFrom: 'Object.') equals: Object.  self assert: (presenter findClassFrom: '.Object.') equals: Object.  self assert: (presenter findClassFrom: 'somethingBefore := 42.Object') equals: Object.  self assert: (presenter findClassFrom: 'somethingBefore := 42.Object. somethingAfter := 11') equals: Object.  self assert: (presenter findClassFrom: 'NonExistingClass.Object.') equals: ObjecttestSelectPresenterIndexOutsideRangeUnsetsSelectedIndexInWidget  presenter selectIndex: 100.  self assert: self adapter selectedIndexes isEmptyinitializePresenters  toolBar := self newToolBar     addItem: (SpToolBarButton new           label: 'Ok';           icon: (self iconNamed: #smallOk);           help: 'Ok';           action: [ self inform: 'Ok' ];           yourself);     addItem: (SpToolBarButton new           label: 'Cancel';           icon: (self iconNamed: #smallCancel);           help: 'Cancel';           action: [ self inform: 'Cancel' ];           yourself);     yourself.  text := self newTextcancelled  ^self toolbar cancelledselectItems: arg1  self selectionMode selectItems: arg1actionWhenDeactivatedHolder  self deprecated: 'It breaks encapsulation'.  ^nilbasicSelectIndex: arg1  arg1 = 0 ifTrue: [ ^self ].  self selectIndexes: (self selectedIndexes copyWith: arg1)descriptionPresenter  ^descriptionPresentertestActivatedCheckboxPresenterStartsActivatedCheckboxMorph  presenter state: true.  self assert: self adapter stateexecute  | tmp1 |  tmp1 := self context newContact.  self hasSelectedContact ifTrue: [ self contactBook addContact: tmp1 after: self selectedContact ] ifFalse: [ self contactBook addContact: tmp1 ].  self contactBookPresenter updateViewproperty: arg1 whenChangedDo: arg2  (self observablePropertyNamed: arg1) whenChangedDo: arg2help: arg1  help := arg1model  ^modelnewButtonRow  ^self toolbar ifNotNil: [:arg1 |  arg1 buildWithSpec ]visitCommand: arg1  arg1 context ifNotNil: [ ^self ].  arg1 context: self contexttempName: arg1  tempName := arg1columnSpacing  ^columnSpacing ifNil: [ self class defaultColumnSpacing ]focusNext  self presenter withWindowDo: [:arg1 |  | tmp1 |        tmp1 := arg1 allPresentersInFocusOrder.        (tmp1 after: self presenter ifAbsent: [ tmp1 first ]) takeKeyboardFocus ]testVisitCommand  | tmp1 |  tmp1 := (CmCommandGroup named: 'root') asSpecGroup beRoot     register: (CmBlockCommand new           name: 'c1';           block: [  ];           context: 42;           yourself) asSpecCommand;     register: ((CmCommandGroup named: 'sub1') asSpecGroup           register: (CmBlockCommand new                 name: 'c2';                 block: [  ];                 context: 42;                 yourself) asSpecCommand;           register: (CmBlockCommand new                 name: 'c3';                 block: [  ];                 yourself) asSpecCommand);     register: (CmBlockCommand new           name: 'c4';           block: [  ];           yourself) asSpecCommand;     yourself.  self assert: (tmp1 / 'c1') context equals: 42.  self assert: (tmp1 / 'sub1' / 'c2') context equals: 42.  self assert: (tmp1 / 'sub1' / 'c3') context isNil.  self assert: (tmp1 / 'c4') context isNil.  SpRecursiveContextSetter visit: tmp1 toSetContext: 43.  self assert: (tmp1 / 'c1') context equals: 42.  self assert: (tmp1 / 'sub1' / 'c2') context equals: 42.  self assert: (tmp1 / 'sub1' / 'c3') context equals: 43.  self assert: (tmp1 / 'c4') context equals: 43initialize  super initialize.  action := [  ]buildWidget  ^SpStubMenuItemView newiconBlock: arg1  iconBlock := arg1inspectorType  ^self inspector classdynamicPresenter: arg1  dynamicPresenter := arg1beBoth  self displayMode: SpToolBarDisplayMode modeIconAndLabeltransmitTo: arg1  ^self newTransmission     from: self;     to: arg1;     applyisMatching: arg1  ^dataSource model performSearch: arg1 data matching: patternreadObject: arg1  ^self evaluation cull: arg1selection  ^selectionMode valuetranslateSymbol: arg1  ^bindings at: arg1 ifAbsent: [ arg1 ]newMenuButton  ^self instantiate: SpMenuButtonPresenteraddPicked: arg1  pickedItemsHolder add: arg1.  pickedItemsHolder valueChanged: true to: arg1positionPoint: arg1  ^self subclassResponsibilitytestUnselectUnselectedItemKeepsSelectionList  presenter     selectItem: 10;     unselectItem: 20.  self assert: presenter selection selectedItems asArray equals: #(10)presenterAt: arg1 put: arg2  ^self basicPresenters at: arg1 put: arg2lastVisibleRowIndex: arg1  lastVisibleRowIndex := arg1numberOfElements  ^listModel listSizebrowseClass  self deprecated: 'This method seems never called.'.  self currentMethod ifNotNil: [:arg1 |  arg1 methodClass browse ]okToChange  ^self model okToChangetestSelectingAnElementInWidgetUpdatePresenter  self adapter selectIndex: 2.  self assert: self presenter selectedItem equals: 20.  self assert: self adapter selectedIndexes equals: #(2)buildFileMenu  ^self newMenu     addItem: [:arg1 |  arg1           name: 'Push message';           action: [ self pushMessage ] ];     addItem: [:arg1 |  arg1           name: 'Pop message';           action: [ self popMessage ] ];     yourselfchildrenBlock: arg1  tree childrenBlock: arg1addSplitterIn: arg1 for: arg2  arg1 submorphs size = 1 ifFalse: [ ^self ].  arg1 addMorphBack: self direction newSplitterwhenCodeCompletionAllowedChangedDo: arg1  self deprecated: 'Use #whenTextIsAcceptedDo: instead or nothing. Currently, both those methods are doing the same thing but my name is really missleading. Thus, I''ll be removed.' transformWith: '`@receiver whenCodeCompletionAllowedChangedDo: `@statements' -> '`@receiver whenTextIsAcceptedDo: `@statements'.  self whenTextIsAcceptedDo: arg1property: arg1 whenChangedDo: arg2  (self observablePropertyNamed: arg1) whenChangedDo: arg2initializationText  presenter text: 'Text for tests.'enable  self enabled: truemodel: arg1  self deprecated: 'Model was renamed Presenter in Pharo 7' transformWith: '`@receiver model: `@statements1' -> '`@receiver presenter: `@statements1'.  self presenter: arg1menuColumn: arg1 row: arg2  | tmp1 |  tmp1 := self model contextMenu.  tmp1 ifNil: [ ^nil ].  ^SpBindings value: self model application adapterBindings during: [ | tmp2 |        tmp2 := tmp1 value.        tmp2 isMorph ifTrue: [ tmp2 ] ifFalse: [ tmp2 buildWithSpec ] ]testUnselectAllRaisesSelectionEventOnce  | tmp1 |  tmp1 := 0.  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter unselectAll.  self assert: tmp1 equals: 1contextClass: arg1  contextClass := arg1add: arg1 width: arg2  self add: arg1 origin: 0 @ 0 corner: 1 @ 1 offsetOrigin: 0 @ 0 offsetCorner: arg2 @ 0selectorsMenu: arg1  methodsListPresenter menu: arg1canTakeKeyboardFocus  ^truepropertyAt: arg1  ^self properties at: arg1pageClass  ^SpDemoNotebookPresenterdoubleClickAction: arg1  self deprecated: 'Use #whenActivatedDo: and #activateOnDoubleClick instead.'acceptColumnVisitor: arg1  ^arg1 visitIndexColumn: selflistHeight  ^super listHeight + 12initialize  super initialize.  self     name: 'New contact';     description: 'Creates a new contact and add it to the contact book.'displayBlock: arg1  ^self dropList displayBlock: arg1buildWidget  ^SpStubContainerView newcanDeselectByClick  self deprecated: 'It is not clear what option to select if deselected'.  ^falsetestSimpleLookup  | tmp1 |  tmp1 := self newLookup: '.application [ 		Geometry { #width: 42 } 	]'.  self assert: tmp1 width equals: 42testCloseDialogWindowRemovesItFromWindowCollection  | tmp1 |  tmp1 := (application newPresenter: SpButtonPresenter) openDialogWithSpec.  tmp1 close.  self deny: (application windows includes: tmp1)acceptDropBlock  ^acceptDropBlockminHeight: arg1  self minExtent: self minExtentOrDefault x @ arg1testSelectItemAddsItemToSelectedItemList  presenter selectItem: 10.  self assert: (presenter selection includesItem: 10)clickOnSelectedItem  | tmp1 |  tmp1 := self selection selectedItem.  (tmp1 notNil and: [ tmp1 respondsTo: #click ]) ifTrue: [ ^tmp1 click ] ifFalse: [ ^false ]addButtonLabel: arg1 iconNamed: arg2 help: arg3 action: arg4  self addItem: (SpToolBarButton new           label: arg1;           icon: (self application iconNamed: arg2);           help: arg3;           action: arg4;           yourself)from: arg1  self fromPort: arg1 outputPortDefaultinitializeTestedInstance  presenter     beMultipleSelection;     addColumn: (SpStringTableColumn title: 'Test' evaluated: #asString);     roots: #(10 20 30 'abc')specSelector: arg1  specSelector := arg1expand: arg1  expand := arg1buttonNormal  ^buttonNormalbuildWidget  | tmp1 tmp2 |  tmp1 := super buildWidget.  tmp1 announcer when: RubKeystroke send: #keystroke: to: self.  tmp2 := Morph new     extent: 12 @ 12;     color: Color transparent;     changeTableLayout;     listDirection: #topToBottom;     addMorph: (self newIconButtonAction: #decreaseValueOf: with: tmp1 iconSelector: #arrowDoubleDownIcon);     addMorph: (self newIconButtonAction: #increaseValueOf: with: tmp1 iconSelector: #arrowDoubleUpIcon);     yourself.  tmp1     changeProportionalLayout;     addMorph: tmp2 fullFrame: (LayoutFrame identity           bottomFraction: 0;           leftFraction: 1;           topOffset: 4;           leftOffset: -25;           yourself).  ^tmp1addVariableFields: arg1  | tmp1 |  tmp1 := 1.  self object array withIndexDo: [:arg2 :arg3 |  arg2 ifNotNil: [ arg1 add: (SetEyeElement host: self object index: arg3 externalIndex: tmp1).              tmp1 := tmp1 + 1 ] ]connectPresenters  button1 whenActivatedDo: [ self updateLabel ].  button1 whenDeactivatedDo: [ self updateLabel ].  button2 whenChangedDo: [ self updateLabel ].  button3 whenChangedDo: [ self updateLabel ]askBeforeDiscardingEdits  ^self model askBeforeDiscardingEditsversionModel  ^versionModeltestSelectItemsAddsPathsToSelectedPathList  presenter selectItems: {10 .         20}.  self assertCollection: presenter selection selectedPaths hasSameElements: {#(1 3) .         #(1 1 3)}doItReceiver: arg1  self deprecated: 'This has been moved to specific presenters (check children)' on: '2019-04-15' in: #Pharo8addMetacelloBaseline  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  repository ifNil: [ UIManager default inform: 'Please select a repository and try again'.        ^self ].  tmp2 := self baseLines.  tmp3 := tmp2 size > 0 ifTrue: [ 'Current baselines:' , String cr , (tmp2 inject: '' into: [:arg1 :arg2 |  arg1 , arg2 , String cr ]) , 'Enter a new baseline number' ] ifFalse: [ 'Enter a new baseline number ("-baseline" will be automatically added)' ].  tmp1 := UIManager default request: tmp3 initialAnswer: '1.0'.  tmp1 ifNil: [ ^self ].  tmp5 := OrderedCollection new.  tmp8 := UIManager default request: 'Please enter a pattern to filter package names' initialAnswer: '*'.  [ | tmp9 tmp10 |  tmp9 := OrderedCollection new.  tmp10 := OrderedCollection new.  self workingCopies do: [:arg3 |  ((tmp8 match: arg3 package name) and: [ (tmp5 includes: arg3 package name) not ]) ifTrue: [ tmp9 add: arg3 package name.              tmp10 add: arg3 ] ].  tmp6 := UIManager default chooseFrom: tmp9 values: tmp10 title: 'Add dependent package (cancel to stop)'.  tmp6 ifNotNil: [ tmp5 add: tmp6 package name ] ] doWhileTrue: [ tmp6 notNil ].  tmp4 := tmp1 copyWithoutAll: '.-'.  tmp7 := WriteStream on: String new.  tmp7 nextPutAll: 'baseline'.  tmp7 nextPutAll: tmp4.  tmp7 nextPutAll: ': spec         <version: '''.  tmp7 nextPutAll: tmp1.  tmp7 nextPutAll: '-baseline''>                spec for: #common do: [                spec blessing: #baseline.                spec repository: '''.  tmp7 nextPutAll: repository description.  tmp7 nextPutAll: '''.                    "spec                         package: ''Example-Core'';                        package: ''Example-Tests'' with: [ spec requires: ''Example-Core'' ]"'.  tmp5 do: [:arg4 |  tmp7           nextPutAll: '			spec package: ''';           nextPutAll: arg4;           nextPutAll: '''.';           nextPutAll: String cr ].  tmp7 nextPutAll: '                ].'.  self configurationClass compile: tmp7 contents classified: 'baselines'whenSelectionChanged: arg1  self dropList whenSelectionChanged: arg1retrieveSpec: arg1  | tmp1 |  tmp1 := self class perform: arg1.  tmp1 isSpLayout ifTrue: [ tmp1 selector: arg1 ].  ^tmp1setSliceButton  sliceButton := self instantiate: SpButtonPresenter.  sliceButton     state: false;     label: '+Slice';     help: 'Add a slice to cleaning and nicely propose a bug fix';     action: [ self createSlice ]notifyPropertyChanged: arg1  self flag: #todo.  (self observablePropertyNamed: arg1) valueChangedfill: arg1  fill := arg1initialize  super initialize.  shown := falsebeNotExpand  self expand: falseactionBarPresenter: arg1  actionBarPresenter := arg1testSelectItemThenSelectOutsideRangeKeepsSingleSelectedItem  presenter selectItem: 10.  presenter selectItem: 3000.  self assert: presenter selection selectedItems size equals: 1toPort  ^toPortsubwidget  ^subwidgetmenu: arg1  arg1 ifNotNil: [ arg1 owner: self ].  ^menu := arg1addConstraits: arg1 toChild: arg2  | tmp1 |  tmp1 := self addPadding: arg1 padding toMorph: arg2.  arg1 isExpand ifTrue: [ arg1 isFill ifFalse: [ tmp1                 hResizing: #rigid;                 vResizing: #rigid.              tmp1 := self newPanel                 addMorphBack: tmp1;                 yourself ].        tmp1           hResizing: #spaceFill;           vResizing: #spaceFill ] ifFalse: [ layout direction setRigidityOfNonExpandedMorph: tmp1.        arg1 width ifNotNil: [:arg3 |  tmp1 width: arg3 ].        arg1 height ifNotNil: [:arg4 |  tmp1 height: arg4 ] ].  ^tmp1accept: arg1 notifying: arg2  | tmp1 |  tmp1 := self presenter acceptBlock cull: arg1 cull: arg2.  tmp1 == false ifTrue: [ ^false ].  self presenter text: arg1 copy.  self presenter actionPerformed.  self presenter changed: #clearUserEdits.  ^trueclassToTest  ^SpSliderPresenteronMorphTreeSelectionChanged: arg1  | tmp1 |  tmp1 := arg1 selection ifNil: [ #() ] ifNotNil: [:arg2 |  arg2 selectedNodes ].  tmp1 := tmp1 collect: [:arg3 |  arg3 nodeModel ].  self model selectedItems: tmp1property: arg1 rawValue: arg2  (self observablePropertyNamed: arg1) rawValue: arg2hasSyntaxHighlight  ^syntaxHighlightrootCommandsGroup  ^SpRecursiveContextSetter visit: (self class buildRootCommandsGroupFor: self defaultCommandsContext) toSetContext: self defaultCommandsContextattachTransmission: arg1  self destinationPresenter whenSelectionChangedDo: [:arg2 |  self transmitWith: arg1 value: arg2 selectedItem model ]performAction  self action value.  actionPerformed := nilvShrinkWrap  description  descriptionBlock ifNil: [ ^self value asString ].  ^descriptionBlock cull: self valuewhenChildrenBlockChanged: arg1  tree whenChildrenBlockChanged: arg1emulateClick: arg1  backendForTest emulateClick: arg1 onTest: selftestSelectManyIndexesKeepsLastSelectionInWidget  presenter selectPath: #(1).  presenter selectPath: #(2).  self assert: self adapter selectedPaths equals: #(#(2))initialize  self model: SpDemoFormModel new.  super initializelabel  ^value printStringvAlign: arg1  vAlign := arg1objectAsHexBytes  ^String streamContents: [:arg1 |  arg1 nextPutAll: '['.        self object do: [:arg2 |  arg1 << (arg2 printPaddedWith: $0 to: 2 base: 16) ] separatedBy: [ arg1 nextPut: $  ].        arg1 nextPut: $] ] limitedTo: 5000mainMessagePresenter  ^mainMessagePresenterlabelFor: arg1  ^[ arg1 longLabel ] on: Error do: [:arg2 |  arg1 label , ': ' , (self labelFor: arg1 error: arg2) ]classToTest  ^SpTestingAbstractTwoButtonslayout: arg1  layout := arg1.  widget ifNil: [ innerWidget := arg1 direction newWidgetOn: self.        innerWidget borderWidth: arg1 borderWidth.        innerWidget cellInset: arg1 spacing.        layout whenVisiblePagesChangedDo: [ self recalculatePages ].        widget := self newScrollPaneFor: innerWidget ].  super layout: arg1addItemTo: arg1  arg1 addItem: [:arg2 |  arg2           name: 'Dynamic';           icon: (self iconNamed: #delete);           action: [ arg1 menuItems remove: arg2.              self needRebuild: false.              self buildWithSpec ] ].  self needRebuild: false.  self buildWithSpechistory  ^self inspectorWrapper historyadd: arg1 constraints: arg2  self widget ifNil: [ ^self ].  needRecalculatePages := true.  self basicAdd: arg1 constraints: arg2 to: innerWidget.  self scrollToShowLastPageselect  self widgetDo: [:arg1 |  arg1 changed: #select.        arg1 model selectionChanged.        arg1 dependents do: [:arg2 |  arg2 changed ] ]isStyleClass  ^truetestSelectingASecondElementSelectsIt  self presenter selectItem: 10.  self presenter selectItem: 20.  self assert: self presenter selectedItem equals: 20.  self assert: self adapter selectedIndexes equals: #(2)rootNodeHolder  ^self model rootNodeHolderhSpaceFill  startWithSelection  startsWithSelection := trueinitializePresenter  self whenWindowChanged: [ self objectChanged ]themeChanged  self fillStyle: self normalFillStyle.  super themeChangedmethodsFromClass: arg1  ^(self isInstanceSideSelected ifTrue: [ arg1 ] ifFalse: [ arg1 class ]) methods asOrderedCollectionlabel  ^self buildLabel: self model label withIcon: self model iconoptions  ^optionsconfigurationBlock: arg1  configurationBlock := arg1whenEntryCompletionChanged: arg1  self deprecated: 'Use #whenEntryCompletionChangedDo: instead.' transformWith: '`@receiver whenEntryCompletionChanged: `@statements' -> '`@receiver whenEntryCompletionChangedDo: `@statements'.  self whenEntryCompletionChangedDo: arg1resizerWidth: arg1  tree resizerWidth: arg1copyAccessorCode  Clipboard clipboardText: self accessorCode asTextrefreshWidgetList  (self widget showIndex < self widget dataSource numberOfRows and: [ self widget isIndexVisible: self widget showIndex ]) ifFalse: [ self widget resetPosition ].  self refreshWidgetSelection.  (self widget hasSelection and: [ self widget isIndexVisible: self widget selectedIndex ]) ifFalse: [ self widget resetPosition.        self widget ensureVisibleFirstSelection ].  self widget refreshicon  ^iconHolder valueiconName: arg1  self icon: (self iconNamed: arg1)whenMultiSelectionChangedDo: arg1  selectionMode whenChangedDo: arg1vSpaceFill  self widgetDo: [:arg1 |  arg1 vResizing: #spaceFill ]rootNodeHolder: arg1  rootNodeHolder value: arg1testJulianDaysIntervalFor2  | tmp1 |  tmp1 := calendar julianDaysIntervalFor: (Date year: 2018 month: 9 day: 17).  self     assert: tmp1 size equals: calendar daysToDisplayCount;     assert: tmp1 equals: ((Date year: 2018 month: 8 day: 26) julianDayNumber to: (Date year: 2018 month: 10 day: 6) julianDayNumber)testInstanceCreationWithValueHolder  | tmp1 tmp2 tmp3 |  tmp1 := 40 @ 54.  tmp2 := tmp1 asValueHolder.  tmp3 := SpTestingPresenterWithModel on: tmp2.  self assert: tmp3 model equals: tmp1value  ^valueBlock valueclassToTest  ^SpButtonPresenterlabel  ^'thisContext'classToTest  ^SpRadioButtonPresenterscaleInput  ^scaleInputrightText: arg1  self widgetDo: [:arg2 |  arg2 destTextModel setText: arg1.        arg2 updateText ]icons: arg1  icon := arg1beRowHomogeneous  self rowHomogeneous: truedropEnabled: arg1  drawBadgeOn: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp1 := self badge asString.  tmp4 := self badgeFont widthOfString: tmp1.  tmp5 := self badgeFont height.  tmp6 := 14 max: tmp4 + 2.  tmp2 := (bounds right - tmp6 - 2) @ (bounds top + 2) extent: tmp6 @ 14.  arg1 fillOval: tmp2 fillStyle: self badgeColor.  tmp3 := tmp2 center - (tmp4 @ tmp5 / 2.0) + (1 @ 0) extent: tmp4 @ tmp5.  arg1 drawString: tmp1 in: tmp3 font: self badgeFont color: self badgeTextColorbackend  ^backend ifNil: [ self useBackend: self class defaultBackendName.        backend ]hasSyntaxHighlight  ^self model hasSyntaxHighlightchangeList  ^messageList messagesproperty: arg1 rawValue: arg2  (self observablePropertyNamed: arg1) rawValue: arg2buildWidget  ^SpStubDialogWindowView newcolumn: arg1 withConstraints: arg2  | tmp1 |  tmp1 := SpGridAxisConstraints new.  arg2 value: tmp1.  columnConstraints at: arg1 put: tmp1registerSelectorActions  methodsListPresenter whenSelectionChangedDo: [:arg1 |  self updateTextContents ]customizeMorphicBar: arg1  self flag: #todo.  [ [ self currentValue < 1 ] whileTrue: [ self currentValue: self progression value.        arg1 value: self currentValue.        self refreshDelay wait ] ] forkitemFilter  ^self model itemFiltertabs  ^tabs valuenewPhone: arg1  newPhone := arg1testManyPresentersShowManyWidgets  3 timesRepeat: [ self presenter addPresenter: (SpNullMillerPresenter on: SpLabelPresenter new) ].  self assert: self adapter childrenWidgets size equals: 3testSelectMultipleItemAddsAllToSelectedPathList  presenter     selectItem: 10;     selectItem: 30.  self assertCollection: presenter selection selectedPaths hasSameElements: {#(1 3) .         #(1 2 3)}display: arg1  display := arg1tabManager: arg1  tabManager := arg1initialize  super initialize.  items := OrderedCollection new asValueHolder.  self placeAtEndwhenCanDeselectByClickChanged: arg1  self deprecated: 'It is not clear what option to select if deselected'initialize  super initialize.  groups := OrderedCollection new.  self property: #autoRefresh whenChangedDo: [:arg1 |  self menuGroups do: [:arg2 |  arg2 autoRefresh: arg1 ] ]classToTest  ^SpInputTextDropListmouseEnter: arg1 from: arg2  arg2 color: self urlHoverColor.  self currentHand showTemporaryCursor: Cursor webLinkmax: arg1  ^self sliderInput max: arg1menu  ^menuHolder valueread: arg1  ^(super read: arg1) valueselectDirectoryTitle: arg1  ^self backend selectDirectoryTitle: arg1classToTest  ^SpMenuPresenterbottomFraction  ^0isObservableSlot  ^trueactionsHolder  ^actionsHolderisResizeable  ^isResizeabletestNestedStyles  | tmp1 tmp2 tmp3 |  tmp3 := SpStyleSTONReader fromString: '.application [	.label [		Geometry { #width: 21 },		.nested [ 			Geometry { #width: 42 },			.deepNested [ 				Geometry { #width: 84 } ] ] ] ]'.  tmp2 := SpLabelPresenter new     buildWithSpec;     adapter.  tmp1 := SpMorphStyle fromStylesheet: tmp3 adapter: tmp2.  self assert: tmp1 width equals: 21.  tmp2 := SpLabelPresenter new     addStyle: 'nested';     buildWithSpec;     adapter.  tmp1 := SpMorphStyle fromStylesheet: tmp3 adapter: tmp2.  self assert: tmp1 width equals: 42.  tmp2 := SpLabelPresenter new     addStyle: 'nested.deepNested';     buildWithSpec;     adapter.  tmp1 := SpMorphStyle fromStylesheet: tmp3 adapter: tmp2.  self assert: tmp1 width equals: 84pushMessage  self widgetDo: [:arg1 |  self pushMessage: self model message to: arg1 ]testLabelIsSet  presenter label: 'test'.  self assert: presenter label equals: 'test'selectedElement  self tree hasSelectedItem ifFalse: [ ^nil ].  ^self tree selectedItem contentincludes: arg1  ^self presenters includes: arg1selectItems: arg1  arg1 do: [:arg2 |  [ self selectPath: (self pathOf: arg2) ] on: NotFound do: [  ] ]acceptColumnVisitor: arg1  ^arg1 visitImageColumn: selfkeyPressed: arg1 shift: arg2 meta: arg3 control: arg4 option: arg5  | tmp1 tmp2 |  tmp2 := 0.  arg2 ifTrue: [ tmp2 := tmp2 | 8 ].  arg3 ifTrue: [ tmp2 := tmp2 | (Smalltalk os isWin32 | Smalltalk os isUnix ifTrue: [ 2r00010000 ] ifFalse: [ 2r01000000 ]) ].  arg4 ifTrue: [ tmp2 := tmp2 | 2r00010000 ].  arg5 ifTrue: [ tmp2 := tmp2 | (Smalltalk os isWin32 | Smalltalk os isUnix ifTrue: [ 2r01000000 ] ifFalse: [ 2r00100000 ]) ].  tmp1 := KeyboardEvent new setType: #keystroke buttons: tmp2 position: self widget position + (1 @ 1) keyValue: arg1 charCode: arg1 hand: self currentWorld activeHand stamp: Time millisecondClockValue.  tmp1 sentTo: widget.  10 milliSeconds waitactionWhenActivatedHolder  self deprecated: 'It breaks the encapsulation'.  ^niladdVariableFields: arg1  self object initialPC to: self object size do: [:arg2 |  arg1 add: (DynamicEyeElement host: self object label: 'bc ' , arg2 asString value: (self object at: arg2) asString) ]textField  ^textFieldresetSelection  self deprecated: 'I have the impression this method is not use. If it end up been call, please open an issue on pharo-spec/Spec'setUp  super setUp.  point := SpObservablePoint newaddModelTo: arg1  self model items do: [:arg2 |  self model focusOrder add: arg2.        arg1 addMorph: (arg2 buildWithSpec                 width: 100;                 hResizing: #rigid;                 yourself) ]testAddButtonToActionBar  | tmp1 tmp2 |  tmp1 := SpActionBarPresenter new.  tmp2 := SpButtonPresenter new.  self assertEmpty: tmp1 items.  CmUILeftPositionStrategy new addButton: tmp2 toActionBar: tmp1.  self assert: tmp1 items size equals: 1.  self assert: (tmp1 items includesKey: #start).  self assert: (tmp1 items at: #start) size equals: 1.  self assert: (tmp1 items at: #start) anyOne equals: tmp2rightOffset  ^rightOffsetbehavior: arg1  behavior := arg1owner: arg1  owner := arg1sortingBlock: arg1  self model sortingBlock: arg1isVisible  self subclassResponsibilitycreateInstanceFor: arg1  | tmp1 |  tmp1 := self resolveSymbol: arg1.  ^self instantiate: tmp1testAddItemPosition  | tmp1 tmp2 |  self assert: presenter items isEmpty.  presenter addItem: (tmp1 := self newToolbarItem) position: SpToolBarItemPosition left.  presenter addItem: (tmp2 := self newToolbarItem) position: SpToolBarItemPosition right.  self assertCollection: presenter leftItems hasSameElements: {tmp1}.  self assertCollection: presenter rightItems hasSameElements: {tmp2}resetFilteringBlock  self deprecated: 'This feature is now removed from Spec 2. If the visible elements of the list need to be changed, it''s the users of the lists that should manage it and update the list of items of the list.'hash  ^host hashstyleName  ^self subclassResponsibilityaddMark: arg1 at: arg2  ^self marks: (self marks           add: (SpSliderMark new                 value: arg2;                 text: arg1;                 yourself);           yourself)removeStyle: arg1  (styles includes: arg1) ifFalse: [ arg1 ].  styles := styles copyWithout: arg1presenter: arg1  presenter := arg1action: arg1  action := arg1default  ^(self class environment at: #SpMorphicAdapterBindings) newdisplay: arg1  self dropList display: arg1columnConstraintsAt: arg1  ^columnConstraints at: arg1 ifAbsent: [ nil ]refreshDelay  ^refreshDelaylabel  ^slider labeltestDefaultTextIsEmpty  self assert: presenter text isEmptyrows  | tmp1 |  tmp1 := self widget submorphs first.  ^tmp1 submorphsdateInput  ^dateInputselectedItem  ^list selection selectedItemdisplayMode  ^displayMode ifNil: [ displayMode := SpToolBarDisplayMode default ]addItem: arg1  self defaultGroup addItem: arg1open  self model isCentered ifTrue: [ self centered ].  self model initialPosition ifNotNil: [ self widget openAsIs ] ifNil: [ self widget openInWorld ].  self windowIsOpeningisMenuPresenter  ^truetransmitPort: arg1 do: arg2 transform: arg3  self newTransmission     from: self port: arg1;     do: arg2;     transform: arg3;     applytestIconName  self assert: command iconName isNil.  command iconName: #add.  self assert: command iconName equals: #addworkingModel: arg1  workingModel := arg1initialize  super initialize.  updateBlock := [  ].  self timeline: SpTimeline newhiddenIcon  ^self iconNamed: #commentsstepBy: arg1  stepBy := arg1canBeRefreshed: arg1  canBeRefreshed := arg1dataSource: arg1  dataSource := arg1resizingSyle: arg1  ^arg1 ifTrue: [ #spaceFill ] ifFalse: [ #rigid ]updateInspectorFrom: arg1  self updateTitle.  self inspector ifNil: [ ^self ].  self canBeRefreshed ifFalse: [ ^self ].  self needRebuild: false.  self buildWithSpec: arg1 spec selector.  arg1 closebuildPopMessageToolBarItem  ^SpToolBarButton new     label: 'Pop';     icon: (self iconNamed: #glamorousDown);     help: 'Pop last status bar message';     action: [ self popMessage ];     yourselfdefaultGroup  ^defaultGroup ifNil: [ defaultGroup := self instantiate: SpMenuGroupPresenter.        self addMenuGroup: defaultGroup.        defaultGroup ]block: arg1 layoutFrame: arg2  | tmp1 |  tmp1 := SpRowLayout composed.  arg1 value: tmp1.  subwidget := tmp1.  self layoutFrame: arg2whenAcceptOnCRChangedDo: arg1  self property: #acceptOnCR whenChangedDo: arg1method2  setSelectionFromModel: arg1  self widget ifNotNil: [:arg2 |  arg2 setSelection: arg1 ]testUnselectNonSelectedItemDoesNotRemovesSelection  presenter     selectItem: 10;     unselectItem: 30.  self assert: presenter selection selectedItem equals: 10availablePages  ^SpDemoPage availablePagesopenInstance  window ifNil: [ window := presenter openWithSpecLayout: SpLabelPresenter defaultSpec ]withScrollBars  wrapScrollBars := trueremoveAll  needRecalculatePages := true.  innerWidget removeAllMorphsselectedIndex: arg1  self deprecated: 'Use #selectIndex: instead' transformWith: '`@receiver selectedIndex: `@arg' -> '`@receiver selectIndex: `@arg'.  self selectIndex: arg1initialize  super initialize.  options := OrderedCollection newmaxExtentOrDefault  ^maxExtent ifNil: [ 0 @ 0 ]selectedClass  ^classList selection selectedItemselectIndex: arg1  (arg1 = 0 and: [ widget selectedIndexes isEmpty ]) ifTrue: [ ^self ].  (widget selectedIndexes includes: arg1) ifTrue: [ ^self ].  widget selectIndex: arg1addContact: arg1  contents add: arg1newColumn: arg1 left: arg2 right: arg3  | tmp1 |  tmp1 := self computeLayoutFromTop: nil bottom: nil left: arg2 right: arg3.  self newColumn: arg1 origin: tmp1 first corner: tmp1 second offsetOrigin: tmp1 third offsetCorner: tmp1 fourthaddPadding: arg1 toMorph: arg2 into: arg3  ^arg3 addVerticalPadding: arg1 toMorph: arg2testSelectItemsOutsideRangeHasNoSelectedPaths  presenter selectItems: {3000 .         4000}.  self assert: presenter selection selectedPaths isEmptycanBeExecuted  ^self context isContactSelectedkeyStrokeAction: arg1  tree keyStrokeAction: arg1presenters  | tmp1 |  tmp1 := OrderedCollection new.  self presentersDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1testSetSelectPathOutsideRangeRaisesSelectionChangeEventWithUnsetPath  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedPath ].  presenter selectPath: #(4).  self assert: tmp1 equals: niltestSetSelectItemRaisesSelectionItemChangeEventWithSelectedItem  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter selectItem: 10.  self assert: tmp1 equals: 10tempNames  ^[ self object tempNames ] on: Error do: [ #() ]layout: arg1  widget ifNil: [ widget := GeneralScrollPane new           changeScrollerTableLayout;           hResizing: #spaceFill;           vResizing: #spaceFill;           color: Color transparent;           borderColor: Color transparent;           yourself ].  super layout: arg1model  ^self announcingObject valueautoDeselection: arg1  autoDeselection value: arg1mainInspectSubMenu: arg1  arg1 add: 'Inspect (i)' target: self selector: #inspectSelectedObjectInNewWindow.  arg1 add: 'Explore (I)' target: self selector: #exploreSelectedObjecttextConverter: arg1  super textConverter: arg1.  textModel syntaxHighlight: self textConverter shouldShout.  textModel text: self textConverter getTextselectionInterval  self withAdapterDo: [:arg1 |  self rawSelection: arg1 selection ].  ^selection ifNil: [ ^1 to: 0 ]openDialogWithSpecLayout: arg1  ^self application openDialog: self withSpecLayout: arg1asToolbarPresenterWith: arg1  | tmp1 |  tmp1 := SpToolBarPresenterBuilder new.  arg1 value: tmp1 toolbarPresenter.  ^tmp1     visit: self;     toolbarPresenterconnectPresenters  messageList     whenSelectionChangedDo: [:arg1 |  self selectItem: arg1 selectedItem ];     messages: self buildChangeList.  toolbarPresenter dropListModel selectIndex: 1layout  ^layoutannouncer  ^self model announcertoggleAction: arg1  self model state: arg1.  ^self model action cull: arg1whenChangedDo: arg1  self property: #selectedIndex whenChangedDo: [ arg1 cull: self ]requestWindowClose  ^self presenter ifNotNil: [:arg1 |  arg1 requestWindowClose ] ifNil: [ true ]presenterProvidedBy: arg1 configuredAs: arg2  self     presenterBlock: arg1;     configurationBlock: arg2setSelectedChangeSetIndex: arg1  ^changesListPresenter setSelectedIndex: arg1borderWidth  ^self model borderWidthemphasisCodeFor: arg1  ^arg1 inject: 0 into: [:arg2 :arg3 |  arg2 + (self emphasisOptions at: arg3) ]isPlaceAtStart  ^placeAtStartvisitStringColumn: arg1  self addCellColumn: arg1roots: arg1  rootsHolder value: arg1.  self changed: #setRoots: with: {arg1}addAllFromPragma: arg1 target: arg2  self fromSpec: (PragmaMenuBuilder pragmaKeyword: arg1 model: arg2) menuSpecrun  self startmethod  ^methodbutton2  ^button2newEmptyModel  ^SpCollectionListModel on: #()listSize  ^self dropList listSizeproperty: arg1 rawValue: arg2  (self observablePropertyNamed: arg1) rawValue: arg2autoRefreshOnExpand: arg1  autoRefreshOnExpand value: arg1classToTest  ^SpLabelledInputTextDropListtitle  ^super title , ' [' , self objectVariableSize asString , ']'allShownItems  ^rootItem children flatCollect: [:arg1 |  arg1 withExpandedChildren ]testCanDynamicallyRebuildPresenter  self openInstance.  self assert: presenter label label equals: ''.  self shouldnt: [ presenter selectFirstElement ] raise: Error.  self assert: presenter label label equals: '1'testDynamicBuild  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := SpTestingPresenter new.  tmp1 openWithSpec close.  tmp2 := tmp1 list adapter.  tmp1 openWithSpec close.  tmp3 := tmp1 list adapter.  self deny: tmp2 identicalTo: tmp3.  tmp1 list needRebuild: false.  tmp1 needRebuild: false.  tmp1 openWithSpec close.  tmp4 := tmp1 list adapter.  self assert: tmp3 identicalTo: tmp4.  self assert: tmp1 needRebuildtestSmokeCreates  self presentertestSelectItemThenSelectOutsideRangeKeepsFirstElement  presenter selectItem: 10.  presenter selectItem: 5000.  self assert: (presenter selection includesItem: 10)value  self subclassResponsibilitynotify: arg1 on: arg2  arg2 notifyInfo: arg1showClass  ^self class showClasswhenPossibleEntitiesChanged: arg1  self property: #possibleEntities whenChangedDo: arg1selectedPath  ^selectionstyleName  ^styleName ifNil: [ super styleName ]shown  ^showninitialize  super initialize.  selector := #newVSplitterAt:.  layoutFrame := (0 @ 0 corner: 0 @ 0) asSpLayoutFrame rightOffset: 1observablePropertyNamed: arg1  | tmp1 |  tmp1 := self class slotNamed: arg1.  tmp1 isObservableSlot ifFalse: [ SpNonObservableSlotError signal: arg1 ].  ^tmp1 rawRead: selfclassToTest  ^SpTabManagerPresenterwantDropBlock: arg1  wantDropBlock := arg1add: arg1 withConstraints: arg2  super add: arg1 withConstraints: arg2.  adapter ifNotNil: [:arg3 |  arg3 add: arg1 constraints: (children at: arg1) ]testShowPresenterShowsWidget  self presenter show.  self assert: self adapter isVisibledefaultColor  ^self theme textColorisSearchEnabled  ^searchEnabledsetModel: arg1  ^self model: arg1whenSelectedPageChangedDo: arg1  self property: #selectedPage whenChangedDo: arg1testSetRootModelManyTimesPushesOnlyLastPresenterToList  | tmp1 |  self presenter presenterBlock: [:arg1 |  SpNullMillerPresenter on: (SpLabelPresenter new label: arg1 asString) ].  1 to: 3 do: [:arg2 |  self presenter setRootModel: arg2 ].  tmp1 := self presenter presenters first.  self assert: tmp1 wrappedPresenter label equals: 3 asStringdefer: arg1  UIManager default defer: arg1tabDeleted: arg1  self model basicRemoveTab: arg1 modelnewPanel  ^super newPanel     layoutPolicy: SpMorphicPanedLayout new;     yourselfclearUserEditFlag  self model text: self getText.  self changed: #clearUserEditsshortcut  ^shortcutmodel: arg1  model := arg1adapterClass: arg1  ^Smalltalk at: (self translateSymbol: arg1) ifAbsent: [ arg1 ]unselectItem: arg1  self selection unselectItem: arg1layout  ^layoutisNonEditableRow: arg1 column: arg2  ^(self widget dataSource cellColumn: (self widget columns at: arg2) row: arg1) submorphs allSatisfy: [:arg3 |  arg3 asReadOnlyMorph == arg3 ]testEnablingFilteringUpdateOpenedList  self deny: self adapter hasFilter.  presenter enableItemSubstringFilter.  self assert: self adapter hasFilter.  presenter itemFilter: nil.  self deny: self adapter hasFiltertestOpenWindowAddsItToWindowCollection  | tmp1 |  tmp1 := (application newPresenter: SpButtonPresenter) openWithSpec.  self assert: (application windows includes: tmp1)popMessageFrom: arg1  | tmp1 |  pushedMessages ifEmpty: [ ^self ].  pushedMessages removeLast.  tmp1 := pushedMessages ifNotEmpty: #last ifEmpty: [ '' ].  arg1     removeAllMorphs;     addMorph: tmp1 asStringMorphtestSetOwner  | tmp1 |  tmp1 := SpButtonPresenter new.  self assert: tmp1 owner isNil.  presenter presenter: tmp1.  self assert: tmp1 owner equals: presenterincomingTransmission: arg1 from: arg2  self presenter roots: arg1fromPort: arg1  fromPort := arg1testParsingAStyleIsNotAffectedByExistingClass  | tmp1 |  aClass := Object subclass: #Font.  tmp1 := SpStyle createDefaultStyleSheet.  self assert: tmp1 styles isNotEmptyaddPresenterIn: arg1 withSpecLayout: arg2  super addPresenterIn: arg1 withSpecLayout: arg2.  self model buttons ifNotEmpty: [ arg1 setToolbarFrom: [ self buildButtonBar ] ]action  ^self model actionproperty: arg1 rawValue: arg2  (self observablePropertyNamed: arg1) rawValue: arg2whenSelectedItemChangedDo: arg1  selectionHolder whenChangedDo: [:arg2 |  arg2 ifNil: [ arg1 value: nil ] ifNotNil: [ arg2 isEmpty ifTrue: [ arg1 value: nil ] ifFalse: [ arg1 value: (arg2 last lastClicked ifTrue: [ arg2 last content ] ifFalse: [ nil ]) ] ] ]openWithSpecAt: arg1  self buildWithSpecAsPopup.  self changed: #openAt: with: {arg1}focusOrder  ^focusOrder ifNil: [ focusOrder := OrderedCollection new ]assign: arg1 to: arg2  self presenterAt: arg2 put: arg1.  arg1 owner: selfupdateTitle  self withWindowDo: [:arg1 |  arg1 title: self title ]minWidth  ^self minExtent ifNotNil: [:arg1 |  arg1 x ]mainMenu  | tmp1 |  tmp1 := self newMenuBar     addGroup: [:arg1 |  arg1 addItem: [:arg2 |  arg2                 name: 'File';                 icon: (self iconNamed: #openIcon);                 subMenu: self subMenu ].        arg1 addItem: [:arg2 |  arg2                 name: nil;                 description: 'Open file';                 icon: (self iconNamed: #openIcon);                 action: [ self inform: 'Open File' ] ].        arg1 addItem: [:arg2 |  arg2                 name: nil;                 description: 'Save File';                 icon: (self iconNamed: #smallSaveIcon);                 action: [ self inform: 'Save File' ] ].        arg1 addItem: [:arg2 |  arg2                 name: nil;                 description: 'Print file';                 icon: (self iconNamed: #smallPrintIcon);                 action: [ self inform: 'Print file' ] ] ];     addGroup: [:arg1 |  arg1 addItem: [:arg2 |  arg2                 name: nil;                 description: 'Undo';                 icon: (self iconNamed: #smallUndoIcon);                 action: [ self inform: 'Undo' ] ].        arg1 addItem: [:arg2 |  arg2                 name: nil;                 description: 'Redo';                 icon: (self iconNamed: #smallRedoIcon);                 action: [ self inform: 'Redo' ] ] ];     addGroup: [:arg1 |  arg1 addItem: [:arg2 |  arg2                 name: nil;                 description: 'Add menu item';                 icon: (self iconNamed: #add);                 action: [ self addItemTo: arg1 ] ] ].  ^tmp1cancelAction: arg1  cancelAction := arg1sortingBlock  ^self model sortingBlockupdateLabel  label label: (String streamContents: [:arg1 |  {button1 .               button2 .               button3} do: [:arg2 |  arg1                       << arg2 label;                       << ' : ';                       << (arg2 state ifTrue: [ 'V' ] ifFalse: [ 'X' ]) ] separatedBy: [ arg1 << ' - ' ] ])searchMatching: arg1  searchBlock := arg1.  self enableSearchevenRowColor  ^evenRowColor valueexecute  self selectedContact phone: self context newPhone.  self contactBookPresenter updateViewsideRuler  ^sideRulermodel  ^modelrowConstraintsAt: arg1  ^rowConstraints at: arg1 ifAbsent: [ nil ]removeAll  children removeAll.  adapter ifNotNil: [:arg1 |  arg1 removeAll ]selectedHolder  ^selectedHolderselectedIndexes  ^widget selectedIndexesconfigureOSX: arg1  isDisplayed  ^self widget isDisplayedfirstAction: arg1 secondAction: arg2  self firstButton action: arg1.  self secondButton action: arg2defaultNodeFor: arg1  ^SpTreeNodePresenter new     content: arg1;     children: [ self childrenFor: arg1 ];     hasChildren: [ self hasChildrenFor: arg1 ];     yourselfbuttonGroup: arg1  buttonGroup := arg1initializeWidgets  inspectorChoice := self newDropList.  previousButton := self newButton.  nextButton := self newButton.  previousButton     label: '<';     action: [ self inspectorWrapper inspectPrevious.        self update ].  nextButton     label: '>';     action: [ self inspectorWrapper inspectNext.        self update ].  inspectorChoice displayBlock: [:arg1 |  arg1 ]hideHeaderTitle  headerTitle := nilinitialize  super initialize.  displayBlock := [:arg1 |  arg1 ifNotNil: [ arg1 asStringOrText ] ifNil: '' ].  self property: #displayBlock whenChangedDo: [ self date: self date ].  self date: self defaultDatecolumns: arg1  columns := arg1isExpanded: arg1  isExpanded value: arg1selectedItem  self selectedIndex = 0 ifTrue: [ ^nil ].  ^self model at: self selectedIndexisInstanceSideSelected  ^radioButtonInstanceSide stateconfigureButton: arg1 item: arg2  arg1 getIconSelector: #icon.  arg1 badgeSelector: #badgeautoMultiSelection  ^autoMultiSelection valuelabelOnLeft  ^self changed: #labelOnLeft with: #()selectedItems: arg1  tree selectedItems: arg1configuration  ^configurationaddMorph: arg1 fullFrame: arg2  paneMorphs add: arg1.  super addMorph: arg1 fullFrame: arg2addItemRight: arg1  rightPanel addMorphBack: (arg1           vResizing: #spaceFill;           yourself)elements  ^self presentersassociatedRadioButtons: arg1  | tmp1 |  tmp1 := {self} , arg1.  tmp1 do: [:arg2 |  arg2 basicAssociatedRadioButtons: tmp1 ].  arg1 do: [:arg2 |  arg2 state: false ]toPresenter  ^self toPort presentertestUnselectSelectedIndexRaisesSingleEvent  | tmp1 |  tmp1 := 0.  presenter     selectIndex: 1;     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectIndex: 1.  self assert: tmp1 equals: 1testOpenPresenterRaisesBuiltEvent  | tmp1 |  tmp1 := false.  presenter whenBuiltDo: [ tmp1 := true ].  self openInstance.  self assert: tmp1layout: arg1  layout := arg1.  widget ifNil: [ widget := arg1 direction newWidgetOn: self.        widget layoutPolicy position: arg1 position.        self selector: self splitterNewSelector ].  super layout: arg1registerEvents  self whenMenuChangedDo: [ self withAdapterDo: [:arg1 |  arg1 updateMenu ] ]outputPortDefault  ^self outputPorts firstpresenter  ^presenterchildNodeClass  ^childNodeClass valueasArray  self error: 'Should not arrive here. This layout is executable then it will not be interpreted.'initializePresenters  super initializePresenters.  self content: SpSliderInputtestEnabledAffectWidget  presenter enabled: false.  self deny: self adapter enabledrefreshSubMenu: arg1  arg1 add: 'Refresh Inspector' target: self selector: #refresh.  arg1 addLinemenu: arg1  | tmp1 |  tmp1 := self model contextMenu.  tmp1 ifNil: [ ^nil ].  ^SpBindings value: self model application adapterBindings during: [ tmp1 buildWithSpec ]buttonWithColor: arg1  buttonWithColor := arg1rightFraction: arg1  ^0menuPresenter  ^menuPresenterwhenListChanged: arg1  self deprecated: 'Use #whenModelChangedDo: instead' transformWith: '`@receiver whenListChanged: `@argument' -> '`@receiver whenModelChangedDo: `@argument'.  self whenModelChangedDo: arg1classToTest  ^SpSliderInputsize  ^sizetabManager  ^tabManagertestSelectWidgetIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | tmp1 |  presenter selection whenChangedDo: [:arg1 |  tmp1 := arg1 ].  self adapter selectPath: #(1).  self assert: tmp1 equals: #(1)enabled: arg1  super enabled: arg1.  self changed: #enabled: with: {arg1}classToTest  ^SpTreeTablePresenterstate: arg1  self state = arg1 ifTrue: [ ^self ].  state := arg1numberOfRows  ^model ifNil: [ 0 ] ifNotNil: [ self presenters size ]withWindowDo: arg1  self hasWindow ifFalse: [ ^self ].  arg1 value: self rootacceptAllowed  ^self widget editingMode acceptAllowedscrollValueChanged: arg1  self model scrollValue: arg1 stepwhenFilteringBlockChangedDo: arg1  self deprecated: 'This feature is now removed from Spec 2. If the visible elements of the list need to be changed, it''s the users of the lists that should manage it and update the list of items of the list.'buildWidget  | tmp1 tmp2 |  self flag: #pharo7.  tmp1 := self class environment at: #SpRubScrolledTextMorph ifAbsent: [ RubScrolledTextMorph ].  tmp2 := (tmp1 on: self)     getTextSelector: #getText;     setTextSelector: #accept:notifying:;     getSelectionSelector: #readSelection;     menuProvider: self selector: #codePaneMenu:shifted:;     setSelectionSelector: #setSelection:;     ghostText: self placeholder;     beWrapped;     enabled: self enabled;     askBeforeDiscardingEdits: self askBeforeDiscardingEdits;     autoAccept: self autoAccept;     vResizing: #spaceFill;     hResizing: #spaceFill;     setBalloonText: self help;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     registerScrollChanges: #scrollValueChanged:;     yourself.  self setEditingModeFor: tmp2.  self presenter whenTextChangedDo: [:arg1 |  self setText: arg1 to: tmp2 ].  self presenter whenPlaceholderChangedDo: [:arg1 |  self setGhostText: arg1 to: tmp2 ].  ^tmp2table: arg1  table := arg1open  self object ifNil: [ ^self openOnNil ].  self object isInteger ifTrue: [ ^self openOnInteger: self object ].  self object isString ifTrue: [ ^self openOnString: self object ]commandClass  ^SpCodeBrowseItCommandshortcut: arg1  shortcut := arg1addSplitter  self commands add: (SpSplitterHorizontal commands: self commands)restoreButton  ^restoreButtonfillModelWithFormContent  self workingModel     name: self nameTextInput text;     surname: self surnameTextInput text;     number1: number1Input number;     number2: number2Input number;     scale: self scaleInput value;     password: self passwordInput text;     rememberMe: self checkboxInput state;     date: self dateInput date.  self workingModel gender: (genderButtons associations detect: [:arg1 |  arg1 value state ]) key.  self workingModel selectedItems: self itemsInput selectedItemsadapterBindingsClass  ^SpMorphicAdapterBindingsworkingModel  ^workingModellistDirection  self model isPlaceAtEnd ifTrue: [ ^#rightToLeft ].  self model isPlaceAtStart ifTrue: [ ^#leftToRight ].  self error: 'Undefined location to place buttons.'previousInspectorType  | tmp1 tmp2 |  tmp2 := self inspectorTypes.  tmp1 := tmp2 indexOf: self inspectorType ifAbsent: [ ^tmp2 first ].  ^tmp2 atWrap: tmp1 - 1add: arg1 expand: arg2 fill: arg3 padding: arg4  self add: arg1 withConstraints: [:arg5 |  arg5           expand: arg2;           fill: arg3;           padding: arg4 ]testAskBeforeChanging  | tmp1 |  self assert: presenter askBeforeChanging not.  self openInstance.  tmp1 := presenter adapter askBeforeChanging.  self assert: tmp1 not.  presenter askBeforeChanging: true.  tmp1 := presenter adapter askBeforeChanging.  self assert: tmp1saveElement  | tmp1 |  tmp1 := description doItReceiver class compiler     source: description text readStream;     context: nil;     receiver: description doItReceiver;     failBlock: [ ^self ];     evaluate.  self selectedElement save: tmp1.  self objectChangedextractArrayToInterpretFrom: arg1  arrayToInterpret := arg1.  arg1 isSpLayout ifTrue: [ arrayToInterpret := arg1 asArray.        selector := arg1 selector ].  (arrayToInterpret isCollection and: [ arrayToInterpret isSequenceable ]) ifFalse: [ ^arrayToInterpret ].  (arg1 isString or: [ arg1 isText ]) ifTrue: [ ^(self isPresenterSymbol: arg1) ifTrue: [ self presenter ] ifFalse: [ self convertSymbolOfClassToInstance: arg1 ] ].  ^nilbackgroundColorFor: arg1  ^self model backgroundColorFor: arg1presenters  ^self itemsdaysButtonsBuilderFrom: arg1  ^SpDynamicPresentersListBuilder new     modelObjects: (self datesToDisplayFor: arg1);     presenter: SpButtonPresenter configuredAs: [:arg2 :arg3 |  arg2           label: arg3 dayOfMonth asString;           enabled: arg1 monthIndex = arg3 monthIndex;           action: [ self dayClicked: arg3 ].        arg3 julianDayNumber = Date today julianDayNumber ifTrue: [ arg2 icon: (self iconNamed: #glamorousGrayCircle) ] ];     layoutBuilder: (SpDynamicLeftToRightColumnsLayout columns: self daysInAWeek);     yourselfisSearchEnabled  ^self presenter isSearchEnabledresetSortingBlock  self model sortingBlock: nilaccept: arg1  self text: arg1.  self acceptBlock cull: arg1.  self actionPerformed.  self changed: #clearUserEditstitle  ^String streamContents: [:arg1 |  arg1 << self class title << ' on: ' << self model currentChangeSet name ]backgroundColorFor: arg1 at: arg2  self deprecated: 'Should not use. This feature is not supported anymore. This feature depends on the theme'.  ^self backgroundColorBlock cull: arg1 cull: arg2initializeTestedInstance  super initializeTestedInstance.  presenter addColumn: (SpStringTableColumn title: 'Number' evaluated: #yourself).  presenter hideColumnHeadersinspectionMenu: arg1  | tmp1 |  self hasSelectedObject ifFalse: [ ^arg1 ].  tmp1 := self newMenu.  self inspectionSubMenu: tmp1.  self selectedElement inspectionMenu: tmp1.  arg1 addAllMorphs: (tmp1 buildWithSpec: #popup) items.  ^arg1presenters: arg1  self items: arg1positionPoint: arg1  ^self position: self left @ arg1 yselectTabModel: arg1  tabSelectedAction value cull: arg1 cull: selfdisplay: arg1  ^self dropList display: arg1newLookup: arg1  | tmp1 |  tmp1 := SpStyleSTONReader fromString: arg1.  ^SpMorphStyle newStyles: tmp1 flattenClassesclickAtIndex: arg1  self selectIndex: arg1.  activateOnSingleClick ifFalse: [ ^self ].  self doActivateAtIndex: arg1triggerOkAction  self okActionBlock valueinitializeTestedInstance  presenter items: #(10 20 30)returnInterpretationOf: arg1  | tmp1 tmp2 |  tmp1 := self class interpretASpec: arg1 presenter: spec.  tmp2 := (tmp1 isKindOf: SpPresenter) ifTrue: [ self getAdaptorWithDefaultSpecOf: tmp1 ] ifFalse: [ tmp1 ].  self presenter spec: tmp2.  ^tmp2testActivationOnDoubleClickShouldNotActivateOnClick  | tmp1 |  tmp1 := nil.  presenter     activateOnDoubleClick;     whenActivatedDo: [:arg1 |  tmp1 := arg1 selectionItem ].  presenter clickAtIndex: 1.  self assert: tmp1 equals: nilemphasisOptions  ^emphasisOptions ifNil: [ emphasisOptions := {(#bold -> 1) .         (#italic -> 2) .         (#underline -> 4) .         (#narrow -> 8) .         (#struck -> 16)} asDictionary ]prepareToRunAgain  self tearDown.  super setUpitems  ^items valueresult  ^resultcolumns  ^columnscellIndentFor: arg1  ^arg1 depth * 16whenChangedDo: arg1  self property: #state whenChangedDo: arg1step  self refreshinitializePresenters  text := self instantiate: SpLabelPresenter.  plus := self instantiate: SpButtonPresenter.  minus := self instantiate: SpButtonPresenter.  plus label: '+'.  minus label: '-'whenDateChanged: arg1  dateModel whenTextChanged: [:arg2 :arg3 :arg4 :arg5 |  | tmp1 |        tmp1 := date.        date := arg2 ifNotEmpty: [ Date readFrom: arg2 readStream ] ifEmpty: [ nil ].        arg1 cull: date cull: tmp1 cull: arg4 cull: arg5 ]collapseAll  self changed: #collapseAll with: #()retrieveSpec: arg1  self layout ifNotNil: [ ^self layout ].  ^super retrieveSpec: arg1testItems  | tmp1 |  self assert: presenter items isEmpty.  presenter addItem: (tmp1 := self newToolbarItem).  self assertCollection: presenter leftItems hasSameElements: {tmp1}font  self flag: #REMOVE.  ^niltextModel  ^textModelpriorVersionOfAMethod: arg1  | tmp1 |  tmp1 := referencesList identityIndexOf: arg1.  ^referencesList at: tmp1 + 1 ifAbsent: [ nil ]text  ^textwhenActivatedDo: arg1  self whenChangedDo: [:arg2 |  arg2 ifTrue: arg1 ]initializePresenters  notebook := self newNotebook.  checkbox := self newCheckBox.  notebook     addPage: self objectClassPage;     addPage: self objectInspectorPage;     addPage: self browserPagewhenMenuChangedDo: arg1  self property: #contextMenu whenChangedDo: arg1updateWindowTitle  self withWindowDo: [:arg1 |  arg1 title: self title ]propertyAt: arg1 ifAbsent: arg2  ^self properties at: arg1 ifAbsent: arg2styles  ^stylesnewToolbarMorph  ^SpNotebookPanelMorph new     fillStyle: (SolidFillStyle color: Color transparent);     borderStyle: (BorderStyle width: 0);     vResizing: #spaceFill;     hResizing: #shrinkWrap;     cellPositioning: #center;     changeTableLayout;     cellInset: 0;     yourselftestUnselectNonSelectedPathRaisesNoEvent  | tmp1 |  tmp1 := 0.  presenter     selectPath: #(1 1);     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectPath: #(2 1).  self assert: tmp1 equals: 0buildWidget  | tmp1 |  tmp1 := PluggableSliderMorph new     model: self;     getValueSelector: #value;     setValueSelector: #value:;     value: self absoluteValue;     getLabelSelector: #label;     max: self max;     min: self min;     quantum: self quantum;     setBalloonText: self help;     vResizing: #spaceFill;     hResizing: #spaceFill;     yourself.  tmp1 := self presenter isHorizontal ifTrue: [ tmp1 ] ifFalse: [ tmp1 := TransformationMorph new asFlexOf: tmp1.        tmp1 transform withAngle: 90 degreesToRadians negated.        tmp1 ].  self presenter whenMinChangedDo: [:arg1 |  tmp1 min: arg1 ].  self presenter whenMaxChangedDo: [:arg1 |  tmp1 max: arg1 ].  self presenter whenQuantumChangedDo: [:arg1 |  tmp1 quantum: arg1 ].  self presenter whenValueChangedDo: [:arg1 |  tmp1 value: arg1 ].  ^tmp1iconBlock  ^iconBlocknumberOfColumns: arg1  columns := OrderedCollection new.  (1 to: arg1) do: [:arg2 |  self addColumn: (SpStringTableColumn evaluated: [:arg3 |  (self displayBlock value: arg3) at: arg2 ]) ]setLeftOffset: arg1 for: arg2 borderWidth: arg3  arg2 leftFraction = 0 ifTrue: [ arg1 isZero ifTrue: [ arg2 leftOffset: arg3 ] ifFalse: [ arg2 leftOffset: arg1 + self splitterWidth ] ] ifFalse: [ arg2 leftFraction = 1 ifFalse: [ arg2 leftOffset: arg1 + self splitterWidth ] ]activateOnSingleClick  activateOnSingleClick := trueconnectPresenters  list whenSelectionChangedDo: [:arg1 |  label := self newLabel.        label label: arg1 selectedItem asString.        self needRebuild: false.        self buildWithSpec ]removeItemBlock: arg1  removeItemBlock := arg1labelOnLeft  ^self widgetDo: [:arg1 |  arg1 listDirection: #leftToRight ]beHomogeneous  self homogeneous: truehide  visible := falserawSelection: arg1  self property: #selection rawValue: arg1font: arg1  font := arg1testSelectItemsAddsItemsToSelectedItemList  presenter selectItems: {10 .         20}.  self assert: (presenter selection includesItems: {10 .               20})actions: arg1  actionsHolder value: arg1inspectSelectedObjectInNewWindow  self selectedObjectDo: [:arg1 |  self inspectInNewWindow: arg1 ]beExpandable  expandable := truetestSingleClickActivatesRowInSingleClickActivationMode  | tmp1 |  tmp1 := false.  self presenter     activateOnSingleClick;     whenActivatedDo: [ tmp1 := true ].  backendForTest clickFirstRowAndColumn: self adapter.  self assert: tmp1childrenItemsBlock  ^childrenItemsBlocktestSetSelectItemOutsideRangeDoesNotModifySelection  presenter whenSelectionChangedDo: [:arg1 |  self fail ].  presenter selectItem: 1000text  ^textdisplayMode: arg1  displayMode := arg1testSetSelectIndexRaisesSelectionItemChangeEventWithSelectedIndex  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter selectIndex: 1.  self assert: tmp1 equals: 10newName  | tmp1 |  tmp1 := self request: 'New name of the contact' initialAnswer: self selectedContact name title: 'Rename a contact'.  tmp1 isEmpty ifTrue: [ SpInvalidUserInput signal: 'The contact name can not be empty' ].  ^tmp1testChangingFromMultipleToSingleSelection  presenter beMultipleSelection.  self assert: presenter isMultipleSelection.  presenter beSingleSelection.  self deny: presenter isMultipleSelectiontestDisplayMode  presenter beBoth.  self assert: presenter isDisplayModeBoth.  presenter beIcons.  self assert: presenter isDisplayModeIcons.  presenter beText.  self assert: presenter isDisplayModeTextdoubleClick: arg1  ^self model doubleClick: arg1dragTransformationBlock: arg1  dragTransformationBlock := arg1aboutText: arg1  self deprecated: 'With Spec 2, SpPresenter was refactored to move all window management to WindowPresenter.	From now on, if you want to interact with a window you need to:	- Implement #initializeWindow: method (#initializeDialog: for dialogs) to manage window elements before the presenter is opened	- Use the method #window or #withWindowDo: to interact with windows after it has been opened.'.  self window ifNil: [ aboutText := arg1 ] ifNotNil: [:arg2 |  arg2 aboutText: arg1 ]behavior  ^behaviordefaultIcon  ^self iconNamed: #blankIconpageIndex: arg1  pageIndex := arg1cancelAction  ^cancelActiontestSelectPageIndex  | tmp1 tmp2 |  tmp1 := self mockPage.  tmp2 := SpNotebookPage title: 'test' provider: [ SpButtonPresenter new ].  presenter addPage: tmp1.  presenter addPage: tmp2.  presenter selectPageIndex: 2.  self assert: presenter selectedPage equals: tmp2beShrinkable  shrink := truecontextMenu  ^contextMenuwidth: arg1  self expand: false.  width := arg1notifyPropertyChanged: arg1  self flag: #todo.  (self observablePropertyNamed: arg1) valueChangedselectedBehavior  ^self model selectedBehaviorunselectAllChildren  self children value do: [:arg1 |  arg1 selected: false.        arg1 unselectAllChildren ]passwordLabel: arg1  passwordLabel := arg1classToTest  ^SpMethodBrowserlistSize  ^self dropList listSizepadding  ^self lookupProperty: SpStyleContainer valueOf: #paddingobjectAsLatin1String  | tmp1 tmp2 |  tmp2 := String new: (tmp1 := self object size min: 5000).  tmp2 replaceFrom: 1 to: tmp2 size with: (self object copyFrom: 1 to: tmp1).  ^tmp2testSelectPresenterIndexSetsSelectedIndexInWidget  presenter selectPath: #(1).  self assert: (self adapter selectedPaths includes: #(1))selectDialog  ^selectDialoglabel  ^labelHolder valuebuildWidget  ^MorphTreeMorph new     model: self treeModel;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     spInitializeColumsFrom: self;     hResizing: #spaceFill;     vResizing: #spaceFill;     autoDeselection: self autoDeselection;     resizerWidth: self resizerWidth;     columnInset: self columnInset;     iconBlock: self iconBlock;     rowInset: self rowInset;     keystrokeActionSelector: #keyStroke:;     multiSelection: self multiSelection;     autoMultiSelection: self autoMultiSelection;     removeOnlyLastSelected: self selectOnlyLastHighlighted;     isCheckList: self isCheckList;     doubleClickSelector: #doubleClick;     getMenuSelector: #menu:shifted:;     rowColorForEven: self evenRowColor;     rowColorForOdd: self oddRowColor;     buildContents;     yourselfpageClass  ^SpDemoButtonsPresenterexpandRoots  self treeModel expandRootsselectedObjectDo: arg1  self selectedElement ifNotNil: [:arg2 |  arg1 value: arg2 value ]initialize  self class initializeSlots: self.  selection := #().  super initializeinitialize  super initialize.  action := [  ].  name := ''.  autoRefresh := falsemethodsOn: arg1 do: arg2  methodsListPresenter bindKeyCombination: arg1 toAction: arg2keyPressed: arg1 shift: arg2 meta: arg3 control: arg4 option: arg5  | tmp1 tmp2 tmp3 |  tmp3 := self focusedPresenter adapter widget.  tmp2 := 0.  arg2 ifTrue: [ tmp2 := tmp2 | 8 ].  arg3 ifTrue: [ tmp2 := tmp2 | (Smalltalk os isWin32 | Smalltalk os isUnix ifTrue: [ 2r00010000 ] ifFalse: [ 2r01000000 ]) ].  arg4 ifTrue: [ tmp2 := tmp2 | 2r00010000 ].  arg5 ifTrue: [ tmp2 := tmp2 | (Smalltalk os isWin32 | Smalltalk os isUnix ifTrue: [ 2r01000000 ] ifFalse: [ 2r00100000 ]) ].  tmp1 := KeyboardEvent new setType: #keystroke buttons: tmp2 position: tmp3 position + (1 @ 1) keyValue: arg1 charCode: arg1 hand: self currentWorld activeHand stamp: Time millisecondClockValue.  tmp1 sentTo: tmp3.  10 milliSeconds waitshowOnlyDestination: arg1  showOnlyDestination := arg1testCanAddNewItem  presenter     items: #(1 2 3) asOrderedCollection;     addItemBlock: [ 4 ].  presenter addButton click.  self assertCollection: presenter items hasSameElements: #(1 2 3 4)stateHolder  self deprecated: 'It breaks encapsulation'.  ^stateselectFrom: arg1 to: arg2  self widget selectFrom: arg1 to: arg2selectIndex: arg1  self widget listSelectionIndex: arg1ghostText: arg1  self deprecated: 'This API is too tight to Morph. Use #placeholder: instead.' transformWith: '`@receiver ghostText: `@statement' -> '`@receiver placeholder: `@statement'.  self placeholder: arg1isPlacedAtStart  ^placedAtStarttestBasicLayout  | tmp1 |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1.  self place: label2 at: 1 @ 2.  self place: morph2 at: 2 @ 2.  tmp1 := self newLayout.  tmp1 layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 50 @ 20).  self assert: morph1 bounds equals: (50 @ 0 corner: 100 @ 20).  self assert: label2 bounds equals: (0 @ 20 corner: 50 @ 40).  self assert: morph2 bounds equals: (50 @ 20 corner: 100 @ 40)whenDigitsChangedDo: arg1  self property: #digits whenChangedDo: arg1autoRefresh  ^autoRefreshfromSpec: arg1  | tmp1 tmp2 |  tmp1 := arg1 enabledBlock ifNil: [ arg1 enabled ].  tmp2 := arg1 subMenu ifNotNil: [:arg2 |  SpMenuPresenter new fromSpec: arg2 ].  self     name: arg1 label;     state: arg1 checked;     enabled: tmp1;     icon: arg1 icon;     shortcut: arg1 keyText;     subMenu: tmp2;     action: arg1 actionlongLabel  | tmp1 |  tmp1 := self description.  tmp1 size > 150 ifTrue: [ tmp1 := tmp1 first: 150 ].  ^self label ifNotNil: [:arg1 |  arg1 , ': ' , tmp1 ] ifNil: [ tmp1 ]state  ^statetestRightClickShowsMenu  | tmp1 |  presenter contextMenu: (tmp1 := SpMockMenuPresenter new).  self deny: tmp1 shown.  self emulateRightClick.  self assert: tmp1 shownbeHorizontalAlignmentCenter  self hAlign: SpGridAlignment centerinitializePresenters  text := self newText text: 'Implementing #prepareWindow:, you can add a menu, toolbar and statusBar to your component.BEWARE: This elements will be added just when you will open the presenter as a window or dialog. Otherwise, your component will behave just as another composable presenter.'description: arg1  description := arg1beRowNotHomogeneous  self rowHomogeneous: falsetestValue  self assert: presenter value equals: presentertraverseInFocusOrderDo: arg1  self traverseInFocusOrderDo: arg1 excluding: Set newbuildWidget  ^self subclassResponsibilitylayout: arg1  self applyVisibilitydescription  ^self value printStringLimitedTo: 2000model  ^modelscale  ^scalelayoutBuilder  ^layoutBuilderremove  self okToChange ifFalse: [ ^self ].  self model removeChangeSet: self selectedChangeSet prompting: true.  self updateChangesList.  changesListPresenter resetSelectionbrowseVersions  self currentMethod ifNotNil: [:arg1 |  model browseVersionsFrom: arg1 compiledMethod ]isShowingColumnHeaders  ^showColumnHeaderstestUnselectNonSelectedIndexDoesNotRemovesSelection  presenter     selectIndex: 1;     unselectIndex: 3.  self assert: presenter selection selectedIndex equals: 1selectedPage: arg1  self deprecated: 'Use #selectPage: instead' transformWith: '`@receiver selectedPage: `@statements1' -> '`@receiver selectPage: `@statements1'.  self selectPage: arg1italic  ^italictestSelectItemOutsideRangeUnsetsSelectedPath  presenter selectItem: 4000.  self assert: presenter selection selectedPath equals: #()newIconButtonAction: arg1 with: arg2 iconSelector: arg3  ^IconicButton new     target: self;     actionSelector: arg1;     arguments: {arg2};     labelGraphic: (self iconNamed: arg3);     color: Color transparent;     extent: 16 @ 8;     borderWidth: 0;     yourselflabel  ^labelextent  ^self lookupProperty: SpStyleGeometry valueOf: #extentpopMessage  self message: nil.  self changed: #popMessageleftOffset: arg1  ^0subMenu  ^self newMenu     addItem: [:arg1 |  arg1           name: 'Open';           icon: (self iconNamed: #openIcon);           shortcut: $o meta;           action: [ self inform: 'Open' ] ];     addItem: [:arg1 |  arg1           name: 'Save';           icon: (self iconNamed: #smallSaveIcon);           shortcut: $s meta;           action: [ self inform: 'Save' ] ];     addItem: [:arg1 |  arg1           name: 'Print';           shortcut: $p meta;           icon: (self iconNamed: #smallPrintIcon);           action: [ self inform: 'Print' ] ];     addItem: [:arg1 |  arg1           name: 'Close';           shortcut: $c meta;           icon: (self iconNamed: #smallCancelIcon);           action: [ self inform: 'Kill' ] ];     yourselfstepTime  ^1500displaySymbol: arg1  displaySymbol := arg1.  entityText entryCompletion: self entitiesEntryCompletionselectedPath  ^self selectedPaths firstinitialize  super initialize.  self beBoth.  leftItems := OrderedCollection new.  rightItems := OrderedCollection newgetIconFor: arg1  ^self model getIconFor: arg1asButtonPresenter  self flag: #TODO.  ^SpButtonPresenter new     label: self name;     help: self description;     in: [:arg1 |  self hasIcon ifTrue: [ arg1 iconName: self iconName ] ];     action: [ self execute ] yourselfbrowseSelectedObject  self selectedObjectDo: [:arg1 |  arg1 browse ]label  ^labelconfigureWindows: arg1  updateMenu  autoRefresh  ^autoRefreshinspectionMenu: arg1  self hasSelectedObject ifFalse: [ ^arg1 ].  self inspectionSubMenu: arg1.  self selectedElement inspectionMenu: arg1.  ^arg1testResettingMillerListRemovesWidgets  3 timesRepeat: [ self presenter addPresenter: (SpNullMillerPresenter on: SpLabelPresenter new) ].  self presenter resetTo: 0.  self assert: self adapter childrenWidgets isEmptycontents: arg1  contents := arg1dynamicPresenter  ^dynamicPresentercommandClass  ^self subclassResponsibilityx  ^xclassesOn: arg1 do: arg2  classesListPresenter bindKeyCombination: arg1 toAction: arg2initialize  super initialize.  self initializeSemaphoreexecute  self contactBookPresenter removeContact: self selectedContact.  self contactBookPresenter updateViewtakeKeyboardFocus  ^self tree takeKeyboardFocuswhenDisplaySymbolChanged: arg1  self property: #displaySymbol whenChangedDo: arg1title: arg1  selectIndexes: arg1  arg1 ifEmpty: [ ^self unselectAll ].  self selectIndex: arg1 firstsource  ^[ self model source ]acceptOnCR: arg1  acceptOnCR := arg1isDisplayModeText  ^self displayMode = SpToolBarDisplayMode modeLabelnewToolbarItemFont  | tmp1 |  tmp1 := self theme buttonFont.  ^LogicalFont familyName: tmp1 familyName pointSize: tmp1 pointSize - 3menuGroup  ^self presenter menuGrouptestSetSelectItemRaisesSelectionChangeEventWithSelectedItem  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter selectItem: 20.  self assert: tmp1 equals: 20classToTest  ^SpFastTablePresentertempIndex  ^tempIndextestClearSelection  self initializationText.  self openInstance.  presenter selectionInterval: (1 to: 10).  self assert: presenter selectionInterval equals: (1 to: 10).  presenter clearSelection.  self assert: presenter selectionInterval isEmptybeVertical  direction := SpLayoutDirection verticaltestActivationOnDoubleClickShouldActivateOnDoubleClick  | tmp1 |  presenter     activateOnDoubleClick;     whenActivatedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter doubleClickAtPath: #(1 2 1).  self assert: tmp1 equals: 110isInWorld  ^falseshowOptions: arg1  self widgetDo: [:arg2 |  arg2 showOptions: arg1 ]title: arg1  title := arg1asSpecCommand  ^super asSpecCommand     shortcutKey: $r meta;     yourselfcommands: arg1  commands := arg1inspectActionOfSelectedShortcut  | tmp1 tmp2 |  tmp1 := self kmTable selection selectedItem ifNil: [ ^self ].  tmp2 := tmp1 realValue keymap ifNil: [ ^self ].  tmp2 inspectselectedItem  ^tree selectedItemasSpLayout  ^selfnewWidgetOn: arg1  ^arg1 newVerticalmodel  ^modeldoubleClick  ^self model doubleClickwindowIsClosing  isClosed := true.  self presenter windowIsClosinginitializeTestedInstance  presenter presenter: SpLabelPresenter newfromSton: arg1  arg1 parseMapDo: [:arg2 :arg3 |  self perform: arg2 asMutator with: arg3 ]whenListChanged: arg1  listPresenter whenListChanged: arg1container: arg1  container value: arg1execute  self browserClientProvider browseAllImplementorsOf: self selectorinitializeWindow: arg1  arg1     title: self title;     initialExtent: self initialExtent;     windowIcon: self windowIcon;     askOkToClose: self askOkToClose;     aboutText: self aboutTextwhenTreeUpdatedDo: arg1  treeUpdated whenChangedDo: arg1inspectPrevious  history hasPrevious ifFalse: [ ^self ].  self inspectHistoryItem: history previousdirection  ^directionsetModelBeforeInitialization: arg1  self setAnnouncingObject: arg1morphicTabsFor: arg1  ^(arg1 adapter widget submorphs detect: [:arg2 |  arg2 class = TabBarMorph ]) tabsisInitialStateSet  ^initialStateSetinitialize  super initialize.  self class initializeSlots: selfhasScrollBars  ^wrapScrollBarslistElementAt: arg1 ifAbsent: arg2  ^self model listElementAt: arg1 ifAbsent: arg2getMenu  self flag: #TODO.  ^(PragmaMenuBuilder pragmaKeyword: self textArea editingModeClass menuKeyword model: self adapter) menucurrentActivated  ^currentActivated valuedate  ^datelayout: arg1  layout := arg1.  widget ifNil: [ widget := arg1 direction newWidgetOn: self.        widget borderWidth: arg1 borderWidth.        widget submorphs do: [:arg2 |  arg2 cellInset: arg1 spacing ] ].  super layout: arg1customSubMenu: arg1  arg1 addGroup: [:arg2 |  arg2 addItem: [:arg3 |  arg3                 name: 'Inst var refs...';                 action: [ self browseInstVarRefs ] ].        arg2 addItem: [:arg3 |  arg3                 name: 'Inst var defs...';                 action: [ self browseInstVarDefs ] ].        arg2 addItem: [:arg3 |  arg3                 name: 'Class var refs...';                 action: [ self classVarRefs ] ].        arg2 addItem: [:arg3 |  arg3                 name: 'Class variables';                 action: [ self browseInstClassVariables ] ].        arg2 addItem: [:arg3 |  arg3                 name: 'Class refs';                 action: [ self browseClassRefs ] ] ]button  ^self dropListButton buttonsetUp  super setUp.  presenter     addColumn: (SpStringTableColumn title: 'Value' evaluated: #printString);     beMultipleSelection;     roots: #(1 2 3);     children: [:arg1 |  arg1 < 100 ifTrue: [ {(arg1 * 2) .               (arg1 * 3) .               (arg1 * 10)} ] ifFalse: [ #() ] ];     yourselfrefreshWidgetHeaderTitle  self presenter hasHeaderTitle ifTrue: [ self widget columns first model title: self presenter headerTitle.        self widget           showColumnHeaders;           refresh ] ifFalse: [ self widget columns first model title: nil.        self widget           hideColumnHeaders;           refresh ]initializePresenters  super initializePresenters.  self content: SpListPresenterunselectItem: arg1  [ self unselectPath: (self pathOf: arg1) ] on: NotFound do: [  ]size: arg1  size := arg1model: arg1  model := arg1selectItem: arg1  [ self selectPath: (self pathOf: arg1) ] on: NotFound do: [ self itemNotFoundAction ]label  ^self addShortcutTipFor: labelsendersMethod  self method ifNotNil: [:arg1 |  self model browseSendersOfMessagesFrom: arg1 selector ]whenPresentersChangedDo: arg1  self whenModelChangedDo: arg1beNotHomogeneous  self homogeneous: falseclearContent  self text: ''buildChangeList  rgMethod sourcePointer ifNil: [ ^#() ].  ^(SourceFiles changeRecordsFrom: rgMethod sourcePointer className: rgMethod instanceSideParentName isMeta: rgMethod isMetaSide) collectWithIndex: [:arg1 :arg2 |  | tmp1 |        tmp1 := arg1 asRingDefinition.        tmp1 annotationNamed: #versionIndex put: arg2 ]pageClass  ^SpDemoTextInputPresenterinitializePrivateValueHolders  askOkToClose := false.  titleHolder := self class titleadapterBindingsClass  ^SpStubAdapterBindingstype  ^typefillWith: arg1  methodList items: arg1 methods.  ^protocolList items: (arg1 protocols collect: [:arg2 |  arg1 organization protocolOrganizer protocolNamed: arg2 ])onWidgetBuilt  ^self selectedItems: selectionHolder valuefieldEncrypted: arg1  fieldEncrypted := arg1initializePresenters  browseModel := self newButton.  usersModel := self newButton.  sendersModel := self newButton.  implementorsModel := self newButton.  versionModel := self newButton.  dropListModel := self newDropList.  self     setFocusOrder;     setBrowseModel;     setUsersModel;     setVersionModel;     setSendersModel;     setImplementorsModeleventKeyStrokesForPreviousFocus  ^{Character tab shift asKeyCombination}setUp  super setUp.  biChooseMethod := SpChooseMethodUI newpossibleEntities: arg1  possibleEntities := arg1.  entityText entryCompletion: self entitiesEntryCompletionghostText  self deprecated: 'This API is too tight to Morph. Use #placeholder instead.' transformWith: '`@receiver ghostText' -> '`@receiver placeholder'.  ^self placeholderdelegateTo: arg1  delegation := arg1ghostText: arg1  self deprecated: 'This API is too tight to Morph. Use #placeholder: instead.' transformWith: '`@receiver ghostText: `@statement' -> '`@receiver placeholder: `@statement'.  self placeholder: arg1testSelectAllSelectsAllItems  presenter selectAll.  self assert: presenter selection selectedItems asSet equals: presenter model items asSettestSelectPage  | tmp1 tmp2 |  tmp1 := self mockPage.  tmp2 := SpNotebookPage title: 'test' provider: [ SpButtonPresenter new ].  presenter addPage: tmp1.  presenter addPage: tmp2.  presenter selectPage: tmp2.  self assert: presenter selectedPage equals: tmp2initialize  super initialize.  self initializeTSearchable.  autoDeselect := true.  allowToSelect := true.  display := [:arg1 |  arg1 asStringOrText ]testWithoutSyntaxHighlight  presenter withoutSyntaxHighlight.  self deny: self adapter hasSyntaxHighlightEnabledprintOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  arg1 nextPutAll: name.  arg1 nextPut: $)gender: arg1  gender := arg1borderWidth  ^borderWidthconfigureItem: arg1 morph: arg2 toolBar: arg3  arg2     font: arg3 toolbarItemFont;     width: arg3 toolbarItemSize.  arg3 displayMode configureMorph: arg2 item: arg1.  ^arg2scaleValue: arg1  ^((arg1 - self min) / (self max - self min)) asFloatselectedObject  ^self subclassResponsibilitytestOpenPresenterIsDisplayed  self openInstance.  self assert: presenter isDisplayedinitializePresenters  button1 := self newRadioButton.  button2 := self newRadioButton.  button3 := self newRadioButton.  label := self newLabel.  button1 associatedRadioButtons: {button2 .         button3}.  button1 label: 'Button 1'.  button2 label: 'Button 2'.  button3 label: 'Button 3'.  self updateLabelinitializePresenters  list := self newList.  label := self newLabel.  list items: #(1 2 3)testUnselectSelectedItemRemovesSelection  presenter     selectItem: 10;     unselectItem: 10.  self assert: presenter selection isEmptyselector: arg1  selector := arg1columns  ^self model columns collect: [:arg1 |  arg1 buildWithSpec ]passwordInput  ^passwordInputtestActivateDoesNotRaiseDeactivateEvent  presenter state: false.  self assertWith: [:arg1 |  arg1 = 1 ] timesRaisedEvent: #whenDeactivatedDo: inPresenter: presenter whenDoing: [ presenter state: true ]reset  self value: self minremovePostscriptFrom: arg1  (arg1 hasPostscript and: [ arg1 postscriptHasDependents ]) ifTrue: [ ^self inform: 'Cannot remove the postscript rightnow because there is at least onewindow open on that postscript.Close that window and try again.' ].  arg1 removePostscriptpresenterBlock: arg1  presenterBlock := arg1autoRefresh: arg1  autoRefresh := arg1label  ^labelselectIndex: arg1  self selection selectIndex: arg1.  self selection selectedItem valuecreateRingMethodForSelector: arg1 inClass: arg2  (arg2 includesSelector: arg1) ifTrue: [ ^arg2 compiledMethodAt: arg1 ].  ^self createRingMethodForRemovedSelector: arg1 inClass: arg2registerEvents  super registerEvents.  self whenScrollValueChangedDo: [:arg1 |  self changed: #setScrollValue: with: {arg1} ]columnsCount  ^columnsCounttree  ^treechildren: arg1  children value: arg1displayBlock: arg1  self deprecated: 'Please use #display: instead' transformWith: '`@receiver displayBlock: `@arg' -> '`@receiver display: `@arg'.  ^self dropList display: arg1behavior  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8testSmokeHorizontalTest  self presenter beHorizontaltransmission  ^self selectedItemsimage1  ^image1allChanges  ^ChangeSet allChangeSets reversesubpresenterOrLayoutNamed: arg1 of: arg2  ^arg2 additionalSubpresentersMap at: arg1 ifAbsent: [ arg2 presenterAt: arg1 ifAbsent: [ self error: 'No presenter named "' , arg1 , '" was found in ' , arg2 printString ] ]isResizable  ^self model isResizablex: arg1  x := arg1filterField: arg1  filterField := arg1filterWith: arg1  self widgetDo: [:arg2 |  | tmp1 |        tmp1 := arg2 model rootNodes.        tmp1 do: [:arg3 |  arg3 nodeModel updateAccordingTo: arg1 ].        self removeRootsSuchAs: [:arg4 |  (arg1 keepTreeNode: arg4) not and: [ arg4 isEmpty ] ].        self changed: #rootNodes ]initialize  super initialize.  adapterBindings := self adapterBindingsClass newrequest: arg1 initialAnswer: arg2 title: arg3  | tmp1 |  tmp1 := UIManager default request: arg1 initialAnswer: arg2 title: arg3.  tmp1 ifNil: [ SpInteractionCancelled signal ].  ^tmp1headerIcon  ^headerIcon valuestyleOf: arg1  ^arg1 valueOfProperty: #stylebadgeTextColor  ^self theme badgeTextColoraboutToStyleBlock  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8dragTransformationBlock  ^self model dragTransformationBlocksetUp  super setUp.  builder := SpDynamicPresentersListBuilder newrefreshWidgetSelection  | tmp1 |  tmp1 := self presenter selection selectedIndexes.  tmp1 = self widget selectedIndexes ifTrue: [ ^self ].  tmp1 isEmpty ifTrue: [ self widget basicSelectIndexes: #() ] ifFalse: [ self widget basicSelectIndexes: tmp1 ].  ^self widget refreshbuildAdapterFor: arg1 bindings: arg2  ^arg1 needRebuild ifTrue: [ self adapt: arg1 bindings: arg2 ] ifFalse: [ arg1 needRebuild: true.        arg1 adapter ifNil: [ self adapt: arg1 bindings: arg2 ] ifNotNil: [:arg3 |  arg3 isRedrawable ifTrue: [ arg3 removeSubWidgets ].              arg3 ] ]searchText: arg1  arg1 isEmptyOrNil ifTrue: [ ^#() ].  ^Array streamContents: [:arg2 |  self elements withIndexDo: [:arg3 :arg4 |  (self model performSearch: arg3 matching: arg1) ifTrue: [ arg2 nextPut: arg4 ] ] ]presentersInFocusOrder  ^self itemstable  ^tablepositionPoint: arg1  ^self position: arg1 x @ self topwhenRetrievedDo: arg1  retrievedBlock := arg1setContentsOfChangeSet: arg1 forClass: arg2 andSelector: arg3  arg2 ifNil: [ ^self buildChangeSetDescriptionFor: arg1 ].  arg3 ifNil: [ ^self buildClassDescriptionFor: arg1 class: arg2 ] ifNotNil: [ ^self buildSelectorDescriptionFor: arg1 class: arg2 selector: arg3 ]includesItems: arg1  ^arg1 allSatisfy: [:arg2 |  self selectedItems includes: arg2 ]presenter  ^presenterlabel: arg1  label := arg1rememberMe  ^rememberMerefresh  self flag: #TODOisBuilt  ^self isDisplayedconfigureWith: arg1 item: arg2  arg1 configureButton: self item: arg2removeSubWidgets  widget submorphs first removeAllMorphs.  widget submorphs second removeAllMorphswrappedObject: arg1  wrapped := arg1whenGhostTextChanged: arg1  self deprecated: 'This API is too tight to Morph. Use #whenPlaceholderChanged: instead.' transformWith: '`@receiver whenGhostTextChanged: `@statement' -> '`@receiver whenPlaceholderChanged: `@statement'.  self whenPlaceholderChangedDo: arg1refresh  description hasUnacceptedEdits ifTrue: [ ^self ].  description getSelection size = 0 ifTrue: [ self           refreshDescription;           updateList ]testCanRemoveSelectedItem  presenter     items: #(1 2 3) asOrderedCollection;     selectItem: 2.  presenter removeButton click.  self assertCollection: presenter items hasSameElements: #(1 3)state  ^self model statevisibleIf: arg1  visible := arg1isEditable  ^editableclassVarRefs  ^self systemNavigation browseClassVarRefs: self hostClassaddMenuGroup: arg1  arg1 owner: self.  groups add: arg1.  self autoRefresh ifNotNil: [ arg1 autoRefresh: self autoRefresh ]disableSearch  searchEnabled := falseclassToTest  ^SpMenuItemPresentercontent  ^content valuetitle  ^self model titleadd: arg1  self add: arg1 constraints: SpLayoutConstraints newclassToTest  ^SpLinkPresentervisitCommand: arg1  arg1 positionStrategy addButton: arg1 asButtonPresenter toActionBar: self actionBarPresenterdisable  self enabled: falsebuttonNormal: arg1  buttonNormal := arg1value  ^self sliderInput valueplaceholder: arg1  self input placeholder: arg1selectionOrLine  ^self selection ifEmpty: [ self selectLine ]validateApplicationOfPresenter: arg1  arg1 application == self ifFalse: [ SpInvalidApplicationError signal: 'The requested presenter has a different application' ]contents: arg1  self basicAt: 1 put: arg1state  | tmp1 |  tmp1 := self model state.  ^(tmp1 isBlock or: [ tmp1 isMessageSend ]) ifTrue: [ tmp1 cull: self model ] ifFalse: [ tmp1 ]beOk  cancelled := falsechangesMenu: arg1  changesListPresenter contextMenu: arg1redSlider  ^redSliderbutton  ^buttonwidget  ^widgetactionToPerformHolder  self deprecated: 'Spec should not provide a way to get its internals. actionToPerform is not a value holder anymore but an observable slot, thus, this method cannot return anything anymore.'setModelBeforeInitialization: arg1  isClosed  ^isClosedaddLast: arg1  self addLast: arg1 withConstraints: [:arg2 |   ]selectionHolder  ^self observablePropertyNamed: #selectedIndexeslistSize  self dropList listSizeremoveEntryCompletion  ^self input removeEntryCompletionadd: arg1  self add: arg1 withConstraints: [:arg2 |   ]toggleState  self state: self state notadd: arg1 toWindow: arg2  arg2 addMorph: arg1 fullFrame: LayoutFrame identityabstractAdapterClass  ^SpStubAbstractAdapternewRow: arg1 height: arg2  self newRow: arg1 origin: 0 @ 0 corner: 1 @ 0 offsetOrigin: 0 @ 0 offsetCorner: 0 @ arg2beNotResizable  resize := falseconnectPresenters  super connectPresenters.  cancelButton action: [ self performCancelAction ]testRadio2StartsSelected  self assert: self presenter radio2 statebuildWidget  widget := ToolDockingBarMorph new     hResizing: #spaceFill;     vResizing: #spaceFill;     yourself.  self menuGroups doWithIndex: [:arg1 :arg2 |  self adoptMenuGroupModel: arg1 first: arg2 = 1 ].  ^widgetaction  ^actiontestSelectPresenterIndexOutsideRangeUnsetsSelectedIndexInWidget  presenter selectIndex: 100.  self assert: self adapter selectedIndexes isEmptyinput  ^inputsetRoots: arg1  treeModel rootItems: arg1testSelectIndexesAddsItemsToSelectedItemList  presenter selectIndexes: {1 .         2}.  self assert: (presenter selection includesItems: {10 .               20})isEmpty  ^self selectedIndexes isEmptyinitializeTestedInstance  super initializeTestedInstance.  presenter     beMultipleSelection;     items: {10 .         20 .         30 .         'aaa' asText}testUpdateModel  | tmp1 tmp2 |  tmp1 := SpTestingPointModel x: 40 y: 54.  tmp2 := SpTestingPresenterWithModel on: tmp1.  self assert: tmp2 x text equals: tmp1 x asString.  self assert: tmp2 y text equals: tmp1 y asString.  tmp1     x: 1;     y: 2.  tmp1 valueChanged.  self assert: tmp2 x text equals: tmp1 x asString.  self assert: tmp2 y text equals: tmp1 y asStringwantsVisualFeedback: arg1  wantsVisualFeedback := arg1iconFor: arg1  ^iconBlock value cull: arg1 content cull: arg1selectedItem  ^self dropList selectedItemconnectPresenters  super connectPresenters.  checkbox whenActivatedDo: [ notebook addPage: (dynamicPage := self dynamicPage) ].  checkbox whenDeactivatedDo: [ dynamicPage ifNotNil: [:arg1 |  notebook removePage: arg1.              dynamicPage := nil ] ]addFocusRotationKeyBindings  whenBuiltDo: arg1  self announcer when: SpWidgetBuilt do: arg1action  ^actionclassToTest  ^SpDynamicMockPresentertestSelectPathAddsItemToSelectedItemList  presenter selectPath: #(1 3).  self assert: (presenter selection includesItem: 10)imageForm  ^(PNGReadWriter on: (ZnBase64Encoder new decode: PolymorphSystemSettings pharoLogoContents) readStream) nextImagevalue: arg1  slider value: arg1initialize  super initializesetUp  super setUp.  treeWithItems := self modelClass new.  treeWithItems roots: #(#first #second #third #fourth #fifth)autoDeselect: arg1  self widgetDo: [:arg2 |  arg2 autoDeselect: arg1 ]minExtent  ^minExtentbuildWidget  ^FTPluggableIconListMorphAdaptor new     model: self model;     hideColumnHeaders;     beResizable;     columns: self model columns;     getListSizeSelector: #listSize;     getListElementSelector: #listElementAt:;     getIndexSelector: #getIndex;     setIndexSelector: #setIndex:;     getIconSelector: #getIconFor:;     resetListSelector: #resetListSelection;     getMenuSelector: #menu:shifted:;     setMultipleSelection: self model selection isMultipleSelection;     doubleClickSelector: #doubleClick:;     basicWrapSelector: #wrapItem:;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     setBalloonText: self help;     hResizing: #spaceFill;     vResizing: #spaceFill;     selectIndex: 1;     enableFilter: FTSubstringFilter;     explicitFunction;     yourselfwhenEnabledChanged: arg1  self deprecated: 'Use #whenEnabledChangedDo: instead.' transformWith: '`@receiver whenEnabledChangedDo: `@statements' -> '`@receiver whenEnabledChangedDo: `@statements'.  self whenEnabledChangedDo: arg1contents  ^contentstestInstVarNamesAndPresenterNamesArray  builder     modelObjects: {3 .         2 .         1};     presenterBlock: [:arg1 |  SpButtonPresenter ].  self assertCollection: builder instVarNamesAndPresenterNamesArray hasSameElements: #(var1 #SpButtonPresenter var2 #SpButtonPresenter var3 #SpButtonPresenter)whenSelectionChanged: arg1  self list whenSelectionChanged: arg1fixed  ^fixedisVertical  ^self direction = SpLayoutDirection verticaldisplayBlock: arg1  self dropList display: arg1whenTreeUpdated: arg1  self deprecated: 'Use #whenTreeUpdatedDo: instead.' transformWith: '`@receiver whenTreeUpdated: `@statements' -> '`@receiver whenTreeUpdatedDo: `@statements'.  self whenTreeUpdatedDo: arg1testSelectItemsOutsideRangeHasNoSelectedIndexes  presenter selectItems: {300 .         400}.  self assert: presenter selection selectedIndexes isEmptyupdatePresenter  toolbarModel  self deprecated: 'Use #toolbarPresenter instead' transformWith: '`@receiver toolbarModel' -> '`@receiver toolbarPresenter'.  ^self toolbarPresenterisOk  ^self isCancelled notdirection  ^directiontransferBlock: arg1  transferBlock := arg1initializePresenters  okButton := self newButton.  self registerOkButtonEvents.  self focusOrder add: okButtonbuildWidget  ^SpMorphPresenter new     morph: self currentWorld;     yourselfacceptDroppingMorph: arg1 event: arg2 inMorph: arg3  ^self acceptDropBlock cull: arg1 model model cull: arg2 cull: arg3 model modelitems: arg1  ^self dropList items: arg1canTakeKeyboardFocus  ^falseselection  ^selectionmorph: arg1  morph := arg1whenWindowChanged: arg1  self flag: #TODO.  self announcer when: SpWindowBuilt do: [:arg2 |  arg1 cull: arg2 model ]items  ^#('item 1' 'item 2' 'item 3' 'item 4' 'item 5')selectedItem  ^selectionHolder value ifEmpty: [ nil ] ifNotEmpty: [:arg1 |  arg1 last ]value  ^valueobject: arg1  Smalltalk garbageCollect.  super object: (EyePointerWrapper wrap: arg1)value  ^valuebuttons  ^buttonsforeground: arg1  foreground := arg1retrievingBlock  ^retrievingBlockHolder valuetestJulianDaysIntervalFor  | tmp1 |  tmp1 := calendar julianDaysIntervalFor: (Date year: 2018 month: 9 day: 15).  self     assert: tmp1 size equals: calendar daysToDisplayCount;     assert: tmp1 equals: ((Date year: 2018 month: 8 day: 26) julianDayNumber to: (Date year: 2018 month: 10 day: 6) julianDayNumber)doItReceiver: arg1  self deprecated: 'This method is an horrible hack because the VersionBrowser was using Code or Diff presenter but was only using the API of the Code presenter... This method and other methods from the CodePresenter API will be removed.'inspectInNewWindow: arg1  arg1 inspectdragEnabled  ^self presenter dragEnabledautoDeselection  ^self model autoDeselectionaddSpecialFields: arg1  assertWith: arg1 timesRaisedEvent: arg2 inPresenter: arg3 whenDoing: arg4  | tmp1 |  tmp1 := 0.  arg3 perform: arg2 with: [ tmp1 := tmp1 + 1 ].  arg4 value.  arg1 value: tmp1selectedMessage  ^messageList selectedMessageselectPaths: arg1  self selectPath: arg1 lasticonFor: arg1  ^self icons cull: arg1 cull: selfcolor: arg1  self widget ifNotNil: [:arg2 |  arg2 == self ifFalse: [ super color: arg1 ] ]buildChangeSetDescriptionFor: arg1  ^arg1 ifNil: [ '' ] ifNotNil: [ arg1 preambleString ifNil: [ '' ] ]addPaneHSplitterBetween: arg1 and: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 |  arg1 ifEmpty: [ ^self ].  tmp1 := arg1 first layoutFrame bottomFraction.  tmp2 := arg1 select: [:arg3 |  arg3 layoutFrame topFraction = arg3 layoutFrame bottomFraction ].  tmp6 := ((arg1 reject: [:arg3 |  arg3 layoutFrame topFraction = arg3 layoutFrame bottomFraction ]) asSortedCollection: [:arg4 :arg5 |  arg4 layoutFrame rightFraction = arg5 layoutFrame rightFraction ifTrue: [ arg4 layoutFrame leftFraction <= arg5 layoutFrame leftFraction ] ifFalse: [ arg4 layoutFrame rightFraction <= arg5 layoutFrame rightFraction ] ]) readStream.  tmp6 contents ifEmpty: [ ^tmp2 ].  tmp8 := OrderedCollection new.  tmp3 := tmp6 contents first layoutFrame leftFraction.  [ tmp6 atEnd or: [ tmp7 := tmp6 next.        tmp7 layoutFrame leftFraction ~= tmp3 and: [ tmp7 layoutFrame rightFraction ~= tmp3 ] ] ] whileFalse: [ tmp8 add: tmp7.        tmp3 := tmp7 layoutFrame rightFraction ].  tmp4 := tmp8 first layoutFrame.  tmp5 := tmp8 last layoutFrame.  tmp9 := (arg2 reject: [:arg3 |  arg3 layoutFrame topFraction = arg3 layoutFrame bottomFraction ]) select: [:arg3 |  (arg3 layoutFrame leftFraction between: tmp4 leftFraction and: tmp5 rightFraction) or: [ arg3 layoutFrame rightFraction between: tmp4 leftFraction and: tmp5 rightFraction ] ].  tmp11 := (tmp8 collect: [:arg3 |  arg3 layoutFrame bottomOffset ]) max.  tmp10 := ProportionalSplitterMorph new beSplitsTopAndBottom.  tmp10 layoutFrame: ((tmp4 leftFraction @ tmp1 corner: tmp5 rightFraction @ tmp1) asLayoutFrame           leftOffset: tmp4 leftOffset;           rightOffset: tmp5 rightOffset;           topOffset: tmp11;           bottomOffset: 4 + tmp11).  tmp8 := tmp8 , tmp2.  tmp8 do: [:arg3 |  tmp10 addLeftOrTop: arg3 ].  tmp9 do: [:arg3 |  tmp10 addRightOrBottom: arg3 ].  self addMorphBack: tmp10.  ^tmp8searchValueOf: arg1  ^arg1 asStringapplyStyleTo: arg1 inContext: arg2  self prepareWithinContext: arg2.  ^self applyStyleTo: arg1topOffset: arg1  ^0initialize  super initialize.  self selector: #add:.  layoutFrame := SpLayoutFrame identityconnectPresenters  buttonWithShortcut action: [ self inform: 'button with shortcut pressed' ]save: arg1  self host at: self index put: arg1initializePresenters  slider := self instantiate: SpSliderPresenter.  input := self instantiate: SpTextInputFieldPresenter.  self focusOrder add: inputnewVertical  ^self newPanel     listDirection: #topToBottom;     yourselfbuildWidget  widget := self basicMenuPopUp.  self menuGroups do: [:arg1 |  | tmp1 |        tmp1 := arg1 buildWithSpec.        tmp1 do: [:arg2 |  widget addMorphBack: arg2 ] ] separatedBy: [ widget addLine ].  ^widgetstyleExtent: arg1  | tmp1 |  tmp1 := SpStyleSTONReader fromString: ('.application [ Geometry \{ #width: {1}, #height: {2} \} ]' format: {arg1 x .               arg1 y}).  ^SpMorphStyle newStyles: tmp1 flattenClassesresizableChanged  self widgetDo: [:arg1 |  arg1 resizable: self resizable ]surfaceExtent: arg1  surfaceExtent := arg1testNestedLayoutModifiesHeightOfTopLayout  | tmp1 tmp2 tmp3 |  tmp1 := SpBoxLayoutWithTableForTestPresenter new.  tmp2 := SpLabelPresenter new     label: 'Test';     yourself.  tmp3 := SpBoxLayout newVertical     add: (SpBoxLayout newHorizontal add: tmp2 expand: false fill: false padding: 0) expand: false fill: false padding: 0;     yourself.  tmp1 buildAdapterWithSpecLayout: tmp3.  self assert: tmp2 adapter widget owner owner height equals: tmp2 adapter widget heightsubMenu  ^subMenuname  ^nameaboutToStyleBlock: arg1  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8arguments  ^self subclassResponsibilityrootForItems: arg1  ^FTRootItem new     data: arg1;     yourselftransmitPort: arg1 do: arg2  self newTransmission     from: self port: arg1;     do: arg2;     applytestSelectIndexSetsSelectedIndex  presenter selectIndex: 1.  self assert: presenter selection selectedIndex equals: 1entityText  ^entityTextpresenter  ^presenterinitializePresenters  super initializePresenters.  self content: SpTextInputFieldPresenterdoItContext: arg1  self deprecated: 'This has been moved to specific presenters (check children)' on: '2019-04-15' in: #Pharo8menu: arg1  self deprecated: 'Use #contextMenu instead.' transformWith: '`@receiver menu: `@argument' -> '`@receiver contextMenu: `@argument'.  self contextMenu: arg1when: arg1 do: arg2  classShortcuts: arg1 from: arg2  self selectedClass ifNotNil: [ arg1 keyString = '<Cmd-b>' ifTrue: [ ^self browseMethodFull ].        arg1 keyString = '<Cmd-d>' ifTrue: [ ^self forgetClass ].        arg1 keyString = '<Cmd-x>' ifTrue: [ ^self removeClass ] ]splitsTopAndBottom  ^self isHorizontalopenWithSpec: arg1  self buildWithSpec: arg1.  self updateTitlebuildWidget  ^PanelMorph new     layoutPolicy: TableLayout new;     vResizing: #spaceFill;     hResizing: #spaceFill;     yourselfwhenModelChangedDo: arg1  listModel whenModelChangedDo: arg1placeAtStart  placeAtStart := truetestSelectPresenterItemSetsSelectedIndexInWidget  self skiptestAdapterForBindingsRaiseErrorIfNoBinding  | tmp1 |  tmp1 := SpAbstractWidgetLayout for: #NonExistingAdapter.  self should: [ tmp1 adapterFor: SpListPresenter new bindings: SpStubAdapterBindings new ] raise: Errortable  ^tablesave: arg1  self host instVarNamed: self instVarName put: arg1testUnselectSelectedPathRaisesSelectionEventOnce  | tmp1 |  tmp1 := 0.  presenter     selectPath: #(1 2);     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectPath: #(1 2).  self assert: tmp1 equals: 1form: arg1  form := arg1updateMessagesList  | tmp1 |  tmp1 := methodsListPresenter selectedItem.  self selectedClass ifNil: [ methodsListPresenter items: {} ] ifNotNil: [:arg1 |  methodsListPresenter items: (self selectedChangeSet selectorsInClass: arg1 name) sort ].  methodsListPresenter setSelectedItem: tmp1selectedMethod  ^methodList selectedItemenabled: arg1  super enabled: arg1.  self changed: #enabledtestSelectWidgetIndexRaisesSelectionIndexChangeEventOnce  | tmp1 |  tmp1 := 0.  presenter selection whenChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  self adapter selectIndex: 1.  self assert: tmp1 equals: 1basicAdd: arg1 constraints: arg2 to: arg3  | tmp1 |  tmp1 := self buildMorph: arg1 constraints: arg2.  arg3 addMorphBack: tmp1.  ^tmp1setRefreshingBlockForSendersOf: arg1  | tmp1 |  tmp1 := Smalltalk specialSelectorIndexOrNil: arg1.  self refreshingBlock: [:arg2 |  arg2 hasSelector: arg1 specialSelectorIndex: tmp1 ]useNextInspectorType  self inspectorType: self nextInspectorTypeabsoluteValueToValue: arg1  ^self min + (arg1 * (self max - self min)) roundTo: self quantumlastClicked: arg1  lastClicked value: arg1pathOf: arg1  ^(self pathOf: arg1 from: presenter roots) ifNil: [ NotFound signalFor: arg1 in: presenter roots ]subscriptions: arg1  subscriptions := arg1add: arg1  self add: arg1 withConstraints: [:arg2 |   ]testUnselectAllUnselectsall  presenter     selectPath: #(1 2);     unselectAll.  self assert: presenter selection isEmptyisCentered  ^centereddaysLabelsBuilder  ^SpDynamicPresentersListBuilder new     modelObjects: self dayNames;     presenter: SpLabelPresenter configuredAs: [:arg1 :arg2 |  arg1 label: arg2 ];     layoutBuilder: (SpDynamicLeftToRightColumnsLayout columns: self daysInAWeek);     yourselfinitializePresenters  moreOptionsText := 'More options' asText.  lessOptionsText := 'Less options' asText.  moreOptionsButton := self newButton label: moreOptionsTexttestShouldAcceptFloatWithoutMinMax  presenter     beFloat;     digits: 3;     maximum: nil;     minimum: nil.  self assert: (adapter shouldAccept: '').  self assert: (adapter shouldAccept: '100').  self assert: (adapter shouldAccept: '100.1').  self assert: (adapter shouldAccept: '80.1').  self assert: (adapter shouldAccept: '150.1').  self deny: (adapter shouldAccept: 'string').  self deny: (adapter shouldAccept: '10string')presenter  ^presenterisWindowPresenter  ^falsetransferFor: arg1 from: arg2  ^(self model transferFor: arg1 from: self table) buildWithSpechasContents  hasContents isBlock ifTrue: [ ^hasContents value ].  ^self childrenItems notEmptyitems: arg1  associationsWrapperToItem removeAll.  pickedItemsHolder removeAll.  listPresenter items: (arg1 collectWithIndex: [:arg2 :arg3 |  self wrap: arg2 at: arg3 ])openModalWithSpec: arg1  ^self application openModal: self withSpecLayout: (self retrieveSpec: arg1)testFromSpecSingle  | tmp1 |  tmp1 := PluggableMenuSpec withModel: nil.  tmp1 add: 'item'.  presenter fromSpec: tmp1.  self assert: presenter menuGroups size equals: 1.  self assert: presenter menuGroups first menuItems size equals: 1.  self assert: presenter menuGroups first menuItems first name equals: 'item'.  self openInstancesubmerge: arg1 into: arg2  | tmp1 |  arg1 == arg2 ifTrue: [ ^false ].  arg1 isEmpty ifTrue: [ self inform: 'Nothing to copy.  To remove,simply choose "remove".'.        ^false ].  arg1 okayToRemove ifFalse: [ ^false ].  tmp1 := 'Please confirm:  copy all changesin "' , arg1 name , '" into "' , arg2 name , '"and then destroy the change setnamed "' , arg1 name , '"?'.  (self confirm: tmp1) ifFalse: [ ^false ].  (arg1 hasPreamble or: [ arg1 hasPostscript ]) ifTrue: [ (self confirm: 'Caution!  This change set has a preamble ora postscript or both.  If you submerge it intothe other side, these will be lost.Do you really want to go ahead with this?') ifFalse: [ ^false ] ].  self copyAllChangesFrom: arg1 to: arg2.  self removeChangeSet: arg1 prompting: false.  ^truetext: arg1  text := arg1accept  self widgetDo: [:arg1 |  arg1 acceptContents ]performMenuActionWith: arg1  ^self model performMenuActionWith: arg1selector  ^selectoreventKeyStrokesForNextFocus  ^{Character tab asKeyCombination}childrenFor: arg1  ^self model childrenFor: arg1shortCuts  | tmp1 |  tmp1 := super shortCuts.  tmp1 at: $c meta put: [ self copySelectedItemAccessorCode ].  ^tmp1testSelectAll  presenter beSingleSelection.  presenter selectAll.  self assertEmpty: presenter selection selectedItems.  presenter beMultipleSelection.  presenter selectAll.  self assert: (presenter selection selectedItems asArray collect: #label) equals: #('10' '20' '30')addOption: arg1  (arg1 isSelected not and: [ options isEmpty ]) ifTrue: [ arg1 beSelected ].  (arg1 isSelected and: [ options notEmpty ]) ifTrue: [ options do: #beUnselected ].  options add: arg1.  arg1 buttonGroup: selfdisable  self model enabled: falsequantum  ^quantumresetPosition  position := nilitemAtPath: arg1 ifAbsent: arg2  ^[ self itemAtPath: arg1 ] on: SubscriptOutOfBounds do: [ arg2 value ]removeMethods  self currentMethod ifNotNil: [:arg1 |  model removeMethod: arg1 inClass: arg1 methodClass ]withAdapterDo: arg1  ^self adapter ifNotNil: arg1browseValueClass  ^self valueClass browseitemFilter  ^itemFiltertransfer: arg1  passenger := arg1headerAction  ^headerAction valuepresenterAt: arg1  ^self readSlotNamed: arg1initializePresenters  methodsListPresenter := self newList.  classesListPresenter := self newList.  changesListPresenter := self newList.  textPresenter := self newCode.  self setFocus.  methodsListPresenter contextMenu: self messageMenu.  changesListPresenter contextMenu: self changeSetMenu.  classesListPresenter contextMenu: self classMenu.  methodsListPresenter enableItemSubstringFilter.  classesListPresenter enableItemSubstringFilter.  changesListPresenter enableItemSubstringFilter.  changesListPresenter items: self model allChanges.  changesListPresenter display: [:arg1 |  arg1 name ].  classesListPresenter sortingBlock: [:arg2 :arg3 |  arg2 name < arg3 name ]setUp  super setUp.  application := SpMockApplication newbuildWidget  | tmp1 |  tmp1 := super buildWidget.  self presenter whenSyntaxHighlightChangedDo: [:arg1 |  self setEditingModeFor: tmp1 ].  ^tmp1sortFunction: arg1  sortFunction := arg1isDialog  ^truetestActivationOnSingleClickShouldActivateOnClick  | tmp1 |  presenter     activateOnSingleClick;     whenActivatedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter clickAtPath: #(1).  self assert: tmp1 equals: 1testAboutText  | tmp1 tmp2 |  windowPresenter := SpWindowPresenter new.  windowPresenter aboutText: 'test'.  self assert: windowPresenter aboutText equals: 'test'.  windowPresenter close.  tmp1 := SpTextPresenter new.  [ tmp2 := tmp1 openWithSpec.  tmp1 withWindowDo: [:arg1 |  arg1 aboutText: 'test2' ].  self assert: tmp1 window aboutText equals: 'test2' ] ensure: [ tmp2 ifNotNil: #delete ]sortingBlock  ^sortingsetModelBeforeInitialization: arg1  wrappedPresenter := arg1.  wrappedPresenter owner: selftopFraction: arg1  topFraction := arg1model  ^modelcontent  ^self subclassResponsibilityemptyDropList  dropListModel emptyListtestUnselectAllUnselectsSingleSelection  presenter     selectIndex: 1;     unselectAll.  self assert: presenter selection isEmptycurrentChangeSet  ^ChangeSet currentlistMorphClass  ^PluggableIconListMorphmenuColumn: arg1 row: arg2  | tmp1 |  tmp1 := self model contextMenu.  tmp1 ifNil: [ ^nil ].  ^SpBindings value: self model application adapterBindings during: [ tmp1 value buildWithSpec ]maxWidthOf: arg1  ^(arg1 collect: [:arg2 |  (arg2 valueOfProperty: #style) width ]) maxwhenWillBeBuiltDo: arg1  self announcer when: SpWidgetWillBeBuilt do: arg1modalRelativeTo: arg1  self deprecated: 'Do not use this directly. Use #openModalWithSpec (and family) instead.' on: '2019-02-26' in: #Pharo8.  self widgetDo: [:arg2 |  arg1 spSetModal: arg2 ]whenMenuChangedDo: arg1  self property: #contextMenu whenChangedDo: arg1selectIndexes: arg1  self selectionMode selectIndexes: arg1inputTextDropList  ^subwidgetcheckboxWithLabelOnLeft: arg1  checkboxWithLabelOnLeft := arg1styleName  ^((self className withoutPrefix: 'SpMorphic') allButLast: 7) uncapitalizedcommandToTest  ^self commandClass new     context: self newMockContext;     yourselftestActivationOnSingleClickShouldActivateOnClick  | tmp1 |  tmp1 := nil.  presenter     activateOnSingleClick;     whenActivatedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter clickAtIndex: 1.  self assert: tmp1 equals: 10addPreamble  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  self model addPreambleTo: self selectedChangeSet.  changesListPresenter setSelectedItem: self selectedChangeSetclearUndoManager  asToolbarPresenter  ^SpToolBarPresenterBuilder new     visit: self;     toolbarPresenterwidth  ^self extent xisMatching: arg1  ^dataSource model performSearch: arg1 data matching: patternbuildWidget  ^SpStubTabManagerView newopenModal: arg1 withSpecLayout: arg2  ^self open: arg1 withSpecLayout: arg2 using: SpModalWindowPresentercolumns: arg1  self widgetDo: [:arg2 |  | tmp1 |        tmp1 := arg1 collect: [:arg3 |  arg3 buildWithSpec ].        arg2 columns: tmp1.        arg2 resizerChanged.        arg2 updateList ]whenMorphChangedDo: arg1  self property: #morph whenChangedDo: arg1testSelectPresenterIndexSetsSelectedIndexInWidget  presenter selectPath: #(1).  self assert: (self adapter selectedPaths includes: #(1))layout: arg1  | tmp1 |  tmp1 := arg1 asMorphicLayout.  self widgetDo: [:arg2 |  arg2 layoutFrame: tmp1 ]shortcut: arg1  shortcut := arg1buttonWithIcon: arg1  buttonWithIcon := arg1testTitle  | tmp1 tmp2 |  windowPresenter := SpTextPresenter new openWithSpec.  self assert: windowPresenter isDisplayed.  self assert: windowPresenter title equals: 'Text'.  windowPresenter close.  tmp1 := SpTextPresenter new.  [ tmp2 := tmp1 openWithSpec.  tmp1 withWindowDo: [:arg1 |  arg1 title: 'Test Window' ].  self assert: tmp1 window title equals: 'Test Window' ] ensure: [ tmp2 ifNotNil: #delete ]editPostscript  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  self selectedChangeSet editPostscriptrefreshList  ^self widget refreshnewButtonBar  ^self instantiate: SpButtonBarPresentericonFor: arg1  arg1 withErrorsDo: [:arg2 |  ^self iconFor: arg1 error: arg2 ].  ^[ arg1 icon ] on: Error do: [:arg2 |  self iconFor: arg1 error: arg2 ]removeTab: arg1  arg1 adapter deleteaddLast: arg1 expand: arg2  self addLast: arg1 withConstraints: [:arg3 |  arg3 expand: arg2 ]fromSton: arg1  styles := arg1 parseListtestOpenWithSpec  [ self openInstance ] on: Error do: [:arg1 |  self fail: 'Broken class simple instance: ' , self classToTest asString , '' , arg1 signalerContext shortStack ]includesItem: arg1  ^self selectedItems includes: arg1canShrink  ^shrinknewToolBar  ^self instantiate: SpToolBarPresenterconfigureUnix: arg1  whenValueChangedDo: arg1  self subclassResponsibilitytakeHighlight  self widgetDo: [:arg1 |  arg1 changed: #takeHighlight ]defaultWindowPresenterClass  ^SpWindowPresenternewContainerMorph  ^PanelMorph new     layoutPolicy: TableLayout new;     hResizing: #spaceFill;     vResizing: #spaceFill;     listDirection: #topToBottom;     yourselftestPreviousMonthButton  | tmp1 |  tmp1 := Date year: 2018 month: 9 day: 15.  calendar adaptToDate: tmp1.  self assert: calendar monthYearLabel label equals: tmp1 month asString.  calendar previousMonthButton performAction.  self assert: calendar monthYearLabel label equals: (tmp1 addMonths: -1) month asStringisStyleProperty  ^falseradio1  ^radio1initializeTSearchable  self searchMatching: [:arg1 :arg2 |  self performDefaultSearch: arg1 matching: arg2 ]numberOfColumns: arg1 withWidths: arg2  columns := OrderedCollection new.  (1 to: arg1) do: [:arg3 |  self addColumn: ((SpStringTableColumn evaluated: [:arg4 |  (self displayBlock value: arg4) at: arg3 ])                 width: (arg2 at: arg3);                 yourself) ]printDescription  ^description textdoActivateAtIndex: arg1  self model at: arg1 ifAbsent: [ ^self ].  activationBlock cull: ((SpSingleSelectionMode on: self)           basicSelectIndex: arg1;           yourself)topOffset  ^layoutFrame topOffsetincludesIndex: arg1  ^self selectedIndex = arg1icon: arg1  icon := arg1rightOffset  ^0shouldShowInTree  ^falseinitializeWidgets  toolbar := self instantiate: EyeInspectorToolBarclassToTest  ^SpTablePresentericon  ^self model iconsetUp  super setUp.  application := SpMockApplication newiconName: arg1  icon value: (self iconNamed: arg1)waitUntilUIRedrawed  self isRunningInUIProcess ifTrue: [ self currentWorld doOneCycle.        ^self ].  self currentWorld defer: [ uiWaitingSemaphore ifNotNil: #signal ].  uiWaitingSemaphore wait: self defaultWaitDurationpreviousButton  ^previousButtonselectedPaths  ^self widget selectedIndexes collect: [:arg1 |  self widget dataSource pathFromIndex: arg1 ]testActivationOnDoubleClickShouldNotActivateOnClick  | tmp1 |  presenter     activateOnDoubleClick;     whenActivatedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter clickAtPath: #(1).  self assert: tmp1 isNilobjectClass  ^self object classperformTest  backendForTest runTest: [ presenter := self classToTest new.        self initializeTestedInstance.        super performTest ]isCheckList  ^isCheckList valuelongLabel  ^value identityHash asString , ': ' , value printStringremoveContact: arg1  contents remove: arg1borderColor: arg1  borderColor := arg1isSearchEnabled  ^searchEnabledborderWidth: arg1  borderWidth := arg1commands  ^commandsinitialize  super initialize.  displaySymbol := #displayString.  placeholder := 'Choose one'.  possibleEntities := #().  selectDialog := [  ]basicRemoveTab: arg1  (tabs value remove: arg1 ifAbsent: [ ^self ]) owner: nilexploreSelectedObject  self selectedObjectDo: [:arg1 |  arg1 inspect ]digits: arg1  digits := arg1text: arg1  widget     setText: arg1;     acceptTextInModeldisplay  ^displayreadSelection  ^self readSelectionBlock cull: self text cull: selfgenerateNullPresentersInstVarNames: arg1  ^(1 to: arg1) collect: [:arg2 |  self generateUniqueInstanceVariableName ]testDeactivateRaisesChangedEventOnce  presenter state: true.  self assertWith: [:arg1 |  arg1 = 1 ] timesRaisedEvent: #whenChangedDo: inPresenter: presenter whenDoing: [ presenter state: false ]isOutput  ^falsetestSmokeMenu  presenter menu: (SpMenuPresenter new           addGroup: [:arg1 |  arg1                 addItem: [:arg2 |  arg2 name: 'One' ];                 addItem: [:arg2 |  arg2 name: 'Two' ];                 addItem: [:arg2 |  arg2 name: 'Three' ] ];           yourself).  self openInstanceselectedIndex: arg1  ^self list setSelectedIndex: arg1testSelectingAPathUpdatesSelectionInPresenter  self presenter selection     selectPath: #(1 2);     selectPath: #(2 3).  self assert: self adapter selectedPaths asArray equals: #(#(1 2) #(2 3))rootNodeHolder: arg1  tree rootNodeHolder: arg1input  ^subwidget inputbuildWithSpec  ^self widgetitemsInput  ^itemsInputtestSelectManyIndexesKeepsAllSelected  presenter selectPath: #(1).  presenter selectPath: #(2).  self assert: self adapter selectedPaths equals: #(#(1) #(2))browseImplementors  SystemNavigation new browseAllImplementorsOf: rgMethod selectorchanged: arg1  treeModel changed: arg1specSelector  ^specSelectorballoonText  | tmp1 |  tmp1 := self model description.  tmp1 ifNil: [ ^nil ].  ^(tmp1 isBlock or: [ tmp1 isMessageSend ]) ifTrue: [ tmp1 cull: self model ] ifFalse: [ tmp1 ]from: arg1 to: arg2 transform: arg3  self from: arg1 to: arg2 transform: arg3 postTransmission: niltestSetSelectIndexOutsideRangeRaisesSelectionChangeEventWithUnsetItem  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter selectIndex: 4.  self assert: tmp1 equals: niltestSetSelectIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | tmp1 |  presenter selection whenChangedDo: [:arg1 |  tmp1 := arg1 selectedIndex ].  presenter selectIndex: 1.  self assert: tmp1 equals: 1rename: arg1  | tmp1 |  tmp1 := UIManager default request: 'New name for this change set' initialAnswer: arg1 name.  (tmp1 = arg1 name or: [ tmp1 isEmptyOrNil ]) ifTrue: [ ^UIManager default inform: 'Please give a new name' ].  (ChangeSet named: tmp1) ifNotNil: [ ^UIManager default inform: 'Sorry that name is already used' ].  arg1 name: tmp1.  ^arg1countNumberOfProportionals  self commands do: [:arg1 |  arg1 layoutFrame hasNoOffsets ifTrue: [ (arg1 layoutFrame leftFraction == 0 and: [ arg1 layoutFrame rightFraction == 1 ]) ifFalse: [ autoFractionComputation := false ].              numberOfProportionals := numberOfProportionals + 1 ] ]contents  ^self basicAt: 1displayBlock: arg1  displayBlock value: arg1testAddWithPaddingHorizontal  | tmp1 tmp2 tmp3 |  tmp1 := SpBoxLayoutWithTableForTestPresenter new.  tmp2 := SpLabelPresenter new.  tmp3 := SpBoxLayout newHorizontal     add: tmp2 expand: false fill: false padding: 10;     yourself.  tmp1 buildAdapterWithSpecLayout: tmp3.  self assert: tmp2 adapter widget extent equals: tmp2 adapter widget owner extent - (20 @ 0)transferBlock  ^transferBlockinitialize  self class initializeSlots: self.  super initialize.  self spacing: 0.  self borderWidth: 0.  self visiblePages: 2removeEntryCompletion  self entryCompletion: nilproperty: arg1 whenChangedDo: arg2  (self observablePropertyNamed: arg1) whenChangedDo: arg2testSelectMultipleItemsAddsAllToSelectedItemList  presenter selectItem: 10.  presenter selectItem: 30.  self assert: (presenter selection includesItem: 10).  self assert: (presenter selection includesItem: 30)inferiorToMaximum: arg1  ^self model maximum ifNil: [ arg1 ] ifNotNil: [:arg2 |  arg1 min: arg2 ]printOn: arg1  super printOn: arg1.  self title value ifNotNil: [:arg2 |  arg1           nextPutAll: ' ''';           nextPutAll: arg2;           nextPutAll: '''' ]presenter  ^presentermarks: arg1  marks := arg1bottomRightOffset: arg1  bottomOffset := arg1 y.  rightOffset := arg1 xmainMessage: arg1  mainMessage := arg1assertIcon: arg1 equals: arg2  self assert: (arg1 ifNotNil: #form) = arg2registerClassActions  classesListPresenter whenSelectionChangedDo: [:arg1 |  self updateTextContents.        textPresenter behavior: arg1 selectedItem.        textPresenter syntaxHighlight: false.        arg1 selectedItem ifNil: [ methodsListPresenter items: {} ] ifNotNil: [:arg2 |  methodsListPresenter unselectAll.              methodsListPresenter items: (self selectedChangeSet selectorsInClass: arg2 name) sort ] ]buildTab: arg1  ^arg1 buildWithSpec     when: #tabDeleted send: #tabDeleted: to: self;     yourselfdefaultSpecSelector  (Pragma allNamed: #spec: from: self class class to: SpAbstractPresenter class class) detect: [:arg1 |  (arg1 argumentAt: 1) = #default ] ifFound: [:arg2 |  ^arg2 methodSelector ].  ^(Pragma allNamed: #spec from: self class class to: SpAbstractPresenter class class) ifEmpty: [ #defaultSpec ] ifNotEmpty: [:arg3 |  arg3 size = 1 ifTrue: [ arg3 first methodSelector ] ifFalse: [ #defaultSpec ] ]insert: arg1 at: arg2  self withAdapterDo: [:arg3 |  arg3 insert: arg1 at: arg2 ]title: arg1  title := arg1testRemoveTabFromManager2  presenter addTab: redTab.  self assertCollection: presenter tabs hasSameElements: {redTab}.  self openInstance.  redTab adapter widget delete.  self assertCollection: presenter tabs hasSameElements: #().  self assertCollection: (self morphicTabsFor: presenter) hasSameElements: #()isVertical  ^self direction = SpLayoutDirection verticalinitialize  super initialize.  self whenDaySelectedBlock: [:arg1 |   ]setBrowseModel  browseModel     state: false;     label: 'Browse';     action: [ self browseMethod ]tearDown  window ifNotNil: [ window delete ].  super tearDowninitialize  super initialize.  model := SpCollectionListModel on: #().  selection := SpSingleSelectionMode on: self.  displayBlock := [:arg1 :arg2 |  arg2 label ].  iconBlock := [:arg1 :arg2 |  arg2 icon ].  startsWithSelection := truemin: arg1  ^self sliderInput min: arg1buildWidgetAutoRefresh  ^UpdatingMenuItemMorph new     target: self;     balloonTextSelector: #balloonText;     subMenuSelector: #subMenu;     nameSelector: #name;     selector: #performMenuActionWith:;     argumentsBlock: self actionArguments;     getStateSelector: #state;     iconSelector: #icon;     enablementSelector: #enabled;     keyText: self shortcutText;     yourselfinitializeWidgets  defineOutputPorts  ^{SpDropListSelectionPort new}execute  self selectedContact name: self context newName.  self contactBookPresenter updateViewmessages  ^listModel itemsclassToTest  ^SpDropListPresenteraddSpecialFields: arg1  arg1 add: (DynamicEyeElement host: self object label: 'year' value: [ self object year ]).  arg1 add: (DynamicEyeElement host: self object label: 'month of year' value: [ self object monthIndex ]).  arg1 add: (DynamicEyeElement host: self object label: 'day of month' value: [ self object dayOfMonth ]).  arg1 add: (DynamicEyeElement host: self object label: 'full hours' value: [ self object hours ]).  arg1 add: (DynamicEyeElement host: self object label: 'full minutes' value: [ self object minutes ]).  arg1 add: (DynamicEyeElement host: self object label: 'full seconds' value: [ self object seconds ]).  arg1 add: (DynamicEyeElement host: self object label: 'utc' value: [ self object asUTC ])bold: arg1  bold := arg1testInitializePackageListShouldBeSelectTheFistItem  self assert: biChooseMethod packageList selection selectedIndex equals: 1resetSelection  self dropList resetSelectioninitializePresenters  | tmp1 |  tmp1 := self newTextInput     bePassword;     yourself.  email := self instantiate: (SpLabelledPresenter label: 'Email' input: self newTextInput description: 'Email you will use to send activations mails to your users.').  password := self instantiate: (SpLabelledPresenter label: 'Password' input: tmp1 description: 'Password of the email account used.').  self focusOrder     add: email;     add: passworddefaultColor  ^nilcenterWidget: arg1  self deprecated: 'This feature is to tight to Morphic to be in Spec. If you want this feature in a Morphic specific Spec application you should apply it yourself on the widget.		aWindow			fullBounds;			center: self adatper widget center' on: '2019-06-25' in: #Pharo8codePaneMenu: arg1 shifted: arg2  | tmp1 |  tmp1 := self model contextMenu.  tmp1 ifNil: [ ^nil ].  ^SpBindings value: self model application adapterBindings during: [ tmp1 value buildWithSpec ]setUp  super setUp.  menuBuilder := SpMenuPresenterBuilder new.  commandsGroup := (CmCommandGroup named: 'root') asSpecGroup beRoot     register: (CmBlockCommand new           name: 'c1';           block: [  ];           yourself) asSpecCommand;     register: ((CmCommandGroup named: 'sub1') asSpecGroup           register: (CmBlockCommand new                 name: 'c2';                 block: [  ];                 yourself) asSpecCommand;           register: (CmBlockCommand new                 name: 'c3';                 block: [  ];                 yourself) asSpecCommand);     register: (CmBlockCommand new           name: 'c4';           block: [  ];           yourself) asSpecCommand;     yourselfisNonEditableRow: arg1 column: arg2  ^(self widget dataSource cellColumn: (self widget columns at: arg2) row: arg1) submorphs allSatisfy: [:arg3 |  arg3 asReadOnlyMorph == arg3 ]testSetSelectItemRaisesSelectionItemChangeEventWithSelectedItem  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter selectItem: 10.  self assert: tmp1 equals: 10accessorCode  ^'(self tempNamed: ' , self tempName printString , ')'placeholder: arg1  ^self model placeholder: arg1actualPageMorph: arg1  actualPageMorph := arg1switchAutoscale  autoScale := autoScale notsyncMorphPosition  currentVerticalScrollPosition = text scrollValue y ifTrue: [ ^self ].  currentVerticalScrollPosition := text scrollValue y.  self needRebuild: false.  text needRebuild: false.  self buildWithSpecLayout: self defaultSpecLayouttestSelectPathsThenSelectInvalidPathKeepsElements  presenter     selectPaths: {#(1 3) .         #(2 2)};     selectPaths: {#(50) .         #(60 2)}.  self assert: (presenter selection includesItems: #(10 6))headerColumn: arg1  arg1 id ifNil: [ ^nil ].  ^FTCellMorph new     listCentering: #left;     addMorph: arg1 id asMorph asReadOnlyMorph;     yourselfstate  ^self presenter statesetSelectedIndex: arg1  self deprecated: 'Use #selectIndex: instead' transformWith: '`@receiver setSelectedIndex: `@argument' -> '`@receiver selectIndex: `@argument'.  self selectIndex: arg1initializePresenters  self class keys do: [:arg1 |  self additionalSubpresentersMap at: arg1 put: (self newButton label: arg1) ].  subpresenter4 := self newButton label: 'subpresenter4'allowMenuOnNoItem  ^allowMenuOnNoItem valueiconNamed: arg1  arg1 ~= #banana ifTrue: [ self error: 'Only #banana icon is needed for tests.' ].  ^self bananatestScrollUpToPreviousIndexScrollsTopToIndex  self flag: #pharo7.  SystemVersion current major < 8 ifTrue: [ self skip ].  presenter items: (1 to: 500).  presenter verticalAlignment desiredVisibleRow: 100.  self openInstance.  presenter verticalAlignment desiredVisibleRow: 50.  self assert: presenter verticalAlignment firstVisibleRowIndex equals: 50removeAll  collection := #().  self refreshList.  self announcer announce: (ValueChanged newValue: self)label: arg1  labelBlock := arg1newColumn: arg1 width: arg2  self newColumn: arg1 origin: 0 @ 0 corner: 0 @ 1 offsetOrigin: 0 @ 0 offsetCorner: arg2 @ 0hideColumnHeaders  showColumnHeaders := falsecurrentMethod  self deprecated: 'Use #selectedMessage instead' transformWith: '`@receiver currentMethod' -> '`@receiver selectedMessage'.  ^self selectedMessageclasses: arg1  classListPresenter items = arg1 ifTrue: [ ^self ].  classListPresenter     items: arg1;     selectIndex: 1testSelectItemOutsideRangeHasNoSelectedItems  presenter selectItem: 4000.  self assert: presenter selection selectedItems isEmptyautoDeselect: arg1  self deprecated: 'Should not use. This feature is not supported anymore'.  autoDeselect := arg1newIndex: arg1  newIndex := arg1isStyleClass  ^falseacceptDroppingMorph: arg1 event: arg2 inMorph: arg3  ^self model acceptDroppingMorph: arg1 event: arg2 inMorph: arg3testUnselectSelectedItemRemovesItFromSelectionList  presenter     selectItem: 10;     unselectItem: 10.  self assert: presenter selection isEmptyvalue  ^self host basicAt: self indexcollection  ^collectionselectionInterval  ^self widget selectionIntervaltestSelectMultiplePathsAddsAllToSelectedPathList  presenter     selectPath: #(1 2);     selectPath: #(2 2).  self assert: (presenter selection includesItem: 3).  self assert: (presenter selection includesItem: 6).  self assert: (presenter selection includesPath: #(1 2)).  self assert: (presenter selection includesPath: #(2 2))mouseDown: arg1  (self bounds containsPoint: arg1 cursorPoint) ifTrue: [ self fillStyle: self pressedFillStyle ].  lastMouse := arg1 cursorPoint - self position.  self eventHandler ifNotNil: [:arg2 |  arg2 mouseDown: arg1 fromMorph: self ]isHorizontal  ^isHorizontaltestModelSettingValueHolderToValueHolder  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := 40 @ 54.  tmp2 := 1 @ 0.  tmp4 := SpTestingPresenterWithModel on: tmp1.  tmp3 := NewValueHolder value: tmp2.  self assert: tmp4 announcingObject isSpAnnouncingObject.  self assert: tmp4 announcingObject isValueHolder.  self deny: tmp2 isSpAnnouncingObject.  self assert: tmp3 isValueHolder.  tmp4 model: tmp3.  self assert: tmp4 announcingObject isSpAnnouncingObject.  self assert: tmp4 announcingObject isValueHolder.  self assert: tmp4 model == tmp2.  self assert: tmp4 announcingObject == tmp3.  self assert: tmp4 announcingObject announcer numberOfSubscriptions > 0updateTree  tree updateTreeautoAccept: arg1  input autoAccept: arg1rebuildDynamicPresenter  | tmp1 tmp2 |  tmp1 := ((1 to: self cardPairsCount) , (1 to: self cardPairsCount)) shuffled.  tmp2 := OrderedCollection new.  builder := SpDynamicPresentersListBuilder new     modelObjects: tmp1;     presenter: SpButtonPresenter configuredAs: [:arg1 :arg2 |  self gameLogicWithShowedCards: tmp2 objectConcerned: arg2 andAssociatedPresenter: arg1 ];     layoutBuilder: (SpDynamicLeftToRightColumnsLayout columns: 10);     yourself.  self newDynamicPresentersListIn: #dynamicPresenter usingBuilder: builderbuildClassDescriptionFor: arg1 class: arg2  ^String streamContents: [:arg3 |  (arg1 classChangeAt: arg2 name) do: [:arg4 |  arg3 nextPutAll: (self classDescriptionsMap at: arg4) ] separatedBy: [ arg3 cr ] ]redMorphTab  | tmp1 |  tmp1 := SpTabPresenter new.  tmp1     label: 'Red Morph';     icon: (tmp1 iconNamed: #smallBackIcon);     contents: (Morph new           color: Color red;           yourself).  ^tmp1defaultPage  ^self availablePages firstwhenSelectionIndexChanged: arg1  self deprecated: 'Use #selection whenChangedDo: instead' transformWith: '`@receiver whenSelectionIndexChanged: `@argument' -> '`@receiver selection whenChangedDo: [ :selection | `@argument value: selection selectedIndex ]'.  ^self selection whenChangedDo: [:arg2 |  arg1 value: arg2 selectedIndex ]modelChanged  cancel  owner ifNil: [ self delete ] ifNotNil: [ owner delete ]dragPassengersFor: arg1 inMorph: arg2  ^{(self dragTransformationBlock cull: arg1 cull: arg2)}menu: arg1  menu := arg1centeredRelativeTo: arg1  self withWindowDo: [:arg2 |  arg2 centeredRelativeTo: arg1 ]initialize  super initializex: arg1  x := arg1itemAtPath: arg1  ^self itemAt: arg1 first of: self roots then: arg1 allButFirstleftLabel  ^self model leftLabeltestSelectMultipleIndexesAddsAllToSelectedItemList  presenter selectIndex: 1.  presenter selectIndex: 3.  self assert: (presenter selection includesItem: 10).  self assert: (presenter selection includesItem: 30)readSelectionBlock: arg1  ^readSelection := arg1setIndex: arg1  self dropList setIndex: arg1testUnselectAllInWidgetRaisesEmptySelectionChangeEvent  | tmp1 |  self adapter selectIndex: 1.  presenter selection whenChangedDo: [:arg1 |  tmp1 := arg1 ].  self adapter selectIndex: 0.  self assert: tmp1 isEmptydisplayValueAt: arg1  ^self displayValueOf: (model at: arg1)additionalSubpresentersMap  self flag: #TOREMOVE.  ^additionalSubpresentersMap ifNil: [ additionalSubpresentersMap := Dictionary new ]printOn: arg1  super printOn: arg1.  arg1     nextPutAll: '[ ';     print: self value;     nextPutAll: ' ]'setUp  super setUp.  self initializeSemaphorenewPanel  ^super newPanel     layoutPolicy: SpMorphicGridLayout new;     yourselfbuildMorph: arg1 constraints: arg2  | tmp1 |  tmp1 := arg1 buildWithSpec: arg2 spec.  self applyStyle: arg1 to: tmp1.  tmp1 := self addConstraits: arg2 toChild: tmp1.  ^tmp1selector  ^selectorlabel  ^'class'packageListAction  packageList transmitTo: classList transform: [:arg1 |  arg1 ifNotNil: [ arg1 classes asOrderedCollection ] ] postTransmission: [ classList selectIndex: 1 ]selectItems: arg1  arg1 ifEmpty: [ ^self unselectAll ].  self selectItem: arg1 firstsearchedString: arg1 in: arg2  | tmp1 tmp2 tmp3 |  arg1 ifNil: [ ^0 to: 0 ].  arg2 isEmptyOrNil ifTrue: [ ^0 to: 0 ].  tmp1 := arg2 asString.  tmp2 := 0 to: 0.  (arg1 includes: $:) ifTrue: [ | tmp4 |        tmp4 := arg1 substrings: ':'.        tmp4 size = 1 ifTrue: [ tmp3 := self findFirstOccurrenceOf: arg1 in: tmp1.              tmp3 isZero ifFalse: [ tmp2 := tmp3 to: tmp3 + arg1 size - 1 ] ] ifFalse: [ | tmp5 |              tmp3 := self findFirstOccurrenceOf: tmp4 first , ':' in: tmp1.              tmp3 > 0 ifTrue: [ tmp5 := tmp1 findString: tmp4 last , ':' startingAt: tmp3 + (tmp4 first size - 1).                    tmp2 := tmp3 to: tmp5 + tmp4 last size ] ] ] ifFalse: [ tmp3 := self findFirstOccurrenceOf: arg1 in: tmp1.        tmp3 > 0 ifTrue: [ tmp2 := tmp3 to: tmp3 + arg1 size - 1 ] ].  ^tmp2layout: arg1  layout := arg1classToTest  ^SpCheckBoxExamplelastBaseLine  ^self baseLines lastinitializeTestedInstance  super initializeTestedInstance.  presenter     beSingleSelection;     items: #(10 20 30)height  ^self extent yblockToPerformOnWrappers: arg1  blockToPerformOnWrappers value: arg1selectionOrLine  ^self selection ifEmpty: [ self           selectLine;           selection ]showOnlySource: arg1  self widgetDo: [:arg2 |  arg2 showOnlySource: arg1 ]menuHolder  ^menuHoldershortCuts  | tmp1 |  tmp1 := Dictionary new.  tmp1 at: $d meta put: [ self diveIntoSelectedObject ].  tmp1 at: $i meta put: [ self inspectSelectedObjectInNewWindow ].  tmp1 at: $i meta shift put: [ self exploreSelectedObject ].  tmp1 at: $b meta put: [ self browseSelectedObject ].  tmp1 at: $h meta put: [ self browseSelectedObjectClassHierarchy ].  ^tmp1type  ^typetestSelectIndexThenSelectOutsideRangeKeepsFirstElement  presenter selectIndex: 1.  presenter selectIndex: 50.  self assert: (presenter selection includesItem: 10)takeKeyboardFocus  self widget ifNotNil: [:arg1 |  arg1 takeKeyboardFocus ]hasIcons  ^self icons notNilto: arg1 port: arg2  self toPort: (arg1 inputPortNamed: arg2)hasSelectedObject  ^trueselectedIndex  ^self list selectedIndexdoubleClickAtIndex: arg1  self selectIndex: arg1.  activateOnSingleClick ifTrue: [ ^self ].  self doActivateAtIndex: arg1testSelectAll  presenter beSingleSelection.  presenter selectAll.  self assertEmpty: presenter selection selectedItems.  presenter beMultipleSelection.  presenter selectAll.  self assert: presenter selection selectedItems asArray equals: #(10 20 30)packageNameForItem: arg1  ^arg1 package ifNil: [ '' ] ifNotNil: [:arg2 |  arg2 name ]whenIconsChanged: arg1  self deprecated: 'Use #whenIconsChangedDo: instead.' transformWith: '`@receiver whenIconsChanged: `@statements' -> '`@receiver whenIconsChangedDo: `@statements'.  self whenIconsChangedDo: arg1classesListPresenter  ^classesListPresenterobject: arg1  object := arg1presenter: arg1  arg1 owner: self.  self retrievingBlock: [ arg1 buildWithSpec ]selectedIndex  ^self presenter selection selectedPath ifNotEmpty: #first ifEmpty: [ 0 ]buildLabelFrom: arg1  ^LabelMorph newLabel: arg1testSelectItemsThenSelectOutsideRangeKeepsElements  presenter selectItems: {10 .         20}.  presenter selectItems: {4000 .         5000}.  self assert: (presenter selection includesItems: {10 .               20})beHorizontalAlignmentStart  self hAlign: SpGridAlignment starttestCloseWindowRemovesItFromWindowCollection  | tmp1 |  tmp1 := (application newPresenter: SpButtonPresenter) openWithSpec.  tmp1 close.  self deny: (application windows includes: tmp1)emitStore: arg1  | tmp1 |  tmp1 := Object new.  arg1 addTemp: tmp1.  arg1 storeTemp: tmp1.  arg1 popTop.  arg1 pushInstVar: index.  arg1 pushTemp: tmp1.  arg1 send: #value:showBoth  self property: #showOnlySource rawValue: false.  self property: #showOnlyDestination rawValue: false.  self changed: #showBoth with: {}foreground  ^foregroundmessage: arg1  message := arg1testTypePerformsSearch  self presenter selection selectIndex: 1.  self adapter type: '2'.  self assert: self presenter selection selectedIndex equals: 2add: arg1 origin: arg2 corner: arg3  self add: arg1 origin: arg2 corner: arg3 offsetOrigin: 0 @ 0 offsetCorner: 0 @ 0execute  self context acceptpreventUpdatesDuring: arg1  isUpdating ifTrue: [ ^self ].  isUpdating := true.  arg1 ensure: [ isUpdating := false ]initializePresenters  actionBar := self newActionBar     add: (self newButton           label: 'Add';           icon: (self iconNamed: #smallOk);           help: 'Add.';           action: [ World defer: [ self inform: 'Add' ] ];           yourself);     add: (self newButton           label: 'Remove';           icon: (self iconNamed: #smallCancel);           help: 'Remove.';           action: [ World defer: [ self inform: 'Remove' ] ];           yourself);     addLast: (self newButton           label: 'Other';           help: 'Other.';           action: [ World defer: [ self inform: 'Other' ] ];           yourself);     yourself.  text := self newTextclearFilterButton  ^clearFilterButtontransmitDo: arg1  self newTransmission     from: self;     do: arg1;     applyinitialize  super initialize.  currentVerticalScrollPosition := 0browseInstVarRefs  ^self systemNavigation browseInstVarRefs: self hostClasswrapWith: arg1  listModel display: arg1morph  ^presenter adapter widgetremoveItem: arg1  self items remove: arg1.  list selection unselectAllfirstLabel: arg1 secondLabel: arg2  self firstButton label: arg1.  self secondButton label: arg2askOkToClose  ^askOkToCloseminimize  self widgetDo: [:arg1 |  arg1 minimize ]initializeWindow: arg1  arg1 initialExtent: 900 @ 530.  arg1 title: self titleargumentBlock  ^[ Array with: self model ]matchTokenFilter: arg1  ^self matchTokenFilterBlock value: arg1transferFor: arg1 from: arg2  ^self transferBlock value: arg1 value: arg2whenSelectedItemChanged: arg1  self deprecated: 'Use #whenSelectedItemChangedDo: instead.' transformWith: '`@receiver whenSelectedItemChanged: `@statements' -> '`@receiver whenSelectedItemChangedDo: `@statements'.  self whenSelectedItemChangedDo: arg1testDoesNotShowIcons  backendForTest assertIcon: self adapter displayedIcon equals: nilclicked  widget performAction.  self model state: widget isPressedupdateLabel  label label: (String streamContents: [:arg1 |  {button1 .               button2 .               button3} do: [:arg2 |  arg1                       << arg2 label;                       << ' : ';                       << (arg2 state ifTrue: [ 'V' ] ifFalse: [ 'X' ]) ] separatedBy: [ arg1 << ' - ' ] ])rightFraction  ^rightFractioncontent  ^'I am a modal demo with custom actions buttons.  I set closeOnBackdropClick to false so that the user cannot click on the backdrop to close the modal.'testColumnsAreDynamicallySetInWidget  self presenter     displayBlock: [:arg1 |  {arg1 .         42} ];     items: {1 .         2 .         3}.  self assert: self widget columns size equals: 2shown: arg1  shown := arg1updateBlock: arg1  updateBlock := arg1changed  self world ifNil: [ ^self ].  ^fullBounds ifNil: [ self invalidRect: self bounds ] ifNotNil: [ self invalidRect: fullBounds ]dragPassengersFor: arg1 inMorph: arg2  ^self model dragPassengersFor: arg1 inMorph: arg2testIfSingleRadioButtonStartsSelected  self assert: self adapter statehasEditingConflicts: arg1  self widgetDo: [:arg2 |  arg2 hasEditingConflicts: arg1 ]autoFractionComputation  | tmp1 |  tmp1 := numberOfProportionals isZero ifTrue: [ 0 ] ifFalse: [ 1 / numberOfProportionals ].  self commands doWithIndex: [:arg1 :arg2 |  arg1 layoutFrame hasNoOffsets ifTrue: [ self setWidgetLayoutWithNoOffset: arg1 at: arg2 delta: tmp1 ] ifFalse: [ self setWidgetLayoutWithOffset: arg1 at: arg2 ] ]sortingBlock: arg1  ^self list sortingBlock: arg1registerCancelButtonEvents  cancelButton     label: 'Cancel';     enabled: true;     state: falsesetOffsetsFor: arg1 top: arg2 left: arg3 bottom: arg4 right: arg5 borderWidth: arg6  self setRightOffset: arg5 for: arg6 borderWidth: arg1.  self setLeftOffset: arg3 for: arg1 borderWidth: arg6.  self setBottomOffset: arg4 for: arg1 borderWidth: arg6.  self setTopOffset: arg2 for: arg1 borderWidth: arg6changeSetMenuFrom: arg1 to: arg2  ^arg1 changeSetMenu     addGroup: [:arg3 |  arg3           addItem: [:arg4 |  arg4                 name: 'Copy all to the other change set';                 shortcut: $s meta;                 action: [ self copyAllFrom: arg1 to: arg2 ] ];           addItem: [:arg4 |  arg4                 name: 'Submerge into the other change set';                 action: [ self submerge: arg1 into: arg2 ] ];           addItem: [:arg4 |  arg4                 name: 'Subtract the other change set';                 shortcut: $- meta;                 action: [ self subtractFrom: arg1 to: arg2 ] ] ];     yourselfwindow: arg1  window := arg1resetSelection  tree resetSelectioninitializePresenters  list1 := self newList.  list2 := self newList.  list3 := self newList.  label := self newLabel.  multiLabel := self newLabel.  list1     items: self class environment allClasses;     contextMenu: self list1Menu.  list2     items: self class environment allClasses;     sortingBlock: [:arg1 :arg2 |  arg1 asString size < arg2 asString size ];     beMultipleSelection.  list3     items: self class environment allClasses;     itemFilter: [:arg3 :arg4 |  arg3 asString includesSubstring: arg4 ];     icons: [:arg5 |  self iconFor: arg5 ].  label label: 'No selection'.  multiLabel label: 'No multi selection (from list 2 only)'index  ^indexwhenSelectedItemChanged: arg1  self deprecated: 'Use #whenSelectedItemChangedDo: instead' transformWith: '`@receiver whenSelectedItemChanged: `@argument' -> '`@receiver whenSelectedItemChangedDo: `@argument'.  ^self whenSelectionChangedDo: [:arg2 |  arg1 cull: arg2 selectedItem ]styleName: arg1  styleName := arg1add: arg1  self add: arg1 constraints: SpBoxConstraints newisDisplayModeIcons  ^self displayMode = SpToolBarDisplayMode modeIconremoveAllItems  leftItems := OrderedCollection new.  rightItems := OrderedCollection newsurface  ^widget surfacenewRadioButton  ^self instantiate: SpRadioButtonPresentertestResult  | tmp1 tmp2 |  tmp2 := SpMockApplication new.  tmp1 := SpVersatileDialogPresenter newApplication: tmp2.  tmp1 mainMessage: 'Save content' asText allBold.  tmp1 addButton: #save text: 'Save' value: true.  tmp1 addButton: #cancel text: 'Cancel' value: false.  tmp1 mainIcon: (self iconNamed: #question).  tmp1 moreOptionsArea: (tmp1 newCheckBox label: 'Save header').  tmp1 openModalWithSpec.  tmp1 withWindowDo: [:arg1 |  arg1 title: 'Confirmation' ].  (tmp1 buttons at: #save) performAction.  tmp1 moreOptionsArea click.  self assert: tmp1 result.  self assert: tmp1 moreOptionsArea statepageIndex  ^pageIndexacceptAction  ^acceptActiontestTakeKeyboardFocus  mock := SpMockFocusOrderPresenter new     openWithSpec;     yourself.  self takeKeyboardFocus: mock.  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenter.  self takeKeyboardFocus: (mock presenterAt: #secondPresenter).  self deny: (mock presenterAt: #firstPresenter) equals: self focusedPresenter.  self assert: (mock presenterAt: #secondPresenter) equals: self focusedPresenter.  self takeKeyboardFocus: (mock presenterAt: #firstPresenter).  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenter.  self deny: (mock presenterAt: #secondPresenter) equals: self focusedPresenterdynamicPage  ^SpNotebookPage title: 'Dynamic' icon: (self iconNamed: #nautilusIcon) provider: [ SpDynamicWidgetChange new ]model  ^widget modelinitializePresenters  element11 := self newButton label: #element11.  element21 := self newButton label: #element21.  element12 := self newButton label: #element12.  element22 := self newButton label: #element22.  #('element11' 'element12' 'element21' 'element22' 'Row1' 'Row2') do: [:arg1 |  properties at: arg1 put: (Dictionary with: #expanded -> true with: #filled -> true with: #padding -> 5).        self presenterAt: arg1 , 'Expanded' put: (self newCheckBox                 label: 'Expanded';                 state: true;                 whenChangedDo: [:arg2 |  (properties at: arg1) at: #expanded put: arg2.                    self refresh ];                 yourself).        self presenterAt: arg1 , 'Filled' put: (self newCheckBox                 label: 'Filled';                 state: true;                 whenChangedDo: [:arg2 |  (properties at: arg1) at: #filled put: arg2.                    self refresh ];                 yourself).        self presenterAt: arg1 , 'Padding' put: (self newSlider                 min: 0;                 max: 50;                 value: 5;                 whenValueChangedDo: [:arg2 |  (properties at: arg1) at: #padding put: arg2.                    self refresh ];                 yourself) ]testDeactivateRaisesChangedEvent  presenter state: true.  self assertEvent: #whenChangedDo: isRaisedInPresenter: presenter whenDoing: [ presenter state: false ]addInitialPanel  min: arg1  min := arg1whenValueChangedDo: arg1  self property: #value whenChangedDo: arg1isCheckList  ^self model isCheckListdesiredVisibleRow: arg1  desiredVisibleRow := arg1contents  ^contentsregisterEvents  self whenSelectionModeChangedDo: [:arg1 |  self withAdapterDo: #refreshWidgetSelection ].  self whenMenuChangedDo: [ self withAdapterDo: #updateMenu ]includesContact: arg1  ^contents includes: arg1name: arg1  name := arg1isMethodDefinition: arg1  arg1 ifNil: [ ^false ].  ^(arg1 isRingObject and: [ arg1 isMethod and: [ arg1 compiledMethod isNotNil ] ]) or: [ arg1 isCompiledMethod ]expandRoots  self tree expandRootswhenIconChangedDo: arg1  self property: #icon whenChangedDo: arg1browseSelectedObjectClass  self selectedObjectDo: [:arg1 |  Smalltalk tools browser openOnClass: arg1 class ]windowPresenter: arg1  windowPresenter := arg1defaultWaitDuration  ^500 milliSecondtestUnselectSelectedIndexRaisesSelectionEventOnce  | tmp1 |  tmp1 := 0.  presenter     selectIndex: 1;     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectIndex: 1.  self assert: tmp1 equals: 1labelHolder  ^labelHoldertestChangingLabelAffectTheWidget  presenter label: 'ALabel'.  self assert: self widget label equals: 'ALabel'execute: arg1  self setSelection: arg1.  self action cull: arg1 cull: selfinitializeButtons  self subclassResponsibilityhasSelectedItem  ^selectionHolder value isNotEmptywhenSelectionIndexChanged: arg1  self dropList whenSelectionIndexChanged: arg1save: arg1  | tmp1 |  tmp1 := self host array at: self index.  self host     remove: tmp1;     add: arg1displayBlock  self deprecated: 'Please use #display instead' transformWith: '`@receiver displayBlock' -> '`@receiver display'.  ^displaysetSelection: arg1  selection := arg1x  ^xinitializePresenters  super initializePresenters.  cancelButton := self newButton.  self registerCancelButtonEvents.  self focusOrder add: cancelButtoninitialize  super initialize.  self registerToAnnouncements.  self announcer when: SpWidgetBuilt send: #buildUpdateTitle to: selfselectedIndex: arg1  self inspector selectedIndex: arg1searchText: arg1  | tmp1 tmp2 tmp3 |  arg1 isEmptyOrNil ifTrue: [ ^#() ].  tmp3 := OrderedCollection new.  tmp1 := arg1 trimBoth asLowercase.  1 to: self numberOfRows do: [:arg2 |  tmp2 := (self model displayValueAt: arg2) contents trimBoth asLowercase.        (tmp2 beginsWith: tmp1) ifTrue: [ tmp3 add: arg2 ] ].  ^tmp3 asArraytestAdapterForBindings  | tmp1 |  tmp1 := SpAbstractWidgetLayout for: #ListAdapter.  self assert: (tmp1 adapterFor: SpListPresenter new bindings: SpStubAdapterBindings new) class equals: SpStubListAdapterallowedToClose  super allowedToClose ifFalse: [ ^false ].  ^self model askOkToClose ifTrue: [ self model requestWindowClose ] ifFalse: [ true ]setUp  super setUp.  menuBuilder := SpMenuBarPresenterBuilder newstate: arg1  state := arg1getText  ^Text newtriggerCancelAction  self performCancelActiondragEnabled  ^falseinspectSelectedObjectInNewWindow  self selectedObjectDo: [:arg1 |  self inspectInNewWindow: arg1 ]mouseUp: arg1 from: arg2  arg2 color: self urlHoverColor.  self action valueselectionMode: arg1  selectionMode ifNotNil: [ selectionMode transferSubscriptionsTo: arg1 ].  selectionMode := arg1leftText: arg1  self widgetDo: [:arg2 |  arg2 sourceTextModel setText: arg1.        arg2 updateText ]resetArrayComputation  super resetArrayComputation.  size := self commands size.  numberOfProportionals := 0.  lastFractionIndex := 0.  autoFractionComputation := true.  currentOffset := 0.  currentProportional := 0removeButton  ^removeButtonemphasis: arg1  self widgetDo: [:arg2 |  arg2 emphasis: (self emphasisCodeFor: arg1) ]autoMultiSelection: arg1  tree autoMultiSelection: arg1mouseMove: arg1  self target ifNil: [ ^self ].  self setTargetLayoutSizing.  self resetLayoutPosition.  self positionPoint: arg1 cursorPoint - lastMouse.  self setTargetBoundshasCustomSearch  ^searchBlock notNiltext: arg1  text := arg1inspectorType: arg1  | tmp1 |  tmp1 := self inspector text.  arg1 = self inspector class ifTrue: [ ^self ].  arg1 isNil ifTrue: [ ^self ].  (self inspectorTypes includes: arg1) ifFalse: [ ^self ].  self basicInspector: (arg1 new           inspect: self object;           yourself).  self inspector text     text: tmp1 getText;     setSelection: tmp1 getSelection.  history replaceCurrentWith: self inspector.  self toolbar updatemaxWidth  ^self lookupProperty: SpStyleGeometry valueOf: #maxWidthopenDialog: arg1 withSpecLayout: arg2  ^self open: arg1 withSpecLayout: arg2 using: SpDialogWindowPresenternextInspectorType  | tmp1 tmp2 |  tmp2 := self inspectorTypes.  tmp1 := tmp2 indexOf: self inspectorType ifAbsent: [ ^tmp2 first ].  ^tmp2 atWrap: tmp1 + 1open: arg1  ^self open: arg1 withSpecLayout: arg1 defaultSpec using: arg1 defaultWindowPresenterClasscloseable: arg1  closeableHolder value: arg1widget  ^widgetadd: arg1 origin: arg2 corner: arg3 offsetOrigin: arg4 offsetCorner: arg5  commands add: (SpLayoutAdd subwidget: arg1 layoutFrame: ((arg2 corner: arg3) asSpLayoutFrame                 topLeftOffset: arg4;                 bottomRightOffset: arg5))testWhenOpenedDo  | tmp1 |  tmp1 := false.  presenter whenOpenedDo: [ tmp1 := true ].  self openInstance.  self assert: tmp1testSelectPresenterItemSetsSelectedIndexInWidget  presenter selectItem: 20.  self assert: (self adapter selectedIndexes includes: 2)updateRootFor: arg1  | tmp1 |  tmp1 := SpTokenTreeFilter token: arg1.  tree filterWith: tmp1openInstance  window ifNil: [ window := presenter openWithSpec ]changesPresenterOn: arg1 do: arg2  changesListPresenter bindKeyCombination: arg1 toAction: arg2itemNotFoundAction  whenLabelChangedDo: arg1  self property: #label whenChangedDo: arg1mouseLeave: arg1 from: arg2  arg2 color: self urlColor.  self currentHand showTemporaryCursor: niltitle  ^titleHoldertearDown  specInterpreterClass := nil.  specInterpreter := nil.  super tearDownwindowIcon: arg1  windowIcon := arg1valueClass  ^self value wrappedObject classcanDeselectByClick  ^canDeselectByClick valueclassToTest  ^SpScrollSyncExamplesetUsersModel  usersModel     state: false;     label: 'Users';     action: [ self usersMethod ]testFirstActionSecondAction  | tmp1 tmp2 |  tmp1 := false.  tmp2 := false.  presenter firstAction: [ tmp1 := true ] secondAction: [ tmp2 := true ].  presenter firstButton performAction.  presenter secondButton performAction.  self assert: tmp1.  self assert: tmp2selected: arg1  selectedHolder value: arg1initialize  super initialize.  state := true.  initialStateSet := true.  associatedRadioButtons := #()whenPagesChangedDo: arg1  pagesHolder whenChangedDo: arg1whenChildrenBlockChangedDo: arg1  childrenBlockHolder whenChangedDo: arg1headerFont: arg1  headerFont value: arg1title  ^'Keymap Browser'whenContentChangedDo: arg1  content whenChangedDo: arg1newProgressBar  ^self instantiate: SpProgressBarPresenterapplyStyle: arg1  self style applyTo: arg1label  ^labelBlock valuecloseOnBackdropClick  ^closeOnBackdropClicksearchText: arg1  ^(self class perform: (self searchStrategy , 'Strategy') asSymbol) searchWith: arg1 dataSource: selfleftPanel: arg1  leftPanel := arg1minimum  ^minimumplaceHolderText  ^widget ghostText asStringerrorWhileAccessing: arg1 do: arg2  [ self perform: arg1 ] on: Error do: [:arg3 |  arg2 cull: arg3 cull: arg1 ]contextMenuFromCommandsGroup: arg1  self contextMenu: [ arg1 value beRoot asMenuPresenter ]list3  ^list3testDeactivateDoesNotRaiseActivateEvent  presenter state: true.  self assertWith: [:arg1 |  arg1 = 1 ] timesRaisedEvent: #whenActivatedDo: inPresenter: presenter whenDoing: [ presenter state: false ]leftOffset: arg1  leftOffset := arg1centeredRelativeTo: arg1  self changed: #centeredRelativeTo: with: {arg1}attachTransmission: arg1  self destinationPresenter whenSelectionChangedDo: [:arg2 |  self transmitWith: arg1 value: arg2 transmission ]parentNode: arg1  parentNode value: arg1classToTest  ^SpDropListButtonbuildWidget  | tmp1 |  tmp1 := AlphaImageMorph new.  tmp1 model: self.  tmp1     getImageSelector: #getImage;     vResizing: #spaceFill;     hResizing: #spaceFill;     layout: self layoutValue;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     setBalloonText: self help;     update: #getImage.  self model     whenImageChangeDo: [ tmp1 image: (self getImage ifNil: [ Form extent: 1 @ 1 depth: 32 ]) ];     whenAutoScaleChangeDo: [ widget layout: self layoutValue ].  ^tmp1isExpanded  ^isExpanded valueremoveKeyCombination: arg1  self widgetDo: [:arg2 |  arg2 removeKeyCombination: arg1 ]icon  ^iconremoveTabNumber: arg1  self removeTab: (tabs at: arg1)initializePresenters  changeSorterLeft := self instantiate: ChangeSorterPresenter.  changeSorterRight := self instantiate: ChangeSorterPresenter.  self menusRegistration.  self shortcutsRegistration.  self setFocusOrdergtInspectorPreviewIn: arg1  < gtInspectorPresentationOrder: 30>  self widgetDo: [:arg2 |  arg2 gtInspectorMorphIn: arg1 ]showOnlySource  ^showOnlySourceborderWidth  ^borderWidthnotifyPropertyChanged: arg1  self flag: #todo.  (self observablePropertyNamed: arg1) valueChangedfindFirstOccurrenceOf: arg1 in: arg2  | tmp1 |  tmp1 := arg2 findString: arg1 startingAt: 1.  [ tmp1 > 1 and: [ (arg2 at: tmp1 - 1) isAlphaNumeric ] ] whileTrue: [ tmp1 := arg2 findString: arg1 startingAt: tmp1 + 1 ].  ^tmp1testTextIsSet  presenter text: 'aText'.  self assert: presenter text equals: 'aText'icon: arg1  self deprecated: 'Use #iconNamed: instead' transformWith: '`@receiver icon: `@statements' -> '`@receiver iconNamed: `@statements'.  ^self iconNamed: arg1buildWithSpec: arg1  ^self buildWithSpecbuildWithSpecLayout: arg1  ^SpBindings value: self application adapterBindings during: [ self basicBuildWithSpecLayout: arg1 ]phone  ^phoneselectItem: arg1  sourcePresenter ifNil: [ ^self ].  self setSourceContentWith: (self textConverter           method: arg1;           getText).  sourcePresenter clearUndoManager.  self installIconStylerFor: arg1numRows  ^numRowsrightFraction  ^layoutFrame rightFractionbuildWidget  | tmp1 |  tmp1 := LabelMorph new model: self.  tmp1     getEnabledSelector: #enabled;     getTextSelector: #getText;     vResizing: #shrinkWrap;     hResizing: #spaceFill;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     setBalloonText: self help;     color: self model color;     emphasis: (self emphasisCodeFor: self model emphasis);     setProperty: #minWidth toValue: 3.  ^tmp1beNotShrinkable  shrink := falseselectIndex: arg1  (arg1 = 0 and: [ widget selectedIndexes isEmpty ]) ifTrue: [ ^self ].  (widget selectedIndexes includes: arg1) ifTrue: [ ^self ].  widget selectIndex: arg1addItem: arg1 into: arg2  self subclassResponsibilitybaseRowHeight  ^(bounds height / numRows) asIntegerthumbnailSize  ^morphPresenter morph extentexecute  self editor pasteRecentisEmpty  ^self selectedIndex = 0testUnselectAll  presenter beMultipleSelection.  presenter     selectPath: #(1);     selectPath: #(2).  self assert: presenter selection selectedPaths equals: #(#(1) #(2)).  presenter unselectAll.  self assertEmpty: presenter selection selectedPathswidth  ^widthtestSelectItemsOutsideRangeIsEmpty  presenter selectItems: {4000 .         5000}.  self assert: presenter selection isEmptyselectedChangeSet  ^changesListPresenter selection selectedItemwhenSortingBlockChanged: arg1  self deprecated: 'Use #whenSortingBlockChangedDo: instead.' transformWith: '`@receiver whenSortingBlockChanged: `@statements' -> '`@receiver whenSortingBlockChangedDo: `@statements'.  self whenSortingBlockChangedDo: arg1nullPresentersNeededFor: arg1  ^self subclassResponsibilityincludesIndexes: arg1  ^arg1 allSatisfy: [:arg2 |  self selectedIndexes includes: arg2 ]objectVariableSize  ^self object basicSizeaddConstraits: arg1 toChild: arg2  | tmp1 |  tmp1 := arg2.  tmp1 setProperty: #constraints toValue: arg1.  ^tmp1isRoot  self withWindowDo: [:arg1 |  ^arg1 presenter = self ].  ^falseforgetClass  self okToChange ifFalse: [ ^self ].  self selectedClass ifNotNil: [:arg1 |  self model removeClass: arg1 from: self selectedChangeSet.        self setSelectedChangeSet: self selectedChangeSet ]accessorCode  ^self labelcreateWidgets  buttons withIndexDo: [:arg1 :arg2 |  self assign: arg1 to: ('radio' , arg2 asString) asSymbol ]testPropertyReturnsValueOf  | tmp1 |  themeDecorator property: #foo returnsValueOf: 42.  self assert: (themeDecorator objectAtProperty: #foo) equals: 42.  tmp1 := [ 42 ].  themeDecorator property: #fooBlock returnsValueOf: tmp1.  self assert: (themeDecorator objectAtProperty: #fooBlock) equals: tmp1acceptOnCR  ^acceptOnCRtestChangePlaceholderTextUpdatesPresenter  presenter placeholder: 'some text'.  self assert: self adapter placeHolderText equals: 'some text'classMenu  ^self newMenu     title: 'Class list';     addGroup: [:arg1 |  arg1           addItem: [:arg2 |  arg2                 name: 'Delete class from change set';                 shortcut: $d meta;                 action: [ self forgetClass ] ];           addItem: [:arg2 |  arg2                 name: 'Remove class from system';                 shortcut: $x meta;                 action: [ self removeClass ] ] ];     addGroup: [:arg1 |  arg1 addItem: [:arg2 |  arg2                 name: 'Browse full';                 shortcut: $b meta;                 action: [ self browseMethodFull ] ] ];     addGroup: [:arg1 |  arg1 addItem: [:arg2 |  arg2                 name: 'FileOut';                 action: [ self fileOutClass ] ] ];     yourselfwidgetsDo: arg1  self deprecated: 'Use #presentersDo: instead' transformWith: '`@receiver widgetsDo: `@statements1' -> '`@receiver presentersDo: `@statements1'.  self presentersDo: arg1change  boolean := boolean not.  boolean ifTrue: [ self changeToList ] ifFalse: [ self changeToButton ].  self needRebuild: false.  button needRebuild: false.  self buildWithSpecaddModelTo: arg1  self model pages ifEmpty: [ ^self ].  self model pages do: [:arg2 |  self addPage: arg2 to: arg1 ].  self model selectedPage ifNil: [ self model selectPageIndex: 1 ].  arg1 selectedPageIndex: self model selectedPageIndex.  arg1 announcer when: SpNotebookPageChanged send: #pageChanged: to: selfadd: arg1 top: arg2  self add: arg1 top: arg2 bottom: nil left: nil right: nilvalue  ^hosttestWhenLabelChangedDo  presenter label: 'label1'.  presenter whenLabelChangedDo: [:arg1 :arg2 |  self assert: arg2 equals: 'label1'.        self assert: arg1 equals: 'label2' ].  self assert: presenter label equals: 'label1'.  self openInstance.  presenter label: 'label2'.  self assert: presenter label equals: 'label2'add: arg1 phone: arg2  | tmp1 |  tmp1 := SpContact named: arg1 phone: arg2.  self addContact: tmp1.  ^tmp1registerOkButtonEvents  okButton     label: 'Ok';     enabled: true;     state: falsehasPresenter: arg1  ^arg1 isNotNil and: [ arg1 adapter notNil and: [ self adapter hasWidget: arg1 adapter ] ]acceptColumnVisitor: arg1  ^arg1 visitCheckboxColumn: selftestSelectItemSetsSelectedItem  presenter selectItem: 20.  self assert: presenter selection selectedItem equals: 20handleClassRenamed: arg1  | tmp1 tmp2 |  tmp1 := self messages collect: [:arg2 |  | tmp3 tmp4 |        tmp3 := arg1 oldName.        tmp4 := arg1 classRenamed.        arg2 isMetaSide ifTrue: [ tmp3 := tmp3 , ' class'.              tmp4 := tmp4 classSide ].        arg2 parentName = tmp3 ifTrue: [ (tmp4 >> arg2 selector) asFullRingDefinition ] ifFalse: [ arg2 ] ].  tmp2 := messageList selectedIndex.  self messages: tmp1.  self setSelectedIndex: tmp2dropEnabled  ^self presenter dropEnabledwhenAllowToSelectChangedDo: arg1  self deprecated: 'Should not use. Use #selectionMode instead'.  self property: #allowToSelect whenChangedDo: arg1beText  self bePassword: falseconnectPresenters  super connectPresenters.  addButton action: [ | tmp1 |        tmp1 := addItemBlock value.        tmp1 ifNotNil: [ self items add: tmp1.              self refresh ] ].  removeButton action: [ removeItemBlock cull: self selectedItem ].  topButton action: [ self moveElementAt: self selectedIndex to: 1 ].  bottomButton action: [ self moveElementAt: self selectedIndex to: self items size ].  upButton action: [ self moveElementAt: self selectedIndex to: self selectedIndex - 1 ].  downButton action: [ self moveElementAt: self selectedIndex to: self selectedIndex + 1 ]whenLabelClickableChanged: arg1  self deprecated: 'Use #whenLabelClickableChangedDo: instead.' transformWith: '`@receiver whenLabelClickableChanged: `@statements' -> '`@receiver whenLabelClickableChangedDo: `@statements'.  self whenLabelClickableChangedDo: arg1classToTest  ^SpLabelledListfillWith: arg1  self removeAllItems.  SpToolBarPresenterBuilder new     toolbarPresenter: self;     visit: arg1rootMenu  ^self owner rootMenutestPresenterConfiguredAs  | tmp1 |  self     assert: builder presenterBlock isNil;     assert: builder configurationBlock isNil.  tmp1 := [:arg1 :arg2 |   ].  builder presenter: SpButtonPresenter configuredAs: tmp1.  self     assert: (builder presenterBlock value: nil) equals: SpButtonPresenter;     assert: builder configurationBlock equals: tmp1classToTest  ^SpSearchableTreelabel  ^self index printStringbrowseClassRefs  self hostClass isTrait ifTrue: [ self systemNavigation browseAllUsersOfTrait: self hostClass ] ifFalse: [ self systemNavigation browseAllCallsOnClass: self hostClass ]getAction  self deprecated: 'Use #action instead' transformWith: '`@receiver getAction' -> '`@receiver action'.  ^self actionwhenSelectionIndexChangedDo: arg1  self deprecated: 'Use whenSelectionChanged:'.  selection whenSelectionChanged: arg1tearDown  window ifNotNil: [ window delete ].  super tearDowndrawBlock: arg1  drawBlock := arg1dragTransformationBlock  ^dragTransformationBlocktestAddingIconsShowTheIcon  #(pharo add book) do: [:arg1 |  self presenter addItemLabeled: arg1 do: [  ] icon: (self iconNamed: arg1) ].  self presenter selectItem: #pharo.  self assert: self adapter selectedIndexes equals: #(4).  backendForTest assertIcon: self adapter displayedIcon equals: (self iconNamed: #pharo)position: arg1  position := arg1sortClassesInCachedHierarchy: arg1 b: arg2  | tmp1 tmp2 tmp3 |  tmp1 := cachedHierarchy at: arg1.  tmp2 := cachedHierarchy at: arg2.  tmp3 := tmp1 size min: tmp2 size.  1 to: tmp3 do: [:arg3 |  | tmp4 |        tmp4 := (tmp1 at: arg3) printString compare: (tmp2 at: arg3) printString.        tmp4 ~~ 2 ifTrue: [ ^tmp4 == 1 ] ].  ^tmp1 size < tmp2 sizeemulateCenterClick  self emulateClick: MouseButtonEvent blueButtonhasEditingConflicts: arg1  ^self changed: #hasEditingConflicts: with: {arg1}newVSplitterAt: arg1  self widgetDo: [:arg2 |  arg2 newVSplitterAt: arg1 ]deactivationAction: arg1  actionWhenDeactivated := arg1addItem: arg1  self addItem: arg1 position: SpToolBarItemPosition leftencrypted: arg1  ^self input encrypted: arg1accept: arg1 notifying: arg2  ^self selectedMessage ifNotNil: [:arg3 |  arg3 methodClass compile: arg1 classified: arg3 protocol notifying: arg2 ]entity  ^entityhRigid  self subclassResponsibilityselectedContact  ^self contactBookPresenter selectedContactitems: arg1  ^super items: (arg1 collect: [:arg2 |  arg2 asPresenter                 owner: self;                 yourself ])fractions  ^layoutFrame fractionRectanglecellExtents  ^cellExtentsadapt: arg1  model := arg1.  arg1 addDependent: self.  widget := self buildWidgetvalue: arg1  value := EyePointerWrapper wrap: arg1property: arg1 rawValue: arg2  (self observablePropertyNamed: arg1) rawValue: arg2childrenForObject: arg1  ^arg1 submorphs collect: [:arg2 |  DynamicEyeElement host: arg1 value: arg2 ]testUnselectAllInWidgetRaisesSelectionIndexChangeEventOnce  | tmp1 |  tmp1 := 0.  self adapter selectPath: #(1).  presenter selection whenChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  self adapter selectPath: #().  self assert: tmp1 equals: 1setWidgetLayoutWithOffset: arg1 at: arg2  height := arg1 bottomOffset - arg1 topOffset.  arg2 = size ifTrue: [ arg1 layoutFrame: ((0 @ 1 corner: 1 @ 1) asSpLayoutFrame                 topLeftOffset: arg1 leftOffset @ height negated;                 bottomRightOffset: arg1 rightOffset @ 0) ] ifFalse: [ arg1 layoutFrame: ((0 @ currentProportional corner: 1 @ currentProportional) asSpLayoutFrame                 topLeftOffset: arg1 leftOffset @ currentOffset;                 bottomRightOffset: arg1 rightOffset @ (currentOffset + height)).        currentOffset := currentOffset + height ]arguments  ^{}testSetRootModelManyTimesPushesOnlyOnePresenterToList  self presenter presenterBlock: [:arg1 |  SpNullMillerPresenter on: (SpLabelPresenter new label: arg1 asString) ].  1 to: 3 do: [:arg2 |  self presenter setRootModel: arg2 ].  self assert: self presenter size equals: 1whenAcceptBlockChanged: arg1  self deprecated: 'Use #whenAcceptBlockChangedDo: instead.' transformWith: '`@receiver whenAcceptBlockChanged: `@statements' -> '`@receiver whenAcceptBlockChangedDo: `@statements'.  self whenAcceptBlockChangedDo: arg1hasStatusBar  ^self statusBar notNilnewNullPresenter  ^self instantiate: SpNullPresenterprepareToRunAgain  backendForTest runTest: [ super prepareToRunAgain ]classToTest  ^SpClassMethodBrowsertestSetColumnTitleInPresenterPutsColumnHeaderMorph  SystemVersion current major = 7 ifTrue: [ ^self skip ].  self presenter headerTitle: 'test'.  backendForTest assertListHeaderOf: self adapter equals: #('test')initialize  super initializetakeKeyboardFocus  ^self list takeKeyboardFocusinitializePresenters  selectItem: arg1  toolbarPresenter method: arg1.  textModel behavior: (arg1 ifNotNil: [ arg1 methodClass ]).  textModel doItReceiver: textModel behavior.  textModel text: (self textConverter           method: arg1;           getText).  textModel clearUndoManager.  self installIconStylerFor: arg1testOnePresenterShowsOneWidget  self presenter addPresenter: (SpNullMillerPresenter on: SpLabelPresenter new).  self assert: self adapter childrenWidgets size equals: 1rowIndex: arg1  rowIndex := arg1isResizeable: arg1  isResizeable := arg1testAddButtonToToolbar  | tmp1 tmp2 |  tmp1 := SpToolBarPresenter new.  tmp2 := SpToolBarButton new.  self assertEmpty: tmp1 items.  CmUIRightPositionStrategy new addButton: tmp2 toToolbar: tmp1.  self assert: tmp1 rightItems size equals: 1.  self assert: tmp1 rightItems anyOne equals: tmp2.  self assertEmpty: tmp1 leftItemsparent  ^parentupdateList  self withAdapterDo: #refreshWidgetList.  self unselectAllmaxNumberOfWeeksToDisplay  ^6setSelection: arg1  self deprecated: 'Use #selection: instead.' transformWith: '`@receiver setSelection: `@statement' -> '`@receiver selection: `@statement'.  self selection: arg1testSelectedPage  presenter selectPageIndex: 2.  self assert: self adapter selectedPageName equals: 'Mock2'visit: arg1  arg1 acceptColumnVisitor: selfselectPath: arg1  arg1 ifEmpty: [ ^self unselectAll ].  presenter itemAtPath: arg1 ifAbsent: [ ^self ].  selection := arg1displayBlock  ^displayBlockaddTab: arg1  tabs value add: arg1.  arg1 owner: self.  self selectedTab ifNil: [ selectedTab value: arg1 ].  self changed: #addTab: with: {arg1}initializePresenters  text := self instantiate: SpTextInputFieldPresenter.  text     text: 'Object is nil';     enabled: falsetestAddPresenterToComponentListRaisesSingleEvent  | tmp1 tmp2 |  tmp2 := 0.  tmp1 := SpButtonPresenter new.  presenter whenPresentersChangedDo: [ tmp2 := tmp2 + 1 ].  presenter addPresenter: tmp1.  self assert: tmp2 equals: 1mouseDown: arg1  self nodeModel mouseDownAction cull: arg1updateInspectorType  self inspectorType ifNotNil: [:arg1 |  inspectorChoice selectedItem = arg1 ifTrue: [ ^self ].        inspectorChoice selectedItem: arg1 ]pageClass  ^SpDemoModalPresenterclassToTest  ^SpLabelledDropListButtoncustomizeMorphicBar: arg1  self subclassResponsibilitycontent: arg1  content value: arg1canChangeFonts  ^truenewActionBar  ^self instantiate: SpActionBarPresentervalue: arg1  value := arg1messageMenu  ^self newMenu     title: 'Message list';     addGroup: [:arg1 |  arg1           addItem: [:arg2 |  arg2                 name: 'Delete method from changeSet';                 shortcut: $d meta;                 action: [ self forgetMessage ] ];           addItem: [:arg2 |  arg2                 name: 'Remove method from system';                 shortcut: $x meta;                 action: [ self removeMessage ] ] ];     addGroup: [:arg1 |  arg1 addItem: [:arg2 |  arg2                 name: 'Browse full';                 shortcut: $b meta;                 action: [ self browseMethodFull ] ] ];     addGroup: [:arg1 |  arg1           addItem: [:arg2 |  arg2                 name: 'FileOut';                 action: [ self fileOutMessage ] ];           addItem: [:arg2 |  arg2                 name: 'Senders of...';                 shortcut: $n meta;                 action: [ self browseSendersOfMessages ] ];           addItem: [:arg2 |  arg2                 name: 'Implementors of...';                 shortcut: $m meta;                 action: [ self browseImplementorsOfMessages ] ];           addItem: [:arg2 |  arg2                 name: 'Versions';                 shortcut: $v meta;                 action: [ self browseVersions ] ] ];     yourselfaddItemBlock: arg1  addItemBlock := arg1centered  self widgetDo: [:arg1 |  arg1           fullBounds;           position: (Display extent - arg1 extent) // 2 ]dropList  ^self dropListButton dropListclassToTest  ^SpMultiColumnListPresentertestOpenWindowWithDifferentApplicationShouldFail  | tmp1 tmp2 |  tmp1 := SpApplication new.  tmp2 := tmp1 newPresenter: SpButtonPresenter.  self should: [ application open: tmp2 ] raise: SpInvalidApplicationErrorinitializePresenters  classToTest  ^self subclassResponsibilitybuttonWithMenu  ^buttonWithMenuvResizing  ^vResizingupdatePagesWith: arg1  | tmp1 |  self widget ifNil: [ ^self ].  tmp1 := self widget pages reject: [:arg2 |  arg1 anySatisfy: [:arg3 |  arg3 = arg2 model ] ].  tmp1 do: [:arg2 |  self widget removePage: arg2 ].  arg1 reject: [:arg3 |  self widget hasPageWithModel: arg3 ] thenDo: [:arg3 |  self addPage: arg3 to: self widget ]isPassword  ^isPasswordcancelled  self flag: #TODO.  self withWindowDo: #cancelledremove: arg1  | tmp1 |  needRecalculatePages := true.  tmp1 := arg1 adapter widget.  innerWidget removeMorph: tmp1whenSelectionIndexChanged: arg1  self dropList whenSelectionIndexChanged: arg1testUnselectAllInWidgetWithoutSelectionDoesNotRaiseEvent  | tmp1 |  tmp1 := 0.  presenter selection whenChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  self adapter selectIndex: 0.  self assert: tmp1 equals: 0executeDefaultAction  defaultButton ifNil: [ ^self ].  defaultButton action cull: selftextWithStyle  ^self widget getTextbrowseMethod  self method ifNotNil: [:arg1 |  arg1 browse ]maleButton  ^maleButtonisShowingColumnHeaders  ^self model isShowingColumnHeaderstestSetSelectIndexOutsideRangeDoesNotModifySelection  presenter whenSelectionChangedDo: [:arg1 |  self fail ].  presenter selectIndex: 4addVariableFields: arg1  self sortedKeys do: [:arg2 |  arg1 add: (IndexedEyeElement host: self object index: arg2) ]testSelectIndexTwiceAddsIndexToSelectedIndexListOnlyOnce  presenter     selectIndex: 1;     selectIndex: 1.  self assert: presenter selection selectedIndexes asArray equals: #(1)whenMinimumChangedDo: arg1  self property: #minimum whenChangedDo: arg1computeWidgetSizes  rowHeights := self calculateRowHeights.  columnWidths := self calculateColumnWidthsaddItemLabeled: arg1 do: arg2 icon: arg3  | tmp1 |  tmp1 := SpDropListItem on: arg1 do: arg2.  tmp1 icon: arg3.  model add: tmp1.  self selection isEmpty ifTrue: [ self selection selectItem: tmp1 ]isRowExpandable: arg1  ^(layout rowConstraintsAt: arg1) ifNotNil: [:arg2 |  arg2 isExpand ] ifNil: [ false ]drawBlock  ^drawBlockadd: arg1 withConstraints: arg2  super add: arg1 withConstraints: arg2.  adapter ifNotNil: [:arg3 |  arg3 add: arg1 constraints: (children at: arg1) ]notifyInfo: arg1  self subclassResponsibilitynewRow: arg1  self newRow: arg1 origin: 0 @ 0 corner: 1 @ 1accept: arg1  | tmp1 |  tmp1 := (self shouldAccept: arg1 asString) ifTrue: [ arg1 ] ifFalse: [ self model text ].  super accept: tmp1vSpaceFill  selectedItem  | tmp1 |  tmp1 := self widget selectedIndex.  tmp1 = 0 ifTrue: [ ^nil ].  ^(self widget dataSource elementAt: tmp1) datalistPresenter  ^listPresentertestExplicitNotificationRaisesEventWithNewValue  | tmp1 |  point x: 17.  point property: #x whenChangedDo: [:arg1 |  tmp1 := arg1 ].  point notifyPropertyChanged: #x.  self assert: tmp1 equals: 17refreshDelay: arg1  refreshDelay := arg1addItemLabeled: arg1 do: arg2  dropListModel addItemLabeled: arg1 do: arg2itemFilter: arg1  itemFilter := arg1displayBlock: arg1  ^self dropList display: arg1testSelectMultipleIndexesRaisesSelectionChangeEventMultipleTimes  | tmp1 |  tmp1 := 0.  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter selectIndex: 1.  presenter selectIndex: 3.  self assert: tmp1 equals: 2subMenu  ^self newMenu     addItem: [:arg1 |  arg1           name: 'Open';           icon: (self iconNamed: #openIcon);           shortcut: $o meta;           action: [ self inform: 'Open' ] ];     addItem: [:arg1 |  arg1           name: 'Save';           icon: (self iconNamed: #smallSaveIcon);           shortcut: $s meta;           action: [ self inform: 'Save' ] ];     addItem: [:arg1 |  arg1           name: 'Print';           shortcut: $p meta;           icon: (self iconNamed: #smallPrintIcon);           action: [ self inform: 'Print' ] ];     addItem: [:arg1 |  arg1           name: 'Kill';           shortcut: $k meta;           icon: (self iconNamed: #smallCancelIcon);           action: [ self inform: 'Kill' ] ];     yourselftoolbarModel  ^toolbarModelcontainer  ^container valuenewDataSourceMatching: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self elements select: [:arg2 |  tmp2 := self model displayValueOf: arg2.        table columns anySatisfy: [:arg3 |  tmp3 := arg3 transform: tmp2.              arg1 matches: tmp3 ] ].  tmp4 := self copy.  tmp5 := self model copy.  tmp5 prepareForFilteredDataSourceWith: tmp1.  tmp4 model: tmp5.  ^tmp4canDeselectByClick: arg1  canDeselectByClick value: arg1calculateWidthFor: arg1 base: arg2  ^arg2traversePresentersDo: arg1 excluding: arg2  super traversePresentersDo: arg1 excluding: arg2.  presenter traversePresentersDo: arg1 excluding: arg2classToTest  ^SpTablePresenteraction  ^actionupdateChangesList  | tmp1 |  tmp1 := self selectedChangeSet.  changesListPresenter items: self model allChanges.  changesListPresenter selectItem: tmp1id  ^idadd: arg1 target: arg2 selector: arg3  self flag: #TODO.  self addItem: [:arg4 |  arg4           name: arg1;           action: [ arg2 perform: arg3 ] ].  ^self menuItems lastdependentPackages  | tmp1 tmp2 |  tmp1 := self lastBaseLine.  tmp2 := OrderedCollection new.  (self configurationClass project version: tmp1) record loadDirective packageDirectivesDo: [:arg1 |  tmp2 add: arg1 file ].  ^tmp2 collect: [:arg2 |  (arg2 includes: $.) ifTrue: [ (arg2 includes: $-) ifTrue: [ arg2 copyUpToLast: $- ] ifFalse: [ arg2 copyUpTo: $. ] ] ifFalse: [ arg2 ] ]currentIcon  ^currentIconnumber2Input  ^number2Inputselected  ^self nodeModel selectedaddMenuItemsToWindowMenu: arg1  announce: arg1  self announcer announce: arg1testDoesNotUnderstand  presenter content: SpListPresenter.  presenter items: {'aaa' .         'bbb' .         'ccc'}.  self assertCollection: presenter model items hasSameElements: {'aaa' .         'bbb' .         'ccc'}addModelTo: arg1  self model message ifNotNil: [:arg2 |  self pushMessage: arg2 to: arg1 ]action: arg1  action := arg1visible: arg1  rootItems  ^self model rootsplaceholder  ^placeholder ifNil: [ '' ]testInBounds  presenter maximum: nil.  presenter minimum: nil.  self assert: (adapter inBounds: 100) equals: 100.  self assert: (adapter inBounds: 160) equals: 160.  self assert: (adapter inBounds: 80) equals: 80.  presenter maximum: 150.  presenter minimum: 90.  self assert: (adapter inBounds: 100) equals: 100.  self assert: (adapter inBounds: 160) equals: 150.  self assert: (adapter inBounds: 80) equals: 90testIconProvider  self assert: command iconProvider equals: Smalltalk ui icons.  command iconProvider: self.  self assert: command iconProvider equals: self.  command iconName: #banana.  self assert: command icon equals: self bananamorph  ^morphvisiblePages: arg1  layout visiblePages: arg1presenter: arg1  presenter := arg1dropEnabled  ^dropEnabledlastClicked: arg1  self nodeModel lastClicked: arg1.  arg1 ifTrue: [ self model highlightedItem: self nodeModel ] ifFalse: [ self model highlightedItem: nil ]beforeAssertInTest: arg1  whenChangedDo: arg1  self property: #selection whenChangedDo: arg1disabledDropList  ^disabledDropListresetLayoutPosition  self owner layoutPolicy resetPositiontestUnselectUnselectedIndexRaisesNoSelectionEvent  | tmp1 |  tmp1 := 0.  presenter     selectIndex: 1;     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectIndex: 2.  self assert: tmp1 equals: 0extent  ^45 @ 40initializeTSearchable  self searchMatching: [:arg1 :arg2 |  self performDefaultSearch: arg1 matching: arg2 ]emitValue: arg1  arg1 pushInstVar: index.  arg1 send: #valueselectedPage  ^selectedPagelayout: arg1  self subclassResponsibilitytearDown  application close.  super tearDownwhenAllowToSelectChanged: arg1  self deprecated: 'Use #whenAllowToSelectChangedDo: instead.' transformWith: '`@receiver whenAllowToSelectChanged: `@statements' -> '`@receiver whenAllowToSelectChangedDo: `@statements'.  self whenAllowToSelectChangedDo: arg1clearSelection  self selectionInterval: (0 to: 0)testNonOpenPresenterDoesNotRaiseBuiltEvent  | tmp1 |  tmp1 := false.  presenter whenBuiltDo: [ tmp1 := true ].  self deny: tmp1updatePageContent: arg1  self widgetDo: [:arg2 |  (arg2 pageWithModel: arg1) reset.        arg1 = self model selectedPage ifTrue: [ arg2 updatePageIndex: self model selectedPageIndex ] ]whenSelectedItemChanged: arg1  tree whenSelectedItemChanged: arg1remove: arg1  children removeKey: arg1.  adapter ifNotNil: [:arg2 |  arg2 remove: arg1 ]whenActivatedDo: arg1  activationBlock := arg1buildWidget  ^SpStubDialogWindowView newwhenSelectedItemChanged: arg1  self dropList whenSelectedItemChanged: arg1defineInputPorts  ^{SpMorphPort new}fixed: arg1  fixed := arg1addIn: arg1  arg1 addMorph: morph fullFrame: layoutdoesNotUnderstand: arg1  ^self presenterAt: arg1 selector ifAbsent: [ super doesNotUnderstand: arg1 ]dragPassengerFor: arg1 inMorph: arg2  ^self model dragPassengerFor: arg1 inMorph: arg2shiftLastWidgets  | tmp1 tmp2 |  (lastFractionIndex > 0 and: [ lastFractionIndex < size ]) ifFalse: [ ^self ].  tmp1 := size - 1.  [ tmp1 > lastFractionIndex ] whileTrue: [ | tmp3 |        tmp2 := self commands at: tmp1.        tmp1 := tmp1 - 1.        tmp3 := tmp2 bottomOffset - tmp2 topOffset.        tmp2           topOffset: (height + tmp3) negated;           bottomOffset: height negated.        height := height + tmp3 ].  self assert: tmp1 = lastFractionIndex.  tmp2 := self commands at: tmp1.  tmp2 bottomOffset: height negatedaddInstancesVariable: arg1  configureWith: arg1 item: arg2  arg1 configureDropList: self item: arg2roots  ^rootsHolder valueselectedPaths  ^self subclassResponsibilitywhenSelectionIndexChanged: arg1  self dropList whenSelectionIndexChanged: arg1cancelAction: arg1  ^cancelAction := arg1text  ^texttestActivationOnDoubleClickShouldActivateOnDoubleClick  | tmp1 |  tmp1 := nil.  presenter     activateOnDoubleClick;     whenActivatedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter doubleClickAtIndex: 1.  self assert: tmp1 label equals: '10'testSelectLine  self initializationText.  self openInstance.  presenter selectLine.  self assert: presenter selectionInterval equals: (1 to: 15)aboutTitle  ^self model model ifNotNil: [:arg1 |  (arg1 respondsTo: #aboutTitle) ifTrue: [ arg1 aboutTitle ] ifFalse: [ arg1 class name ] ]allAdapters  ^self abstractAdapterClass allAdaptersasMenuPresenter  ^SpMenuPresenterBuilder new     visit: self;     menuPresenterfrom: arg1 to: arg2 transform: arg3 postTransmission: arg4  self     from: arg1;     to: arg2;     transform: arg3;     postTransmission: arg4;     applybuildWidget  ^self menuItems select: #isVisible thenCollect: #buildWithSpecnewContact  | tmp1 tmp2 |  tmp1 := self request: 'Enter new contact name and phone (split by comma)' initialAnswer: '' title: 'Create new contact'.  tmp2 := tmp1 splitOn: $,.  (tmp2 size = 2 and: [ tmp2 allSatisfy: #isNotEmpty ]) ifFalse: [ SpInvalidUserInput signal: 'Please enter contact name and phone (split by comma)' ].  ^SpContact new     name: tmp2 first;     phone: tmp2 second;     yourselfinitializeDialogWindow: arg1  arg1     addButton: 'Ok' do: [:arg2 |  arg2 triggerOkAction.        arg2 close ];     addButton: 'Cancel' do: [:arg2 |  arg2 triggerCancelAction.        arg2 close ]evaluated: arg1  evaluation := arg1initializePresenters  buttonPresenter := self newButtonnewNotebookPage  self flag: #TODO.  ^SpNotebookPage newclassToTest  ^SpTreeTablePresenterlayout  ^layoutinitialize  super initialize.  container := nil asValueHolder.  displayBlock := [:arg1 |  arg1 printString ] asValueHolder.  initialWidth := 100 asValueHolder.  resizable := true asValueHolder.  headerLabel := nil asValueHolder.  headerFont := self class defaultFont asValueHolder.  headerIcon := nil asValueHolder.  headerAction := nil asValueHolder.  self registerEventsselector: arg1  selector := arg1julianDaysIntervalFor: arg1  | tmp1 tmp2 |  tmp1 := arg1 julianDayNumber - arg1 dayOfMonth - (self dayBeforeMonthOf: arg1) + 1.  tmp2 := arg1 julianDayNumber + (arg1 month daysInMonth - arg1 dayOfMonth) + (self daysAfterMonthOf: arg1).  ^tmp1 to: tmp2inspectorWrapper  ^self ownersuspendSelectionEventsDuring: arg1  | tmp1 tmp2 |  tmp1 := self widget announcer subscriptions.  tmp2 := Set new.  tmp1 subscriptionsOf: self do: [:arg2 |  ({FTSelectionChanged .         FTStrongSelectionChanged} includes: arg2 announcementClass) ifTrue: [ tmp2 add: arg2 ] ].  tmp2 do: [:arg2 |  tmp1 remove: arg2 ].  arg1 ensure: [ tmp2 do: [:arg2 |  tmp1 add: arg2 ] ]connectPresenters  radio1 state: false.  radio2 state: true.  radio3 state: falseisExpandable  ^expandable and: [ self width isNil ]whenMultiSelectionChanged: arg1  self deprecated: 'Should not use'classToTest  ^SpTextInputFieldPresenterselectFileTitle: arg1  ^self backend selectFileTitle: arg1sortByColumn: arg1 event: arg2 morph: arg3  arg1 sortDataSource: selfsurname: arg1  surname := arg1lazyPageMorphCreation: arg1  lazyPageMorphCreation := arg1multiSelection  ^self model multiSelectiondiveInto: arg1  self inspect: arg1openOnString  | tmp1 tmp2 tmp3 |  tmp3 whenChangedDo: [:arg1 |  tmp1 label label: arg1 asString ].  tmp2 := tmp3 valuedefaultCommandsContext  ^selfbuildHierarchyForMessages: arg1  | tmp1 tmp2 |  self topologicSort ifFalse: [ tmp1 := IdentityDictionary new.        arg1 do: [:arg2 |  tmp1 at: arg2 put: {} ].        ^tmp1 ].  tmp1 := Dictionary new.  tmp2 := (arg1 collect: #methodClass) asSet.  arg1 do: [:arg3 |  | tmp3 tmp4 |        tmp4 := arg3 methodClass.        tmp3 := OrderedCollection new.        tmp4 allSuperclassesDo: [:arg4 |  (tmp2 includes: arg4) ifTrue: [ tmp3 addFirst: arg4 ] ].        tmp3 addLast: tmp4.        tmp3 addLast: arg3 selector.        tmp1 at: arg3 put: tmp3 ].  ^tmp1transform: arg1  transformBlock := arg1testSetLabelInPresenterSetsInInMorph  presenter label: 'something'.  self assert: self adapter label equals: 'something'whenColumnsChangedDo: arg1  self property: #columns whenChangedDo: arg1messageMenuFrom: arg1 to: arg2  ^arg1 messageMenu     addGroup: [:arg3 |  arg3           addItem: [:arg4 |  arg4                 name: 'Copy method to the other change set';                 action: [ self copyMethodFrom: arg1 to: arg2 ] ];           addItem: [:arg4 |  arg4                 name: 'Move method to the other change set';                 action: [ self moveMethodFrom: arg1 to: arg2 ] ] ];     yourselfdescription: arg1  arg1 ifNil: [ ^self ].  descriptionPresenter := self newLabel     label: arg1;     emphasis: #italic;     yourselfclassToTest  ^SpComponentListPresenterautoAccept: arg1  inputField autoAccept: arg1listElementAt: arg1 ifAbsent: arg2  ^self listItems at: arg1 ifAbsent: arg2iconHolder  ^iconHoldertestColumnHomogeneousDiferentRowsAndColumns  | tmp1 |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 2.  self place: label2 at: 3 @ 3.  self place: morph2 at: 4 @ 4.  tmp1 := self newLayout.  tmp1 layout beColumnHomogeneous.  (self styleMinExtent: 100 @ 20) applyTo: label2.  tmp1 layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 100 @ 20).  self assert: morph1 bounds equals: (100 @ 20 corner: 200 @ 40).  self assert: label2 bounds equals: (200 @ 40 corner: 300 @ 60).  self assert: morph2 bounds equals: (300 @ 60 corner: 400 @ 80)testWhenActionPerformedDoAfterAction  | tmp1 tmp2 |  tmp1 := 0.  tmp2 := 0.  self assert: tmp1 equals: 0.  self assert: tmp2 equals: 0.  presenter action: [ tmp1 := Time microsecondClockValue.        1 milliSecond wait ].  presenter whenActionPerformedDo: [ tmp2 := Time microsecondClockValue ].  self openInstance.  self assert: tmp1 equals: 0.  self assert: tmp2 equals: 0.  presenter adapter action.  self assert: tmp1 < tmp2triggerCancelAction  value: arg1  ^self sliderInput value: arg1newHorizontal  ^self newPanel     listDirection: #leftToRight;     addMorphBack: (self newPanel           listDirection: #leftToRight;           yourself);     addMorphBack: (self newPanel           listDirection: #leftToRight;           hResizing: #shrinkWrap;           width: 0;           yourself);     yourselfstyleName  ^'toolBar.iconsAndLabel'addItemLeft: arg1  arg1 owner: self.  leftItems add: arg1.  self notifyPropertyChanged: #leftItemsinput  ^inputinitialize  super initialize.  boolean := truesetSelectedClassIndex: arg1  ^classesListPresenter setSelectedIndex: arg1buildLayoutFor: arg1  ^self subclassResponsibilityvisitIndexColumn: arg1  self addCell: self rowIndex column: arg1testAdapterBindings  self assert: application adapterBindings class equals: SpStubAdapterBindings.  application useBackend: #Morphic.  self assert: application adapterBindings class equals: SpMorphicAdapterBindingsfrom: arg1 port: arg2 to: arg3 transform: arg4 postTransmission: arg5  self     from: arg1 port: arg2;     to: arg3;     transform: arg4;     postTransmission: arg5;     applyclassToTest  ^SpToggleButtonPresentertestSelectingAnElementSelectsIt  self presenter selectItem: 10.  self assert: self presenter selectedItem equals: 10.  self assert: self adapter selectedIndexes equals: #(1)icon: arg1  icon value: arg1codeFont  ^StandardFonts codeFontname  | tmp1 |  tmp1 := self model name.  ^(tmp1 isBlock or: [ tmp1 isMessageSend ]) ifTrue: [ tmp1 cull: self model ] ifFalse: [ tmp1 ]borderWidth: arg1  self widget ifNotNil: [:arg2 |  arg2 borderWidth: arg1 ]cellExtentAt: arg1  ^self cellExtents at: arg1max: arg1  max := arg1ghostText  self deprecated: 'This API is too tight to Morph. Use #placeholder instead.' transformWith: '`@receiver ghostText' -> '`@receiver placeholder'.  ^self placeholderinitializePresenters  methodBrowser := self instantiate: MessageBrowser.  textField := self newTextInput.  textField     placeholder: 'Enter a class name';     autoAccept: true;     removeEntryCompletion.  methodBrowser sortingBlock: [:arg1 :arg2 |  arg1 selector < arg2 selector ]label: arg1  label := arg1acceptDropBlock  ^self model acceptDropBlocktestLabelBottom  self openInstance: #labelBottomclickTab: arg1  | tmp1 tmp2 |  tmp1 := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent redButton buttons: MouseButtonEvent redButton hand: nil stamp: nil.  tmp2 := self widget tabSelectorMorph tabs at: arg1.  (tmp2 handlesMouseDown: tmp1) ifTrue: [ tmp2 mouseDown: tmp1.        tmp2 mouseUp: tmp1 ]checkboxNormal  ^checkboxNormalbeep  self adapter beepaccessorCode  ^'(self occurrencesOf: ' , self label , ')'testUnselectSelectedPathRaisesSingleEvent  | tmp1 |  tmp1 := 0.  presenter     selectPath: #(1 1);     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectPath: #(1 1).  self assert: tmp1 equals: 1testSwitchAutoScale  | tmp1 |  tmp1 := presenter autoScale.  presenter switchAutoscale.  self assert: presenter autoScale equals: tmp1 notinitialize  super initialize.  bindings := Dictionary new.  self initializeBindingsisVisible  ^visible valueaddCell: arg1 column: arg2  | tmp1 |  arg1 ifNil: [ ^self ].  tmp1 := arg1 asMorph asReadOnlyMorph.  self addCellMorph: tmp1 column: arg2buildLabelFrom: arg1 withAction: arg2  | tmp1 |  tmp1 := arg1 isMorph ifTrue: [ arg1 ] ifFalse: [ self buildLabelFrom: arg1 ].  ^arg2 ifNotNil: [ arg2 vResizing: #spaceFill.        PanelMorph new           addMorphBack: tmp1;           addMorphBack: arg2;           yourself ] ifNil: [ tmp1 ]headerTitle  ^headerTitlewhenSortingBlockChangedDo: arg1  self property: #sorting whenChangedDo: arg1initialize  super initialize.  actionWhenActivated := [  ].  actionWhenDeactivated := [  ].  state := false.  labelClickable := true.  label := ''.  self whenLabelClickableChangedDo: [:arg1 |  self changed: {#labelClickable: .               arg1} ]roots  ^{(RootEyeElement host: self object)}connectPresenters  list selectItem: self selectedPage.  list whenSelectionChangedDo: [:arg1 |  arg1 selectedItem ifNotNil: [:arg2 |  arg2 = self selectedPage ifFalse: [ self selectedPage: arg2.                    page := self instantiate: arg2.                    self needRebuild: false.                    self buildWithSpec.                    list selectItem: self selectedPage ] ] ifNil: [ list setSelectedItem: self selectedPage ] ]pages: arg1  arg1 do: [:arg2 |  arg2 owner: self ].  pagesHolder rawValue: arg1.  pagesHolder valueChanged: nilhost  ^hostinitializeTestedInstance  manager := SpTabManagerPresenter newwhenDisplayBlockChanged: arg1  self deprecated: 'Use #whenDisplayBlockChangedDo: instead.' transformWith: '`@receiver whenDisplayBlockChanged: `@statements' -> '`@receiver whenDisplayBlockChangedDo: `@statements'.  self whenDisplayBlockChangedDo: arg1ensureAtLeastOneColumnIn: arg1  self model columns ifNotEmpty: [ ^self ].  arg1 addColumn: (self newColumnFrom: self defaultColumn)openOnNil  ui := SpOpenOnNilExample new.  ui     extent: 200 @ 100;     openWithSpecextent  ^extentusersMethod  self method methodClass ifNotNil: [:arg1 |  self model browseClassRefsOf: arg1 ]addHorizontalPadding: arg1 toMorph: arg2  ^self newWrapMorph     hResizing: arg2 hResizing;     vResizing: arg2 vResizing;     width: arg2 width + (arg1 * 2);     height: arg2 height;     addMorph: (arg2           hResizing: #spaceFill;           vResizing: #spaceFill;           yourself) fullFrame: (LayoutFrame identity           leftOffset: arg1;           rightOffset: arg1 negated);     yourselfasArray  ^(OrderedCollection new     add: self type;     addAll: self privateAsArray;     yourself) asArrayisMatching: arg1  ^dataSource model performSearch: arg1 data matching: patternlistSize  ^self list listSizemodel  ^modelsuperiorToMinimum: arg1  ^self model minimum ifNil: [ arg1 ] ifNotNil: [:arg2 |  arg1 max: arg2 ]connectPresenters  inputField whenTextChangedDo: [:arg1 |  self updateRootFor: arg1 ].  tree whenTreeUpdatedDo: [ inputField text: '' ]initialize  super initialize.  self     changeTableLayout;     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #spaceFill;     color: self color;     extent: 0 @ 0.  self initializePanelsselectedMessage: arg1  messageList selectMessage: arg1setTargetLayoutSizing  self target hResizing = #rigid ifTrue: [ ^self ].  self target hResizing: #rigid.  self targetAfter hResizing: #spaceFillinitializeShortcuts  self shortCuts keysAndValuesDo: [:arg1 :arg2 |  self tree bindKeyCombination: arg1 toAction: arg2 ]labelClickable: arg1  labelClickable := arg1addMenuItemsToWindowMenu: arg1  self presenter addMenuItemsToWindowMenu: arg1bottomFraction  ^layoutFrame bottomFractionimage  ^widget scaledImageresetSelection  self selectedItems: {}accessorCode  ^super labelpackageOf: arg1  ^'[' , (self packageNameForItem: arg1) , ']'escapePressed  self model triggerCancelActionhasSelectedContact  ^self contactBookPresenter isContactSelectedinitialize  super initializerightLabel  ^self model rightLabelmaxHeight  ^self maxExtent ifNotNil: [:arg1 |  arg1 y ]isResizable  ^self presenter isResizabletestDefaultMaxLengthIsZero  self assert: presenter maxLength equals: 0button  ^buttonresultPane: arg1  resultPane := arg1title  ^self object printStringtransmitTo: arg1 transform: arg2  ^self newTransmission     from: self;     to: arg1;     transform: arg2;     applytestInsertAt  self initializationText.  self openInstance.  presenter insert: 'insertion ' at: 9.  self assert: presenter text equals: 'Text for insertion tests.'indeterminate  self state: SpProgressBarIndeterminated newtestLabelRight  self openInstance: #labelRightborderColor: arg1  self widget ifNotNil: [:arg2 |  arg2 borderColor: arg1 ]refeshedChangeSet: arg1  isRefreshing ifTrue: [ ^self ].  isRefreshing := true.  arg1 updateChangesList.  isRefreshing := falsewhenCurrentlyActivatedChangedDo: arg1  currentlyActivated whenChangedDo: arg1newIconList  self deprecated: 'Please use #newList instead.' transformWith: '`@receiver newIconList' -> '`@receiver newList'.  ^self instantiate: SpIconListPresentersetWidgetColor: arg1  | tmp1 tmp2 |  tmp1 := [:arg2 |  (arg2 valueOfProperty: #noFill ifAbsent: [ false ]) ifTrue: [ SolidFillStyle color: Color transparent ] ifFalse: [ SolidFillStyle color: self color ] ].  tmp2 := [:arg2 |  SolidFillStyle color: self color muchDarker ].  arg1 theme: ((SpUIThemeDecorator theme: arg1 theme)           property: #buttonNormalFillStyleFor: returnsValueOf: tmp1;           property: #buttonMouseOverFillStyleFor: returnsValueOf: tmp1;           property: #buttonPressedFillStyleFor: returnsValueOf: tmp2;           yourself)unselectPath: arg1  self selectPaths: (self selectedPaths copyWithout: arg1)realMenu  ^realMenusubmitButton: arg1  submitButton := arg1initialize  super initialize.  action := [  ].  autoScale := falseheight  ^self extent ifNotNil: [:arg1 |  arg1 y ]askOkToClose  ^self model askOkToCloselabelFor: arg1  ^arg1 labeltestShouldAcceptFloat  presenter     beFloat;     minimum: 90;     maximum: 120;     digits: 3.  self assert: (adapter shouldAccept: '').  self assert: (adapter shouldAccept: '100').  self assert: (adapter shouldAccept: '100.1').  self deny: (adapter shouldAccept: '80.1').  self deny: (adapter shouldAccept: '150.1').  self deny: (adapter shouldAccept: 'string').  self deny: (adapter shouldAccept: '10string').  self deny: (adapter shouldAccept: '100.1111')topFraction: arg1  ^0initialize  super initialize.  pushedMessages := OrderedCollection newopenDialogWithSpec  ^self application openDialog: self withSpecLayout: self retrieveDefaultSpecunselectAll  self clearSelectionaddPresenterIn: arg1 withSpecLayout: arg2  self model initialPosition ifNotNil: [:arg3 |  arg1 position: arg3 ].  self model initialExtent ifNotNil: [:arg4 |  arg1 extent: arg4 ].  self addContent: (self model presenter buildWithSpecLayout: arg2) toWindow: arg1testSelectIndexOutsideRangeHasNoSelectedIndexes  presenter selectIndex: 4.  self assert: presenter selection selectedIndexes isEmptyremoveKeyCombination: arg1  self contextKeyBindings removeKey: arg1 ifAbsent: [ ^self ].  self withAdapterDo: [:arg2 |  arg2 removeKeyCombination: arg1 ]toolbarItemSize  ^self displayMode heightcheckboxWithColor  ^checkboxWithColortestSetSelectItemRaisesSelectionChangeEventWithSelectedItem  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter selectItem: 20.  self assert: tmp1 equals: 20rowSpacing  ^self layout rowSpacingbuildWidget  ^SpStubTreeNodeView newassertIcon: arg1 equals: arg2  backendForTest assertIcon: arg1 equals: arg2title  ^'Example of using #prepareWindow:'whenShownDo: arg1  self property: #shown whenChangedDo: arg1sortElements: arg1  unsortedElements ifNil: [ unsortedElements := self rootsItems ].  self rootItem data: ((self rootItem children collect: #data) sorted: arg1)whenIconsChangedDo: arg1  self property: #icon whenChangedDo: arg1recalculatePageWidths  | tmp1 tmp2 tmp3 |  tmp2 := self childrenWidgets.  tmp3 := self widget width.  tmp1 := tmp2 size = 1 ifTrue: [ tmp3 ] ifFalse: [ tmp3 / (layout visiblePages min: tmp2 size) - (layout spacing / (layout visiblePages min: tmp2 size)) ].  tmp2 reverseWithIndexDo: [:arg1 :arg2 |  arg1           left: (arg2 - 1) * tmp1;           width: tmp1 ]listSize  ^self listItems sizeselectedSelector  ^methodsListPresenter selection selectedItemaddDefaultButton: arg1  defaultButton := self addButton: arg1.  defaultButton addStyle: 'default'.  ^defaultButtonaddHSplitter  self commands add: (SpSplitterHorizontal commands: self commands)instVarNamesFrom: arg1  ^arg1 instVarNames , arg1 nullPresentersInstVarNamesbeHorizontal  direction := SpLayoutDirection horizontaltestWhenPlaceholderChangesRaisesSingleEvent  self assertWith: [:arg1 |  arg1 = 1 ] timesRaisedEvent: #whenPlaceholderChangedDo: inPresenter: presenter whenDoing: [ presenter placeholder: 'test' ]menuItems  ^items valueupdateSelectionOf: arg1  self selectInto: arg1 paths: self model selection selectedPathsdiveIntoSelectedObject  self inspector diveIntoSelectedObjectupdateSearch  self presenter isSearchEnabled ifTrue: [ widget enableSearch ] ifFalse: [ widget disableFunction ]whenChangesListChanges: arg1  changesListPresenter whenModelChangedDo: arg1selectAll  self selectIndexes: (1 to: self model size)resetRootNodes  rootNodes := nilremovePageIndex: arg1  self removePage: (self pages at: arg1)radioButtonsAction  radioButtonClassSide whenActivatedDo: [ self fillWith: self selectedClass class ].  radioButtonInstanceSide whenActivatedDo: [ self fillWith: self selectedClass ]buildWidget  ^Morph new     color: Color transparent;     hResizing: #spaceFill;     vResizing: #spaceFill;     yourselfcopySelectedItemAccessorCode  self hasSelectedObject ifFalse: [ ^self ].  self selectedElement copyAccessorCoderesolvePresenter: arg1 presenter: arg2 bindings: arg3  arg1 isSymbol ifTrue: [ ^(self subpresenterOrLayoutNamed: arg1 of: arg2) ifNil: [ self error: 'You presenter named "' , arg1 , '" from ' , arg2 printString , ' was not initialized.' ] ].  arg1 isSpLayout ifTrue: [ ^arg1 buildAdapterFor: arg2 bindings: arg3 ].  ^arg1 asPresenter     owner: arg2;     yourselfnew: arg1  ^self newPresenter: arg1testModelObjects  builder modelObjects: {3 .         2 .         1}.  self assertCollection: builder instVarToModelObject hasSameElements: {(#var1 -> 3) .         (#var2 -> 2) .         (#var3 -> 1)}getIconFor: arg1  ^self icons cull: arg1 cull: selftestSelectPathsTwiceAddsPathssToSelectedPathListOnlyOnce  | tmp1 |  tmp1 := {#(1 3) .   #(2 2)}.  presenter     selectPaths: tmp1;     selectPaths: tmp1.  self assertCollection: presenter selection selectedPaths hasSameElements: tmp1execute  'OK' crLoginstVarNamesFrom: arg1  | tmp1 tmp2 |  tmp1 := super instVarNamesFrom: arg1.  tmp2 := tmp1 groupsOf: tmp1 size / self rowsCount atATimeCollect: [:arg2 |  arg2 readStream ].  ^OrderedCollection streamContents: [:arg3 |  [ tmp2 noneSatisfy: #atEnd ] whileTrue: [ tmp2 do: [:arg4 |  arg3 nextPut: arg4 next ] ] ]defineInputPorts  ^{SpListItemsPort new}registerEvents  rootsHolder whenChangedDo: [ self updateTree ].  childrenBlockHolder whenChangedDo: [ self updateTree ].  hasChildrenBlockHolder whenChangedDo: [ self updateTree ].  displayBlock whenChangedDo: [ self updateTree ].  iconBlock whenChangedDo: [ self updateTree ].  autoDeselection whenChangedDo: [:arg1 |  self update: {#autoDeselection: .               arg1} ].  columns whenChangedDo: [:arg2 |  arg2 do: [:arg3 |  arg3 container: self ].        self changed: #columns: with: {arg2} ].  selectionHolder whenChangedDo: [:arg4 |  self changed: {#selectItems .               arg4} ].  rootNodeHolder whenChangedDo: [:arg5 |  self updateTree ].  isCheckList whenChangedDo: [:arg1 |  self changed: #isCheckList: with: {arg1} ].  oddRowColor whenChangedDo: [:arg6 |  self changed: #oddRowColor: with: {arg6} ].  evenRowColor whenChangedDo: [:arg6 |  self changed: #evenRowColor: with: {arg6} ].  menuBlockHolder whenChangedDo: [:arg7 :arg8 |  arg8 ifNotNil: [ | tmp1 |              arg8 isBlock ifTrue: [ tmp1 := SpMenuPresenter new.                    arg8 cull: tmp1 cull: false ] ifFalse: [ tmp1 := arg8 ].              tmp1 applyTo: self ].        arg7 ifNotNil: [ | tmp2 |              arg7 isBlock ifTrue: [ tmp2 := SpMenuPresenter new.                    arg7 cull: tmp2 cull: false ] ifFalse: [ tmp2 := arg7 ].              tmp2 applyTo: self ] ].  self announcer when: SpWidgetBuilt send: #onWidgetBuilt to: selfremoveTabIndex: arg1  self tabs removeAt: arg1.  self tabs ifNotEmpty: [ self selectedIndex: (self selectedIndex - 1) \\ self tabs size + 1 ] ifEmpty: [ self selectedIndex: 0 ].  self updateTabsnumber  ^self text asNumberremoveSubWidgets  self subclassResponsibilitydropListButton  ^subwidgetdefineOutputPorts  ^#()entryCompletion: arg1  ^self input entryCompletion: arg1elementChanged  self text doItReceiver: self selectedElement value.  self text ifNotNil: [:arg1 |  arg1 behavior: self selectedElement value class ]buildWidget  ^SpStubTextView newcontents  ^self childrenItems collect: [:arg1 |  self childNodeFromItem: arg1 ]whenLabelChangedDo: arg1  self property: #label whenChangedDo: arg1presenter  ^presentercommands: arg1  commands := arg1hasContentToShow  ^self model hasContentToShownotify: arg1  self withAdapterDo: [:arg2 |  arg1 type notify: arg1 on: arg2 ]displayBlock  self deprecated: 'Please use #display instead' transformWith: '`@receiver displayBlock' -> '`@receiver display'.  ^displayBlockunselectAll  self subclassResponsibilitygameLogicWithShowedCards: arg1 objectConcerned: arg2 andAssociatedPresenter: arg3  arg3     icon: self hiddenIcon;     action: [ (arg3 icon = self hiddenIcon and: [ arg1 size < 2 ]) ifTrue: [ arg1 add: arg3.              arg3                 icon: nil;                 label: arg2 asString.              arg1 size = 2 ifTrue: [ [ (1 / 2) second wait.                    arg1 first label asString = arg1 second label asString ifTrue: [ arg1 do: [:arg4 |  arg4                                   icon: self foundIcon;                                   label: nil ] ] ifFalse: [ arg1 do: [:arg4 |  arg4                                   icon: self hiddenIcon;                                   label: nil ] ].                    arg1 removeAll ] fork ] ] ]date: arg1  | tmp1 |  date := arg1.  tmp1 := self display value: date.  self dateModel text: tmp1attachTransmission: arg1  self destinationPresenter whenTextChangedDo: [:arg2 |  self transmitWith: arg1 value: arg2 text ]whenChangedDo: arg1  self property: #desiredVisibleRow whenChangedDo: arg1label  ^labelasArray  ^{leftFraction .   topFraction .   rightFraction .   bottomFraction .   leftOffset .   topOffset .   rightOffset .   bottomOffset}autoRefresh  | tmp1 |  tmp1 := self model autoRefresh.  ^(tmp1 isBlock or: [ tmp1 isMessageSend ]) ifTrue: [ tmp1 cull: self model ] ifFalse: [ tmp1 ]testSelectItemOutsideRangeUnsetsSelectedItem  presenter selectItem: 4000.  self assert: presenter selection selectedItem equals: niltestSelectIndexAddsIndexToSelectedIndexList  presenter selectIndex: 1.  self assert: (presenter selection includesIndex: 1)value: arg1  value := arg1hRigid  self widgetDo: [:arg1 |  arg1 hResizing: #rigid ]testRowColorsBeforeBuild  treeWithItems oddRowColor: Color red.  treeWithItems evenRowColor: Color green.  treeWithItems buildWithSpec.  self assert: treeWithItems adapter widget rowColors equals: (Array with: Color green with: Color red)codeTab  ^SpNotebookPage title: 'Code' icon: (self iconNamed: #changeUpdate) provider: [ self newText           text: (self codeFor: self pageClass);           yourself ]setTopOffset: arg1 for: arg2 borderWidth: arg3  arg2 topFraction = 0 ifTrue: [ arg1 isZero ifTrue: [ arg2 topOffset: arg3 ] ifFalse: [ arg2 topOffset: arg1 + self splitterWidth ] ] ifFalse: [ arg2 topFraction = 1 ifFalse: [ arg2 topOffset: arg1 + self splitterWidth ] ]numberOfRows  ^model ifNil: [ 0 ] ifNotNil: [ self listModel size ]askBeforeChanging  ^askBeforeChangingbuildWidget  ^SpStubIconListView newadapter  backendForTest openInstanceOf: self.  ^presenter adapterpresentersDo: arg1  self class allSlots reject: [:arg2 |  arg2 name = #owner ] thenDo: [:arg2 |  | tmp1 |        tmp1 := self readSlot: arg2.        (tmp1 isKindOf: SpAbstractPresenter) ifTrue: [ arg1 value: tmp1 ] ]refreshDescription: arg1  | tmp1 |  arg1 ifNil: [ ^self ].  tmp1 := [ arg1 description ] on: Error do: [ 'Error while printing ' , arg1 accessorCode ].  description text = tmp1 ifTrue: [ ^self ].  self keepScrollPositionOf: description during: [ description text: tmp1 ]tick  timeline ticktestInterpretASpecModelMorphAssociation  | tmp1 tmp2 tmp3 |  tmp2 := SpAbstractWidgetPresenter new.  tmp1 := {#MenuRegistration .   #help: .   #icon:}.  tmp3 := specInterpreterClass interpretASpec: tmp1 presenter: tmp2.  self assert: tmp2 adapter == tmp3checkboxWithHelp: arg1  checkboxWithHelp := arg1basicBuildWithSpecLayout: arg1  | tmp1 |  (self spec isNil or: [ self needRebuild ]) ifTrue: [ self buildWindowWithLayout: self retrieveDefaultSpec presenterLayout: arg1 ] ifFalse: [ tmp1 := self widget ].  ^tmp1add: arg1 withSpec: arg2 right: arg3  self add: arg1 withSpec: arg2 top: nil bottom: nil left: nil right: arg3classToTest  ^SpTextPresenterwhenBorderColorChanged: arg1  self deprecated: 'Use #whenBorderColorChangedDo: instead.' transformWith: '`@receiver whenBorderColorChanged: `@statements' -> '`@receiver whenBorderColorChangedDo: `@statements'.  self whenBorderColorChangedDo: arg1normalBorderStyle  ^BorderStyle simple     width: 0;     baseColor: Color transparentinitMinMax  presenter     min: 0;     max: 100gtInspectorPreviewIn: arg1  < gtInspectorPresentationOrder: 30>  self adapter ifNotNil: [:arg2 |  arg2 gtInspectorPreviewIn: arg1 ]compareToOtherVersion  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := self changeList.  tmp1 := tmp2 collect: #stamp.  tmp3 := UIManager default chooseFrom: tmp1.  tmp3 > 0 ifFalse: [ ^self ].  tmp4 := tmp2 at: tmp3.  self compareTo: tmp4 withLabel: tmp4 stampupdateTitle  DisplayScreen hostWindowTitle: self titlemodel  ^modelfileOut  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  self selectedChangeSet fileOutbuildWidget  ^SpStubDropListView newrightPanel: arg1  rightPanel := arg1email  ^emailopenOnString: arg1  ui := SpOpenOnStringExample new: arg1.  ui     extent: 300 @ 200;     openWithSpecselection: arg1  self deprecated: '#selection: was used to set an interval, and did not convey the correct meaning. Use #selectionInterval: instead.' transformWith: '`@receiver selection: `@arg' -> '`@receiver selectionInterval: `@arg'.  self selectionInterval: arg1whenDisplayDo: arg1  self announcer when: SpWidgetDisplayed do: arg1addLast: arg1  (items at: #end ifAbsentPut: [ OrderedCollection new ]) add: arg1setIndex: arg1  ^self dropList setIndex: arg1columns: arg1  columns := arg1roots: arg1  roots := arg1.  self selection clearSelectionunselectItem: arg1  self selection unselectItem: arg1childrenForObject: arg1  arg1 isDirectory ifFalse: [ ^#() ].  ^arg1 children collect: [:arg2 |  DynamicEyeElement host: arg1 value: arg2 ]openInstanceOf: arg1  arg1 window ifNil: [ arg1 presenter application: app.        arg1 window: arg1 presenter openWithSpec ].  self waitUntilUIRedrawedclassToTest  ^SpCheckBoxPresenterinitialize  buttons := OrderedCollection new.  currentActivated := nil asValueHolder.  super initializewrapItem: arg1 index: arg2  ^self model wrapItem: arg1 index: arg2newRow: arg1 origin: arg2 corner: arg3 offsetOrigin: arg4 offsetCorner: arg5  | tmp1 |  tmp1 := arg1.  tmp1 isBlock ifFalse: [ tmp1 := [:arg6 |  arg6 add: arg1 ] ].  commands add: (SpLayoutAddRow block: tmp1 layoutFrame: ((arg2 corner: arg3) asSpLayoutFrame                 topLeftOffset: arg4;                 bottomRightOffset: arg5))adapterName  ^#PanedAdapterisVisible  ^widget visibleinspectMethod  self currentMethod ifNotNil: [:arg1 |  arg1 inspect ]nodeModel: arg1  nodeModel := arg1whenCodeCompletionAllowedChanged: arg1  self deprecated: 'Use #whenTextIsAcceptedDo: instead or nothing. Currently, both those methods are doing the same thing but my name is really missleading. Thus, I''ll be removed.' transformWith: '`@receiver whenCodeCompletionAllowedChanged: `@statements' -> '`@receiver whenTextIsAcceptedDo: `@statements'.  self whenTextIsAcceptedDo: arg1edgeName  ^#bottomassertImage: arg1 equals: arg2  (arg2 isNil and: [ arg1 isNil or: [ arg1 width = 1 and: [ arg1 height = 1 ] ] ]) ifTrue: [ ^self ].  self assert: arg1 width = arg2 width.  self assert: arg1 height = arg2 height.  self assert: arg1 bits = arg2 bitsaboutText  ^self model aboutTextmatches: arg1  ^self block cull: arg1 cull: patternselectAll  self changed: #selectAdd with: #()direction  ^self layout directiondaysAfterMonthOf: arg1  ^self daysToDisplayCount - arg1 month daysInMonth - (self dayBeforeMonthOf: arg1)encrypted: arg1  self input encrypted: arg1execute  self action cull: selfrowInset: arg1  tree rowInset: arg1dayNames  ^#('Sun' 'Mon' 'Tue' 'Wed' 'Thu' 'Fri' 'Sat')setWidgetLayoutWithNoOffset: arg1 at: arg2 delta: arg3  arg1 layoutFrame: ((0 @ currentProportional corner: 1 @ (currentProportional + arg3)) asSpLayoutFrame           topOffset: currentOffset;           yourself).  currentOffset := 0.  currentProportional := currentProportional + arg3.  lastFractionIndex := arg2modalRelativeTo: arg1  self deprecated: 'Do not use this directly. Use #openModalWithSpec (and family) instead.' on: '2019-02-26' in: #Pharo8.  self changed: #modalRelativeTo: with: {arg1}redraw  self surface drawDuring: [:arg1 |  drawBlock cull: arg1 ]takeKeyboardFocus  ^self listModel takeKeyboardFocustearDown  window ifNotNil: [ window delete ].  super tearDownselectedObjectDo: arg1  arg1 value: self selectedObjectwidgetBuilt: arg1  | tmp1 |  tmp1 := self layout presenters first.  borderWidth value: tmp1 borderWidth.  columnSpacing value: tmp1 columnSpacing.  rowSpacing value: tmp1 rowSpacing.  columnHomogeneous state: tmp1 isColumnHomogeneous.  rowHomogeneous state: tmp1 isRowHomogeneouschildNodeFromItem: arg1  ^(arg1     container: self model;     buildWithSpec)     parentNode: self;     yourselfpackageNameForItem: arg1  ^arg1 package ifNil: [ '' ] ifNotNil: [:arg2 |  arg2 name ]buildWidget  widget := FTTableMorph new     beRowNotHomogeneous;     dataSource: self newDataSource;     setMultipleSelection: self presenter isMultipleSelection;     hideColumnHeaders;     hResizing: #spaceFill;     vResizing: #spaceFill;     setBalloonText: self help;     onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self;     onAnnouncement: FTStrongSelectionChanged send: #strongSelectionChanged: to: self;     yourself.  self presenter whenPresentersChangedDo: [ self refreshList ].  self refreshWidgetSelection.  self presenter whenSelectionChangedDo: [ self refreshWidgetSelection ].  ^widgetnotifyPropertyChanged: arg1  self flag: #todo.  (self observablePropertyNamed: arg1) valueChangedaddFocusRotationKeyBindings  applyPostTransmissionWith: arg1  self postTransmission ifNil: [ ^self ].  self postTransmission cull: self toPresenter cull: self fromPresenter cull: arg1testInitializeIsInstanceButtonSelectedShouldBetrue  self assert: biChooseMethod isInstanceSideSelectedtestRemoveBlockExecutedWhenSelectedItemRemoved  | tmp1 tmp2 |  tmp1 := false.  presenter     items: #(1 2 3) asOrderedCollection;     removeItemBlock: [:arg1 |  tmp1 := true.        tmp2 := arg1 ];     selectItem: 2.  presenter removeButton click.  self assert: tmp1 description: 'removeBlock not exeuted when selected item removed!'.  self assert: tmp2 equals: 2parent: arg1  parent := arg1initialize  super initialize.  kmCategory := KMCategory newitems: arg1  self dropList items: arg1behavior  self deprecated: 'This method is an horrible hack because the VersionBrowser was using Code or Diff presenter but was only using the API of the Code presenter... This method and other methods from the CodePresenter API will be removed.'.  ^self contextClassadd: arg1 top: arg2 bottom: arg3 left: arg4 right: arg5  | tmp1 |  tmp1 := self computeLayoutFromTop: arg2 bottom: arg3 left: arg4 right: arg5.  self add: arg1 origin: tmp1 first corner: tmp1 second offsetOrigin: tmp1 third offsetCorner: tmp1 fourthvalue  ^self host valuesAndCounts at: self indexicon: arg1  self button icon: arg1selectedItem  ^self dropList selectedItemwhenMenuChanged: arg1  tree whenMenuChanged: arg1nextMonthButton  ^nextMonthButtonlistSize  self dropList listSizeemptyList  ^self dropList emptyListlabelHolder  self deprecated: 'Nobody should access directly to internals of Spec. Now this variable is not a value holder anymore.'connectPresenters  super connectPresenters.  moreOptionsButton action: [ moreOptionsVisible := moreOptionsVisible not.        self needRebuild: false.        self buildWithSpec ]itemsLabel: arg1  itemsLabel := arg1testOpening  | tmp1 |  tmp1 := application newPresenter: SpTestingPresenterWithAdditionalPresenters.  tmp1 openWithSpec.  #(subpresenter1 subpresenter2 subpresenter3) do: [:arg1 |  self assert: (tmp1 additionalSubpresentersMap at: arg1) owner equals: tmp1 ]scrollValue: arg1  ^scrollValue := arg1askOkToClose: arg1  self deprecated: 'With Spec 2, SpPresenter was refactored to move all window management to WindowPresenter.	From now on, if you want to interact with a window you need to:	- Implement #initializeWindow: method (#initializeDialog: for dialogs) to manage window elements before the presenter is opened	- Use the method #window or #withWindowDo: to interact with windows after it has been opened.'.  self window ifNil: [ askOkToClose := arg1 ] ifNotNil: [:arg2 |  arg2 askOkToClose: arg1 ]activePresenter  ^activePresenterscale: arg1  scale := arg1statusBar: arg1  arg1 ifNotNil: [ arg1 owner: self ].  ^statusbar := arg1execute  'OK' crLogtearDown  mock ifNotNil: [ mock hasWindow ifTrue: [ mock window close ] ].  super tearDownredraw  widget redrawtitle  ^self object class printStringdropList  ^dropListrightText: arg1  rightText := arg1contextMenuFromCommandsGroup: arg1  self contextMenu: [ arg1 value beRoot asMenuPresenter ]evaluate: arg1 andDo: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg1 readStream.  tmp3 := self context doItReceiver.  tmp4 := self context doItContext.  tmp2 := tmp3 class compiler     source: tmp1;     context: tmp4;     receiver: tmp3;     requestor: tmp3;     failBlock: [ ^nil ];     evaluate.  ^arg2 value: tmp2setRGMethodFrom: arg1  rgMethod := arg1 asRingDefinition asHistoricalcalculatedExtent  self extent ifNotNil: [:arg1 |  ^arg1 ].  self minExtent ifNotNil: [:arg1 |  arg1 ].  ^10 @ 10isPresenter  ^falsecolor: arg1  color := arg1title  ^String streamContents: [:arg1 |  arg1 << self class title << ' on: ' << self model currentChangeSet name ]initializeTestedInstance  presenter     numberOfColumns: 2;     displayBlock: [:arg1 |  {arg1 .         42 .         1} ];     items: {1 .         2 .         3}testSetSelectItemOutsideRangeRaisesSelectionChangeEventWithUnsetPath  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedPath ].  presenter selectItem: 4000.  self assert: tmp1 equals: #()initializePresenters  list := self newListneglect: arg1  arg1 neglectMenuModel: selfwidth: arg1  width := arg1presenters  ^self basicPresenters valuesinBounds: arg1  ^self inferiorToMaximum: (self superiorToMinimum: arg1)widget  self deprecated: 'Should use #adapter instead' transformWith: '`@receiver widget' -> '`@receiver adapter'.  ^self spectestIsPresenter  self deny: application isPresenterautoAccept  ^self sliderInput autoAcceptinstallIconStylerFor: arg1  (self isMethodDefinition: arg1) ifFalse: [ ^self ].  IconStyler styleText: self textModel withAst: arg1 astaddSelf: arg1  arg1 add: (SelfEyeElement host: self object)bottomFraction: arg1  layoutFrame bottomFraction: arg1triggerCancelAction  self cancelcolumn  ^self position xat: arg1 ifAbsent: arg2  ^collection at: arg1 ifAbsent: arg2notify: arg1  arg1 dispatchTo: self backenddeepPresenters  ^self presenters inject: #() into: [:arg1 :arg2 |  arg1 , (arg2 isSpLayout ifTrue: [ arg2 deepPresenters ] ifFalse: [ {arg2} ]) ]interpretASpec: arg1 presenter: arg2  self presenter: arg2.  ^self interpretASpec: arg1add: arg1 width: arg2  self add: arg1 withConstraints: [:arg3 |  arg3 width: arg2 ]buttonHighlighted  ^buttonHighlightedtestMaxLengthIsSet  presenter maxLength: 10.  self assert: presenter maxLength equals: 10elementAt: arg1  ^self presenters at: arg1adoptPaneColor: arg1  super adoptPaneColor: arg1.  self fillStyle: self normalFillStylewhenDaySelectedBlock  ^whenDaySelectedBlockgetIndex  ^selection selectedIndexinitializePresenters  radioButtonExample := self instantiate: SpRadioButtonExamplechildrenForObject: arg1  | tmp1 |  tmp1 := arg1 wrappedObject pointersToExcept: {self .         arg1}.  tmp1 := tmp1 reject: [:arg2 |  arg2 class = EyePointerWrapper ].  onlyStrong ifTrue: [ tmp1 := tmp1 reject: [:arg2 |  arg2 pointsOnlyWeaklyTo: arg1 wrappedObject ] ].  ^tmp1 collect: [:arg2 |  PointerEyeElement host: arg1 wrappedObject value: arg2 ]buttonWithMenu: arg1  buttonWithMenu := arg1rebuildWidget  self widgets removeAll.  self createWidgets.  self needFullRebuild: false.  self buildWithSpecLayout: self dynamicLayoutcalculateRowHeights  ^layout isRowHomogeneous ifTrue: [ self calculateHomogeneousRowHeights ] ifFalse: [ self calculateNotHomogeneousRowHeights ]pushHistory  history add: self inspector.  self toolbar updateicon  ^(self value iconOrThumbnailOfSize: 16) ifNil: [ self value class systemIcon ]versionMethod  self method ifNotNil: [:arg1 |  self model browseVersionsFrom: arg1 ]buildWithSpec: arg1  ^self buildWithSpeclabel: arg1  labelHolder value: arg1testSelectIndexesAddsIndexesToSelectedIndexList  presenter selectIndexes: {1 .         2}.  self assert: (presenter selection includesIndexes: {1 .               2})popMessage  self widgetDo: [:arg1 |  self popMessageFrom: arg1 ]testSelectItemsThenSelectOutsideRangeKeepsElements  presenter selectItems: {10 .         20}.  presenter selectItems: {4000 .         5000}.  self assert: (presenter selection includesItems: {10 .               20})icon  | tmp1 |  tmp1 := self model icon.  ^(tmp1 isBlock or: [ tmp1 isMessageSend ]) ifTrue: [ tmp1 cull: self model ] ifFalse: [ tmp1 ]selectAll  ^self input selectAllselectIndex: arg1  self basicSelectIndex: (self withinRangeIndex: arg1)generateSpec  | tmp1 tmp2 |  tmp1 := layoutFrame asArray readStream.  tmp2 := OrderedCollection with: #SpLayoutFrame.  #(leftFraction: topFraction: rightFraction: bottomFraction: leftOffset: topOffset: rightOffset: bottomOffset:) do: [:arg1 |  tmp2 add: arg1.        tmp1 next ifNil: [ tmp2 add: 0 ] ifNotNil: [:arg2 |  tmp2 add: arg2 ] ].  ^tmp2 asArraycheckboxWithHelp  ^checkboxWithHelpstate: arg1  state := arg1testSelectItemAddsIndexToSelectedIndexList  presenter selectItem: 10.  self assert: (presenter selection includesIndex: 1)updatePageTitle: arg1  self widgetDo: [:arg2 |  arg2 relabelPage: (arg2 pageWithModel: arg1) with: (self buildLabelForPage: arg1) ]setUp  super setUp.  presentersBuilder := SpDynamicPresentersListBuilder new     modelObjects: (1 to: 14);     presenter: SpButtonPresenter configuredAs: [:arg1 :arg2 |   ];     buildDynamicPresenter;     yourself.  layout := SpDynamicTopToBottomRowsLayout rows: 7width  ^self lookupProperty: SpStyleGeometry valueOf: #widthsetScrollValue: arg1  self widgetDo: [:arg2 |  arg2 scrollPane           hScrollbarValue: arg1 x;           vScrollbarValue: arg1 y;           updateScrollbars ]click  ^self model action valueactivateOnDoubleClick  activateOnSingleClick := falseswitchAutoscale  self widgetDo: [:arg1 |  arg1 layout: self layoutValue ]initialize  super initialize.  title := 'Title'.  okBlock := [  ].  removeItemBlock := [:arg1 |  self items remove: arg1.  self refresh ]addConstraits: arg1 toChild: arg2  self subclassResponsibilitydayClicked: arg1  self whenDaySelectedBlock cull: arg1 cull: selftestSelectItemSetsSelectedItem  presenter selectItem: 20.  self assert: presenter selection selectedItem equals: 20bottomButton  ^bottomButtonsetIndexes: arg1  self deprecated: 'Use the #selection object instead. This method assumes multiple selection' transformWith: '`@receiver setIndexes: `@arg' -> '`@receiver selection selectIndexes: `@arg'.  self selection selectIndexes: arg1text: arg1  self input text: arg1keyStroke: arg1  ^self model keyStroke: arg1textModel1  ^textModel1whenDisplayBlockChangedDo: arg1  displayBlock whenChangedDo: arg1getIndex  ^self model getIndexneglectMenuModel: arg1  arg1 menuGroups do: [:arg2 |  arg2 menuItems do: [:arg3 |  arg3 shortcut ifNotNil: [:arg4 |  self removeKeyCombination: arg4 ].              arg3 subMenu ifNotNil: [:arg5 |  arg5 neglect: self ] ] ]configurationClass  ^Smalltalk globals at: workingCopy package name asSymboltestRadio3StartsDeselected  self openInstance.  self deny: self presenter radio3 statetestLabelChangeRaisesEvent  self assertEvent: #whenChangedDo: isRaisedInPresenter: presenter whenDoing: [ presenter label: 'test' ]removeTab: arg1  self basicRemoveTab: arg1.  self changed: #removeTab: with: {arg1}contextClass  ^contextClassshortcutGroup: arg1  shortcutGroup := arg1testSetSelectPathOutsideRangeRaisesSelectionChangeEventWithUnsetItem  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter selectPath: #(4).  self assert: tmp1 equals: nilwhenMenuChangedDo: arg1  self property: #contextMenu whenChangedDo: arg1wantsDroppedMorph: arg1 event: arg2 inMorph: arg3  arg1 isTransferable ifFalse: [ ^false ].  ^self wantDropBlock cull: arg1 passenger cull: arg2 cull: arg3getLabelSelector  ^getLabelSelectorhasUnacceptedEdits: arg1  self model hasUnacceptedEdits: arg1initializeTestedInstance  presenter     addColumn: (SpStringTableColumn title: 'Value' evaluated: #printString);     hideColumnHeaders;     roots: #(1 2 3);     children: [:arg1 |  {(arg1 * 2) .         (arg1 * 3) .         (arg1 * 10)} ]addPaneHSplitters  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := paneMorphs reject: [:arg1 |  arg1 layoutFrame bottomFraction = 1 or: [ arg1 layoutFrame bottomFraction = 0 ] ].  [ tmp1 notEmpty ] whileTrue: [ tmp2 := tmp1 first layoutFrame bottomFraction.        tmp3 := tmp1 select: [:arg1 |  arg1 layoutFrame bottomFraction = tmp2 ].        tmp4 := paneMorphs select: [:arg1 |  arg1 layoutFrame topFraction = tmp2 ].        tmp1 := tmp1 copyWithoutAll: (self addPaneHSplitterBetween: tmp3 and: tmp4) ]testContextMenu  | tmp1 tmp2 |  self assert: presenter contextMenu isNil.  tmp1 := SpMenuPresenter new.  tmp2 := false.  presenter whenMenuChangedDo: [ tmp2 := true ].  presenter contextMenu: tmp1.  self assert: presenter contextMenu equals: tmp1.  self assert: tmp2datesToDisplayFor: arg1  ^(self julianDaysIntervalFor: arg1) collect: [:arg2 |  Date julianDayNumber: arg2 ]keyStrokeAction: arg1  keyStroke value: arg1fileOutClass  self model fileOutClass: self selectedClass from: self selectedChangeSettestSelectIndexOutsideRangeUnsetsSelectedItem  presenter selectIndex: 4.  self assert: presenter selection selectedItem equals: nilpushMessage  count := count + 1.  statusBar pushMessage: ('StatusBar message {1}...' format: {count})waitUntilUIRedrawed  self isRunningInUIProcess ifTrue: [ self currentWorld doOneCycle.        ^self ].  self currentWorld defer: [ uiWaitingSemaphore ifNotNil: #signal ].  uiWaitingSemaphore wait: self defaultWaitDurationcontactBookPresenter  ^self contextcontextMenu  ^contextMenuperformTest  specInitializationStrategy beforeTest: self.  super performTestlabel  ^displayBlock cull: modelwithoutScrollBars  wrapScrollBars := falseinitializePresenters  browseButton := self newButton.  configButton := self newButton.  packageButton := self newButton.  self setBrowseButton.  self setConfigButton.  self setPackageButton.  self setSliceButtonbuildAdapterFor: arg1 bindings: arg2  ^SpInterpreter interpretASpec: self presenter: arg1doItContext  ^self objectfillFormWithWorkingModel  | tmp1 |  tmp1 := self workingModel.  self nameTextInput text: tmp1 name.  self surnameTextInput text: tmp1 surname.  self number1Input text: tmp1 number1 asString.  self number2Input text: tmp1 number2 asString.  self scaleInput value: tmp1 scale.  self passwordInput text: tmp1 password.  self checkboxInput state: tmp1 rememberMe.  self dateInput date: tmp1 date.  (genderButtons at: tmp1 gender) state: true.  self itemsInput selectItems: self workingModel selectedItemsrecalculatePages  self widget ifNil: [ ^self ].  self childrenWidgets ifEmpty: [ ^self ].  (needRecalculatePages not and: [ lastExtent = self widget extent and: [ lastPageSize = self childrenWidgets size ] ]) ifTrue: [ ^self ].  needRecalculatePages := false.  lastExtent := self widget extent.  lastPageSize := self childrenWidgets size.  layout direction recalculatePages: selfchanged  ^self widgetDo: [:arg1 |  arg1 changed ]classToTest  ^SpTabPresenterselectPaths: arg1  (arg1 isEmpty or: [ arg1 size = 1 and: [ arg1 first isEmpty ] ]) ifTrue: [ ^self unselectAll ].  arg1 do: [:arg2 |  presenter itemAtPath: arg2 ifAbsent: [ ^self ] ].  selection = arg1 ifTrue: [ ^self ].  selection := arg1contextMenu: arg1  contextMenu := arg1property: arg1 rawValue: arg2  (self observablePropertyNamed: arg1) rawValue: arg2rowIndex  ^rowIndexpresenter  ^presenterhasChildrenBlock  ^hasChildrenBlockHolder valuepageTitleChanged: arg1  self changed: #updatePageTitle: with: {arg1}accessorCode  ^'self class'copyMethodFrom: arg1 to: arg2  | tmp1 |  self checkThatSidesDiffer: [ ^self ].  tmp1 := arg2 selectedChangeSet.  arg1 selectedSelector ifNotNil: [:arg3 |  | tmp2 |        tmp2 := arg1 selectedClass.        self model copySelector: arg3 inClass: tmp2 from: arg1 selectedChangeSet to: tmp1.        arg2 updateClassesListAndMessagesList ]testSelectIndexesOutsideRangeIsEmpty  presenter selectIndexes: {4 .         5}.  self assert: presenter selection isEmptybasicSelectionChanged: arg1  | tmp1 |  tmp1 := self presenter selection.  arg1 newSelectedIndexes ifEmpty: [ ^tmp1 unselectAll ].  (arg1 newSelectedIndexes difference: arg1 oldSelectedIndexes) ifEmpty: [ ^self ].  tmp1 selectPaths: (arg1 newSelectedIndexes collect: [:arg2 |  self widget dataSource pathFromIndex: arg2 ])emphasis: arg1  emphasis := arg1 isSymbol ifTrue: [ {arg1} ] ifFalse: [ arg1 ].  self changed: #emphasis: with: {emphasis}start  setRigidityOfNonExpandedMorph: arg1  self subclassResponsibilityaskBeforeDiscardingEdits: arg1  self widget askBeforeDiscardingEdits: arg1testExecute  self flag: #TODOisFill  ^fill ifNil: [ self class defaultFill ]retrieveDefaultSpec  ^self retrieveSpec: self defaultSpecSelectorindexFromPath: arg1  ^arg1 sumpresenters  ^self items values flattenedtestUnselectUnselectedItemRaisesNoSelectionEvent  | tmp1 |  tmp1 := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectItem: 20.  self assert: tmp1 equals: 0gender  ^genderradio2  ^radio2page  ^pagetestIconFor  presenter     items: #(#add #back #catalog);     icons: [:arg1 |  Smalltalk ui icons iconNamed: arg1 asSymbol ].  self assert: (presenter iconFor: #add) equals: (Smalltalk ui icons iconNamed: #add)evaluation  ^evaluationgetList  ^model itemswindowClosed: arg1  self windows remove: arg1 ifAbsent: [  ]defaultInitialExtent  ^self currentWorld extentwhenValueChangedDo: arg1  self property: #value whenChangedDo: arg1selectIndexes: arg1  self subclassResponsibilitydoubleClick  doubleClick value valueshowOnlySource  ^self model showOnlySourcecloseable  ^closeableHolder valuewindowIsClosing  SystemAnnouncer uniqueInstance unsubscribe: selftestAddColumnRaisesColumnChangedEvent  | tmp1 |  tmp1 := false.  presenter whenColumnsChangedDo: [ tmp1 := true ].  presenter addColumn: (SpStringTableColumn new evaluated: #yourself).  self assert: tmp1urlHoverColor  ^self urlColor darkerrightOffset: arg1  ^0initialize  super initialize.  selectedIndexes := OrderedCollection newheaderMorph  ^headerMorphuseBackend: arg1  backend := SpApplicationBackend findBackendNamed: arg1autoScale  ^autoScalemodel: arg1  (arg1 isSpAnnouncingObject not and: [ self announcingObject isValueHolder ]) ifTrue: [ self announcingObject value: arg1 ] ifFalse: [ self setAnnouncingObject: arg1 ]isRedrawable  ^falsebrowseButton  ^browseButtontestRemoveTabUnsetOwner  presenter addTab: redTab.  self assert: redTab owner equals: presenter.  presenter removeTab: redTab.  self assert: redTab owner isNilfrom: arg1 to: arg2  self from: arg1 to: arg2 transform: nilselectOnlyLastHighlighted  ^self model selectOnlyLastHighlightedreadSelectionBlock  ^readSelectionbuildWidget  | tmp1 tmp2 |  tmp1 := Morph new     changeProportionalLayout;     hResizing: #spaceFill;     vResizing: #spaceFill;     yourself.  tmp2 := (self progressBarState progressBarMorph from: 0 to: 1)     changeProportionalLayout;     hResizing: #spaceFill;     vResizing: #spaceFill;     yourself.  self progressBarState customizeMorphicBar: tmp2.  tmp1 addMorph: tmp2 fullFrame: LayoutFrame identity.  ^tmp1model: arg1  model := arg1icon  ^icontestWhenNumberChangedDo  | tmp1 tmp2 |  tmp1 := 0.  presenter whenNumberChangedDo: [:arg1 |  tmp1 := tmp1 + 1.        tmp2 := arg1 ].  presenter number: 10.  self assert: tmp1 equals: 1.  self assert: tmp2 equals: 10testChangingHelpAffectTheWidget  presenter help: 'ALabel'.  self assert: self adapter helpText equals: 'ALabel'testInferiorToMaximum  presenter maximum: nil.  self assert: (adapter inferiorToMaximum: 100) equals: 100.  presenter maximum: 150.  self assert: (adapter inferiorToMaximum: 100) equals: 100.  presenter maximum: 90.  self assert: (adapter inferiorToMaximum: 100) equals: 90objectChanged  self text doItReceiver: self object.  self text ifNotNil: [:arg1 |  arg1 behavior: self object class ].  self tree     roots: self roots;     expandRootsinitialize  super initialize.  self beExpandablelabelClickable  ^labelClickableselectedIndexes  ^selectedIndexesverticalAlignment  ^vAlignwhenModelChangedDo: arg1  model whenChangedDo: arg1selectPath: arg1  self subclassResponsibilitytestSelectAllDoesNotRaiseEvent  | tmp1 |  tmp1 := 0.  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter selectAll.  self assert: tmp1 equals: 0model  ^modeltestIsClosed  self assert: presenter isClosed.  self openInstance.  self deny: presenter isClosed.  presenter close.  self assert: presenter isClosedcancelButton  ^cancelButtonhistory  ^historybeVertical  direction := SpLayoutDirection verticalinitialize  super initialize.  calculating := falsetestInitializeClassListShouldBeSelectTheFistItem  self assert: biChooseMethod classList selection selectedIndex equals: 1autoRefresh  ^autoRefreshwidthPositionIn: arg1  ^self position < 1 ifTrue: [ (arg1 x * self position) asInteger ] ifFalse: [ self position ]resetArrayComputation  postTransmission  ^postTransmissionnotify: arg1 at: arg2 in: arg3  self flag: #TOMOVE.  self widgetDo: [:arg4 |  arg4 notify: arg1 at: arg2 in: arg3 ]instVarName: arg1  instVarName := arg1testMaxLengthIsSetInWidget  presenter maxLength: 10.  self assert: self widget maxLength equals: 10y: arg1  y := arg1doActivateAtPath: arg1  self itemAtPath: arg1 ifAbsent: [ ^self ].  activationBlock cull: ((SpTreeSingleSelectionMode on: self)           selectPath: arg1;           yourself)syntaxHighlight: arg1  syntaxHighlight := arg1headerLabel  ^headerLabel valuepresenterAt: arg1 ifAbsent: arg2  ^self basicPresenters at: arg1 ifAbsent: [ [ self readSlotNamed: arg1 ] on: SlotNotFound do: arg2 ]testAddPresenterAddsWidget  | tmp1 |  tmp1 := SpButtonPresenter new.  presenter addPresenter: tmp1.  backendForTest waitUntilUIRedrawed.  self assert: self adapter children first equals: tmp1 adapter widgettestActivationOnSingleClickShouldNotActivateOnClickOutside  | tmp1 |  presenter     activateOnSingleClick;     whenActivatedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter clickAtPath: #(4).  self assert: tmp1 isNilactivateOnDoubleClick  activateOnSingleClick := falseremoveChangeSet: arg1 prompting: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := arg1 name.  arg1 okayToRemove ifFalse: [ ^self ].  (arg1 isEmpty or: [ arg2 not ]) ifFalse: [ tmp1 := 'Are you certain that you want to remove (destroy) the change setnamed  "' , tmp2 , '" ?'.        (self confirm: tmp1) ifFalse: [ ^self ] ].  arg2 ifTrue: [ tmp4 := arg1 hasPreamble ifTrue: [ arg1 hasPostscript ifTrue: [ 'a preamble and a postscript' ] ifFalse: [ 'a preamble' ] ] ifFalse: [ arg1 hasPostscript ifTrue: [ 'a postscript' ] ifFalse: [ '' ] ].        tmp4 isEmpty ifFalse: [ (self confirm: 'Caution!  This change set has' , tmp4 , ' which will belost if you destroy the change set.Do you really want to go ahead with this?') ifFalse: [ ^self ] ] ].  tmp3 := arg1 name initialIntegerOrNil.  tmp3 ifNotNil: [ SystemVersion current unregisterUpdate: tmp3 ].  ChangeSet removeChangeSet: arg1vRigid  selectedObjectDo: arg1  self selectedElement ifNotNil: [:arg2 |  arg1 value: arg2 value wrappedObject ]index  ^indexdisableSearch  searchEnabled := falsependingText: arg1  self widgetDo: [:arg2 |  arg2 setText: arg1.        arg2 hasUnacceptedEdits: true ]testWithSyntaxHighlight  presenter withSyntaxHighlight.  self assert: self adapter hasSyntaxHighlightEnabledinitialWidth: arg1  initialWidth value: arg1update: arg1  arg1 = #pushMessage ifTrue: [ self pushMessage ].  arg1 = #popMessage ifTrue: [ self popMessage ].  ^super update: arg1flattenClasses  ^(self styles inject: (OrderedCollection with: self) into: [:arg1 :arg2 |  arg2 isStyleClass ifTrue: [ arg1 addAll: arg2 flattenClasses ].        arg1 ]) flattenedchildNodeClass: arg1  childNodeClass value: arg1selectItem: arg1  list selectItem: arg1testSelectPresenterIndexOutsideRangeUnsetsSelectedIndexInWidget  presenter selectPath: #(100).  self assert: self adapter selectedPaths isEmptyinitialize  self class initializeSlots: self.  super initialize.  needRebuild := truetestSelectIndexTwiceMakesIsListedOnceInSelectedIndexes  presenter     selectIndex: 3;     selectIndex: 3.  self assert: presenter selection selectedIndexes asArray equals: #(3)menu  ^menunewHorizontal  ^self newPanel     listDirection: #leftToRight;     yourselfbuildWithSpecAsPopup  ^self buildWithSpec: #popupselectedPage  ^selectedPageasToolBarPresenter  self deprecated: 'Use #asToolbarPresenter instead.' transformWith: '`@receiver asToolBarPresenter' -> '`@receiver asToolbarPresenter'.  ^self asToolbarPresenterretrievingBlock: arg1  retrievingBlockHolder value: arg1passenger  ^passengerapplyStyle: arg1  super applyStyle: arg1.  arg1 fitContentsmaxLength: arg1  maxLength := arg1.  self updateTextselectedMethods  self deprecated: 'I have the impression this method is not use. If it end up been call, please open an issue on pharo-spec/Spec'.  ^{self selectedMessage} asOrderedCollectionextent  ^extentheight: arg1  self expand: false.  height := arg1methodRemoved: arg1  UIManager default defer: [ self handleMethodRemoved: arg1 ]testSetSelectInvalidPathDoesNotModifySelection  presenter whenSelectionChangedDo: [:arg1 |  self fail ].  presenter selectPath: #(50 1)passwordLabel  ^passwordLabeltestAddPage  self assertEmpty: presenter pages.  presenter addPage: self mockPage.  self assert: presenter pages size equals: 1selectedPage: arg1  selectedPage := arg1topFraction  ^0buildWidget  ^SpStubFastTableView newpassenger: arg1  passenger := arg1 valueheight: arg1  self vRigid.  self widgetDo: [:arg2 |  arg2 height: arg1 ]applyTextStyle  self setText: self presenter text to: self widgetoutputPortNamed: arg1  ^self outputPorts detect: [:arg2 |  arg2 name = arg1 ]property: arg1 whenChangedDo: arg2  (self observablePropertyNamed: arg1) whenChangedDo: arg2whenBehaviorChangedDo: arg1  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8widgetFor: arg1  arg1 adapter ifNotNil: [:arg2 |  ^arg2 widget ].  ^arg1 buildWithSpec     vResizing: #shrinkWrap;     yourselfwhenSelectedItemsChanged: arg1  self deprecated: 'Use #whenSelectedItemsChangedDo: instead.' transformWith: '`@receiver whenSelectedItemsChanged: `@statements' -> '`@receiver whenSelectedItemsChangedDo: `@statements'.  self whenSelectedItemsChangedDo: arg1testHideHeaderTitleUnsetsTitle  presenter     headerTitle: 'title';     hideHeaderTitle.  self deny: presenter hasHeaderTitleasSpecCommand  ^super asSpecCommand     shortcutKey: $n meta;     yourselftestRemoveTab  presenter addTab: redTab.  self assertCollection: presenter tabs hasSameElements: {redTab}.  presenter removeTab: redTab.  self assertCollection: presenter tabs hasSameElements: #()beColumnNotHomogeneous  self columnHomogeneous: falsecancelAction: arg1  self toolbar cancelAction: arg1classDescriptionsMap  ^self class classDescriptionsMaptestOpenPresenterIsBuilt  self openInstance.  self assert: presenter isBuiltactivate  self activateHelpWithoutArguments ifTrue: [ ^self ].  (self hasOption: 'list') ifTrue: [ ^self listApplications ].  self runApplicationisEmpty  ^self contents isEmptyisEmpty  ^self presenters isEmptypageAt: arg1  ^(self pages at: arg1) actualPageMorphisAboutToStyle  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8runCase  self resources do: [:arg1 |  arg1 availableFor: self ].  [ super setUp.  backendForTest runTest: [ presenter := self classToTest new.        self performTest ] ] ensure: [ self tearDown.        self cleanUpInstanceVariables ]testUnselectAllInWidgetWithoutSelectionDoesNotRaiseEvent  | tmp1 |  tmp1 := 0.  presenter selection whenChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  self adapter selectPath: #().  self assert: tmp1 equals: 0label  ^self model labelitems  ^list model itemssetVersionModel  versionModel     state: false;     label: 'Version';     action: [ self versionMethod ]subwidget: arg1 spec: arg2 layoutFrame: arg3  self subwidget: arg1.  self specSelector: arg2.  self layoutFrame: arg3whenPasswordChangedDo: arg1  self property: #isPassword whenChangedDo: arg1updateClassesListAndMessagesList  | tmp1 |  tmp1 := methodsListPresenter selectedItem.  self updateClassesList.  methodsListPresenter setSelectedItem: tmp1.  self updateMessagesListtestWhenActivatedDo  | tmp1 |  tmp1 := false.  presenter whenActivatedDo: [ tmp1 := true ].  self emulateLeftClick.  self assert: tmp1parentNode  ^parentNode valuetestSelectPathSetsSelectedPath  presenter selectPath: #(1 1).  self assert: presenter selection selectedPath equals: #(1 1)asSpLayout  ^selfregisterShortcut: arg1  | tmp1 |  tmp1 := self window.  (tmp1 isNil or: [ arg1 isNil ]) ifTrue: [ ^self ].  tmp1 presenter bindKeyCombination: arg1 toAction: [ self performAction ]presentersInFocusOrder  ^focusOrder ifNil: [ self layoutPresenters select: [:arg1 |  arg1 isVisible and: [ arg1 canTakeKeyboardFocus ] ] ]testSuceedToOpenInstance  self shouldnt: [ self openInstance ] raise: ErrorsetSelectedIndex: arg1  self deprecated: 'Use #selectedIndex: instead' transformWith: '`@receiver setSelectedIndex: `@argument' -> '`@receiver selectedIndex:`@argument'.  ^self selectedIndex: arg1testSuperiorToMinimum  presenter minimum: nil.  self assert: (adapter superiorToMinimum: 100) equals: 100.  presenter minimum: 90.  self assert: (adapter superiorToMinimum: 100) equals: 100.  presenter minimum: 120.  self assert: (adapter superiorToMinimum: 100) equals: 120initialize  super initialize.  self hResizing: nil.  self vResizing: nilwhenSelectedPageChanged: arg1  self deprecated: 'Use #whenSelectedPageChangedDo: instead.' transformWith: '`@receiver whenSelectedPageChanged: `@statements' -> '`@receiver whenSelectedPageChangedDo: `@statements'.  self whenSelectedPageChangedDo: arg1y  ^yaddKeyBindingsTo: arg1  leftText  ^self model leftTextsetSelectedClass: arg1  ^classesListPresenter setSelectedItem: arg1whenSelectedChangedDo: arg1  selected whenChangedDo: arg1climbRate: arg1  climbRate := arg1selectAll  self selection selectAlltestAsButtonPresenter2  | tmp1 |  command := CmCommand forSpec     name: 'foo';     description: 'bar';     iconName: #blank;     yourself.  tmp1 := command asButtonPresenter.  self assert: tmp1 label equals: 'foo'.  self assert: tmp1 help equals: 'bar'.  self assert: tmp1 icon equals: (tmp1 iconNamed: #blank)testSelectItemsThenSelectOutsideRangeKeepsPaths  presenter selectItems: {10 .         20}.  presenter selectItems: {5000 .         6000}.  self assertCollection: presenter selection selectedPaths hasSameElements: {#(1 1 3) .         #(1 3)}whenDeactivationActionChanged: arg1  self deprecated: 'Use #whenDeactivationActionChangedDo: instead.' transformWith: '`@receiver whenDeactivationActionChanged: `@statements' -> '`@receiver whenDeactivationActionChangedDo: `@statements'.  self whenDeactivationActionChangedDo: arg1whenOpenedDo: arg1  self property: #isClosed whenChangedDo: [:arg2 |  arg2 ifFalse: [ arg1 value ] ]emulateLeftClick  self emulateClick: MouseButtonEvent redButtonaddKeyBindingsTo: arg1  self addFocusRotationKeyBindings.  self presenter contextKeyBindings ifNotNil: [:arg2 |  arg2 allEntries keymaps do: [:arg3 |  self bindKeyCombination: arg3 shortcut toAction: arg3 action ] ]itemAtPath: arg1  ^self itemAtPath: arg1 expanding: falseresetSelection  self dropList resetSelectioninitializeDialogWindow: arg1  super initializeDialogWindow: arg1.  arg1     closeOnBackdropClick: true;     okAction: [:arg2 |  self inform: 'Ok action' ];     cancelAction: [:arg2 |  self inform: 'Cancel' ]initialExtent  ^initialExtent ifNil: [ self defaultInitialExtent ]multiSelection: arg1  multiSelection value: arg1initializePresenters  checkboxNormal := self newCheckBox label: 'normal'.  checkboxDisabled := self newCheckBox     label: 'disabled';     disable;     yourself.  checkboxWithColor := self newCheckBox     label: 'red';     color: Color red;     yourself.  checkboxWithHelp := self newCheckBox     label: 'with help';     help: 'this is checkbox with help';     yourself.  checkboxWithLabelOnLeft := self newCheckBox     label: 'left';     yourself.  checkboxExample := self instantiate: SpCheckBoxExample.  self whenBuiltDo: [ checkboxWithLabelOnLeft labelOnLeft ]description  ^descriptionshiftLastWidgets  | tmp1 tmp2 |  (lastFractionIndex > 0 and: [ lastFractionIndex < size ]) ifFalse: [ ^self ].  tmp1 := size - 1.  [ tmp1 > lastFractionIndex ] whileTrue: [ | tmp3 |        tmp2 := self commands at: tmp1.        tmp1 := tmp1 - 1.        tmp3 := tmp2 rightOffset - tmp2 leftOffset.        tmp2           leftOffset: (width + tmp3) negated;           rightOffset: width negated.        width := width + tmp3 ].  self assert: tmp1 = lastFractionIndex.  tmp2 := self commands at: tmp1.  tmp2 layoutFrame rightOffset: width negatedowner: arg1  owner := arg1decreaseValueOf: arg1  arg1 setText: (self decreasedValueFrom: arg1 getText)possibleEntities  ^possibleEntities ifNil: [ #() ] ifNotNil: [ possibleEntities value ]initialize  super initialize.  self beNotHomogeneous.  self spacing: 0.  self borderWidth: 0newMockContext  ^SpCodeCommandContextMock newmodel: arg1  model := arg1newVertical  ^self newPanel     listDirection: #topToBottom;     yourselfaddSpecialFields: arg1  arg1 add: (DynamicEyeElement host: self object label: 'sign' value: [ self object sign ]).  arg1 add: (DynamicEyeElement host: self object label: 'significand' value: [ self object significand ]).  arg1 add: (DynamicEyeElement host: self object label: 'exponent' value: [ self object exponent ]).  arg1 add: (DynamicEyeElement host: self object label: 'binary' value: [ self object binaryLiteralString ])selectedItems  ^self selectedIndexes collect: [:arg1 |  self model at: arg1 ]headerColumn: arg1  | tmp1 |  arg1 id ifNil: [ ^nil ].  tmp1 := SpHeaderCellMorph new     addMorph: arg1 id asMorph asReadOnlyMorph;     yourself.  arg1 isSortable ifTrue: [ tmp1 eventHandler: (MorphicEventHandler new on: #click send: #sortByColumn:event:morph: to: self withValue: arg1) ].  ^tmp1customSubMenu: arg1  arg1 addGroup: [:arg2 |  arg2           addItem: [:arg3 |  arg3                 name: 'List Methods Using "' , self instVarName , '"';                 action: [ self referencesToInstanceVariable ] ];           addItem: [:arg3 |  arg3                 name: 'List Methods Storing into "' , self instVarName , '"';                 action: [ self storingsIntoInstanceVariable ] ] ]leftFraction  ^0isRedrawable  ^trueclassToTest  ^SpListPresentermoreOptionsArea: arg1  moreOptionsArea := arg1uniformDropList  ^uniformDropListnewToolbarItem  ^SpToolBarButton newadd: arg1  self add: arg1 origin: 0 @ 0 corner: 1 @ 1emptyList  model collection: OrderedCollection newinitialize  super initialize.  labelHolder := '' asValueHolder.  iconHolder := self defaultIcon asValueHolder.  morphHolder := nil asValueHolder.  retrievingBlockHolder := nil asValueHolder.  menuHolder := nil asValueHolder.  actionsHolder := OrderedCollection new asValueHolder.  closeableHolder := true asValueHolder.  tabSelectedActionHolder := [  ] asValueHolder.  selectedHolder := false asValueHolderaddContact: arg1 after: arg2  contents add: arg1 after: arg2propertyAt: arg1 ifAbsentPut: arg2  ^self properties at: arg1 ifAbsentPut: arg2whenChangedDo: arg1  subscriptions add: arg1okToChange  ^self model okToChangeat: arg1  ^collection at: arg1retrievingBlockHolder  ^retrievingBlockHoldersetTargetBounds  | tmp1 |  tmp1 := self target.  tmp1 bounds: (tmp1 bounds withRight: self left - 1)tempIndex: arg1  tempIndex := arg1buildWidget  | tmp1 |  tmp1 := PanelMorph new     changeTableLayout;     listDirection: self listDirection;     hResizing: #spaceFill;     vResizing: #rigid;     cellInset: self class defaultItemSeparation;     height: self class defaultHeight;     yourself.  self addModelTo: tmp1.  ^tmp1title  ^'Point'beEncrypted  ^self input beEncryptednewLayout  ^SpMorphicGridLayout new     layout: (SpGridLayout new           borderWidth: 0;           columnSpacing: 0;           rowSpacing: 0;           columnHomogeneous: false;           rowHomogeneous: false;           yourself);     yourselftearDown  aClass ifNotNil: [:arg1 |  arg1 removeFromSystem ].  super tearDownselectedObject  ^self valuewhenAboutToStyleBlockChanged: arg1  self deprecated: 'Use #whenAboutToStyleBlockChangedDo: instead.' transformWith: '`@receiver whenAboutToStyleBlockChanged: `@statements' -> '`@receiver whenAboutToStyleBlockChangedDo: `@statements'.  self whenAboutToStyleBlockChangedDo: arg1whenDisplayBlockChanged: arg1  self deprecated: 'Use #whenDisplayBlockChangedDo: instead.' transformWith: '`@receiver whenDisplayBlockChanged: `@statements' -> '`@receiver whenDisplayBlockChangedDo: `@statements'.  self whenDisplayBlockChangedDo: arg1removePicked: arg1  pickedItemsHolder remove: arg1 ifAbsent: [ ^self ]testUnselectUnselectedItemRaisesNoSelectionEvent  | tmp1 |  tmp1 := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectItem: 20.  self assert: tmp1 equals: 0testLabelIsSet  presenter label: 'test'.  self assert: presenter label equals: 'test'acceptColumnVisitor: arg1  ^arg1 visitCompositeColumn: selfrowSpacing  ^rowSpacing ifNil: [ self class defaultRowSpacing ]incomingTransmission: arg1 from: arg2  self destinationPresenter items: arg1leftText  ^leftTexttestSelectItemThenSelectOutsideRangeKeepsFirstIndex  presenter selectItem: 10.  presenter selectItem: 500.  self assert: (presenter selection includesIndex: 1)cell: arg1  cell := arg1testSelectIndexOutsideRangeHasNoSelectedItems  presenter selectIndex: 4.  self assert: presenter selection selectedItems isEmptyselectedMethod  ^messageList selectedMethodmodel  self deprecated: 'Use #presenter instead' transformWith: '`@receiver model' -> '`@receiver presenter'.  ^self presenteropenDialogWithSpec: arg1  ^self application openDialog: self withSpecLayout: (self retrieveSpec: arg1)selectDialog: arg1  selectDialog := arg1whenTextIsAccepted: arg1  self input whenTextIsAccepted: arg1progressBarState  ^self model stateparseStyleClass  | tmp1 tmp2 tmp3 |  [ tmp2 := self newReference.  tmp1 := self parseStyleName.  tmp3 := self styleClass new     name: tmp1;     parent: currentStyle;     yourself.  self pushStyle: tmp3 during: [ tmp3 fromSton: self ].  self setReference: tmp2 to: tmp3 ] on: NotFound do: [:arg1 |  acceptUnknownClasses ifTrue: [ tmp3 := STON mapClass new.              self storeReference: tmp3.              self parseMapDo: [:arg2 :arg3 |  tmp3 at: arg2 put: arg3 ].              tmp3 at: STON classNameKey put: arg1 object ] ifFalse: [ self error: 'Cannot resolve class named ' , arg1 object printString ] ].  ^tmp3testAddPresenterPushesItToPresenterList  self presenter addPresenter: (SpNullMillerPresenter on: SpLabelPresenter new).  self assert: self presenter size equals: 1withProgressionBlock  ^withProgressionBlockstyleName  ^'toolBar.icons'removePageAt: arg1  pagesHolder removeAt: arg1canTakeKeyboardFocus  ^falsepresenterAt: arg1 put: arg2  ^self basicPresenters at: arg1 put: arg2title  ^idcolor: arg1  self widgetDo: [:arg2 |  arg2 color: arg1 ]setTargetBounds  | tmp1 |  tmp1 := self target.  tmp1 bounds: (tmp1 position corner: tmp1 right @ (self top - 1))calculateColumnWidths  ^layout isColumnHomogeneous ifTrue: [ self calculateHomogeneousColumnWidths ] ifFalse: [ self calculateNotHomogeneousColumnWidths ]connectPresenters  button action: [ input text: textToReset ].  input whenTextChangedDo: [:arg1 |  label label: arg1 ].  check     whenActivatedDo: [ self needRebuild: false.        self buildWithSpecLayout: self class defaultSpec ];     whenDeactivatedDo: [ self needRebuild: false.        self buildWithSpecLayout: self class bottomLayout ]beMultipleSelection  self selectionMode: (SpMultipleSelectionMode on: self)color: arg1  ^color := arg1visitStringColumn: arg1  initializePresenters  computeNonSplitterWidgetsIn: arg1  (self commands reject: #isSplitter) do: [:arg2 |  self setOffsetsFor: arg2 top: arg2 topOffset left: arg2 leftOffset bottom: arg2 bottomOffset right: arg2 rightOffset borderWidth: self class windowBorderWidth.        arg1 addAll: arg2 asSpecElements ]drawBlock: arg1  drawBlock := arg1object  ^objectapplyVisibility  width: arg1  width := arg1buildWidget  ^SpStubSliderView newtraverseInFocusOrderDo: arg1 excluding: arg2  arg2 add: self.  arg1 value: self.  self selectedPage ifNil: [ ^self ].  self selectedPage activePresenter traverseInFocusOrderDo: arg1 excluding: arg2defineInputPorts  ^{SpRootsPresenterPort new}initializeDropList  toolbarPresenter     addItemLabeled: 'Source' do: [ self textConverter: SourceMethodConverter new ];     addItemLabeled: 'Time stamp' do: [ self textConverter: TimeStampMethodConverter new ]visitCompositeColumn: arg1  arg1 columns do: [:arg2 |  self visit: arg2 ]toPrintableString: arg1  self flag: #TODO.  ^String streamContents: [:arg2 |  arg2 << ' "' << arg1 << '"' ]index: arg1  index := arg1help  ^helpheaderAction: arg1  headerAction value: arg1add: arg1 top: arg2 bottom: arg3  self add: arg1 top: arg2 bottom: arg3 left: nil right: nilcontextMenu  ^contextMenutype: arg1  self text: arg1whenSelectedItemChangedDo: arg1  self whenSelectionChangedDo: [:arg2 |  arg1 cull: arg2 second ]wantDropBlock  ^self model wantDropBlockflattenProperties  ^(self flattenClasses inject: self properties into: [:arg1 :arg2 |  arg1 , arg2 properties ]) flattenedconnectPresenters  sliders whenChangedDo: [ preview image: self makeNewForm ]headerFontChanged  self widgetDo: [:arg1 |  arg1 header label: self headerLabel font: self headerFont.        arg1 container resizerChanged ]transform: arg1  ^arg1testClassSideRadioButtonState  biChooseMethod radioButtonClassSide click.  self deny: biChooseMethod isInstanceSideSelectedlayoutFrame: arg1  self activate.  super layoutFrame: arg1pageClass  ^SpDemoTablePresenterposition  ^positionapplyStyleTo: arg1  ^arg1propertyAt: arg1 ifPresent: arg2 ifAbsentPut: arg3  ^self properties at: arg1 ifPresent: arg2 ifAbsentPut: arg3beEncrypted  self input beEncryptedtestNewPresenterIsNotDisplayed  self deny: presenter isDisplayednewExampleMenu  | tmp1 |  tmp1 := String loremIpsum substrings.  ^SpMenuPresenter new     addGroup: [:arg1 |  1 to: 10 atRandom do: [:arg2 |  arg1 addItem: [:arg3 |  arg3                       name: ('{1}: {2}' format: {arg2 .                                 tmp1 atRandom});                       action: [ button label: arg3 name ] ] ] ];     yourselfinitializeWindow: arg1  arg1 title: 'Calendar'testStayingActiveDoesNotRaiseChangedEvent  presenter state: true.  self denyEvent: #whenChangedDo: isRaisedInPresenter: presenter whenDoing: [ presenter state: true ]y  ^yremoveSubWidgets  innerWidget removeAllMorphsmodel  ^modelinitializePrivateHooks  self flag: #todo.  self initializeWidgets.  self initializePresenters.  self initializePresenter.  self connectPresenters.  self updatePresenteraddToolBarTo: arg1  | tmp1 |  tmp1 := self model toolBar buildWithSpec.  arg1 addMorphBack: tmp1.  tmp1     hResizing: #spaceFill;     vResizing: #rigidpresentersDo: arg1  self basicPresenters valuesDo: arg1useProportionalLayout  self widgetDo: [:arg1 |  arg1 changeProportionalLayout ]testSelectionStartsEmptyIfStartWithoutSelectionIsSet  self assert: self presenter selectedItem equals: nil.  self assert: self adapter selectedIndexes equals: #()icon: arg1  icon := arg1item  ^itemwhenSearchChangedDo: arg1  self property: #searchEnabled whenChangedDo: arg1moreOptionsText  ^moreOptionsTextmenu  ^self newMenu     title: 'Context menu example';     addGroup: [:arg1 |  arg1           addItem: [:arg2 |  arg2                 name: 'Print in transcript';                 shortcut: $p meta;                 description: 'Print the selected class on Transcript';                 action: [ table1 selectedItem traceCr ] ];           addItem: [:arg2 |  arg2                 name: 'Browse';                 iconName: #open;                 action: [ table1 selectedItem browse ] ];           addItem: [:arg2 |  arg2                 name: 'Print infos';                 subMenu: (self newMenu addGroup: [:arg3 |  arg3                             addItem: [:arg4 |  arg4                                   name: 'Print number of methods';                                   action: [ table1 selectedItem methods size traceCr ] ];                             addItem: [:arg4 |  arg4                                   name: 'Print number of variables';                                   action: [ table1 selectedItem instanceVariables size traceCr ] ] ]) ] ];     addGroup: [:arg1 |  arg1           addItem: [:arg2 |  arg2                 name: 'Item showing only if item a odd number of letters';                 visibleIf: [ table1 selectedItem printString size odd ];                 action: [ table1 selectedItem traceCr ] ];           addItem: [:arg2 |  arg2                 name: 'Disabled in second group';                 disable;                 action: [ table1 selectedItem traceCr ] ];           addItem: [:arg2 |  arg2                 name: 'Disabled if class begins with A';                 enabled: [ table1 selectedItem printString first ~= $A ];                 action: [ table1 selectedItem traceCr ] ] ]beInteger  self numberType: Integersubscriptions  ^subscriptionswhenSelectDialogChanged: arg1  self property: #selectDialog whenChangedDo: arg1updateMenu  instVarNames  ^self instVarToModelObject collect: #keybuildLabelForPage: arg1  | tmp1 |  tmp1 := Morph new     changeTableLayout;     vResizing: #spaceFill;     hResizing: #shrinkWrap;     cellInset: self class cellInset;     color: Color transparent;     listDirection: #leftToRight;     yourself.  arg1 icon ifNotNil: [:arg2 |  tmp1 addMorphBack: arg2 asMorph ].  tmp1 addMorphBack: arg1 title asMorph.  ^tmp1addDefaultButton: arg1 do: arg2  defaultButton := self addButton: arg1 do: arg2.  defaultButton addStyle: 'default'.  ^defaultButtoninitialize  super initialize.  self whenLabelChangedDo: [ self changed: #getText ]classToTest  ^SpEditableListPresentercontextMenu: arg1  contextMenu := arg1execute  self editor copySelectionconnectPresenters  okButton action: self okActionBlocktree  ^tree ifNil: [ tree := self instantiate: SpTreePresenter.        tree whenBuiltDo: [ self initializeShortcuts ].        tree           whenSelectedItemChanged: [:arg1 |  arg1 ifNotNil: [ self elementChanged ] ];           childrenBlock: [:arg2 |  self childrenFor: arg2 ];           iconBlock: [:arg3 |  self iconFor: arg3 ];           displayBlock: [:arg2 |  self labelFor: arg2 ];           menu: [:arg4 |  self inspectionMenu: arg4 ];           doubleClick: [ self diveInto: self selectedObject ];           yourself ]dropEnabled: arg1  self widget ifNotNil: [:arg2 |  arg2 dropEnabled: arg1 ]buildWithSpecLayout: arg1  | tmp1 |  adapter := self basicBuildAdapterWithSpecLayout: arg1.  tmp1 := adapter widget.  self announce: (SpWidgetBuilt model: self widget: tmp1).  ^tmp1initializePresenters  button1 := self newCheckBox.  button2 := self newCheckBox.  button3 := self newCheckBox.  label := self newLabel.  button1 label: 'Button 1'.  button2 label: 'Button 2'.  button3 label: 'Button 3'.  self updateLabel.  self setFocusmoveClassFrom: arg1 to: arg2  self checkThatSidesDiffer: [ ^self ].  (self okToChange and: [ arg1 selectedClass notNil ]) ifFalse: [ ^self ].  self copyClassFrom: arg1 to: arg2.  arg1 forgetClasstestSubscribeToChangeRaisesEventWithNewValue  | tmp1 |  point property: #x whenChangedDo: [:arg1 |  tmp1 := arg1 ].  point x: 17.  self assert: tmp1 equals: 17options: arg1  options := arg1autoAccept  ^input autoAccepttextToReset  ^textToResettestSelectPathThenSelectInvalidPathKeepsFirstElement  presenter selectPath: #(1 3).  presenter selectPath: #(50).  self assert: (presenter selection includesItem: 10)initialExtent  ^self inspector initialExtenttestChangeDeactivatedAfterOpenCheckboxDectivatesIt  presenter state: true.  self openInstance.  presenter state: false.  self deny: presenter statesubtractFrom: arg1 to: arg2  | tmp1 tmp2 |  tmp1 := arg1 selectedChangeSet.  tmp2 := arg2 selectedChangeSet.  self checkThatSidesDiffer: [ ^self ].  self model subtractFrom: tmp1 to: tmp2.  changeSorterRight setSelectedChangeSet: tmp1pendingText  ^self widgetDo: [:arg1 |  arg1 text ]stepTime  ^50cancelled  ^falsetestSelectingAPathUpdatesSelectionInPresenter  self presenter selection selectPath: #(2 3).  self assert: self presenter selectedItem equals: 20multiLabel  ^multiLabelfieldDisabled  ^fieldDisabledtestSelectPresenterItemSetsSelectedIndexInWidget  presenter selectItem: (presenter items at: 2).  self assert: (self adapter selectedIndexes includes: 2)doesNotUnderstand: arg1  ^arg1 sendTo: subwidgetnameLabel: arg1  nameLabel := arg1classToTest  ^SpListPresenterspecSpacer  ^SpSpacerPresenter newtestSelectItemsOutsideRangeHasNoSelectedItems  presenter selectItems: {300 .         400}.  self assert: presenter selection selectedItems isEmptyclose  self isOpen ifFalse: [ ^self ].  self changed: #close with: #().  self application windowClosed: selftestSelectInvalidPathsHasNoSelectedPaths  presenter selectPaths: {#(10 20) .         #(20 20)}.  self assert: presenter selection selectedPaths isEmptyaddPresenter: arg1  arg1 owner: self.  self model add: arg1notify: arg1  arg1 type notify: arg1 on: selfaddGroup: arg1  | tmp1 |  tmp1 := self instantiate: SpMenuGroupPresenter.  arg1 value: tmp1.  self addMenuGroup: tmp1layoutTopToBottom: arg1 in: arg2  self ensureHeightPosition: arg1 in: arg2.  super layoutTopToBottom: arg1 in: arg2withSyntaxHighlight  self syntaxHighlight: trueplaceholder: arg1  ^self input placeholder: arg1triggerCancelAction  cancelAction ifNil: [ ^self ].  cancelAction cull: selfsetToolbarFrom: arg1  | tmp1 |  tmp1 := arg1 value.  self toolbar: tmp1.  self model presenter focusOrder addLast: toolbar.  toolbar focusOrder addLast: self modelbuildWidget  ^SpStubMenuGroupView newminHeight  ^self lookupProperty: SpStyleGeometry valueOf: #minHeightmethodClassNameForItem: arg1  ^arg1 methodClass ifNotNil: [:arg2 |  arg2 name ] ifNil: [ '' ]initializeWindow  super initializeWindow.  self presenter initializeDialogWindow: selfnumber2Label: arg1  number2Label := arg1newTabManager  self deprecated: 'Use newNotebook instead' on: '2019-01-24' in: #Pharo8.  ^self instantiate: SpTabManagerPresenterinitialize  super initialize.  moreOptionsVisible := false.  buttons := OrderedDictionary newbrowseSelectedObject  self selectedObjectDo: [:arg1 |  arg1 browse ]classToTest  ^SpTreeTablePresenterindeterminateStepIncrease  ^oddPassage ifTrue: [ 40 ] ifFalse: [ 15 ]childrenBlock  ^[ self model buildChildren ]testSelectionStartsSelectingFirst  self assert: self presenter selectedItem equals: 10.  self assert: self adapter selectedIndexes equals: #(1)initializeWindow: arg1  super initializeWindow: arg1.  arg1 title: 'Recent versions of ' , rgMethod displayNamewhenIsResizableChangedDo: arg1  self property: #isResizable whenChangedDo: arg1hasContents: arg1  hasContents := arg1messages: arg1  messageList messages: arg1spacing: arg1  spacing := arg1value  ^slider valueitems: arg1  self dropList items: arg1dragEnabled  ^dragEnabledposition  ^positionaddConstraits: arg1 toChild: arg2  layout direction setRigidityOfNonExpandedMorph: arg2.  ^arg2adapt: arg1  widget := self buildWidgetWith: arg1.  arg1 addDependent: widget.  self bindModel: arg1 andWidget: widgetcolumns  ^tree columnsleftPanel  ^leftPanelcanTakeKeyboardFocus  ^falsebuildMenuBar  ^self newMenuBar addGroup: [:arg1 |  arg1 addItem: [:arg2 |  arg2                 name: 'File';                 subMenu: self buildFileMenu ] ]selectedIndexes  self deprecated: 'Use the #selection object instead. This method assumes multiple selection' transformWith: '`@receiver selectedIndexes' -> '`@receiver selection selectedIndexes'.  ^self selection selectedIndexesisRedrawable  ^trueaddItemRight: arg1  arg1 owner: self.  rightItems add: arg1.  self notifyPropertyChanged: #rightItemspageClass  ^SpDemoImagePresenteraddSpecialFields: arg1  arg1 add: (DynamicEyeElement host: self object label: 'unicode' description: [ self objectAsUnicodeCodePoint ] value: [ self object codePoint ])visitCommand: arg1  arg1 hasShortcutKey ifFalse: [ ^self ].  kmCategory addKeymapEntry: (KMKeymap shortcut: arg1 shortcutKey action: [ arg1 canBeExecuted ifTrue: [ arg1 execute ] ])columnInset: arg1  columnInset value: arg1presentersDo: arg1  self basicPresenters valuesDo: arg1initializeWindow: arg1  self flag: #TODOapplyTo: arg1  self properties do: [:arg2 |  arg2 applyTo: arg1 ]enabled: arg1  testWhenSelectedPageChangedDo  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := 0.  tmp1 := self mockPage.  tmp2 := SpNotebookPage title: 'test' provider: [ SpButtonPresenter new ].  presenter whenSelectedPageChangedDo: [:arg1 |  tmp4 := arg1.        tmp3 := tmp3 + 1 ].  presenter addPage: tmp1.  presenter addPage: tmp2.  presenter selectPageIndex: 2.  self assert: tmp3 equals: 1.  self assert: tmp4 equals: tmp2testHasIcon  self deny: command hasIcon.  command iconName: #banana.  self assert: command hasIconwhenChangedDo: arg1  self property: #selectedIndexes whenChangedDo: [ arg1 cull: self ]initialize  super initialize.  self     name: 'Rename';     description: 'Rename the selected contact.'ensureWidthPosition: arg1 in: arg2  | tmp1 |  self position ifNil: [ ^self ].  tmp1 := arg1 submorphs first.  tmp1 hResizing = #rigid ifFalse: [ tmp1 hResizing: #rigid ].  tmp1 privateBounds: (tmp1 bounds withWidth: (self widthPositionIn: arg2 extent))shortcutCharacter  ^self shortcut ifNotNil: [:arg1 |  arg1 platformCharacter ]selected: arg1  selected value: arg1testVisitCommandThatCantBeRunWithHideStrategy  self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.  (CmBlockCommand new     name: 'c';     description: 'desc';     context: [ 41 ];     canBeExecutedBlock: [:arg1 |  arg1 = 42 ];     block: [:arg1 |  42 ];     yourself) asSpecCommand beHiddenWhenCantBeRun acceptVisitor: menuBuilder.  self assert: menuBuilder menuPresenter defaultGroup menuItems isEmptyinitialize  textConverter := SourceMethodConverter new.  super initializewrappers  ^associationsWrapperToItem keysinspector: arg1  self basicInspector: arg1.  self pushHistoryselectionMode: arg1  selectionMode ifNotNil: [ selectionMode transferSubscriptionsTo: arg1 ].  selectionMode := arg1openWithSpecLayout: arg1  self buildWithSpecLayout: arg1.  self changed: #open with: #().  self allPresenters do: [:arg2 |  arg2 announceDisplayed ].  self updateTitlenumber2Input: arg1  number2Input := arg1testSelectItemOutsideRangeUnsetsSelectedIndex  presenter selectItem: 40.  self assert: presenter selection selectedIndex equals: 0cancelled: arg1  cancelled := arg1assertHasHeader: arg1  self waitUntilUIRedrawed.  self assert: (arg1 widget instVarNamed: #showColumnHeaders)showColumnHeaders  showColumnHeaders := truetestSelectItemOutsideRangeHasNoSelectedPath  presenter selectItem: 4000.  self assert: presenter selection selectedPaths isEmptydynamicPresenter  ^dynamicPresenterwhenMenuHolderChanged: arg1  self deprecated: 'Use #whenMenuHolderChangedDo: instead.' transformWith: '`@receiver whenMenuHolderChanged: `@statements' -> '`@receiver whenMenuHolderChangedDo: `@statements'.  self whenMenuHolderChangedDo: arg1styleSheet  ^self application styleSheettestSelectAbsentItemGivesEmptySelection  presenter selectItem: 4000.  self assert: presenter selection isEmptyadapterName  ^adapterNamelabelClickable  ^labelClickableHolder valuemorph: arg1  morph := arg1getText  ^self model labelsetEditingModeFor: arg1  self hasSyntaxHighlight ifTrue: [ self setEditingModeFor: arg1 withBehavior: self behavior ] ifFalse: [ super setEditingModeFor: arg1 ]testSetSelectIndexRaisesSelectionChangeEventWithSelectedItem  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter selectIndex: 1.  self assert: tmp1 equals: 10doubleClickAction: arg1  self deprecated: 'Use whenActivatedDo: instead' transformWith: '`@receiver whenActivatedDo: `@argument' -> '`@receiver doubleClickAction: `@argument'.  self whenActivatedDo: [:arg2 |  arg1 value: arg2 selectedItem ]testSetSortingBlockBeforeItems  | tmp1 |  tmp1 := 0.  presenter whenSortingBlockChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter sortingBlock: [:arg2 |  arg2 label asNumber ] ascending.  presenter items: #(3 8 1 0).  self assert: tmp1 equals: 1.  self assert: (presenter model at: 1) label equals: '0'monthYearLabel  ^monthYearLabelstoringsIntoInstanceVariable  ^self systemNavigation browseAllStoresInto: self instVarName from: self hostClasspresenters  ^self model presenterspresenter: arg1 configuredAs: arg2  self presenterProvidedBy: [:arg3 |  arg1 ] configuredAs: arg2contentArea: arg1  contentArea := arg1setText: arg1 to: arg2  arg2 setText: arg1testSetSelectPathRaisesSelectionPathChangeEventWithSelectedPath  | tmp1 |  presenter selection whenChangedDo: [:arg1 |  tmp1 := arg1 ].  presenter selectPath: #(1 2).  self assert: tmp1 equals: #(1 2)selectDirectoryTitle: arg1  ^UIManager default chooseDirectory: arg1 path: ''name  ^namegenders  ^#(male female)testHidePresenterHidesWidget  self presenter hide.  self deny: self adapter isVisiblelist1Menu  ^self newMenu     title: 'Context menu example';     addGroup: [:arg1 |  arg1           addItem: [:arg2 |  arg2                 name: 'Print in transcript';                 shortcut: $p meta;                 description: 'Print the selected class on Transcript';                 action: [ list1 selectedItem traceCr ] ];           addItem: [:arg2 |  arg2                 name: 'Browse';                 iconName: #open;                 action: [ list1 selectedItem browse ] ];           addItem: [:arg2 |  arg2                 name: 'Print infos';                 subMenu: (self newMenu addGroup: [:arg3 |  arg3                             addItem: [:arg4 |  arg4                                   name: 'Print number of methods';                                   action: [ list1 selectedItem methods size traceCr ] ];                             addItem: [:arg4 |  arg4                                   name: 'Print number of variables';                                   action: [ list1 selectedItem instanceVariables size traceCr ] ] ]) ] ];     addGroup: [:arg1 |  arg1           addItem: [:arg2 |  arg2                 name: 'Item showing only if item a odd number of letters';                 visibleIf: [ list1 selectedItem printString size odd ];                 action: [ list1 selectedItem traceCr ] ];           addItem: [:arg2 |  arg2                 name: 'Disabled in second group';                 disable;                 action: [ list1 selectedItem traceCr ] ];           addItem: [:arg2 |  arg2                 name: 'Disabled if class begins with A';                 enabled: [ list1 selectedItem printString first ~= $A ];                 action: [ list1 selectedItem traceCr ] ] ]isMultipleSelection  ^truey  ^yallowMenuOnNoItem: arg1  allowMenuOnNoItem value: arg1newHeaderMorph  ^(self theme newRowIn: self theme for: {self tabSelectorMorph})     cellInset: 0;     cellPositioning: #bottomCenter;     borderWidth: 0testListBox  | tmp1 tmp2 tmp3 |  tmp2 := SpMockApplication new.  tmp1 := SpVersatileDialogPresenter newApplication: tmp2.  tmp3 := tmp1 newList.  tmp3 items: #(one two three).  tmp1 contentArea: tmp3.  tmp1 addButton: #ok text: 'OK' value: #ok condition: [ tmp3 selection isEmpty not ].  tmp1 addButton: #cancel text: 'Cancel' value: nil.  tmp1 mainIcon: (self iconNamed: #question).  tmp1 openModalWithSpec.  tmp1 withWindowDo: [:arg1 |  arg1 title: 'Confirmation' ].  tmp1 contentArea selection selectIndex: 2.  (tmp1 buttons at: #ok) click.  self assert: tmp1 result equals: #ok.  self assert: tmp1 contentArea selection selectedItem equals: #twosetUp  super setUp.  presenter := SpNumberInputFieldPresenter new.  adapter := self actualClass adapt: presenterrightItems  ^rightItemstestSubscribeToUnexistentPropertyRaisesError  self should: [ point property: #z whenChangedDo: [ self fail: 'This event shouldnt have been subscribed at all' ] ] raise: SlotNotFoundtitle  ^'OpenOnStringExample'aboutText: arg1  aboutText := arg1initialize  super initialize.  self initializeTSearchable.  showColumnHeaders := true.  columns := #().  isResizable := falseisSpLayout  ^truesetRightOffset: arg1 for: arg2 borderWidth: arg3  arg3 rightFraction = 1 ifTrue: [ arg1 isZero ifTrue: [ arg3 rightOffset: arg2 negated ] ifFalse: [ arg3 rightOffset: arg1 - self splitterWidth ] ]tearDown  window ifNotNil: [ window delete ].  super tearDowntestSelectMultipleItemAddsAllToSelectedIndexList  presenter selectItem: 10.  presenter selectItem: 30.  self assert: (presenter selection includesIndex: 1).  self assert: (presenter selection includesIndex: 3)newStatusBar  ^self instantiate: SpStatusBarPresenterrefreshShowColumnHeaders  self presenter isShowingColumnHeaders ifTrue: [ self widget           showColumnHeaders;           refresh ] ifFalse: [ self widget           hideColumnHeaders;           refresh ]model: arg1  model := arg1testListWithoutColumnsHasSingleColumn  self assert: self adapter columns size equals: 1initializeTestedInstance  presenter     addColumn: (SpStringTableColumn title: 'Value' evaluated: #printString);     hideColumnHeaders;     beMultipleSelection;     roots: #(1 2 3);     children: [:arg1 |  {(arg1 * 2) .         (arg1 * 3) .         (arg1 * 10)} ]setFocusOrder  self focusOrder     add: browseModel;     add: usersModel;     add: sendersModel;     add: implementorsModel;     add: versionModelresolveSymbol: arg1  ^Smalltalk at: arg1hAlign: arg1  hAlign := arg1notify: arg1 at: arg2 in: arg3  self changed: #notify:at:in: with: {arg1 .         arg2 .         arg3}displayBlock: arg1  self deprecated: 'Please use #display: instead' transformWith: '`@receiver displayBlock: `@arg' -> '`@receiver display: `@arg'.  self dropList display: arg1whenFontChangedDo: arg1  self property: #font whenChangedDo: arg1initializePresenters  x := self newTextInput.  y := self newTextInputimage: arg1  image := arg1connectPresenters  self submitButton action: [ self submit ].  self restoreButton action: [ self restore ]testScrollDownToPosteriorIndexScrollsBottomToIndex  self flag: #pharo7.  SystemVersion current major < 8 ifTrue: [ self skip ].  presenter items: (1 to: 500).  presenter verticalAlignment desiredVisibleRow: 100.  self openInstance.  self assert: (presenter verticalAlignment lastVisibleRowIndex between: 100 and: 101)createRingMethodForRemovedSelector: arg1 inClass: arg2  | tmp1 tmp2 |  tmp2 := RGMethodDefinition class: arg2 selector: arg1.  tmp1 := (self selectedChangeSet changeRecorderFor: arg2) methodChanges at: arg1 ifAbsent: [ ^tmp2 ].  tmp2 sourcePointer: tmp1 methodInfoFromRemoval first.  ^tmp2instVarToModelObjectDo: arg1  self instVarToModelObject do: [:arg2 |  arg1 value: arg2 key value: arg2 value ]activatesOnDoubleClick  ^activateOnSingleClick notsetRefreshedToTrue  canBeRefreshed := trueclearSelection  selection := #()selectedProtocol  ^protocolList selection selectedItemwhenBehaviorChangedDo: arg1  self property: #behavior whenChangedDo: arg1selector  ^selectorbadge: arg1  badge := arg1initialize  self class initializeSlots: self.  super initialize.  desiredVisibleRow := 1whenSelectedChanged: arg1  self deprecated: 'Use #whenSelectedChangedDo: instead.' transformWith: '`@receiver whenSelectedChanged: `@statements' -> '`@receiver whenSelectedChangedDo: `@statements'.  self whenSelectedChangedDo: arg1listItems  ^self getList collect: [:arg1 |  arg1 model ]isPresenterSymbol: arg1  self flag: #todo.  ^#(#model #presenter) anySatisfy: [:arg2 |  arg2 = arg1 ]hasWidget: arg1  ^self allMorphs includes: arg1oddRowColor  ^oddRowColor valueopenAt: arg1  self widgetDo: [:arg2 |  arg2 invokeAt: arg1 + (2 @ 7) in: self currentWorld allowKeyboard: true ]initializePresenters  dynamicPresenter := self newNullPresenter.  differentCardsCountSlider := self newSlider.  differentCardsCountSlider     min: 1;     max: 50;     label: '# cards';     whenValueChangedDo: [ self rebuildDynamicPresenter ];     value: 25nameTextInput: arg1  nameTextInput := arg1testInitializeMethodListShouldBeSelectTheFistItem  self assert: biChooseMethod methodList selection selectedIndex equals: 1items  ^self model collectionborderWidth  ^borderWidth ifNil: [ self class defaultBorderWidth ]searchMatching: arg1  searchBlock := arg1.  self enableSearchtabSelected: arg1  self model selectedTab: arg1 modeltestRemovePageAt  | tmp1 |  presenter addPage: self mockPage.  tmp1 := SpNotebookPage title: 'test' provider: [ SpButtonPresenter new ].  presenter addPage: tmp1.  self assert: presenter pages size equals: 2.  presenter removePageAt: 1.  self assertCollection: presenter pages hasSameElements: {tmp1}ghostText: arg1  self deprecated: 'This API is too tight to Morph. Use #placeholder: instead.' transformWith: '`@receiver ghostText: `@statement' -> '`@receiver placeholder: `@statement'.  self placeholder: arg1notEmpty  ^self isEmpty notwrapItem: arg1  ^self model wrapItem: arg1selectItems: arg1  self selectIndexes: (arg1 collect: [:arg2 |  self indexOfItem: arg2 ])cellColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp1 := FTCellMorph new.  tmp2 := SpMorphicTableCellBuilder on: self.  tmp2     cell: tmp1;     rowIndex: arg2;     visit: arg1 model.  ^tmp1topologicSort  ^topologySorticon  ^icontestMaxLengthTruncatesText  presenter maxLength: 10.  presenter text: '1234567890 ---'.  self assert: presenter text equals: '1234567890'addPaneVSplitterBetween: arg1 and: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 |  arg1 ifEmpty: [ ^self ].  tmp1 := arg1 first layoutFrame rightFraction.  tmp2 := arg1 select: [:arg3 |  arg3 layoutFrame leftFraction = arg3 layoutFrame rightFraction ].  tmp6 := ((arg1 reject: [:arg3 |  arg3 layoutFrame leftFraction = arg3 layoutFrame rightFraction ]) asSortedCollection: [:arg4 :arg5 |  arg4 layoutFrame bottomFraction = arg5 layoutFrame bottomFraction ifTrue: [ arg4 layoutFrame topFraction <= arg5 layoutFrame topFraction ] ifFalse: [ arg4 layoutFrame bottomFraction <= arg5 layoutFrame bottomFraction ] ]) readStream.  tmp6 contents ifEmpty: [ ^tmp2 ].  tmp8 := OrderedCollection new.  tmp3 := tmp6 contents first layoutFrame topFraction.  [ tmp6 atEnd or: [ tmp7 := tmp6 next.        tmp7 layoutFrame topFraction ~= tmp3 and: [ tmp7 layoutFrame bottomFraction ~= tmp3 ] ] ] whileFalse: [ tmp8 add: tmp7.        tmp3 := tmp7 layoutFrame bottomFraction ].  tmp4 := tmp8 first layoutFrame.  tmp5 := tmp8 last layoutFrame.  tmp9 := (arg2 reject: [:arg3 |  arg3 layoutFrame leftFraction = arg3 layoutFrame rightFraction ]) select: [:arg3 |  arg3 layoutFrame topFraction between: tmp4 topFraction and: tmp5 bottomFraction ].  tmp11 := (tmp8 collect: [:arg3 |  arg3 layoutFrame rightOffset ]) max.  tmp10 := ProportionalSplitterMorph new.  tmp10 layoutFrame: ((tmp1 @ tmp4 topFraction corner: tmp1 @ tmp5 bottomFraction) asLayoutFrame           leftOffset: tmp11;           topOffset: tmp4 topOffset;           rightOffset: 4 + tmp11;           bottomOffset: tmp5 bottomOffset).  tmp8 := tmp8 , tmp2.  tmp8 do: [:arg3 |  tmp10 addLeftOrTop: arg3 ].  tmp9 do: [:arg3 |  tmp10 addRightOrBottom: arg3 ].  self addMorphBack: tmp10.  ^tmp8checkboxDisabled: arg1  checkboxDisabled := arg1selectionChanged: arg1  | tmp1 |  self presenter selection isMultipleSelection ifTrue: [ self presenter selection selectIndexes: (arg1 newSelectedIndexes reject: [:arg2 |  arg2 = 0 ]) ].  self presenter selection isMultipleSelection ifFalse: [ self presenter selection selectIndex: (arg1 newSelectedIndexes ifNotEmpty: [:arg3 |  arg3 first ] ifEmpty: [ 0 ]) ].  tmp1 := arg1 newSelectedIndexes difference: arg1 oldSelectedIndexes.  (tmp1 notEmpty and: [ self presenter activatesOnSingleClick ]) ifTrue: [ self presenter doActivateAtIndex: tmp1 last ].  arg1 newSelectedIndexes ifNotEmpty: [ ^self ].  self presenter selection unselectAllnewNotebook  ^self instantiate: SpNotebookPresenterincreaseValueOf: arg1  arg1 setText: (self increasedValueFrom: arg1 getText)applyMenuModel: arg1  arg1 menuGroups do: [:arg2 |  arg2 menuItems do: [:arg3 |  arg3 shortcut ifNotNil: [:arg4 |  self bindKeyCombination: arg4 toAction: [ arg3 performMenuActionWith: #() ] ].              arg3 subMenu ifNotNil: [:arg5 |  arg5 applyTo: self ] ] ]initialize  super initialize.  children := [ self container childrenFor: self content ] asValueHolder.  hasChildren := [ self container hasChildrenFor: self content ] asValueHolder.  content := nil asValueHolder.  icon := nil asValueHolder.  container := nil asValueHolder.  matchTokenFilter := [:arg1 |  false ] asValueHolder.  parentNode := nil asValueHolder.  childNodeClass := self class asValueHolder.  selected := false asValueHolder.  lastClicked := false asValueHolder.  mouseDownAction := [:arg2 |   ] asValueHolder.  hasContentToShow := false asValueHolder.  isExpanded := false asValueHolder.  selected whenChangedDo: [:arg3 |  self changed: #selected: with: {arg3} ].  isExpanded whenChangedDo: [:arg3 |  self changed: #isExpanded: with: {arg3} ]testShouldAccept  presenter     beInteger;     minimum: 90;     maximum: 120.  self assert: (adapter shouldAccept: '').  self assert: (adapter shouldAccept: '100').  self deny: (adapter shouldAccept: 'string').  self deny: (adapter shouldAccept: '10string')initialize  super initialize.  titleHolder := self class defaultTitle.  isClosed := true.  isResizeable := true.  centered := false.  askOkToClose := true.  self property: #titleHolder whenChangedDo: [:arg1 |  self changed: #title: with: {arg1} ].  self property: #centered whenChangedDo: [:arg1 |  self changed: #centered with: #() ]action: arg1  actionBlock := arg1hasChildren  ^hasChildren valuehasWindow  ^self root isWindowPresenteracceptOnCR: arg1  ^self input acceptOnCR: arg1constraintsClass  ^SpGridConstraintstoken: arg1  token := arg1newPresenterFor: arg1  ^newPresenterBlock value: arg1prepareForFilteredDataSourceWith: arg1  model := arg1constraintsClass  ^SpBoxConstraintsbottomOffset: arg1  ^0headerFont  ^headerFont valuewhenDisplayBlockChanged: arg1  tree whenDisplayBlockChanged: arg1rowPositions  ^rowPositionsheaderFont  ^self model headerFontselectedClassOrMetaClass  ^self behaviortestUnselectSelectedIndexRemovesSelection  presenter     selectIndex: 1;     unselectIndex: 1.  self assert: presenter selection isEmptyname  ^nameapplyStyle: arg1  sortingBlock: arg1  listModel sortingBlock: arg1selectedItem  selection ifEmpty: [ ^nil ].  ^presenter itemAtPath: selectionusePreviousInspectorType  self inspectorType: self previousInspectorTypeinitialize  model := AbstractTool new.  super initializeinitializeShortcuts  self shortCuts keysAndValuesDo: [:arg1 :arg2 |  self list bindKeyCombination: arg1 toAction: arg2 ]borderWidth: arg1  borderWidth := arg1testOpenWindowWithDifferentApplicationDoesNotAddItToWindowCollection  | tmp1 tmp2 tmp3 |  tmp1 := SpApplication new.  tmp2 := tmp1 newPresenter: SpButtonPresenter.  tmp3 := application windows copy.  self should: [ application open: tmp2 withSpecLayout: SpButtonPresenter defaultSpec ] raise: SpInvalidApplicationError.  self assert: application windows equals: tmp3initializeTestedInstance  presenter drawBlock: [  ].  presenter surfaceExtent: 800 @ 600resizerWidth  ^resizerWidth valuehelpText  ^self widget balloonTextextentOrDefault  ^extent ifNil: [ 0 @ 0 ]icon: arg1  ^self button icon: arg1unselectAll  self selectIndexes: #()childrenItems: arg1  childrenItems := arg1changeSelection: arg1 from: arg2  | tmp1 |  tmp1 := self presenters indexOf: arg2.  columnsWillChangeBlock ifNotNil: [ columnsWillChangeBlock cull: tmp1 ].  self resetTo: tmp1.  self pushModel: arg1disableSearch  searchEnabled := falseactForSpec  self flag: #TODOselectedItems  ^self selectedItem ifNotNil: [:arg1 |  {arg1} ] ifNil: [ #() ]close  backdropMorph ifNotNil: #delete.  backdropMorph := nilproperty: arg1 rawValue: arg2  (self observablePropertyNamed: arg1) rawValue: arg2layout  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := SpBoxLayout newVertical.  tmp3 := SpBoxLayout newHorizontal.  self add: #element11 to: tmp3.  self add: #element12 to: tmp3.  tmp4 := SpBoxLayout newHorizontal.  self add: #element21 to: tmp4.  self add: #element22 to: tmp4.  tmp2 := SpBoxLayout newVertical.  self add: tmp3 properties: 'Row1' to: tmp2.  self add: tmp4 properties: 'Row2' to: tmp2.  tmp1 add: tmp2.  self flag: #todo.  tmp5 := SpBoxLayout newVertical.  #('Row1' 'Row2' 'element11' 'element12' 'element21' 'element22') doWithIndex: [:arg1 :arg2 |  tmp5 add: (SpBoxLayout newVertical                 add: arg1 capitalized;                 add: (SpBoxLayout newHorizontal                       add: (self presenterAt: arg1 , 'Expanded');                       add: (self presenterAt: arg1 , 'Filled');                       yourself);                 add: (SpBoxLayout newHorizontal                       add: 'Padding';                       add: (self presenterAt: arg1 , 'Padding');                       yourself);                 yourself) ].  tmp1 add: tmp5.  ^tmp1testSelectMultiplePathsAddsAllToSelectedItemList  presenter     selectPath: #(1 2);     selectPath: #(2 2).  self assert: (presenter selection includesItem: 3).  self assert: (presenter selection includesItem: 6)configureDropList: arg1 item: arg2  self flag: 'TODO: maybe customize the drop list to have a better look''n feel'sortFunction  ^self model sortFunctioninitialize  super initialize.  instVarCount := 0.  nullPresentersInstVarNames := #()moreOptionsButton  ^moreOptionsButtontestAddNoPresenterToComponentListDoesNotRaiseEvent  | tmp1 |  tmp1 := false.  presenter whenPresentersChangedDo: [ tmp1 := true ].  self deny: tmp1testModelSettingObjectToModel  | tmp1 tmp2 tmp3 |  tmp2 := SpTestingPointModel x: 1 y: 2.  tmp1 := 40 @ 54.  tmp3 := SpTestingPresenterWithModel on: tmp2.  self assert: tmp3 announcingObject isSpAnnouncingObject.  self deny: tmp3 announcingObject isValueHolder.  self deny: tmp1 isSpAnnouncingObject.  self deny: tmp1 isValueHolder.  tmp3 model: tmp1.  self assert: tmp3 announcingObject isSpAnnouncingObject.  self assert: tmp3 announcingObject isValueHolder.  self assert: tmp3 model == tmp1.  self deny: tmp3 announcingObject == tmp2.  self assert: tmp3 announcingObject announcer numberOfSubscriptions > 0testSetSelectItemRaisesSelectionPathChangeEventWithSelectedPath  | tmp1 |  presenter selection whenChangedDo: [:arg1 |  tmp1 := arg1 ].  presenter selectItem: 10.  self assert: tmp1 equals: #(1 3)pendingText  self withAdapterDo: [:arg1 |  arg1 isMorphicAdapter ifTrue: [ ^arg1 pendingText ] ].  ^self getTextchildrenFor: arg1  ^self childrenBlock cull: arg1 cull: selfdisplayForItem: arg1  ^self display cull: arg1 model cull: arg1min  ^self presenter mintestShowingColumnDisplayColumn  self presenter showColumnHeaders.  backendForTest assertHasHeader: self adapterinitialExtent  ^self model initialExtentroots  ^self childrenForObject: self objectminExtent: arg1  minExtent := arg1instVarNamesFrom: arg1  | tmp1 tmp2 |  tmp1 := super instVarNamesFrom: arg1.  tmp2 := tmp1 groupsOf: tmp1 size / self columnsCount atATimeCollect: [:arg2 |  arg2 readStream ].  ^OrderedCollection streamContents: [:arg3 |  [ tmp2 noneSatisfy: #atEnd ] whileTrue: [ tmp2 do: [:arg4 |  arg3 nextPut: arg4 next ] ] ]refreshWidgetSelection  | tmp1 |  tmp1 := self presenter selection selectedIndexes.  tmp1 = self widget selectedIndexes ifTrue: [ ^self ].  tmp1 isEmpty ifTrue: [ self widget basicSelectIndexes: #() ] ifFalse: [ self widget basicSelectIndexes: tmp1 ].  self refreshListtestShowColumnHeadersInPresenterShowsThemInWidget  SystemVersion current major = 7 ifTrue: [ ^self skip ].  self presenter showColumnHeaders.  self assert: self adapter isShowColumnHeaderswhenCanDeselectByClickChanged: arg1  self deprecated: 'Use #whenCanDeselectByClickChangedDo: instead.' transformWith: '`@receiver whenCanDeselectByClickChanged: `@statements' -> '`@receiver whenCanDeselectByClickChangedDo: `@statements'.  self whenCanDeselectByClickChangedDo: arg1leftOffset  ^0visible: arg1  widget: arg1  widget := arg1initializeWidgets  super initializeWidgets.  morphPresenter := self newMorph.  morphPresenter morph: (PanelMorph new           changeProportionalLayout;           vResizing: #spaceFill;           hResizing: #spaceFill;           yourself)windowIcon  ^windowIcontestFromSpecSubMenu  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := PluggableMenuSpec withModel: nil.  tmp3 := tmp1 add: 'parent'.  tmp2 := PluggableMenuSpec withModel: nil.  tmp2 add: 'child'.  tmp3 subMenu: tmp2.  presenter fromSpec: tmp1.  tmp4 := presenter menuGroups first menuItems first subMenu.  self assert: tmp4 menuGroups size equals: 1.  self assert: tmp4 menuGroups first menuItems size equals: 1.  self assert: tmp4 menuGroups first menuItems first name equals: 'child'.  self openInstancetestRemovePageAt  presenter addPage: (SpNotebookPage title: 'Mock3' provider: [ SpLabelPresenter new ]).  self assert: self adapter numberOfTabs equals: 3.  presenter removePageAt: 2.  self assert: self adapter numberOfTabs equals: 2.  self assert: self adapter selectedPageName equals: 'Mock'closeOnBackdropClick: arg1  closeOnBackdropClick := arg1abstractAdapterClass  ^SpAbstractMorphicAdaptercolumns  ^columns valueaccessorCode  self subclassResponsibilityfileOutSelector: arg1 from: arg2  arg2 fileOutMethod: arg1testSelectPathsThenSelectInvalidPathKeepsPaths  | tmp1 |  tmp1 := {#(1 3) .   #(2 2)}.  presenter     selectPaths: tmp1;     selectPaths: {#(50) .         #(60 2)}.  self assert: (presenter selection includesPaths: tmp1)testWhenIconChangedDo  presenter iconName: #glamorousCancel.  presenter whenLabelChangedDo: [:arg1 :arg2 |  self assert: arg1 equals: (self iconNamed: #glamorousCancel) ].  self assert: presenter icon equals: (self iconNamed: #glamorousCancel).  self openInstance.  presenter iconName: #pharo.  self assert: presenter icon equals: (self iconNamed: #pharo)testUnselectPresenterIndexUnselectsIndexInWidget  presenter     selectIndex: 1;     unselectIndex: 1.  self assert: self adapter selectedIndexes isEmptyinitializeWindow: arg1  arg1     title: 'Box layout example';     initialExtent: 600 @ 800showSourceWithConverter: arg1  sourcePresenter := self newCode.  isShowingDiff := false.  self needRebuild: false.  self buildWithSpec.  self textConverter: arg1.  sourcePresenter acceptBlock: [:arg2 :arg3 |  (self accept: arg2 notifying: arg3) notNil ].  sourcePresenter behavior: self selectedMessage methodClass.  messageList selectIndex: messageList selectedIndexopen: arg1 withSpecLayout: arg2 using: arg3  | tmp1 |  self validateApplicationOfPresenter: arg1.  tmp1 := arg3 presenter: arg1.  self windows add: tmp1.  tmp1 openWithSpecLayout: arg2.  ^tmp1bePassword  self bePassword: truetestSelectMultipleItemsAddsAllToSelectedItemList  presenter selectItem: 10.  presenter selectItem: 30.  self assert: (presenter selection includesItem: 10).  self assert: (presenter selection includesItem: 30)externalIndex  ^externalIndexisHomogeneous  ^homogeneousbrowseValueClassHierarchy  ^self valueClass browseHierarchytestClickingRadio3DeselectsRadio1  self openInstance.  self presenter radio3 adapter clicked.  self deny: self presenter radio1 stateinitialize  super initialize.  children := OrderedDictionary newresetAllPageContents  self pages do: #resetContenthasToolbar  ^self toolBar notNil and: [ self toolBar notEmpty ]testSetSelectPathRaisesSelectionItemChangeEventWithSelectedItem  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter selectPath: #(1 3).  self assert: tmp1 equals: 10scrollValue  ^scrollValuelayoutMorph: arg1 staringAt: arg2 withComputation: arg3  | tmp1 tmp2 tmp3 |  tmp1 := arg1 valueOfProperty: #gridConstraints.  tmp2 := arg2 + (arg3 positionAt: tmp1 position).  arg1 vResizing: (self resizingSyle: self isRowHomogeneous).  arg1 hResizing: (self resizingSyle: self isColumnHomogeneous).  (layout rowConstraintsAt: tmp1 position y) ifNotNil: [:arg4 |  arg4 expand ifNotNil: [:arg5 |  arg1 vResizing: (self resizingSyle: arg5) ] ].  (layout columnConstraintsAt: tmp1 position x) ifNotNil: [:arg4 |  arg4 expand ifNotNil: [:arg5 |  arg1 hResizing: (self resizingSyle: arg5) ] ].  tmp3 := (arg1 hResizing = #spaceFill and: [ arg1 vResizing = #spaceFill ]) ifTrue: [ arg3 cellExtentAt: tmp1 position ] ifFalse: [ self calculateExtentFor: arg1 constraint: tmp1 computation: arg3 ].  arg1 bounds: (tmp2 extent: tmp3)buttonDisabled: arg1  buttonDisabled := arg1classToTest  ^SpComponentListPresenterclassToTest  ^SpLabelledSliderInputstepTime  ^20registerToAnnouncements  SystemAnnouncer uniqueInstance weak     when: MethodAdded send: #methodAdded: to: self;     when: MethodModified send: #methodModified: to: self;     when: MethodRecategorized send: #methodRecategorized: to: self;     when: MethodRemoved send: #methodRemoved: to: self;     when: ClassRenamed send: #classRenamed: to: selftreeModel  ^treeModelspan: arg1  span := arg1canDeselectByClick: arg1  self deprecated: 'This option is removed in Spec 2'initialize  isShowingDiff := false.  super initializeinitialize  super initialize.  tabs := OrderedCollection new asValueHolder.  tabSelectedAction := [  ] asValueHolder.  selectedTab := nil asValueHolder.  self myDependents: WeakSet new.  tabs whenChangedDo: [:arg1 |  self widget ifNotNil: [:arg2 |  arg2 tabs: self getTabs value ] ].  selectedTab whenChangedDo: [:arg3 |  tabSelectedAction value cull: arg3 cull: self ]selectedElementDo: arg1  self selectedElement ifNotNil: arg1initializePresenters  button := self newButton.  bottom := self newList.  button     label: 'Change';     action: [ self change ];     state: false.  bottom items: (1 to: 10) asOrderedCollectiontestMaxLengthTruncatesAlreadyTypedText  presenter text: '1234567890 ---'.  presenter maxLength: 10.  self assert: presenter text equals: '1234567890'labelOnRight  ^self widgetDo: [:arg1 |  arg1 listDirection: #rightToLeft ]item  ^self model contentconnectPresenters  messageList     whenSelectionChangedDo: [:arg1 |  [:arg2 |  self selectItem: arg2 ] cull: arg1 selectedItem ];     whenModelChangedDo: [ self updateTitle ].  textModel acceptBlock: [:arg3 :arg4 |  (self accept: arg3 notifying: arg4) notNil ]testColor  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Random new.  tmp2 := tmp1 nextInt: 255.  tmp3 := tmp1 nextInt: 255.  tmp4 := tmp1 nextInt: 255.  presenter redSlider value: tmp2.  presenter greenSlider value: tmp3.  presenter blueSlider value: tmp4.  self assert: presenter color equals: (Color r: tmp2 g: tmp3 b: tmp4 range: 255)hash  ^super hash bitXor: instVarName hashsurnameTextInput  ^surnameTextInputtestRemovePage  | tmp1 |  presenter addPage: self mockPage.  tmp1 := SpNotebookPage title: 'test' provider: [ SpButtonPresenter new ].  presenter addPage: tmp1.  self assert: presenter pages size equals: 2.  presenter removePage: tmp1.  self assert: presenter pages size equals: 1add: arg1 withSpec: arg2  self add: arg1 withSpec: arg2 origin: 0 @ 0 corner: 1 @ 1variants  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  tmp2 := self object class inspectorClass.  tmp1 add: tmp2.  tmp2 = Object inspectorClass ifFalse: [ tmp1 add: EyeBasicInspector ].  tmp1 add: EyeTreeInspector.  tmp1 addAll: self object class additionalInspectorClasses.  ^tmp1newDataSource  ^SpMorphicTableDataSource new     model: self model;     yourselflist2  ^list2doubleClickAtPath: arg1  self selectPath: arg1.  activateOnSingleClick ifTrue: [ ^self ].  self doActivateAtPath: arg1roots  ^self childrenForObject: self objectinitialize  super initialize.  self initializeTSearchable.  self withScrollBars.  activationBlock := [  ].  showColumnHeaders := true.  columns := #().  isResizable := false.  childrenBlock := [:arg1 |  #() ].  roots := #().  self beSingleSelection.  self activateOnDoubleClick.  self registerEventslabel  ^widget contentswhenAcceptBlockChangedDo: arg1  self property: #actionToPerform whenChangedDo: arg1classMenuFrom: arg1 to: arg2  ^arg1 classMenu     addGroup: [:arg3 |  arg3           addItem: [:arg4 |  arg4                 name: 'Copy class to the other change set';                 action: [ self copyClassFrom: arg1 to: arg2 ] ];           addItem: [:arg4 |  arg4                 name: 'Move class to the other change set';                 action: [ self moveClassFrom: arg1 to: arg2 ] ] ];     yourselftext  ^texttestHideColumnHeadersDoesNotShowHeaders  presenter hideColumnHeaders.  self deny: presenter isShowingColumnHeaderscommands  ^commandsselectedMessage  ^nilbrowseSelectedObjectClassHierarchy  self selectedObjectDo: [:arg1 |  arg1 class browseHierarchy ]observablePropertyNamed: arg1  | tmp1 |  tmp1 := self class slotNamed: arg1.  tmp1 isObservableSlot ifFalse: [ SpNonObservableSlotError signal: arg1 ].  ^tmp1 rawRead: selftestActivationWithoutActivationBlockDoesNothing  | tmp1 |  tmp1 := nil.  presenter activateOnSingleClick.  presenter clickAtIndex: 1.  self assert: tmp1 equals: nilmodel  ^modelperformNextSelectorAndIncrementIndex  | tmp1 tmp2 |  tmp2 := arrayToInterpret at: index.  self assert: tmp2 isArray not description: 'Before there was an #ifTrue:ifFalse: on `aSelector isArray` but it seems that the aSelector could never be an Array. If one day we have an array here, please report the problem and link it to https://github.com/pharo-spec/Spec/issues/60'.  tmp2 := tmp2 asSymbol.  tmp1 := (arrayToInterpret copyFrom: index + 1 to: index + tmp2 numArgs) collect: [:arg1 |  self class interpretASpec: arg1 presenter: self presenter ].  index := index + tmp2 numArgs + 1.  ^self actionToPerformWithSelector: tmp2 arguments: tmp1childrenBlock: arg1  childrenBlockHolder value: arg1initialize  wrapHolder := [:arg1 |  arg1 printString ] asValueHolder.  pickedItemsHolder := OrderedCollection new asValueHolder.  associationsWrapperToItem := Dictionary new asValueHolder.  associationsItemToWrapper := Dictionary new asValueHolder.  associationsIndexToWrapper := Dictionary new asValueHolder.  labelClickableHolder := true asValueHolder.  defaultValueHolder := false asValueHolder.  blockToPerformOnWrappers := [:arg2 |   ] asValueHolder.  super initializeheaderLabel  ^self model headerLabelsetIndex: arg1  self dropList setIndex: arg1wantsSteps  ^truewhenColumnsWillChangeDo: arg1  columnsWillChangeBlock := arg1selectedItem: arg1  self deprecated: 'Use #selectItem: instead' transformWith: '`@receiver selectedItem: `@arg' -> '`@receiver selectItem: `@arg'.  self selectItem: arg1initialize  super initialize.  self bePlacedAtStartwidget  ^widgetpendingText: arg1  self withAdapterDo: [:arg2 |  arg2 isMorphicAdapter ifTrue: [ ^arg2 pendingText: arg1 ] ].  self text: arg1selectEntity  ^selectEntitydaysButtons  ^daysButtons, arg1  ^self class new     styles: self styles , arg1 styles;     yourselftestUnselectPresenterItemUnselectsIndexInWidget  presenter     selectItem: 20;     unselectItem: 20.  self assert: self adapter selectedIndexes isEmptyisResizable: arg1  isResizable := arg1setFocus  self focusOrder     add: button1;     add: button2;     add: button3selectAdd  self widgetDo: [:arg1 |  arg1 selectAll ]moreOptionsArea  ^moreOptionsAreabuttonHighlighted: arg1  buttonHighlighted := arg1connectPresenters  minus action: [ | tmp1 |        tmp1 := text label asInteger.        text label: (tmp1 - 1) asString ].  plus action: [ | tmp1 |        tmp1 := text label asInteger.        text label: (tmp1 + 1) asString ]initializeTestedInstance  presenter content: SpTestingPresenterextent  ^self subclassResponsibilitytestInitialStatus  | tmp1 |  tmp1 := SpGridLayout new.  self assert: tmp1 isColumnHomogeneous.  self assert: tmp1 isRowHomogeneous.  self assert: tmp1 columnSpacing equals: 10.  self assert: tmp1 rowSpacing equals: 5.  self assert: tmp1 borderWidth equals: 20title  ^'Dynamic Examples'menuPresenter: arg1  menuPresenter := arg1rootNodes  ^rootNodes ifNil: [ rootNodes := super rootNodes ]addFocusRotationKeyBindings  ^super addFocusRotationKeyBindingscontextMenu: arg1  listModel contextMenu: arg1adapterName  ^#OverlayAdapterregisterEvents  super registerEvents.  self property: #autoDeselect whenChangedDo: [:arg1 |  self changed: #autoDeselect: with: {arg1} ].  self whenDisplayBlockChangedDo: [ self withAdapterDo: #refreshWidgetList ].  self property: #headerTitle whenChangedDo: [ self withAdapterDo: #refreshWidgetHeaderTitle ]beVerticalAlignmentCenter  self vAlign: SpGridAlignment centeradd: arg1  self subclassResponsibilityisRunningInUIProcess  ^UIManager default uiProcess == Processor activeProcesstitle  ^self inspector titlewithoutScrollBars  wrapScrollBars := falsenumber1Input: arg1  number1Input := arg1testClickOnPage  self adapter clickTab: 2.  self assert: self adapter selectedPageName equals: 'Mock2'isDisplayModeBoth  ^self displayMode = SpToolBarDisplayMode modeIconAndLabelplus  ^pluswhenFilteringBlockChanged: arg1  self deprecated: 'Use #whenFilteringBlockChangedDo: instead.' transformWith: '`@receiver whenFilteringBlockChanged: `@statements' -> '`@receiver whenFilteringBlockChangedDo: `@statements'.  self whenFilteringBlockChangedDo: arg1isShowingColumnHeaders  ^showColumnHeadersconstraintsClass  ^self subclassResponsibilitywhenSelectionIndexChanged: arg1  listPresenter whenSelectionIndexChanged: arg1accessorCode  ^'(self array at: ' , self index asString , ')'sortedKeys  ^[ [ self object keys sort ] on: Error do: [ self object keys ] ] on: Error do: [ #() ]testSelectPathsAddsPathsToSelectedPathList  | tmp1 |  tmp1 := {#(1 2) .   #(2 2)}.  presenter selectPaths: tmp1.  self assert: (presenter selection includesPaths: tmp1)items: arg1  ^self dropList items: arg1beNotResizable  self isResizable: falsesetBalloonText: arg1  self widget ifNotNil: [:arg2 |  arg2 setBalloonText: arg1 ]registerForChanges  self property: #method whenChangedDo: [:arg1 |  | tmp1 |        tmp1 := arg1 ifNil: [ false ] ifNotNil: [ true ].        browseModel state: tmp1.        usersModel state: tmp1.        sendersModel state: tmp1.        versionModel state: tmp1.        implementorsModel state: tmp1 ]whenClosedDo: arg1  self property: #isClosed whenChangedDo: [:arg2 |  arg2 ifTrue: [ arg1 value ] ]testDynamicBuild  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := SpTestingPresenter new.  tmp1 openWithSpec close.  tmp2 := tmp1 list adapter.  tmp1 openWithSpec close.  tmp3 := tmp1 list adapter.  self deny: tmp2 identicalTo: tmp3.  tmp1 list needRebuild: false.  tmp1 needRebuild: false.  tmp1 openWithSpec close.  tmp4 := tmp1 list adapter.  self assert: tmp3 identicalTo: tmp4.  self assert: tmp1 needRebuilddisplayMode: arg1  displayMode ifNotNil: [ self removeStyle: displayMode styleName ].  displayMode := arg1.  self addStyle: displayMode styleNamewhenValueChangedDo: arg1  self sliderInput whenValueChangedDo: arg1filterField  ^filterFieldtestUnselectAllRaisesSelectionEventOnce  | tmp1 |  tmp1 := 0.  presenter selectIndex: 1.  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter unselectAll.  self assert: tmp1 equals: 1removeSubWidgets  self widgetDo: [:arg1 |  arg1 removeAllMorphs ]addPage: arg1  arg1 owner: self.  pagesHolder add: arg1setSelectedChangeSet: arg1  ^changesListPresenter setSelectedItem: arg1timeline: arg1  self flag: #comment.  timeline := arg1.  timeline whenTickDo: [:arg2 |  self updateModelToMoment: arg2 ]askBeforeChanging: arg1  askBeforeChanging := arg1toolBar: arg1  arg1 ifNotNil: [ arg1 owner: self ].  ^toolBar := arg1testUpdateModelWithValueHolder  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := 40 @ 54.  tmp2 := NewValueHolder value: tmp1.  self assert: tmp2 value == tmp1.  tmp4 := tmp2 announcer.  self assert: tmp2 announcer subscriptions subscriptions size equals: 0.  tmp3 := SpTestingPresenterWithModel on: tmp2.  self assert: tmp4 == tmp2 announcer.  self assert: tmp3 x text equals: tmp1 x asString.  self assert: tmp3 y text equals: tmp1 y asString.  tmp1 setX: 1 setY: 2.  self assert: tmp2 value == tmp1.  tmp2 valueChanged.  self assert: tmp4 == tmp2 announcer.  self assert: tmp3 x text equals: tmp1 x asString.  self assert: tmp3 y text equals: tmp1 y asStringwhenIsExpandedChangedDo: arg1  isExpanded whenChangedDo: arg1takeKeyboardFocus: arg1  arg1 takeKeyboardFocus.  self waitUntilUIRedrawedtestSelectPathOutsideRangeUnsetsSelectedItem  presenter selectPath: {4}.  self assert: presenter selection selectedItem equals: nilname  ^nameupdateTitle  self changed: #title: with: {self title}downButton  ^downButtontestMethodListContentWhenClassSideIsSelected  biChooseMethod radioButtonClassSide click.  biChooseMethod packageList selectItem: SpMethodChooserMockClass package.  biChooseMethod classList selectItem: SpMethodChooserMockClass.  self denyEmpty: biChooseMethod methodList items.  self assert: biChooseMethod methodList selection selectedIndex equals: 1.  self assertCollection: SpMethodChooserMockClass class methods hasSameElements: biChooseMethod methodList itemsvalue  ^self host at: self indextestModelSettingModelToModel  | tmp1 tmp2 tmp3 |  tmp1 := SpTestingPointModel x: 1 y: 2.  tmp2 := SpTestingPointModel x: 4 y: 5.  tmp3 := SpTestingPresenterWithModel on: tmp1.  self assert: tmp3 announcingObject isSpAnnouncingObject.  self deny: tmp3 announcingObject isValueHolder.  self assert: tmp2 isSpAnnouncingObject.  self deny: tmp2 isValueHolder.  tmp3 model: tmp2.  self assert: tmp3 announcingObject isSpAnnouncingObject.  self deny: tmp3 announcingObject isValueHolder.  self assert: tmp3 announcingObject == tmp2.  self assert: tmp3 announcingObject announcer numberOfSubscriptions > 0testwhenChangedDo  | tmp1 |  tmp1 := 0.  presenter whenChangedDo: [ tmp1 := tmp1 + 1 ].  presenter redSlider value: 66.  presenter greenSlider value: 17.  presenter blueSlider value: 200.  self assert: tmp1 equals: 3onDateChosen: arg1  arg1 calendar delete.  self date: arg1 dateobservablePropertyNamed: arg1  | tmp1 |  tmp1 := self class slotNamed: arg1.  tmp1 isObservableSlot ifFalse: [ SpNonObservableSlotError signal: arg1 ].  ^tmp1 rawRead: selfpageClass  ^SpDemoCheckboxesPresentertestSubscriptionsAreTransfered  self subclassResponsibilityrow: arg1 withConstraints: arg2  | tmp1 |  tmp1 := SpGridAxisConstraints new.  arg2 value: tmp1.  rowConstraints at: arg1 put: tmp1newSlider  ^self instantiate: SpSliderPresenteraddPadding: arg1 toMorph: arg2  arg1 = 0 ifTrue: [ ^arg2 ].  ^layout direction addPadding: arg1 toMorph: arg2 into: selfobservablePropertyNamed: arg1  | tmp1 |  tmp1 := self class slotNamed: arg1.  tmp1 isObservableSlot ifFalse: [ SpNonObservableSlotError signal: arg1 ].  ^tmp1 rawRead: selfaddAllColumns: arg1  arg1 do: [:arg2 |  self addColumn: arg2 ]action  ^actionBlockwhenBackgroundColorBlockChanged: arg1  self deprecated: 'Should not use. This feature is not supported anymore. This feature depends on the theme'privateAsArray  | tmp1 |  tmp1 := OrderedCollection new.  self resetArrayComputation.  self computeNonSplitterWidgetsIn: tmp1.  self computeSplittersIn: tmp1.  ^tmp1 asArraychildrenForObject: arg1  ^(EyeInspector inspector: arg1) elements select: [:arg2 |  arg2 shouldShowInTree ]mockPage  ^SpNotebookPage title: 'Mock' icon: (self iconNamed: #changeUpdate) provider: [ SpButtonPresenter new ]topFraction  ^topFractiondelete  enabled: arg1  enabled := arg1initializePanels  leftPanel := self newPanelMorph.  rightPanel := self newPanelMorph     listDirection: #rightToLeft;     hResizing: #spaceFill.  self     addMorphBack: leftPanel;     addMorphBack: rightPanelfieldEncrypted  ^fieldEncryptedtestAddPage  self assert: self adapter numberOfTabs equals: 2.  presenter addPage: (SpNotebookPage title: 'Mock3' provider: [ SpLabelPresenter new ]).  self assert: self adapter numberOfTabs equals: 3subwidgetArguments  ^self subwidget isArray ifTrue: [ #(presenter) , self subwidget , {#retrieveSpec: .               self specSelector} ] ifFalse: [ {#presenter .         self subwidget .         #retrieveSpec: .         self specSelector} ]includesItems: arg1  ^self selectedItems includesAll: arg1testTransmissionFromPackageToClassList  | tmp1 |  tmp1 := RPackage named: 'TestPackageForSpecTests' asSymbol.  biChooseMethod packageList items: {tmp1}.  biChooseMethod packageList selectItem: tmp1.  self assertEmpty: biChooseMethod classList items.  self assert: biChooseMethod selectedClass isNilupdateTextContents  | tmp1 |  tmp1 := self model setContentsOfChangeSet: self selectedChangeSet forClass: self selectedClass andSelector: self selectedSelector.  (tmp1 asString lines anySatisfy: [:arg1 |  self model classDescriptionsMap values , {'Method was added, but cannot be found!' .               'Added then removed (see versions)' .               'Method has been removed (see versions)' .               'Class organization was changed.'} includes: arg1 ]) ifTrue: [ textPresenter withoutSyntaxHighlight ] ifFalse: [ textPresenter withSyntaxHighlight ].  textPresenter text: tmp1initializePresenters  table1 := self newTable.  label := self newLabel.  self resetLabel.  table1     addColumn: ((SpCheckBoxTableColumn title: ' ' evaluated: [:arg1 |  selectedClasses includes: arg1 ])           onActivation: [:arg1 |  selectedClasses add: arg1.              self resetLabel ];           onDesactivation: [:arg1 |  selectedClasses remove: arg1.              self resetLabel ];           width: 20;           yourself);     addColumn: ((SpImageTableColumn title: 'Icon' evaluated: #systemIcon)           width: 50;           yourself);     addColumn: (SpStringTableColumn title: 'Name' evaluated: #name);     addColumn: (SpStringTableColumn title: 'Number of subclasses' evaluated: [:arg1 |  arg1 subclasses size asString ]);     items: self class environment allClasses;     beResizablesetFocus  self focusOrder     add: uniformDropList;     add: heterogeneousDropList;     add: disabledDropListtestSelectWidgetIndexRaisesSelectionIndexChangeEventOnce  | tmp1 |  tmp1 := 0.  presenter selection whenChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  self adapter selectPath: #(1).  self assert: tmp1 equals: 1testSelectItemOutsideRangeHasNoSelectedIndexes  presenter selectItem: 400.  self assert: presenter selection selectedIndexes isEmptywrapHolder  ^wrapHolderpageClass  ^SpDemoActionBarPresenterrefreshDescription  self refreshDescription: self selectedElementbasicPresenters  ^presenters ifNil: [ presenters := OrderedDictionary new ]list  ^list ifNil: [ list := self newList           activateOnDoubleClick;           whenSelectionChangedDo: [:arg1 |  [:arg2 |  self refreshDescription: arg2 ] cull: arg1 selectedItem ];           whenActivatedDo: [ self diveIntoSelectedObject ];           yourself ]itemFilterBlock  self deprecated: 'Use #itemFilter instead' transformWith: '`@receiver itemFilterBlock' -> '`@receiver itemFilter'.  ^self itemFiltercanBeRefreshed  ^canBeRefreshedtext  ^self input textvRigid  self widgetDo: [:arg1 |  arg1 vResizing: #rigid ]badgeSelector: arg1  badgeSelector := arg1property: arg1 whenChangedDo: arg2  (self observablePropertyNamed: arg1) whenChangedDo: arg2newPhone  ^newPhonecolor  ^sliders colorinspectInNewWindow: arg1  arg1 inspecttoolbar  ^toolbarlist  ^self subwidgettestUnselectAllUnselectsall  presenter     selectIndex: 1;     unselectAll.  self assert: presenter selection isEmptydefaultButtonId  ^defaultButtonIdtestUnselectAll  presenter beMultipleSelection.  presenter selectAll.  self assert: presenter selection selectedItems asArray equals: #(10 20 30).  presenter unselectAll.  self assertEmpty: presenter selection selectedItemsencrypted: arg1  self widgetDo: [:arg2 |  arg2 encrypted: arg1.        arg2 changed ]input  ^self subwidgetwithProgressionBlock: arg1  withProgressionBlock := arg1value  ^self host array at: self indexbuildWidget  self model model whenChangedDo: [ self changed: #getList.        self changed: #getIndex ].  self model selection whenChangedDo: [ self changed: #getIndex ].  ^SpDropListMorph new     wrapSelector: #wrap:withIndex:;     on: self list: #getList selected: #getIndex changeSelected: #setIndex:;     hResizing: #spaceFill;     vResizing: #spaceFill;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     enabled: self enabled;     setBalloonText: self help;     yourselfclassToTest  ^SpMillerColumnPresenterdateLabel  ^dateLabeltestSelectPresenterItemSetsSelectedIndexInWidget  presenter selectItem: (presenter items at: 2).  self assert: (self adapter selectedIndexes includes: 2)setLayoutSizing  self subclassResponsibilityautoDeselection  ^autoDeselection valueinitializeTestedInstance  label: arg1  displayBlock := [ arg1 ]selectedIndexes  ^widget selectedIndexeslistApplications  | tmp1 |  tmp1 := Smalltalk platform lineEnding.  self stdout << 'List of applications: ' << tmp1 << '---- ' << tmp1.  SpApplication findAll do: [:arg1 |  self stdout << arg1 applicationName << tmp1 ].  self exitSuccessinitialize  super initialize.  self     name: 'Change phone';     description: 'Change the phone number of the contact.'focusedPresenter  ^mock allPresentersInFocusOrder detect: [:arg1 |  arg1 adapter widget hasKeyboardFocus ] ifNone: [ nil ]initializeTestedInstance  presenter     addColumn: (SpStringTableColumn title: 'Value' evaluated: #printString);     addColumn: (SpImageTableColumn title: 'Icon' evaluated: [:arg1 |  self iconNamed: #add ]);     hideColumnHeaders;     roots: #(1 2 3);     children: [:arg2 |  {(arg2 * 2) .         (arg2 * 3) .         (arg2 * 10)} ]entityText: arg1  entityText := arg1newDataSource  ^SpMorphicTreeTableDataSource new     model: self model;     rootItem: (self rootForItems: self model roots);     childrenBlock: [:arg1 :arg2 |  self model childrenFor: arg1 ];     yourselfborderColor  ^borderColortestSelectPresenterIndexSetsSelectedIndexInWidget  presenter selectIndex: 1.  self assert: (self adapter selectedIndexes includes: 1)initialize  super initialize.  self flag: #REVIEW.  scrollValue := 0 @ 0.  self withScrollBarsbuildStatusBar  ^SpStatusBarPresenter newlabel  ^'self'pressedFillStyle  ^self theme splitterPressedFillStyleFor: selfisFloat  ^self numberType = FloattestResetingSelectionResetsSelection  self presenter selectItem: 10.  self presenter resetSelection.  self assert: self presenter selectedItem equals: nil.  self assert: self adapter selectedIndexes isEmptytestSelectItemsOutsideRangeIsEmpty  presenter selectItems: {4000 .         5000}.  self assert: presenter selection isEmptynewCloseButtonFor: arg1  ^SpButtonPresenter new     icon: self theme windowCloseForm;     action: [ self removePage: arg1 ];     buildWithSpecisInput  ^true= arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^self label = arg1 label and: [ action = arg1 action ]number2  ^number2add: arg1 withSpec: arg2 bottom: arg3  self add: arg1 withSpec: arg2 top: nil bottom: arg3 left: nil right: niluseBasicInspector  self inspectorType: EyeBasicInspectormodelObjects: arg1  instVarToModelObject := arg1 collect: [:arg2 |  self generateUniqueInstanceVariableName -> arg2 ]buildWidget  ^SpStubTickingWindowView newname: arg1  name := arg1withErrorsDo: arg1  self errorPropertySelectors do: [:arg2 |  self errorWhileAccessing: arg2 do: arg1 ]defineOutputPorts  ^{SpSelectionPort new .   SpActivationPort new}canTakeKeyboardFocus  ^falseinitialize  super initialize.  self type: SpNotificationType inforegisterEvents  self whenTextChangedDo: [ self changed: #getText ].  self whenReadSelectionIsChangedDo: [ self changed: #readSelection ].  self property: #hasUnacceptedEdits whenChangedDo: [:arg1 |  self changed: #setHasUnacceptedEdits: with: {arg1} ].  self property: #selection whenChangedDo: [:arg2 |  self changed: #setSelectionFromModel: with: {arg2 value} ].  self whenAutoAcceptChangedDo: [:arg1 |  self changed: #autoAccept: with: {arg1} ].  self property: #wantsVisualFeedback whenChangedDo: [:arg1 |  self changed: #changed with: #() ].  self property: #askBeforeDiscardingEdits whenChangedDo: [:arg1 |  self changed: #askBeforeDiscardingEdits: with: {arg1} ]autoMultiSelection  ^self model autoMultiSelectionselectedClass  ^classesListPresenter selection selectedItemtitle  ^titlewhenCanDeselectByClickChangedDo: arg1  self deprecated: 'This option is removed in Spec 2'protocolNameForItem: arg1  ^arg1 category ifNil: [ '' ]initializeTestedInstance  presenter     addPage: (SpNotebookPage title: 'Mock' icon: (self iconNamed: #changeUpdate) provider: [ SpButtonPresenter new ]);     addPage: (SpNotebookPage title: 'Mock2' icon: (self iconNamed: #changeUpdate) provider: [ SpLabelPresenter new ])testSelectAllDoesNotSelect  presenter selectAll.  self assert: presenter selection isEmptyspacing: arg1  spacing := arg1isExpand  ^expand ifNil: [ self class defaultExpand ]addContent: arg1 toWindow: arg2  removePage: arg1  pagesHolder remove: arg1whenValueChangedDo: arg1  whenEntryCompletionChangedDo: arg1  self property: #entryCompletion whenChangedDo: arg1defaultColor  ^self theme backgroundColorconnectPresenters  self registerChangeActions.  self registerClassActions.  self registerSelectorActions.  changesListPresenter items ifNotEmpty: [ changesListPresenter selectIndex: 1 ]surfaceExtent  ^surfaceExtentwhenSelectionChanged: arg1  self dropList whenSelectionChanged: arg1iconFor: arg1  ^nilinitialize  selectedClasses := OrderedCollection with: ASTCache with: ASTEvaluationTest with: Abort.  super initializeobservablePropertyNamed: arg1  | tmp1 |  tmp1 := self class slotNamed: arg1.  tmp1 isObservableSlot ifFalse: [ SpNonObservableSlotError signal: arg1 ].  ^tmp1 rawRead: selfpushMessage: arg1  self message: arg1.  self changed: #pushMessageclassToTest  ^SpTextFieldExampleaddVariableFields: arg1  self variableFieldsToShow do: [:arg2 |  arg1 add: (BasicIndexedEyeElement host: self object index: arg2) ]asMorphicLayout  ^LayoutFrame identity     topFraction: self topFraction;     topOffset: self topOffset;     bottomFraction: self bottomFraction;     bottomOffset: self bottomOffset;     rightFraction: self rightFraction;     rightOffset: self rightOffset;     leftFraction: self leftFraction;     leftOffset: self leftOffset;     yourselfname: arg1  name := arg1displayBlock: arg1  wrapHolder value: arg1newWidgetOn: arg1  ^arg1 newHorizontalnewTree  self deprecated: 'Use #newTreeTable instead'.  ^self instantiate: SpTreePresenteraskBeforeDiscardingEdits: arg1  askBeforeDiscardingEdits := arg1testRowSpacing  | tmp1 |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1.  self place: label2 at: 1 @ 2.  self place: morph2 at: 2 @ 2.  (tmp1 := self newLayout) layout rowSpacing: 5.  tmp1 layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 50 @ 20).  self assert: morph1 bounds equals: (50 @ 0 corner: 100 @ 20).  self assert: label2 bounds equals: (0 @ 25 corner: 50 @ 45).  self assert: morph2 bounds equals: (50 @ 25 corner: 100 @ 45)testEmptyMillerListHasNoWidgets  self assert: self adapter childrenWidgets isEmptyextent  ^30 @ 30showOnlySource: arg1  showOnlySource := arg1testSetSelectItemOutsideRangeRaisesSelectionChangeEventWithUnsetItem  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter selectItem: 40.  self assert: tmp1 equals: nilmodel  self deprecated: 'User should not use model directly.'.  ^messageList modeladdDependent: arg1  self myDependents add: arg1urlColor  ^self color ifNil: [ self theme urlColor ]newDataSourceMatching: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := self elements select: [:arg2 |  tmp2 := self model displayValueOf: arg2.        table columns anySatisfy: [:arg3 |  tmp3 := arg3 transform: tmp2.              arg1 matches: tmp3 ] ].  tmp4 := self copy.  tmp5 := self model copy.  tmp5 prepareForFilteredDataSourceWith: tmp1.  tmp4 model: tmp5.  ^tmp4label  ^self instVarNamecalculateNotHomogeneousColumnWidths  | tmp1 tmp2 |  tmp1 := Array new: numColumns withAll: 0.  morphs do: [:arg1 |  | tmp3 |        tmp3 := (arg1 valueOfProperty: #gridConstraints) column.        (self isColumnExpandable: tmp3) ifFalse: [ tmp1 at: tmp3 put: ((tmp1 at: tmp3) max: (self styleOf: arg1) width) ] ].  tmp2 := tmp1 count: [:arg1 |  arg1 isZero ].  tmp2 > 0 ifTrue: [ | tmp4 tmp5 |        tmp5 := (tmp1 reject: [:arg1 |  arg1 isZero ]) ifNotEmpty: [:arg2 |  arg2 sum ] ifEmpty: [ 0 ].        tmp4 := ((bounds width - tmp5) / tmp2) asInteger.        tmp1 := tmp1 collect: [:arg1 |  arg1 = 0 ifTrue: [ tmp4 ] ifFalse: [ arg1 ] ] ].  ^tmp1whenSelectedItemChangedDo: arg1  self deprecated: 'Use #whenSelectionChangedDo: instead' transformWith: '`@receiver whenSelectedItemChangedDo: `@argument' -> '`@receiver whenSelectionChangedDo: [ :selection | `@argument cull: selection selectedItem ]'.  self selection whenChangedDo: [:arg2 |  arg1 cull: arg2 selectedItem ]selectIndex: arg1  (arg1 = 0 and: [ widget selectedIndexes isEmpty ]) ifTrue: [ ^self ].  (widget selectedIndexes includes: arg1) ifTrue: [ ^self ].  widget selectIndex: arg1textStyler  ^textStylertestDefaultPlaceholderIsEmpty  self assert: presenter placeholder isEmptyborderWidth  ^borderWidthbrowseClassRefs  self currentMethod ifNotNil: [:arg1 |  model browseClassRefsOf: arg1 methodClass ]subscribeToAnnouncements: arg1  arg1 announcer     when: SpWindowWillClose send: #announce: to: self presenter announcer;     when: WindowResizing send: #announce: to: self presenter announcerwhenBorderWidthChangedDo: arg1  self property: #borderWidth whenChangedDo: arg1testSelectAllRaisesSelectionEventOnce  | tmp1 |  tmp1 := 0.  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter selectAll.  self assert: tmp1 equals: 1testSelectItemsAddsItemsToSelectedItemList  presenter selectItems: {10 .         20}.  self assert: (presenter selection includesItems: {10 .               20})contextClass  ^self model contextClassprogress: arg1 every: arg2  self state: (SpProgressBarProgressing progression: arg1 every: arg2)message  ^messagerightPanel  ^rightPanelclassToTest  ^SpMockDynamicPresentersetSendersModel  sendersModel     state: false;     label: 'Senders';     action: [ self sendersMethod ]state: arg1  ^self presenter state: arg1allGridConstraints  ^morphs collect: [:arg1 |  arg1 valueOfProperty: #gridConstraints ifAbsent: [ self error: 'Constraints not defined for ' , arg1 asString ] ]exampleTab  ^SpNotebookPage title: 'Example' icon: (self iconNamed: #smallPaint) provider: [ self instantiate: self pageClass ]ensureExtentFor: arg1  self extent ifNotNil: [:arg2 |  DisplayScreen hostWindowSize: arg2 ].  self initialExtent ifNotNil: [:arg2 |  DisplayScreen hostWindowSize: arg2 ]x: arg1  x := arg1newRow: arg1 top: arg2  self newRow: arg1 top: arg2 bottom: nilisBold  ^bold == truedefaultWindowModelClass  self deprecated: 'Use #defaultWindowPresenterClass instead' transformWith: '`@receiver defaultWindowModelClass' -> '`@receiver defaultWindowPresenterClass'.  ^self defaultWindowPresenterClassprogressBarMorph  ^ProgressBarMorphmaximize  self widgetDo: [:arg1 |  arg1 maximize ]initialize  super initialize.  self     removeMorph: self contentMorph;     removeMorph: self tabSelectorMorph;     headerMorph: self newHeaderMorph;     addMorph: self headerMorph;     addMorph: self contentMorphselection  | tmp1 |  self flag: 'I wonder about the naming of the classes: should actions based on selection not be available also on text presenters?'.  tmp1 := context selection.  tmp1 ifEmpty: [ ^'' ].  self flag: 'The following code has been commented: it seems wrong and provokes the current context to be restarted in the debugger'.  ^context text copyFrom: tmp1 first to: tmp1 lastisMatch: arg1 pattern: arg2  | tmp1 |  tmp1 := (self toString: arg1) trimBoth asLowercase.  ^tmp1 beginsWith: arg2checkboxInput: arg1  checkboxInput := arg1isExpanded: arg1  whenAbsoluteValueChangedDo: arg1  self property: #absoluteValue whenChangedDo: arg1state: arg1  ^self presenter state: arg1execute  self context inspectbuildWidget  ^SpStubTransferView newmodelClass  ^SpTreePresentersaveElement: arg1  | tmp1 |  tmp1 := description doItReceiver class compiler     source: arg1;     context: self doItContext;     receiver: description doItReceiver;     failBlock: [ ^self ];     evaluate.  self selectedElement save: tmp1.  self objectChangedadapterBindingsClass  self subclassResponsibilityadd: arg1  self add: arg1 withConstraints: [:arg2 |   ]widget  ^widgetwhenTextChangedDo: arg1  self property: #text whenChangedDo: arg1newListMorph  ^(self listMorphClass on: self list: #list selected: #listSelectionIndex changeSelected: #listSelectionIndex: menu: nil keystroke: nil)     getIconSelector: #getIconFor:;     autoDeselect: false;     wrapSelector: #wrapItem:index:;     roundedCorners: #(2 3);     setProperty: #morphicLayerNumber toValue: 5;     borderStyle: (self theme dropListNormalListBorderStyleFor: self);     on: #mouseDown send: #listMouseDown: to: self;     yourselfprintOn: arg1  arg1     print: self label;     << '->';     << (self value printStringLimitedTo: 50)hasScrollBars  ^wrapScrollBarsasSpecCommand  ^super asSpecCommand     iconName: #removeIcon;     shortcutKey: $x meta;     yourselfinitializePresenters  link1 := self newLink.  link2 := self newLink.  link3 := self newLink.  link4 := self newLink.  link1 url: 'https://pharo.org'.  link2     url: 'https://pharo.org';     label: 'Pharo website'.  link3     url: 'https://pharo.org';     label: 'Pharo website';     color: Color purple.  link4     action: [ Object browse ];     label: 'Browse Object'connectPresenters  list1 whenSelectionChangedDo: [:arg1 |  [:arg2 |  label label: (arg2 ifNil: [ 'Deselection from list 1' ] ifNotNil: [ 'Selection from list 1: ' , arg2 asString ]) ] cull: arg1 selectedItem ].  list2 whenSelectionChangedDo: [:arg1 |  [:arg3 |  multiLabel label: (arg3 ifEmpty: [ 'Not multi selection (from list 2 only)' ] ifNotEmpty: [ 'Multi-selection from list 2: ' , arg3 asString ]) ] cull: arg1 selectedItems ].  list3 whenSelectionChangedDo: [:arg1 |  [:arg2 |  label label: (arg2 ifNil: [ 'Deselection from list 3' ] ifNotNil: [ 'Selection from list 3: ' , arg2 asString ]) ] cull: arg1 selectedItem ]number1  ^number1displayBlock  self deprecated: 'Please use #display instead' transformWith: '`@receiver displayBlock' -> '`@receiver display'.  ^displayBlockeventKeyStrokesForNextFocus  ^{Character arrowRight asKeyCombination .   Character tab asKeyCombination}multiSelection  ^multiSelection valuetestSelectIndexThenSelectOutsideRangeKeepsSingleSelectedItem  presenter selectIndex: 1.  presenter selectIndex: 50.  self assert: presenter selection selectedItems size equals: 1widgets  self deprecated: 'Use #basicPresenters instead' transformWith: '`@receiver widgets' -> '`@receiver basicPresenters'.  ^self basicPresentersaddSettingsTo: arg1  self widget ifNotNil: [ self applyVisibility ]includesItem: arg1  self subclassResponsibilitydefineInputPorts  ^{SpListItemsPort new}notifyPropertyChanged: arg1  self flag: #todo.  (self observablePropertyNamed: arg1) valueChangedaddAllInstVars: arg1  arg1 add: (AllInstVarsEyeElement host: self object)classToTest  ^SpLabelPresentercreateVersionForBlessing: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := self configurationClass methods select: [:arg2 |  arg2 selector beginsWith: 'version' ].  tmp1 := (tmp1 collect: [:arg3 |  arg3 pragmas first argumentAt: 1 ]) asSortedCollection.  tmp2 := ''.  tmp1 size > 4 ifTrue: [ tmp2 := 'Last 4 versions: ' , (tmp1 copyFrom: tmp1 size - 4 to: tmp1 size) asArray printString , String cr ].  tmp3 := tmp1 size > 0 ifTrue: [ tmp1 last , '.1' ] ifFalse: [ '1.0' ].  tmp4 := UIManager default request: tmp2 initialAnswer: tmp3.  tmp4 ifNil: [ ^self ].  tmp5 := tmp4 copyWithoutAll: '.-'.  tmp6 := WriteStream on: String new.  tmp6 nextPutAll: 'version'.  tmp6 nextPutAll: tmp5.  tmp6 nextPutAll: ': spec         <version: '''.  tmp6 nextPutAll: tmp4.  tmp6     nextPutAll: ''' imports: #(''';     nextPutAll: self lastBaseLine;     nextPutAll: ''')>        spec for: #common do: [                spec blessing: ';     nextPutAll: arg1 printString;     nextPutAll: '.'.  self dependentPackages do: [:arg4 |  tmp6           nextPutAll: '			spec package: ''';           nextPutAll: arg4;           nextPutAll: ''' with: '''.        tmp7 := (MCPackage named: arg4) workingCopy.        tmp7 needsSaving ifTrue: [ self inform: 'The configuration you want to save depends on the package ' , arg4 , '. You first need to save this package in order to create the version'.              ^self ].        tmp6 nextPutAll: tmp7 ancestry ancestors first name.        tmp6           nextPutAll: '''.';           nextPutAll: String cr ].  tmp6 nextPutAll: '                ].'.  self configurationClass compile: tmp6 contents classified: 'versions'needRebuild: arg1  needRebuild := arg1isHorizontal  ^self direction = SpLayoutDirection horizontalspacing  ^spacingbuildUpdateTitle  self updateTitle.  textModel text: textModel texticon  ^self model iconopenModal: arg1  ^self openModal: arg1 withSpecLayout: arg1 defaultSpecactionToPerformWithSelector: arg1 arguments: arg2  ^[ spec perform: arg1 withArguments: arg2 ] on: MessageNotUnderstood do: [:arg3 |  (arg1 last ~= $: and: [ arg2 isEmpty ]) ifTrue: [ self subpresenterNamed: arg1 ] ifFalse: [ arg3 pass ] ]root  ^self owner ifNotNil: [:arg1 |  arg1 root ] ifNil: [ self ]setBalloonText: arg1  cellColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp2 := self elementAt: arg2.  tmp1 := FTCellMorph new     cellInset: 5;     yourself.  tmp1 addMorphBack: (self widgetFor: tmp2).  ^tmp1update  self preventUpdatesDuring: [ self updateInspectorChoice.        self updateInspectorType.        previousButton enabled: self history hasPrevious.        nextButton enabled: self history hasNext ]testHideColumnHeadersRaisesOneEventOnly  | tmp1 |  tmp1 := 0.  presenter whenShowColumnHeadersChangedDo: [ tmp1 := tmp1 + 1 ].  presenter hideColumnHeaders.  self assert: tmp1 equals: 1input  ^inputselectorOf: arg1  ^arg1 selectorselectionChanged: arg1  self suspendSelectionEventsDuring: [ self basicSelectionChanged: arg1 ]execute  self editor cutselectIndex: arg1  listModel selectIndex: arg1setTargetLayoutSizing  self subclassResponsibilityadapt: arg1  super adapt: arg1.  self addSettingsTo: self widget.  self addKeyBindingsTo: self widget.  self flag: #TODOinitialize  super initialize.  okAction := [ true ]iconMorph  ^ImageMorph new form: (self iconNamed: #calendarIcon)doesNotUnderstand: arg1  (self treeModel respondsTo: arg1 selector) ifFalse: [ ^super doesNotUnderstand: arg1 ].  ^self treeModel perform: arg1 selector withArguments: arg1 argumentsisRunningInUIProcess  ^UIManager default uiProcess == Processor activeProcessdragEnabled: arg1  self widget ifNotNil: [:arg2 |  arg2 dragEnabled: arg1 ]add: arg1  collection := collection copyWith: arg1.  self refreshList.  self announcer announce: (ValueChanged newValue: self)newHorizontal  ^self newPanel     listDirection: #leftToRight;     yourselfbutton  ^buttonbeforeTest: arg1  testWhenSyntaxHighlightChangedDo  | tmp1 tmp2 |  tmp1 := 0.  tmp2 := true.  presenter whenSyntaxHighlightChangedDo: [:arg1 |  tmp1 := tmp1 + 1.        tmp2 := arg1 ].  presenter withoutSyntaxHighlight.  self assert: tmp1 equals: 1.  self deny: tmp2testNonOpenPresenterDoesNotRaiseDisplayedEvent  | tmp1 |  tmp1 := false.  presenter whenDisplayDo: [ tmp1 := true ].  self deny: tmp1addItem: arg1  self addItem: arg1 position: SpToolBarItemPosition leftreadObject: arg1  ^self model readObject: arg1action  ^textModel acceptBlockmainIcon: arg1  mainIcon := arg1classToTest  ^SpRGBWidgettestKeyBindings  | tmp1 |  tmp1 := false.  presenter bindKeyCombination: $t meta toAction: [ tmp1 := true ].  self adapter keyPressed: $t asciiValue shift: false meta: true control: false option: false.  self assert: tmp1buildWidget  ^SpStubListView newopenInstance  window ifNil: [ window := presenter openWithSpec ].  self currentWorld doOneCyclehasBadge  ^self badge notNillayoutFrame: arg1  layoutFrame := arg1 asSpLayoutFrameincomingTransmission: arg1 from: arg2  self destinationPresenter text: arg1privateAsArray  self resetArrayComputation.  self countNumberOfProportionals.  autoFractionComputation ifTrue: [ self autoFractionComputation ] ifFalse: [ self manualFractionComputation ].  self shiftLastWidgets.  ^super privateAsArrayremove: arg1  | tmp1 |  tmp1 := arg1 adapter widget.  widget submorphs first removeMorph: tmp1.  widget submorphs second removeMorph: tmp1testContextMenu  | tmp1 tmp2 |  self assert: presenter contextMenu isNil.  tmp1 := SpMenuPresenter new.  tmp2 := false.  presenter whenMenuChangedDo: [ tmp2 := true ].  presenter contextMenu: tmp1.  self assert: presenter contextMenu equals: tmp1.  self assert: tmp2buttonWithShortcut: arg1  buttonWithShortcut := arg1testClickingRadio3SelectsIt  self openInstance.  self presenter radio3 adapter clicked.  self assert: self presenter radio3 statehSpaceFill  self widgetDo: [:arg1 |  arg1 hResizing: #spaceFill ]selectItem: arg1  self basicSelectIndex: (self indexOfItem: arg1)highlightedItem: arg1  highlightedItem value: arg1listModel  ^model modelpreviousMonthButton  ^previousMonthButtonclassToTest  ^SpTestPresenterWithThreeRadioButtonsleftFraction: arg1  layoutFrame leftFraction: arg1testDeactivatePresenterIsNotActive  presenter state: false.  self deny: presenter stateclassToTest  ^SpWindowPresenterdefineOutputPorts  ^{SpSelectionPort new .   SpActivationPort new}rootNodeHolder  ^rootNodeHolder valuewhenItemFilterBlockChangedDo: arg1  self property: #itemFilter whenChangedDo: arg1nameLabel  ^nameLabelupdate  self needRebuild: false.  self buildWithSpecdeselectAll  self changed: #deselectAll with: #()= arg1  ^self foreground = arg1 foregrounddefaultValue: arg1  defaultValueHolder value: arg1testCanCancelAddNewItem  presenter     items: #(1 2 3) asOrderedCollection;     addItemBlock: [ nil ].  presenter addButton click.  self assertCollection: presenter items hasSameElements: #(1 2 3)selectFirstElement  list selectIndex: 1rowMorphFor: arg1  | tmp1 tmp2 |  tmp1 := arg1 nodeModel.  tmp2 := self rowMorphGetSelector ifNil: [ tmp1 rowMorphForColumn: self ] ifNotNil: [ self rowMorphGetterBlock value: tmp1 value: self container ].  tmp2 := tmp2 asMorph.  tmp2 ifNotNil: [ tmp2 borderWidth: 0 ] ifNil: [ tmp2 := self defaultRowMorph ].  ^tmp2 rowMorphForNode: tmp1 inColumn: selftabs: arg1  tabs value: arg1oddRowColor: arg1  oddRowColor value: arg1whenChangedDo: arg1  redSlider whenValueChangedDo: arg1.  greenSlider whenValueChangedDo: arg1.  blueSlider whenValueChangedDo: arg1changeSets  ^self changesListPresenter listItemsarguments  ^{(self commands identityIndexOf: self)}testSelectInvalidPathsHasNoSelectedItems  presenter selectPaths: {#(10 20) .         #(20 20)}.  self assert: presenter selection selectedItems isEmptyinitialize  super initialize.  count := 0isRowHomogeneous  ^self layout isRowHomogeneousclickFirstRowAndColumn: arg1  self waitUntilUIRedrawed.  arg1 widget mouseDown: (MouseEvent new           setHand: HandMorph new;           setPosition: arg1 widget submorphs first submorphs first bounds center;           yourself)okButton  ^okButtoninitializeShortcuts  self bindKeyCombination: $[ meta toAction: [ self inspectPrevious ].  self bindKeyCombination: $] meta toAction: [ self inspectNext ].  self bindKeyCombination: $[ meta shift toAction: [ self usePreviousInspectorType ].  self bindKeyCombination: $] meta shift toAction: [ self useNextInspectorType ].  self bindKeyCombination: $0 meta toAction: [ self useBasicInspector ].  self bindKeyCombination: $0 meta shift toAction: [ self useDefaultInspector ].  self bindKeyCombination: $1 meta toAction: [ self useInspectorAt: 1 ].  self bindKeyCombination: $2 meta toAction: [ self useInspectorAt: 2 ].  self bindKeyCombination: $3 meta toAction: [ self useInspectorAt: 3 ].  self bindKeyCombination: $4 meta toAction: [ self useInspectorAt: 4 ].  self bindKeyCombination: $5 meta toAction: [ self useInspectorAt: 5 ].  self bindKeyCombination: $6 meta toAction: [ self useInspectorAt: 6 ].  self bindKeyCombination: $7 meta toAction: [ self useInspectorAt: 7 ].  self bindKeyCombination: $8 meta toAction: [ self useInspectorAt: 8 ].  self bindKeyCombination: $9 meta toAction: [ self useInspectorAt: 9 ]defaultValue  ^defaultValueHolder valuecloseableHolder  ^closeableHolderborderColor: arg1  property: arg1 whenChangedDo: arg2  (self observablePropertyNamed: arg1) whenChangedDo: arg2numberOfItems  ^self widget leftPanel submorphs size + self widget rightPanel submorphs sizeisMorphicAdapter  ^falseitemSubstringFilter  self deprecated: 'Use #enableItemSubstringFilter instead' transformWith: '`@receiver itemSubstringFilter' -> '`@receiver enableItemSubstringFilter'.  self enableItemSubstringFilterdefineInputPorts  ^#()selectEntity: arg1  selectEntity := arg1presenters  ^self itemsicons: arg1  icon := arg1testSelectItemThenSelectOutsideRangeKeepsFirstElement  presenter selectItem: 10.  presenter selectItem: 5000.  self assert: (presenter selection includesItem: 10)forceChangesListRefresh  | tmp1 |  tmp1 := self selectedChangeSet.  changesListPresenter items: self model allChanges.  changesListPresenter setSelectedItem: tmp1highlightedItem: arg1  tree highlightedItem: arg1buildWidget  | tmp1 |  self flag: #pharo7.  tmp1 := ((self class environment at: #SpRubTextFieldMorph ifAbsent: [ RubTextFieldMorph ]) on: self)     getTextSelector: #getText;     setTextSelector: #accept:notifying:;     getSelectionSelector: #readSelection;     menuProvider: self selector: #codePaneMenu:shifted:;     setSelectionSelector: #setSelection:;     entryCompletion: self entryCompletion;     ghostText: self placeholder;     encrypted: self encrypted;     enabled: self enabled;     askBeforeDiscardingEdits: self askBeforeDiscardingEdits;     autoAccept: self autoAccept;     vResizing: #spaceFill;     hResizing: #spaceFill;     setBalloonText: self help;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     maxLength: self presenter maxLength;     yourself.  self presenter whenTextChangedDo: [:arg1 |  tmp1 setText: arg1 ].  self presenter whenPlaceholderChangedDo: [:arg1 |  tmp1 ghostText: arg1 ].  self presenter whenPasswordChangedDo: [:arg2 |  tmp1 encrypted: arg2 ].  self presenter whenMaxLengthChangedDo: [:arg3 |  tmp1 maxLength: arg3 ].  ^tmp1listModel  ^listModelshowSubMenu: arg1  arg1 menuGroups ifNil: [ ^self ].  subMenuWidget ifNotNil: [ subMenuWidget delete.        subMenuWidget := nil ].  subMenuWidget := (SpMorphicMenuAdapter adaptAsPopup: arg1) widget.  subMenuWidget popUpAdjacentTo: {self widget bounds bottomLeft .         self widget bounds bottomRight} forHand: ActiveHand from: self widget.  subMenuWidget popUpOwner: selfisShowColumnHeaders  ^widget isShowColumnHeaderstestSelectItemRaiseEvent  | tmp1 |  self presenter whenSelectionChangedDo: [ tmp1 := true ].  self presenter selection selectPath: #(2 3).  self assert: tmp1 equals: truepreferedPaneColor: arg1  preferedPaneColor value: arg1topOffset  ^0buildWidget  | tmp1 |  tmp1 := PluggableToggleButtonMorph on: self getState: #state action: #toggleAction: label: #label menu: nil.  tmp1     icon: self icon;     label: self label;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     setBalloonText: self help;     getEnabledSelector: #enabled;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled.  self presenter whenLabelChangedDo: [:arg1 |  tmp1 label: arg1 ].  self presenter whenIconChangedDo: [ tmp1 icon: self icon ].  self presenter whenChangedDo: [ tmp1 pressed: self model state ].  ^tmp1kmTable  ^kmTableselectedIndexes  ^widget selectedIndexesdrawOn: arg1  super drawOn: arg1.  self hasBadge ifTrue: [ self drawBadgeOn: arg1 ]initializePresenters  listModel := self newList.  textModel1 := self newText.  textModel2 := self newCode.  listModel beMultipleSelection.  listModel items: self class environment allClasseswhenActivatedDo: arg1  testSetHeaderTitleSetsTitle  presenter headerTitle: 'title'.  self assert: presenter headerTitle equals: 'title'description: arg1  description := arg1exploreSubMenu: arg1  arg1 addGroup: [:arg2 |  arg2 addItem: [:arg3 |  arg3                 name: 'Explore Pointers';                 action: [ self explorePointers ] ] ]object  ^objectobservablePropertyNamed: arg1  | tmp1 |  tmp1 := self class slotNamed: arg1.  tmp1 isObservableSlot ifFalse: [ SpNonObservableSlotError signal: arg1 ].  ^tmp1 rawRead: selfnameTextInput  ^nameTextInputaboutText  ^aboutText ifNil: [ aboutText := 'The about text for this window has not been set.' ]filterWith: arg1  self selection: nil.  self updateTree.  self expandAll.  self changed: #filterWith: with: {arg1}.  self expandAlllayoutBuilder: arg1  layoutBuilder := arg1objectChanged  self subclassResponsibilityheaderMorph: arg1  headerMorph := arg1.  headerMorph clipSubmorphs: truetestChangeActivatedAfterOpenCheckboxDectivatesIt  presenter state: false.  self openInstance.  presenter state: true.  self assert: presenter staterewind  ticks := lowestValueselected  ^self model selectedbottomOffset  ^0testRadio1StartsDeselected  self deny: self presenter radio1 statedescription  ^descriptionvisitCheckboxColumn: arg1  | tmp1 |  tmp1 := SpCheckBoxPresenter new     state: (arg1 readObject: self item);     yourself.  arg1 onActivation ifNotNil: [:arg2 |  tmp1 whenActivatedDo: [ arg2 cull: self item ] ].  arg1 onDesactivation ifNotNil: [:arg2 |  tmp1 whenDeactivatedDo: [ arg2 cull: self item ] ].  self addCellMorph: tmp1 buildWithSpec column: arg1height: arg1  self extent: self extentOrDefault x @ arg1pickedItems  ^pickedItemsHolder valueon: arg1 send: arg2 to: arg3  self announcer when: arg1 send: arg2 to: arg3numberOfTabs  ^self widget tabSelectorMorph tabs sizeaddPadding: arg1 toMorph: arg2 into: arg3  ^arg3 addHorizontalPadding: arg1 toMorph: arg2testSelectInvalidPathHasNoSelectedItems  presenter selectPath: #(4).  self assert: presenter selection selectedItems isEmptytestUnselectSelectedPathRemovesItFromSelectionList  presenter     selectPath: #(1 2);     unselectPath: #(1 2).  self assert: presenter selection isEmptycustomMenuActions: arg1  customMenuActions := arg1testSmokeOpenPresenterWithItems  window := presenter     items: #(1 2 3);     openWithSpecvalue  ^valueisOutput  ^truenewWrapMorph  ^Morph new     layoutPolicy: ProportionalLayout new;     color: Color transparent;     borderColor: Color transparent yourselfbrowseInstVarDefs  ^self systemNavigation browseInstVarDefs: self hostClassiconBlock: arg1  tree iconBlock: arg1text  ^self input textuseDefaultInspector  self inspectorType: self object class inspectorClassaddVSplitter  self commands add: (SpSplitterVertical commands: self commands)minHeight: arg1  self widgetDo: [:arg2 |  arg2 minHeight: arg1 ]cellColumn: arg1 row: arg2  | tmp1 tmp2 tmp3 |  tmp3 := self elementAt: arg2.  tmp1 := FTIndentedCellMorph new.  tmp1 indentBy: (self cellIndentFor: tmp3).  (self isFirstColumn: arg1) ifTrue: [ tmp1 addMorphBack: (self buttonFor: tmp3) ].  tmp2 := SpMorphicTreeTableCellBuilder on: self.  tmp2     cell: tmp1;     item: tmp3 data;     visit: arg1 model.  ^tmp1buttons  ^buttonstestSettingAnImageSetsTheImageAndThrowsEvent  | tmp1 |  self presenter whenImageChangeDo: [ tmp1 := true ].  self presenter image: self imageForm.  backendForTest assertImage: self adapter image equals: self imageForm.  self assert: tmp1entity: arg1  entity := arg1.  arg1 ifNotNil: [ self entityText text: (arg1 perform: self displaySymbol) ] ifNil: [ self entityText text: '' ]borderColor  ^borderColorwhenLabelClickableChangedDo: arg1  self property: #labelClickable whenChangedDo: arg1autoSelect: arg1  textModel readSelectionBlock: [:arg2 |  self selectedMessage ifNotNil: [:arg3 |  (self isMethodDefinition: arg3) ifFalse: [ self intervalOf: arg1 inCommentText: arg2 ] ifTrue: [ self intervalOf: arg1 inCode: arg2 of: arg3 ] ] ]testSetSelectPathRaisesSelectionChangeEventWithSelectedItem  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter selectPath: #(1 3).  self assert: tmp1 equals: 10setUp  super setUp.  themeDecorator := SpUIThemeDecorator exampleDecoratorToMakePluggableButtonRedmanualFractionComputation  self commands doWithIndex: [:arg1 :arg2 |  arg1 layoutFrame hasNoOffsets ifTrue: [ | tmp1 |              tmp1 := arg1 layoutFrame bottomFraction - arg1 layoutFrame topFraction.              self setWidgetLayoutWithNoOffset: arg1 at: arg2 delta: tmp1 ] ifFalse: [ self setWidgetLayoutWithOffset: arg1 at: arg2 ] ]readObject: arg1  ^self transform: (table displayBlock value: arg1)testSelectItemOutsideRangeHasNoSelectedItems  presenter selectItem: 400.  self assert: presenter selection selectedItems isEmptyinitialize  cancelled := false.  cancelAction := [ true ].  super initializetable  ^tableselection: arg1  self changed: #selection: with: {arg1}backgroundColor  ^backgroundColorfillTag: arg1 withAttribute: arg2  arg2 class = TextColor ifTrue: [ arg1 foreground: arg2 color ].  self flag: #TODOtext  self input textscaleLabel: arg1  scaleLabel := arg1outputPorts  ^self defineOutputPorts collect: [:arg1 |  arg1 presenter: self ]testExample  self flag: #todo.  (self classToTest respondsTo: #example) ifFalse: [ self skip ].  [ window := self classToTest example ] on: Error do: [:arg1 |  self fail: 'Broken class example: ' , self classToTest asString , '' , arg1 signalerContext shortStack ]wrappedPresenter  ^wrappedPresenterisInteger  ^self numberType = IntegerinitializePresenters  messageList := self instantiate: MessageList.  toolbarPresenter := self instantiate: SpMethodToolbar.  messageList     topologicSort: false;     sortingBlock: [:arg1 :arg2 |  (arg1 annotationNamed: #versionIndex ifAbsent: [ 0 ]) < (arg2 annotationNamed: #versionIndex ifAbsent: [ 0 ]) ];     contextMenu: self messageListMenu.  toolbarPresenter     addItemLabeled: 'Side By Side' do: [ self showDiffMorphWithConverter: (DiffMorphChangeRecordConverter methodReference: self textConverter method referencesList: self changeList) ];     addItemLabeled: 'Source' do: [ self showSourceWithConverter: (SourceMethodConverter method: self textConverter method) ];     addItemLabeled: 'Diff' do: [ self showSourceWithConverter: (DiffChangeRecordConverter methodReference: self textConverter method referencesList: self changeList) ].  toolbarPresenter versionModel     label: 'Revert';     action: [ self revert: self selectedMessage ]borderWidth: arg1  borderWidth := arg1property: arg1 rawValue: arg2  (self observablePropertyNamed: arg1) rawValue: arg2testActivationOnSingleClickShouldActivateOnClick  | tmp1 |  tmp1 := nil.  presenter     activateOnSingleClick;     whenActivatedDo: [:arg1 |  tmp1 := arg1 selectedItem ].  presenter clickAtIndex: 1.  self assert: tmp1 label equals: '10'applyTo: arg1  (arg1 respondsTo: #font:) ifFalse: [ ^self ].  arg1 font: self definedFontbeSelected  self setSelection: truetestVisibilityWithBlock  presenter visibleIf: [ true ].  self assert: self adapter isVisibleroots  ^tree rootsowner: arg1  owner := arg1number1Input  ^number1InputclassToTest  ^SpRadioButtonExampleselectLine  self widgetDo: [:arg1 |  arg1 textArea editor selectLine ]tick  self ticks: ticks + stepByevenRowColor: arg1  tree evenRowColor: arg1add: arg1 at: arg2 span: arg3  ^self add: arg1 withConstraints: [:arg4 |  arg4           position: arg2;           span: arg3 ]selected: arg1  arg1 ifTrue: [ self select ] ifFalse: [ self deselect ]associatedRadioButtons  ^associatedRadioButtonstestAddTabOpened  self openInstance.  self assertCollection: presenter tabs hasSameElements: #().  presenter addTab: redTab.  self assertCollection: presenter tabs hasSameElements: {redTab}beHorizontalAlignmentEnd  self hAlign: SpGridAlignment endselectedIndex  ^selectedIndextextModel2  ^textModel2value: arg1  ^self presenter value: arg1default: arg1  arg1 privateSetState: true.  arg1 takeKeyboardFocus.  arg1 whenBuiltDo: [ arg1 privateSetState: true.        self currentActivated: arg1 ]add: arg1 right: arg2  self add: arg1 top: nil bottom: nil left: nil right: arg2oddRowColor  ^self model oddRowColorpreferedPaneColor: arg1  tree preferedPaneColor: arg1changeSorterRight  ^changeSorterRightwhenIsResizableChangedDo: arg1  self property: #isResizable whenChangedDo: arg1allPresenters  | tmp1 |  tmp1 := OrderedCollection new.  self traversePresentersDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1setFilter: arg1  arg1 ifEmpty: [ self collectAllShortcuts ] ifNotEmpty: [:arg2 |  self kmTable items: (self shortcuts select: [:arg3 |  {arg3 realValue shortcut asString .                     arg3 shortcutName .                     arg3 categoryName} anySatisfy: [:arg4 |  arg4 includesSubstring: arg2 caseSensitive: false ] ]) ]whenMaxChangedDo: arg1  self property: #max whenChangedDo: arg1initializePresenters  | tmp1 tmp2 |  indeterminated := self newProgressBar.  fixed := self newProgressBar.  withProgressionBlock := self newProgressBar.  withText := self newProgressBar.  label := self newLabel.  indeterminated indeterminate.  fixed fixedPercentage: 30.  tmp1 := 0.  withProgressionBlock progress: [ tmp1 := tmp1 + 0.01 ] every: 0.5 second.  tmp2 := 0.  withText progress: [ tmp2 := tmp2 + 0.01 ] every: 0.1 second.  label label: 'This is a progress bar'initializeWidgets  text := self newCoderunApplication  | tmp1 |  tmp1 := SpApplication findNamed: self applicationName ifNone: [ ^self exitFailure: ('Application {1} not found.' format: {self applicationName}) ].  [ tmp1 new     prepareAsStandaloneApplication;     run ] forknewSplitter  ^self subclassResponsibilitytakeKeyboardFocus  self widget tabSelectorMorph takeKeyboardFocusinitialize  super initialize.  self     hResizing: #spaceFill;     vResizing: #spaceFill;     setLayoutSizing;     extent: self defaultWidth @ self defaultHeightinitializePresenters  messageList := self instantiate: MessageList.  toolbarPresenter := self instantiate: SpMethodToolbarmorph  ^presenter adapter widgetbadge  badgeSelector ifNil: [ ^nil ].  ^self model perform: badgeSelectorheaderLabelChanged  self widgetDo: [:arg1 |  arg1 header label: self headerLabel.        arg1 container resizerChanged ]displayIn: arg1 do: arg2  self displayStrategy display: self in: arg1 do: arg2browseSendersOfMessage  self currentMethod ifNotNil: [:arg1 |  model browseSendersOfMessagesFrom: arg1 selector ]printObject: arg1  | tmp1 |  tmp1 := [ arg1 printString ] on: Error do: [ '<error in printString: try ''Inspect it'' to debug>' ].  self afterSelectionInsertAndSelect: (self toPrintableString: tmp1)title  ^titlepage: arg1  page := arg1execute  self browserClientProvider browseAllSendersOf: self selectorinitialExtent  ^600 @ 300testSpanColumn  | tmp1 |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1.  self place: label2 at: 3 @ 1.  self place: morph2 at: 2 @ 2 span: 2 @ 1.  tmp1 := self newLayout.  tmp1 layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 50 @ 20).  self assert: morph1 bounds equals: (50 @ 0 corner: 100 @ 20).  self assert: label2 bounds equals: (100 @ 0 corner: 150 @ 20).  self assert: morph2 bounds equals: (50 @ 20 corner: 150 @ 40)newList  ^self instantiate: SpListPresenterbuildWidget  ^StringMorph new     contents: self label;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     vResizing: #shrinkWrap;     hResizing: #spaceFill;     setBalloonText: self help;     color: self urlColor;     on: #mouseEnter send: #mouseEnter:from: to: self;     on: #mouseLeave send: #mouseLeave:from: to: self;     on: #mouseDown send: #mouseDown:from: to: self;     on: #mouseUp send: #mouseUp:from: to: self;     yourselfinitializePresenters  dateModel := self newTextInput.  chooseDateButton := self newButton.  chooseDateButton     icon: self iconMorph;     action: [ self chooseDate ];     extent: self iconMorph extentnewButton  ^PluggableButtonMorph on: self getState: nil action: #action label: #label icon: #icon menu: niltestSelectItemSelectsTheGivenElementAndExpandsTheBranches  self presenter selection selectPath: #(2 3).  self assert: self adapter selectedItem equals: 20whenIsExpandedChanged: arg1  self deprecated: 'Use #whenIsExpandedChangedDo: instead.' transformWith: '`@receiver whenIsExpandedChanged: `@statements' -> '`@receiver whenIsExpandedChangedDo: `@statements'.  self whenIsExpandedChangedDo: arg1basicBuildAdapterWithSpecLayout: arg1  self announcer announce: (SpWidgetWillBeBuilt model: self).  self adapter: (arg1 asSpLayout buildAdapterFor: self bindings: SpBindings value).  self announcer announce: (SpWidgetBuilt model: self widget: adapter widget).  ^adaptercurrentlyActivated: arg1  currentlyActivated := arg1whenValueChangedDo: arg1  self state whenValueChangedDo: arg1execute  self evaluateSelectionAndDo: [:arg1 |  self printObject: arg1 ]buildWidget  ^SpSpinnerMorph newminWidth  ^self lookupProperty: SpStyleGeometry valueOf: #minWidthtestSelectWidgetIndexRaisesSelectionIndexChangeEventOnce  | tmp1 |  tmp1 := 0.  presenter selection whenChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  self adapter selectIndex: 1.  self assert: tmp1 equals: 1rootNodeHolder  ^tree rootNodeHoldertestWhenClimbRateChangedDo  | tmp1 tmp2 |  tmp1 := 0.  presenter whenClimbRateChangedDo: [:arg1 |  tmp1 := tmp1 + 1.        tmp2 := arg1 ].  presenter climbRate: 1.  self assert: tmp1 equals: 1.  self assert: tmp2 equals: 1action: arg1  ^self button action: arg1linkSplittersToSplitters  self splitters do: [:arg1 |  arg1 splitsTopAndBottom ifTrue: [ self splitters do: [:arg2 |  arg2 splitsTopAndBottom ~= arg1 splitsTopAndBottom ifTrue: [ arg2 layoutFrame bottomFraction = arg1 layoutFrame topFraction ifTrue: [ arg1 addLeftOrTop: arg2 ].                          arg2 layoutFrame topFraction = arg1 layoutFrame bottomFraction ifTrue: [ arg1 addRightOrBottom: arg2 ] ] ] ] ifFalse: [ self splitters do: [:arg2 |  arg2 splitsTopAndBottom ~= arg1 splitsTopAndBottom ifTrue: [ arg2 layoutFrame rightFraction = arg1 layoutFrame leftFraction ifTrue: [ arg1 addLeftOrTop: arg2 ].                          arg2 layoutFrame leftFraction = arg1 layoutFrame rightFraction ifTrue: [ arg1 addRightOrBottom: arg2 ] ] ] ].        arg1 comeToFront ]action: arg1  action := arg1fromSpec: arg1  self addItem: [:arg2 |  arg2 fromSpec: arg1 ]initialize  super initialize.  selectedIndex := 0registerEvents  displayBlock whenChangedDo: [ self changed: #displayBlockChanged ].  resizable whenChangedDo: [ self changed: #resizableChanged ].  headerLabel whenChangedDo: [ self changed: #headerLabelChanged ].  headerFont whenChangedDo: [ self changed: #headerFontChanged ].  headerIcon whenChangedDo: [ self changed: #headerIconChanged ]okButton  ^windowPresenter addButton: 'Ok' do: [:arg1 |  arg1 triggerOkAction.        arg1 close ]add: arg1 withSpec: arg2 origin: arg3 corner: arg4 offsetOrigin: arg5 offsetCorner: arg6  commands add: (SpLayoutAddWithSpec subwidget: arg1 spec: arg2 layoutFrame: ((arg3 corner: arg4) asSpLayoutFrame                 topLeftOffset: arg5;                 bottomRightOffset: arg6))testStringColumnsShouldBeNonEditable  self assert: (self adapter isNonEditableRow: 4 column: 1)textPresenter  ^textPresenterupdateItemFilterBlockWith: arg1  ^arg1 ifNotNil: [ widget           enableFilter: (SpFTSpecFilter block: arg1);           explicitFunction ] ifNil: [ self updateSearch ]defineOutputPorts  ^{SpSelectionPort new .   SpActivationPort new}buildButtonFor: arg1  ^self theme newButtonIn: widget for: arg1 getState: nil action: #performMenuActionWith: arguments: {widget} getEnabled: #isEnabled label: (IconicListItem text: arg1 name icon: arg1 icon) help: arg1 descriptiongtInspectorSubPresentersIn: arg1  < gtInspectorPresentationOrder: 20>  arg1 tree     title: 'Sub presenters';     rootsExpanded;     display: [:arg2 |  {arg2} ];     children: [:arg2 |  arg2 presenters ];     when: [:arg2 |  arg2 presenters isNotEmpty ]copyAllChangesFrom: arg1 to: arg2  arg2 assimilateAllChangesFoundIn: arg1initialize  super initialize.  self     name: 'Print';     description: 'Print the contact book in Transcript.'enabled: arg1  self widget ifNotNil: [:arg2 |  arg2 enabled: arg1 ]basicAdd: arg1 constraints: arg2 to: arg3  | tmp1 |  tmp1 := self buildMorph: arg1 constraints: arg2.  arg2 isPlacedAtStart ifTrue: [ arg3 submorphs first addMorphBack: tmp1 ] ifFalse: [ arg3 submorphs second addMorphBack: tmp1 ].  arg3 height: (arg3 height max: tmp1 height).  arg3 width: (arg3 width max: tmp1 width).  ^tmp1label  ^labelname: arg1  name := arg1leftOffset: arg1  ^layoutFrame leftOffset: arg1testAutoscale  self presenter image: self imageForm.  self presenter autoScale: false.  self deny: self adapter hasImageAutoscaled.  self presenter autoScale: true.  self assert: self adapter hasImageAutoscaledrightOffset  ^layoutFrame rightOffsetlist  ^listhasAnyBaseline  ^self baseLines notEmptyinitializeWindow: arg1  arg1 initialExtent: (900 min: self currentWorld extent x) @ (550 min: self currentWorld extent y)from: arg1 port: arg2  self fromPort: (arg1 outputPortNamed: arg2)minWidth: arg1  self minExtent: arg1 @ self minExtentOrDefault ymultiSelection: arg1  tree multiSelection: arg1buttonWithIconOnly  ^buttonWithIconOnlyhasToolBar  self deprecated: 'Use #hasToolbar instead. cf https://www.dictionary.com/browse/toolbar' transformWith: '`@receiver hasToolBar' -> '`@receiver hasToolbar'.  ^self hasToolbarbuildWidget  ^DiffMorph new     on: self;     from: self leftText to: self rightText contextClass: self contextClass;     hResizing: #spaceFill;     vResizing: #spaceFill;     setBalloonText: self help;     showOptions: self showOptions;     leftLabel: self leftLabel rightLabel: self rightLabel;     showOnlyDestination: self showOnlyDestination;     yourselfmethods: arg1  self listModel items: arg1removeOnlyLastSelected: arg1  removeOnlyLastSelected value: arg1basicAdd: arg1 constraints: arg2 to: arg3  | tmp1 |  tmp1 := self buildMorph: arg1 constraints: arg2.  tmp1     hResizing: #spaceFill;     vResizing: #spaceFill.  arg3 scrollTarget: tmp1.  ^tmp1initializePresenters  firstButton := self instantiate: SpButtonPresenter.  secondButton := self instantiate: SpButtonPresenter.  self initializeButtons.  self focusOrder     add: firstButton;     add: secondButtonselectedChangeSetIndex  ^changesListPresenter selectedIndexbasicLayout: arg1 in: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := arg1 submorphs.  tmp3 := arg2 insetBy: self padding.  tmp1 := (SpMorphicGridLayoutComputation layout: self) computeMorphs: tmp2 bounds: tmp3.  tmp4 := tmp3 origin.  tmp2 do: [:arg3 |  self layoutMorph: arg3 staringAt: tmp4 withComputation: tmp1 ]step  self model steptestNullPresentersInstVarNamesAndPresenterNamesArray  builder     modelObjects: {1 .         2 .         3};     presenter: SpCheckBoxPresenter configuredAs: [:arg1 :arg2 |   ];     buildDynamicPresenter;     createNullPresenters: 3.  self assertCollection: builder nullPresentersInstVarNamesAndPresenterNamesArray equals: #(var4 #SpNullPresenter var5 #SpNullPresenter var6 #SpNullPresenter)giveFocusToPreviousFrom: arg1  ^self model giveFocusToPreviousFrom: arg1isHorizontal  ^falseshowOptions: arg1  showOptions := arg1testPasswordIsSetInWidget  presenter bePassword.  self assert: self adapter isPasswordinspectObject: arg1  arg1 inspectdisplayValueOf: arg1  ^self display value: arg1beVertical  isHorizontal := falseblock  ^blockbeForCode  self deprecated: 'The forCode functionality has moved to TextCodePresenter, please use it instead TextPresenter.' on: '2019-04-05' in: #Pharo8selectedIndex  ^listModel selection selectedIndexsetRigidityOfNonExpandedMorph: arg1  arg1     hResizing: #spaceFill;     vResizing: #rigidadapter  backendForTest openInstanceOf: self.  ^presenter adapterdeleteIfPopUp: arg1  beNotExpandable  expandable := falseexpand: arg1  expand := arg1property: arg1 returnsValueOf: arg2  themeOverrideDict at: arg1 put: arg2priorVersionOfAMethod: arg1  | tmp1 tmp2 |  tmp2 := referencesList sorted: [:arg2 :arg3 |  arg2 timeStamp > arg3 timeStamp ].  tmp1 := tmp2 indexOf: arg1.  ^tmp2 at: tmp1 + 1 ifAbsent: [ arg1 ]whenAutoScaleChangeDo: arg1  self property: #autoScale whenChangedDo: arg1centered  centered := truenodeModel  ^nodeModelselectPage: arg1  arg1 = self selectedPage ifTrue: [ ^self ].  selectedPage := arg1testSmokeCreates  self presentercompareTo: arg1 withLabel: arg2  | tmp1 tmp2 |  tmp1 := Array with: arg1 with: self selectedMessage.  tmp2 := (DiffMorphChangeRecordConverter methodReference: arg1 referencesList: tmp1) getText.  SpDiffPresenter new     title: ('Comparison from {1} to {2}' format: {tmp1 second stamp .               arg2});     leftText: tmp2 first;     rightText: tmp2 second;     openWithSpecinsert: arg1 at: arg2  | tmp1 |  tmp1 := self getText.  tmp1 := (tmp1 copyFrom: 1 to: arg2) , arg1 , (tmp1 copyFrom: arg2 + 1 to: tmp1 size).  self model text: tmp1whenSelectionIndexChanged: arg1  self dropList whenSelectionIndexChanged: arg1isSearchEnabled  ^searchEnabledinitializePresenters  tree := self newTree.  inputField := self newTextInput.  button := self newButton.  tree rootNodeHolder: [:arg1 |  (tree defaultNodeFor: arg1)           matchTokenFilterBlock: [:arg2 |  arg2 token ifEmpty: [ true ] ifNotEmpty: [ arg1 asString asLowercase includesSubstring: arg2 token asLowercase ] ];           yourself ].  button     label: '';     icon: (self iconNamed: #smallFindIcon);     state: false;     action: [ inputField accept ].  inputField     placeholder: 'Search';     entryCompletion: nil;     acceptOnCR: true.  self focusOrder     add: tree;     add: inputFieldtestSearchWithFunction  self presenter searchMatching: [:arg1 :arg2 |  (arg1 - 1) asString beginsWith: arg2 ].  self selectIndex: 1.  self adapter typeForSearch: '2'.  self deny: self selectedIndex equals: 2.  self adapter typeForSearch: '2'.  self assert: self selectedIndex equals: 3presenters  ^layout presentersmoveElementAt: arg1 to: arg2  | tmp1 |  (arg2 between: 1 and: self items size) ifFalse: [ ^self ].  tmp1 := list itemAt: arg1.  self items     remove: tmp1;     add: tmp1 beforeIndex: arg2.  self refresh.  self list selectIndex: arg2isMenuPresenter  ^truecheckSplitters  self widgetDo: [:arg1 |  arg1 checkSplitters ]labelHolder  self deprecated: 'Nobody should access directly to internals of Spec. Now this variable is not a value holder anymore.'layout  ^layoutincomingTransmission: arg1 from: arg2  self destinationPresenter setModel: arg1createReleaseVersion  self hasAnyBaseline ifFalse: [ UIManager default inform: 'Please, define a baseline first'.        ^self ].  ^self createVersionForBlessing: #releaseadd: arg1 withSpec: arg2 top: arg3 bottom: arg4 left: arg5 right: arg6  | tmp1 |  tmp1 := self computeLayoutFromTop: arg3 bottom: arg4 left: arg5 right: arg6.  self add: arg1 withSpec: arg2 origin: tmp1 first corner: tmp1 second offsetOrigin: tmp1 third offsetCorner: tmp1 fourthautoRefreshOnExpand  ^autoRefreshOnExpand valueselectedObject  ^self selectedElement valueunselectIndex: arg1  self selection unselectIndex: arg1classToTest  ^SpDropListExamplevisitCommand: arg1  arg1 displayIn: stack top do: [:arg2 |  self fillItem: arg2 with: arg1 ]doItContext  ^self model doItContextbeError  self type: SpNotificationType errorinitialExtent  | tmp1 tmp2 |  tmp1 := StandardFonts defaultFont widthOfString: 'M'.  tmp2 := self class inputTextHeight.  ^90 @ 24 * (tmp1 @ tmp2)newRow: arg1 top: arg2 bottom: arg3  | tmp1 |  tmp1 := self computeLayoutFromTop: arg2 bottom: arg3 left: nil right: nil.  self newRow: arg1 origin: tmp1 first corner: tmp1 second offsetOrigin: tmp1 third offsetCorner: tmp1 fourthlessOptionsText: arg1  lessOptionsText := arg1defineInputPorts  ^{SpModelPort new}initialExtent: arg1  initialExtent := arg1testSubscribeBlockWithoutParametersIsCalled  | tmp1 |  tmp1 := false.  point property: #x whenChangedDo: [ tmp1 := true ].  point x: 17.  self assert: tmp1selector  ^nilwhenMinChangedDo: arg1  self property: #min whenChangedDo: arg1editor  self flag: 'This is wrong! How can we edit text/code from text/code presenters?'.  self flag: 'Class name is wrong: it also applies to text and not only to code!'.  ^context adapter widget textArea editorlessOptionsText  ^lessOptionsTexttitle  ^'Text editor'shortcutGroup  ^shortcutGroupmenuItems  ^self model menuItemsbuildWidget  ^TabManagerMorph new     model: self model;     setTabs: self getTabs;     when: #tabSelected send: #tabSelected: to: self;     vResizing: #spaceFill;     hResizing: #spaceFill;     yourselfpadding  ^paddingprintDescription: arg1  self refreshDescription: arg1connectPresenters  filterField whenTextChangedDo: [:arg1 |  clearFilterButton enabled: arg1 isNotEmpty.        self setFilter: arg1 ].  clearFilterButton action: [ filterField text: '' ]buttonWithHelp  ^buttonWithHelpconfigure: arg1  OSPlatform current configureApplication: arg1 configuration: selfincreasedValueFrom: arg1  | tmp1 |  tmp1 := arg1 ifEmpty: [ 0 ] ifNotEmpty: [:arg2 |  arg2 asNumber + self model climbRate ].  tmp1 := self inBounds: tmp1.  ^self model isInteger ifTrue: [ tmp1 rounded asString ] ifFalse: [ tmp1 printShowingDecimalPlaces: self model digits ]marks  ^marksobjectChanged  self text doItReceiver: self object.  self text ifNotNil: [:arg1 |  arg1 behavior: self object class ].  self tree roots: self rootsisPlaceAtEnd  ^self isPlaceAtStart nottestPushModelUsesPresenterBlock  | tmp1 |  self presenter presenterBlock: [:arg1 |  tmp1 := SpNullMillerPresenter on: (SpLabelPresenter new label: arg1 asString) ].  self presenter pushModel: 1.  self assert: self presenter presenters first equals: tmp1isSpLayout  ^truetoolbar  [ self deprecated: 'The way dialogs uses toolbars changed in Pharo 8 and this way is deprecated. 		Before the dialog bar had one or two buttons: Ok and Cancel, but they where not configurable. Now the user can add itself multiple buttons and configure their action more easily.		So here is how the new way works:		If you do not override the method #initializeDialogWindow: in your dialog, two default buttons will be added: "Ok" and "Cancel". You can then configure their actions with the #okAction: and #cancelAction: selectors.		If you do not want those default buttons you can override #initializeDialogWindow: and use this new API:		aWindow 		addButton: ''Debug''		do: [ :presenter | self accept. presenter close ];		addButton: ''Ignore'' 		do: [ :presenter | presenter close ]. 	' ].  ^SpDeprecatedSpecToolbarHelper for: selfinput: arg1  input := arg1.  self focusOrder add: inputtoolBar  ^toolBartestScrollUpToNegativeIndexScrollsTopToFirstIndex  self flag: #pharo7.  SystemVersion current major < 8 ifTrue: [ self skip ].  presenter items: (1 to: 500).  presenter verticalAlignment desiredVisibleRow: 100.  self openInstance.  presenter verticalAlignment desiredVisibleRow: -1.  self assert: presenter verticalAlignment firstVisibleRowIndex equals: 1testClickRaisesChangedEvent  | tmp1 |  tmp1 := false.  presenter whenChangedDo: [ tmp1 := true ].  self emulateLeftClick.  self assert: tmp1initialize  super initialize.  self listCentering: #left.  self indentBy: self class indenthandleMethodRemoved: arg1  | tmp1 tmp2 tmp3 |  self isDisplayed ifFalse: [ ^self ].  refreshingBlock ifNil: [ ^self ].  self okToChange ifFalse: [ ^self ].  tmp1 := arg1 method.  (tmp1 methodClass notNil and: [ tmp1 methodClass isObsolete not ]) ifFalse: [ ^self ].  tmp2 := messageList selectedIndex.  tmp3 := self selectedMessage.  (tmp3 notNil and: [ tmp3 methodClass = tmp1 methodClass and: [ tmp3 selector = tmp1 selector ] ]) ifTrue: [ textModel hasUnacceptedEdits: false ].  self messages: (self messages           remove: tmp1 asFullRingDefinition ifAbsent: [ nil ];           yourself).  self setSelectedIndex: tmp2whenSelectionChangedDo: arg1  list whenSelectionChangedDo: arg1displayBlock: arg1  self deprecated: 'Please use #display: instead' transformWith: '`@receiver displayBlock: `@arg' -> '`@receiver display: `@arg'.  displayBlock := arg1buildWithSpec  ^self buildWithSpecLayout: self retrieveDefaultSpecwhenDeactivationActionChangedDo: arg1  self property: #actionWhenDeactivated whenChangedDo: arg1focusPrevious  self presenter withWindowDo: [:arg1 |  | tmp1 |        tmp1 := arg1 allPresentersInFocusOrder.        (tmp1 before: self presenter ifAbsent: [ tmp1 last ]) takeKeyboardFocus ]testJulianDaysIntervalFor4  | tmp1 |  tmp1 := calendar julianDaysIntervalFor: (Date year: 2018 month: 9 day: 30).  self     assert: tmp1 size equals: calendar daysToDisplayCount;     assert: tmp1 equals: ((Date year: 2018 month: 8 day: 26) julianDayNumber to: (Date year: 2018 month: 10 day: 6) julianDayNumber)browseVersions  self selectedClass ifNotNil: [:arg1 |  self selectedSelector ifNotNil: [:arg2 |  | tmp1 |              tmp1 := self createRingMethodForSelector: arg2 inClass: arg1.              self model browseVersionsFrom: tmp1 ] ]testSelectionExecutesBlock  | tmp1 |  self presenter dropListItems: (#(10 20 30) collect: [:arg1 |  SpDropListItem on: arg1 do: [ tmp1 := arg1 ] ]).  self presenter selectItem: 20.  self assert: tmp1 equals: 20isHorizontal  ^self direction = SpLayoutDirection horizontalnewPresenter: arg1  ^arg1 newApplication: selftestNullPresentersNeededFor  self assert: (layout nullPresentersNeededFor: presentersBuilder) equals: 0onDesactivation  ^onDesactivationtestSelectPathOutsideRangeUnsetsSelectedPath  presenter selectPath: #(4).  self assert: presenter selection selectedPath equals: #()presenterAt: arg1  ^self basicPresenters at: arg1testFirstVisibleRowIsInitiallyFirstRow  presenter items: (1 to: 500).  self openInstance.  self assert: presenter verticalAlignment firstVisibleRowIndex equals: 1clickAtPath: arg1  self selectPath: arg1.  activateOnSingleClick ifFalse: [ ^self ].  self doActivateAtPath: arg1window: arg1  window := arg1constraintsClass  ^SpLayoutConstraintsdescription  ^self host longPrintStringLimitedTo: 2000bottomFraction: arg1  ^0asKMCategory  ^SpKMCategoryBuilder new     visit: self;     kmCategoryadapterBindings  ^adapterBindingsaddTitle: arg1  self deprecated: 'Use #title: instead.' transformWith: '`@receiver addTitle: `@argument' -> '`@receiver title: `@argument'.  self title: arg1canDiscardEdits  ^trueentryCompletion: arg1  ^self input entryCompletion: arg1rowSpacing: arg1  rowSpacing := arg1close  checkboxInput  ^checkboxInputcontainer: arg1  container value: arg1initialize  super initialize.  buttons := OrderedCollection new.  cancelled := true.  self initializeDefaultActionspageClass  ^SpDemoLabelledPresenterinitializePresenters  tabManager := self newNotebook.  tabManager     addPage: self exampleTab;     addPage: self codeTabsetUp  super setUp.  command := SpCommand newsend: arg1  self send: arg1 withArguments: #()testSetSelectPathRaisesSelectionChangeEventWithSelectedPath  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedPath ].  presenter selectPath: #(1 2).  self assert: tmp1 equals: #(1 2)displayBlock  ^displayBlock valuetestWhenPagesChangedDo  | tmp1 |  tmp1 := 0.  self assertEmpty: presenter pages.  presenter whenPagesChangedDo: [ tmp1 := tmp1 + 1 ].  presenter addPage: self mockPage.  self assert: tmp1 equals: 1title  ^titlenotifyPropertyChanged: arg1  self flag: #todo.  (self observablePropertyNamed: arg1) valueChangedbuildWidget  | tmp1 |  tmp1 := FTTableMorph new     hResizing: #spaceFill;     vResizing: #spaceFill;     intercellSpacing: self class intercellSpacing;     yourself.  self addModelTo: tmp1.  ^tmp1preferedPaneColor  ^self model preferedPaneColoritemAt: arg1 of: arg2 then: arg3  | tmp1 |  tmp1 := arg2 at: arg1.  ^arg3 ifNotEmpty: [ self itemAt: arg3 first of: (self childrenFor: tmp1) then: arg3 allButFirst ] ifEmpty: [ tmp1 ]emulateClick: arg1 onTest: arg2  arg2 openInstance.  MouseButtonEvent yellowButton = arg1 ifTrue: [ arg2 adapter rightClicked ].  MouseButtonEvent redButton = arg1 ifTrue: [ arg2 adapter clicked ]layout: arg1  widget ifNil: [ widget := PanelMorph new           layoutPolicy: SpMorphicOverlayLayout new;           hResizing: #spaceFill;           vResizing: #spaceFill;           color: Color transparent;           borderColor: Color transparent;           yourself ].  super layout: arg1browseSenders  SystemNavigation new browseSendersOf: rgMethod selector name: 'Senders of ' , rgMethod selector autoSelect: rgMethod selectorselectedTab  ^selectedTab valuetitle  ^'OpenOnNilExample'testShouldAcceptInteger  presenter     beInteger;     minimum: 90;     maximum: 120.  self assert: (adapter shouldAccept: '').  self assert: (adapter shouldAccept: '100').  self deny: (adapter shouldAccept: '100.10').  self deny: (adapter shouldAccept: '80').  self deny: (adapter shouldAccept: '150').  self deny: (adapter shouldAccept: 'string').  self deny: (adapter shouldAccept: '10string')prepareWithinContext: arg1  behavior := arg1 behaviorclose  self windows copy do: #closeinitializePresenters  dynamicPresenter := self newNullPresenter.  self rebuildDynamicPresenterkeepTreeNode: arg1  ^falsepresenters  ^self basicPresenters valueslayout: arg1  number1Label  ^number1LabelsecondSelection: arg1  tree secondSelection: arg1browseSendersOfMessages  self model browseSendersOfMessagesFrom: self selectedSelectormenu: arg1  menu := arg1label  self subclassResponsibilitybrowseMethod  self currentMethod ifNotNil: [:arg1 |  arg1 browse ]createPackage  | tmp1 |  tmp1 := UIManager default request: 'Name of package:'.  tmp1 isEmptyOrNil ifTrue: [ ^self ].  RPackageOrganizer default registerPackageNamed: tmp1.  MCWorkingCopy forPackage: (MCPackage new name: tmp1)unselectItem: arg1  self unselectIndex: (self indexOfItem: arg1)actualClass  ^SpMorphicNumberInputFieldAdapterpresenters  ^self basicPresenters valuesaddCellMorph: arg1 column: arg2  arg2 isExpandable ifFalse: [ arg1           hResizing: #rigid;           width: (arg2 width ifNil: [ arg1 width ]) ].  cell addMorphBack: arg1initializeBindings  self allAdapters do: [:arg1 |  bindings at: arg1 adaptingName put: arg1 name.        arg1 adaptingAliases do: [:arg2 |  bindings at: arg2 put: arg1 name ] ]digits  ^digitsselectedObject: arg1  self list setSelectedIndex: 1.  self list listItems withIndexDo: [:arg2 :arg3 |  arg2 value == arg1 ifTrue: [ self list setSelectedIndex: arg3 ] ]classToTest  ^SpLabelledContainernewMorph  ^self instantiate: SpMorphPresenterinitializeButtons  applyTo: arg1  arg1 setProperty: #style toValue: self.  self styles do: [:arg2 |  arg2 applyTo: arg1 ]basicAssociatedRadioButtons: arg1  associatedRadioButtons := arg1 copyWithout: selfitems: arg1  arg1 ifNotEmpty: [ self numberOfColumns: (displayBlock value: arg1 first) size ].  super items: arg1color  ^self model colorinspectionMenu: arg1  self     exploreSubMenu: arg1;     browseSubMenu: arg1;     customSubMenu: arg1;     endSubMenu: arg1;     errorSubMenu: arg1itemBlock  ^[ self item ]selectIndexes: arg1  | tmp1 |  tmp1 := (arg1 collect: [:arg2 |  self withinRangeIndex: arg2 ]) asSet.  (tmp1 isNotEmpty and: [ tmp1 allSatisfy: [:arg2 |  arg2 = 0 ] ]) ifTrue: [ ^self ].  tmp1 := tmp1 reject: [:arg2 |  arg2 = 0 ].  tmp1 = self selectedIndexes asSet ifTrue: [ ^self ].  ^selectedIndexes := tmp1 asOrderedCollectioninitializePresenters  = arg1  self == arg1 ifTrue: [ ^true ].  self class = arg1 class ifFalse: [ ^false ].  ^host == arg1 hosthost: arg1  host := arg1testRowColorsAfterBuild  treeWithItems buildWithSpec.  treeWithItems oddRowColor: Color red.  treeWithItems evenRowColor: Color green.  self assert: treeWithItems adapter widget rowColors equals: (Array with: Color green with: Color red)rangeMinimum: arg1 maximum: arg2  self minimum: arg1.  self maximum: arg2newPanel  ^Morph new     changeTableLayout;     hResizing: #spaceFill;     vResizing: #spaceFill;     color: Color transparent;     borderColor: Color transparent;     clipSubmorphs: true;     beSticky;     borderWidth: 0;     extent: 0 @ 0;     yourselfaddSpecialFields: arg1  arg1 add: (DynamicEyeElement host: self object label: 'hex' description: [ self object printStringRadix: 16 ] value: [ self object ]).  arg1 add: (DynamicEyeElement host: self object label: 'octal' description: [ self object printStringRadix: 8 ] value: [ self object ]).  arg1 add: (DynamicEyeElement host: self object label: 'binary' description: [ self object printStringRadix: 2 ] value: [ self object ]).  (self object between: 0 and: 16r10FFFF) ifTrue: [ arg1 add: (DynamicEyeElement host: self object label: 'character' description: [:arg2 |  arg2 printString ] value: [ self object asCharacter ]) ]label: arg1  label := arg1applyStyleTo: arg1  ^self subclassResponsibilityclimbRate  ^climbRatetestInstVarNames  builder modelObjects: {3 .         2 .         1}.  self assertCollection: builder instVarNames hasSameElements: #(var1 var2 var3)isColumnHomogeneous  ^columnHomogeneousbindModel: arg1 andWidget: arg2  arg2 when: #tabSelected send: #tabSelected to: arg1.  arg1 actionsHolder whenChangedDo: [:arg3 |  arg2 actions: arg3 ].  arg1 closeableHolder whenChangedDo: [:arg3 |  arg2 closeable: arg3 ].  arg1 iconHolder whenChangedDo: [:arg3 |  arg2 icon: arg3 ].  arg1 labelHolder whenChangedDo: [:arg3 |  arg2 label: arg3 ].  arg1 menuHolder whenChangedDo: [:arg3 |  arg2 menu: arg3 ].  arg1 morphHolder whenChangedDo: [:arg3 |  arg2 morph: arg3 ].  arg1 retrievingBlockHolder whenChangedDo: [:arg3 |  arg2 retrievingBlock: arg3 ].  arg1 selectedHolder whenChangedDo: [:arg3 |  arg2 selected: arg3 ]initialize  updating := false.  super initializeclassToTest  ^SpNotebookPresentertestWhenHelpChanged  presenter help: 'label1'.  presenter whenHelpChangedDo: [:arg1 :arg2 |  self assert: arg2 equals: 'label1'.        self assert: arg1 equals: 'label2' ].  self assert: presenter help equals: 'label1'.  self openInstance.  presenter help: 'label2'.  self assert: presenter help equals: 'label2'setUp  super setUp.  self error: 'Do not override me.... use #initializeTestedInstance'testBuildAdapterForBindings  | tmp1 |  tmp1 := SpAbstractWidgetLayout for: #ListAdapter.  self assert: (tmp1 buildAdapterFor: SpListPresenter new bindings: SpStubAdapterBindings new) widget class equals: SpStubListViewwhenPlaceholderChanged: arg1  self property: #placeholder whenChangedDo: arg1setCurrentChangeSet  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  self model setCurrentChangeSet: self selectedChangeSet.  self updateWindowTitlehasOwner  ^self owner notNilrootNodeFor: arg1  | tmp1 |  tmp1 := self rootNodeHolder cull: arg1.  tmp1 container: self.  ^tmp1browseSelectedObjectClassHierarchy  self selectedObjectDo: [:arg1 |  arg1 class browseHierarchy ]dropEnabled: arg1  dropEnabled := arg1adapterBindings  ^self backend adapterBindingswhenImageChangeDo: arg1  self property: #image whenChangedDo: arg1whenChangedDo: arg1  self subclassResponsibilityexecute: arg1  buttonGroup unselectAll.  self beSelected.  self action cull: arg1 cull: selfwhenRootsChangedDo: arg1  rootsHolder whenChangedDo: arg1whenAboutToStyleBlockChangedDo: arg1  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8testColumnsAreExplicitlySetEvenIfDisplayBlockContainsMoreItems  self assert: presenter columns size equals: 2firstButton  ^firstButtontitle: arg1  ^DisplayScreen hostWindowTitle: arg1whenDeactivatedDo: arg1  self whenChangedDo: [:arg2 |  arg2 ifFalse: arg1 ]isAboutToStyle  self deprecated: 'Use #okToStle instead' transformWith: '`@receiver isAboutToStyle' -> '`@receiver okToStyle'.  ^self okToStyletestBeNotPasswordIsSet  presenter bePassword: false.  self deny: presenter isPasswordwhenCanDeselectByClickChangedDo: arg1  canDeselectByClick whenChangedDo: arg1getText  self deprecated: 'This method is an horrible hack because the VersionBrowser was using Code or Diff presenter but was only using the API of the Code presenter... This method and other methods from the CodePresenter API will be removed.'.  ^self rightTextokToChange  self flag: #TODO.  self presenter canDiscardEdits ifTrue: [ ^true ].  self changed: #wantToChange.  ^self canDiscardEditswhenActivatedDo: arg1  activationBlock := arg1vSpaceFill  self subclassResponsibilitypresenter  ^presenterdefaultOnce: arg1  arg1 privateSetState: true.  self currentActivated: arg1adapt: arg1 bindings: arg2  | tmp1 |  tmp1 := self adapterFor: arg1 bindings: arg2.  tmp1 adapt: arg1.  ^tmp1setModal: arg1  self widgetDo: [:arg2 |  arg2 spSetModal: arg1 ]fromPort  ^fromPortsetSelection: arg1  selected := arg1.  self changed: #isSelectedinitialize  super initialize.  self beResizeableprivateSetState: arg1  self deprecated: 'Do not use it'.  state := arg1.  self changed: #stateselectedIndex: arg1  self deprecated: 'Use #selectIndex: instead' transformWith: '`@receiver selectedIndex: `@arg' -> '`@receiver selectIndex: `@arg'.  self selectIndex: arg1newCode  ^self instantiate: SpCodePresenterinitializePrivateAnnouncer  announcer := Announcer newisSortable  ^self model isSortabletestSubscribeToEventDoesNotRaiseEvent  presenter selection whenChangedDo: [:arg1 |  self fail ]icon  ^icon valuesetSelectedIndex: arg1  self deprecated: 'Use #selectedIndex: instead' transformWith: '`@receiver setSelectedIndex: `@argument' -> '`@receiver selectedIndex: `@argument'.  ^self selectIndex: arg1testUnselectNonSelectedIndexRaisesNoEvent  | tmp1 |  tmp1 := 0.  presenter     selectIndex: 1;     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectIndex: 2.  self assert: tmp1 equals: 0testSelectPathsAddsItemsToSelectedItemList  | tmp1 |  tmp1 := {#(1 2) .   #(2 2)}.  presenter selectPaths: tmp1.  self assert: (presenter selection includesItems: {3 .               6})buildWidget  | tmp1 |  tmp1 := PanelMorph new     changeTableLayout;     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #spaceFill;     cellInset: self class defaultItemSeparation;     height: self class defaultHeight;     yourself.  self addModelTo: tmp1.  ^tmp1action: arg1  action := arg1height  ^self lookupProperty: SpStyleGeometry valueOf: #heightinitializePresenters  button1 := self newButton.  button2 := self newButton.  button1     label: 'Open 1';     action: [ SpDemoModal1Presenter new openModalWithSpec ].  button2     label: 'Open 2';     action: [ SpDemoModal2Presenter new openModalWithSpec ]tabSelected  tabSelectedActionHolder value cull: selfname  ^name ifNil: [ self class portName ]initialize  super initialize.  pagesHolder := OrderedCollection new asValueHolder.  pagesHolder whenChangedDo: [ self pagesChanged ]bottomOffset  ^layoutFrame bottomOffsetpageClass  ^SpDemoLinksPresentertearDown  instance ifNotNil: [ instance close.        instance := nil ].  super tearDownbindKeyCombination: arg1 toAction: arg2  contextKeyBindings ifNil: [ contextKeyBindings := KMCategory new ].  contextKeyBindings addKeymapEntry: (KMKeymap shortcut: arg1 action: arg2).  self withAdapterDo: [:arg3 |  arg3 bindKeyCombination: arg1 toAction: arg2 ]blockToPerformOnWrappers  ^blockToPerformOnWrappers valuedefaultTransferFor: arg1 from: arg2  ^SpTransferPresenter new     transfer: arg1;     from: arg2;     yourselfwhenChildrenBlockChanged: arg1  self deprecated: 'Use #whenChildrenBlockChangedDo: instead.' transformWith: '`@receiver whenChildrenBlockChanged: `@statements' -> '`@receiver whenChildrenBlockChangedDo: `@statements'.  self whenChildrenBlockChangedDo: arg1testUnselectAllRaisesSelectionEventOnce  | tmp1 |  tmp1 := 0.  presenter selectPath: #(1 1).  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter unselectAll.  self assert: tmp1 equals: 1acceptOnCR  ^self model acceptOnCRadd: arg1 bottom: arg2  self add: arg1 top: nil bottom: arg2 left: nil right: nilhasPageWithModel: arg1  ^self pages anySatisfy: [:arg2 |  arg2 model = arg1 ]footnoteArea  ^footnoteAreawhenRootsChanged: arg1  self deprecated: 'Use #whenRootsChangedDo: instead.' transformWith: '`@receiver whenRootsChanged: `@statements' -> '`@receiver whenRootsChangedDo: `@statements'.  self whenRootsChangedDo: arg1confirm: arg1 label: arg2  ^UIManager default confirm: arg1 label: arg2visitCheckboxColumn: arg1  fromPresenter  ^self fromPort presenterinitialize  super initialize.  self beInteger.  self digits: self class defaultDigits.  self climbRate: self class defaultClimbRatehResizing: arg1  hResizing := arg1roots  ^self model rootslabelClickable  ^self presenter labelClickablebrowseImplementorsOfMessages  self model browseMessagesFrom: self selectedSelectorinitialize  super initialize.  text := ''.  placeholder := ''.  actionToPerform := [:arg1 |   ].  readSelection := [ selection ].  actionPerformed := ''.  hasUnacceptedEdits := false.  selection := 1 to: 0.  autoAccept := false.  wantsVisualFeedback := true.  askBeforeDiscardingEdits := true.  self registerEventsbuildWidget  ^SpStubMultiColumnListView newevenRowColor: arg1  evenRowColor value: arg1incomingTransmission: arg1 from: arg2  self destinationPresenter morph: arg1buildWidget  ^self class newclassToTest  ^self subclassResponsibilityhasError  self withErrorsDo: [ ^true ].  ^falseiconHolder: arg1  self deprecated: 'Use iconBlock: instead' transformWith: '`@receiver iconHolder: `@statements1' -> '`@receiver iconBlock: `@statements1'.  self iconBlock: arg1number2Label  ^number2LabelonlyStrong  onlyStrong := truecolumnSpan  ^self span xradioButtonClassSide  ^radioButtonClassSidewhenTextIsAccepted: arg1  self deprecated: 'Use #whenTextIsAcceptedDo: instead.' transformWith: '`@receiver whenTextIsAccepted: `@statements' -> '`@receiver whenTextIsAcceptedDo: `@statements'.  self whenTextIsAcceptedDo: arg1add: arg1 properties: arg2 to: arg3  arg3 add: arg1 withConstraints: [:arg4 |  arg4           expand: ((properties at: arg2) at: #expanded);           fill: ((properties at: arg2) at: #filled);           padding: ((properties at: arg2) at: #padding) ]lastVisibleRowIndex  ^lastVisibleRowIndexshowOnlyDestination  ^self model showOnlyDestinationconnectPresenters  listModel whenSelectionChangedDo: [ self updateText ]interpretASpec: arg1 model: arg2 selector: arg3  self deprecated: 'Use `interpretASpec: aSpec presenter: aPresenter` instead' transformWith: '`@receiver interpretASpec: `@statements1 model: `@statements2 selector: `@statements3' -> '`@receiver interpretASpec: `@statements1 presenter: `@statements2'.  ^self interpretASpec: arg1 presenter: arg2contactBook  ^contactBookposition  ^positiondrawOn: arg1  self redraw.  self surface displayOnMorphicCanvas: arg1 at: bounds originitemsLabel  ^itemsLabelsearchPresenter  ^searchPresentercircle: arg1  ^arg1 createPath: [:arg2 |  arg2           absolute;           moveTo: 50 @ 150;           ccwArcTo: 150 @ 250 angle: 90 degreesToRadians;           ccwArcTo: 250 @ 150 angle: 90 degreesToRadians;           ccwArcTo: 150 @ 50 angle: 90 degreesToRadians;           ccwArcTo: 50 @ 150 angle: 90 degreesToRadians ]resetListSelection  self selectIndex: 0selectionHolder  ^self observablePropertyNamed: #selectionticks  ^ticksselectedItems  ^selectedItemswantDropBlock  ^wantDropBlockwhenSelectedItemChanged: arg1  | tmp1 |  tmp1 := [:arg2 |  arg1 cull: (associationsWrapperToItem at: arg2 ifAbsent: [ nil ]) ].  listPresenter whenSelectedItemChanged: tmp1changeSorterLeft  ^changeSorterLeftnewDataSource  ^SpComponentListDataSource new     model: self presenter;     yourselfexplorePointers  ^Smalltalk tools pointerExplorer openStrongOn: self valueunselectAll  self selection unselectAlltoolbar: arg1  | tmp1 |  toolbar := arg1.  self removeMorph: (tmp1 := self submorphs last).  self addMorph: (self newDialogPanel           addMorphBack: tmp1;           addMorphBack: self newButtonRow;           yourself) frame: (0 @ 0 corner: 1 @ 1)urlHolder  self deprecated: 'Nobody should access directly to internals of Spec. Now this variable is not a value holder anymore.'pathFromIndex: arg1  | tmp1 |  tmp1 := self allShownItems at: arg1 ifAbsent: [ ^#() ].  ^self pathOfItem: tmp1 root: rootItemtransferSubscriptionsTo: arg1  arg1 subscriptions: subscriptionstopOffset  ^topOffsettestAddingAnItemSelectsItIfThereIsNone  self presenter addItemLabeled: 40 do: [  ].  self assert: self presenter selectedItem equals: 40.  self assert: self adapter selectedIndexes equals: #(4)iconName: arg1  iconHolder value: (self iconNamed: arg1)addPresenterIn: arg1 withSpecLayout: arg2  actForSpec  UIManager default inform: self messageText.  self flag: #TODOwhenSelectedItemsChangedDo: arg1  selectionHolder whenChangedDo: [:arg2 |  arg1 cull: (arg2 collect: [:arg3 |  arg3 content ]) ]askBeforeDiscardingEdits  ^askBeforeDiscardingEditsbuildWidget  ^SpStubDiffView newlistSize  ^self model sizeshouldShowInTree  ^falsebottom  ^bottompages  ^pagesHolder valueinitializePresenters  < script: 'self new openWithSpec'>  table := self newTable     addColumn: (SpCompositeTableColumn new           title: 'Classes';           addColumn: (SpImageTableColumn evaluated: #systemIcon) beNotExpandable;           addColumn: (SpStringTableColumn evaluated: #name);           yourself);     items: Smalltalk allClassesAndTraits;     itemFilter: [:arg1 :arg2 |  arg1 crTrace.        arg1 asLowercase includesSubstring: arg2 asLowercase ];     yourselfwidgetDo: arg1  ^self widget ifNotNil: arg1checkboxFor: arg1  ^associationsItemToWrapper at: arg1 ifAbsent: [ nil ]model  ^modelhasSyntaxHighlightEnabled  ^(self widget textArea editingMode isKindOf: RubPlainTextMode) notneedRebuild  ^needRebuildautoDeselect  self deprecated: 'Should not use. This feature is not supported anymore'.  ^autoDeselectselectedItems: arg1  selectionHolder value: arg1setUp  super setUp.  presenter     beMultipleSelection;     items: #(10 20 30)removeSubWidgets  inputPortDefault  ^self inputPorts firstunscaledInitialExtent  ^15 @ 26iconBlock  ^[:arg1 |  self iconFor: arg1 ]defaultTitle  ^'Change Sorter'prepareWithinContext: arg1  nullPresentersNeededFor: arg1  ^self rowsCount - ((arg1 modelObjects size - 1) % self rowsCount + 1)applyTo: arg1  self subclassResponsibilitytoolbar: arg1  toolbar := arg1classToTest  ^SpOpenOnStringExamplematchTokenFilterBlock: arg1  matchTokenFilter value: arg1spacing: arg1  layout spacing: arg1generateUniqueInstanceVariableName  instVarCount := instVarCount + 1.  ^(#var , instVarCount asString) asSymbolsourceIntervalOf: arg1 in: arg2  | tmp1 |  tmp1 := arg2 allChildren detect: [:arg3 |  arg3 isMessage and: [ arg3 selector = arg1 ] ] ifNone: [ ^#() ].  ^tmp1 keywordsPositions first to: tmp1 keywordsPositions last + tmp1 keywords last size - 1initializePresenters  label := self instantiate: SpLabelPresenter.  check := self instantiate: SpCheckBoxPresenter.  input := self instantiate: SpTextInputFieldPresenter.  button := self instantiate: SpButtonPresenter.  button     label: 'reset';     action: [ input text: textToReset ].  check     label: 'Label on top';     state: falsewhenActionChangedDo: arg1  self property: #action whenChangedDo: arg1transferFor: arg1 from: arg2  ^(self transferBlock cull: arg1 cull: self model) buildWithSpecprintString  ^wrapped printStringeventKeyStrokesForNextFocus  ^{Character tab asKeyCombination}canBeExecuted  ^self context isContactSelectedwhenIconsChanged: arg1  self deprecated: 'Use #whenIconsChangedDo: instead' transformWith: '`@receiver whenIconsChanged: `@argument' -> '`@receiver whenIconsChangedDo: `@argument'.  self whenIconsChangedDo: arg1rowsCount  ^rowsCounttestClassIsDisplayedWithCorrectAlignment  | tmp1 tmp2 |  tmp1 := SpBoxLayoutWithTableForTestPresenter new.  instance := tmp1 openWithSpec.  tmp2 := tmp1 table adapter widget.  self assert: instance window left <= tmp2 left.  self assert: tmp2 left <= tmp2 submorphs first leftcontext  ^contextresetSelection  self deprecated: 'Please use #unselectAll instead' transformWith: '`@receiver resetSelection' -> '`@receiver unselectAll'.  self unselectAllinitializePresenters  table1 := self newTreeTable.  table1     addColumn: (SpCompositeTableColumn new           title: 'Classes';           addColumn: ((SpImageTableColumn evaluated: #systemIcon)                 width: 20;                 yourself);           addColumn: (SpStringTableColumn evaluated: #name);           yourself);     addColumn: (SpStringTableColumn title: 'Number of subclasses' evaluated: [:arg1 |  arg1 subclasses size asString ]);     addColumn: (SpStringTableColumn title: 'Number of methods' evaluated: [:arg1 |  arg1 methods size asString ]);     roots: {Object};     children: [:arg2 |  arg2 subclasses ];     beResizable;     contextMenu: self menu;     activateOnDoubleClick;     whenActivatedDo: [:arg3 |  arg3 selectedItem browse ]sliderInput  ^subwidgetwhenItemsChangeDo: arg1  self     property: #leftItems whenChangedDo: arg1;     property: #rightItems whenChangedDo: arg1rowInset  ^rowInset valuetitle: arg1  title := arg1autoAccept: arg1  autoAccept := arg1doItContext  ^nilwithoutSyntaxHighlight  self syntaxHighlight: falsemethodAdded: arg1  UIManager default defer: [ self handleMethodAdded: arg1 ]newTabSelectorMorph  ^SpNotebookTabSelectorMorph new     vResizing: #shrinkWrap;     hResizing: #spaceFill;     cellInset: self class tabCellInset;     yourselfstate  ^self presenter statesetModelBeforeInitialization: arg1  self setRGMethodFrom: arg1deleteDiscardingChanges  | tmp1 |  tmp1 := SpWindowWillClose new     window: self;     yourself.  self announce: tmp1.  self currentWorld announcer announce: tmp1.  ^super deleteDiscardingChangesnewSplitter  ^SpPanedResizerMorph newHorizontaladoptPaneColor: arg1  self assureExtension.  extension fillStyle ifNil: [ self color: arg1 ].  self borderStyle baseColor: arg1 darker.  self submorphsDo: [:arg2 |  arg2 adoptPaneColor: arg1 ]resizerWidth: arg1  resizerWidth value: arg1initializeSemaphore  uiWaitingSemaphore := Semaphore newon: arg1 do: arg2  self deprecated: 'Use #bindKeyCombination:toAction: instead.' transformWith: '`@receiver on: `@statements1 do: `@statements2' -> '`@receiver bindKeyCombination: `@statements1 toAction: `@statements2'.  self bindKeyCombination: arg1 toAction: arg2items: arg1  model collection: arg1roots  ^self childrenForObject: self objectinitialize  super initialize.  columns := OrderedCollection new: 2buttonWithIcon  ^buttonWithIconfastForward  ticks := highestValuetestUnselectSelectedItemRaisesSelectionEventOnce  | tmp1 |  tmp1 := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectItem: 10.  self assert: tmp1 equals: 1buildWidget  ^self autoRefresh ifTrue: [ self buildWidgetAutoRefresh ] ifFalse: [ self buildWidgetNoRefresh ]keyText: arg1  self flag: #TODO.  self shortcut: arg1 first metawhenDrawBlockChangedDo: arg1  self property: #drawBlock whenChangedDo: arg1urlDuringClickColor  ^self urlHoverColor darkerinitializeTestedInstance  redTab := self redMorphTabbrowseMethodFull  self selectedClass ifNotNil: [:arg1 |  Smalltalk tools browser openOnClass: arg1 selector: self selectedSelector ]homogeneous: arg1  homogeneous := arg1canDeselectByClick  self deprecated: 'This option is removed in Spec 2'.  ^falseinitializeWindow: arg1  super initializeWindow: arg1.  arg1     title: self title;     windowIcon: self taskbarIcon;     askOkToClose: truesortingBlock  ^self model sortingBlocktestSetSortingBlockBeforeItems  | tmp1 |  tmp1 := 0.  presenter whenSortingBlockChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter sortingBlock: #yourself ascending.  presenter items: #(3 8 1 0).  self assert: tmp1 equals: 1.  self assert: (presenter model at: 1) equals: 0testOpenDialogWindowAddsItToWindowCollection  | tmp1 |  tmp1 := (application newPresenter: SpButtonPresenter) openDialogWithSpec.  self assert: (application windows includes: tmp1)buildWidget  | tmp1 |  tmp1 := SpNotebookMorph new     vResizing: #spaceFill;     hResizing: #spaceFill;     setBalloonText: self help;     yourself.  self addModelTo: tmp1.  self model whenPagesChangedDo: [:arg1 |  self updatePagesWith: arg1 ].  self model whenSelectedPageChangedDo: [:arg2 |  self selectPage: arg2 ].  ^tmp1bindKeyCombination: arg1 toAction: arg2  add: arg1 withSpec: arg2 top: arg3  self add: arg1 withSpec: arg2 top: arg3 bottom: nil left: nil right: niltestSelectIndexAddsItemToSelectedItemList  presenter selectIndex: 1.  self assert: (presenter selection includesItem: 10)extent: arg1  ^self widget extent: arg1tabs  ^tabsgetIconFor: arg1  ^self model getIconFor: arg1whenRootsChangedDo: arg1  self property: #roots whenChangedDo: arg1setSourceContentWith: arg1  isShowingDiff ifTrue: [ (arg1 isText or: [ arg1 isString ]) ifTrue: [ sourcePresenter leftText: ''.              sourcePresenter rightText: arg1 ] ifFalse: [ sourcePresenter leftText: arg1 first.              sourcePresenter rightText: arg1 second ] ] ifFalse: [ sourcePresenter text: arg1 ]mouseDown: arg1 from: arg2  arg2 color: self urlDuringClickColorlabel: arg1  label := arg1topOffset: arg1  layoutFrame topOffset: arg1typeForSearch: arg1  self type: arg1delete  self widgetDo: [:arg1 |  arg1 delete ]initialize  | tmp1 |  super initialize.  self color: Color transparent.  tmp1 := self newSpinnerMorph.  transformationMorph := TransformationMorph new asFlexOf: tmp1.  self addMorph: transformationMorphinspectHistoryItem: arg1  self inspector: arg1 keymenu  ^menubindKeyCombination: arg1 toAction: arg2  banana  ^42testDecreasedValueFrom  presenter     beInteger;     minimum: 80;     climbRate: 2.  self assert: (adapter decreasedValueFrom: '85') equals: '83'.  self assert: (adapter decreasedValueFrom: '81') equals: '80'.  self assert: (adapter decreasedValueFrom: '80') equals: '80'.  presenter     beFloat;     climbRate: 2.5;     digits: 1.  self assert: (adapter decreasedValueFrom: '85') equals: '82.5'.  self assert: (adapter decreasedValueFrom: '81') equals: '80.0'whenStateChangedDo: arg1  self property: #state whenChangedDo: arg1whenSelectedItemChanged: arg1  self dropList whenSelectedItemChanged: arg1modelChanged  x text: self model x asString.  y text: self model y asStringrowInset  ^self model rowInsetconnectPresenters  classListPresenter transmitTo: methodListPresenter transform: [:arg1 |  arg1 methods sort: #selector descending ] postTransmission: [:arg2 |  arg2 selectIndex: 1 ].  methodListPresenter transmitTo: textPresenter transform: [:arg3 |  arg3 ifNil: [ '' ] ifNotNil: #sourceCode ] postTransmission: [:arg2 :arg4 :arg5 |  arg5 ifNotNil: [ arg2 behavior: arg5 methodClass ] ]stepTime  ^self presenter stepTimefixedPercentage: arg1  self fixedAt: arg1 / 100registerMethodShortcuts: arg1  arg1 bindKeyCombination: PharoShortcuts current browseShortcut toAction: [ self selectedSelector ifNotNil: [ self browseMethodFull ] ].  arg1 bindKeyCombination: $d meta toAction: [ self selectedSelector ifNotNil: [ self forgetMessage ] ].  arg1 bindKeyCombination: PharoShortcuts current browseImplementorsShortcut toAction: [ self selectedSelector ifNotNil: [ self browseImplementorsOfMessages ] ].  arg1 bindKeyCombination: PharoShortcuts current browseSendersShortcut toAction: [ self selectedSelector ifNotNil: [ self browseSendersOfMessages ] ].  arg1 bindKeyCombination: PharoShortcuts current browseVersionsShortcut toAction: [ self selectedSelector ifNotNil: [ self browseVersions ] ].  arg1 bindKeyCombination: PharoShortcuts current removeShortcut toAction: [ self selectedSelector ifNotNil: [ self removeMessage ] ]setUp  super setUp.  presenter     beSingleSelection;     items: #(10 20 30)adapterFor: arg1 bindings: arg2  ^self class environment at: (arg2 translateSymbol: self adapterName) ifPresent: [:arg3 |  arg3 owner: arg1 ] ifAbsent: [ self error: 'No binding for ' , self adapterName , ' found.' ]list: arg1  list := arg1traverseInFocusOrderDo: arg1 excluding: arg2  self presenter traverseInFocusOrderDo: arg1 excluding: arg2handleMethodModified: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  self isDisplayed ifFalse: [ ^self ].  refreshingBlock ifNil: [ ^self ].  tmp1 := arg1 newMethod.  tmp2 := arg1 oldMethod.  tmp3 := self selectedMessage.  tmp3 ifNil: [ ^self ].  (tmp3 methodClass = tmp2 methodClass and: [ tmp3 selector = tmp2 selector ]) ifFalse: [ ^self ].  (self shouldRefreshItem: tmp1 fromAnnouncement: arg1) ifFalse: [ ^self ].  tmp7 := textModel hasUnacceptedEdits.  tmp7 ifTrue: [ tmp5 := textModel pendingText ].  tmp4 := messageList selectedIndex.  tmp6 := self messages     remove: tmp3 ifAbsent: [  ];     add: tmp1 asFullRingDefinition;     yourself.  self messages: tmp6.  self setSelectedIndex: tmp4.  tmp7 ifFalse: [ ^self ].  textModel pendingText: tmp5.  textModel hasEditingConflicts: trueborderWidth: arg1  presenter: arg1  presenter := arg1hasIcons  ^iconBlock isNotNil and: [ self model collection anySatisfy: [:arg1 |  arg1 icon isNotNil ] ]arguments  subwidgetArguments ifNil: [ subwidgetArguments := self subwidgetArguments ].  ^{{subwidgetArguments .   #layout: .   self generateSpec}}whenShortcutsChanged: arg1  self deprecated: 'This event does not has sense in Spec2'unselectAll  self selectIndex: 0testSelectIndexesTwiceAddsIndexesToSelectedIndexListOnlyOnce  presenter     selectIndexes: {1 .         2};     selectIndexes: {1 .         2}.  self assertCollection: presenter selection selectedIndexes hasSameElements: {1 .         2}layoutProperties: arg1  self widgetDo: [:arg2 |  arg2 layoutProperties: arg1 ]accessorCode  ^'(self basicAt: ' , self index asString , ')'testSpanRow  | tmp1 |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1 span: 1 @ 2.  self place: label2 at: 1 @ 2.  self place: morph2 at: 3 @ 2.  tmp1 := self newLayout.  tmp1 layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 50 @ 20).  self assert: morph1 bounds equals: (50 @ 0 corner: 100 @ 40).  self assert: label2 bounds equals: (0 @ 20 corner: 50 @ 40).  self assert: morph2 bounds equals: (100 @ 20 corner: 150 @ 40)whenHasChildrenBlockChangedDo: arg1  hasChildrenBlockHolder whenChangedDo: arg1selectLine  self withAdapterDo: [:arg1 |  arg1 selectLine ].  ^self selectionIntervalbold  ^bolddisplay: arg1  displayBlock := arg1transmitDo: arg1 transform: arg2  self newTransmission     from: self;     do: arg1;     transform: arg2;     applytransferFor: arg1 from: arg2  ^self model transferFor: arg1 from: arg2icon  ^iconbuildWidget  | tmp1 |  tmp1 := SpMorphicListDataSource new.  tmp1 model: self model.  widget := FTTableMorph new     dataSource: tmp1;     hideColumnHeaders;     enableSearch;     beResizable;     columns: {self newListColumn};     setMultipleSelection: self model isMultipleSelection;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     setBalloonText: self help;     hResizing: #spaceFill;     vResizing: #spaceFill;     onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self;     onAnnouncement: FTStrongSelectionChanged send: #strongSelectionChanged: to: self;     yourself.  self presenter whenModelChangedDo: [ widget refresh ].  self presenter whenSelectionChangedDo: [ self refreshWidgetSelection ].  self presenter selection whenChangedDo: [ self refreshWidgetSelection ].  self presenter whenSearchChangedDo: [ self updateSearch ].  self refreshWidgetHeaderTitle.  self refreshWidgetSelection.  self presenter whenItemFilterBlockChangedDo: [:arg1 |  self updateItemFilterBlockWith: arg1 ].  self updateItemFilterBlockWith: self itemFilter.  self configureScrolling.  widget bindKeyCombination: Character space toAction: [ self model clickOnSelectedItem ].  ^widgetaddShortcutTipFor: arg1  ^self addShortcutTipFor: self shortcutCharacter on: arg1testRemoveTabFromMorphic  presenter addTab: redTab.  self openInstance.  self assertCollection: presenter tabs hasSameElements: {redTab}.  presenter removeTab: redTab.  self assertCollection: presenter tabs hasSameElements: #().  self assertCollection: (self morphicTabsFor: presenter) hasSameElements: #()mouseDownAction: arg1  mouseDownAction value: arg1name: arg1  name := arg1loremIpsum  ^String loremIpsum: 2854initialize  model := ChangeSorterModel new.  SystemAnnouncer uniqueInstance weak when: CurrentChangeSetChanged send: #updateTitle to: self.  super initialize.  self initializeAnnouncementsinteractionModel  ^selftestUnselectUnselectedPathKeepsSelectionList  presenter     selectPath: #(1 2);     unselectPath: #(2 2).  self assert: presenter selection selectedPaths equals: {#(1 2)}value: arg1  value = arg1 ifTrue: [ ^self ].  value := arg1makeNewForm  ^(Form extent: 30 @ 30 depth: 32) fillColor: self colorcontainer  ^containerbuildLayout  ^self layoutBuilder buildFor: selfstyle  ^SpMorphStyle fromStylesheet: self styleSheet adapter: selftext: arg1  ^self input text: arg1testInitializeProtocolListShouldSelectedItemSetToAll  self assert: biChooseMethod selectedProtocol name equals: '-- all --'initializeWidgets  super initializeWidgets.  description := self newTextlabel: arg1  label := arg1icon  ^icontestAutoScale  | tmp1 tmp2 |  tmp1 := 0.  presenter whenAutoScaleChangeDo: [:arg1 |  tmp2 := arg1.        tmp1 := tmp1 + 1 ].  presenter autoScale: true.  self assert: tmp1 equals: 1.  self assert: tmp2testShouldAcceptFloatWithMaxDigits  presenter     beFloat;     minimum: 0;     maximum: 120;     digits: 5.  self assert: (adapter shouldAccept: '1.1111').  self assert: (adapter shouldAccept: '1.11111').  self deny: (adapter shouldAccept: '1.111111')testConvertRandomSymbolOfClassToInstance  | tmp1 tmp2 |  tmp1 := #MenuRegistration.  tmp2 := specInterpreter convertSymbolOfClassToInstance: tmp1.  self assert: tmp2 class name equals: tmp1eventKeyStrokesForPreviousFocus  ^{Character arrowLeft command ctrl asKeyCombination}newPanel  ^super newPanel     extent: 1 @ 1;     yourselfisMultipleSelection  ^falsepadding: arg1  padding := arg1changeSetMenu  ^self newMenu     title: 'Change Set';     addGroup: [:arg1 |  arg1           addItem: [:arg2 |  arg2                 name: 'Make changes go to me';                 shortcut: $m meta;                 action: [ self setCurrentChangeSet ] ];           addItem: [:arg2 |  arg2                 name: 'New change set...';                 shortcut: $n meta;                 action: [ self newSet ] ];           addItem: [:arg2 |  arg2                 name: 'Find...';                 shortcut: $f meta;                 action: [ self findChangeSet ] ] ];     addGroup: [:arg1 |  arg1           addItem: [:arg2 |  arg2                 name: 'Rename change set';                 shortcut: $r meta;                 action: [ self rename ] ];           addItem: [:arg2 |  arg2                 name: 'File out';                 shortcut: $o meta;                 action: [ self fileOut ] ];           addItem: [:arg2 |  arg2                 name: 'Browse methods';                 shortcut: $b meta;                 action: [ self browseChangeSet ] ];           addItem: [:arg2 |  arg2                 name: 'Browse change set';                 shortcut: $B meta;                 action: [ self openChangeSetBrowser ] ];           addItem: [:arg2 |  arg2                 name: 'Add/Edit preamble';                 shortcut: $p meta;                 action: [ self addPreamble ] ];           addItem: [:arg2 |  arg2                 name: 'Remove preamble';                 action: [ self removePreamble ] ];           addItem: [:arg2 |  arg2                 name: 'Add/Edit postscript...';                 action: [ self editPostscript ] ];           addItem: [:arg2 |  arg2                 name: 'Remove postscript';                 action: [ self removePostscript ] ] ];     addGroup: [:arg1 |  arg1 addItem: [:arg2 |  arg2                 name: 'Destroy change set';                 shortcut: $x meta;                 action: [ self remove ] ] ];     yourselfselectionChanged  self changed: #selectionChanged with: #()inspectionSubMenu: arg1  arg1 addGroup: [:arg2 |  arg2 addItem: [:arg3 |  arg3                 name: 'Inspect' translated;                 action: [ self inspectSelectedObjectInNewWindow ];                 shortcut: $i meta ].        arg2 addItem: [:arg3 |  arg3                 name: 'Explore' translated;                 action: [ self exploreSelectedObject ];                 shortcut: $i meta shift ].        self customMenuActions cull: arg1 cull: arg2 ]state: arg1  ^self presenter state: arg1addPaneVSplitters  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := paneMorphs reject: [:arg1 |  arg1 layoutFrame rightFraction = 1 or: [ arg1 layoutFrame rightFraction = 0 ] ].  [ tmp1 notEmpty ] whileTrue: [ tmp2 := tmp1 first layoutFrame rightFraction.        tmp3 := tmp1 select: [:arg1 |  arg1 layoutFrame rightFraction = tmp2 ].        tmp4 := paneMorphs select: [:arg1 |  arg1 layoutFrame leftFraction = tmp2 and: [ arg1 layoutFrame rightFraction ~= tmp2 ] ].        tmp1 := tmp1 copyWithoutAll: (self addPaneVSplitterBetween: tmp3 and: tmp4) ]classToTest  ^SpListPresenterdisplay  ^displayBlockselectedPackage  ^packageList selectedItemwhenSelectedItemChanged: arg1  self dropList whenSelectedItemChanged: arg1properties  ^properties ifNil: [ properties := SmallDictionary new ]testContextKeyBindings  | tmp1 |  tmp1 := presenter contextKeyBindings.  self assert: tmp1 notNil.  self assert: (tmp1 isKindOf: KMCategory)isRowHomogeneous  ^rowHomogeneoustext: arg1  self deprecated: 'This method is an horrible hack because the VersionBrowser was using Code or Diff presenter but was only using the API of the Code presenter... This method and other methods from the CodePresenter API will be removed.'.  (arg1 isText or: [ arg1 isString ]) ifTrue: [ self leftText: ''.        self rightText: arg1 ] ifFalse: [ self leftText: arg1 first.        self rightText: arg1 second ]requestWindowClose  ^trueacceptBlock: arg1  ^self input acceptBlock: arg1whenSelectedItemsChanged: arg1  tree whenSelectedItemsChanged: arg1incomingTransmission: arg1 from: arg2  self action cull: arg1 cull: arg2testAddColumnRaisesOneEventOnly  | tmp1 |  tmp1 := 0.  presenter whenColumnsChangedDo: [ tmp1 := tmp1 + 1 ].  presenter addColumn: (SpStringTableColumn new evaluated: #yourself).  self assert: tmp1 equals: 1resizable  ^self model resizableinitialize  super initialize.  leftText := ''.  rightText := ''.  showOptions := true.  showOnlyDestination := false.  showOnlySource := false.  self property: #leftText whenChangedDo: [:arg1 |  self changed: #leftText: with: {arg1} ].  self property: #rightText whenChangedDo: [:arg1 |  self changed: #rightText: with: {arg1} ].  self property: #contextClass whenChangedDo: [:arg2 |  self changed: #contextClass: with: {arg2} ].  self property: #showOptions whenChangedDo: [:arg3 |  self changed: #showOptions: with: {arg3} ].  self property: #showOnlyDestination whenChangedDo: [:arg3 |  self changed: #showOnlyDestination: with: {arg3} ].  self property: #showOnlySource whenChangedDo: [:arg3 |  self changed: #showOnlySource: with: {arg3} ].  self property: #leftLabel whenChangedDo: [:arg1 |  self changed: #leftLabel: with: {arg1} ].  self property: #rightLabel whenChangedDo: [:arg1 |  self changed: #rightLabel: with: {arg1} ]testSetSelectItemRaisesSelectionChangeEventWithSelectedIndex  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedIndex ].  presenter selectItem: 20.  self assert: tmp1 equals: 2whenMenuChanged: arg1  self deprecated: 'Use #whenMenuChangedDo: instead.' transformWith: '`@receiver whenMenuChanged: `@statements' -> '`@receiver whenMenuChangedDo: `@statements'.  self whenMenuChangedDo: arg1visiblePages: arg1  visiblePages := arg1addFocusRotationKeyBindings  self presenter canTakeKeyboardFocus ifFalse: [ ^self ].  self bindKeyCombination: Character tab asKeyCombination toAction: [ self focusNext ].  self bindKeyCombination: Character tab shift asKeyCombination toAction: [ self focusPrevious ]source  ^sourcecontext: arg1  context := arg1subwidget: arg1 layoutFrame: arg2  subwidget := arg1 isSymbol ifTrue: [ {#presenter .         arg1} ] ifFalse: [ arg1 isCollection ifTrue: [ arg1 isEmpty ifTrue: [  ] ifFalse: [ self flag: #todo.                    (#(#model #presenter) anySatisfy: [:arg3 |  arg1 first = arg3 ]) ifTrue: [ arg1 ] ifFalse: [ {#presenter} , arg1 ] ] ] ifFalse: [ arg1 ] ].  layoutFrame := arg2description: arg1  descriptionBlock := arg1presenters  ^self itemsvisitCommand: arg1  arg1 hasShortcutKey ifFalse: [ ^self ].  self presenter bindKeyCombination: arg1 shortcutKey toAction: [ arg1 canBeExecuted ifTrue: [ arg1 execute ] ]testVisitCommand  | tmp1 tmp2 |  tmp2 := nil.  self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.  (CmBlockCommand new     name: 'c';     description: 'desc';     context: [ 41 ];     block: [:arg1 |  tmp2 := arg1 + 1 ];     yourself) asSpecCommand acceptVisitor: menuBuilder.  self assert: menuBuilder menuPresenter defaultGroup menuItems size equals: 1.  tmp1 := menuBuilder menuPresenter defaultGroup menuItems first.  self assert: tmp1 class equals: SpMenuItemPresenter.  self assert: tmp1 name equals: 'c'.  self assert: tmp1 description equals: 'desc'.  self assert: tmp2 isNil.  tmp1 action value.  self assert: tmp2 equals: 42decreasedValueFrom: arg1  | tmp1 |  tmp1 := arg1 ifEmpty: [ 0 ] ifNotEmpty: [:arg2 |  arg2 asNumber - self model climbRate ].  tmp1 := self inBounds: tmp1.  ^self model isInteger ifTrue: [ tmp1 rounded asString ] ifFalse: [ tmp1 printShowingDecimalPlaces: self model digits ]initializePresenters  packages := self newList display: #name.  classes := self newList display: #name.  protocols := self newList display: [:arg1 |  arg1 value name ].  methods := self newList display: #selector.  code := self newCode.  packages transmitTo: classes transform: [:arg2 |  arg2 definedClasses asArray ].  packages transmitTo: code transform: [:arg2 |  self classTemplateFor: arg2 ].  classes transmitTo: protocols transform: [:arg3 |  arg3 organization allProtocols collect: [:arg4 |  arg3 -> arg4 ] as: OrderedCollection ] postTransmission: [:arg5 :arg6 |  arg5 selectIndex: 1 ].  classes transmitTo: code transform: #definitionWithSlots.  protocols transmitTo: methods transform: [:arg1 |  arg1 value methods collect: [:arg4 |  arg1 key >> arg4 ] as: OrderedCollection ].  protocols transmitTo: code transform: [:arg1 |  arg1 key sourceCodeTemplate ].  methods transmitTo: code transform: #sourceCode.  packages items: RPackageOrganizer default packagesmenu: arg1 shifted: arg2  ^(self model menu: arg1 shifted: arg2) ifNotNil: [:arg3 |  arg3 buildWithSpecAsPopup ]rightFraction  ^0newTreeTable  ^self instantiate: SpTreeTablePresenterselectedItem  self dropList selectedIteminitialize  self class initializeSlots: self.  super initialize.  value := 0addStatusBarTo: arg1  | tmp1 |  tmp1 := self model statusBar buildWithSpec.  arg1 addMorphBack: tmp1.  tmp1     hResizing: #spaceFill;     vResizing: #rigidresult: arg1  result := arg1iconNamed: arg1  ^self class iconNamed: arg1setUp  super setUp.  presenter := self classToTest new.  self initializeTestedInstanceresetContent  self owner updatePageContent: selfselectInto: arg1 paths: arg2  | tmp1 tmp2 |  tmp2 := arg2 collect: [:arg3 |  | tmp3 |        tmp3 := arg1 dataSource itemAtPath: arg3 expanding: true.        tmp3 ifNil: [ arg1 selectIndex: 0.              ^self ].        tmp3 ].  arg1 refresh.  tmp1 := tmp2 collect: [:arg4 |  arg1 dataSource indexOfItem: arg4 ].  arg1 selectIndexes: tmp1setUp  super setUp.  label1 := Morph new.  morph1 := Morph new.  label2 := Morph new.  morph2 := Morph new.  panel := Morph new     extent: 100 @ 100;     yourself.  {label1 .   morph1 .   label2 .   morph2} do: [:arg1 |  panel addMorphBack: arg1.        self style applyTo: arg1 ]columnInset: arg1  tree columnInset: arg1surface  ^surface ifNil: [ surface := AthensCairoSurface extent: self extent ]type: arg1  type := arg1isStyleClassChar: arg1  ^arg1 = $.isSortable  ^self sortFunction notNilbuildWidget  ^SpTreeColumn new     resizable: self resizable;     startWidth: self initialWidth;     setHeaderButtonLabel: self headerLabel font: self headerFont icon: self headerIcon target: self actionSelector: self performHeaderActionSelector;     rowMorphGetSelector: self displayBlockclassToTest  ^SpOpenOnNilExampletestSetSelectItemOutsideRangeRaisesSelectionChangeEventWithUnsetIndex  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedIndex ].  presenter selectItem: 40.  self assert: tmp1 equals: 0execute  self browserClientProvider browseMethodsWithSourceString: self selection matchCase: falsebottomOffset  ^bottomOffsetelements  ^self list itemsasPresenter  ^selftestUseBackend  self assert: application backend name equals: #Mock.  application useBackend: #Morphic.  self assert: application backend name equals: #MorphictestUnselectUnselectedItemKeepsSelectionList  presenter     selectItem: 10;     unselectItem: 20.  self assert: presenter selection selectedItems asArray equals: #(10)applicationName  ^applicationName ifNil: [ applicationName := self argumentAt: 1 ]applyVisibility  self presenter ifNil: [ ^self ].  self widget visible: self presenter isVisible.  self presenter whenVisibleChangedDo: [:arg1 |  self presenter isVisible ifTrue: [ self widget show ] ifFalse: [ self widget hide ] ]findChangeSetIn: arg1  | tmp1 tmp2 tmp3 tmp4 |  self okToChange ifFalse: [ ^self ].  tmp2 := UIManager default request: 'ChangeSet name or fragment?'.  tmp2 isEmptyOrNil ifTrue: [ ^self ].  tmp4 := arg1 collect: #name.  tmp3 := arg1 select: [:arg2 |  (tmp4 includes: arg2 name) and: [ arg2 name includesSubstring: tmp2 caseSensitive: false ] ].  tmp3 size = 0 ifTrue: [ ^self inform: 'No matching change sets.' ].  tmp3 size = 1 ifTrue: [ ^tmp3 first ].  tmp1 := UIManager default chooseFrom: (tmp3 collect: [:arg3 |  arg3 name ]).  tmp1 = 0 ifFalse: [ ^tmp3 at: tmp1 ]testShowColumnHeadersShowHeaders  presenter showColumnHeaders.  self assert: presenter isShowingColumnHeadersopenModalWithSpec  self layout ifNil: [ ^super openWithSpec ].  ^self application openModal: self withSpecLayout: self layoutclearItems  leftPanel removeAllMorphs.  rightPanel removeAllMorphsuseProportionalLayout  self subclassResponsibilitychildren  ^self rows collect: [:arg1 |  | tmp1 |        tmp1 := arg1 submorphs first.        tmp1 submorphs first ]add: arg1 height: arg2  self add: arg1 origin: 0 @ 0 corner: 1 @ 1 offsetOrigin: 0 @ 0 offsetCorner: 0 @ arg2model  ^modelclassToTest  ^SpListPresenterbuildChildren  contents := self children value collect: [:arg1 |  | tmp1 |        tmp1 := (arg1 isKindOf: SpTreeNodePresenter) ifTrue: [ arg1 ] ifFalse: [ (self childNodeClassFor: arg1) new content: arg1 ].        tmp1           parentNode: self;           yourself ].  ^contentsparseAST: arg1  | tmp1 |  tmp1 := RBParser parseFaultyMethod: arg1.  tmp1 isParseError ifFalse: [ ^tmp1 ].  ^RBParser parseFaultyExpression: arg1childrenItems  ^self model autoRefreshOnExpand ifTrue: [ childrenItemsBlock value ] ifFalse: [ childrenItems ifNil: [ childrenItems := childrenItemsBlock value ] ]title  ^'OpenOnIntExample'icon: arg1  icon := arg1leftFraction: arg1  leftFraction := arg1classToTest  ^SpTreeTablePresentershouldAccept: arg1  | tmp1 tmp2 |  arg1 ifEmpty: [ ^true ].  tmp1 := self model isInteger ifTrue: [ '(\-)?[0-9]*' ] ifFalse: [ '(\-)?[0-9]+(\.[0-9]{0,' , self model digits asString , '})?' ].  (tmp1 asRegex matches: arg1) ifFalse: [ ^false ].  tmp2 := arg1 asNumber.  self model minimum ifNotNil: [:arg2 |  tmp2 < arg2 ifTrue: [ ^false ] ].  self model maximum ifNotNil: [:arg3 |  tmp2 > arg3 ifTrue: [ ^false ] ].  ^trueupdateItems: arg1  arg1 clearItems.  self presenter leftItems do: [:arg2 |  arg1 addItem: (self configureItem: arg2 morph: arg2 buildWithSpec toolBar: arg1) position: SpToolBarItemPosition left ].  self presenter rightItems do: [:arg2 |  arg1 addItem: (self configureItem: arg2 morph: arg2 buildWithSpec toolBar: arg1) position: SpToolBarItemPosition right ]font: arg1  self widgetDo: [:arg2 |  arg2 font: arg1 ]testOpenDialogWindowWithDifferentApplicationDoesNotAddItToWindowCollection  | tmp1 tmp2 tmp3 |  tmp1 := SpApplication new.  tmp2 := tmp1 newPresenter: SpButtonPresenter.  tmp3 := application windows copy.  self should: [ application openDialog: tmp2 ] raise: SpInvalidApplicationError.  self assert: application windows equals: tmp3initialize  super initialize.  childrenBlockHolder := [ {} ] asValueHolder.  hasChildrenBlockHolder := [:arg1 |  (self childrenFor: arg1) notEmpty ] asValueHolder.  rootsHolder := {} asValueHolder.  selectionHolder := {} asValueHolder.  menuBlockHolder := [  ] asValueHolder.  displayBlock := [:arg1 |  arg1 asString ] asValueHolder.  removeOnlyLastSelected := false asValueHolder.  autoDeselection := true asValueHolder.  autoMultiSelection := false asValueHolder.  columnInset := 5 asValueHolder.  doubleClick := [  ] asValueHolder.  allowMenuOnNoItem := false asValueHolder.  isCheckList := false asValueHolder.  keyStroke := [:arg2 |   ] asValueHolder.  multiSelection := false asValueHolder.  evenRowColor := self theme backgroundColor asValueHolder.  oddRowColor := self theme backgroundColor asValueHolder.  preferedPaneColor := self theme backgroundColor asValueHolder.  resizerWidth := 2 asValueHolder.  rowInset := 2 asValueHolder.  iconBlock := [:arg3 :arg4 |  arg4 icon ] asValueHolder.  highlightedItem := nil asValueHolder.  rootNodeHolder := [:arg1 |  SpTreeNodePresenter new     content: arg1;     children: [ self childrenFor: arg1 ] ] asValueHolder.  columns := {(SpTreeColumnPresenter new displayBlock: [:arg4 |  self wrapItem: arg4 content ])} asValueHolder.  autoRefreshOnExpand := false asValueHolder.  self dragTransformationBlock: [:arg1 :arg5 |  arg1 complexContents ].  treeUpdated := nil asValueHolder.  self registerEventswhenShowColumnHeadersChangedDo: arg1  self property: #showColumnHeaders whenChangedDo: arg1refresh  self items: self itemsisVertical  ^self isHorizontal notwhenBorderColorChangedDo: arg1  self property: #borderColor whenChangedDo: arg1openDialog: arg1  ^self openDialog: arg1 withSpecLayout: arg1 defaultSpecinitialize  super initialize.  self position: 50 percentcontentAreaPresenter  ^contentAreaPresenterisComposite  ^falsewhenIconsChangedDo: arg1  self property: #icon whenChangedDo: arg1ghostText: arg1  self deprecated: 'This API is too tight to Morph. Use #placeholder: instead.' transformWith: '`@receiver ghostText: `@statement' -> '`@receiver placeholder: `@statement'.  self placeholder: arg1initialize  super initialize.  selected := falsewhenSelectedIndexChangedDo: arg1  self whenSelectionChangedDo: [:arg2 |  arg1 cull: arg2 first ]date: arg1  date := arg1placeholder: arg1  ^self input placeholder: arg1add: arg1 height: arg2  self add: arg1 withConstraints: [:arg3 |  arg3 height: arg2 ]itemBeginsWithFilter  self deprecated: 'Use #enableItemBeginsWithFilter instead' transformWith: '`@receiver itemBeginsWithFilter' -> '`@receiver enableItemBeginsWithFilter'.  self enableItemBeginsWithFilternotifyPropertyChanged: arg1  self flag: #todo.  (self observablePropertyNamed: arg1) valueChangedinitializeTestedInstance  presenter startWithoutSelection.  super initializeTestedInstancewhenActivatedDo: arg1  self subclassResponsibilityabstractAdapterClass  ^self subclassResponsibilitysetUp  super setUp.  presenter := SpListPresenter new.  presenter items: (1 to: 10)getList  ^self model getListtestLabelChangeRaisesEventOnce  self assertWith: [:arg1 |  arg1 = 1 ] timesRaisedEvent: #whenChangedDo: inPresenter: presenter whenDoing: [ presenter label: 'test' ]padding  ^self layout borderWidthsetIndex: arg1  ^self dropList setIndex: arg1baseLines  | tmp1 |  tmp1 := self configurationClass methods select: [:arg1 |  arg1 selector beginsWith: 'baseline' ].  tmp1 := (tmp1 collect: [:arg2 |  arg2 pragmas first argumentAt: 1 ]) asSortedCollection.  ^tmp1lastClicked  ^lastClicked valueresultPane  ^resultPaneshowSubMenuIfPresent  self model contextMenu ifNil: [ ^self ].  self showSubMenu: self model contextMenulinkRadioButton: arg1  buttons do: [:arg2 |  arg1 whenActivatedDo: [ arg2 privateSetState: false ].        arg2 whenActivatedDo: [ arg1 privateSetState: false ] ].  arg1 whenActivatedDo: [ self currentActivated: arg1 ]initialize  super initializeconnectPresenters  withText whenValueChangedDo: [:arg1 |  label label: (arg1 * 100) asInteger asString , '%' ]buildWidget  ^SpStubTableContainerView newvalue: arg1  lock ifTrue: [ ^self ].  lock := true.  [ | tmp1 |  tmp1 := value.  value := arg1.  self valueChanged: tmp1 ] ensure: [ lock := false ]execute  | tmp1 |  tmp1 := self findClassOn: self selectionOrLine trimmed.  tmp1 ifNil: [ ^self ].  self browseClass: tmp1display: arg1  list display: arg1setWidgetLayoutWithOffset: arg1 at: arg2  | tmp1 tmp2 |  width := arg1 offsets width.  tmp1 := arg1 offsets top.  tmp2 := arg1 offsets bottom.  arg2 = size ifTrue: [ arg1 layoutFrame: ((1 @ 0 corner: 1 @ 1) asSpLayoutFrame                 topLeftOffset: width negated @ tmp1;                 bottomRightOffset: 0 @ tmp2) ] ifFalse: [ arg1 layoutFrame: ((currentProportional @ 0 corner: currentProportional @ 1) asSpLayoutFrame                 topLeftOffset: currentOffset @ tmp1;                 bottomRightOffset: (currentOffset + width) @ tmp2).        currentOffset := currentOffset + width ]testAddTabSetOwner  self assert: redTab owner isNil.  presenter addTab: redTab.  self assert: redTab owner equals: presenternumColumns  ^numColumnsselectedItems  ^self selection selectedItemsaddKeyBindingsTo: arg1  whenClimbRateChangedDo: arg1  self property: #climbRate whenChangedDo: arg1buildWidget  ^SpStubPanedView newtestSelectMultipleItemsRaisesSelectionChangeEventMultipleTimes  | tmp1 |  tmp1 := 0.  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter selectItem: 10.  presenter selectItem: 30.  self assert: tmp1 equals: 2geometryValueBetween: arg1 and: arg2  ^arg1 = 0 ifTrue: [ arg2 ] ifFalse: [ arg1 ]testAbsoluteValue  self initMinMax.  presenter absoluteValue: 0.5.  self assert: presenter value == 50title: arg1  title := arg1updateTitle  self flag: #TODO.  self withWindowDo: #updateTitleisSelected  ^selectedtestLabelIsUrlByDefault  self assert: presenter label isNil.  presenter url: 'Test'.  self assert: presenter label equals: 'Test'.  presenter label: 'Label'.  self assert: presenter label equals: 'Label'morph: arg1  widget := arg1selectedItem  ^self selection selectedItem ifNotNil: #modelfootnoteIcon: arg1  footnoteIcon := arg1customSubMenu: arg1  customMenuActions  ^[:arg1 :arg2 |  arg2 addItem: [:arg3 |  arg3           name: 'Dive Into' translated;           action: [ self diveIntoSelectedObject ];           shortcut: $d meta ].  (history hasPrevious or: [ history hasNext ]) ifTrue: [ arg1 addGroup: [:arg4 |  history hasPrevious ifTrue: [ arg4 addItem: [:arg3 |  arg3                             name: 'Back' translated;                             action: [ self inspectPrevious ];                             shortcut: $[ meta ] ].              history hasNext ifTrue: [ arg4 addItem: [:arg3 |  arg3                             name: 'Forward' translated;                             action: [ self inspectNext ];                             shortcut: $] meta ] ] ] ] ]classToTest  ^SpNotebookPresenternextButton  ^nextButtonclassRenamed: arg1  UIManager default defer: [ self handleClassRenamed: arg1 ]setTargetBounds  self subclassResponsibilitywhenVisiblePagesChangedDo: arg1  self property: #visiblePages whenChangedDo: arg1testInstanceCreation  | tmp1 tmp2 |  tmp1 := 40 @ 54.  tmp2 := SpTestingPresenterWithModel on: tmp1.  self assert: tmp2 model equals: tmp1.  self deny: (tmp1 dependents includes: tmp2)classToTest  ^SpListSelectionPresenterasSpecElements  ^{self selector} , self argumentsobservablePropertyNamed: arg1  | tmp1 |  tmp1 := self class slotNamed: arg1.  tmp1 isObservableSlot ifFalse: [ SpNonObservableSlotError signal: arg1 ].  ^tmp1 rawRead: selftestSelectIndexTwiceMakesIndexSelected  presenter     selectIndex: 3;     selectIndex: 3.  self assert: (presenter selection includesIndex: 3)openModalWithSpecLayout: arg1  ^self application openModal: self withSpecLayout: arg1basicInspector: arg1  inspector ifNotNil: [:arg2 |  arg2 owner: nil ].  inspector := arg1.  arg1     owner: self;     ownerChangedcolumnInset  ^columnInset valuevalue: arg1  value := arg1labelOnRight  ^self changed: #labelOnRight with: #()endSubMenu: arg1  arg1 addGroup: [:arg2 |  arg2 addItem: [:arg3 |  arg3                 name: 'Copy Name';                 action: [ self copyAccessorCode ];                 shortcut: $c meta ] ]checkboxNormal: arg1  checkboxNormal := arg1useTreeInspector  self inspectorType: EyeTreeInspectorisCancelled  ^cancelledrefresh  self shouldBeImplementeddefaultSpec  ^self class perform: self defaultSpecSelectoruseBackend: arg1 with: arg2  self useBackend: arg1.  configuration := arg2.  arg2 configure: selfactionPerformed  actionPerformed := self textinitializePresenters  super initializePresenters.  self content: SpDropListPresentertestSelectWidgetIndexRaisesSelectionIndexChangeEventOnce  | tmp1 |  tmp1 := 0.  presenter selection whenChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  self adapter selectPath: #(1).  self assert: tmp1 equals: 1color  ^colorisPartialMatch  | tmp1 |  tmp1 := false.  self children value do: [:arg1 |  (arg1 selected or: [ arg1 isPartialMatch ]) ifTrue: [ tmp1 := true ] ].  ^tmp1doItReceiver  self deprecated: 'This has been moved to specific presenters (check children)' on: '2019-04-15' in: #Pharo8resizingStringFor: arg1  ^arg1 ifTrue: [ #spaceFill ] ifFalse: [ #rigid ]traverseInFocusOrderDo: arg1 excluding: arg2  self presentersInFocusOrder do: [:arg3 |  arg3 traverseInFocusOrderDo: arg1 excluding: arg2 ]notifyPropertyChanged: arg1  self flag: #todo.  (self observablePropertyNamed: arg1) valueChangedtestEmptyPresenterHasEmptyAdapter  backendForTest waitUntilUIRedrawed.  self assertEmpty: self adapter childreninitializePresenter  inspectorChoice whenSelectedItemChanged: [:arg1 |  self preventUpdatesDuring: [ self inspectorType: arg1 ] ]setChildren: arg1  self childrenItemsBlock: arg1widget: arg1  widget := arg1theme: arg1  theme := arg1testWhenWillCloseDo  | tmp1 tmp2 |  tmp1 := false.  tmp2 := false.  presenter whenWillCloseDo: [ tmp1 := true ].  presenter whenClosedDo: [ tmp2 := tmp1 ].  self openInstance.  presenter close.  self assert: tmp1.  self assert: tmp2removeClass  (self model removeClass: self selectedClass) ifTrue: [ self setSelectedChangeSet: self selectedChangeSet ]rebuildWithSpecLayout: arg1  self changed: #rebuildWithSpecLayout: with: {arg1}cancel  self cancelled: truehostClass  ^host classcommands  ^commandsasSpecCommand  | tmp1 |  tmp1 := super asSpecCommand.  self shortcutKey ifNotNil: [:arg1 |  tmp1 shortcutKey: arg1 ].  self defaultIconName ifNotNil: [:arg2 |  tmp1 iconName: arg2 ].  ^tmp1subtractFrom: arg1 to: arg2  arg1 forgetAllChangesFoundIn: arg2canChangeText  ^self widget textArea canChangeTextlayout  ^layoutmenu  ^menuinitialPosition  ^initialPositionlistModel  ^listModelcomputeColumnPositions  columnPositions := Array new: numColumns.  columnPositions at: 1 put: 0.  2 to: numColumns do: [:arg1 |  columnPositions at: arg1 put: (columnPositions at: arg1 - 1) + (columnWidths at: arg1 - 1) + self layout columnSpacing ]widget  ^self adapter widgettestShouldAcceptNegativeFloat  presenter     beFloat;     maximum: 120;     digits: 3;     minimum: -150.  self assert: (adapter shouldAccept: '-100.1').  self deny: (adapter shouldAccept: '-200.1')initializeTestedInstance  presenter     beSingleSelection;     addColumn: (SpStringTableColumn title: 'Test' evaluated: #asString);     roots: #(10 20 30)inspect: arg1  | tmp1 |  tmp1 := self inspectorType.  self     inspector: (EyeInspector inspector: arg1);     inspectorType: tmp1textConverter  ^textConverterpageClass  self subclassResponsibilitymax  ^self presenter maxisEmpty  ^selection isEmptybuildWidget  ^PanelMorph new     changeProportionalLayout;     vResizing: #spaceFill;     hResizing: #spaceFill;     yourselferrorSubMenu: arg1  self hasError ifFalse: [ ^self ].  arg1 addGroup: [:arg2 |  self withErrorsDo: [:arg3 :arg4 |  arg2 addItem: [:arg5 |  arg5                       name: 'Debug Accessing ' , arg4 printString , ' of ' , self accessorCode;                       icon: (self iconNamed: #smallWarningIcon);                       action: [ [ self perform: arg4 ] fork ] ] ] ]sendersModel  ^sendersModelnewSimpleButtonMorph: arg1 color: arg2  ^SimpleButtonMorph new     label: arg1;     color: arg2;     target: [ self inform: 'Test' ];     actionSelector: #value;     helpText: 'Button at ' , arg1 asString;     yourselfsaveBlock: arg1  saveBlock := arg1label: arg1  label label: arg1getSelectionStateFor: arg1  self deprecated: 'This method from the old API will be removed.' transformWith: '`@receiver getSelectionStateFor: `@statements' -> '`@receiver selection selectedIndexes includes: `@statements'.  ^self selection selectedIndexes includes: arg1selectMessage: arg1  listModel selectItem: arg1extent  ^self columnWidths sum @ self rowHeights sumtestWhenMinimumChangedDo  | tmp1 tmp2 |  tmp1 := 0.  presenter whenMinimumChangedDo: [:arg1 |  tmp1 := tmp1 + 1.        tmp2 := arg1 ].  presenter minimum: 10.  self assert: tmp1 equals: 1.  self assert: tmp2 equals: 10initialize  super initialize.  displayBlock := #yourself.  icon := [:arg1 |  nil ].  handlesDoubleClick := falsemethodShortcuts: arg1 from: arg2  self selectedSelector ifNotNil: [ arg1 keyString = '<Cmd-b>' ifTrue: [ ^self browseMethodFull ].        arg1 keyString = '<Cmd-d>' ifTrue: [ ^self forgetMessage ].        arg1 keyString = '<Cmd-m>' ifTrue: [ ^self browseImplementorsOfMessages ].        arg1 keyString = '<Cmd-n>' ifTrue: [ ^self browseSendersOfMessages ].        arg1 keyString = '<Cmd-v>' ifTrue: [ ^self browseVersions ].        arg1 keyString = '<Cmd-x>' ifTrue: [ ^self removeMessage ] ]recalculatePages: arg1  ^arg1 recalculatePageWidthspreservePositionProportionOn: arg1  | tmp1 |  tmp1 := arg1 submorphs first.  position := self isHorizontal ifTrue: [ (tmp1 width * 100 / arg1 width) asInteger percent ] ifFalse: [ (tmp1 height * 100 / arg1 height) asInteger percent ]addMenuTo: arg1  | tmp1 |  tmp1 := self model menu buildWithSpec.  arg1 addMorphBack: tmp1.  tmp1     hResizing: #spaceFill;     vResizing: #rigidconnectPresenters  selectEntity action: [ | tmp1 |        tmp1 := self selectDialog value.        tmp1 openDialogWithSpec okAction: [ self entity: tmp1 selectedItem ] ]labelMorph: arg1  labelMorph := arg1enabled  self deprecated: 'Please use #isEnabled instead' transformWith: '`@receiver enabled' -> '`@receiver isEnabled'.  ^self isEnabledtestHidePresenterHidesWidget  self skipsecondButton  ^secondButtonapplyStyle: arg1 to: arg2  self flag: #TODO.  arg1 adapter ifNil: [ ^self ].  arg1 adapter applyStyle: arg2position: arg1  position := arg1findClassFrom: arg1  | tmp1 |  tmp1 := RBParser parseExpression: arg1 onError: [ ^nil ].  tmp1 nodesDo: [:arg2 |  (arg2 isVariable and: [ arg2 name first isUppercase ]) ifTrue: [ (self class environment classNamed: arg2 name) ifNotNil: [:arg3 |  ^arg3 ] ] ].  ^nilautoScale: arg1  autoScale := arg1display  ^displayBlockenableSearch  searchEnabled := truehasNoOffsets  ^leftOffset = 0 and: [ rightOffset = 0 and: [ topOffset = 0 and: [ bottomOffset = 0 ] ] ]acceptBlock: arg1  actionToPerform := arg1whenContentChanged: arg1  self deprecated: 'Use #whenContentChangedDo: instead.' transformWith: '`@receiver whenContentChanged: `@statements' -> '`@receiver whenContentChangedDo: `@statements'.  self whenContentChangedDo: arg1whenSelectionIndexChanged: arg1  self dropList whenSelectionIndexChanged: arg1wrapItem: arg1  ^displayBlock value cull: arg1 cull: selfmethod1  testSelectItemsThenSelectOutsideRangeKeepsIndexes  presenter selectItems: {10 .         20}.  presenter selectItems: {500 .         600}.  self assert: (presenter selection includesIndexes: {1 .               2})open  self model windowIsOpening.  backdropMorph := FullscreenMorph new     color: self theme modalBackdropColor;     on: #click send: #mouseClick:onBackdrop: to: self;     openInWorld;     yourself.  self widget     toggleStickiness;     openCenteredInWorld.  [ self widget world notNil ] whileTrue: [ self widget outermostWorldMorph doOneCycle ]defer: arg1  self backend defer: arg1edgeName  ^self subclassResponsibilitywindow: arg1  window := arg1initializeShortcuts  font  ^self lookupProperty: SpStyleFont valueOf: #definedFonttakeKeyboardFocus  self withAdapterDo: [:arg1 |  arg1 takeKeyboardFocus ]initializeTestedInstance  presenterAt: arg1 put: arg2  ^self basicPresenters at: arg1 put: arg2selectedIndex  ^self getIndexlistPresenter  ^listPresentercomputeLayoutFromTop: arg1 bottom: arg2 left: arg3 right: arg4  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp7 := arg3 isFloat ifTrue: [ arg3 ] ifFalse: [ 0 ].  tmp1 := arg1 isFloat ifTrue: [ arg1 ] ifFalse: [ 0 ].  tmp3 := arg4 isFloat ifTrue: [ 1 - arg4 ] ifFalse: [ 1 ].  tmp6 := arg2 isFloat ifTrue: [ 1 - arg2 ] ifFalse: [ 1 ].  tmp8 := arg3 isInteger ifTrue: [ arg3 ] ifFalse: [ 0 ].  tmp4 := arg1 isInteger ifTrue: [ arg1 ] ifFalse: [ 0 ].  tmp2 := arg4 isInteger ifTrue: [ arg4 negated ] ifFalse: [ 0 ].  tmp5 := arg2 isInteger ifTrue: [ arg2 negated ] ifFalse: [ 0 ].  ^{(tmp7 @ tmp1) .   (tmp3 @ tmp6) .   (tmp8 @ tmp4) .   (tmp2 @ tmp5)}attachTransmission: arg1  self subclassResponsibilitybottomOffset: arg1  bottomOffset := arg1computeMorphs: arg1 bounds: arg2  morphs := arg1.  bounds := arg2.  self computeNumberOfRowsAndColumns.  self computeWidgetSizes.  self computeRowPositions.  self computeColumnPositions.  self computeCellExtentsitems  ^collectionhRigid  scaleInput: arg1  scaleInput := arg1testChangeWidgetTextUpdatesPresenter  self adapter text: 'some text'.  self assert: presenter text equals: 'some text'instVarToModelObject  ^instVarToModelObjectactualPageMorph  ^actualPageMorph ifNil: [ actualPageMorph := self lazyPageMorphCreation value           hResizing: #spaceFill;           vResizing: #spaceFill;           yourself ]buildWidget  ^SpStubTabView newaddButton: arg1  buttons add: arg1.  ^arg1menuGroups  ^groupstestSelectItemThenSelectOutsideRangeKeepsFirstPath  presenter selectItem: 10.  presenter selectItem: 5000.  self assertCollection: presenter selection selectedPaths hasSameElements: #(#(1 3))rightText  ^self model rightTextsubwidget  ^subwidgetselectedItem: arg1  self selectedItems: {arg1}table: arg1  table := arg1buildWidget  ^SpStubCheckBoxView newbuildWidget  ^nilrowHomogeneous: arg1  rowHomogeneous := arg1testFiltering  presenter items: {'aa' .         'bb' .         'ab' .         'ba'}.  presenter searchPresenter text: 'a'.  self assertCollection: presenter listPresenter items hasSameElements: {'aa' .         'ab'}padding  ^padding ifNil: [ self class defaultPadding ]