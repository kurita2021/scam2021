setLayoutSizing  self     hResizing: #rigid;     vResizing: #spaceFillapplyStyleTo: aString  ^self withAdapterDo: [:anAdapter |  anAdapter applyStyleTo: aString ]accept: aText notifying: aNotifyier  super accept: aText asString notifying: aNotifyierclassToTest  ^SpToolBarPresenterinspectorTypes  ^self inspector variantsgetImage  ^self model imageresetSelection  listPresenter resetSelectionnotifyPropertyChanged: aName  self flag: #todo.  (self observablePropertyNamed: aName) valueChangedselectFileTitle: aString  ^UIManager default chooseExistingFileReference: aString extensions: nil path: ''title: aString  titleHolder := aStringregisterEvents  super registerEvents.  self property: #handlesDoubleClick whenChangedDo: [:bool |  self changed: {#handlesDoubleClick .               bool} ]spacing  ^layout spacingmin: aNumber  slider min: aNumber.  input text: aNumber asStringselectAll  self widgetDo: [:w |  w selectAll ]id: anObject  id := anObjecttestBorderWidthHomogeneous  | layout |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1.  self place: label2 at: 1 @ 2.  self place: morph2 at: 2 @ 2.  (layout := self newLayout) layout     beColumnHomogeneous;     beRowHomogeneous;     borderWidth: 5.  layout layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (5 @ 5 corner: 50 @ 50).  self assert: morph1 bounds equals: (50 @ 5 corner: 95 @ 50).  self assert: label2 bounds equals: (5 @ 50 corner: 50 @ 95).  self assert: morph2 bounds equals: (50 @ 50 corner: 95 @ 95)buttons  ^buttonsaddPresenterIn: container withSpecLayout: aSpec  self presenter ifNil: [ ^self ].  widget := self presenter buildWithSpecLayout: aSpec.  container addMorph: widget fullFrame: LayoutFrame identityinitialize  super initialize.  action := [  ].  state := false.  askBeforeChanging := false.  self whenFontChangedDo: [ self changed: #font ].  self whenStateChangedDo: [ self changed: #state ].  self whenMenuChangedDo: [ self withAdapterDo: #updateMenu ].  self property: #askBeforeChanging whenChangedDo: [:newValue |  self changed: {#askBeforeChanging: .               newValue} ].  self property: #shortcut whenChangedDo: [:newShortcut :oldShortcut |  self unregisterShortcut: oldShortcut.        self registerShortcut: newShortcut.        self changed: #label ].  self color: nilcontextMenu  ^contextMenuwhenSearchChangedDo: aBlock  self property: #searchEnabled whenChangedDo: aBlockinitializePresenters  previousMonthButton := self newButton.  previousMonthButton label: '<'.  nextMonthButton := self newButton.  nextMonthButton label: '>'.  monthYearLabel := self newLabel.  monthYearLabel label: '-'.  namesOfDaysLabels := self newNullPresenter.  daysButtons := self newNullPresentercalculateNotHomogeneousRowHeights  | newRowHeights |  newRowHeights := Array new: numRows withAll: 0.  morphs do: [:each |  | row |        row := (each valueOfProperty: #gridConstraints) row.        newRowHeights at: row put: ((newRowHeights at: row) max: each height) ].  ^newRowHeightsinitializePresenters  packageList := self newList.  classList := self newList.  methodList := self newList.  radioButtonClassSide := self newRadioButton.  radioButtonInstanceSide := self newRadioButton.  protocolList := self newList.  packageList     items: RPackageOrganizer default packages;     display: #name;     sortingBlock: #name ascending;     icons: [:item |  self iconNamed: #package ].  classList     sortingBlock: #name ascending;     icons: [:item |  self iconNamed: item systemIconName ].  protocolList     display: #name;     sortingBlock: #name ascending.  methodList     sortingBlock: #name ascending;     display: #selector.  radioButtonClassSide label: 'class side'.  radioButtonInstanceSide     label: 'instance side';     state: true.  radioButtonInstanceSide associatedRadioButtons: {radioButtonClassSide}.  self focusOrder     add: packageList;     add: classList;     add: methodListcontainer  ^self model containerhShrinkWrap  newBadgeFont  | baseBadgeFont |  baseBadgeFont := StandardFonts codeFont.  ^(LogicalFont familyName: baseBadgeFont familyName pointSize: baseBadgeFont pointSize - 3) weightValue: 700classToTest  ^SpPickListPresenterisCheckList: aBoolean  tree isCheckList: aBooleanbuildWidget  ^SpStubButtonView newdropList  ^self inputTextDropList dropListrightClicked  self subclassResponsibilitybeResizable  resize := trueinitialize: anInteger  text label: anInteger asStringwhenHighlightedItemChanged: aBlock  self deprecated: 'Use #whenHighlightedItemChangedDo: instead.' transformWith: '`@receiver whenHighlightedItemChanged: `@statements' -> '`@receiver whenHighlightedItemChangedDo: `@statements'.  self whenHighlightedItemChangedDo: aBlockacceptColumnVisitor: aBuilder  ^self subclassResponsibilityfirstIcon: firstIconName secondIcon: secondIconName  self firstButton icon: (self iconNamed: firstIconName).  self secondButton icon: (self iconNamed: secondIconName)buildCodeMenu  ^self codeCommandGroup asMenuPresenterborderWidth  ^self lookupProperty: SpStyleContainer valueOf: #borderWidthbeforeAssertInTest: aSpecTest  aSpecTest openInstancetransmission  self subclassResponsibilitydo: aBlock  self toPort: (SpActionPort newAction: aBlock)keepScrollPositionOf: specHolder during: aBlock  | scrollValue |  specHolder adapter ifNil: [ ^aBlock value ].  scrollValue := description scrollValue.  aBlock value.  description scrollValue: scrollValueselectedIndex  ^listPresenter selectedIndexnotifyPropertyChanged: aName  self flag: #todo.  (self observablePropertyNamed: aName) valueChangedclickItem: anInteger  self selectIndex: anIntegerheaderIcon  ^self model headerIconextent: aPoint  ^extent := aPointexecute  self evaluateSelectionAndDo: [:result |   ]whenMenuChangedDo: aBlock  self property: #contextMenu whenChangedDo: aBlockwidget  ^self adapter widgettestSortingBlock  | count |  count := 0.  presenter whenSortingBlockChangedDo: [:sortFunction |  count := count + 1 ].  presenter items: #(3 8 1 0).  presenter sortingBlock: [:each |  each label asNumber ] ascending.  self assert: count equals: 1.  self assert: (presenter model at: 1) label equals: '0'layoutPresenters  layout ifNil: [ ^self presenters ].  ^layout deepPresenters select: [:each |  each isSymbol ] thenCollect: [:each |  self presenterAt: each ]whenUrlChangedDo: aBlock  self property: #url whenChangedDo: aBlockaddSpecialFields: elements  elements add: (DynamicEyeElement host: self object label: 'hex bytes' description: [ self objectAsHexBytes ] value: [ self object ]).  elements add: (DynamicEyeElement host: self object label: 'hex string' value: [ self objectAsHexString ]).  elements add: (DynamicEyeElement host: self object label: 'latin-1 string' value: [ self objectAsLatin1String ]).  elements add: (DynamicEyeElement host: self object label: 'utf-8 string' value: [ [ self objectAsUTF8String ] on: ZnInvalidUTF8 do: [:exception |  exception asString ] ])inputField  ^inputFieldinitialize  super initialize.  treeModel := SpTreeModel model: self.  treeModel announcer when: MorphTreeSelectionChanged send: #onMorphTreeSelectionChanged: to: selfclassTemplateFor: aPackage  ^'Object subclass: #NameOfSubclass	slots: {}	classVariables: {}	package: ''' , aPackage name , ''' 'childrenItemsBlock: aBlock  childrenItemsBlock := aBlockwhenSelectedItemChanged: aBlock  self dropList whenSelectedItemChanged: aBlockclearText  self widgetDo: [:w |  w setTextWith: '' ]setIndex: anIndex  self deprecated: 'Use #selectIndex: instead' transformWith: '`@receiver setIndex: `@arg' -> '`@receiver selectIndex: `@arg'.  self selectIndex: anIndexbaseColumnWidth  ^(bounds width / numColumns) asIntegernewColumn: aBlock origin: originPoint corner: cornerPoint  self newColumn: aBlock origin: originPoint corner: cornerPoint offsetOrigin: 0 @ 0 offsetCorner: 0 @ 0transferBlock  ^self model transferBlockenabled  | enabled |  enabled := self model isEnabled.  ^(enabled isBlock or: [ enabled isMessageSend ]) ifTrue: [ enabled cull: self model ] ifFalse: [ enabled ]addShortcutTipFor: aCharacter on: aString  | index text |  self flag: #REMOVE.  aString ifNil: [ ^nil ].  text := aString asText.  aCharacter ifNil: [ ^text ].  index := aString asLowercase indexOf: aCharacter asLowercase.  index isZero ifTrue: [ ^text ].  ^text     addAttribute: TextEmphasis underlined from: index to: index;     yourselfselector: aSymbol  selector := aSymboladapt: aPresenter  super adapt: aPresenter.  widget on: #click send: #click to: selfdestinationPresenter  ^delegation ifNotNil: [ delegation value ] ifNil: [ presenter ]execute  self browserClientProvider browseAllReferencesTo: self selectorinput  ^self inputTextDropList inputtestAddLabelledButtonAddTheButton  presenter addItem: (SpToolBarButton new           label: 'a label';           iconNamed: #abstract;           action: [  ];           yourself).  self assert: (self adapter hasButtonWithLabel: 'a label').  self assert: self adapter numberOfItems equals: 1selectedClassOrMetaClass  ^self behaviorwhenHighlightedItemChangedDo: aBlock  highlightedItem whenChangedDo: aBlockbuildWidgetWith: aTabPresenter  ^TabMorph new     model: aTabPresenter;     label: aTabPresenter label;     icon: aTabPresenter icon;     retrievingBlock: aTabPresenter retrievingBlock;     morph: aTabPresenter contents;     menu: aTabPresenter menu;     closeable: aTabPresenter closeable;     setActionsFrom: [ aTabPresenter actions ];     yourselftextModel  ^textModelbuildWidget  ^SpStubLabelAdapter newvResizing: aBoolean  vResizing := aBooleanenable  self model enabled: truelazyPageMorphCreation  ^lazyPageMorphCreationnotify: aSpecNotification on: aNotificationAware  aNotificationAware notifyError: aSpecNotificationretrieveSpec: aSelector  self layout ifNil: [ ^super retrieveSpec: aSelector ].  ^self layoutpresenterAt: aName ifAbsent: aBlock  ^[ self readSlotNamed: aName ] on: SlotNotFound do: aBlocktext: aText  self input text: aTextdisplayBlock  self deprecated: 'Please use #display instead' transformWith: '`@receiver displayBlock' -> '`@receiver display'.  ^tree displaychildren  ^childrenitems: aList  | dropListItems |  dropListItems := aList collect: [:each |  SpDropListItem on: each do: [  ] ].  model collection: dropListItems.  (dropListItems isNotEmpty and: [ startsWithSelection and: [ self selection isEmpty ] ]) ifTrue: [ self selectIndex: 1 ]configureScrolling  self presenter verticalAlignment whenChangedDo: [ widget scrollToIndex: self presenter verticalAlignment desiredVisibleRow ].  self presenter whenDisplayDo: [ widget scrollToIndex: self presenter verticalAlignment desiredVisibleRow.        self scrollingChanged ].  widget onAnnouncement: FTScrollingChanged send: #scrollingChanged to: selfacceptDroppingMorph: draggedMorph event: event inMorph: source  | item index |  index := source rowAtLocation: event position.  item := self presenter model at: index ifAbsent: [ nil ].  ^self acceptDropBlock valueWithEnoughArguments: {draggedMorph model model .         event .         source model model .         item .         index}addMenuItem: aMenuItem  aMenuItem owner: self.  items add: aMenuItem.  self autoRefresh ifNotNil: [ aMenuItem autoRefresh: self autoRefresh ]variableFieldsToShow  | bSize |  bSize := self objectVariableSize.  ^bSize <= (self limit1 + self limit2) ifTrue: [ 1 to: bSize ] ifFalse: [ (1 to: self limit1) , (bSize - self limit2 + 1 to: bSize) ]doItContext  ^doItContexttestScrollDownToNonExistingIndexScrollsBottomToLastIndex  self flag: #pharo7.  SystemVersion current major < 8 ifTrue: [ self skip ].  presenter items: (1 to: 500).  presenter verticalAlignment desiredVisibleRow: 600.  self openInstance.  self assert: presenter verticalAlignment lastVisibleRowIndex equals: 500maxExtent  ^maxExtentemphasis  ^emphasistestRadio2WidgetStartsSelected  self openInstance.  self assert: self presenter radio2 adapter statebrowseInstClassVariables  ^self systemNavigation browseClassVariables: self hostClassstatusBar  ^statusbartestSelectAClassShouldDisplayHisProtcolInProtocolList  biChooseMethod packageList selectItem: self class package.  biChooseMethod classList selectItem: SpMethodChooserMockClass.  self assertCollection: (biChooseMethod protocolList items collect: #name) hasSameElements: #(#'-- all --' #accessing)maxWidth  ^self maxExtent ifNotNil: [:aPoint |  aPoint x ]filteringBlock: aBlock  self deprecated: 'This feature is now removed from Spec 2. If the visible elements of the list need to be changed, it''s the users of the lists that should manage it and update the list of items of the list.'backendForTest: aClass  backendForTest := aClass newname  ^self class backendNametestEnabled  self assert: presenter isEnabled.  self openInstance.  self assert: self morph enabled.  presenter enabled: false.  self deny: self morph enabledleftFraction  ^leftFractioncomputeRowPositions  rowPositions := Array new: numRows.  rowPositions at: 1 put: 0.  2 to: numRows do: [:index |  rowPositions at: index put: (rowPositions at: index - 1) + (rowHeights at: index - 1) + self layout rowSpacing ]initializePresenters  image1 := self newImage.  image2 := self newImage.  image1 image: (self iconNamed: #pharo).  image2 image: self currentWorld submorphs last formtestFirstIconSecondIcon  presenter firstIcon: #thumbsUp secondIcon: #thumbsDown.  self assert: presenter firstButton icon == (self iconNamed: #thumbsUp).  self assert: presenter secondButton icon == (self iconNamed: #thumbsDown)buildLayoutFor: aDynamicPresentersListBuilder  | layout |  layout := SpBoxLayout newVertical.  (self instVarNamesFrom: aDynamicPresentersListBuilder) groupsOf: self rowsCount atATimeDo: [:group |  | subLayout |        subLayout := SpBoxLayout newHorizontal.        group do: [:instVar |  subLayout add: instVar ].        layout add: subLayout ].  ^layoutbadge  ^badgeacceptBlock  ^actionToPerformgreenSlider  ^greenSlidertestVisitCommandsGroup  | menuItems |  self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.  commandsGroup acceptVisitor: menuBuilder.  menuItems := menuBuilder menuPresenter defaultGroup menuItems.  self assert: menuItems size equals: 3.  self assert: menuItems first class equals: SpMenuItemPresenter.  self assert: menuItems first name equals: commandsGroup entries first name.  self assert: menuItems first description equals: commandsGroup entries first description.  self assert: menuItems first subMenu isNil.  self assert: menuItems second class equals: SpMenuItemPresenter.  self assert: menuItems second name equals: commandsGroup entries second name.  self assert: menuItems second description equals: commandsGroup entries second description.  self assert: menuItems second subMenu isNotNil.  self assert: menuItems second subMenu class equals: SpMenuPresenter.  self assert: menuItems second subMenu menuGroups size equals: 1.  self assert: menuItems second subMenu menuGroups first menuItems size equals: 2.  self assert: menuItems second subMenu menuGroups first menuItems first class equals: SpMenuItemPresenter.  self assert: menuItems second subMenu menuGroups first menuItems first name equals: commandsGroup entries second entries first name.  self assert: menuItems second subMenu menuGroups first menuItems first description equals: commandsGroup entries second entries first description.  self assert: menuItems second subMenu menuGroups first menuItems second class equals: SpMenuItemPresenter.  self assert: menuItems second subMenu menuGroups first menuItems second name equals: commandsGroup entries second entries second name.  self assert: menuItems second subMenu menuGroups first menuItems second description equals: commandsGroup entries second entries second description.  self assert: menuItems third class equals: SpMenuItemPresenter.  self assert: menuItems third name equals: commandsGroup entries third name.  self assert: menuItems third description equals: commandsGroup entries third description.  self assert: menuItems third subMenu isNiltype: anObject  type := anObjectsetSelectedItem: anIndex  self deprecated: 'Use #selectedItem: instead' transformWith: '`@receiver setSelectedItem: `@argument' -> '`@receiver selectedItem:`@argument'.  ^self selectItem: anIndexinitializeWindow: aWindowPresenter  aWindowPresenter title: self titleenableItemBeginsWithFilter  self itemFilter: [:each :pattern |  each asLowercase beginsWith: pattern asLowercase ]testActivateRaisesChangedEvent  presenter state: false.  self assertEvent: #whenChangedDo: isRaisedInPresenter: presenter whenDoing: [ presenter state: true ]addVariableFields: elements  self sortedKeys do: [:key |  elements add: (BagEyeElement host: self object index: key) ]inspect: anObject  self object: anObjectassertText: text atInterval: interval isStyle: styleName  interval do: [:index |  self assertText: text at: index isStyle: styleName ]selectItem: anItem  | realItem |  anItem ifNil: [ self selection unselectAll.        ^self ].  realItem := model collection detect: [:each |  each model = anItem ].  self selection selectItem: realItem.  realItem valuedelete  self widgetDo: [:w |  w delete.        self application windowClosed: self ]selectedItem  ^self list selectedItemtestNoClickDoesNotExecuteAction  | actionExecuted |  actionExecuted := false.  presenter action: [ actionExecuted := true ].  self deny: actionExecutedremove: aPresenter  children removeKey: aPresenter.  adapter ifNotNil: [:theAdapter |  theAdapter remove: aPresenter ]rightFraction: aNumber  ^layoutFrame rightFraction: aNumbercolumnPositions  ^columnPositionstestInterpreterCanAccessPresenterVariablesWithoutAccessor  | window |  [ self shouldnt: [ window := SpMockPesenterWithoutGetter new openWithSpec ] raise: MessageNotUnderstood ] ensure: [ window ifNotNil: #close ]index: anObject  index := anObjectminHeightOf: aMorph  ^(self styleOf: aMorph) minHeight ifNil: [ 0 ]setUp  super setUp.  calendar := SpCalendarPresenter newpageClass  ^SpDemoToolBarPresenteraddPreambleTo: aChangeSet  aChangeSet assurePreambleExistssetRefreshingBlockForImplementorsOf: aSelector  self refreshingBlock: [:message |  message selector = aSelector ]clearSelection  selection := #()testAddColumnInPresenterAddsItToWidget  | newColumn |  newColumn := SpStringTableColumn title: 'Hex' evaluated: #hex.  self presenter addColumn: newColumn.  self assert: self adapter columns last id equals: newColumn titlewantsSteps  ^truegetText  self deprecated: 'Use #text instead' transformWith: '`@receiver getText' -> '`@receiver text'.  ^self texthash  ^index hashselectedTab: aTab  selectedTab value: aTabmouseUp: anEvent  (self bounds containsPoint: anEvent cursorPoint) ifFalse: [ anEvent hand showTemporaryCursor: nil ].  self adoptPaneColor: self paneColor.  self preserveLayoutPositiontestSelectWidgetIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | selectedPaths |  presenter selection whenChangedDo: [:selection |  selectedPaths := selection ].  self adapter selectPath: #(1).  self assert: (selectedPaths includes: #(1))testShouldAcceptNegativeInteger  presenter     beInteger;     maximum: 120;     minimum: -150.  self assert: (adapter shouldAccept: '-100').  self deny: (adapter shouldAccept: '-200')testSelectItemOutsideRangeIsEmpty  presenter selectItem: 4000.  self assert: presenter selection isEmptycollection: anObject  | oldValue |  oldValue := collection.  collection := anObject.  self refreshList.  self announcer announce: (ValueChanged oldValue: oldValue newValue: collection)model  ^modeltestSelectPathThenSelectInvalidPathKeepsSingleSelectedItem  presenter selectPath: #(1 3).  presenter selectPath: #(50).  self assert: presenter selection selectedItems size equals: 1button  ^buttonleftText: anObject  leftText := anObjectcheckboxLabel  ^checkboxLabelinitialize  self class initializeSlots: self.  super initialize.  self property: #title whenChangedDo: [ self pageTitleChanged ].  self property: #icon whenChangedDo: [ self pageTitleChanged ]sortingBlock: aBlock  self model sortingBlock: aBlocktestDeepMultipleLookup  | styleResolver |  styleResolver := self newLookup: '.application [ 		Geometry { #width: 11 },		.other [			Geometry { #width: 22 },			.deep1 [				Geometry { #width: 33 }			],			.deep2 [				Geometry { #width: 42 }			]		]	]'.  self assert: styleResolver width equals: 42testMoveElementAtTo  presenter items: {'AAA' .         'BBB' .         'CCC'} asOrderedCollection.  presenter moveElementAt: 1 to: 3.  self assert: presenter items asArray equals: {'BBB' .         'CCC' .         'AAA'}pathOf: anItem from: aCollection  | index |  index := aCollection indexOf: anItem.  index > 0 ifTrue: [ ^{index} ].  aCollection withIndexDo: [:each :i |  (self pathOf: anItem from: (presenter childrenFor: each)) ifNotNil: [:path |  ^{i} , path ] ].  ^nilcancelAction  ^cancelActionselector  ^selectornewWidgetOn: anAdapter  ^self subclassResponsibilitygetAdaptorWithDefaultSpecOf: result  ^result buildAdapterWithSpecLayout: result retrieveDefaultSpecheaderIconChanged  self widgetDo: [:w |  self headerIcon ifNil: [ w header removeIcon ] ifNotNil: [ w header icon: (ImageMorph new form: self headerIcon) ] ]selectIndex: anIndex  messageList selectIndex: anIndexwrapItem: anItem index: anIndex  | result |  result := self model displayForItem: anItem.  ^result asStringattachTransmission: aTransmission  self destinationPresenter whenActivatedDo: [:selection |  self transmitWith: aTransmission value: selection ]openWithSpecLayout: aSpecLayout  ^self application open: self withSpecLayout: aSpecLayouttestSelectIndexSetsSelectedItem  presenter selectIndex: 1.  self assert: presenter selection selectedItem equals: 10addContent: aMorph toWindow: aSpecWindow  | containerMorph |  containerMorph := self newContainerMorph.  containerMorph layoutFrame: aMorph layoutFrame.  self model hasMenu ifTrue: [ self addMenuTo: containerMorph ].  self model hasToolbar ifTrue: [ self addToolBarTo: containerMorph ].  containerMorph addMorphBack: aMorph.  aMorph     hResizing: #spaceFill;     vResizing: #spaceFill.  self model hasStatusBar ifTrue: [ self addStatusBarTo: containerMorph ].  self add: containerMorph toWindow: aSpecWindowsetUp  super setUp.  specInterpreterClass := SpInterpreter.  specInterpreter := specInterpreterClass new.  specInterpreter presenter: SpTestingPresenter newisWindowPresenter  ^truebeEditable  editable := truetext  ^textcardPairsCount  ^self differentCardsCountSlider valueapplyPreTransmissionWith: aTransmittedObject  self preTransmission ifNil: [ ^self ].  self preTransmission cull: self toPresenter cull: self fromPresenter cull: aTransmittedObjectaddLast: aName withConstraints: aBlock  self add: aName withConstraints: [:constraints |  constraints bePlacedAtEnd.        aBlock value: constraints ]isHorizontal  ^self subclassResponsibilitytree  ^tree ifNil: [ tree := self instantiate: SpTreePresenter.        tree whenBuiltDo: [ self initializeShortcuts ].        tree           whenSelectedItemChanged: [:item |  item ifNotNil: [ self text doItReceiver: item value ] ];           displayBlock: [:anObject |  self labelFor: anObject ];           menu: [:menu |  self inspectionMenu: menu ];           hasChildrenBlock: [:o |  true ];           childrenBlock: [:anObject |  self childrenFor: anObject ];           yourself ]removeClass: class from: changeSet  changeSet removeClassChanges: classannouncingObject  ^announcingObjectselectedItem  ^valuewhenDaySelectedBlock: aBlockWith0To2Arguments  whenDaySelectedBlock := aBlockWith0To2ArgumentsdropList  ^self subwidgetroots  ^self childrenForObject: self objecttext: aPresenter  text := aPresenterdragEnabled: aBoolean  model  ^modelselectedIndex  self deprecated: 'Use the #selection object instead. This method assumes single selection' transformWith: '`@receiver selectedIndex' -> '`@receiver selection selectedIndex'.  ^self selection selectedIndexbuttonWithIconOnly: anObject  buttonWithIconOnly := anObjectshouldShowInTree  ^trueproperty: aName whenChangedDo: aBlockClosure  (self observablePropertyNamed: aName) whenChangedDo: aBlockClosuredefaultSpecLayout  < spec>  ^SpLayout composed     add: #sideRuler origin: 0 @ (1 - self currentVerticalScrollPosition) corner: 0 @ (1 - self currentVerticalScrollPosition) offsetOrigin: 0 @ -250 offsetCorner: 50 @ 250;     add: #text origin: 0 @ 0 corner: 1 @ 1 offsetOrigin: 50 @ 0 offsetCorner: 0 @ 0;     yourselfpresenters  ^children keyshasContentToShow: aBlock  hasContentToShow value: aBlocktestFontAffectsTheWidget  backendForTest canChangeFonts ifFalse: [ self skip ].  presenter label: 'ALabel'.  presenter font: StandardFonts codeFont.  self assert: self widget label equals: 'ALabel'.  self assert: self widget font equals: StandardFonts codeFontshowOnlyDestination: aBoolean  self widgetDo: [:w |  w showOnlyDestination: aBoolean ]initialize  super initialize.  label := ''.  emphasis := #().  self whenLabelChangedDo: [ self changed: #getText ]basicMenuPopUp  ^MenuMorph new     addIfNeededTitle: self title andIcon: self icon;     yourselfabsoluteValue: aBoolean  ^self sliderInput absoluteValue: aBooleanasSpLayout  ^selfentryCompletion: anEntryCompletion  self input entryCompletion: anEntryCompletionconfigureButton: aButton item: aToolbarItem  aButton getLabelSelector: #label.  aButton getIconSelector: #icon.  aButton badgeSelector: #badgeinstantiateMorphs  morph1 := Morph new     color: Color red;     width: 60;     height: 20.  morph2 := Morph new     color: Color blue;     width: 20;     height: 60.  morph3 := Morph new     color: Color green;     width: 50;     height: 50withScrollBars  wrapScrollBars := trueinstVarName  ^instVarNameisOpen  ^self isClosed notinitialize  super initialize.  self beColumnHomogeneous.  self beRowHomogeneous.  columnConstraints := Dictionary new.  rowConstraints := Dictionary newtestFirstLabelSecondLabel  presenter firstLabel: 'label 1' secondLabel: 'label 2'.  self assert: presenter firstButton label asString equals: 'label 1'.  self assert: presenter secondButton label asString equals: 'label 2'layoutSpec: aSymbol  layoutSpec := aSymbolmethodRecategorized: aMethod  labelClickable  ^self model labelClickablelistSize  ^self dropList listSizewhenValueChangedDo: aBlock  self property: #currentValue whenChangedDo: aBlocktestWhenLabelChangedDo  | count result |  count := 0.  presenter whenLabelChangedDo: [:label |  count := count + 1.        result := label ].  presenter label: 'Test'.  self assert: result equals: 'Test'.  self assert: count equals: 1label  ^self model labelunselectPath: aPath  self subclassResponsibilitystyleMinExtent: aPoint  | rootStyle |  rootStyle := SpStyleSTONReader fromString: ('.application [ Geometry \{ #minWidth: {1}, #minHeight: {2} \} ]' format: {aPoint x .               aPoint y}).  ^SpMorphStyle newStyles: rootStyle flattenClassestestUnselectWidgetIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | selectedPath |  self adapter selectPath: #(1).  presenter selection whenChangedDo: [:selection |  selectedPath := selection ].  self adapter selectPath: #().  self assertEmpty: selectedPathpageTitleChanged  self owner ifNil: [ ^self ].  self owner pageTitleChanged: selfselectedItems  ^self selectedItemsAtIndexes: self selection selectedIndexesasToolBarPresenterWith: aBlock  self deprecated: 'Use #asToolbarPresenterWith: instead.' transformWith: '`@receiver asToolBarPresenterWith: `@arg' -> '`@receiver asToolbarPresenterWith: `@arg'.  ^self asToolbarPresenterWith: aBlockmin  ^minupdate: aSymbol with: anArray  self perform: aSymbol withArguments: anArraysetUp  super setUp.  super setUp.  presenter     addColumn: (SpStringTableColumn title: 'Value' evaluated: #printString);     beSingleSelection;     roots: #(1 2 3);     children: [:aNumber |  aNumber < 100 ifTrue: [ {(aNumber * 2) .               (aNumber * 3) .               (aNumber * 10)} ] ifFalse: [ #() ] ];     yourselfmax: aNumber  slider max: aNumberreadSelection  ^self model readSelectiontitle  ^titletestContextMenu  | menu changed |  self assert: presenter contextMenu isNil.  menu := SpMenuPresenter new.  changed := false.  presenter whenMenuChangedDo: [ changed := true ].  presenter contextMenu: menu.  self assert: presenter contextMenu equals: menu.  self assert: changedclassToTest  self subclassResponsibilitycenteredRelativeTo: aModel  self deprecated: 'This feature is to tight to Morphic to be in Spec. If you want this feature in a Morphic specific Spec application you should apply it yourself on the widget.		aWindow			fullBounds;			center: self adatper widget center' on: '2019-06-25' in: #Pharo8toolbarPresenter: anObject  toolbarPresenter := anObjectguessTypeForName: aString  ^niladdItemLabeled: aString do: aBlock  self addItemLabeled: aString do: aBlock icon: nilstyleTableAt: styleName do: aBlock  | attributes |  attributes := (SHRBTextStyler initialTextAttributesForPixelHeight: 1) at: styleName.  attributes do: aBlockowner: anObject  owner := anObjectcancelled  ^cancellednotifyError: aSpecNotification  self subclassResponsibilitybuildWidget  ^SpStubBoxView newaddItem: aToolbarItem position: aPosition  aToolbarItem owner: self.  aPosition addItem: aToolbarItem into: selfinitializePresenters  redSlider := self instantiate: SpSliderInput.  greenSlider := self instantiate: SpSliderInput.  blueSlider := self instantiate: SpSliderInput.  redSlider     min: 0;     max: 255;     label: 'Red' translated.  greenSlider     min: 0;     max: 255;     label: 'Green' translated.  blueSlider     min: 0;     max: 255;     label: 'Blue' translated.  self focusOrder     add: redSlider;     add: greenSlider;     add: blueSlidercontentArea  ^contentAreawhenSelectedItemChanged: aBlock  self dropList whenSelectedItemChanged: aBlockspecInitializationStrategy: aStrategy  specInitializationStrategy := aStrategysetTargetLayoutSizing  self target vResizing = #rigid ifTrue: [ ^self ].  self target vResizing: #rigid.  self targetAfter vResizing: #spaceFillasMenuBarPresenter  ^SpMenuBarPresenterBuilder new     visit: self;     menuPresenterdefinedFont  | definedFont |  definedFont := LogicalFont familyName: self name pointSize: self size.  self isItalic ifTrue: [ definedFont forceItalicOrOblique ].  self isBold ifTrue: [ definedFont forceBold ].  ^definedFontaddItem: anObject into: aToolbar  aToolbar addItemRight: anObjecttestSelectManyIndexesKeepsAllSelected  presenter selectIndex: 1.  presenter selectIndex: 2.  self assert: self adapter selectedIndexes asArray equals: #(1 2)classToTest  ^SpTablePresentertoolbarItemFont: anObject  toolbarItemFont := anObjecttestOpenDialogWindowWithDifferentApplicationShouldFail  | secondApplication presenterInSecondApplication |  secondApplication := SpApplication new.  presenterInSecondApplication := secondApplication newPresenter: SpButtonPresenter.  self should: [ application openDialog: presenterInSecondApplication ] raise: SpInvalidApplicationErrorcopyAllFrom: src to: dest  self checkThatSidesDiffer: [ ^self ].  self model copyAllChangesFrom: src selectedChangeSet to: dest selectedChangeSet.  dest updateClassesListinitializePresenters  labelPresenter := self newLabel.  descriptionPresenter := self newNullPresentertitle  ^titleHoldertestUnselectSelectedItemRaisesSelectionEventOnce  | counter |  counter := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectItem: 10.  self assert: counter equals: 1beInfo  self type: SpNotificationType infoclassToTest  ^SpSearchableListtestClickActivatedCheckboxDectivatesIt  presenter state: true.  self emulateLeftClick.  self deny: presenter statewhenSelectedItemChangedDo: aBlock  selection whenChangedDo: [ aBlock cull: self selectedItem ]giveFocusToNextFrom: aModel  ^self presenter giveFocusToNextFrom: aModelroots: aCollection  roots := aCollection asOrderedCollection.  tree roots: aCollection asOrderedCollectiontestSelectPathTwiceAddsPathToSelectedPathListOnlyOnce  presenter selectPath: #(1 3).  presenter selectPath: #(1 3).  self assert: presenter selection selectedPaths equals: #(#(1 3))dateLabel: anObject  dateLabel := anObjectperformMenuActionWith: aMenuItem  | en |  en := self isEnabled.  en isBlock ifTrue: [ en := en value ].  en ifFalse: [ ^self ].  self action cull: aMenuItemdisplayBlock  ^displayBlock valuetransmitWith: aTransmission value: transmitted  aTransmission applyPreTransmissionWith: transmitted.  aTransmission toPort incomingTransmission: (aTransmission transformed: transmitted) from: self.  aTransmission applyPostTransmissionWith: transmittedselectIndex: index  self presenter selection selectPath: {index}setPackageButton  packageButton     state: false;     label: '+Package';     help: 'Add a new package and make it the working copy';     action: [ self createPackage ]withText: anObject  withText := anObjectarguments  ^{(self commands identityIndexOf: self)}changesListPresenter  ^changesListPresenterinstantiate: aPresenterClass  ^aPresenterClass owner: selfmodel: anObject  self deprecated: 'Use #presenter: instead' transformWith: '`@receiver model: `@statment1' -> '`@receiver presenter: `@statment1'.  self presenter: anObjectclassesMenu: aBlock  classesListPresenter contextMenu: aBlockwrap: item at: index  | checkBox |  associationsIndexToWrapper at: index ifPresent: [:cb |  ^cb ].  checkBox := self instantiate: SpCheckBoxPresenter.  blockToPerformOnWrappers value value: checkBox.  checkBox label: (wrapHolder value cull: item cull: self).  checkBox whenActivatedDo: [ self addPicked: item.        listPresenter setSelectedItem: checkBox.        listPresenter takeKeyboardFocus ].  checkBox whenDeactivatedDo: [ self removePicked: item.        listPresenter selectItem: checkBox.        listPresenter takeKeyboardFocus ].  checkBox     state: self defaultValue;     labelClickable: self labelClickable.  associationsWrapperToItem at: checkBox put: item.  associationsItemToWrapper at: item put: checkBox.  associationsIndexToWrapper at: index put: checkBox.  ^checkBoxbasicAdd: aPresenter constraints: constraints to: aPanel  testAddPresenterToComponentListIsInPresenterCollection  | button |  button := SpButtonPresenter new.  presenter addPresenter: button.  self assert: (presenter includes: button)refreshList  ^self widget refreshsubwidget: anObject  subwidget := anObjectselectedItem  self deprecated: 'Use #selectedMessage instead' transformWith: '`@receiver selectedItem' -> '`@receiver selectedMessage'.  ^self selectedMessagebePlacedAtStart  placedAtStart := trueremoveMessage  self okToChange ifFalse: [ ^self ].  self selectedSelector ifNotNil: [:selector |  | class method |        class := self selectedClass.        (class includesSelector: selector) ifFalse: [ ^self ].        method := class >> selector.        (self model removeMethod: method inClass: class) ifTrue: [ self updateMessagesList ] ]presenter: anObject  presenter := anObjectbuildWidget  ^SpStubMenuView newtestShouldAcceptIntegerWithoutMinMax  presenter     beInteger;     maximum: nil;     minimum: nil.  self assert: (adapter shouldAccept: '').  self assert: (adapter shouldAccept: '100').  self deny: (adapter shouldAccept: '100.10').  self assert: (adapter shouldAccept: '80').  self assert: (adapter shouldAccept: '150').  self deny: (adapter shouldAccept: 'string').  self deny: (adapter shouldAccept: '10string')span  ^spanrename  | set |  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  set := self model rename: self selectedChangeSet.  changesListPresenter     updateList;     setSelectedItem: set.  self updateWindowTitletestBorderWidthNotHomogeneous  | layout |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1.  self place: label2 at: 1 @ 2.  self place: morph2 at: 2 @ 2.  (layout := self newLayout) layout     beRowNotHomogeneous;     beColumnNotHomogeneous;     borderWidth: 5.  layout layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (5 @ 5 corner: 55 @ 25).  self assert: morph1 bounds equals: (55 @ 5 corner: 105 @ 25).  self assert: label2 bounds equals: (5 @ 25 corner: 55 @ 45).  self assert: morph2 bounds equals: (55 @ 25 corner: 105 @ 45)browseModel  ^browseModelchildrenBlock  ^childrenBlockHolder valuetestSelectIndexesThenSelectOutsideRangeKeepsIndexes  presenter selectIndexes: {1 .         2}.  presenter selectIndexes: {50 .         60}.  self assert: (presenter selection includesIndexes: {1 .               2})whenCanDeselectByClickChanged: aBlock  self deprecated: 'Use #whenCanDeselectByClickChangedDo: instead.' transformWith: '`@receiver whenCanDeselectByClickChanged: `@statements' -> '`@receiver whenCanDeselectByClickChangedDo: `@statements'.  self whenCanDeselectByClickChangedDo: aBlockstyleSheet  ^self propertyAt: #styleSheet ifAbsent: [ SpStyle defaultStyleSheet ]addPresenterIn: widgetToBuild withSpecLayout: aSpec  self addContent: (self model presenter buildWithSpecLayout: aSpec) toWindow: widgetToBuildwhenGhostTextChanged: aBlock  self deprecated: 'This API is too tight to Morph. Use #whenPlaceholderChanged: instead.' transformWith: '`@receiver whenGhostTextChanged: `@statement' -> '`@receiver whenPlaceholderChangedDo: `@statement'.  self whenPlaceholderChangedDo: aBlockcustomMenuActions  ^customMenuActions ifNil: [ customMenuActions := [  ] ]testOpenPresenterRaisesDisplayEvent  | displayed |  displayed := false.  presenter whenDisplayDo: [ displayed := true ].  self openInstance.  self assert: displayedbackgroundColorFor: anItem at: index  ^self model backgroundColorFor: anItem at: indexclassToTest  ^SpCheckBoxPresentertestFromStylesheetAdapter  | lookup labelAdapter |  labelAdapter := SpLabelPresenter new     buildWithSpec;     adapter.  lookup := SpMorphStyle fromStylesheet: (SpStyleSTONReader fromString: '.application [	.label [		Geometry { #width: 42 }		]	]') adapter: labelAdapter.  self assert: lookup width equals: 42.  lookup := SpMorphStyle fromStylesheet: (SpStyleSTONReader fromString: '.application [	Geometry { #width: 42 },	.label [ ]	]') adapter: labelAdapter.  self assert: lookup width equals: 42.  lookup := SpMorphStyle fromStylesheet: (SpStyleSTONReader fromString: '.application [	.label [		Geometry { #width: 42 }	],	.other [ 		.label [ 			Geometry { #width: 22 } 		] 	]]') adapter: labelAdaptertoolName  ^self class toolNametestWhenClosedDo  | closed |  closed := false.  presenter whenClosedDo: [ closed := true ].  self openInstance.  presenter close.  self assert: closedclassToTest  ^SpDatePresenterbuildWidget  ^SpStubNumberInputFieldView newtargetAfter  ^self owner submorphs after: selftestDeepLookup  | styleResolver |  styleResolver := self newLookup: '.application [ 		Geometry { #width: 11 },		.other [			Geometry { #width: 22 },			.deep [				Geometry { #width: 42 }			]		]	]'.  self assert: styleResolver width equals: 42testExplicitNotificationRaisesEventOnlyOnce  | count |  count := 0.  point property: #x whenChangedDo: [ count := count + 1 ].  point notifyPropertyChanged: #x.  self assert: count equals: 1width  ^widthborderColor  ^self model borderColortestMethodListContentWhenInstanceSideIsSelected  biChooseMethod radioButtonInstanceSide click.  biChooseMethod packageList selectItem: SpMethodChooserMockClass package.  biChooseMethod classList selectItem: SpMethodChooserMockClass.  self denyEmpty: biChooseMethod methodList items.  self assert: biChooseMethod methodList selection selectedIndex equals: 1.  self assertCollection: SpMethodChooserMockClass methods hasSameElements: biChooseMethod methodList itemsrestore  self modelChangedtransmission  self subclassResponsibilitybasicAdd: aPresenter constraints: constraints to: aPanel  | childMorph |  childMorph := self buildMorph: aPresenter constraints: constraints.  aPanel addMorphBack: childMorph.  ^childMorphlabelPresenter: anObject  labelPresenter := anObjectprotocolList  ^protocolListmenu: aBlock  menuBlockHolder value: aBlockcopyClassFrom: src to: dest  | otherChangeSet |  self checkThatSidesDiffer: [ ^self ].  self okToChange ifFalse: [ ^self inform: 'Can''t discard edits.' ].  src selectedClass ifNil: [ ^self inform: 'Selected class is nil.' ].  otherChangeSet := dest selectedChangeSet.  self model copyClass: src selectedClass from: src selectedChangeSet to: otherChangeSet.  dest setSelectedChangeSet: otherChangeSetinitializePresenters  menu := self newMenuBar     addGroup: [:group |  group addItem: [:item |  item                 name: 'File';                 icon: (self iconNamed: #openIcon);                 subMenu: self subMenu ].        group addItem: [:item |  item                 name: '';                 description: 'Open file';                 icon: (self iconNamed: #openIcon);                 action: [ self inform: 'Open File' ] ].        group addItem: [:item |  item                 name: '';                 description: 'Save File';                 icon: (self iconNamed: #smallSaveIcon);                 action: [ self inform: 'Save File' ] ].        group addItem: [:item |  item                 name: '';                 description: 'Print file';                 icon: (self iconNamed: #smallPrintIcon);                 action: [ self inform: 'Print file' ] ] ];     addGroup: [:group |  group addItem: [:item |  item                 name: '';                 description: 'Undo';                 icon: (self iconNamed: #smallUndoIcon);                 action: [ self inform: 'Undo' ] ].        group addItem: [:item |  item                 name: '';                 description: 'Redo';                 icon: (self iconNamed: #smallRedoIcon);                 action: [ self inform: 'Redo' ] ] ];     addGroup: [:group |  group addItem: [:item |  item                 name: '';                 description: 'Add menu item';                 icon: (self iconNamed: #add);                 action: [ self addItemTo: group ] ] ].  menu applyTo: self.  text := self newText.  self focusOrder add: textheight  ^heightobjectVariableSize  ^[ self object size ] on: Error do: [ self object basicSize ]basicPresenters  ^presenters ifNil: [ presenters := OrderedDictionary new ]phone: anObject  phone := anObjectform  ^formwithWidgetDo: aValuable  ^self adapter ifNotNil: aValuablerealMenu: anObject  realMenu := anObjecttestAddManyPresentersPushesThemToPresenterList  3 timesRepeat: [ self presenter addPresenter: (SpNullMillerPresenter on: SpLabelPresenter new) ].  self assert: self presenter size equals: 3initialize  super initialize.  selector := #newHSplitterAt:.  layoutFrame := (0 @ 0 corner: 0 @ 0) asSpLayoutFrame bottomOffset: 1placeAtEnd  placeAtStart := falseaction  ^actionchildren  ^children valuepreTransmission  ^preTransmissionlist  ^liststate  ^statesetImplementorsModel  implementorsModel     state: false;     label: 'Implementors';     action: [ self implementorsMethod ]testSetColumnTitleInPresenterShowsThemInWidget  self presenter headerTitle: 'test'.  self assert: self adapter isShowColumnHeadersadd: aName  self add: aName withConstraints: [:constraints |   ]suspendAnnouncementsDuring: aBlock  | subscriptions |  subscriptions := self announcer subscriptions subscriptions.  subscriptions do: [:sub |  self announcer unsubscribe: sub ].  aBlock value.  subscriptions do: [:sub |  self announcer basicSubscribe: sub ]initialize  super initialize.  self actionBarPresenter: SpActionBarPresenter newbuildWithSpec: aSpec  ^self buildWithSpecLayout: (self retrieveSpec: aSpec)testSelecting2ElementsUpdatesThePresenterCorrectly  selectOnlyLastHighlighted  ^removeOnlyLastSelected valueinstantiatePresenters: aCollectionOfPairs  (aCollectionOfPairs anySatisfy: [:e |  e isKindOf: Association ]) ifTrue: [ aCollectionOfPairs do: [:a |  | k v |              k := a key.              v := a value.              self instVarNamed: k asString put: (self createInstanceFor: v) ] ] ifFalse: [ aCollectionOfPairs pairsDo: [:k :v |  self instVarNamed: k asString put: (self createInstanceFor: v) ] ]buildDynamicPresenter  dynamicPresenter := SpDynamicPresenter new.  dynamicPresenter instantiatePresenters: self instVarNamesAndPresenterNamesArray.  self instVarToModelObjectDo: [:instVarName :object |  self configurationBlock value: (instVarName value: dynamicPresenter) value: object ].  ^dynamicPresenterinitialize  super initialize.  visible := true.  self initializePrivateAnnouncer.  self initializePrivateValueHolders.  self initializePrivateHooks.  self initializePrivateAnnouncementsinitializePresenters  radio1 := self newRadioButton     label: 'radio1';     yourself.  radio2 := self newRadioButton     label: 'radio2';     yourself.  radio3 := self newRadioButton     label: 'radio3';     yourself.  radio1 associatedRadioButtons: {radio2 .         radio3}testExplicitNotifyUnexistentPropertyChangedRaisesError  self should: [ point notifyPropertyChanged: #z ] raise: SlotNotFoundslider  ^slidericon  ^icondoubleClick: aBlock  doubleClick value: aBlocktestUnselectSelectedPathRemovesSelection  presenter     selectPath: #(1 1);     unselectPath: #(1 1).  self assert: presenter selection isEmptyemulateRightClick  self emulateClick: MouseButtonEvent yellowButtoncolumnWidths  ^columnWidthswithText  ^withTexthasMenu  ^self menu notNilselectedItemsSorted  ^self selectedItemsAtIndexes: self selection selectedIndexes sortinternalGetText  ^TextDiffBuilder buildDisplayPatchFrom: (self priorVersionOfAMethod: method) sourceCode to: method sourceCode inClass: method classNameplaceholder: aText  placeholder := aTextwhenAutoDeselectChanged: aBlock  self deprecated: 'Use #whenAutoDeselectChangedDo: instead.' transformWith: '`@receiver whenAutoDeselectChanged: `@statements' -> '`@receiver whenAutoDeselectChangedDo: `@statements'.  self whenAutoDeselectChangedDo: aBlocktestSetRootModelWithPresenterDoesNotFail  self presenter presenterBlock: [:model |  SpNullMillerPresenter on: (SpLabelPresenter new label: model asString) ].  self shouldnt: [ self presenter setRootModel: 1 ] raise: ErrormessageListMenu  ^self newMenu     addGroup: [:aGroup |  aGroup           addItem: [:anItem |  anItem                 name: 'Compare to current';                 help: 'Compare selected version to the current version';                 action: [ self compareToCurrentVersion ] ];           addItem: [:anItem |  anItem                 name: 'Compare to version...';                 help: 'Compare selected version to another selected version';                 action: [ self compareToOtherVersion ] ];           addItem: [:anItem |  anItem                 name: 'Revert to selected version';                 help: 'Resubmit the selected version, so that it becomes the current version';                 action: [ self revert: self selectedMessage ] ];           addItem: [:anItem |  anItem                 name: 'Senders';                 shortcut: $n meta;                 action: [ self browseSenders ] ];           addItem: [:anItem |  anItem                 name: 'Implementors';                 shortcut: $m meta;                 action: [ self browseImplementors ] ] ];     yourselfisMorphicAdapter  ^truesetRootModel: aModel  self resetTo: 0.  self pushModel: aModelcolor: aColor  color := aColorcontent  ^self nodeModel contentadd: aWidget  whenAutoAcceptChanged: aBlock  self deprecated: 'Use #whenAutoAcceptChangedDo: instead.' transformWith: '`@receiver whenAutoAcceptChanged: `@statements' -> '`@receiver whenAutoAcceptChangedDo: `@statements'.  self whenAutoAcceptChangedDo: aBlockmethodClassNameForItem: anItem  ^anItem methodClass ifNotNil: [:class |  class name ] ifNil: [ '' ]setHeaderButtonLabel: aLabel font: aFont icon: anIconForm target: aReceiver actionSelector: aSelector  (aLabel isNil and: [ anIconForm isNil and: [ aReceiver isNil or: [ aSelector isNil ] ] ]) ifTrue: [ ^self ].  self headerButton.  aLabel ifNil: [ self header label: '' font: nil ] ifNotNil: [ self header label: aLabel font: aFont ].  anIconForm ifNotNil: [ self header icon: (ImageMorph new form: anIconForm) ].  (aSelector notNil and: [ aReceiver notNil ]) ifFalse: [ ^self ].  self header actionSelector: aSelector.  self header target: aReceivertable  ^tableselection  ^selectionModeupdateAccordingTo: aFilter  self widgetDo: [:w |  w contents do: [:n |  n nodeModel updateAccordingTo: aFilter ].        w contents removeAllSuchThat: [:n |  (aFilter keepTreeNode: n nodeModel) not and: [ n nodeModel isEmpty ] ] ]menu: aBlock shifted: aBoolean  self deprecated: 'Use #contextMenu: instead. The old way to create a MenuPresenter was this method taking a MenuMorph as parameter. This will not work with other backend and will be totally removed in Pharo7. Now you should use #contextMenu takin a MenuPresenter (or a block returning a menu presenter) as parameter.' on: '2019-03-07' in: #Pharo8.  self contextMenu: [ aBlock cull: (MenuMorph new                 defaultTarget: self;                 yourself) cull: true ]bindKeyCombination: aShortcut toAction: aBlock  self widgetDo: [:w |  w bindKeyCombination: aShortcut toAction: aBlock ]rowInset: anInteger  rowInset value: anIntegerchildNodeClassFor: anItem  ^childNodeClass valuenumberType: aClass  numberType := aClasstestReplaceItemList  | changed |  changed := false.  presenter whenModelChangedDo: [ changed := true ].  presenter items: #(a b c).  self assert: presenter model collection equals: #(a b c).  self assert: changeddefer: aBlock  self application defer: aBlockeventKeyStrokesForPreviousFocus  ^{Character arrowLeft asKeyCombination .   Character tab shift asKeyCombination}buildLayoutFor: aDynamicPresentersListBuilder  | layout |  layout := SpBoxLayout newHorizontal.  (self instVarNamesFrom: aDynamicPresentersListBuilder) groupsOf: self columnsCount atATimeDo: [:group |  | subLayout |        subLayout := SpBoxLayout newVertical.        group do: [:instVar |  subLayout add: instVar ].        layout add: subLayout ].  ^layoutbackendForTest: aClass  backendForTest := aClass newnewIndex  ^newIndexclassToTest  ^SpVersatileDialogPresenteractivationAction: aBlock  actionWhenActivated := aBlockwhenSortingBlockChangedDo: aBlock  self model whenSortingBlockChangedDo: aBlockopenWithSpecLayout: aSpec  self buildWithSpecLayout: aSpec.  self updateTitlerowsCount: anObject  (anObject isInteger and: [ anObject > 0 ]) ifFalse: [ self error: 'A positive integer is expected as parameter.' ].  rowsCount := anObjectadd: anAdapter  self widgetDo: [:w |  w spEnsureLayoutAndAddMorph: anAdapter widget ]accessorCode  ^self instVarNametraversePresentersDo: aBlock  self traversePresentersDo: aBlock excluding: Set newdisplayBlock: aBlock  listModel displayBlock: aBlockwhenTextChanged: aBlock  self input whenTextChanged: aBlocktestPlaceholderIsSet  presenter placeholder: 'enter something...'.  self assert: presenter placeholder equals: 'enter something...'aboutToStyle: aBoolean  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8hideColumnHeaders  showColumnHeaders := falseselectionHolder  ^self observablePropertyNamed: #selectedIndexrefreshColumnsInWidget  widget columns: (self model columns collect: [:each |  self newColumnFrom: each ]).  self ensureAtLeastOneColumnIn: widgettoolbarPresenter  ^toolbarPresentertestAsButtonPresenterExecutesOnClick  | flag buttonPresenter |  flag := false.  command := CmBlockCommand new     block: [ flag := true ];     yourself.  buttonPresenter := command asSpecCommand asButtonPresenter.  buttonPresenter click.  self assert: flag equals: truewrite: aValue to: anObject  (super read: anObject) ifNotNil: [:v |  v value: aValue ].  ^aValuedropListItems: dropListItems  model collection: dropListItemsinitializePresenters  label := self instantiate: SpLabelPresenterenabled: aBoolean  self presentersDo: [:each |  each enabled: aBoolean ]testRemoveTabFromManager  self openInstance.  presenter addTab: redTab.  self assertCollection: presenter tabs hasSameElements: {redTab}.  self assertCollection: (self morphicTabsFor: presenter) hasSameElements: {redTab adapter widget}.  redTab adapter widget delete.  self assertCollection: presenter tabs hasSameElements: #().  self assertCollection: (self morphicTabsFor: presenter) hasSameElements: #()denyEvent: anEventName isRaisedInPresenter: aPresenter whenDoing: aBlock  self assertWith: [:times |  times = 0 ] timesRaisedEvent: anEventName inPresenter: aPresenter whenDoing: aBlockintervalOf: aSelector inCode: aText of: aMethod  aMethod compiledMethod ifNil: [ ^0 to: 0 ].  ^(self sourceIntervalOf: aSelector in: aMethod ast) ifEmpty: [ self searchedString: aSelector asString in: aText ]newCheckBox  ^self instantiate: SpCheckBoxPresentertestSelectIndexesThenSelectOutsideRangeKeepsElements  presenter selectIndexes: {1 .         2}.  presenter selectIndexes: {50 .         60}.  self assert: (presenter selection includesItems: {10 .               20})addCellColumn: aTableColumn  self addCell: (aTableColumn readObject: self item) column: aTableColumntestModelSettingModelToValueHolder  | point model presenter |  point := 40 @ 54.  presenter := SpTestingPresenterWithModel on: point.  model := SpTestingPointModel x: 1 y: 2.  self assert: presenter announcingObject isSpAnnouncingObject.  self assert: presenter announcingObject isValueHolder.  self assert: model isSpAnnouncingObject.  self deny: model isValueHolder.  presenter model: model.  self assert: presenter announcingObject isSpAnnouncingObject.  self deny: presenter announcingObject isValueHolder.  self assert: presenter announcingObject == model.  self assert: presenter announcingObject announcer numberOfSubscriptions > 0initialize: aString  label label: aString.  input text: aString.  textToReset := aStringstate: aValue  (aValue not and: [ associatedRadioButtons noneSatisfy: [:e |  e state ] ]) ifTrue: [ ^self ].  super state: aValue.  aValue ifTrue: [ associatedRadioButtons do: [:e |  e state: false ] ]rowHeights  ^rowHeightsadapter  ^nilallUnselectedItems  | result |  result := OrderedCollection new.  self selected ifFalse: [ result add: self ].  self children value do: [:e |  result addAll: e allUnselectedItems ].  ^resultensureExtentFor: widget  self extent ifNil: [ self initialExtent ifNotNil: [:ex |  (widget respondsTo: #extent:) ifTrue: [ widget extent: ex ] ] ] ifNotNil: [:ex |  (widget respondsTo: #extent:) ifTrue: [ widget extent: ex ] ]acceptDroppingMorph: draggedMorph event: event inMorph: source  ^self acceptDropBlock cull: draggedMorph model model cull: event cull: source cull: source modelacceptBlock: aBlock  textModel acceptBlock: aBlockbuildWidget  ^SpStubSpacerView newwidth  ^self extent ifNotNil: [:aPoint |  aPoint x ]selectPaths: pathArray  self selection selectPaths: pathArrayemptyAccumulator: controls  controls do: [:button |  widget addMorphBack: button ].  controls removeAlllabel  ^self presenter labelassertList: anAdapter displayItems: aCollection  | tableContainer tableRowContents |  self waitUntilUIRedrawed.  tableContainer := anAdapter widget submorphs first.  tableRowContents := tableContainer submorphs collect: [:row |  | cell |        cell := row submorphs first.        (cell submorphs detect: [:e |  e isKindOf: StringMorph ]) contents ].  self assert: tableRowContents first = aCollection first.  self assert: tableRowContents second = aCollection second.  self assert: tableRowContents third = aCollection thirdmodelChanged  workingModel := self model copy.  self fillFormWithWorkingModelstep  | range |  super step.  range := end - start.  self value: self value + (range / self indeterminateStepIncrease).  self value > range ifFalse: [ ^self ].  self value: start.  oddPassage := oddPassage notwhenTextIsAcceptedDo: aBlock  self property: #actionPerformed whenChangedDo: aBlockwantsDroppedMorph: draggedMorph event: anEvent inMorph: source  ^self model wantsDroppedMorph: draggedMorph event: anEvent inMorph: sourcehasProperty: aSymbol  ^themeOverrideDict includesKey: aSymboladapterName  ^#BoxAdapterbuildButtonBar  | buttonBar |  buttonBar := (SpButtonBarPresenter owner: self model) placeAtEnd.  self model buttons do: [:buttonPresenter |  buttonBar add: buttonPresenter ].  ^buttonBarinitialExtent  ^200 @ 25topologicSort: aBoolean  ^messageList topologicSort: aBooleanbeforeTest: aSpecTest  aSpecTest openInstanceselectItem: anItem  self selection selectItem: anItemconnectPresenters  labelClickableHolder whenChangedDo: [:aBoolean |  associationsWrapperToItem keysDo: [:e |  e labelClickable: aBoolean ] ].  defaultValueHolder whenChangedDo: [:value |  associationsWrapperToItem keysDo: [:cb |  cb state: value ] ]isPresenter  ^trueinitialize  super initialize.  lock := false.  subscriptions := OrderedCollection newaboutText  ^aboutTextabsoluteValue: aFloat  ^self presenter absoluteValue: aFloatconstraintsClass  ^SpBoxConstraintsiconFor: class  ((class includesBehavior: (Smalltalk globals at: #TestCase ifAbsent: [ false ])) and: [ class isAbstract not ]) ifTrue: [ class hasPassedTest ifTrue: [ ^self iconNamed: #testGreenIcon ].        class hasFailedTest ifTrue: [ ^self iconNamed: #testYellowIcon ].        class hasErrorTest ifTrue: [ ^self iconNamed: #testRedIcon ].        ^self iconNamed: #testNotRunIcon ].  class organization classComment ifEmpty: [ ^self iconNamed: #uncommentedClassIcon ].  ((class includesBehavior: (Smalltalk globals at: #TestCase ifAbsent: [ false ])) and: [ class isAbstract not ]) ifTrue: [ class hasPassedTest ifTrue: [ ^self iconNamed: #testGreenIcon ].        class hasFailedTest ifTrue: [ ^self iconNamed: #testYellowIcon ].        class hasErrorTest ifTrue: [ ^self iconNamed: #testRedIcon ].        ^self iconNamed: #testNotRunIcon ].  class organization classComment ifEmpty: [ ^self iconNamed: #uncommentedClassIcon ].  ^class systemIconhelpText  ^widget balloonTextadapter: anAdapter  adapter := anAdapterstrongSelectionChanged: aFTStrongSelectionChanged  self presenter activatesOnDoubleClick ifTrue: [ self presenter doubleClickAtIndex: aFTStrongSelectionChanged selectedIndex ]maxExtent: anObject  maxExtent := anObjectonLayoutChange: aBlock  layoutChangeAction := aBlockwhenScrollValueChangedDo: aBlock  self property: #scrollValue whenChangedDo: aBlockisHorizontal  ^(properties listDirection == #topToBottom or: [ properties listDirection == #bottomToTop ]) nottoolbar  ^toolbarselectPath: aPath  self selection selectPath: aPathaccept: aText  self model accept: aTextaddTab: aTab  self widgetDo: [:w |  w addTab: (self buildTab: aTab) ]testSelectIndexesOutsideRangeHasNoSelectedIndexes  presenter selectIndexes: {4 .         5}.  self assert: presenter selection selectedIndexes isEmptytestSelectPathThenSelectInvalidPathKeepsFirstPath  presenter selectPath: #(1 3).  presenter selectPath: #(50).  self assert: (presenter selection includesPath: #(1 3))childrenFor: anObject  ^self children value: anObjecttabSelectedActionHolder  ^tabSelectedActionHolderselectAllChildren  self children value do: [:e |  e selected: true.        e selectAllChildren ]extent  ^45 @ 25placeholder: aString  placeholder := aString.  entityText placeholder: aStringactivatesOnSingleClick  ^activateOnSingleClickconvertSymbolOfClassToInstance: aSymbol  | translatedSymbol |  translatedSymbol := self bindings translateSymbol: aSymbol.  ^(Smalltalk at: translatedSymbol ifAbsent: [ ^translatedSymbol ]) owner: self presentersetFocus  self focusOrder     add: messageList;     add: toolbarPresenter;     add: textModelassertListHeaderOf: anAdapter equals: aCollection  | tableContainer tableRowMorph cells |  self waitUntilUIRedrawed.  tableContainer := anAdapter widget submorphs first.  tableRowMorph := tableContainer submorphs first.  cells := tableRowMorph submorphs.  self assert: (cells collect: [:c |  c submorphs first contents ]) asArray = aCollection asArrayfullFrame: anObject  layout := anObjectelements  ^self model ifNotNil: #items ifNil: [ #() ]itemNotFoundAction  self clearSelectionstyle: aSymbol  | tag |  tag := SpCodeStyleForTest new.  self styleTableAt: aSymbol do: [:each |  self fillTag: tag withAttribute: each ].  ^tagminWidthOf: aMorph  ^(self styleOf: aMorph) minWidth ifNil: [ 0 ]whenActivationActionChangedDo: aBlock  self property: #actionWhenActivated whenChangedDo: aBlockshowBoth  self widgetDo: [:w |  w showBoth ]daysInAWeek  ^self dayNames sizetestSelectMultipleItemsRaisesSelectionChangeEventMultipleTimes  | events |  events := 0.  presenter whenSelectionChangedDo: [:selection |  events := events + 1 ].  presenter selectItem: 10.  presenter selectItem: 30.  self assert: events equals: 2refreshList  ^self widget refreshdisplayBlock: aBlock  self deprecated: 'Please use #display: instead' transformWith: '`@receiver displayBlock: `@arg' -> '`@receiver display: `@arg'.  tree display: aBlockscaleLabel  ^scaleLabelbuttonAt: id  ^buttons at: idenableSearch  searchEnabled := truetext  ^textexpandRoots  self changed: #expandRoots with: #()pageClass  ^SpDemoFormPresenterhAlign  ^hAlignclicked  widget toggleSelectedinitializePresenters  label := self newLabel.  list := self newList.  addButton := self newButton.  removeButton := self newButton.  upButton := self newButton.  downButton := self newButton.  topButton := self newButton.  bottomButton := self newButton.  addButton     addStyle: 'small';     icon: (self iconNamed: #addIcon);     help: 'Add a new item to the list'.  removeButton     addStyle: 'small';     icon: (self iconNamed: #removeIcon);     help: 'Remove a item from the list'.  upButton     addStyle: 'small';     icon: (self iconNamed: #upIcon);     help: 'Move this item up from one element'.  downButton     addStyle: 'small';     icon: (self iconNamed: #downIcon);     help: 'Move this item down from one element'.  topButton     addStyle: 'small';     icon: (self iconNamed: #topIcon);     help: 'Move this item on the first position of the list'.  bottomButton     addStyle: 'small';     icon: (self iconNamed: #bottomIcon);     help: 'Move this item on the last position of the list'checkboxDisabled  ^checkboxDisabledhasChildrenBlock: aBlock  hasChildrenBlockHolder value: aBlockokAction: aBlock  okBlock := aBlockinitialize  self class initializeSlots: self.  super initialize.  currentValue := 0beVertical  direction := SpLayoutDirection verticalwindowIsOpening  self model windowIsOpeningproperty: aName rawValue: anObject  (self observablePropertyNamed: aName) rawValue: anObjectgenerateElements  | elements |  elements := OrderedCollection new.  self addSelf: elements.  self showClass ifTrue: [ self addClass: elements ].  self showAllInstVars ifTrue: [ self addAllInstVars: elements ].  self addSpecialFields: elements.  self addInstancesVariable: elements.  self addVariableFields: elements.  ^elementsnewDropList  ^self instantiate: SpDropListPresentermodel: anObject  model := anObjectprogression  ^progressionlabel  ^'all inst vars'textStyler: aTextStyler  textStyler := aTextStylerhasContentToShow  ^hasContentToShow valuedisplay  ^tree displaytestCustomFocusOrder  mock := SpMockFocusOrderPresenter new.  mock focusOrder     add: (mock presenterAt: #thirdPresenter);     add: (mock presenterAt: #firstPresenter);     add: (mock presenterAt: #secondPresenter).  mock openWithSpec.  self takeKeyboardFocus: mock.  self assert: (mock presenterAt: #thirdPresenter) equals: self focusedPresenter.  self pressTab.  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenter.  self pressTab.  self assert: (mock presenterAt: #secondPresenter) equals: self focusedPresenter.  self pressTab.  self assert: (mock presenterAt: #thirdPresenter) equals: self focusedPresentertestRemovingIconsAfterAddingThem  #(pharo add book) do: [:each |  self presenter addItemLabeled: each do: [  ] icon: (self iconNamed: each) ].  self presenter selectItem: nil.  self presenter model removeAll.  #(pharo add book) do: [:each |  self presenter addItemLabeled: each do: [  ] icon: nil ].  self assert: self adapter selectedIndexes equals: #(1).  backendForTest assertIcon: self adapter displayedIcon equals: nilprogressBarMorph  ^SpIndeterminatedProgressBarMorphnewHSplitterAt: aPosition  self widgetDo: [:w |  w newHSplitterAt: aPosition ]ownerChanged  super ownerChanged.  self expandRootselementAt: rowIndex  ^self listModel at: rowIndexpresenterProvider  ^presenterProviderbottomFraction  ^bottomFractionunselectIndex: anIndex  self selectIndexes: (self selectedIndexes copyWithout: anIndex)strongSelectionChanged: aFTStrongSelectionChanged  self presenter activatesOnDoubleClick ifFalse: [ ^self ].  self presenter doubleClickAtPath: self selectedPathfootnoteArea: aTextOrPresenter  footnoteArea := aTextOrPresentertransmission  ^self selectedItemresetSelection  ^self dropList resetSelectionbeMultipleSelection  self selectionMode: (SpTreeMultipleSelectionMode on: self)sortByColumn: aColumn event: anEvent morph: aMorph  aColumn sortDataSource: selfclick  self toggleStateallowToSelect: aBoolean  self deprecated: 'Should not use. Use #selectionMode: instead'.  allowToSelect := aBoolean.  aBoolean ifFalse: [ self resetSelection ]whenSortingBlockChangedDo: aBlock  self model whenSortingBlockChangedDo: aBlockselectedItem  ^associationsWrapperToItem at: listPresenter selectedItem ifAbsent: [ nil ]vAlign  ^vAlignwhenSearchChangedDo: aBlock  self property: #searchEnabled whenChangedDo: aBlockapplication  ^self owner applicationinitializePresenter  self property: #extent whenChangedDo: [:ex |  self withAdapterDo: [:widget |  (widget respondsTo: #extent:) ifTrue: [ widget extent: ex ] ] ]color  ^Color r: redSlider value g: greenSlider value b: blueSlider value range: 255initializePrivateAnnouncements  self property: #titleHolder whenChangedDo: [ self updateTitle ]initializePresenters  listPresenter := self newList.  searchPresenter := self newTextInput.  searchPresenter     autoAccept: true;     placeholder: 'Filter'openModalWithSpec  ^self application openModal: self withSpecLayout: self retrieveDefaultSpecshortcutText  | shortcut |  shortcut := self shortcut.  shortcut isString ifTrue: [ shortcut := self defaultModifierShortcut ].  ^shortcut ifNotNil: [ KMShortcutPrinter toString: shortcut ] ifNil: [ nil ]when: anAnnouncement do: aBlock  self widgetDo: [:w |  w announcer when: anAnnouncement do: aBlock ]selectedContact  ^table selection selectedItemwithinRangeIndex: anIndex  | indexToSelect |  indexToSelect := anIndex.  self model at: indexToSelect ifAbsent: [ indexToSelect := 0 ].  ^indexToSelecttestIncreasedValueFrom  presenter     beInteger;     maximum: 100;     climbRate: 2.  self assert: (adapter increasedValueFrom: '85') equals: '87'.  self assert: (adapter increasedValueFrom: '99') equals: '100'.  self assert: (adapter increasedValueFrom: '100') equals: '100'.  presenter     beFloat;     climbRate: 2.5;     digits: 1.  self assert: (adapter increasedValueFrom: '85') equals: '87.5'.  self assert: (adapter increasedValueFrom: '99') equals: '100.0'initializeTestedInstance  presenter roots: #(10 20 30)whenTabSelected: aBlock  tabSelectedActionHolder value: aBlockselectedObject  ^self selectedElement valueindexOfItem: anItem  ^self model indexOf: anItem ifAbsent: [ 0 ]pageAt: index  ^self pages at: indexisContactSelected  ^table selection selectedItem notNilpageChanged: ann  self model selectPage: ann page modelpassword: anObject  password := anObjecttestUnselectAllInWidgetRaisesEmptySelectionChangeEvent  | gotSelection |  self adapter selectPath: #(1).  presenter selection whenChangedDo: [:selection |  gotSelection := selection ].  self adapter selectPath: #().  self assertEmpty: gotSelectionleftOffset  ^leftOffsettestSmokeVerticalTest  self presenter beVerticalwhenPickedItemsChanged: aBlock  pickedItemsHolder whenChangedDo: aBlocktestSelectIndexThenSelectOutsideRangeKeepsFirstIndex  presenter selectIndex: 1.  presenter selectIndex: 50.  self assert: (presenter selection includesIndex: 1)name: anObject  name := anObjectaccessorCode  ^'(self at: ' , self index asString , ')'selectedMethod  self selectedMessage ifNil: [ ^nil ].  ^self selectedMessage compiledMethodrightClickAtIndex: anIndex  self clickItem: anIndex.  self halt.  ^self menu: nil shifted: falsegetTabs  ^[ self model tabs collect: [:each |  self buildTab: each ] ]whenAcceptOnCRChanged: aBlock  self deprecated: 'Use #whenAcceptOnCRChangedDo: instead.' transformWith: '`@receiver whenAcceptOnCRChanged: `@statements' -> '`@receiver whenAcceptOnCRChangedDo: `@statements'.  self whenAcceptOnCRChangedDo: aBlockbottomOffset: aNumber  layoutFrame bottomOffset: aNumberselectedClassIndex  ^classesListPresenter selectedIndexnewTab  self deprecated: 'Use newNotebook instead' on: '2019-01-24' in: #Pharo8.  ^self instantiate: SpTabPresentershowOnlyDestination  ^showOnlyDestinationinitialExtent  ^nilcolumns  ^columnscreateDevelopmentVersion  self hasAnyBaseline ifFalse: [ UIManager default inform: 'Please, define a baseline first'.        ^self ].  ^self createVersionForBlessing: #developmentperformDefaultSearch: item matching: pattern  | text |  text := (self searchValueOf: item) trimBoth asLowercase.  ^text beginsWith: patternadd: aBlock left: aNumber  self add: aBlock top: nil bottom: nil left: aNumber right: nilremoveContact: aCmContact  | confirm |  confirm := self confirm: ('Are you sure you want to remove {1} contact' format: {aCmContact name}) label: 'Remove the contact'.  confirm ifTrue: [ self contactBook removeContact: aCmContact ]helpText  ^nodeModel helpselectItems: aListOfItem  self selection selectItems: aListOfIteminitialize  super initialize.  closeOnBackdropClick := truetestContent  presenter content: SpListPresenter.  self assert: presenter subwidget class equals: SpListPresentertestPresentersBlockReceivesAthensCanvas  | receivedCanvas |  self presenter drawBlock: [:canvas |  receivedCanvas := canvas ].  self adapter redraw.  self openInstance.  1 second wait.  self assert: receivedCanvas isNotNil.  self assert: (receivedCanvas isKindOf: AthensCanvas)step  self presenter stepincomingTransmission: anObject from: outPort  self destinationPresenter label: anObjecttestBePasswordIsSet  presenter bePassword.  self assert: presenter isPasswordpresentersDo: aBlock  self basicPresenters valuesDo: aBlockvalue  ^valueopenInstance: aLayoutSelector  window := presenter openWithSpec: aLayoutSelectorisSplitter  ^falseprintOn: stream  super printOn: stream.  stream << '(' << self name << ')'explanation  ^explanationcentered  self withWindowDo: #centerednormalFillStyle  ^self theme splitterNormalFillStyleFor: selfcancelButton  ^windowPresenter addButton: 'Cancel' do: [:presenter |  presenter triggerCancelAction.        presenter close ]buildWidget  | button |  button := (SpToolBarButtonMorph on: self model getState: nil action: #execute)     helpText: self model help;     beIconTop;     hResizing: #rigid;     vResizing: #spaceFill;     borderWidth: 0;     borderColor: Color transparent;     cellPositioning: #center;     yourself.  ^buttoncheckboxWithColor: anObject  checkboxWithColor := anObjectcontactBook  ^self contactBookPresenter contactBookwrappedObject  ^wrappeddisplayBlock: aBlock  displayBlock := aBlockunselectPath: aPath  selection = aPath ifFalse: [ ^self ].  self clearSelectiontestSortingBlock  | count |  count := 0.  presenter whenSortingBlockChangedDo: [:sortFunction |  count := count + 1 ].  presenter items: #(3 8 1 0).  presenter sortingBlock: [:a :b |  a model < b model ].  self assert: count equals: 1.  self assert: (presenter model at: 1) model equals: 0updateTitle  self window title: self titletestSelectPresenterIndexSetsSelectedIndexInWidget  presenter selectIndex: 1.  self assert: (self adapter selectedIndexes includes: 1)beVerticalAlignmentEnd  self vAlign: SpGridAlignment endtestAddingColumnUpdatesWidget  self presenter addColumn: (SpStringTableColumn title: 'Value' evaluated: #printString).  self assert: self adapter columnCount equals: 3removePostscript  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  self model removePostscriptFrom: self selectedChangeSet.  changesListPresenter setSelectedItem: self selectedChangeSetsubwidget: anObject  subwidget := anObjectsetSelectedIndex: anIndex  listPresenter setSelectedIndex: anIndextestContextMenu  | menu changed |  self assert: presenter contextMenu isNil.  menu := SpMenuPresenter new.  changed := false.  presenter whenMenuChangedDo: [ changed := true ].  presenter contextMenu: menu.  self assert: presenter contextMenu equals: menu.  self assert: changedgetLabelSelector: aSelector  getLabelSelector := aSelector.  self update: getLabelSelectorx  ^xbeCancel  cancelled := truetext: aText  | truncatedText |  truncatedText := self maxLength = 0 ifTrue: [ aText ] ifFalse: [ aText first: (self maxLength min: aText size) ].  super text: truncatedTextinstallIconStylerFor: anItem  ((self isMethodDefinition: anItem) or: [ isShowingDiff not ]) ifFalse: [ ^self ].  IconStyler styleText: sourcePresenter withAst: anItem astdynamicPresenter: anObject  dynamicPresenter := anObjectcountNumberOfProportionals  self commands do: [:e |  e layoutFrame hasNoOffsets ifTrue: [ (e layoutFrame topFraction == 0 and: [ e layoutFrame bottomFraction == 1 ]) ifFalse: [ autoFractionComputation := false ].              numberOfProportionals := numberOfProportionals + 1 ] ]rootMenu  ^self owner rootMenunewPanelMorph  ^PanelMorph new     changeTableLayout;     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #spaceFill;     cellInset: self class defaultItemSeparation @ 0;     extent: 0 @ 0;     color: self color;     yourselfwhenMenuChangedDo: aBlock  menuBlockHolder whenChangedDo: aBlockrefreshList  self sortingBlock ifNotNil: [:aSortFunction |  collection sort: aSortFunction ]execute  self flag: 'Suspicious: is there not an more obvious/clean way of doing that?'.  self context adapter widget cancelinitialExtent  ^self model ifNil: [ super initialExtent ] ifNotNil: [:m |  m initialExtent ifNil: [ super initialExtent ] ]isDialog  ^falsenewLink  ^self instantiate: SpLinkPresenterstate  ^stateselectIndex: index  self presenter selection selectIndex: indexmorphHolder  ^morphHolderupdateAccordingTo: aFilter  (aFilter keepTreeNode: self) ifFalse: [ self changed: #updateAccordingTo: with: {aFilter} ]configButton  ^configButtoninitializeTestedInstance  super initializeTestedInstance.  presenter items: #(10 20 30)columnsCount: anObject  (anObject isInteger and: [ anObject > 0 ]) ifFalse: [ self error: 'A positive integer is expected as parameter.' ].  columnsCount := anObjecttestRightClickShowsMenu  | menu |  presenter contextMenu: (menu := SpMockMenuPresenter new).  self deny: menu shown.  self emulateRightClick.  self assert: menu shownbrowseClass: aClass  aClass browsetestAbsoluteValueToValueScales  self initMinMax.  self assert: (presenter absoluteValueToValue: 0.5) equals: 50messages: aCollection  self cacheHierarchyForClasses: aCollection.  listModel items: cachedHierarchy keys asOrderedCollection.  listModel listSize > 0 ifTrue: [ listModel selectIndex: 1 ]contents: anObject  contents := anObjectmouseDownAction  ^mouseDownAction valueconnectPresenters  listModel whenSelectionChangedDo: [:selection |  selection isEmpty ifTrue: [ textModel text: ''.              textModel behavior: nil.              toolbarModel method: nil ] ifFalse: [ | m |              m := selection selectedItem.              textModel text: m sourceCode.              textModel behavior: m methodClass.              toolbarModel method: m ] ].  self acceptBlock: [:t |  self listModel selectedItem inspect ].  self wrapWith: [:item |  item methodClass name , '>>#' , item selector ]addRadioButton: aButton  self linkRadioButton: aButton.  buttons add: aButton.  aButton     privateSetState: false;     owner: self.  self focusOrder add: aButton.  self rebuildWidgetvisitImageColumn: aTableColumn  self addCellColumn: aTableColumnclearUndoManager  self withAdapterDo: #clearUndoManageronAcceptEdition: aBlock  acceptAction := aBlockgetSelectionStateFor: anIndex  self deprecated: 'This method from the old API will be removed.'.  ^self model getSelectionStateFor: anIndexinitializePresenters  dropList := self instantiate: SpDropListPresenter.  button := self instantiate: SpButtonPresenter.  self focusOrder     add: dropList;     add: buttontestSelectingOutOfRangeKeepOldSelection  self presenter selection selectPath: #(2 3).  self presenter selection selectPath: #(7 3).  self assert: self adapter selectedItem equals: 20findClassFromSelection  ^self findClassFrom: self selectionOrLine trimmedsplitterNewSelector  ^layout isHorizontal ifTrue: [ #newHorizontal ] ifFalse: [ #newVertical ]whenReadSelectionIsChanged: aBlock  self deprecated: 'Use #whenReadSelectionIsChangedDo: instead.' transformWith: '`@receiver whenReadSelectionIsChanged: `@statements' -> '`@receiver whenReadSelectionIsChangedDo: `@statements'.  self whenReadSelectionIsChangedDo: aBlockrevert: aChangeRecord  aChangeRecord ifNil: [ ^self inform: 'nothing selected, so nothing done' ] ifNotNil: [ rgMethod realClass compile: aChangeRecord sourceCode classified: aChangeRecord category withStamp: aChangeRecord stamp notifying: nil ].  self setRGMethodFrom: rgMethod realClass >> rgMethod selector.  messageList     messages: self buildChangeList;     selectIndex: 1newDynamicPresentersListIn: accessorSymbol usingBuilder: aDynamicPresentersListBuilder  | mutatorSymbol newDynamicPresenter |  mutatorSymbol := (accessorSymbol , ':') asSymbol.  (self perform: accessorSymbol) ifNotNil: [:dynamicPresenter |  dynamicPresenter owner: nil ].  newDynamicPresenter := aDynamicPresentersListBuilder build.  self perform: mutatorSymbol with: newDynamicPresenter.  newDynamicPresenter owner: self.  self needRebuild: false.  self buildWithSpeccontents  ^morphHolder valuewithoutScrollBars  wrapScrollBars := falsepage  ^pagecontextMenu: aValuable  contextMenu := aValuablecurrentActivated: aRadioButton  currentActivated value: aRadioButtoninitialize  super initialize.  token := ''notifyPropertyChanged: aName  self flag: #todo.  (self observablePropertyNamed: aName) valueChangedtestGenerateUniqueInstanceVariableName  1 to: 10 do: [:i |  self assert: builder generateUniqueInstanceVariableName equals: (#var , i asString) asSymbol ]rightClicked  | evt |  evt := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent yellowButton buttons: MouseButtonEvent yellowButton hand: nil stamp: nil.  self widget click: evtsetWidgetLayoutWithNoOffset: widget at: index delta: delta  widget layoutFrame: ((currentProportional @ 0 corner: (currentProportional + delta) @ 1) asSpLayoutFrame leftOffset: currentOffset).  currentOffset := 0.  currentProportional := currentProportional + delta.  lastFractionIndex := indexisSelected: aBooolean  iconHolder  self deprecated: 'Use iconBlock instead' transformWith: '`@receiver iconHolder' -> '`@receiver iconBlock'.  ^self iconBlockconfigureButton: aButton item: aToolbarItem  aButton getLabelSelector: #label.  aButton badgeSelector: #badgeitemsInput: anObject  itemsInput := anObjectheaderAction  ^self model headerActionsetHasUnacceptedEdits: aBoolean  self widgetDo: [:w |  w basicHasUnacceptedEdits: aBoolean ]isResizeable: aBoolean  ^self widgetDo: [:w |  w isResizeable: aBoolean ]adapterName  ^#MillerAdapterregisterEventsForStyling  self whenBehaviorChangedDo: [:class |  self changed: #classOrMetaClass: with: {class}.        self changed: #getText ]add: aName withConstraints: aBlock  | constraints |  children size = 2 ifTrue: [ self error: 'You can not add more than two paned presenters.' ].  constraints := self constraintsClass new.  aBlock value: constraints.  children at: aName put: constraintsincludesItem: anItem  ^self selectedItem = anItemupdateListSelectionIndex  currentIcon ifNotNil: [ self removeMorph: currentIcon ].  super updateListSelectionIndex.  self selectedItem ifNotNil: [:item |  (self getIconFor: item) ifNotNil: [:icon |  currentIcon := icon asMorph.              self addMorphFront: currentIcon ] ]pageClass  ^SpDemoListsPresenternewRichText  ^self instantiate: SpRichTextPresenteraccessorCode  ^self labeladd: aButtonPresenter  (items at: #start ifAbsentPut: [ OrderedCollection new ]) add: aButtonPresentermenu  ^menumouseClick: evt onBackdrop: aMorph  self closeOnBackdropClick ifFalse: [ ^self ].  self model triggerCancelAction.  self model close.  aMorph deletetestUnselectSelectedItemRaisesSingleEvent  | counter |  counter := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectItem: 10.  self assert: counter equals: 1rightClicked  | evt |  evt := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent yellowButton buttons: MouseButtonEvent yellowButton hand: nil stamp: nil.  self widget click: evtinitializePresenter  super initializePresenter.  description whenTextIsAcceptedDo: [:newText |  self saveElement: newText.        self refreshDescription ]testSelectItemsOutsideRangeHasNoSelectedItems  presenter selectItems: {3000 .         4000}.  self assert: presenter selection selectedItems isEmptyuseInspectorAt: index  | types |  types := self inspectorTypes.  self inspectorType: (types at: (index min: types size max: 1))kmTable: anObject  kmTable := anObjectbuildWidgetPopup  ^self buildWidgetvalue  self action cull: self label cull: selfdefaultButtonId: anObject  defaultButtonId := anObjectwhenDisplayBlockChangedDo: aBlock  self property: #display whenChangedDo: aBlocknewContentMorph  ^PanelMorph new     roundedCorners: #(2 3 4);     changeTableLayout;     layoutInset: 4;     cellInset: 8;     vResizing: #spaceFill;     hResizing: #spaceFill;     borderStyle: (self theme tabPanelBorderStyleFor: self);     yourselfmenu: aMenu shifted: aBoolean  (aMenu add: 'Refresh' target: self selector: #collectAllShortcuts) icon: (self iconNamed: #smallUpdateIcon).  self kmTable selection selectedItem ifNil: [ ^aMenu ].  (aMenu add: 'Browse Definition' target: self selector: #browseDefinitionOfSelectedShortcut) icon: (self iconNamed: #smallSystemBrowserIcon).  (aMenu add: 'Inspect Action' target: self selector: #inspectActionOfSelectedShortcut) icon: (self iconNamed: #smallInspectItIcon).  ^aMenuinitialize  super initialize.  dragHand := ActiveHandaction  self presenter menu ifNotNil: [:aValuable |  aValuable value ifNotNil: [:aMenu |  aMenu owner: self presenter.              self showSubMenu: aMenu ] ].  self widget ifNotNil: [:m |  m takeKeyboardFocus ]checkboxWithLabelOnLeft  ^checkboxWithLabelOnLeftstyle  ^self styleExtent: 50 @ 20beResizable  self isResizable: truetestContextMenu  | menu changed |  self assert: presenter contextMenu isNotNil.  menu := SpMenuPresenter new.  changed := false.  presenter whenMenuChangedDo: [ changed := true ].  presenter contextMenu: menu.  self assert: presenter contextMenu equals: menu.  self assert: changedborderWidth  ^borderWidthselectedItem  ^self subclassResponsibilitybindKeyCombination: aShortcut toAction: aBlock  testChangingRootsUpdateWidget  self presenter roots: #(10 11 12).  backendForTest assertList: self adapter displayItems: #('10' '11' '12')searchValueOf: anObject  ^anObject asStringshortcutKey  ^self class defaultShortcutKeychildren: aBlock  childrenBlock := aBlockpressShiftTab  self keyPressed: Character tab asciiValue shift: true meta: false control: false option: false.  self waitUntilUIRedrawedtestChangeInInstanceVariableRaisesEventOnlyOnce  | count |  count := 0.  point property: #x whenChangedDo: [ count := count + 1 ].  point x: 17.  self assert: count equals: 1item  ^self dataSource elementAt: self rowIndextestColumnSpacing  | layout |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1.  self place: label2 at: 1 @ 2.  self place: morph2 at: 2 @ 2.  (layout := self newLayout) layout columnSpacing: 5.  layout layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 50 @ 20).  self assert: morph1 bounds equals: (55 @ 0 corner: 105 @ 20).  self assert: label2 bounds equals: (0 @ 20 corner: 50 @ 40).  self assert: morph2 bounds equals: (55 @ 20 corner: 105 @ 40)icons  ^icontestWhenIconsChangedDo  | icon counter |  counter := 0.  presenter whenIconsChangedDo: [:iconBlock |  icon := iconBlock cull: #add.        counter := counter + 1 ].  presenter icons: [:item |  Smalltalk ui icons iconNamed: item asSymbol ].  self assert: icon equals: (Smalltalk ui icons iconNamed: #add).  self assert: counter equals: 1basicAdd: aPresenter constraints: constraints to: aPanel  | childMorph |  childMorph := self buildMorph: aPresenter constraints: constraints.  aPanel addMorphBack: childMorph.  self addSplitterIn: aPanel for: childMorph.  ^childMorphbutton1  ^button1testSetSelectIndexOutsideRangeRaisesSelectionChangeEventWithUnsetIndex  | selectedIndex |  presenter whenSelectionChangedDo: [:selection |  selectedIndex := selection selectedIndex ].  presenter selectIndex: 4.  self assert: selectedIndex equals: 0initialize  self class initializeSlots: self.  super initialize.  shown := falsemainMessage  ^mainMessagegenderLabel  ^genderLabelstyles: aCollection  styles := aCollection asArrayhasScrollBars  ^wrapScrollBarscloseOnBackdropClick  ^self model closeOnBackdropClickentryCompletion  ^self model entryCompletionmenusRegistration  self menusRegistrationFrom: changeSorterLeft to: changeSorterRight.  self menusRegistrationFrom: changeSorterRight to: changeSorterLeftbuildWidget  ^SpWindow new     model: model;     isResizeable: self isResizeable;     in: [:this |  self subscribeToAnnouncements: this ];     yourselftestNullPresentersNeededFor  self assert: (layout nullPresentersNeededFor: presentersBuilder) equals: 0action  ^actionselectedItems  ^self list selectedItemsisNonEditableRow: aRow column: aColumn  ^truedisplayBlock: aBlock  self deprecated: 'Please use #display: instead' transformWith: '`@receiver displayBlock: `@arg' -> '`@receiver display: `@arg'.  display := aBlockshortcutsRegistration  self shortcutsRegistrationFrom: changeSorterLeft to: changeSorterRight.  self shortcutsRegistrationFrom: changeSorterRight to: changeSorterLeftbuildWidget  | checkButton |  checkButton := CheckboxMorph on: self selected: #state changeSelected: #state:.  checkButton     label: self label;     beCheckbox;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     setBalloonText: self help;     getEnabledSelector: #enabled;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     labelClickable: self labelClickable.  self presenter whenLabelChangedDo: [:newLabel |  checkButton label: newLabel ].  self presenter whenChangedDo: [ checkButton updateSelection ].  ^checkButtonsubwidgetArguments  ^subwidget asArraywindows  ^windows ifNil: [ windows := Set new ]isRendered  ^actualPageMorph notNilpropertyAt: aKey ifPresent: aBlock  ^self properties at: aKey ifPresent: aBlockselectedIndex  ^self presenter selection selectedIndexselectionHolder  ^self subclassResponsibilitybuttonWithDifferentFont: anObject  buttonWithDifferentFont := anObjectvisitCommand: aCmCommandEntry  aCmCommandEntry positionStrategy addButton: (SpToolBarButton new           label: aCmCommandEntry name;           help: aCmCommandEntry description;           icon: aCmCommandEntry icon;           action: [ aCmCommandEntry execute ];           yourself) toToolbar: self toolbarPresenterselectionInterval: anInterval  selection := anIntervaltraverseInFocusOrderDo: aBlock excluding: excludes  self presentersInFocusOrder do: [:each |  each traverseInFocusOrderDo: aBlock excluding: excludes ]model  ^modeldoItReceiver  ^self model doItReceiverfirstVisibleRowIndex  ^firstVisibleRowIndexstrongSelectionChanged: aFTStrongSelectionChanged  self presenter activatesOnDoubleClick ifFalse: [ ^self ].  self presenter doubleClickAtIndex: aFTStrongSelectionChanged selectedIndexleftItems  ^leftItemsclassListAction  classList transmitTo: methodList transform: [:selectedClass |  selectedClass ifNotNil: [ self methodsFromClass: selectedClass ] ifNil: [ #() ] ] postTransmission: [:destination |  destination selectIndex: 1 ].  classList transmitTo: protocolList transform: [:selectedClass |  selectedClass ifNotNil: [ self isInstanceSideSelected ifTrue: [ selectedClass organization allProtocols as: OrderedCollection ] ifFalse: [ selectedClass class organization allProtocols as: OrderedCollection ] ] ifNil: [ #() ] ] postTransmission: [:protcolList |  protocolList selectIndex: ((protcolList items collect: #name) indexOf: '-- all --') ]source: aBlock  source := aBlock valuesetModal: aWindow  self deprecated: 'Do not use this directly. Use #openModalWithSpec (and family) instead.' on: '2019-02-26' in: #Pharo8.  self changed: #setModal: with: {aWindow}testAddTabUnopened  self assertCollection: presenter tabs hasSameElements: #().  presenter addTab: redTab.  self assertCollection: presenter tabs hasSameElements: {redTab}execute  Smalltalk tools transcript open.  self contactBook contents do: [:contact |  self traceCr: contact name , ' - ' , contact name ]extent: aPoint  extent := aPointensureKeyBindingsFor: aWidget  super ensureKeyBindingsFor: aWidget.  self registerChangeSetShortcuts: changesListPresenter.  self registerClassShortcuts: classesListPresenter.  self registerMethodShortcuts: methodsListPresentertestSetSelectPathRaisesSelectionChangeEventWithSelectedItem  | selectedItems |  presenter whenSelectionChangedDo: [:selection |  selectedItems := selection selectedItems ].  presenter selectPath: #(1 3).  self assert: (selectedItems includes: 10)testSubscribeToExistentNonObservablePropertyRaisesError  self should: [ point property: #y whenChangedDo: [ self fail: 'This event shouldnt have been subscribed at all' ] ] raise: SpNonObservableSlotErrortestJulianDaysIntervalFor3  | interval |  interval := calendar julianDaysIntervalFor: (Date year: 2018 month: 9 day: 1).  self     assert: interval size equals: calendar daysToDisplayCount;     assert: interval equals: ((Date year: 2018 month: 8 day: 26) julianDayNumber to: (Date year: 2018 month: 10 day: 6) julianDayNumber)entitiesEntryCompletion  ^EntryCompletion new     dataSourceBlock: [:currText |  self possibleEntities collect: [:each |  each perform: self displaySymbol ] ];     chooseBlock: [:selectedName |  self entity: (self possibleEntities detect: [:each |  (each perform: self displaySymbol) = selectedName ]) ];     filterBlock: [:currEntity :currText |  currEntity asUppercase includesSubstring: currText asString asUppercase ]testVisitCommandThatCantBeRunWithDisableStrategy  self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.  (CmBlockCommand new     name: 'c';     description: 'desc';     context: [ 41 ];     canBeExecutedBlock: [:x |  x = 42 ];     block: [:x |  42 ];     yourself) asSpecCommand acceptVisitor: menuBuilder.  self assert: menuBuilder menuPresenter defaultGroup menuItems size equals: 1radio3  ^radio3testSelectIndexOutsideRangeUnsetsSelectedIndex  presenter selectIndex: 4.  self assert: (presenter selection includesIndex: 0)topOffset: anObject  topOffset := anObjectbasicSelectIndex: indexToSelect  self subclassResponsibilityadd: aName expand: shouldExpand  ^self add: aName withConstraints: [:constraints |  constraints expand: shouldExpand ]focusOrder: anObject  ^focusOrder := anObjectcolumns: aCollection  tree columns: aCollectionbeHorizontal  direction := SpLayoutDirection horizontalimplementorsModel  ^implementorsModelsetModelBeforeInitialization: aContactBook  super setModelBeforeInitialization: aContactBook.  contactBook := aContactBookwhenSelectionChangedDo: aBlock  self selection whenChangedDo: [ aBlock cull: selectionMode ]value  ^self host classcolumns: aCollection  columns value: aCollectionbuildWidget  ^SpStubImageView newadd: aName at: aPoint  ^self add: aName at: aPoint span: 1 @ 1title  ^self class title , ' [' , messageList numberOfElements printString , ']'hasChildrenBlock  ^self model hasChildrenicon: anIcon  icon := anIconhelpText  ^self widget helpTextclassToTest  ^SpListPresenterupdateTree  self treeModel resetRootNodes.  self treeModel changed: #rootNodesmodel: anObject  model := anObjectnullPresentersInstVarNamesAndPresenterNamesArray  ^(self nullPresentersInstVarNames inject: OrderedCollection new into: [:col :instVar |  col           add: instVar;           add: SpNullPresenter name;           yourself ]) asArraytraversePresentersDo: aBlock excluding: excludes  (excludes includes: self) ifTrue: [ ^self ].  excludes add: self.  aBlock value: self.  self class allSlots do: [:each |  | var |        var := self readSlot: each.        (var isKindOf: SpAbstractPresenter) ifTrue: [ var traversePresentersDo: aBlock excluding: excludes ] ]isFirstColumn: column  ^(table columns indexOf: column) = 1initializePresenters  kmTable := self newTable.  kmTable     addColumn: (SpStringTableColumn title: 'Shortcut' evaluated: [:aKMShortcutDeclaration |  aKMShortcutDeclaration realValue shortcut asString ]);     addColumn: (SpStringTableColumn title: 'Name' evaluated: #shortcutName);     addColumn: (SpStringTableColumn title: 'Category' evaluated: #categoryName);     beResizable;     menu: [:m :s |  self menu: m shifted: s ].  filterField := self newTextInput.  filterField     removeEntryCompletion;     placeholder: 'Filter';     autoAccept: true.  clearFilterButton := self newButton.  clearFilterButton     icon: (self iconNamed: #smallCancelIcon);     enabled: false.  self collectAllShortcutstestSetRootModelResetsToSinglePresenter  self presenter presenterBlock: [:model |  SpNullMillerPresenter on: (SpLabelPresenter new label: model asString) ].  3 timesRepeat: [ self presenter addPresenter: (SpNullMillerPresenter on: SpLabelPresenter new) ].  self presenter setRootModel: 1.  self assert: self presenter size equals: 1initialize  super initialize.  items := OrderedCollection new asValueHolder.  self property: #autoRefresh whenChangedDo: [:aBoolean |  self menuItems do: [:each |  each autoRefresh: aBoolean ] ]leftLabel: anObject  leftLabel := anObjectobjectAsHexString  ^String streamContents: [:s |  self object do: [:each |  s << (each printPaddedWith: $0 to: 2 base: 16) ] ] limitedTo: 5000initializeTestedInstance  observablePropertyNamed: aName  | slot |  slot := self class slotNamed: aName.  slot isObservableSlot ifFalse: [ SpNonObservableSlotError signal: aName ].  ^slot rawRead: selfshortcutCharacter  ^nilinitialize  super initialize.  self beResizable.  self beShrinkableclassToTest  ^SpLabelledTextInputencrypted: aBoolean  self deprecated: 'Use #bePassword: instead' transformWith: '`@receiver encrypted: `@arg' -> '`@receiver bePassword: `@arg'.  self bePassword: aBooleandefineInputPorts  ^{SpListItemsPort new}performSearch: item matching: pattern  ^searchBlock value: item value: patternprepareAsSortableColumn: aColumn  menu: aBlock  self deprecated: 'Use #contextMenu: instead. The old way to create a MenuPresenter was this method taking a MenuMorph as parameter. This will not work with other backend and will be totally removed in Pharo7. Now you should use #contextMenu takin a MenuPresenter (or a block returning a menu presenter) as parameter.' on: '2019-03-07' in: #Pharo8.  self contextMenu: [ aBlock cull: (MenuMorph new                 defaultTarget: self;                 yourself) cull: false ]diveInto: anObject  self owner ifNotNil: [:navigator |  (navigator respondsTo: #diveInto:) ifTrue: [ ^navigator diveInto: anObject ] ].  self inspectInNewWindow: anObjectbackgroundColorBlock: aBlock  self deprecated: 'Should not use. This feature is not supported anymore. This feature depends on the theme'hasImageAutoscaled  ^self widget layout = #scaledAspecttestHasProperty  self     assert: (themeDecorator hasProperty: #buttonNormalFillStyleFor:);     assert: (themeDecorator hasProperty: #buttonMouseOverFillStyleFor:);     assert: (themeDecorator hasProperty: #buttonPressedFillStyleFor:);     deny: (themeDecorator hasProperty: #controlButtonSelectedDisabledFillStyleFor:);     deny: (themeDecorator hasProperty: #scrollbarMouseOverBorderStyleFor:);     deny: (themeDecorator hasProperty: #scrollbarThumbCornerStyleIn:)acquireWidth: anOwnerWidth  ^self widthOrUndefined min: anOwnerWidthdenyHasHeader: anAdapter  | tableContainer |  self waitUntilUIRedrawed.  tableContainer := anAdapter widget submorphs first.  self assert: tableContainer submorphs size = 3takeKeyboardFocus  self presenter presentersInFocusOrder ifNotEmpty: [:presenters |  presenters first takeKeyboardFocus ]updateMenu  objectAtProperty: aSymbol  ^themeOverrideDict at: aSymbolparseSimpleValue  | char |  readStream atEnd ifFalse: [ char := readStream peek.        (self isStyleClassChar: char) ifTrue: [ ^self parseStyleClass ] ].  ^super parseSimpleValuetestNewPresenterIsNotBuilt  self deny: presenter isBuiltrestoreButton: anObject  restoreButton := anObjectbuildWidget  currentMorph := self presenter morph ifNil: [ Morph new color: Color transparent ].  self presenter whenMorphChangedDo: [:morph |  self applyStyle: morph.        currentMorph owner ifNotNil: [:ownerMorph |  ownerMorph replaceSubmorph: currentMorph by: morph ] ].  ^currentMorphselected: aBoolean  self nodeModel selected: aBooleanwhenMenuChanged: aBlock  self deprecated: 'Use #whenMenuChangedDo: instead.' transformWith: '`@receiver whenMenuChanged: `@statements' -> '`@receiver whenMenuChangedDo: `@statements'.  self whenMenuChangedDo: aBlockabsoluteValue  ^self presenter absoluteValueaddConstraits: constraints toChild: childMorph  | theMorph |  theMorph := childMorph.  theMorph setProperty: #constraints toValue: constraints.  ^theMorphbuildWidgetNoRefresh  ^ToggleMenuItemMorph new     contents: self name;     target: self;     selector: #performMenuActionWith:;     subMenu: self subMenu;     argumentsBlock: self actionArguments;     getStateSelector: self stateSelector;     icon: self icon;     enablementSelector: #enabled;     balloonText: self balloonText;     keyText: self shortcutText;     yourselfcolumnConstraintsAt: aNumber  ^layout columnConstraintsAt: aNumberwindow  ^windowdoubleClick: aBlock  tree doubleClick: aBlockbuildWidget  ^SpTreeNodeModel new     setItemFromBlock: self itemBlock;     icon: self icon;     setChildren: self childrenBlock;     hasContents: self hasChildrenBlock;     model: self container;     nodeModel: self modelwhenLabelChangedDo: aBlock  self property: #label whenChangedDo: aBlockaddButton: aString do: aBlock  ^self addButton: (SpButtonPresenter new           owner: self;           label: aString;           action: [ aBlock cull: self ];           yourself)presenterBlock: aBlockClosure  newPresenterBlock := aBlockClosurebackgroundColorBlock  self deprecated: 'Should not use. This feature is not supported anymore. This feature depends on the theme'delete  self withAdapterDo: #deletewhenActivationActionChanged: aBlock  self deprecated: 'Use #whenActivationActionChangedDo: instead.' transformWith: '`@receiver whenActivationActionChanged: `@statements' -> '`@receiver whenActivationActionChangedDo: `@statements'.  self whenActivationActionChangedDo: aBlocktransmission  ^self selectedItemevenRowColor: aColor  ^self widget rowColorForEven: aColortransferFor: passenger from: aMorph  ^(self model transferFor: passenger from: self table) buildWithSpechShrinkWrap  self widgetDo: [:w |  w hResizing: #shrinkWrap ]sortedKeys  ^[ [ self object valuesAndCounts keys sorted ] on: Error do: [ self object valuesAndCounts keys ] ] on: Error do: [ #() ]matchTokenFilterBlock  ^matchTokenFilter valueselectedPageIndex  | page |  page := self selectedPage.  page ifNil: [ ^0 ].  ^self pages indexOf: pagedefaultIconName  ^self class defaultIconNameimage2  ^image2actionBarPresenter  ^actionBarPresentertestHasShortcutKey  self deny: command hasShortcutKey.  command shortcutKey: $a asKeyCombination.  self assert: command hasShortcutKeyaddButton: id text: buttonText value: anObject  ^self addButton: id text: buttonText value: anObject condition: truecolumns  ^columnsconfigureMorph: aMorph item: itemPresenter  aMorph configureWith: self item: itemPresenterpresenterAt: aName  ^self basicPresenters at: aNameisExecutable  ^truefilteringBlock: aBlock  self deprecated: 'This feature is now removed from Spec 2. If the visible elements of the list need to be changed, it''s the users of the lists that should manage it and update the list of items of the list.'announceDisplayed  self announcer announce: (SpWidgetDisplayed new           presenter: self;           widget: (adapter ifNotNil: [ adapter widget ]);           yourself)whenSelectionChanged: aBlock  listPresenter whenSelectionChanged: aBlockrefreshingBlock: aBlock  refreshingBlock := aBlockperformDefaultSearch: item matching: pattern  | text |  text := (self searchValueOf: item) trimBoth asLowercase.  ^text beginsWith: patternitems: anItemList  list items: anItemListclassToTest  ^SpDynamicWidgetChangewhenSelectionChanged: aBlock  self dropList whenSelectionChanged: aBlockupdatePageContent: aPage  self changed: #updatePageContent: with: {aPage}askOkToClose: aBoolean  askOkToClose := aBooleantestColumnNotHomogeneousPairedRowsAndColumns  | layout |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1.  self place: label2 at: 1 @ 2.  self place: morph2 at: 2 @ 2.  layout := self newLayout.  layout layout beColumnNotHomogeneous.  (self styleExtent: 30 @ 20) applyTo: label1.  (self styleExtent: 50 @ 20) applyTo: morph1.  (self styleExtent: 40 @ 20) applyTo: label2.  (self styleExtent: 60 @ 20) applyTo: morph2.  layout layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 40 @ 20).  self assert: morph1 bounds equals: (40 @ 0 corner: 100 @ 20).  self assert: label2 bounds equals: (0 @ 20 corner: 40 @ 40).  self assert: morph2 bounds equals: (40 @ 20 corner: 100 @ 40)initialize  super initialize.  model := ChangeSorterModel new.  isRefreshing := false.  SystemAnnouncer uniqueInstance weak when: CurrentChangeSetChanged send: #updateTitle to: selfaddLast: aName expand: shouldExpand fill: shouldFill padding: aNumber  self addLast: aName withConstraints: [:constraints |  constraints           expand: shouldExpand;           fill: shouldFill;           padding: aNumber ]setUp  super setUp.  self error: 'Do not override me.... use #initializeTestedInstance'performDefaultSearch: item matching: pattern  | text |  text := (self searchValueOf: item) trimBoth asLowercase.  ^text beginsWith: patternicon  ^widget label iconlayout  | mainLayout row |  mainLayout := SpBoxLayout newVertical.  contentArea ifNotNil: [ mainMessage ifNotNil: [ mainMessagePresenter := (mainMessage isString or: [ mainMessage isText ]) ifTrue: [ self newLabel label: mainMessage ] ifFalse: [ mainMessage ].              mainLayout add: #mainMessagePresenter ] ].  row := SpBoxLayout newHorizontal.  mainIcon ifNotNil: [ mainIconPresenter := self newImage image: self mainIcon.        row add: #mainIconPresenter withConstraints: [:constraints |  constraints width: self mainIcon width * 2 ] ].  contentArea ifNotNil: [ contentAreaPresenter := (contentArea isString or: [ contentArea isText ]) ifTrue: [ self newLabel label: contentArea ] ifFalse: [ contentArea ].        row add: #contentAreaPresenter ] ifNil: [ mainMessage ifNotNil: [ mainMessagePresenter := (mainMessage isString or: [ mainMessage isText ]) ifTrue: [ self newLabel label: mainMessage ] ifFalse: [ mainMessage ].              row add: #mainMessagePresenter ] ].  mainLayout add: row.  row := SpBoxLayout newHorizontal.  moreOptionsArea ifNotNil: [ moreOptionsButton label: (moreOptionsVisible ifFalse: [ self moreOptionsText ] ifTrue: [ self lessOptionsText ]).        moreOptionsButton icon: (self iconNamed: (moreOptionsVisible ifFalse: [ #arrowDown ] ifTrue: [ #arrowUp ])).        row add: #moreOptionsButton.        moreOptionsAreaPresenter := (moreOptionsArea isString or: [ moreOptionsArea isText ]) ifTrue: [ self newLabel label: moreOptionsArea ] ifFalse: [ moreOptionsArea ] ].  buttons keysAndValuesDo: [:buttonKey :aButton |  row add: buttonKey ].  mainLayout add: row.  moreOptionsVisible ifTrue: [ mainLayout add: #moreOptionsAreaPresenter ].  footnoteArea ifNotNil: [ row := SpBoxLayout newHorizontal.        footnoteIcon ifNotNil: [ footnoteIconPresenter := self newImage image: footnoteIcon.              row add: #footnoteIconPresenter withConstraints: [:constraints |  constraints width: self footnoteIcon width * 2 ] ].        footnoteAreaPresenter := (footnoteArea isString or: [ footnoteArea isText ]) ifTrue: [ self newLabel label: footnoteArea ] ifFalse: [ footnoteArea ].        row add: #footnoteAreaPresenter ].  mainLayout add: row.  defaultButtonId ifNotNil: [ (self buttonAt: defaultButtonId) takeKeyboardFocus ].  ^mainLayouthasPortNamed: aName  ^(self defineOutputPorts anySatisfy: [:each |  each name = aName ]) or: [ self defineInputPorts anySatisfy: [:each |  each name = aName ] ]initialize  super initialize.  activationBlock := [  ].  verticalAlignment := SpVerticalAlignment new.  self withScrollBars.  self model: self newEmptyModel.  self beSingleSelection.  self activateOnDoubleClick.  self registerEventsselectPageIndex: aNumber  self selectPage: (self pages at: aNumber)testAddButtonToActionBar  | actionBar button |  actionBar := SpActionBarPresenter new.  button := SpButtonPresenter new.  self assertEmpty: actionBar items.  CmUIRightPositionStrategy new addButton: button toActionBar: actionBar.  self assert: actionBar items size equals: 1.  self assert: (actionBar items includesKey: #end).  self assert: (actionBar items at: #end) size equals: 1.  self assert: (actionBar items at: #end) anyOne equals: buttonaction  ^actionnewToggleButton  ^self instantiate: SpToggleButtonPresentertestOnDateChosen  | mookChoseDate |  mookChoseDate := ChoseDate new.  mookChoseDate     calendar: StandardWindow new;     date: Date tomorrow.  presenter onDateChosen: mookChoseDate.  self assert: presenter date equals: Date tomorrowautoAccept  ^self model autoAcceptblock: anObject  block := anObjectvShrinkWrap  self widgetDo: [:w |  w vResizing: #shrinkWrap ]selectionChanged: ann  | diff |  self presenter selection isMultipleSelection ifTrue: [ self presenter selection selectIndexes: (ann newSelectedIndexes reject: [:e |  e = 0 ]) ].  self presenter selection isMultipleSelection ifFalse: [ self presenter selection selectIndex: (ann newSelectedIndexes ifNotEmpty: [:indexes |  indexes first ] ifEmpty: [ 0 ]) ].  diff := ann newSelectedIndexes difference: ann oldSelectedIndexes.  (diff notEmpty and: [ self presenter activatesOnSingleClick ]) ifTrue: [ self presenter doActivateAtIndex: diff last ].  ann newSelectedIndexes ifNotEmpty: [ ^self ].  self presenter selection unselectAllokAction: aBlock  okAction := aBlockcollectAllShortcuts  self kmTable items: self shortcutssetInvokingView: aRubTextEditor  registerChangeSetShortcuts: aWidget  aWidget bindKeyCombination: PharoShortcuts current browseShortcut toAction: [ self selectedChangeSet ifNotNil: [ self browseChangeSet ] ].  aWidget bindKeyCombination: $b meta shift toAction: [ self selectedChangeSet ifNotNil: [ self openChangeSetBrowser ] ].  aWidget bindKeyCombination: $m meta toAction: [ self selectedChangeSet ifNotNil: [ self setCurrentChangeSet ] ].  aWidget bindKeyCombination: $n meta toAction: [ self selectedChangeSet ifNotNil: [ self newSet ] ].  aWidget bindKeyCombination: $o meta toAction: [ self selectedChangeSet ifNotNil: [ self fileOut ] ].  aWidget bindKeyCombination: $r meta toAction: [ self selectedChangeSet ifNotNil: [ self rename ] ].  aWidget bindKeyCombination: $p meta toAction: [ self selectedChangeSet ifNotNil: [ self addPreamble ] ].  aWidget bindKeyCombination: PharoShortcuts current removeShortcut toAction: [ self selectedChangeSet ifNotNil: [ self remove ] ].  aWidget bindKeyCombination: $f meta toAction: [ self findChangeSet ]badgeFont  ^badgeFont ifNil: [ badgeFont := self newBadgeFont ]connectPresenters  changeSorterLeft whenChangesListChanges: [ self refeshedChangeSet: changeSorterRight ].  changeSorterRight whenChangesListChanges: [ self refeshedChangeSet: changeSorterLeft ]testUnselectSelectedItemRemovesSelection  presenter     selectItem: 10;     unselectItem: 10.  self assert: presenter selection isEmptyupdate: aSymbol  self changed: aSymbolisMenuPresenter  ^falseinitialize  super initialize.  newPresenterBlock := [:model |  Error signal: 'should provide a new presenter block' ]testSelectIndexOutsideRangeIsEmpty  presenter selectIndex: 4.  self assert: presenter selection isEmptyverticalAlignment  ^verticalAlignmenthasWidget: aMorphicButtonAdapter  ^self widget hasWidget: aMorphicButtonAdapter widgetupdateModelToMoment: aTick  updateBlock cull: aTick.  self adapter ifNotNil: [ self adapter updateModelToMoment: aTick ]offsets  self flag: #fix.  ^layoutFrame leftOffset @ layoutFrame topOffset corner: layoutFrame rightOffset @ layoutFrame bottomOffsettestLayoutIn  (self class localSelectors reject: [:each |  each = #testLayoutIn ]) select: [:each |  each beginsWith: 'test' ] thenDo: [:each |  self setUp.        self perform: each.        self tearDown ]updateModelToMoment: tick  self widget changednumber2: anObject  number2 := anObjectstyleSheet: aStyleClass  ^self propertyAt: #styleSheet put: aStyleClasscontextClass: aClass  self widgetDo: [:w |  w           contextClass: aClass;           updateText ]contents: aMorph  morphHolder value: aMorphbuildWidget  | toolBarMorph |  toolBarMorph := SpToolBarMorph new.  self addModelTo: toolBarMorph.  ^toolBarMorphhorizontalAlignment  ^hAlignwhenTextStylerChangedDo: aBlock  self property: #textStyler whenChangedDo: aBlocktestClearContent  self initializationText.  self denyEmpty: presenter text.  presenter clearContent.  self assertEmpty: presenter textdaysButtons: anObject  daysButtons := anObjectlookupClass: name  ^classes at: name ifAbsentPut: [ SpStyle allSubclasses , Color withAllSubclasses detect: [:class |  class isMeta not and: [ class stonName = name ] ] ifNone: [ NotFound signalFor: name ] ]click  self isEnabled ifFalse: [ ^self ].  ^self performActionproperty: aName whenChangedDo: aBlockClosure  (self observablePropertyNamed: aName) whenChangedDo: aBlockClosurebeDecrypted  self deprecated: 'Use #beText instead' transformWith: '`@receiver beDecrypted' -> '`@receiver beText'.  self beTextwhenNumberChangedDo: aBlock  self whenTextChangedDo: [:txt |  aBlock value: self number ]buildFor: aDynamicPresentersListBuilder  aDynamicPresentersListBuilder createNullPresenters: (self nullPresentersNeededFor: aDynamicPresentersListBuilder).  ^self buildLayoutFor: aDynamicPresentersListBuilderaddButton: id text: buttonText value: anObject condition: aCondition  | aButton |  aButton := self newButton label: buttonText.  aButton action: [ aCondition value ifTrue: [ self return: anObject ] ].  buttons at: id put: aButton.  self presenterAt: id put: aButtonsetUp  super setUp.  presenter     roots: #(1 2 3);     children: [:aNumber |  aNumber < 100 ifTrue: [ (aNumber * 10 to: aNumber * 10 + 10) asArray ] ifFalse: [ #() ] ]autoAccept: aBoolean  ^self model autoAccept: aBooleanwhen: anAnnouncement do: aBlock  self subclassResponsibilitywhenSelectionIndexesChanged: aBlock  self deprecated: 'Use #whenSelectionChangedDo: instead' transformWith: '`@receiver whenSelectionIndexesChanged: `@argument' -> '`@receiver whenSelectionChangedDo: [ :selection | `@argument value: selection selectedIndexes ]'.  self whenSelectionChangedDo: [:selection |  aBlock value: selection selectedIndexes ]testChangingIconAffectTheWidget  presenter iconName: #pharo.  self assertIcon: self adapter icon equals: (self iconNamed: #pharo)selection  ^selectionwhenSelectedIndexChangedDo: aBlock  self deprecated: 'Use #selection whenChangedDo: instead' transformWith: '`@receiver whenSelectedIndexChangedDo: `@argument' -> '`@receiver selection whenChangedDo: [ :selection | `@argument value: selection selectedIndex ]'.  ^self selection whenChangedDo: [:selection |  aBlock value: selection selectedIndex ]initializeTSearchable  self searchMatching: [:item :pattern |  self performDefaultSearch: item matching: pattern ]isMultipleSelection  ^falsestyleClass  ^SpStyleClassaddStyle: aStyle  styles := styles copyWith: aStyleisForSmalltalkCode: aBoolean  testUnselectNonSelectedPathDoesNotRemovesSelection  presenter     selectPath: #(1 1);     unselectPath: #(1 3).  self assert: presenter selection selectedPath equals: #(1 1)addColumn: aColumn  columns := columns copyWith: aColumnwhenSelectedItemChanged: aBlock  self deprecated: 'Use #whenSelectedItemChangedDo: instead.' transformWith: '`@receiver whenSelectedItemChanged: `@statements' -> '`@receiver whenSelectedItemChangedDo: `@statements'.  self whenSelectedItemChangedDo: aBlockadapter  ^adaptercreateNewSet  ^ChangeSet newChangeSetelements  ^#()interpretASpec: aSpec  aSpec ifNil: [ ^nil ].  (self extractArrayToInterpretFrom: aSpec) ifNotNil: [:result |  ^result ].  (self retrieveSpecFrom: aSpec) ifNotNil: [:instance |  ^instance ].  index := 2.  [ index <= arrayToInterpret size ] whileTrue: [ | newInstance |        newInstance := self performNextSelectorAndIncrementIndex.        index > arrayToInterpret size ifTrue: [ ^self returnInterpretationOf: newInstance ].        spec := newInstance ].  self assert: arrayToInterpret size < 2.  self presenter spec: spec.  ^specselectItems: aCollection  self subclassResponsibilityvalueChanged: oldValue  subscriptions do: [:block |  block cull: self value cull: oldValue ]basicPresenters  ^presenters ifNil: [ presenters := OrderedDictionary new ]modelObjects  ^instVarToModelObject collect: #valuebeText  self displayMode: SpToolBarDisplayMode modeLabelhost: anObject  host := EyePointerWrapper wrap: anObjectlabel  ^labelbeHorizontal  isHorizontal := truebuildWidget  | radioButton |  self presenter isInitialStateSet ifFalse: [ self presenter property: #state rawValue: false.        self presenter associatedRadioButtons do: [:each |  each property: #state rawValue: false ] ].  radioButton := CheckboxMorph new     on: self selected: #state changeSelected: #state:;     getEnabledSelector: #enabled;     label: self label;     labelClickable: self labelClickable;     beRadioButton;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     setBalloonText: self help;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     yourself.  self presenter whenLabelChangedDo: [:newLabel |  radioButton label: newLabel ].  self presenter whenChangedDo: [ radioButton updateSelection ].  ^radioButtonnewRow: aBlock origin: originPoint corner: cornerPoint  self newRow: aBlock origin: originPoint corner: cornerPoint offsetOrigin: 0 @ 0 offsetCorner: 0 @ 0classToTest  ^self subclassResponsibilityopenOnInteger: anInteger  ui := SpOpenOnIntExample new: anInteger.  ui     extent: 100 @ 100;     openWithSpecaccessorCode  ^self descriptiontestSetSelectItemOutsideRangeRaisesSelectionChangeEventWithUnsetItem  | selectedItem |  presenter whenSelectionChangedDo: [:selection |  selectedItem := selection selectedItem ].  presenter selectItem: 4000.  self assert: selectedItem equals: nilwithScrollBars  wrapScrollBars := truedate  ^dateupdateTree  self changed: #updateTree with: {}.  treeUpdated value: nilinitializeDialogWindow: aDialogWindowPresenter  aDialogWindowPresenter initialExtent: 400 @ 200initializePresenters  super initializePresenters.  self content: SpDropListButtonreferencesToInstanceVariable  ^self systemNavigation browseAllAccessesTo: self instVarName from: self hostClassgetIconFor: aDropListItem  ^self model getIconFor: aDropListItemhasEditingConflicts  ^self widget ifNil: [ false ] ifNotNil: [:w |  w hasEditingConflicts ]save: aValue  elements  ^self model itemstestChangeListInPresenterUpdatesWidget  self presenter items: #('1' '2' '3').  backendForTest assertList: self adapter displayItems: #('1' '2' '3')transmission  ^self selectedItemsactForSpec  self subclassResponsibilityemptyList  ^self dropList emptyListwhenActionChangedDo: aBlock  self property: #action whenChangedDo: aBlocktestClickExecuteAction  | actionExecuted |  actionExecuted := false.  presenter action: [ actionExecuted := true ].  self emulateLeftClick.  self assert: actionExecutedinitialize  super initialize.  editable := falselabel: aString  label label: ' - ' , aString , ' - 'browseConfiguration  self configurationClass browsetestVisibilityWithBlockThatReturnsFalse  presenter visibleIf: [ false ].  self deny: self adapter isVisiblefirstVisibleRowIndex: anInteger  firstVisibleRowIndex := anIntegeraddSpecialFields: elements  elements add: (DynamicEyeElement host: self object label: 'ast' value: [ self object ast ]).  elements add: (DynamicEyeElement host: self object label: 'ir' description: [:value |  | string |              string := value longPrintString.              string copyFrom: 2 to: string size ] value: [ self object ir ]).  elements add: (DynamicEyeElement host: self object label: 'all bytecodes' value: [ self object symbolic ]).  elements add: (DynamicEyeElement host: self object label: 'header' value: [ self object headerDescription ]).  self object literals withIndexDo: [:literal :index |  elements add: (DynamicEyeElement host: self object label: 'literal ' , index asString value: literal) ]hasUnacceptedEdits: aBoolean  hasUnacceptedEdits := aBooleandataSource  ^dataSourcerightOffset: aNumber  layoutFrame rightOffset: aNumberclassToTest  ^SpAthensAnimatedPresentertoPort: aPort  toPort := aPortaddColumn: aColumn  columns := self columns copyWith: aColumnisExpanded  ^self nodeModel isExpandednumber1: anObject  number1 := anObjectinitialize  self class initializeSlots: self.  super initializemessage: anObject  message := anObjectrefreshWidgetSelection  emptyList  self dropList emptyListshortcutsRegistrationFrom: src to: dest  src changesPresenterOn: $c meta do: [ self copyAllFrom: src to: dest ].  src changesPresenterOn: $- meta do: [ self subtractFrom: src to: dest ]maxHeight  ^self lookupProperty: SpStyleGeometry valueOf: #maxHeightrightClicked  | evt |  evt := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent yellowButton buttons: MouseButtonEvent yellowButton hand: nil stamp: nil.  self widget click: evtinitializeDefaultActions  self okAction: [ cancelled := false.        self close ].  self cancelAction: [ cancelled := true.        self close ]initialize  super initialize.  contents := OrderedCollection newicon: anObject  icon := anObjectselection  self deprecated: '#selection was used to return an interval, and did not convey the correct meaning. Use #selectionInterval instead.' transformWith: '`@receiver selection' -> '`@receiver selectionInterval'.  ^self selectionIntervalspec: anAdapter  self flag: #TODO.  self adapter: anAdapterfieldNormal  ^fieldNormalicons  ^iconcurrentText  ^textPresenter getTexttoString: anItem  ^super toString: anItem databuttonWithColor  ^buttonWithColorinitialize  super initialize.  isUpdating := falseclassToTest  ^SpDropListPresenterchangeToList  self instantiatePresenters: #(bottom #SpListPresenter).  button font: (LogicalFont familyName: 'Source Sans Pro' pointSize: 10).  bottom items: (1 to: 100) asOrderedCollectionevaluateSelectionAndDo: aBlock  | selection |  selection := self selectionOrLine.  selection ifEmpty: [ ^'' ].  ^self evaluate: selection andDo: aBlockcontextKeyBindings  self flag: #TODO.  ^contextKeyBindingsquantum  ^self model quantumtestNextMonthButton  | d |  d := Date year: 2018 month: 9 day: 15.  calendar adaptToDate: d.  self assert: calendar monthYearLabel label equals: d month asString.  calendar nextMonthButton performAction.  self assert: calendar monthYearLabel label equals: (d addMonths: 1) month asStringresizable: aBoolean  resizable value: aBooleanclassToTest  ^SpApplicationWithToolbarinitialize  super initialize.  self     name: 'Remove';     description: 'Removes the selected contact from the contact book.'classToTest  ^SpTreeTablePresenterwindow  ^windowleftLabel: aText  self widgetDo: [:w |  w leftLabel: aText rightLabel: self rightLabel ]kmCategory  ^kmCategorywhenSelectionIndexChanged: aBlock  self deprecated: 'Use #whenSelectionIndexChangedDo: instead.' transformWith: '`@receiver whenSelectionIndexChanged: `@statements' -> '`@receiver whenSelectionIndexChangedDo: `@statements'.  self whenSelectionIndexChangedDo: aBlocktestSelectItemsAddsIndexesToSelectedIndexList  presenter selectItems: {10 .         20}.  self assert: (presenter selection includesIndexes: #(1 2))includesItem: anItem  ^self selectedItems includes: anItemselectedItem  self deprecated: 'Use the #selection object instead. This method assumes single selection' transformWith: '`@receiver selectedItem' -> '`@receiver selection selectedItem'.  ^self selection selectedItemnewPhone  | phone |  phone := self request: 'New phone for the contact' initialAnswer: self selectedContact phone title: 'Set new phone for contact'.  (phone matchesRegex: '\d\d\d\s\d\d\d') ifFalse: [ SpInvalidUserInput signal: 'The phone number is not well formated. Should match "\d\d\d\s\d\d\d"' ].  ^phoneinitializePresenters  addMorph: aMorph  paneMorphs add: aMorph.  ^super addMorph: aMorphafterSelectionInsertAndSelect: aString  | selection |  selection := self context selection.  self context insert: aString at: selection last + 1.  self context selection: (selection last + 1 to: selection last + aString size)newLabel  ^self instantiate: SpLabelPresenterfrom: aModel  source := aModelframe: rectangle  layout := rectangle asSpLayoutFrametestClickingRadio3DeselectsRadio2  self openInstance.  self presenter radio3 adapter clicked.  self deny: self presenter radio2 stateiconFor: anEyeElement error: error  ^self iconNamed: #smallWarningIconowner  ^ownerminHeight  ^self minExtent ifNotNil: [:aPoint |  aPoint y ]cancelled  ^cancelledisCheckList: aBoolean  self widgetDo: [:w |  w isCheckList: aBoolean ]testSelectMultiplePathsRaisesSelectionChangeEventMultipleTimes  | events |  events := 0.  presenter whenSelectionChangedDo: [:selection |  events := events + 1 ].  presenter selectPath: #(1).  presenter selectPath: #(1 3).  self assert: events equals: 2columnSpacing: anObject  columnSpacing := anObjectadd: aButtonPresenter  aButtonPresenter owner: self.  items add: aButtonPresentertestFocusRotationBackwards  mock := SpMockFocusOrderPresenter new     openWithSpec;     yourself.  self takeKeyboardFocus: mock.  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenter.  self pressShiftTab.  self assert: (mock presenterAt: #thirdPresenter) equals: self focusedPresenter.  self pressShiftTab.  self assert: (mock presenterAt: #secondPresenter) equals: self focusedPresenter.  self pressShiftTab.  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenterdoItContext: anObject  doItContext := anObjectproperty: aName whenChangedDo: aBlockClosure  (self observablePropertyNamed: aName) whenChangedDo: aBlockClosurelayoutFrame  ^layoutFrameincludesIndex: anIndex  self subclassResponsibilitytestPageAt  | page |  presenter addPage: self mockPage.  page := SpNotebookPage title: 'test' provider: [ SpButtonPresenter new ].  presenter addPage: page.  self assert: (presenter pageAt: 2) equals: pagetitle  ^'Spec UI Framework Demo'addLazyPage: aBlock label: aStringOrMorph collapsable: aBoolean  | newPage label |  newPage := SpNotebookPageMorph new.  newPage lazyPageMorphCreation: aBlock.  label := self buildLabelFrom: aStringOrMorph withAction: (aBoolean ifTrue: [ self newCloseButtonFor: newPage ] ifFalse: [ nil ]).  newPage labelMorph: label.  self addPage: newPage label: labelinitializePresenters  addModelTo: toolBarMorph  toolBarMorph displayMode: self presenter displayMode.  toolBarMorph height: self presenter displayMode height.  toolBarMorph setBalloonText: self presenter help.  self presenter whenItemsChangeDo: [ self updateItems: toolBarMorph ].  self updateItems: toolBarMorphindexOfItem: anItem  ^self allShownItems indexOf: anItemtakeHighlight  self changed: #takeHighlight with: #()internalGetText  | priorSource |  priorSource := (self priorVersionOfAMethod: method) ifNotNil: [:m |  m sourceCode ] ifNil: [ '' ].  ^Array with: priorSource with: method sourceCodetestLabelLeft  self openInstance: #labelLeftunselectAll  options do: #beUnselectedadapterName  ^#ScrollableAdapterinputPorts  ^self defineInputPorts collect: [:each |  each presenter: self ]retrievePresenter  activePresenter := self presenterProvider value.  retrievedBlock ifNotNil: [ retrievedBlock cull: activePresenter ].  ^activePresenterdiveIntoSelectedObject  self selectedObjectDo: [:anObject |  self diveInto: anObject ]getSelection  self deprecated: 'Use #selection instead.' transformWith: '`@receiver getSelection' -> '`@receiver selection'.  ^self selectionhighlightedItem  ^highlightedItem valueinput  ^inputtestPresenterPlaceholderIsSetInWidget  presenter placeholder: 'something'.  self assert: self adapter placeHolderText equals: 'something'addAllInstVars: elements  elements  ^{('name' -> self name) .   ('surname' -> self surname) .   ('number 1' -> self number1) .   ('number 2' -> self number2) .   ('scale' -> self scale) .   ('password' -> self password) .   ('rememberMe' -> self rememberMe) .   ('date' -> self date) .   ('gender' -> self gender) .   ('items' -> self selectedItems)}testDeactivateRaisesDeactivatedEvent  presenter state: true.  self assertEvent: #whenDeactivatedDo: isRaisedInPresenter: presenter whenDoing: [ presenter state: false ]buildToolBar  ^self newToolBar     addItem: self buildPushMessageToolBarItem;     addItem: self buildPopMessageToolBarItem;     addItem: self buildPopMessageToolBarItem position: SpToolBarItemPosition right;     yourselfproperty: aName whenChangedDo: aBlockClosure  (self observablePropertyNamed: aName) whenChangedDo: aBlockClosureitems: aCollectionOfButtonPresenters  items := OrderedCollection new asValueHolder.  aCollectionOfButtonPresenters do: [:each |  each owner: self ].  items addAll: aCollectionOfButtonPresentersentryCompletion: anEntryCompletion  entryCompletion := anEntryCompletiontoken  ^tokentestChangingLabelAffectTheWidget  presenter label: 'ALabel'.  self assert: self widget label equals: 'ALabel'announcer  ^announcer ifNil: [ announcer := Announcer new ]setBrowseButton  browseButton     state: false;     enabled: false;     label: 'Browse';     help: 'Browse the working copy of the selected package';     action: [ self browseWorkingCopy ]isHorizontal  ^self direction = SpLayoutDirection horizontalproperty: aName whenChangedDo: aBlockClosure  (self observablePropertyNamed: aName) whenChangedDo: aBlockClosureallowToSelect  self deprecated: 'Should not use. Use #selectionMode instead'.  ^allowToSelectwindowIcon: aForm  self deprecated: 'With Spec 2, SpPresenter was refactored to move all window management to WindowPresenter.	From now on, if you want to interact with a window you need to:	- Implement #initializeWindow: method (#initializeDialog: for dialogs) to manage window elements before the presenter is opened	- Use the method #window or #withWindowDo: to interact with windows after it has been opened.'.  self window ifNil: [ windowIcon := aForm ] ifNotNil: [:window |  window windowIcon: aForm ]cell  ^cellbuildWidget  ^SpStubTextInputFieldView newwantsDroppedMorph: draggedMorph event: anEvent inMorph: source  ^self wantDropBlock cull: draggedMorph cull: anEvent cull: sourceisDisplayed  ^truesave: aValue  self host basicAt: self index put: aValueitems: aCollection  baseItems := aCollection.  listPresenter items: aCollectionvalue  ^self host readSlotNamed: self instVarNamecurrentVerticalScrollPosition  ^currentVerticalScrollPositionmodel: anObject  model := anObjectperformHeaderAction  self headerAction cull: self model cull: selfconfigurationBlock  ^configurationBlockwhenTickDo: aBlock  self property: #ticks whenChangedDo: aBlockaction: aBlock  self button action: aBlockheaderColumn: column  column id ifNil: [ ^nil ].  ^FTCellMorph new     listCentering: #left;     addMorph: column id asMorph asReadOnlyMorph;     yourselfinitializePresenters  listPresenter := self newList.  listPresenter display: [:item |  item ].  self focusOrder add: listPresenterselectedElement  ^self subclassResponsibilityinitialPosition: aPoint  initialPosition := aPointbeHorizontal  direction := SpLayoutDirection horizontalaction  self showSubMenuIfPresent.  self widget ifNotNil: [:m |  m takeKeyboardFocus ].  self model performActioncheck  ^checktestWhenActionPerformedDo  | actionExecuted actionPerformed |  actionExecuted := false.  actionPerformed := false.  self assert: actionExecuted equals: false.  self assert: actionPerformed equals: false.  presenter action: [ actionExecuted := true ].  presenter whenActionPerformedDo: [ actionPerformed := true ].  self openInstance.  self assert: actionExecuted equals: false.  self assert: actionPerformed equals: false.  presenter adapter action.  self assert: actionExecuted equals: true.  self assert: actionPerformed equals: truetestUnselectAllRaisesSelectionEventOnce  | events |  events := 0.  presenter whenSelectionChangedDo: [:selection |  events := events + 1 ].  presenter unselectAll.  self assert: events equals: 1testDeactivatedCheckboxPresenterStartsDeactivatedCheckboxMorph  presenter state: false.  self deny: self adapter statetestSelectAllWithExistingSelectionLeavesSelection  presenter     selectIndex: 1;     selectAll.  self assert: (presenter selection includesIndex: 1)whenExtentChangedDo: aBlockClosure  self property: #surfaceExtent whenChangedDo: aBlockClosurecancelled  ^falseselectedIndex  ^self inspector selectedIndextestSelectItemThenSelectOutsideRangeKeepsSingleSelectedItem  presenter selectItem: 10.  presenter selectItem: 3000.  self assert: presenter selection selectedItems size equals: 1applyTo: aMorph  aMorph     width: (self geometryValueBetween: self extentOrDefault x and: aMorph width);     height: (self geometryValueBetween: self extentOrDefault y and: aMorph height).  self hResizing ifNotNil: [:aBoolean |  aMorph hResizing: (self resizingStringFor: aBoolean) ].  self vResizing ifNotNil: [:aBoolean |  aMorph vResizing: (self resizingStringFor: aBoolean) ]moveMethodFrom: src to: dest  self copyMethodFrom: src to: dest.  src forgetMessage.  src updateClassesListAndMessagesListspec  ^speclabelMorph  ^labelMorphnewImage  ^self instantiate: SpImagePresentertestValueToAbsoluteValueScales  self initMinMax.  self assert: (presenter valueToAbsoluteValue: 50) equals: 0.5changeToButton  self instantiatePresenters: #(bottom #SpButtonPresenter).  button font: (LogicalFont familyName: 'Source Sans Pro' pointSize: 9).  bottom label: 'I am useless'borderColor: aColor  borderColor := aColorrightLabel  ^rightLabelkeyStroke: anEvent fromMorph: aMorph  lookupProperty: aPropertyClass valueOf: aSymbol  (self propertiesLike: aPropertyClass) reverseDo: [:each |  (each perform: aSymbol) ifNotNil: [:value |  ^value ] ].  ^niladoptMenuGroupModel: aGroupModel first: aBoolean  | controls |  aBoolean ifFalse: [ widget           addMorphBack: (self theme newToolSpacerIn: widget);           addMorphBack: (self theme newToolbarHandleIn: widget);           addMorphBack: (self theme newToolSpacerIn: widget) ].  controls := OrderedCollection new.  aGroupModel menuItems do: [:item |  self adoptMenuItemModel: item accumulator: controls ].  self emptyAccumulator: controlsselectionChanged: ann  ^selectionHolder value: (ann selection ifNil: [ #() ] ifNotNil: [:selection |  selection selectedNodes ])setLayoutSizing  self     hResizing: #spaceFill;     vResizing: #rigidghostText  self deprecated: 'This API is too tight to Morph. Use #placeholder instead.' transformWith: '`@receiver ghostText' -> '`@receiver placeholder'.  ^self placeholdericon: anIcon  icon := anIconicon  ^iconwhenEntityChanged: aBlock  self property: #entity whenChangedDo: aBlockinitialize  super initialize.  history := NavigationHistory new.  self initializeShortcuts.  self property: #inspector whenChangedDo: [:new :old |  self updateInspectorFrom: old ].  self announcer when: SpWidgetBuilt send: #setRefreshedToTrue to: self.  canBeRefreshed := false.  self whenWindowChanged: [:w |  w whenClosedDo: [ self inspector close ] ]owner  ^ownertestSelectMultiplePathsRaisesSelectionChangeEventMultipleTimes  | events |  events := 0.  presenter whenSelectionChangedDo: [:selection |  events := events + 1 ].  presenter selectPath: #(1 1).  presenter selectPath: #(3).  self assert: events equals: 2ownerChanged  self     customMenuActions: self owner customMenuActions;     takeKeyboardFocusbeSingleSelection  self selectionMode: (SpSingleSelectionMode on: self)addAllInstVars: elements  pageClass  ^SpDemoTreeTablePresenterselectedItems  selection ifEmpty: [ ^#() ].  ^selection collect: [:path |  presenter itemAtPath: path ]selectAll  okAction: aBlock  ^okAction := aBlockposition: anObject  position := anObjectnewColumn: aBlock right: aNumber  self newColumn: aBlock left: nil right: aNumberbeEncrypted  ^self input beEncryptedicon: anIcon  icon := anIconrightOffset: anObject  rightOffset := anObjectbeMultipleSelection  ^self list beMultipleSelectionsubmit  self fillModelWithFormContent.  self model: workingModel.  self announcingObject valueChangedclassToTest  ^SpComponentListPresenterdelete  self withWindowDo: #deleteinitialize  super initialize.  items := Dictionary new asValueHolderaddItem: aBlock  | item |  item := self instantiate: SpMenuItemPresenter.  aBlock value: item.  self addMenuItem: itemisSplitter  ^truetestInstanceSideRadioButtonClickIsInstanceButtonShouldbeTrue  biChooseMethod radioButtonClassSide click.  self deny: biChooseMethod isInstanceSideSelected.  biChooseMethod radioButtonInstanceSide click.  self assert: biChooseMethod isInstanceSideSelectedupdatePageIndex: index  | oldPage |  index = 0 ifTrue: [ ^self ].  oldPage := self tabSelectorMorph selectedTab.  self pageMorph ifNil: [ self contentMorph addMorph: (self pageAt: index) ] ifNotNil: [:page |  | pageBounds |        pageBounds := self pageMorph bounds.        self contentMorph replaceSubmorph: page by: (self pageAt: index).        self flag: 'Without setting here the bounds the page moves a few pixels when refreshing the inspector'.        self pageMorph bounds: pageBounds.        self pageMorph layoutChanged ].  self headerMorph layoutChanged.  self pageMorph layoutChanged.  self adoptPaneColor: (self owner ifNil: [ self ]) paneColor.  (self tabSelectorMorph tabs at: index) font: self tabSelectorMorph font.  self announcer announce: (SpNotebookPageChanged new           page: (self pages at: index);           oldPage: oldPage;           pageIndex: index)widget  ^widgetactions  ^actionsHolder valuestepTime  ^self model stepTimetextModel: aModel  textModel := aModeltriggerOkAction  okAction ifNil: [ ^self ].  okAction cull: selfbrowserClientProvider  ^SystemNavigation defaultgetIconSelector: aSelector  getIconSelector := aSelector.  self update: getIconSelectormenu: aBlock  menuHolder value: aBlockbrowseChangeSet  | messages |  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  messages := self selectedChangeSet changedMessageList select: [:each |  each isValid ].  Smalltalk tools messageList browse: messages title: 'Methods in Change Set ' , self selectedChangeSet namehShrinkWrap  self subclassResponsibilitywhenSelectionChanged: aBlock  self dropList whenSelectionChanged: aBlocktransmitTo: aPresenter transform: aValuable postTransmission: postValuable  ^self newTransmission     from: self;     to: aPresenter;     transform: aValuable;     postTransmission: postValuable;     applychooseDate  | calendar defaultDate |  defaultDate := self date ifNil: [ self defaultDate ].  calendar := CalendarMorph openOn: defaultDate.  calendar     center: calendar cursorPoint;     fitInWorld;     onChoiceSend: #onDateChosen: to: selfensureKeyBindingsFor: aWidget  aWidget bindKeyCombination: PharoShortcuts current browseShortcut toAction: [ self browseMethod ].  aWidget bindKeyCombination: PharoShortcuts current inspectItShortcut toAction: [ self inspectMethod ].  aWidget bindKeyCombination: PharoShortcuts current browseImplementorsShortcut toAction: [ self browseMessages ].  aWidget bindKeyCombination: PharoShortcuts current browseSendersShortcut toAction: [ self browseSendersOfMessage ].  aWidget bindKeyCombination: PharoShortcuts current browseReferencesShortcut toAction: [ self browseClassRefs ].  aWidget bindKeyCombination: PharoShortcuts current browseVersionsShortcut toAction: [ self browseVersions ].  aWidget bindKeyCombination: PharoShortcuts current removeShortcut toAction: [ self removeMethods ]disableFilter  self itemFilter: nilpasswordInput: anObject  passwordInput := anObjectdefault: aButton  aButton privateSetState: true.  aButton takeKeyboardFocus.  aButton whenBuiltDo: [ aButton privateSetState: true ]dynamicLayout  | lay |  lay := SpLayout composed newColumn: [:column |  self basicPresenters keysDo: [:item |  column newRow: [:row |  row add: item ] ].        column newRow: [:row |   ] ].  self layout: lay.  ^layreceiverClass  ^self behaviorerrorPropertySelectors  ^#(icon label longLabel description)getIconSelector  ^getIconSelectorcontainerMorph  ^container morphrightFraction: anObject  rightFraction := anObjectsortFunction  ^sortFunctionaddClass: elements  elements add: (ClassEyeElement host: self object)newMenu  ^self instantiate: SpMenuPresentervalue  ^valueclassToTest  ^SpTreeTablePresenterrowHeight: rowIndex  rowIndex = 0 ifTrue: [ ^super rowHeight: rowIndex ].  ^(self widgetFor: (self elementAt: rowIndex)) heightaddPadding: aNumber toMorph: aMorph into: anAdapter  ^self subclassResponsibilityisColumnExpandable: colNumber  ^(layout columnConstraintsAt: colNumber) ifNotNil: [:c |  c isExpand ] ifNil: [ false ]setEditingModeFor: textArea withBehavior: aBehavior  aBehavior ifNotNil: [ textArea beForSmalltalkCodeInClass: aBehavior ] ifNil: [ textArea beForSmalltalkScripting ]takeKeyboardFocus  whenMaxLengthChangedDo: aBlockClosure  self property: #maxLength whenChangedDo: aBlockClosureiconFor: aNode  ^self model iconFor: aNodeclassToTest  ^SpImagePresenterhelpText  ^widget balloonTextsubpresenterNamed: aSelector  ^spec additionalSubpresentersMap at: aSelector ifAbsent: [ spec class allInstVarNames detect: [:var |  var = aSelector ] ifFound: [:var |  spec instVarNamed: aSelector ] ifNone: [ self error: spec asString , ' does not implement the method ' , aSelector , '. Maybe your spec reference a presenter that does not exists.' ] ]newRow: aBlock bottom: aNumber  self newRow: aBlock top: nil bottom: aNumberensureAtLeastOneColumnIn: tableMorph  self model columns ifNotEmpty: [ ^self ].  tableMorph addColumn: (self newColumnFrom: self defaultColumn)password  ^passwordbuildWidget  ^SpStubWindowView newminimum: aNumber  minimum := aNumberproperty: aName rawValue: anObject  (self observablePropertyNamed: aName) rawValue: anObjecttabs: anObject  tabs := anObjectunselectIndex: anInteger  self subclassResponsibilitysave: aValue  self host valuesAndCounts at: self index put: aValueicon  ^self presenter iconowner  ^ownerselection: anObject  selection := anObjecttestFindClassFrom  self assert: (presenter findClassFrom: '') equals: nil.  self assert: (presenter findClassFrom: 'Object') equals: Object.  self assert: (presenter findClassFrom: 'Object.') equals: Object.  self assert: (presenter findClassFrom: '.Object.') equals: Object.  self assert: (presenter findClassFrom: 'somethingBefore := 42.Object') equals: Object.  self assert: (presenter findClassFrom: 'somethingBefore := 42.Object. somethingAfter := 11') equals: Object.  self assert: (presenter findClassFrom: 'NonExistingClass.Object.') equals: ObjecttestSelectPresenterIndexOutsideRangeUnsetsSelectedIndexInWidget  presenter selectIndex: 100.  self assert: self adapter selectedIndexes isEmptyinitializePresenters  toolBar := self newToolBar     addItem: (SpToolBarButton new           label: 'Ok';           icon: (self iconNamed: #smallOk);           help: 'Ok';           action: [ self inform: 'Ok' ];           yourself);     addItem: (SpToolBarButton new           label: 'Cancel';           icon: (self iconNamed: #smallCancel);           help: 'Cancel';           action: [ self inform: 'Cancel' ];           yourself);     yourself.  text := self newTextcancelled  ^self toolbar cancelledselectItems: aCollection  self selectionMode selectItems: aCollectionactionWhenDeactivatedHolder  self deprecated: 'It breaks encapsulation'.  ^nilbasicSelectIndex: indexToSelect  indexToSelect = 0 ifTrue: [ ^self ].  self selectIndexes: (self selectedIndexes copyWith: indexToSelect)descriptionPresenter  ^descriptionPresentertestActivatedCheckboxPresenterStartsActivatedCheckboxMorph  presenter state: true.  self assert: self adapter stateexecute  | contact |  contact := self context newContact.  self hasSelectedContact ifTrue: [ self contactBook addContact: contact after: self selectedContact ] ifFalse: [ self contactBook addContact: contact ].  self contactBookPresenter updateViewproperty: aName whenChangedDo: aBlockClosure  (self observablePropertyNamed: aName) whenChangedDo: aBlockClosurehelp: aString  help := aStringmodel  ^modelnewButtonRow  ^self toolbar ifNotNil: [:t |  t buildWithSpec ]visitCommand: aCmCommand  aCmCommand context ifNotNil: [ ^self ].  aCmCommand context: self contexttempName: anObject  tempName := anObjectcolumnSpacing  ^columnSpacing ifNil: [ self class defaultColumnSpacing ]focusNext  self presenter withWindowDo: [:window |  | presenters |        presenters := window allPresentersInFocusOrder.        (presenters after: self presenter ifAbsent: [ presenters first ]) takeKeyboardFocus ]testVisitCommand  | commandsGroup |  commandsGroup := (CmCommandGroup named: 'root') asSpecGroup beRoot     register: (CmBlockCommand new           name: 'c1';           block: [  ];           context: 42;           yourself) asSpecCommand;     register: ((CmCommandGroup named: 'sub1') asSpecGroup           register: (CmBlockCommand new                 name: 'c2';                 block: [  ];                 context: 42;                 yourself) asSpecCommand;           register: (CmBlockCommand new                 name: 'c3';                 block: [  ];                 yourself) asSpecCommand);     register: (CmBlockCommand new           name: 'c4';           block: [  ];           yourself) asSpecCommand;     yourself.  self assert: (commandsGroup / 'c1') context equals: 42.  self assert: (commandsGroup / 'sub1' / 'c2') context equals: 42.  self assert: (commandsGroup / 'sub1' / 'c3') context isNil.  self assert: (commandsGroup / 'c4') context isNil.  SpRecursiveContextSetter visit: commandsGroup toSetContext: 43.  self assert: (commandsGroup / 'c1') context equals: 42.  self assert: (commandsGroup / 'sub1' / 'c2') context equals: 42.  self assert: (commandsGroup / 'sub1' / 'c3') context equals: 43.  self assert: (commandsGroup / 'c4') context equals: 43initialize  super initialize.  action := [  ]buildWidget  ^SpStubMenuItemView newiconBlock: aBlock  iconBlock := aBlockinspectorType  ^self inspector classdynamicPresenter: anObject  dynamicPresenter := anObjectbeBoth  self displayMode: SpToolBarDisplayMode modeIconAndLabeltransmitTo: aPresenter  ^self newTransmission     from: self;     to: aPresenter;     applyisMatching: anItem  ^dataSource model performSearch: anItem data matching: patternreadObject: anObject  ^self evaluation cull: anObjectselection  ^selectionMode valuetranslateSymbol: aSymbol  ^bindings at: aSymbol ifAbsent: [ aSymbol ]newMenuButton  ^self instantiate: SpMenuButtonPresenteraddPicked: item  pickedItemsHolder add: item.  pickedItemsHolder valueChanged: true to: itempositionPoint: aPoint  ^self subclassResponsibilitytestUnselectUnselectedItemKeepsSelectionList  presenter     selectItem: 10;     unselectItem: 20.  self assert: presenter selection selectedItems asArray equals: #(10)presenterAt: aName put: aPresenter  ^self basicPresenters at: aName put: aPresenterlastVisibleRowIndex: anInteger  lastVisibleRowIndex := anIntegernumberOfElements  ^listModel listSizebrowseClass  self deprecated: 'This method seems never called.'.  self currentMethod ifNotNil: [:method |  method methodClass browse ]okToChange  ^self model okToChangetestSelectingAnElementInWidgetUpdatePresenter  self adapter selectIndex: 2.  self assert: self presenter selectedItem equals: 20.  self assert: self adapter selectedIndexes equals: #(2)buildFileMenu  ^self newMenu     addItem: [:item |  item           name: 'Push message';           action: [ self pushMessage ] ];     addItem: [:item |  item           name: 'Pop message';           action: [ self popMessage ] ];     yourselfchildrenBlock: aBlock  tree childrenBlock: aBlockaddSplitterIn: aPanel for: childMorph  aPanel submorphs size = 1 ifFalse: [ ^self ].  aPanel addMorphBack: self direction newSplitterwhenCodeCompletionAllowedChangedDo: aBlock  self deprecated: 'Use #whenTextIsAcceptedDo: instead or nothing. Currently, both those methods are doing the same thing but my name is really missleading. Thus, I''ll be removed.' transformWith: '`@receiver whenCodeCompletionAllowedChangedDo: `@statements' -> '`@receiver whenTextIsAcceptedDo: `@statements'.  self whenTextIsAcceptedDo: aBlockproperty: aName whenChangedDo: aBlockClosure  (self observablePropertyNamed: aName) whenChangedDo: aBlockClosureinitializationText  presenter text: 'Text for tests.'enable  self enabled: truemodel: aModel  self deprecated: 'Model was renamed Presenter in Pharo 7' transformWith: '`@receiver model: `@statements1' -> '`@receiver presenter: `@statements1'.  self presenter: aModelmenuColumn: column row: rowIndex  | menuPresenter |  menuPresenter := self model contextMenu.  menuPresenter ifNil: [ ^nil ].  ^SpBindings value: self model application adapterBindings during: [ | m |        m := menuPresenter value.        m isMorph ifTrue: [ m ] ifFalse: [ m buildWithSpec ] ]testUnselectAllRaisesSelectionEventOnce  | events |  events := 0.  presenter whenSelectionChangedDo: [:selection |  events := events + 1 ].  presenter unselectAll.  self assert: events equals: 1contextClass: anObject  contextClass := anObjectadd: aSpec width: aNumber  self add: aSpec origin: 0 @ 0 corner: 1 @ 1 offsetOrigin: 0 @ 0 offsetCorner: aNumber @ 0selectorsMenu: aBlock  methodsListPresenter menu: aBlockcanTakeKeyboardFocus  ^truepropertyAt: aKey  ^self properties at: aKeypageClass  ^SpDemoNotebookPresenterdoubleClickAction: aBlockClosure  self deprecated: 'Use #whenActivatedDo: and #activateOnDoubleClick instead.'acceptColumnVisitor: aBuilder  ^aBuilder visitIndexColumn: selflistHeight  ^super listHeight + 12initialize  super initialize.  self     name: 'New contact';     description: 'Creates a new contact and add it to the contact book.'displayBlock: aBlock  ^self dropList displayBlock: aBlockbuildWidget  ^SpStubContainerView newcanDeselectByClick  self deprecated: 'It is not clear what option to select if deselected'.  ^falsetestSimpleLookup  | styleResolver |  styleResolver := self newLookup: '.application [ 		Geometry { #width: 42 } 	]'.  self assert: styleResolver width equals: 42testCloseDialogWindowRemovesItFromWindowCollection  | window |  window := (application newPresenter: SpButtonPresenter) openDialogWithSpec.  window close.  self deny: (application windows includes: window)acceptDropBlock  ^acceptDropBlockminHeight: aNumber  self minExtent: self minExtentOrDefault x @ aNumbertestSelectItemAddsItemToSelectedItemList  presenter selectItem: 10.  self assert: (presenter selection includesItem: 10)clickOnSelectedItem  | item |  item := self selection selectedItem.  (item notNil and: [ item respondsTo: #click ]) ifTrue: [ ^item click ] ifFalse: [ ^false ]addButtonLabel: aLabel iconNamed: anIconName help: aHelpString action: aBlock  self addItem: (SpToolBarButton new           label: aLabel;           icon: (self application iconNamed: anIconName);           help: aHelpString;           action: aBlock;           yourself)from: aPresenter  self fromPort: aPresenter outputPortDefaultinitializeTestedInstance  presenter     beMultipleSelection;     addColumn: (SpStringTableColumn title: 'Test' evaluated: #asString);     roots: #(10 20 30 'abc')specSelector: aSymbol  specSelector := aSymbolexpand: anObject  expand := anObjectbuttonNormal  ^buttonNormalbuildWidget  | textMorph iconsContainer |  textMorph := super buildWidget.  textMorph announcer when: RubKeystroke send: #keystroke: to: self.  iconsContainer := Morph new     extent: 12 @ 12;     color: Color transparent;     changeTableLayout;     listDirection: #topToBottom;     addMorph: (self newIconButtonAction: #decreaseValueOf: with: textMorph iconSelector: #arrowDoubleDownIcon);     addMorph: (self newIconButtonAction: #increaseValueOf: with: textMorph iconSelector: #arrowDoubleUpIcon);     yourself.  textMorph     changeProportionalLayout;     addMorph: iconsContainer fullFrame: (LayoutFrame identity           bottomFraction: 0;           leftFraction: 1;           topOffset: 4;           leftOffset: -25;           yourself).  ^textMorphaddVariableFields: elements  | externalIndex |  externalIndex := 1.  self object array withIndexDo: [:value :index |  value ifNotNil: [ elements add: (SetEyeElement host: self object index: index externalIndex: externalIndex).              externalIndex := externalIndex + 1 ] ]connectPresenters  button1 whenActivatedDo: [ self updateLabel ].  button1 whenDeactivatedDo: [ self updateLabel ].  button2 whenChangedDo: [ self updateLabel ].  button3 whenChangedDo: [ self updateLabel ]askBeforeDiscardingEdits  ^self model askBeforeDiscardingEditsversionModel  ^versionModeltestSelectItemsAddsPathsToSelectedPathList  presenter selectItems: {10 .         20}.  self assertCollection: presenter selection selectedPaths hasSameElements: {#(1 3) .         #(1 1 3)}doItReceiver: anObject  self deprecated: 'This has been moved to specific presenters (check children)' on: '2019-04-15' in: #Pharo8addMetacelloBaseline  | baselineNumber existingBaselines msg selectorName addedPackages package stream packagePattern |  repository ifNil: [ UIManager default inform: 'Please select a repository and try again'.        ^self ].  existingBaselines := self baseLines.  msg := existingBaselines size > 0 ifTrue: [ 'Current baselines:' , String cr , (existingBaselines inject: '' into: [:sum :el |  sum , el , String cr ]) , 'Enter a new baseline number' ] ifFalse: [ 'Enter a new baseline number ("-baseline" will be automatically added)' ].  baselineNumber := UIManager default request: msg initialAnswer: '1.0'.  baselineNumber ifNil: [ ^self ].  addedPackages := OrderedCollection new.  packagePattern := UIManager default request: 'Please enter a pattern to filter package names' initialAnswer: '*'.  [ | packageNames workingCopies |  packageNames := OrderedCollection new.  workingCopies := OrderedCollection new.  self workingCopies do: [:pkg |  ((packagePattern match: pkg package name) and: [ (addedPackages includes: pkg package name) not ]) ifTrue: [ packageNames add: pkg package name.              workingCopies add: pkg ] ].  package := UIManager default chooseFrom: packageNames values: workingCopies title: 'Add dependent package (cancel to stop)'.  package ifNotNil: [ addedPackages add: package package name ] ] doWhileTrue: [ package notNil ].  selectorName := baselineNumber copyWithoutAll: '.-'.  stream := WriteStream on: String new.  stream nextPutAll: 'baseline'.  stream nextPutAll: selectorName.  stream nextPutAll: ': spec         <version: '''.  stream nextPutAll: baselineNumber.  stream nextPutAll: '-baseline''>                spec for: #common do: [                spec blessing: #baseline.                spec repository: '''.  stream nextPutAll: repository description.  stream nextPutAll: '''.                    "spec                         package: ''Example-Core'';                        package: ''Example-Tests'' with: [ spec requires: ''Example-Core'' ]"'.  addedPackages do: [:pName |  stream           nextPutAll: '			spec package: ''';           nextPutAll: pName;           nextPutAll: '''.';           nextPutAll: String cr ].  stream nextPutAll: '                ].'.  self configurationClass compile: stream contents classified: 'baselines'whenSelectionChanged: aBlock  self dropList whenSelectionChanged: aBlockretrieveSpec: aSelector  | layout |  layout := self class perform: aSelector.  layout isSpLayout ifTrue: [ layout selector: aSelector ].  ^layoutsetSliceButton  sliceButton := self instantiate: SpButtonPresenter.  sliceButton     state: false;     label: '+Slice';     help: 'Add a slice to cleaning and nicely propose a bug fix';     action: [ self createSlice ]notifyPropertyChanged: aName  self flag: #todo.  (self observablePropertyNamed: aName) valueChangedfill: aBoolean  fill := aBooleaninitialize  super initialize.  shown := falsebeNotExpand  self expand: falseactionBarPresenter: anObject  actionBarPresenter := anObjecttestSelectItemThenSelectOutsideRangeKeepsSingleSelectedItem  presenter selectItem: 10.  presenter selectItem: 3000.  self assert: presenter selection selectedItems size equals: 1toPort  ^toPortsubwidget  ^subwidgetmenu: aMenuPresenter  aMenuPresenter ifNotNil: [ aMenuPresenter owner: self ].  ^menu := aMenuPresenteraddConstraits: constraints toChild: childMorph  | theMorph |  theMorph := self addPadding: constraints padding toMorph: childMorph.  constraints isExpand ifTrue: [ constraints isFill ifFalse: [ theMorph                 hResizing: #rigid;                 vResizing: #rigid.              theMorph := self newPanel                 addMorphBack: theMorph;                 yourself ].        theMorph           hResizing: #spaceFill;           vResizing: #spaceFill ] ifFalse: [ layout direction setRigidityOfNonExpandedMorph: theMorph.        constraints width ifNotNil: [:w |  theMorph width: w ].        constraints height ifNotNil: [:h |  theMorph height: h ] ].  ^theMorphaccept: aText notifying: aNotifyier  | accept |  accept := self presenter acceptBlock cull: aText cull: aNotifyier.  accept == false ifTrue: [ ^false ].  self presenter text: aText copy.  self presenter actionPerformed.  self presenter changed: #clearUserEdits.  ^trueclassToTest  ^SpSliderPresenteronMorphTreeSelectionChanged: ann  | items |  items := ann selection ifNil: [ #() ] ifNotNil: [:selection |  selection selectedNodes ].  items := items collect: [:each |  each nodeModel ].  self model selectedItems: itemsproperty: aName rawValue: anObject  (self observablePropertyNamed: aName) rawValue: anObjecthasSyntaxHighlight  ^syntaxHighlightrootCommandsGroup  ^SpRecursiveContextSetter visit: (self class buildRootCommandsGroupFor: self defaultCommandsContext) toSetContext: self defaultCommandsContextattachTransmission: aTransmission  self destinationPresenter whenSelectionChangedDo: [:selection |  self transmitWith: aTransmission value: selection selectedItem model ]performAction  self action value.  actionPerformed := nilvShrinkWrap  description  descriptionBlock ifNil: [ ^self value asString ].  ^descriptionBlock cull: self valuewhenChildrenBlockChanged: aBlock  tree whenChildrenBlockChanged: aBlockemulateClick: mouseButtonCode  backendForTest emulateClick: mouseButtonCode onTest: selftestSelectManyIndexesKeepsLastSelectionInWidget  presenter selectPath: #(1).  presenter selectPath: #(2).  self assert: self adapter selectedPaths equals: #(#(2))initialize  self model: SpDemoFormModel new.  super initializelabel  ^value printStringvAlign: anObject  vAlign := anObjectobjectAsHexBytes  ^String streamContents: [:s |  s nextPutAll: '['.        self object do: [:each |  s << (each printPaddedWith: $0 to: 2 base: 16) ] separatedBy: [ s nextPut: $  ].        s nextPut: $] ] limitedTo: 5000mainMessagePresenter  ^mainMessagePresenterlabelFor: anEyeElement  ^[ anEyeElement longLabel ] on: Error do: [:error |  anEyeElement label , ': ' , (self labelFor: anEyeElement error: error) ]classToTest  ^SpTestingAbstractTwoButtonslayout: aLayout  layout := aLayout.  widget ifNil: [ innerWidget := aLayout direction newWidgetOn: self.        innerWidget borderWidth: aLayout borderWidth.        innerWidget cellInset: aLayout spacing.        layout whenVisiblePagesChangedDo: [ self recalculatePages ].        widget := self newScrollPaneFor: innerWidget ].  super layout: aLayoutaddItemTo: aGroup  aGroup addItem: [:item |  item           name: 'Dynamic';           icon: (self iconNamed: #delete);           action: [ aGroup menuItems remove: item.              self needRebuild: false.              self buildWithSpec ] ].  self needRebuild: false.  self buildWithSpechistory  ^self inspectorWrapper historyadd: aPresenter constraints: constraints  self widget ifNil: [ ^self ].  needRecalculatePages := true.  self basicAdd: aPresenter constraints: constraints to: innerWidget.  self scrollToShowLastPageselect  self widgetDo: [:w |  w changed: #select.        w model selectionChanged.        w dependents do: [:e |  e changed ] ]isStyleClass  ^truetestSelectingASecondElementSelectsIt  self presenter selectItem: 10.  self presenter selectItem: 20.  self assert: self presenter selectedItem equals: 20.  self assert: self adapter selectedIndexes equals: #(2)rootNodeHolder  ^self model rootNodeHolderhSpaceFill  startWithSelection  startsWithSelection := trueinitializePresenter  self whenWindowChanged: [ self objectChanged ]themeChanged  self fillStyle: self normalFillStyle.  super themeChangedmethodsFromClass: aClass  ^(self isInstanceSideSelected ifTrue: [ aClass ] ifFalse: [ aClass class ]) methods asOrderedCollectionlabel  ^self buildLabel: self model label withIcon: self model iconoptions  ^optionsconfigurationBlock: anObject  configurationBlock := anObjectwhenEntryCompletionChanged: aBlock  self deprecated: 'Use #whenEntryCompletionChangedDo: instead.' transformWith: '`@receiver whenEntryCompletionChanged: `@statements' -> '`@receiver whenEntryCompletionChangedDo: `@statements'.  self whenEntryCompletionChangedDo: aBlockresizerWidth: anInteger  tree resizerWidth: anIntegercopyAccessorCode  Clipboard clipboardText: self accessorCode asTextrefreshWidgetList  (self widget showIndex < self widget dataSource numberOfRows and: [ self widget isIndexVisible: self widget showIndex ]) ifFalse: [ self widget resetPosition ].  self refreshWidgetSelection.  (self widget hasSelection and: [ self widget isIndexVisible: self widget selectedIndex ]) ifFalse: [ self widget resetPosition.        self widget ensureVisibleFirstSelection ].  self widget refreshicon  ^iconHolder valueiconName: aSymbol  self icon: (self iconNamed: aSymbol)whenMultiSelectionChangedDo: aBlockClosure  selectionMode whenChangedDo: aBlockClosurevSpaceFill  self widgetDo: [:w |  w vResizing: #spaceFill ]rootNodeHolder: aBlock  rootNodeHolder value: aBlocktestJulianDaysIntervalFor2  | interval |  interval := calendar julianDaysIntervalFor: (Date year: 2018 month: 9 day: 17).  self     assert: interval size equals: calendar daysToDisplayCount;     assert: interval equals: ((Date year: 2018 month: 8 day: 26) julianDayNumber to: (Date year: 2018 month: 10 day: 6) julianDayNumber)testInstanceCreationWithValueHolder  | point valueHolder presenter |  point := 40 @ 54.  valueHolder := point asValueHolder.  presenter := SpTestingPresenterWithModel on: valueHolder.  self assert: presenter model equals: pointvalue  ^valueBlock valueclassToTest  ^SpButtonPresenterlabel  ^'thisContext'classToTest  ^SpRadioButtonPresenterscaleInput  ^scaleInputrightText: aText  self widgetDo: [:w |  w destTextModel setText: aText.        w updateText ]icons: aBlock  icon := aBlockbeRowHomogeneous  self rowHomogeneous: truedropEnabled: aBoolean  drawBadgeOn: aCanvas  | badgeString badgeBounds textBounds textWidth textHeight width |  badgeString := self badge asString.  textWidth := self badgeFont widthOfString: badgeString.  textHeight := self badgeFont height.  width := 14 max: textWidth + 2.  badgeBounds := (bounds right - width - 2) @ (bounds top + 2) extent: width @ 14.  aCanvas fillOval: badgeBounds fillStyle: self badgeColor.  textBounds := badgeBounds center - (textWidth @ textHeight / 2.0) + (1 @ 0) extent: textWidth @ textHeight.  aCanvas drawString: badgeString in: textBounds font: self badgeFont color: self badgeTextColorbackend  ^backend ifNil: [ self useBackend: self class defaultBackendName.        backend ]hasSyntaxHighlight  ^self model hasSyntaxHighlightchangeList  ^messageList messagesproperty: aName rawValue: anObject  (self observablePropertyNamed: aName) rawValue: anObjectbuildWidget  ^SpStubDialogWindowView newcolumn: aNumber withConstraints: aBlock  | constraints |  constraints := SpGridAxisConstraints new.  aBlock value: constraints.  columnConstraints at: aNumber put: constraintsregisterSelectorActions  methodsListPresenter whenSelectionChangedDo: [:selection |  self updateTextContents ]customizeMorphicBar: aProgressBarMorph  self flag: #todo.  [ [ self currentValue < 1 ] whileTrue: [ self currentValue: self progression value.        aProgressBarMorph value: self currentValue.        self refreshDelay wait ] ] forkitemFilter  ^self model itemFiltertabs  ^tabs valuenewPhone: anObject  newPhone := anObjecttestManyPresentersShowManyWidgets  3 timesRepeat: [ self presenter addPresenter: (SpNullMillerPresenter on: SpLabelPresenter new) ].  self assert: self adapter childrenWidgets size equals: 3testSelectMultipleItemAddsAllToSelectedPathList  presenter     selectItem: 10;     selectItem: 30.  self assertCollection: presenter selection selectedPaths hasSameElements: {#(1 3) .         #(1 2 3)}display: aBlock  display := aBlocktabManager: anObject  tabManager := anObjectinitialize  super initialize.  items := OrderedCollection new asValueHolder.  self placeAtEndwhenCanDeselectByClickChanged: aBlock  self deprecated: 'It is not clear what option to select if deselected'initialize  super initialize.  groups := OrderedCollection new.  self property: #autoRefresh whenChangedDo: [:aBoolean |  self menuGroups do: [:each |  each autoRefresh: aBoolean ] ]classToTest  ^SpInputTextDropListmouseEnter: anEvent from: aMorph  aMorph color: self urlHoverColor.  self currentHand showTemporaryCursor: Cursor webLinkmax: aNumber  ^self sliderInput max: aNumbermenu  ^menuHolder valueread: anObject  ^(super read: anObject) valueselectDirectoryTitle: aString  ^self backend selectDirectoryTitle: aStringclassToTest  ^SpMenuPresenterbottomFraction  ^0isObservableSlot  ^trueactionsHolder  ^actionsHolderisResizeable  ^isResizeabletestNestedStyles  | lookup labelAdapter styleSheet |  styleSheet := SpStyleSTONReader fromString: '.application [	.label [		Geometry { #width: 21 },		.nested [ 			Geometry { #width: 42 },			.deepNested [ 				Geometry { #width: 84 } ] ] ] ]'.  labelAdapter := SpLabelPresenter new     buildWithSpec;     adapter.  lookup := SpMorphStyle fromStylesheet: styleSheet adapter: labelAdapter.  self assert: lookup width equals: 21.  labelAdapter := SpLabelPresenter new     addStyle: 'nested';     buildWithSpec;     adapter.  lookup := SpMorphStyle fromStylesheet: styleSheet adapter: labelAdapter.  self assert: lookup width equals: 42.  labelAdapter := SpLabelPresenter new     addStyle: 'nested.deepNested';     buildWithSpec;     adapter.  lookup := SpMorphStyle fromStylesheet: styleSheet adapter: labelAdapter.  self assert: lookup width equals: 84pushMessage  self widgetDo: [:w |  self pushMessage: self model message to: w ]testLabelIsSet  presenter label: 'test'.  self assert: presenter label equals: 'test'selectedElement  self tree hasSelectedItem ifFalse: [ ^nil ].  ^self tree selectedItem contentincludes: aPresenter  ^self presenters includes: aPresenterselectItems: aListOfItems  aListOfItems do: [:each |  [ self selectPath: (self pathOf: each) ] on: NotFound do: [  ] ]acceptColumnVisitor: aBuilder  ^aBuilder visitImageColumn: selfkeyPressed: keyCode shift: shiftBoolean meta: metaBoolean control: controlBoolean option: optionBoolean  | evt modifiers |  modifiers := 0.  shiftBoolean ifTrue: [ modifiers := modifiers | 8 ].  metaBoolean ifTrue: [ modifiers := modifiers | (Smalltalk os isWin32 | Smalltalk os isUnix ifTrue: [ 2r00010000 ] ifFalse: [ 2r01000000 ]) ].  controlBoolean ifTrue: [ modifiers := modifiers | 2r00010000 ].  optionBoolean ifTrue: [ modifiers := modifiers | (Smalltalk os isWin32 | Smalltalk os isUnix ifTrue: [ 2r01000000 ] ifFalse: [ 2r00100000 ]) ].  evt := KeyboardEvent new setType: #keystroke buttons: modifiers position: self widget position + (1 @ 1) keyValue: keyCode charCode: keyCode hand: self currentWorld activeHand stamp: Time millisecondClockValue.  evt sentTo: widget.  10 milliSeconds waitactionWhenActivatedHolder  self deprecated: 'It breaks the encapsulation'.  ^niladdVariableFields: elements  self object initialPC to: self object size do: [:index |  elements add: (DynamicEyeElement host: self object label: 'bc ' , index asString value: (self object at: index) asString) ]textField  ^textFieldresetSelection  self deprecated: 'I have the impression this method is not use. If it end up been call, please open an issue on pharo-spec/Spec'setUp  super setUp.  point := SpObservablePoint newaddModelTo: panelMorph  self model items do: [:each |  self model focusOrder add: each.        panelMorph addMorph: (each buildWithSpec                 width: 100;                 hResizing: #rigid;                 yourself) ]testAddButtonToActionBar  | actionBar button |  actionBar := SpActionBarPresenter new.  button := SpButtonPresenter new.  self assertEmpty: actionBar items.  CmUILeftPositionStrategy new addButton: button toActionBar: actionBar.  self assert: actionBar items size equals: 1.  self assert: (actionBar items includesKey: #start).  self assert: (actionBar items at: #start) size equals: 1.  self assert: (actionBar items at: #start) anyOne equals: buttonrightOffset  ^rightOffsetbehavior: aClass  behavior := aClassowner: anObject  owner := anObjectsortingBlock: aBlock  self model sortingBlock: aBlockisVisible  self subclassResponsibilitycreateInstanceFor: aClassSymbol  | class |  class := self resolveSymbol: aClassSymbol.  ^self instantiate: classtestAddItemPosition  | itemLeft itemRight |  self assert: presenter items isEmpty.  presenter addItem: (itemLeft := self newToolbarItem) position: SpToolBarItemPosition left.  presenter addItem: (itemRight := self newToolbarItem) position: SpToolBarItemPosition right.  self assertCollection: presenter leftItems hasSameElements: {itemLeft}.  self assertCollection: presenter rightItems hasSameElements: {itemRight}resetFilteringBlock  self deprecated: 'This feature is now removed from Spec 2. If the visible elements of the list need to be changed, it''s the users of the lists that should manage it and update the list of items of the list.'hash  ^host hashstyleName  ^self subclassResponsibilityaddMark: aText at: aValue  ^self marks: (self marks           add: (SpSliderMark new                 value: aValue;                 text: aText;                 yourself);           yourself)removeStyle: aStyle  (styles includes: aStyle) ifFalse: [ aStyle ].  styles := styles copyWithout: aStylepresenter: aPresenter  presenter := aPresenteraction: aBlock  action := aBlockdefault  ^(self class environment at: #SpMorphicAdapterBindings) newdisplay: aBlock  self dropList display: aBlockcolumnConstraintsAt: columnNumber  ^columnConstraints at: columnNumber ifAbsent: [ nil ]refreshDelay  ^refreshDelaylabel  ^slider labeltestDefaultTextIsEmpty  self assert: presenter text isEmptyrows  | tableContainer |  tableContainer := self widget submorphs first.  ^tableContainer submorphsdateInput  ^dateInputselectedItem  ^list selection selectedItemdisplayMode  ^displayMode ifNil: [ displayMode := SpToolBarDisplayMode default ]addItem: aBlock  self defaultGroup addItem: aBlockopen  self model isCentered ifTrue: [ self centered ].  self model initialPosition ifNotNil: [ self widget openAsIs ] ifNil: [ self widget openInWorld ].  self windowIsOpeningisMenuPresenter  ^truetransmitPort: aPortName do: aBlock transform: transformBlock  self newTransmission     from: self port: aPortName;     do: aBlock;     transform: transformBlock;     applytestIconName  self assert: command iconName isNil.  command iconName: #add.  self assert: command iconName equals: #addworkingModel: anObject  workingModel := anObjectinitialize  super initialize.  updateBlock := [  ].  self timeline: SpTimeline newhiddenIcon  ^self iconNamed: #commentsstepBy: aNumber  stepBy := aNumbercanBeRefreshed: anObject  canBeRefreshed := anObjectdataSource: anObject  dataSource := anObjectresizingSyle: expand  ^expand ifTrue: [ #spaceFill ] ifFalse: [ #rigid ]updateInspectorFrom: oldInspector  self updateTitle.  self inspector ifNil: [ ^self ].  self canBeRefreshed ifFalse: [ ^self ].  self needRebuild: false.  self buildWithSpec: oldInspector spec selector.  oldInspector closebuildPopMessageToolBarItem  ^SpToolBarButton new     label: 'Pop';     icon: (self iconNamed: #glamorousDown);     help: 'Pop last status bar message';     action: [ self popMessage ];     yourselfdefaultGroup  ^defaultGroup ifNil: [ defaultGroup := self instantiate: SpMenuGroupPresenter.        self addMenuGroup: defaultGroup.        defaultGroup ]block: aBlock layoutFrame: aLayoutFrame  | row |  row := SpRowLayout composed.  aBlock value: row.  subwidget := row.  self layoutFrame: aLayoutFramewhenAcceptOnCRChangedDo: aBlock  self property: #acceptOnCR whenChangedDo: aBlockmethod2  setSelectionFromModel: aSelection  self widget ifNotNil: [:w |  w setSelection: aSelection ]testUnselectNonSelectedItemDoesNotRemovesSelection  presenter     selectItem: 10;     unselectItem: 30.  self assert: presenter selection selectedItem equals: 10availablePages  ^SpDemoPage availablePagesopenInstance  window ifNil: [ window := presenter openWithSpecLayout: SpLabelPresenter defaultSpec ]withScrollBars  wrapScrollBars := trueremoveAll  needRecalculatePages := true.  innerWidget removeAllMorphsselectedIndex: anIndex  self deprecated: 'Use #selectIndex: instead' transformWith: '`@receiver selectedIndex: `@arg' -> '`@receiver selectIndex: `@arg'.  self selectIndex: anIndexinitialize  super initialize.  options := OrderedCollection newmaxExtentOrDefault  ^maxExtent ifNil: [ 0 @ 0 ]selectedClass  ^classList selection selectedItemselectIndex: anInteger  (anInteger = 0 and: [ widget selectedIndexes isEmpty ]) ifTrue: [ ^self ].  (widget selectedIndexes includes: anInteger) ifTrue: [ ^self ].  widget selectIndex: anIntegeraddContact: aContact  contents add: aContactnewColumn: aBlock left: left right: right  | layout |  layout := self computeLayoutFromTop: nil bottom: nil left: left right: right.  self newColumn: aBlock origin: layout first corner: layout second offsetOrigin: layout third offsetCorner: layout fourthaddPadding: aNumber toMorph: aMorph into: anAdapter  ^anAdapter addVerticalPadding: aNumber toMorph: aMorphtestSelectItemsOutsideRangeHasNoSelectedPaths  presenter selectItems: {3000 .         4000}.  self assert: presenter selection selectedPaths isEmptycanBeExecuted  ^self context isContactSelectedkeyStrokeAction: aBlock  tree keyStrokeAction: aBlockpresenters  | presenters |  presenters := OrderedCollection new.  self presentersDo: [:each |  presenters add: each ].  ^presenterstestSetSelectPathOutsideRangeRaisesSelectionChangeEventWithUnsetPath  | selectedPath |  presenter whenSelectionChangedDo: [:selection |  selectedPath := selection selectedPath ].  presenter selectPath: #(4).  self assert: selectedPath equals: niltestSetSelectItemRaisesSelectionItemChangeEventWithSelectedItem  | selectedItem |  presenter whenSelectionChangedDo: [:selection |  selectedItem := selection selectedItem ].  presenter selectItem: 10.  self assert: selectedItem equals: 10tempNames  ^[ self object tempNames ] on: Error do: [ #() ]layout: aLayout  widget ifNil: [ widget := GeneralScrollPane new           changeScrollerTableLayout;           hResizing: #spaceFill;           vResizing: #spaceFill;           color: Color transparent;           borderColor: Color transparent;           yourself ].  super layout: aLayoutmodel  ^self announcingObject valueautoDeselection: aBoolean  autoDeselection value: aBooleanmainInspectSubMenu: aMenu  aMenu add: 'Inspect (i)' target: self selector: #inspectSelectedObjectInNewWindow.  aMenu add: 'Explore (I)' target: self selector: #exploreSelectedObjecttextConverter: aTextConverter  super textConverter: aTextConverter.  textModel syntaxHighlight: self textConverter shouldShout.  textModel text: self textConverter getTextselectionInterval  self withAdapterDo: [:anAdapter |  self rawSelection: anAdapter selection ].  ^selection ifNil: [ ^1 to: 0 ]openDialogWithSpecLayout: aSpecLayout  ^self application openDialog: self withSpecLayout: aSpecLayoutasToolbarPresenterWith: aBlock  | builder |  builder := SpToolBarPresenterBuilder new.  aBlock value: builder toolbarPresenter.  ^builder     visit: self;     toolbarPresenterconnectPresenters  messageList     whenSelectionChangedDo: [:selection |  self selectItem: selection selectedItem ];     messages: self buildChangeList.  toolbarPresenter dropListModel selectIndex: 1layout  ^layoutannouncer  ^self model announcertoggleAction: aBoolean  self model state: aBoolean.  ^self model action cull: aBooleanwhenChangedDo: aBlock  self property: #selectedIndex whenChangedDo: [ aBlock cull: self ]requestWindowClose  ^self presenter ifNotNil: [:aPresenter |  aPresenter requestWindowClose ] ifNil: [ true ]presenterProvidedBy: blockReturningPresenter configuredAs: blockConfiguringThePresenter  self     presenterBlock: blockReturningPresenter;     configurationBlock: blockConfiguringThePresentersetSelectedChangeSetIndex: anIndex  ^changesListPresenter setSelectedIndex: anIndexborderWidth  ^self model borderWidthemphasisCodeFor: anEmphasis  ^anEmphasis inject: 0 into: [:sum :next |  sum + (self emphasisOptions at: next) ]isPlaceAtStart  ^placeAtStartvisitStringColumn: aTableColumn  self addCellColumn: aTableColumnroots: aCollection  rootsHolder value: aCollection.  self changed: #setRoots: with: {aCollection}addAllFromPragma: pragma target: target  self fromSpec: (PragmaMenuBuilder pragmaKeyword: pragma model: target) menuSpecrun  self startmethod  ^methodbutton2  ^button2newEmptyModel  ^SpCollectionListModel on: #()listSize  ^self dropList listSizeproperty: aName rawValue: anObject  (self observablePropertyNamed: aName) rawValue: anObjectautoRefreshOnExpand: aBoolean  autoRefreshOnExpand value: aBooleanclassToTest  ^SpLabelledInputTextDropListtitle  ^super title , ' [' , self objectVariableSize asString , ']'allShownItems  ^rootItem children flatCollect: [:e |  e withExpandedChildren ]testCanDynamicallyRebuildPresenter  self openInstance.  self assert: presenter label label equals: ''.  self shouldnt: [ presenter selectFirstElement ] raise: Error.  self assert: presenter label label equals: '1'testDynamicBuild  | model widget1 widget2 widget3 |  model := SpTestingPresenter new.  model openWithSpec close.  widget1 := model list adapter.  model openWithSpec close.  widget2 := model list adapter.  self deny: widget1 identicalTo: widget2.  model list needRebuild: false.  model needRebuild: false.  model openWithSpec close.  widget3 := model list adapter.  self assert: widget2 identicalTo: widget3.  self assert: model needRebuildtestSmokeCreates  self presentertestSelectItemThenSelectOutsideRangeKeepsFirstElement  presenter selectItem: 10.  presenter selectItem: 5000.  self assert: (presenter selection includesItem: 10)value  self subclassResponsibilitynotify: aSpecNotification on: aNotificationAware  aNotificationAware notifyInfo: aSpecNotificationshowClass  ^self class showClasswhenPossibleEntitiesChanged: aBlock  self property: #possibleEntities whenChangedDo: aBlockselectedPath  ^selectionstyleName  ^styleName ifNil: [ super styleName ]shown  ^showninitialize  super initialize.  selector := #newVSplitterAt:.  layoutFrame := (0 @ 0 corner: 0 @ 0) asSpLayoutFrame rightOffset: 1observablePropertyNamed: aName  | slot |  slot := self class slotNamed: aName.  slot isObservableSlot ifFalse: [ SpNonObservableSlotError signal: aName ].  ^slot rawRead: selfclassToTest  ^SpTabManagerPresenterwantDropBlock: aBlock  wantDropBlock := aBlockadd: aPresenter withConstraints: aBlock  super add: aPresenter withConstraints: aBlock.  adapter ifNotNil: [:theAdapter |  theAdapter add: aPresenter constraints: (children at: aPresenter) ]testShowPresenterShowsWidget  self presenter show.  self assert: self adapter isVisibledefaultColor  ^self theme textColorisSearchEnabled  ^searchEnabledsetModel: aDomainObject  ^self model: aDomainObjectwhenSelectedPageChangedDo: aBlock  self property: #selectedPage whenChangedDo: aBlocktestSetRootModelManyTimesPushesOnlyLastPresenterToList  | nullMillerPresenter |  self presenter presenterBlock: [:model |  SpNullMillerPresenter on: (SpLabelPresenter new label: model asString) ].  1 to: 3 do: [:each |  self presenter setRootModel: each ].  nullMillerPresenter := self presenter presenters first.  self assert: nullMillerPresenter wrappedPresenter label equals: 3 asStringdefer: aBlock  UIManager default defer: aBlocktabDeleted: aTab  self model basicRemoveTab: aTab modelnewPanel  ^super newPanel     layoutPolicy: SpMorphicPanedLayout new;     yourselfclearUserEditFlag  self model text: self getText.  self changed: #clearUserEditsshortcut  ^shortcutmodel: aTablePresenter  model := aTablePresenteradapterClass: aSymbol  ^Smalltalk at: (self translateSymbol: aSymbol) ifAbsent: [ aSymbol ]unselectItem: anItem  self selection unselectItem: anItemlayout  ^layoutisNonEditableRow: aRow column: aColumn  ^(self widget dataSource cellColumn: (self widget columns at: aColumn) row: aRow) submorphs allSatisfy: [:e |  e asReadOnlyMorph == e ]testEnablingFilteringUpdateOpenedList  self deny: self adapter hasFilter.  presenter enableItemSubstringFilter.  self assert: self adapter hasFilter.  presenter itemFilter: nil.  self deny: self adapter hasFiltertestOpenWindowAddsItToWindowCollection  | window |  window := (application newPresenter: SpButtonPresenter) openWithSpec.  self assert: (application windows includes: window)popMessageFrom: aMorph  | message |  pushedMessages ifEmpty: [ ^self ].  pushedMessages removeLast.  message := pushedMessages ifNotEmpty: #last ifEmpty: [ '' ].  aMorph     removeAllMorphs;     addMorph: message asStringMorphtestSetOwner  | button |  button := SpButtonPresenter new.  self assert: button owner isNil.  presenter presenter: button.  self assert: button owner equals: presenterincomingTransmission: anObject from: outPort  self presenter roots: anObjectfromPort: aPort  fromPort := aPorttestParsingAStyleIsNotAffectedByExistingClass  | aStylesheet |  aClass := Object subclass: #Font.  aStylesheet := SpStyle createDefaultStyleSheet.  self assert: aStylesheet styles isNotEmptyaddPresenterIn: widgetToBuild withSpecLayout: aSpec  super addPresenterIn: widgetToBuild withSpecLayout: aSpec.  self model buttons ifNotEmpty: [ widgetToBuild setToolbarFrom: [ self buildButtonBar ] ]action  ^self model actionproperty: aName rawValue: anObject  (self observablePropertyNamed: aName) rawValue: anObjectwhenSelectedItemChangedDo: aBlock  selectionHolder whenChangedDo: [:col |  col ifNil: [ aBlock value: nil ] ifNotNil: [ col isEmpty ifTrue: [ aBlock value: nil ] ifFalse: [ aBlock value: (col last lastClicked ifTrue: [ col last content ] ifFalse: [ nil ]) ] ] ]openWithSpecAt: aPosition  self buildWithSpecAsPopup.  self changed: #openAt: with: {aPosition}focusOrder  ^focusOrder ifNil: [ focusOrder := OrderedCollection new ]assign: aPresenter to: anInstVarName  self presenterAt: anInstVarName put: aPresenter.  aPresenter owner: selfupdateTitle  self withWindowDo: [:window |  window title: self title ]minWidth  ^self minExtent ifNotNil: [:aPoint |  aPoint x ]mainMenu  | aMenu |  aMenu := self newMenuBar     addGroup: [:group |  group addItem: [:item |  item                 name: 'File';                 icon: (self iconNamed: #openIcon);                 subMenu: self subMenu ].        group addItem: [:item |  item                 name: nil;                 description: 'Open file';                 icon: (self iconNamed: #openIcon);                 action: [ self inform: 'Open File' ] ].        group addItem: [:item |  item                 name: nil;                 description: 'Save File';                 icon: (self iconNamed: #smallSaveIcon);                 action: [ self inform: 'Save File' ] ].        group addItem: [:item |  item                 name: nil;                 description: 'Print file';                 icon: (self iconNamed: #smallPrintIcon);                 action: [ self inform: 'Print file' ] ] ];     addGroup: [:group |  group addItem: [:item |  item                 name: nil;                 description: 'Undo';                 icon: (self iconNamed: #smallUndoIcon);                 action: [ self inform: 'Undo' ] ].        group addItem: [:item |  item                 name: nil;                 description: 'Redo';                 icon: (self iconNamed: #smallRedoIcon);                 action: [ self inform: 'Redo' ] ] ];     addGroup: [:group |  group addItem: [:item |  item                 name: nil;                 description: 'Add menu item';                 icon: (self iconNamed: #add);                 action: [ self addItemTo: group ] ] ].  ^aMenucancelAction: aBlock  cancelAction := aBlocksortingBlock  ^self model sortingBlockupdateLabel  label label: (String streamContents: [:s |  {button1 .               button2 .               button3} do: [:button |  s                       << button label;                       << ' : ';                       << (button state ifTrue: [ 'V' ] ifFalse: [ 'X' ]) ] separatedBy: [ s << ' - ' ] ])searchMatching: aBlock  searchBlock := aBlock.  self enableSearchevenRowColor  ^evenRowColor valueexecute  self selectedContact phone: self context newPhone.  self contactBookPresenter updateViewsideRuler  ^sideRulermodel  ^modelrowConstraintsAt: rowNumber  ^rowConstraints at: rowNumber ifAbsent: [ nil ]removeAll  children removeAll.  adapter ifNotNil: [:anAdapter |  anAdapter removeAll ]selectedHolder  ^selectedHolderselectedIndexes  ^widget selectedIndexesconfigureOSX: anApplication  isDisplayed  ^self widget isDisplayedfirstAction: firstActionBlock secondAction: secondActionBlock  self firstButton action: firstActionBlock.  self secondButton action: secondActionBlockdefaultNodeFor: item  ^SpTreeNodePresenter new     content: item;     children: [ self childrenFor: item ];     hasChildren: [ self hasChildrenFor: item ];     yourselfbuttonGroup: anITOptionButtonGroup  buttonGroup := anITOptionButtonGroupinitializeWidgets  inspectorChoice := self newDropList.  previousButton := self newButton.  nextButton := self newButton.  previousButton     label: '<';     action: [ self inspectorWrapper inspectPrevious.        self update ].  nextButton     label: '>';     action: [ self inspectorWrapper inspectNext.        self update ].  inspectorChoice displayBlock: [:label |  label ]hideHeaderTitle  headerTitle := nilinitialize  super initialize.  displayBlock := [:object |  object ifNotNil: [ object asStringOrText ] ifNil: '' ].  self property: #displayBlock whenChangedDo: [ self date: self date ].  self date: self defaultDatecolumns: aCollection  columns := aCollectionisExpanded: aBoolean  isExpanded value: aBooleanselectedItem  self selectedIndex = 0 ifTrue: [ ^nil ].  ^self model at: self selectedIndexisInstanceSideSelected  ^radioButtonInstanceSide stateconfigureButton: aButton item: aToolbarItem  aButton getIconSelector: #icon.  aButton badgeSelector: #badgeautoMultiSelection  ^autoMultiSelection valuelabelOnLeft  ^self changed: #labelOnLeft with: #()selectedItems: aCollection  tree selectedItems: aCollectionconfiguration  ^configurationaddMorph: aMorph fullFrame: aLayout  paneMorphs add: aMorph.  super addMorph: aMorph fullFrame: aLayoutaddItemRight: aMorph  rightPanel addMorphBack: (aMorph           vResizing: #spaceFill;           yourself)elements  ^self presentersassociatedRadioButtons: aCollection  | allElements |  allElements := {self} , aCollection.  allElements do: [:each |  each basicAssociatedRadioButtons: allElements ].  aCollection do: [:each |  each state: false ]toPresenter  ^self toPort presentertestUnselectSelectedIndexRaisesSingleEvent  | counter |  counter := 0.  presenter     selectIndex: 1;     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectIndex: 1.  self assert: counter equals: 1testOpenPresenterRaisesBuiltEvent  | built |  built := false.  presenter whenBuiltDo: [ built := true ].  self openInstance.  self assert: builtlayout: aLayout  layout := aLayout.  widget ifNil: [ widget := aLayout direction newWidgetOn: self.        widget layoutPolicy position: aLayout position.        self selector: self splitterNewSelector ].  super layout: aLayoutregisterEvents  self whenMenuChangedDo: [ self withAdapterDo: [:anAdapter |  anAdapter updateMenu ] ]outputPortDefault  ^self outputPorts firstpresenter  ^presenterchildNodeClass  ^childNodeClass valueasArray  self error: 'Should not arrive here. This layout is executable then it will not be interpreted.'initializePresenters  super initializePresenters.  self content: SpSliderInputtestEnabledAffectWidget  presenter enabled: false.  self deny: self adapter enabledrefreshSubMenu: aMenu  aMenu add: 'Refresh Inspector' target: self selector: #refresh.  aMenu addLinemenu: aMenu  | menuPresenter |  menuPresenter := self model contextMenu.  menuPresenter ifNil: [ ^nil ].  ^SpBindings value: self model application adapterBindings during: [ menuPresenter buildWithSpec ]buttonWithColor: anObject  buttonWithColor := anObjectrightFraction: aNumber  ^0menuPresenter  ^menuPresenterwhenListChanged: aBlock  self deprecated: 'Use #whenModelChangedDo: instead' transformWith: '`@receiver whenListChanged: `@argument' -> '`@receiver whenModelChangedDo: `@argument'.  self whenModelChangedDo: aBlockclassToTest  ^SpSliderInputsize  ^sizetabManager  ^tabManagertestSelectWidgetIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | selectedPath |  presenter selection whenChangedDo: [:selection |  selectedPath := selection ].  self adapter selectPath: #(1).  self assert: selectedPath equals: #(1)enabled: aBoolean  super enabled: aBoolean.  self changed: #enabled: with: {aBoolean}classToTest  ^SpTreeTablePresenterstate: aBoolean  self state = aBoolean ifTrue: [ ^self ].  state := aBooleannumberOfRows  ^model ifNil: [ 0 ] ifNotNil: [ self presenters size ]withWindowDo: aValuable  self hasWindow ifFalse: [ ^self ].  aValuable value: self rootacceptAllowed  ^self widget editingMode acceptAllowedscrollValueChanged: aValue  self model scrollValue: aValue stepwhenFilteringBlockChangedDo: aBlock  self deprecated: 'This feature is now removed from Spec 2. If the visible elements of the list need to be changed, it''s the users of the lists that should manage it and update the list of items of the list.'buildWidget  | widgetClass newWidget |  self flag: #pharo7.  widgetClass := self class environment at: #SpRubScrolledTextMorph ifAbsent: [ RubScrolledTextMorph ].  newWidget := (widgetClass on: self)     getTextSelector: #getText;     setTextSelector: #accept:notifying:;     getSelectionSelector: #readSelection;     menuProvider: self selector: #codePaneMenu:shifted:;     setSelectionSelector: #setSelection:;     ghostText: self placeholder;     beWrapped;     enabled: self enabled;     askBeforeDiscardingEdits: self askBeforeDiscardingEdits;     autoAccept: self autoAccept;     vResizing: #spaceFill;     hResizing: #spaceFill;     setBalloonText: self help;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     registerScrollChanges: #scrollValueChanged:;     yourself.  self setEditingModeFor: newWidget.  self presenter whenTextChangedDo: [:text |  self setText: text to: newWidget ].  self presenter whenPlaceholderChangedDo: [:text |  self setGhostText: text to: newWidget ].  ^newWidgettable: anObject  table := anObjectopen  self object ifNil: [ ^self openOnNil ].  self object isInteger ifTrue: [ ^self openOnInteger: self object ].  self object isString ifTrue: [ ^self openOnString: self object ]commandClass  ^SpCodeBrowseItCommandshortcut: aShortcut  shortcut := aShortcutaddSplitter  self commands add: (SpSplitterHorizontal commands: self commands)restoreButton  ^restoreButtonfillModelWithFormContent  self workingModel     name: self nameTextInput text;     surname: self surnameTextInput text;     number1: number1Input number;     number2: number2Input number;     scale: self scaleInput value;     password: self passwordInput text;     rememberMe: self checkboxInput state;     date: self dateInput date.  self workingModel gender: (genderButtons associations detect: [:each |  each value state ]) key.  self workingModel selectedItems: self itemsInput selectedItemsadapterBindingsClass  ^SpMorphicAdapterBindingsworkingModel  ^workingModellistDirection  self model isPlaceAtEnd ifTrue: [ ^#rightToLeft ].  self model isPlaceAtStart ifTrue: [ ^#leftToRight ].  self error: 'Undefined location to place buttons.'previousInspectorType  | index types |  types := self inspectorTypes.  index := types indexOf: self inspectorType ifAbsent: [ ^types first ].  ^types atWrap: index - 1add: aName expand: shouldExpand fill: shouldFill padding: aNumber  self add: aName withConstraints: [:constraints |  constraints           expand: shouldExpand;           fill: shouldFill;           padding: aNumber ]testAskBeforeChanging  | state |  self assert: presenter askBeforeChanging not.  self openInstance.  state := presenter adapter askBeforeChanging.  self assert: state not.  presenter askBeforeChanging: true.  state := presenter adapter askBeforeChanging.  self assert: statesaveElement  | newValue |  newValue := description doItReceiver class compiler     source: description text readStream;     context: nil;     receiver: description doItReceiver;     failBlock: [ ^self ];     evaluate.  self selectedElement save: newValue.  self objectChangedextractArrayToInterpretFrom: aFragment  arrayToInterpret := aFragment.  aFragment isSpLayout ifTrue: [ arrayToInterpret := aFragment asArray.        selector := aFragment selector ].  (arrayToInterpret isCollection and: [ arrayToInterpret isSequenceable ]) ifFalse: [ ^arrayToInterpret ].  (aFragment isString or: [ aFragment isText ]) ifTrue: [ ^(self isPresenterSymbol: aFragment) ifTrue: [ self presenter ] ifFalse: [ self convertSymbolOfClassToInstance: aFragment ] ].  ^nilbackgroundColorFor: anItem  ^self model backgroundColorFor: anItempresenters  ^self itemsdaysButtonsBuilderFrom: aDate  ^SpDynamicPresentersListBuilder new     modelObjects: (self datesToDisplayFor: aDate);     presenter: SpButtonPresenter configuredAs: [:button :date |  button           label: date dayOfMonth asString;           enabled: aDate monthIndex = date monthIndex;           action: [ self dayClicked: date ].        date julianDayNumber = Date today julianDayNumber ifTrue: [ button icon: (self iconNamed: #glamorousGrayCircle) ] ];     layoutBuilder: (SpDynamicLeftToRightColumnsLayout columns: self daysInAWeek);     yourselfisSearchEnabled  ^self presenter isSearchEnabledresetSortingBlock  self model sortingBlock: nilaccept: aText  self text: aText.  self acceptBlock cull: aText.  self actionPerformed.  self changed: #clearUserEditstitle  ^String streamContents: [:stream |  stream << self class title << ' on: ' << self model currentChangeSet name ]backgroundColorFor: anItem at: index  self deprecated: 'Should not use. This feature is not supported anymore. This feature depends on the theme'.  ^self backgroundColorBlock cull: anItem cull: indexinitializeTestedInstance  super initializeTestedInstance.  presenter addColumn: (SpStringTableColumn title: 'Number' evaluated: #yourself).  presenter hideColumnHeadersinspectionMenu: aMenu  | menuModel |  self hasSelectedObject ifFalse: [ ^aMenu ].  menuModel := self newMenu.  self inspectionSubMenu: menuModel.  self selectedElement inspectionMenu: menuModel.  aMenu addAllMorphs: (menuModel buildWithSpec: #popup) items.  ^aMenupresenters: aCollection  self items: aCollectionpositionPoint: aPoint  ^self position: self left @ aPoint yselectTabModel: tabModel  tabSelectedAction value cull: tabModel cull: selfdisplay: aBlock  ^self dropList display: aBlocknewLookup: aString  | rootClass |  rootClass := SpStyleSTONReader fromString: aString.  ^SpMorphStyle newStyles: rootClass flattenClassesclickAtIndex: anIndex  self selectIndex: anIndex.  activateOnSingleClick ifFalse: [ ^self ].  self doActivateAtIndex: anIndextriggerOkAction  self okActionBlock valueinitializeTestedInstance  presenter items: #(10 20 30)returnInterpretationOf: newInstance  | result adaptor |  result := self class interpretASpec: newInstance presenter: spec.  adaptor := (result isKindOf: SpPresenter) ifTrue: [ self getAdaptorWithDefaultSpecOf: result ] ifFalse: [ result ].  self presenter spec: adaptor.  ^adaptortestActivationOnDoubleClickShouldNotActivateOnClick  | activatedItem |  activatedItem := nil.  presenter     activateOnDoubleClick;     whenActivatedDo: [:selection |  activatedItem := selection selectionItem ].  presenter clickAtIndex: 1.  self assert: activatedItem equals: nilemphasisOptions  ^emphasisOptions ifNil: [ emphasisOptions := {(#bold -> 1) .         (#italic -> 2) .         (#underline -> 4) .         (#narrow -> 8) .         (#struck -> 16)} asDictionary ]prepareToRunAgain  self tearDown.  super setUpitems  ^items valueresult  ^resultcolumns  ^columnscellIndentFor: item  ^item depth * 16whenChangedDo: aBlock  self property: #state whenChangedDo: aBlockstep  self refreshinitializePresenters  text := self instantiate: SpLabelPresenter.  plus := self instantiate: SpButtonPresenter.  minus := self instantiate: SpButtonPresenter.  plus label: '+'.  minus label: '-'whenDateChanged: aBlock  dateModel whenTextChanged: [:newText :oldText :announcement :anAnnouncer |  | oldDate |        oldDate := date.        date := newText ifNotEmpty: [ Date readFrom: newText readStream ] ifEmpty: [ nil ].        aBlock cull: date cull: oldDate cull: announcement cull: anAnnouncer ]collapseAll  self changed: #collapseAll with: #()retrieveSpec: aSelector  self layout ifNotNil: [ ^self layout ].  ^super retrieveSpec: aSelectortestItems  | item |  self assert: presenter items isEmpty.  presenter addItem: (item := self newToolbarItem).  self assertCollection: presenter leftItems hasSameElements: {item}font  self flag: #REMOVE.  ^niltextModel  ^textModelpriorVersionOfAMethod: aChangeRecord  | index |  index := referencesList identityIndexOf: aChangeRecord.  ^referencesList at: index + 1 ifAbsent: [ nil ]text  ^textwhenActivatedDo: aBlock  self whenChangedDo: [:bool |  bool ifTrue: aBlock ]initializePresenters  notebook := self newNotebook.  checkbox := self newCheckBox.  notebook     addPage: self objectClassPage;     addPage: self objectInspectorPage;     addPage: self browserPagewhenMenuChangedDo: aBlock  self property: #contextMenu whenChangedDo: aBlockupdateWindowTitle  self withWindowDo: [:window |  window title: self title ]propertyAt: aKey ifAbsent: aBlock  ^self properties at: aKey ifAbsent: aBlockstyles  ^stylesnewToolbarMorph  ^SpNotebookPanelMorph new     fillStyle: (SolidFillStyle color: Color transparent);     borderStyle: (BorderStyle width: 0);     vResizing: #spaceFill;     hResizing: #shrinkWrap;     cellPositioning: #center;     changeTableLayout;     cellInset: 0;     yourselftestUnselectNonSelectedPathRaisesNoEvent  | counter |  counter := 0.  presenter     selectPath: #(1 1);     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectPath: #(2 1).  self assert: counter equals: 0buildWidget  | preWidget |  preWidget := PluggableSliderMorph new     model: self;     getValueSelector: #value;     setValueSelector: #value:;     value: self absoluteValue;     getLabelSelector: #label;     max: self max;     min: self min;     quantum: self quantum;     setBalloonText: self help;     vResizing: #spaceFill;     hResizing: #spaceFill;     yourself.  preWidget := self presenter isHorizontal ifTrue: [ preWidget ] ifFalse: [ preWidget := TransformationMorph new asFlexOf: preWidget.        preWidget transform withAngle: 90 degreesToRadians negated.        preWidget ].  self presenter whenMinChangedDo: [:newValue |  preWidget min: newValue ].  self presenter whenMaxChangedDo: [:newValue |  preWidget max: newValue ].  self presenter whenQuantumChangedDo: [:newValue |  preWidget quantum: newValue ].  self presenter whenValueChangedDo: [:newValue |  preWidget value: newValue ].  ^preWidgeticonBlock  ^iconBlocknumberOfColumns: aNumber  columns := OrderedCollection new.  (1 to: aNumber) do: [:index |  self addColumn: (SpStringTableColumn evaluated: [:entity |  (self displayBlock value: entity) at: index ]) ]setLeftOffset: left for: widget borderWidth: windowBorderWidth  widget leftFraction = 0 ifTrue: [ left isZero ifTrue: [ widget leftOffset: windowBorderWidth ] ifFalse: [ widget leftOffset: left + self splitterWidth ] ] ifFalse: [ widget leftFraction = 1 ifFalse: [ widget leftOffset: left + self splitterWidth ] ]activateOnSingleClick  activateOnSingleClick := trueconnectPresenters  list whenSelectionChangedDo: [:sel |  label := self newLabel.        label label: sel selectedItem asString.        self needRebuild: false.        self buildWithSpec ]removeItemBlock: aBlock  removeItemBlock := aBlocklabelOnLeft  ^self widgetDo: [:w |  w listDirection: #leftToRight ]beHomogeneous  self homogeneous: truehide  visible := falserawSelection: anInterval  self property: #selection rawValue: anIntervalfont: aFont  font := aFonttestSelectItemsAddsItemsToSelectedItemList  presenter selectItems: {10 .         20}.  self assert: (presenter selection includesItems: {10 .               20})actions: aCollection  actionsHolder value: aCollectioninspectSelectedObjectInNewWindow  self selectedObjectDo: [:anObject |  self inspectInNewWindow: anObject ]beExpandable  expandable := truetestSingleClickActivatesRowInSingleClickActivationMode  | activated |  activated := false.  self presenter     activateOnSingleClick;     whenActivatedDo: [ activated := true ].  backendForTest clickFirstRowAndColumn: self adapter.  self assert: activatedchildrenItemsBlock  ^childrenItemsBlocktestSetSelectItemOutsideRangeDoesNotModifySelection  presenter whenSelectionChangedDo: [:selection |  self fail ].  presenter selectItem: 1000text  ^textdisplayMode: anObject  displayMode := anObjecttestSetSelectIndexRaisesSelectionItemChangeEventWithSelectedIndex  | selectedItem |  presenter whenSelectionChangedDo: [:selection |  selectedItem := selection selectedItem ].  presenter selectIndex: 1.  self assert: selectedItem equals: 10newName  | newName |  newName := self request: 'New name of the contact' initialAnswer: self selectedContact name title: 'Rename a contact'.  newName isEmpty ifTrue: [ SpInvalidUserInput signal: 'The contact name can not be empty' ].  ^newNametestChangingFromMultipleToSingleSelection  presenter beMultipleSelection.  self assert: presenter isMultipleSelection.  presenter beSingleSelection.  self deny: presenter isMultipleSelectiontestDisplayMode  presenter beBoth.  self assert: presenter isDisplayModeBoth.  presenter beIcons.  self assert: presenter isDisplayModeIcons.  presenter beText.  self assert: presenter isDisplayModeTextdoubleClick: event  ^self model doubleClick: eventdragTransformationBlock: aBlock  dragTransformationBlock := aBlockaboutText: aString  self deprecated: 'With Spec 2, SpPresenter was refactored to move all window management to WindowPresenter.	From now on, if you want to interact with a window you need to:	- Implement #initializeWindow: method (#initializeDialog: for dialogs) to manage window elements before the presenter is opened	- Use the method #window or #withWindowDo: to interact with windows after it has been opened.'.  self window ifNil: [ aboutText := aString ] ifNotNil: [:window |  window aboutText: aString ]behavior  ^behaviordefaultIcon  ^self iconNamed: #blankIconpageIndex: anObject  pageIndex := anObjectcancelAction  ^cancelActiontestSelectPageIndex  | mock mock2 |  mock := self mockPage.  mock2 := SpNotebookPage title: 'test' provider: [ SpButtonPresenter new ].  presenter addPage: mock.  presenter addPage: mock2.  presenter selectPageIndex: 2.  self assert: presenter selectedPage equals: mock2beShrinkable  shrink := truecontextMenu  ^contextMenuwidth: aNumber  self expand: false.  width := aNumbernotifyPropertyChanged: aName  self flag: #todo.  (self observablePropertyNamed: aName) valueChangedselectedBehavior  ^self model selectedBehaviorunselectAllChildren  self children value do: [:e |  e selected: false.        e unselectAllChildren ]passwordLabel: anObject  passwordLabel := anObjectclassToTest  ^SpMethodBrowserlistSize  ^self dropList listSizepadding  ^self lookupProperty: SpStyleContainer valueOf: #paddingobjectAsLatin1String  | width str |  str := String new: (width := self object size min: 5000).  str replaceFrom: 1 to: str size with: (self object copyFrom: 1 to: width).  ^strtestSelectPresenterIndexSetsSelectedIndexInWidget  presenter selectPath: #(1).  self assert: (self adapter selectedPaths includes: #(1))selectDialog  ^selectDialoglabel  ^labelHolder valuebuildWidget  ^MorphTreeMorph new     model: self treeModel;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     spInitializeColumsFrom: self;     hResizing: #spaceFill;     vResizing: #spaceFill;     autoDeselection: self autoDeselection;     resizerWidth: self resizerWidth;     columnInset: self columnInset;     iconBlock: self iconBlock;     rowInset: self rowInset;     keystrokeActionSelector: #keyStroke:;     multiSelection: self multiSelection;     autoMultiSelection: self autoMultiSelection;     removeOnlyLastSelected: self selectOnlyLastHighlighted;     isCheckList: self isCheckList;     doubleClickSelector: #doubleClick;     getMenuSelector: #menu:shifted:;     rowColorForEven: self evenRowColor;     rowColorForOdd: self oddRowColor;     buildContents;     yourselfpageClass  ^SpDemoButtonsPresenterexpandRoots  self treeModel expandRootsselectedObjectDo: aBlock  self selectedElement ifNotNil: [:element |  aBlock value: element value ]initialize  self class initializeSlots: self.  selection := #().  super initializeinitialize  super initialize.  action := [  ].  name := ''.  autoRefresh := falsemethodsOn: aShortcut do: aBlock  methodsListPresenter bindKeyCombination: aShortcut toAction: aBlockkeyPressed: keyCode shift: shiftBoolean meta: metaBoolean control: controlBoolean option: optionBoolean  | evt modifiers widget |  widget := self focusedPresenter adapter widget.  modifiers := 0.  shiftBoolean ifTrue: [ modifiers := modifiers | 8 ].  metaBoolean ifTrue: [ modifiers := modifiers | (Smalltalk os isWin32 | Smalltalk os isUnix ifTrue: [ 2r00010000 ] ifFalse: [ 2r01000000 ]) ].  controlBoolean ifTrue: [ modifiers := modifiers | 2r00010000 ].  optionBoolean ifTrue: [ modifiers := modifiers | (Smalltalk os isWin32 | Smalltalk os isUnix ifTrue: [ 2r01000000 ] ifFalse: [ 2r00100000 ]) ].  evt := KeyboardEvent new setType: #keystroke buttons: modifiers position: widget position + (1 @ 1) keyValue: keyCode charCode: keyCode hand: self currentWorld activeHand stamp: Time millisecondClockValue.  evt sentTo: widget.  10 milliSeconds waitshowOnlyDestination: aBoolean  showOnlyDestination := aBooleantestCanAddNewItem  presenter     items: #(1 2 3) asOrderedCollection;     addItemBlock: [ 4 ].  presenter addButton click.  self assertCollection: presenter items hasSameElements: #(1 2 3 4)stateHolder  self deprecated: 'It breaks encapsulation'.  ^stateselectFrom: nodeStart to: nodeStop  self widget selectFrom: nodeStart to: nodeStopselectIndex: anInteger  self widget listSelectionIndex: anIntegerghostText: aText  self deprecated: 'This API is too tight to Morph. Use #placeholder: instead.' transformWith: '`@receiver ghostText: `@statement' -> '`@receiver placeholder: `@statement'.  self placeholder: aTextisPlacedAtStart  ^placedAtStarttestBasicLayout  | layout |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1.  self place: label2 at: 1 @ 2.  self place: morph2 at: 2 @ 2.  layout := self newLayout.  layout layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 50 @ 20).  self assert: morph1 bounds equals: (50 @ 0 corner: 100 @ 20).  self assert: label2 bounds equals: (0 @ 20 corner: 50 @ 40).  self assert: morph2 bounds equals: (50 @ 20 corner: 100 @ 40)whenDigitsChangedDo: aBlock  self property: #digits whenChangedDo: aBlockautoRefresh  ^autoRefreshfromSpec: aSpec  | en newSubMenu |  en := aSpec enabledBlock ifNil: [ aSpec enabled ].  newSubMenu := aSpec subMenu ifNotNil: [:sub |  SpMenuPresenter new fromSpec: sub ].  self     name: aSpec label;     state: aSpec checked;     enabled: en;     icon: aSpec icon;     shortcut: aSpec keyText;     subMenu: newSubMenu;     action: aSpec actionlongLabel  | description |  description := self description.  description size > 150 ifTrue: [ description := description first: 150 ].  ^self label ifNotNil: [:label |  label , ': ' , description ] ifNil: [ description ]state  ^statetestRightClickShowsMenu  | menu |  presenter contextMenu: (menu := SpMockMenuPresenter new).  self deny: menu shown.  self emulateRightClick.  self assert: menu shownbeHorizontalAlignmentCenter  self hAlign: SpGridAlignment centerinitializePresenters  text := self newText text: 'Implementing #prepareWindow:, you can add a menu, toolbar and statusBar to your component.BEWARE: This elements will be added just when you will open the presenter as a window or dialog. Otherwise, your component will behave just as another composable presenter.'description: anObject  description := anObjectbeRowNotHomogeneous  self rowHomogeneous: falsetestValue  self assert: presenter value equals: presentertraverseInFocusOrderDo: aBlock  self traverseInFocusOrderDo: aBlock excluding: Set newbuildWidget  ^self subclassResponsibilitylayout: aLayout  self applyVisibilitydescription  ^self value printStringLimitedTo: 2000model  ^modelscale  ^scalelayoutBuilder  ^layoutBuilderremove  self okToChange ifFalse: [ ^self ].  self model removeChangeSet: self selectedChangeSet prompting: true.  self updateChangesList.  changesListPresenter resetSelectionbrowseVersions  self currentMethod ifNotNil: [:method |  model browseVersionsFrom: method compiledMethod ]isShowingColumnHeaders  ^showColumnHeaderstestUnselectNonSelectedIndexDoesNotRemovesSelection  presenter     selectIndex: 1;     unselectIndex: 3.  self assert: presenter selection selectedIndex equals: 1selectedPage: aPage  self deprecated: 'Use #selectPage: instead' transformWith: '`@receiver selectedPage: `@statements1' -> '`@receiver selectPage: `@statements1'.  self selectPage: aPageitalic  ^italictestSelectItemOutsideRangeUnsetsSelectedPath  presenter selectItem: 4000.  self assert: presenter selection selectedPath equals: #()newIconButtonAction: aSymbol with: textMorph iconSelector: anIconSymbol  ^IconicButton new     target: self;     actionSelector: aSymbol;     arguments: {textMorph};     labelGraphic: (self iconNamed: anIconSymbol);     color: Color transparent;     extent: 16 @ 8;     borderWidth: 0;     yourselflabel  ^labelextent  ^self lookupProperty: SpStyleGeometry valueOf: #extentpopMessage  self message: nil.  self changed: #popMessageleftOffset: aNumber  ^0subMenu  ^self newMenu     addItem: [:item |  item           name: 'Open';           icon: (self iconNamed: #openIcon);           shortcut: $o meta;           action: [ self inform: 'Open' ] ];     addItem: [:item |  item           name: 'Save';           icon: (self iconNamed: #smallSaveIcon);           shortcut: $s meta;           action: [ self inform: 'Save' ] ];     addItem: [:item |  item           name: 'Print';           shortcut: $p meta;           icon: (self iconNamed: #smallPrintIcon);           action: [ self inform: 'Print' ] ];     addItem: [:item |  item           name: 'Close';           shortcut: $c meta;           icon: (self iconNamed: #smallCancelIcon);           action: [ self inform: 'Kill' ] ];     yourselfstepTime  ^1500displaySymbol: anObject  displaySymbol := anObject.  entityText entryCompletion: self entitiesEntryCompletionselectedPath  ^self selectedPaths firstinitialize  super initialize.  self beBoth.  leftItems := OrderedCollection new.  rightItems := OrderedCollection newgetIconFor: anItem  ^self model getIconFor: anItemasButtonPresenter  self flag: #TODO.  ^SpButtonPresenter new     label: self name;     help: self description;     in: [:button |  self hasIcon ifTrue: [ button iconName: self iconName ] ];     action: [ self execute ] yourselfbrowseSelectedObject  self selectedObjectDo: [:anObject |  anObject browse ]label  ^labelconfigureWindows: anApplication  updateMenu  autoRefresh  ^autoRefreshinspectionMenu: aMenu  self hasSelectedObject ifFalse: [ ^aMenu ].  self inspectionSubMenu: aMenu.  self selectedElement inspectionMenu: aMenu.  ^aMenutestResettingMillerListRemovesWidgets  3 timesRepeat: [ self presenter addPresenter: (SpNullMillerPresenter on: SpLabelPresenter new) ].  self presenter resetTo: 0.  self assert: self adapter childrenWidgets isEmptycontents: anObject  contents := anObjectdynamicPresenter  ^dynamicPresentercommandClass  ^self subclassResponsibilityx  ^xclassesOn: aShortcut do: aBlock  classesListPresenter bindKeyCombination: aShortcut toAction: aBlockinitialize  super initialize.  self initializeSemaphoreexecute  self contactBookPresenter removeContact: self selectedContact.  self contactBookPresenter updateViewtakeKeyboardFocus  ^self tree takeKeyboardFocuswhenDisplaySymbolChanged: aBlock  self property: #displaySymbol whenChangedDo: aBlocktitle: aString  selectIndexes: aCollection  aCollection ifEmpty: [ ^self unselectAll ].  self selectIndex: aCollection firstsource  ^[ self model source ]acceptOnCR: aBoolean  acceptOnCR := aBooleanisDisplayModeText  ^self displayMode = SpToolBarDisplayMode modeLabelnewToolbarItemFont  | buttonFont |  buttonFont := self theme buttonFont.  ^LogicalFont familyName: buttonFont familyName pointSize: buttonFont pointSize - 3menuGroup  ^self presenter menuGrouptestSetSelectItemRaisesSelectionChangeEventWithSelectedItem  | selectedElement |  presenter whenSelectionChangedDo: [:selection |  selectedElement := selection selectedItem ].  presenter selectItem: 20.  self assert: selectedElement equals: 20classToTest  ^SpFastTablePresentertempIndex  ^tempIndextestClearSelection  self initializationText.  self openInstance.  presenter selectionInterval: (1 to: 10).  self assert: presenter selectionInterval equals: (1 to: 10).  presenter clearSelection.  self assert: presenter selectionInterval isEmptybeVertical  direction := SpLayoutDirection verticaltestActivationOnDoubleClickShouldActivateOnDoubleClick  | activatedItem |  presenter     activateOnDoubleClick;     whenActivatedDo: [:selection |  activatedItem := selection selectedItem ].  presenter doubleClickAtPath: #(1 2 1).  self assert: activatedItem equals: 110isInWorld  ^falseshowOptions: aBoolean  self widgetDo: [:w |  w showOptions: aBoolean ]title: anObject  title := anObjectasSpecCommand  ^super asSpecCommand     shortcutKey: $r meta;     yourselfcommands: anObject  commands := anObjectinspectActionOfSelectedShortcut  | selection action |  selection := self kmTable selection selectedItem ifNil: [ ^self ].  action := selection realValue keymap ifNil: [ ^self ].  action inspectselectedItem  ^tree selectedItemasSpLayout  ^selfnewWidgetOn: anAdapter  ^anAdapter newVerticalmodel  ^modeldoubleClick  ^self model doubleClickwindowIsClosing  isClosed := true.  self presenter windowIsClosinginitializeTestedInstance  presenter presenter: SpLabelPresenter newfromSton: stonReader  stonReader parseMapDo: [:message :value |  self perform: message asMutator with: value ]whenListChanged: aBlock  listPresenter whenListChanged: aBlockcontainer: anObject  container value: anObjectexecute  self browserClientProvider browseAllImplementorsOf: self selectorinitializeWindow: aWindowPresenter  aWindowPresenter     title: self title;     initialExtent: self initialExtent;     windowIcon: self windowIcon;     askOkToClose: self askOkToClose;     aboutText: self aboutTextwhenTreeUpdatedDo: aBlock  treeUpdated whenChangedDo: aBlockinspectPrevious  history hasPrevious ifFalse: [ ^self ].  self inspectHistoryItem: history previousdirection  ^directionsetModelBeforeInitialization: aDomainObject  self setAnnouncingObject: aDomainObjectmorphicTabsFor: aManagerModel  ^(aManagerModel adapter widget submorphs detect: [:each |  each class = TabBarMorph ]) tabsisInitialStateSet  ^initialStateSetinitialize  super initialize.  self class initializeSlots: selfhasScrollBars  ^wrapScrollBarslistElementAt: anIndex ifAbsent: aBlock  ^self model listElementAt: anIndex ifAbsent: aBlockgetMenu  self flag: #TODO.  ^(PragmaMenuBuilder pragmaKeyword: self textArea editingModeClass menuKeyword model: self adapter) menucurrentActivated  ^currentActivated valuedate  ^datelayout: aLayout  layout := aLayout.  widget ifNil: [ widget := aLayout direction newWidgetOn: self.        widget borderWidth: aLayout borderWidth.        widget submorphs do: [:each |  each cellInset: aLayout spacing ] ].  super layout: aLayoutcustomSubMenu: aMenu  aMenu addGroup: [:aGroup |  aGroup addItem: [:anItem |  anItem                 name: 'Inst var refs...';                 action: [ self browseInstVarRefs ] ].        aGroup addItem: [:anItem |  anItem                 name: 'Inst var defs...';                 action: [ self browseInstVarDefs ] ].        aGroup addItem: [:anItem |  anItem                 name: 'Class var refs...';                 action: [ self classVarRefs ] ].        aGroup addItem: [:anItem |  anItem                 name: 'Class variables';                 action: [ self browseInstClassVariables ] ].        aGroup addItem: [:anItem |  anItem                 name: 'Class refs';                 action: [ self browseClassRefs ] ] ]button  ^self dropListButton buttonsetUp  super setUp.  presenter     addColumn: (SpStringTableColumn title: 'Value' evaluated: #printString);     beMultipleSelection;     roots: #(1 2 3);     children: [:aNumber |  aNumber < 100 ifTrue: [ {(aNumber * 2) .               (aNumber * 3) .               (aNumber * 10)} ] ifFalse: [ #() ] ];     yourselfrefreshWidgetHeaderTitle  self presenter hasHeaderTitle ifTrue: [ self widget columns first model title: self presenter headerTitle.        self widget           showColumnHeaders;           refresh ] ifFalse: [ self widget columns first model title: nil.        self widget           hideColumnHeaders;           refresh ]initializePresenters  super initializePresenters.  self content: SpListPresenterunselectItem: anItem  [ self unselectPath: (self pathOf: anItem) ] on: NotFound do: [  ]size: aNumber  size := aNumbermodel: anObject  model := anObjectselectItem: anItem  [ self selectPath: (self pathOf: anItem) ] on: NotFound do: [ self itemNotFoundAction ]label  ^self addShortcutTipFor: labelsendersMethod  self method ifNotNil: [:aMethod |  self model browseSendersOfMessagesFrom: aMethod selector ]whenPresentersChangedDo: aBlock  self whenModelChangedDo: aBlockbeNotHomogeneous  self homogeneous: falseclearContent  self text: ''buildChangeList  rgMethod sourcePointer ifNil: [ ^#() ].  ^(SourceFiles changeRecordsFrom: rgMethod sourcePointer className: rgMethod instanceSideParentName isMeta: rgMethod isMetaSide) collectWithIndex: [:c :i |  | rg |        rg := c asRingDefinition.        rg annotationNamed: #versionIndex put: i ]pageClass  ^SpDemoTextInputPresenterinitializePrivateValueHolders  askOkToClose := false.  titleHolder := self class titleadapterBindingsClass  ^SpStubAdapterBindingstype  ^typefillWith: aClass  methodList items: aClass methods.  ^protocolList items: (aClass protocols collect: [:eachSymbol |  aClass organization protocolOrganizer protocolNamed: eachSymbol ])onWidgetBuilt  ^self selectedItems: selectionHolder valuefieldEncrypted: anObject  fieldEncrypted := anObjectinitializePresenters  browseModel := self newButton.  usersModel := self newButton.  sendersModel := self newButton.  implementorsModel := self newButton.  versionModel := self newButton.  dropListModel := self newDropList.  self     setFocusOrder;     setBrowseModel;     setUsersModel;     setVersionModel;     setSendersModel;     setImplementorsModeleventKeyStrokesForPreviousFocus  ^{Character tab shift asKeyCombination}setUp  super setUp.  biChooseMethod := SpChooseMethodUI newpossibleEntities: aBlock  possibleEntities := aBlock.  entityText entryCompletion: self entitiesEntryCompletionghostText  self deprecated: 'This API is too tight to Morph. Use #placeholder instead.' transformWith: '`@receiver ghostText' -> '`@receiver placeholder'.  ^self placeholderdelegateTo: aPresenter  delegation := aPresenterghostText: aText  self deprecated: 'This API is too tight to Morph. Use #placeholder: instead.' transformWith: '`@receiver ghostText: `@statement' -> '`@receiver placeholder: `@statement'.  self placeholder: aTexttestSelectAllSelectsAllItems  presenter selectAll.  self assert: presenter selection selectedItems asSet equals: presenter model items asSettestSelectPage  | mock mock2 |  mock := self mockPage.  mock2 := SpNotebookPage title: 'test' provider: [ SpButtonPresenter new ].  presenter addPage: mock.  presenter addPage: mock2.  presenter selectPage: mock2.  self assert: presenter selectedPage equals: mock2initialize  super initialize.  self initializeTSearchable.  autoDeselect := true.  allowToSelect := true.  display := [:object |  object asStringOrText ]testWithoutSyntaxHighlight  presenter withoutSyntaxHighlight.  self deny: self adapter hasSyntaxHighlightEnabledprintOn: aStream  super printOn: aStream.  aStream nextPut: $(.  aStream nextPutAll: name.  aStream nextPut: $)gender: anObject  gender := anObjectborderWidth  ^borderWidthconfigureItem: itemModel morph: itemMorph toolBar: toolBarMorph  itemMorph     font: toolBarMorph toolbarItemFont;     width: toolBarMorph toolbarItemSize.  toolBarMorph displayMode configureMorph: itemMorph item: itemModel.  ^itemMorphscaleValue: v  ^((v - self min) / (self max - self min)) asFloatselectedObject  ^self subclassResponsibilitytestOpenPresenterIsDisplayed  self openInstance.  self assert: presenter isDisplayedinitializePresenters  button1 := self newRadioButton.  button2 := self newRadioButton.  button3 := self newRadioButton.  label := self newLabel.  button1 associatedRadioButtons: {button2 .         button3}.  button1 label: 'Button 1'.  button2 label: 'Button 2'.  button3 label: 'Button 3'.  self updateLabelinitializePresenters  list := self newList.  label := self newLabel.  list items: #(1 2 3)testUnselectSelectedItemRemovesSelection  presenter     selectItem: 10;     unselectItem: 10.  self assert: presenter selection isEmptyselector: anObject  selector := anObjectcolumns  ^self model columns collect: [:each |  each buildWithSpec ]passwordInput  ^passwordInputtestActivateDoesNotRaiseDeactivateEvent  presenter state: false.  self assertWith: [:times |  times = 1 ] timesRaisedEvent: #whenDeactivatedDo: inPresenter: presenter whenDoing: [ presenter state: true ]reset  self value: self minremovePostscriptFrom: aChange  (aChange hasPostscript and: [ aChange postscriptHasDependents ]) ifTrue: [ ^self inform: 'Cannot remove the postscript rightnow because there is at least onewindow open on that postscript.Close that window and try again.' ].  aChange removePostscriptpresenterBlock: anObject  presenterBlock := anObjectautoRefresh: aBoolean  autoRefresh := aBooleanlabel  ^labelselectIndex: anInteger  self selection selectIndex: anInteger.  self selection selectedItem valuecreateRingMethodForSelector: aSelector inClass: aClass  (aClass includesSelector: aSelector) ifTrue: [ ^aClass compiledMethodAt: aSelector ].  ^self createRingMethodForRemovedSelector: aSelector inClass: aClassregisterEvents  super registerEvents.  self whenScrollValueChangedDo: [:newPosition |  self changed: #setScrollValue: with: {newPosition} ]columnsCount  ^columnsCounttree  ^treechildren: aBlock  children value: aBlockdisplayBlock: aBlock  self deprecated: 'Please use #display: instead' transformWith: '`@receiver displayBlock: `@arg' -> '`@receiver display: `@arg'.  ^self dropList display: aBlockbehavior  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8testSmokeHorizontalTest  self presenter beHorizontaltransmission  ^self selectedItemsimage1  ^image1allChanges  ^ChangeSet allChangeSets reversesubpresenterOrLayoutNamed: presenterNameOrLayout of: aPresenter  ^aPresenter additionalSubpresentersMap at: presenterNameOrLayout ifAbsent: [ aPresenter presenterAt: presenterNameOrLayout ifAbsent: [ self error: 'No presenter named "' , presenterNameOrLayout , '" was found in ' , aPresenter printString ] ]isResizable  ^self model isResizablex: anObject  x := anObjectfilterField: anObject  filterField := anObjectfilterWith: aFilter  self widgetDo: [:w |  | nodes |        nodes := w model rootNodes.        nodes do: [:r |  r nodeModel updateAccordingTo: aFilter ].        self removeRootsSuchAs: [:n |  (aFilter keepTreeNode: n) not and: [ n isEmpty ] ].        self changed: #rootNodes ]initialize  super initialize.  adapterBindings := self adapterBindingsClass newrequest: request initialAnswer: initialAnwser title: title  | answer |  answer := UIManager default request: request initialAnswer: initialAnwser title: title.  answer ifNil: [ SpInteractionCancelled signal ].  ^answerheaderIcon  ^headerIcon valuestyleOf: aMorph  ^aMorph valueOfProperty: #stylebadgeTextColor  ^self theme badgeTextColoraboutToStyleBlock  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8dragTransformationBlock  ^self model dragTransformationBlocksetUp  super setUp.  builder := SpDynamicPresentersListBuilder newrefreshWidgetSelection  | rowIndexes |  rowIndexes := self presenter selection selectedIndexes.  rowIndexes = self widget selectedIndexes ifTrue: [ ^self ].  rowIndexes isEmpty ifTrue: [ self widget basicSelectIndexes: #() ] ifFalse: [ self widget basicSelectIndexes: rowIndexes ].  ^self widget refreshbuildAdapterFor: aPresenter bindings: adapterBindings  ^aPresenter needRebuild ifTrue: [ self adapt: aPresenter bindings: adapterBindings ] ifFalse: [ aPresenter needRebuild: true.        aPresenter adapter ifNil: [ self adapt: aPresenter bindings: adapterBindings ] ifNotNil: [:adapter |  adapter isRedrawable ifTrue: [ adapter removeSubWidgets ].              adapter ] ]searchText: aString  aString isEmptyOrNil ifTrue: [ ^#() ].  ^Array streamContents: [:stream |  self elements withIndexDo: [:each :index |  (self model performSearch: each matching: aString) ifTrue: [ stream nextPut: index ] ] ]presentersInFocusOrder  ^self itemstable  ^tablepositionPoint: aPoint  ^self position: aPoint x @ self topwhenRetrievedDo: aBlock  retrievedBlock := aBlocksetContentsOfChangeSet: changeSet forClass: class andSelector: selector  class ifNil: [ ^self buildChangeSetDescriptionFor: changeSet ].  selector ifNil: [ ^self buildClassDescriptionFor: changeSet class: class ] ifNotNil: [ ^self buildSelectorDescriptionFor: changeSet class: class selector: selector ]includesItems: aCollection  ^aCollection allSatisfy: [:anItem |  self selectedItems includes: anItem ]presenter  ^presenterlabel: aString  label := aStringrememberMe  ^rememberMerefresh  self flag: #TODOisBuilt  ^self isDisplayedconfigureWith: displayModel item: itemPresenter  displayModel configureButton: self item: itemPresenterremoveSubWidgets  widget submorphs first removeAllMorphs.  widget submorphs second removeAllMorphswrappedObject: anObject  wrapped := anObjectwhenGhostTextChanged: aBlock  self deprecated: 'This API is too tight to Morph. Use #whenPlaceholderChanged: instead.' transformWith: '`@receiver whenGhostTextChanged: `@statement' -> '`@receiver whenPlaceholderChanged: `@statement'.  self whenPlaceholderChangedDo: aBlockrefresh  description hasUnacceptedEdits ifTrue: [ ^self ].  description getSelection size = 0 ifTrue: [ self           refreshDescription;           updateList ]testCanRemoveSelectedItem  presenter     items: #(1 2 3) asOrderedCollection;     selectItem: 2.  presenter removeButton click.  self assertCollection: presenter items hasSameElements: #(1 3)state  ^self model statevisibleIf: aValuable  visible := aValuableisEditable  ^editableclassVarRefs  ^self systemNavigation browseClassVarRefs: self hostClassaddMenuGroup: aMenuGroup  aMenuGroup owner: self.  groups add: aMenuGroup.  self autoRefresh ifNotNil: [ aMenuGroup autoRefresh: self autoRefresh ]disableSearch  searchEnabled := falseclassToTest  ^SpMenuItemPresentercontent  ^content valuetitle  ^self model titleadd: aPresenter  self add: aPresenter constraints: SpLayoutConstraints newclassToTest  ^SpLinkPresentervisitCommand: aCmCommandEntry  aCmCommandEntry positionStrategy addButton: aCmCommandEntry asButtonPresenter toActionBar: self actionBarPresenterdisable  self enabled: falsebuttonNormal: anObject  buttonNormal := anObjectvalue  ^self sliderInput valueplaceholder: aText  self input placeholder: aTextselectionOrLine  ^self selection ifEmpty: [ self selectLine ]validateApplicationOfPresenter: aPresenter  aPresenter application == self ifFalse: [ SpInvalidApplicationError signal: 'The requested presenter has a different application' ]contents: anObject  self basicAt: 1 put: anObjectstate  | state |  state := self model state.  ^(state isBlock or: [ state isMessageSend ]) ifTrue: [ state cull: self model ] ifFalse: [ state ]beOk  cancelled := falsechangesMenu: aBlock  changesListPresenter contextMenu: aBlockredSlider  ^redSliderbutton  ^buttonwidget  ^widgetactionToPerformHolder  self deprecated: 'Spec should not provide a way to get its internals. actionToPerform is not a value holder anymore but an observable slot, thus, this method cannot return anything anymore.'setModelBeforeInitialization: aDomainObject  isClosed  ^isClosedaddLast: aName  self addLast: aName withConstraints: [:constraints |   ]selectionHolder  ^self observablePropertyNamed: #selectedIndexeslistSize  self dropList listSizeremoveEntryCompletion  ^self input removeEntryCompletionadd: aName  self add: aName withConstraints: [:constraints |   ]toggleState  self state: self state notadd: containerMorph toWindow: aSpecWindow  aSpecWindow addMorph: containerMorph fullFrame: LayoutFrame identityabstractAdapterClass  ^SpStubAbstractAdapternewRow: aBlock height: aNumber  self newRow: aBlock origin: 0 @ 0 corner: 1 @ 0 offsetOrigin: 0 @ 0 offsetCorner: 0 @ aNumberbeNotResizable  resize := falseconnectPresenters  super connectPresenters.  cancelButton action: [ self performCancelAction ]testRadio2StartsSelected  self assert: self presenter radio2 statebuildWidget  widget := ToolDockingBarMorph new     hResizing: #spaceFill;     vResizing: #spaceFill;     yourself.  self menuGroups doWithIndex: [:aGroup :index |  self adoptMenuGroupModel: aGroup first: index = 1 ].  ^widgetaction  ^actiontestSelectPresenterIndexOutsideRangeUnsetsSelectedIndexInWidget  presenter selectIndex: 100.  self assert: self adapter selectedIndexes isEmptyinput  ^inputsetRoots: aCollection  treeModel rootItems: aCollectiontestSelectIndexesAddsItemsToSelectedItemList  presenter selectIndexes: {1 .         2}.  self assert: (presenter selection includesItems: {10 .               20})isEmpty  ^self selectedIndexes isEmptyinitializeTestedInstance  super initializeTestedInstance.  presenter     beMultipleSelection;     items: {10 .         20 .         30 .         'aaa' asText}testUpdateModel  | aPoint presenter |  aPoint := SpTestingPointModel x: 40 y: 54.  presenter := SpTestingPresenterWithModel on: aPoint.  self assert: presenter x text equals: aPoint x asString.  self assert: presenter y text equals: aPoint y asString.  aPoint     x: 1;     y: 2.  aPoint valueChanged.  self assert: presenter x text equals: aPoint x asString.  self assert: presenter y text equals: aPoint y asStringwantsVisualFeedback: aBoolean  wantsVisualFeedback := aBooleaniconFor: aNode  ^iconBlock value cull: aNode content cull: aNodeselectedItem  ^self dropList selectedItemconnectPresenters  super connectPresenters.  checkbox whenActivatedDo: [ notebook addPage: (dynamicPage := self dynamicPage) ].  checkbox whenDeactivatedDo: [ dynamicPage ifNotNil: [:page |  notebook removePage: page.              dynamicPage := nil ] ]addFocusRotationKeyBindings  whenBuiltDo: aBlock  self announcer when: SpWidgetBuilt do: aBlockaction  ^actionclassToTest  ^SpDynamicMockPresentertestSelectPathAddsItemToSelectedItemList  presenter selectPath: #(1 3).  self assert: (presenter selection includesItem: 10)imageForm  ^(PNGReadWriter on: (ZnBase64Encoder new decode: PolymorphSystemSettings pharoLogoContents) readStream) nextImagevalue: aNumber  slider value: aNumberinitialize  super initializesetUp  super setUp.  treeWithItems := self modelClass new.  treeWithItems roots: #(#first #second #third #fourth #fifth)autoDeselect: aBoolean  self widgetDo: [:w |  w autoDeselect: aBoolean ]minExtent  ^minExtentbuildWidget  ^FTPluggableIconListMorphAdaptor new     model: self model;     hideColumnHeaders;     beResizable;     columns: self model columns;     getListSizeSelector: #listSize;     getListElementSelector: #listElementAt:;     getIndexSelector: #getIndex;     setIndexSelector: #setIndex:;     getIconSelector: #getIconFor:;     resetListSelector: #resetListSelection;     getMenuSelector: #menu:shifted:;     setMultipleSelection: self model selection isMultipleSelection;     doubleClickSelector: #doubleClick:;     basicWrapSelector: #wrapItem:;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     setBalloonText: self help;     hResizing: #spaceFill;     vResizing: #spaceFill;     selectIndex: 1;     enableFilter: FTSubstringFilter;     explicitFunction;     yourselfwhenEnabledChanged: aBlock  self deprecated: 'Use #whenEnabledChangedDo: instead.' transformWith: '`@receiver whenEnabledChangedDo: `@statements' -> '`@receiver whenEnabledChangedDo: `@statements'.  self whenEnabledChangedDo: aBlockcontents  ^contentstestInstVarNamesAndPresenterNamesArray  builder     modelObjects: {3 .         2 .         1};     presenterBlock: [:o |  SpButtonPresenter ].  self assertCollection: builder instVarNamesAndPresenterNamesArray hasSameElements: #(var1 #SpButtonPresenter var2 #SpButtonPresenter var3 #SpButtonPresenter)whenSelectionChanged: aBlock  self list whenSelectionChanged: aBlockfixed  ^fixedisVertical  ^self direction = SpLayoutDirection verticaldisplayBlock: aBlock  self dropList display: aBlockwhenTreeUpdated: aBlock  self deprecated: 'Use #whenTreeUpdatedDo: instead.' transformWith: '`@receiver whenTreeUpdated: `@statements' -> '`@receiver whenTreeUpdatedDo: `@statements'.  self whenTreeUpdatedDo: aBlocktestSelectItemsOutsideRangeHasNoSelectedIndexes  presenter selectItems: {300 .         400}.  self assert: presenter selection selectedIndexes isEmptyupdatePresenter  toolbarModel  self deprecated: 'Use #toolbarPresenter instead' transformWith: '`@receiver toolbarModel' -> '`@receiver toolbarPresenter'.  ^self toolbarPresenterisOk  ^self isCancelled notdirection  ^directiontransferBlock: aBlock  transferBlock := aBlockinitializePresenters  okButton := self newButton.  self registerOkButtonEvents.  self focusOrder add: okButtonbuildWidget  ^SpMorphPresenter new     morph: self currentWorld;     yourselfacceptDroppingMorph: draggedMorph event: event inMorph: source  ^self acceptDropBlock cull: draggedMorph model model cull: event cull: source model modelitems: aList  ^self dropList items: aListcanTakeKeyboardFocus  ^falseselection  ^selectionmorph: anObject  morph := anObjectwhenWindowChanged: aBlock  self flag: #TODO.  self announcer when: SpWindowBuilt do: [:ann |  aBlock cull: ann model ]items  ^#('item 1' 'item 2' 'item 3' 'item 4' 'item 5')selectedItem  ^selectionHolder value ifEmpty: [ nil ] ifNotEmpty: [:col |  col last ]value  ^valueobject: anObject  Smalltalk garbageCollect.  super object: (EyePointerWrapper wrap: anObject)value  ^valuebuttons  ^buttonsforeground: anObject  foreground := anObjectretrievingBlock  ^retrievingBlockHolder valuetestJulianDaysIntervalFor  | interval |  interval := calendar julianDaysIntervalFor: (Date year: 2018 month: 9 day: 15).  self     assert: interval size equals: calendar daysToDisplayCount;     assert: interval equals: ((Date year: 2018 month: 8 day: 26) julianDayNumber to: (Date year: 2018 month: 10 day: 6) julianDayNumber)doItReceiver: aReceiver  self deprecated: 'This method is an horrible hack because the VersionBrowser was using Code or Diff presenter but was only using the APIof the Code presenter... This method and other methods from the CodePresenter APIwill be removed.'inspectInNewWindow: anObject  anObject inspectdragEnabled  ^self presenter dragEnabledautoDeselection  ^self model autoDeselectionaddSpecialFields: elements  assertWith: assertionBlock timesRaisedEvent: anEventName inPresenter: aPresenter whenDoing: actionBlock  | timesCalled |  timesCalled := 0.  aPresenter perform: anEventName with: [ timesCalled := timesCalled + 1 ].  actionBlock value.  assertionBlock value: timesCalledselectedMessage  ^messageList selectedMessageselectPaths: pathArray  self selectPath: pathArray lasticonFor: anItem  ^self icons cull: anItem cull: selfcolor: aColor  self widget ifNotNil: [:w |  w == self ifFalse: [ super color: aColor ] ]buildChangeSetDescriptionFor: changeSet  ^changeSet ifNil: [ '' ] ifNotNil: [ changeSet preambleString ifNil: [ '' ] ]addPaneHSplitterBetween: topMorphs and: bottomMorphs  | targetY fixed rightFraction leftFrame rightFrame sorted morph topGroup bottomGroup splitter offset |  topMorphs ifEmpty: [ ^self ].  targetY := topMorphs first layoutFrame bottomFraction.  fixed := topMorphs select: [:m |  m layoutFrame topFraction = m layoutFrame bottomFraction ].  sorted := ((topMorphs reject: [:m |  m layoutFrame topFraction = m layoutFrame bottomFraction ]) asSortedCollection: [:a :b |  a layoutFrame rightFraction = b layoutFrame rightFraction ifTrue: [ a layoutFrame leftFraction <= b layoutFrame leftFraction ] ifFalse: [ a layoutFrame rightFraction <= b layoutFrame rightFraction ] ]) readStream.  sorted contents ifEmpty: [ ^fixed ].  topGroup := OrderedCollection new.  rightFraction := sorted contents first layoutFrame leftFraction.  [ sorted atEnd or: [ morph := sorted next.        morph layoutFrame leftFraction ~= rightFraction and: [ morph layoutFrame rightFraction ~= rightFraction ] ] ] whileFalse: [ topGroup add: morph.        rightFraction := morph layoutFrame rightFraction ].  leftFrame := topGroup first layoutFrame.  rightFrame := topGroup last layoutFrame.  bottomGroup := (bottomMorphs reject: [:m |  m layoutFrame topFraction = m layoutFrame bottomFraction ]) select: [:m |  (m layoutFrame leftFraction between: leftFrame leftFraction and: rightFrame rightFraction) or: [ m layoutFrame rightFraction between: leftFrame leftFraction and: rightFrame rightFraction ] ].  offset := (topGroup collect: [:m |  m layoutFrame bottomOffset ]) max.  splitter := ProportionalSplitterMorph new beSplitsTopAndBottom.  splitter layoutFrame: ((leftFrame leftFraction @ targetY corner: rightFrame rightFraction @ targetY) asLayoutFrame           leftOffset: leftFrame leftOffset;           rightOffset: rightFrame rightOffset;           topOffset: offset;           bottomOffset: 4 + offset).  topGroup := topGroup , fixed.  topGroup do: [:m |  splitter addLeftOrTop: m ].  bottomGroup do: [:m |  splitter addRightOrBottom: m ].  self addMorphBack: splitter.  ^topGroupsearchValueOf: item  ^item asStringapplyStyleTo: aString inContext: anObject  self prepareWithinContext: anObject.  ^self applyStyleTo: aStringtopOffset: aNumber  ^0initialize  super initialize.  self selector: #add:.  layoutFrame := SpLayoutFrame identityconnectPresenters  buttonWithShortcut action: [ self inform: 'button with shortcut pressed' ]save: aValue  self host at: self index put: aValueinitializePresenters  slider := self instantiate: SpSliderPresenter.  input := self instantiate: SpTextInputFieldPresenter.  self focusOrder add: inputnewVertical  ^self newPanel     listDirection: #topToBottom;     yourselfbuildWidget  widget := self basicMenuPopUp.  self menuGroups do: [:group |  | items |        items := group buildWithSpec.        items do: [:item |  widget addMorphBack: item ] ] separatedBy: [ widget addLine ].  ^widgetstyleExtent: aPoint  | rootStyle |  rootStyle := SpStyleSTONReader fromString: ('.application [ Geometry \{ #width: {1}, #height: {2} \} ]' format: {aPoint x .               aPoint y}).  ^SpMorphStyle newStyles: rootStyle flattenClassesresizableChanged  self widgetDo: [:w |  w resizable: self resizable ]surfaceExtent: anExtent  surfaceExtent := anExtenttestNestedLayoutModifiesHeightOfTopLayout  | base presenter layout |  base := SpBoxLayoutWithTableForTestPresenter new.  presenter := SpLabelPresenter new     label: 'Test';     yourself.  layout := SpBoxLayout newVertical     add: (SpBoxLayout newHorizontal add: presenter expand: false fill: false padding: 0) expand: false fill: false padding: 0;     yourself.  base buildAdapterWithSpecLayout: layout.  self assert: presenter adapter widget owner owner height equals: presenter adapter widget heightsubMenu  ^subMenuname  ^nameaboutToStyleBlock: aBlockReturningABoolean  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8arguments  ^self subclassResponsibilityrootForItems: aCollection  ^FTRootItem new     data: aCollection;     yourselftransmitPort: aPortName do: aBlock  self newTransmission     from: self port: aPortName;     do: aBlock;     applytestSelectIndexSetsSelectedIndex  presenter selectIndex: 1.  self assert: presenter selection selectedIndex equals: 1entityText  ^entityTextpresenter  ^presenterinitializePresenters  super initializePresenters.  self content: SpTextInputFieldPresenterdoItContext: anObject  self deprecated: 'This has been moved to specific presenters (check children)' on: '2019-04-15' in: #Pharo8menu: aMenu  self deprecated: 'Use #contextMenu instead.' transformWith: '`@receiver menu: `@argument' -> '`@receiver contextMenu: `@argument'.  self contextMenu: aMenuwhen: anAnnouncement do: aBlock  classShortcuts: event from: aMorph  self selectedClass ifNotNil: [ event keyString = '<Cmd-b>' ifTrue: [ ^self browseMethodFull ].        event keyString = '<Cmd-d>' ifTrue: [ ^self forgetClass ].        event keyString = '<Cmd-x>' ifTrue: [ ^self removeClass ] ]splitsTopAndBottom  ^self isHorizontalopenWithSpec: aSpec  self buildWithSpec: aSpec.  self updateTitlebuildWidget  ^PanelMorph new     layoutPolicy: TableLayout new;     vResizing: #spaceFill;     hResizing: #spaceFill;     yourselfwhenModelChangedDo: aBlock  listModel whenModelChangedDo: aBlockplaceAtStart  placeAtStart := truetestSelectPresenterItemSetsSelectedIndexInWidget  self skiptestAdapterForBindingsRaiseErrorIfNoBinding  | layout |  layout := SpAbstractWidgetLayout for: #NonExistingAdapter.  self should: [ layout adapterFor: SpListPresenter new bindings: SpStubAdapterBindings new ] raise: Errortable  ^tablesave: aValue  self host instVarNamed: self instVarName put: aValuetestUnselectSelectedPathRaisesSelectionEventOnce  | counter |  counter := 0.  presenter     selectPath: #(1 2);     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectPath: #(1 2).  self assert: counter equals: 1form: anObject  form := anObjectupdateMessagesList  | sel |  sel := methodsListPresenter selectedItem.  self selectedClass ifNil: [ methodsListPresenter items: {} ] ifNotNil: [:class |  methodsListPresenter items: (self selectedChangeSet selectorsInClass: class name) sort ].  methodsListPresenter setSelectedItem: selselectedMethod  ^methodList selectedItemenabled: aBoolean  super enabled: aBoolean.  self changed: #enabledtestSelectWidgetIndexRaisesSelectionIndexChangeEventOnce  | counter |  counter := 0.  presenter selection whenChangedDo: [:selection |  counter := counter + 1 ].  self adapter selectIndex: 1.  self assert: counter equals: 1basicAdd: aPresenter constraints: constraints to: aPanel  | childMorph |  childMorph := self buildMorph: aPresenter constraints: constraints.  aPanel addMorphBack: childMorph.  ^childMorphsetRefreshingBlockForSendersOf: aSelector  | specialIndex |  specialIndex := Smalltalk specialSelectorIndexOrNil: aSelector.  self refreshingBlock: [:method |  method hasSelector: aSelector specialSelectorIndex: specialIndex ]useNextInspectorType  self inspectorType: self nextInspectorTypeabsoluteValueToValue: v  ^self min + (v * (self max - self min)) roundTo: self quantumlastClicked: aBoolean  lastClicked value: aBooleanpathOf: anItem  ^(self pathOf: anItem from: presenter roots) ifNil: [ NotFound signalFor: anItem in: presenter roots ]subscriptions: anObject  subscriptions := anObjectadd: aName  self add: aName withConstraints: [:aConstraint |   ]testUnselectAllUnselectsall  presenter     selectPath: #(1 2);     unselectAll.  self assert: presenter selection isEmptyisCentered  ^centereddaysLabelsBuilder  ^SpDynamicPresentersListBuilder new     modelObjects: self dayNames;     presenter: SpLabelPresenter configuredAs: [:label :str |  label label: str ];     layoutBuilder: (SpDynamicLeftToRightColumnsLayout columns: self daysInAWeek);     yourselfinitializePresenters  moreOptionsText := 'More options' asText.  lessOptionsText := 'Less options' asText.  moreOptionsButton := self newButton label: moreOptionsTexttestShouldAcceptFloatWithoutMinMax  presenter     beFloat;     digits: 3;     maximum: nil;     minimum: nil.  self assert: (adapter shouldAccept: '').  self assert: (adapter shouldAccept: '100').  self assert: (adapter shouldAccept: '100.1').  self assert: (adapter shouldAccept: '80.1').  self assert: (adapter shouldAccept: '150.1').  self deny: (adapter shouldAccept: 'string').  self deny: (adapter shouldAccept: '10string')presenter  ^presenterisWindowPresenter  ^falsetransferFor: passenger from: aMorph  ^(self model transferFor: passenger from: self table) buildWithSpechasContents  hasContents isBlock ifTrue: [ ^hasContents value ].  ^self childrenItems notEmptyitems: aCollection  associationsWrapperToItem removeAll.  pickedItemsHolder removeAll.  listPresenter items: (aCollection collectWithIndex: [:e :i |  self wrap: e at: i ])openModalWithSpec: aSelector  ^self application openModal: self withSpecLayout: (self retrieveSpec: aSelector)testFromSpecSingle  | menuDescription |  menuDescription := PluggableMenuSpec withModel: nil.  menuDescription add: 'item'.  presenter fromSpec: menuDescription.  self assert: presenter menuGroups size equals: 1.  self assert: presenter menuGroups first menuItems size equals: 1.  self assert: presenter menuGroups first menuItems first name equals: 'item'.  self openInstancesubmerge: source into: destination  | message |  source == destination ifTrue: [ ^false ].  source isEmpty ifTrue: [ self inform: 'Nothing to copy.  To remove,simply choose "remove".'.        ^false ].  source okayToRemove ifFalse: [ ^false ].  message := 'Please confirm:  copy all changesin "' , source name , '" into "' , destination name , '"and then destroy the change setnamed "' , source name , '"?'.  (self confirm: message) ifFalse: [ ^false ].  (source hasPreamble or: [ source hasPostscript ]) ifTrue: [ (self confirm: 'Caution!  This change set has a preamble ora postscript or both.  If you submerge it intothe other side, these will be lost.Do you really want to go ahead with this?') ifFalse: [ ^false ] ].  self copyAllChangesFrom: source to: destination.  self removeChangeSet: source prompting: false.  ^truetext: aText  text := aTextaccept  self widgetDo: [:w |  w acceptContents ]performMenuActionWith: arguments  ^self model performMenuActionWith: argumentsselector  ^selectoreventKeyStrokesForNextFocus  ^{Character tab asKeyCombination}childrenFor: aNode  ^self model childrenFor: aNodeshortCuts  | shortCuts |  shortCuts := super shortCuts.  shortCuts at: $c meta put: [ self copySelectedItemAccessorCode ].  ^shortCutstestSelectAll  presenter beSingleSelection.  presenter selectAll.  self assertEmpty: presenter selection selectedItems.  presenter beMultipleSelection.  presenter selectAll.  self assert: (presenter selection selectedItems asArray collect: #label) equals: #('10' '20' '30')addOption: anOption  (anOption isSelected not and: [ options isEmpty ]) ifTrue: [ anOption beSelected ].  (anOption isSelected and: [ options notEmpty ]) ifTrue: [ options do: #beUnselected ].  options add: anOption.  anOption buttonGroup: selfdisable  self model enabled: falsequantum  ^quantumresetPosition  position := nilitemAtPath: anArray ifAbsent: aBlock  ^[ self itemAtPath: anArray ] on: SubscriptOutOfBounds do: [ aBlock value ]removeMethods  self currentMethod ifNotNil: [:method |  model removeMethod: method inClass: method methodClass ]withAdapterDo: aValuable  ^self adapter ifNotNil: aValuablebrowseValueClass  ^self valueClass browseitemFilter  ^itemFiltertransfer: anObject  passenger := anObjectheaderAction  ^headerAction valuepresenterAt: aName  ^self readSlotNamed: aNameinitializePresenters  methodsListPresenter := self newList.  classesListPresenter := self newList.  changesListPresenter := self newList.  textPresenter := self newCode.  self setFocus.  methodsListPresenter contextMenu: self messageMenu.  changesListPresenter contextMenu: self changeSetMenu.  classesListPresenter contextMenu: self classMenu.  methodsListPresenter enableItemSubstringFilter.  classesListPresenter enableItemSubstringFilter.  changesListPresenter enableItemSubstringFilter.  changesListPresenter items: self model allChanges.  changesListPresenter display: [:item |  item name ].  classesListPresenter sortingBlock: [:a :b |  a name < b name ]setUp  super setUp.  application := SpMockApplication newbuildWidget  | newWidget |  newWidget := super buildWidget.  self presenter whenSyntaxHighlightChangedDo: [:hasSyntaxHighlight |  self setEditingModeFor: newWidget ].  ^newWidgetsortFunction: aBlock  sortFunction := aBlockisDialog  ^truetestActivationOnSingleClickShouldActivateOnClick  | activatedItem |  presenter     activateOnSingleClick;     whenActivatedDo: [:selection |  activatedItem := selection selectedItem ].  presenter clickAtPath: #(1).  self assert: activatedItem equals: 1testAboutText  | presenter window |  windowPresenter := SpWindowPresenter new.  windowPresenter aboutText: 'test'.  self assert: windowPresenter aboutText equals: 'test'.  windowPresenter close.  presenter := SpTextPresenter new.  [ window := presenter openWithSpec.  presenter withWindowDo: [:w |  w aboutText: 'test2' ].  self assert: presenter window aboutText equals: 'test2' ] ensure: [ window ifNotNil: #delete ]sortingBlock  ^sortingsetModelBeforeInitialization: aModel  wrappedPresenter := aModel.  wrappedPresenter owner: selftopFraction: anObject  topFraction := anObjectmodel  ^modelcontent  ^self subclassResponsibilityemptyDropList  dropListModel emptyListtestUnselectAllUnselectsSingleSelection  presenter     selectIndex: 1;     unselectAll.  self assert: presenter selection isEmptycurrentChangeSet  ^ChangeSet currentlistMorphClass  ^PluggableIconListMorphmenuColumn: column row: rowIndex  | menuPresenter |  menuPresenter := self model contextMenu.  menuPresenter ifNil: [ ^nil ].  ^SpBindings value: self model application adapterBindings during: [ menuPresenter value buildWithSpec ]maxWidthOf: aCollection  ^(aCollection collect: [:each |  (each valueOfProperty: #style) width ]) maxwhenWillBeBuiltDo: aBlock  self announcer when: SpWidgetWillBeBuilt do: aBlockmodalRelativeTo: aWindow  self deprecated: 'Do not use this directly. Use #openModalWithSpec (and family) instead.' on: '2019-02-26' in: #Pharo8.  self widgetDo: [:w |  aWindow spSetModal: w ]whenMenuChangedDo: aBlock  self property: #contextMenu whenChangedDo: aBlockselectIndexes: aCollection  self selectionMode selectIndexes: aCollectioninputTextDropList  ^subwidgetcheckboxWithLabelOnLeft: anObject  checkboxWithLabelOnLeft := anObjectstyleName  ^((self className withoutPrefix: 'SpMorphic') allButLast: 7) uncapitalizedcommandToTest  ^self commandClass new     context: self newMockContext;     yourselftestActivationOnSingleClickShouldActivateOnClick  | activatedItem |  activatedItem := nil.  presenter     activateOnSingleClick;     whenActivatedDo: [:selection |  activatedItem := selection selectedItem ].  presenter clickAtIndex: 1.  self assert: activatedItem equals: 10addPreamble  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  self model addPreambleTo: self selectedChangeSet.  changesListPresenter setSelectedItem: self selectedChangeSetclearUndoManager  asToolbarPresenter  ^SpToolBarPresenterBuilder new     visit: self;     toolbarPresenterwidth  ^self extent xisMatching: anItem  ^dataSource model performSearch: anItem data matching: patternbuildWidget  ^SpStubTabManagerView newopenModal: aPresenter withSpecLayout: aSpecLayout  ^self open: aPresenter withSpecLayout: aSpecLayout using: SpModalWindowPresentercolumns: newColumns  self widgetDo: [:w |  | columns |        columns := newColumns collect: [:each |  each buildWithSpec ].        w columns: columns.        w resizerChanged.        w updateList ]whenMorphChangedDo: aBlock  self property: #morph whenChangedDo: aBlocktestSelectPresenterIndexSetsSelectedIndexInWidget  presenter selectPath: #(1).  self assert: (self adapter selectedPaths includes: #(1))layout: aLayout  | layout |  layout := aLayout asMorphicLayout.  self widgetDo: [:w |  w layoutFrame: layout ]shortcut: aShortcut  shortcut := aShortcutbuttonWithIcon: anObject  buttonWithIcon := anObjecttestTitle  | presenter window |  windowPresenter := SpTextPresenter new openWithSpec.  self assert: windowPresenter isDisplayed.  self assert: windowPresenter title equals: 'Text'.  windowPresenter close.  presenter := SpTextPresenter new.  [ window := presenter openWithSpec.  presenter withWindowDo: [:w |  w title: 'Test Window' ].  self assert: presenter window title equals: 'Test Window' ] ensure: [ window ifNotNil: #delete ]editPostscript  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  self selectedChangeSet editPostscriptrefreshList  ^self widget refreshnewButtonBar  ^self instantiate: SpButtonBarPresentericonFor: anEyeElement  anEyeElement withErrorsDo: [:error |  ^self iconFor: anEyeElement error: error ].  ^[ anEyeElement icon ] on: Error do: [:error |  self iconFor: anEyeElement error: error ]removeTab: aTab  aTab adapter deleteaddLast: aName expand: shouldExpand  self addLast: aName withConstraints: [:constraints |  constraints expand: shouldExpand ]fromSton: stonReader  styles := stonReader parseListtestOpenWithSpec  [ self openInstance ] on: Error do: [:e |  self fail: 'Broken class simple instance: ' , self classToTest asString , '' , e signalerContext shortStack ]includesItem: anItem  ^self selectedItems includes: anItemcanShrink  ^shrinknewToolBar  ^self instantiate: SpToolBarPresenterconfigureUnix: anApplication  whenValueChangedDo: aBlock  self subclassResponsibilitytakeHighlight  self widgetDo: [:w |  w changed: #takeHighlight ]defaultWindowPresenterClass  ^SpWindowPresenternewContainerMorph  ^PanelMorph new     layoutPolicy: TableLayout new;     hResizing: #spaceFill;     vResizing: #spaceFill;     listDirection: #topToBottom;     yourselftestPreviousMonthButton  | d |  d := Date year: 2018 month: 9 day: 15.  calendar adaptToDate: d.  self assert: calendar monthYearLabel label equals: d month asString.  calendar previousMonthButton performAction.  self assert: calendar monthYearLabel label equals: (d addMonths: -1) month asStringisStyleProperty  ^falseradio1  ^radio1initializeTSearchable  self searchMatching: [:item :pattern |  self performDefaultSearch: item matching: pattern ]numberOfColumns: aNumber withWidths: widths  columns := OrderedCollection new.  (1 to: aNumber) do: [:index |  self addColumn: ((SpStringTableColumn evaluated: [:entity |  (self displayBlock value: entity) at: index ])                 width: (widths at: index);                 yourself) ]printDescription  ^description textdoActivateAtIndex: anIndex  self model at: anIndex ifAbsent: [ ^self ].  activationBlock cull: ((SpSingleSelectionMode on: self)           basicSelectIndex: anIndex;           yourself)topOffset  ^layoutFrame topOffsetincludesIndex: anIndex  ^self selectedIndex = anIndexicon: anObject  icon := anObjectrightOffset  ^0shouldShowInTree  ^falseinitializeWidgets  toolbar := self instantiate: EyeInspectorToolBarclassToTest  ^SpTablePresentericon  ^self model iconsetUp  super setUp.  application := SpMockApplication newiconName: aSelector  icon value: (self iconNamed: aSelector)waitUntilUIRedrawed  self isRunningInUIProcess ifTrue: [ self currentWorld doOneCycle.        ^self ].  self currentWorld defer: [ uiWaitingSemaphore ifNotNil: #signal ].  uiWaitingSemaphore wait: self defaultWaitDurationpreviousButton  ^previousButtonselectedPaths  ^self widget selectedIndexes collect: [:e |  self widget dataSource pathFromIndex: e ]testActivationOnDoubleClickShouldNotActivateOnClick  | activatedItem |  presenter     activateOnDoubleClick;     whenActivatedDo: [:selection |  activatedItem := selection selectedItem ].  presenter clickAtPath: #(1).  self assert: activatedItem isNilobjectClass  ^self object classperformTest  backendForTest runTest: [ presenter := self classToTest new.        self initializeTestedInstance.        super performTest ]isCheckList  ^isCheckList valuelongLabel  ^value identityHash asString , ': ' , value printStringremoveContact: aContact  contents remove: aContactborderColor: aColor  borderColor := aColorisSearchEnabled  ^searchEnabledborderWidth: anObject  borderWidth := anObjectcommands  ^commandsinitialize  super initialize.  displaySymbol := #displayString.  placeholder := 'Choose one'.  possibleEntities := #().  selectDialog := [  ]basicRemoveTab: aTab  (tabs value remove: aTab ifAbsent: [ ^self ]) owner: nilexploreSelectedObject  self selectedObjectDo: [:anObject |  anObject inspect ]digits: aNumber  digits := aNumbertext: aString  widget     setText: aString;     acceptTextInModeldisplay  ^displayreadSelection  ^self readSelectionBlock cull: self text cull: selfgenerateNullPresentersInstVarNames: anInteger  ^(1 to: anInteger) collect: [:i |  self generateUniqueInstanceVariableName ]testDeactivateRaisesChangedEventOnce  presenter state: true.  self assertWith: [:times |  times = 1 ] timesRaisedEvent: #whenChangedDo: inPresenter: presenter whenDoing: [ presenter state: false ]isOutput  ^falsetestSmokeMenu  presenter menu: (SpMenuPresenter new           addGroup: [:group |  group                 addItem: [:item |  item name: 'One' ];                 addItem: [:item |  item name: 'Two' ];                 addItem: [:item |  item name: 'Three' ] ];           yourself).  self openInstanceselectedIndex: integer  ^self list setSelectedIndex: integertestSelectingAPathUpdatesSelectionInPresenter  self presenter selection     selectPath: #(1 2);     selectPath: #(2 3).  self assert: self adapter selectedPaths asArray equals: #(#(1 2) #(2 3))rootNodeHolder: aBlock  tree rootNodeHolder: aBlockinput  ^subwidget inputbuildWithSpec  ^self widgetitemsInput  ^itemsInputtestSelectManyIndexesKeepsAllSelected  presenter selectPath: #(1).  presenter selectPath: #(2).  self assert: self adapter selectedPaths equals: #(#(1) #(2))browseImplementors  SystemNavigation new browseAllImplementorsOf: rgMethod selectorchanged: aSymbol  treeModel changed: aSymbolspecSelector  ^specSelectorballoonText  | balloonText |  balloonText := self model description.  balloonText ifNil: [ ^nil ].  ^(balloonText isBlock or: [ balloonText isMessageSend ]) ifTrue: [ balloonText cull: self model ] ifFalse: [ balloonText ]from: aPresenter to: anotherPresenter transform: aValuable  self from: aPresenter to: anotherPresenter transform: aValuable postTransmission: niltestSetSelectIndexOutsideRangeRaisesSelectionChangeEventWithUnsetItem  | selectedItem |  presenter whenSelectionChangedDo: [:selection |  selectedItem := selection selectedItem ].  presenter selectIndex: 4.  self assert: selectedItem equals: niltestSetSelectIndexRaisesSelectionIndexChangeEventWithSelectedIndex  | selectedIndex |  presenter selection whenChangedDo: [:selection |  selectedIndex := selection selectedIndex ].  presenter selectIndex: 1.  self assert: selectedIndex equals: 1rename: aChangeSet  | newName |  newName := UIManager default request: 'New name for this change set' initialAnswer: aChangeSet name.  (newName = aChangeSet name or: [ newName isEmptyOrNil ]) ifTrue: [ ^UIManager default inform: 'Please give a new name' ].  (ChangeSet named: newName) ifNotNil: [ ^UIManager default inform: 'Sorry that name is already used' ].  aChangeSet name: newName.  ^aChangeSetcountNumberOfProportionals  self commands do: [:e |  e layoutFrame hasNoOffsets ifTrue: [ (e layoutFrame leftFraction == 0 and: [ e layoutFrame rightFraction == 1 ]) ifFalse: [ autoFractionComputation := false ].              numberOfProportionals := numberOfProportionals + 1 ] ]contents  ^self basicAt: 1displayBlock: aBlock  displayBlock value: aBlocktestAddWithPaddingHorizontal  | base presenter layout |  base := SpBoxLayoutWithTableForTestPresenter new.  presenter := SpLabelPresenter new.  layout := SpBoxLayout newHorizontal     add: presenter expand: false fill: false padding: 10;     yourself.  base buildAdapterWithSpecLayout: layout.  self assert: presenter adapter widget extent equals: presenter adapter widget owner extent - (20 @ 0)transferBlock  ^transferBlockinitialize  self class initializeSlots: self.  super initialize.  self spacing: 0.  self borderWidth: 0.  self visiblePages: 2removeEntryCompletion  self entryCompletion: nilproperty: aName whenChangedDo: aBlockClosure  (self observablePropertyNamed: aName) whenChangedDo: aBlockClosuretestSelectMultipleItemsAddsAllToSelectedItemList  presenter selectItem: 10.  presenter selectItem: 30.  self assert: (presenter selection includesItem: 10).  self assert: (presenter selection includesItem: 30)inferiorToMaximum: aNumber  ^self model maximum ifNil: [ aNumber ] ifNotNil: [:max |  aNumber min: max ]printOn: aStream  super printOn: aStream.  self title value ifNotNil: [:t |  aStream           nextPutAll: ' ''';           nextPutAll: t;           nextPutAll: '''' ]presenter  ^presentermarks: anObject  marks := anObjectbottomRightOffset: aPoint  bottomOffset := aPoint y.  rightOffset := aPoint xmainMessage: aTextOrPresenter  mainMessage := aTextOrPresenterassertIcon: anAlphaImageMorph equals: aForm  self assert: (anAlphaImageMorph ifNotNil: #form) = aFormregisterClassActions  classesListPresenter whenSelectionChangedDo: [:selection |  self updateTextContents.        textPresenter behavior: selection selectedItem.        textPresenter syntaxHighlight: false.        selection selectedItem ifNil: [ methodsListPresenter items: {} ] ifNotNil: [:class |  methodsListPresenter unselectAll.              methodsListPresenter items: (self selectedChangeSet selectorsInClass: class name) sort ] ]buildTab: aTab  ^aTab buildWithSpec     when: #tabDeleted send: #tabDeleted: to: self;     yourselfdefaultSpecSelector  (Pragma allNamed: #spec: from: self class class to: SpAbstractPresenter class class) detect: [:each |  (each argumentAt: 1) = #default ] ifFound: [:pragma |  ^pragma methodSelector ].  ^(Pragma allNamed: #spec from: self class class to: SpAbstractPresenter class class) ifEmpty: [ #defaultSpec ] ifNotEmpty: [:pragmas |  pragmas size = 1 ifTrue: [ pragmas first methodSelector ] ifFalse: [ #defaultSpec ] ]insert: aString at: positionIndex  self withAdapterDo: [:anAdapter |  anAdapter insert: aString at: positionIndex ]title: aString  title := aStringtestRemoveTabFromManager2  presenter addTab: redTab.  self assertCollection: presenter tabs hasSameElements: {redTab}.  self openInstance.  redTab adapter widget delete.  self assertCollection: presenter tabs hasSameElements: #().  self assertCollection: (self morphicTabsFor: presenter) hasSameElements: #()isVertical  ^self direction = SpLayoutDirection verticalinitialize  super initialize.  self whenDaySelectedBlock: [:aDate |   ]setBrowseModel  browseModel     state: false;     label: 'Browse';     action: [ self browseMethod ]tearDown  window ifNotNil: [ window delete ].  super tearDowninitialize  super initialize.  model := SpCollectionListModel on: #().  selection := SpSingleSelectionMode on: self.  displayBlock := [:itemModel :item |  item label ].  iconBlock := [:itemModel :item |  item icon ].  startsWithSelection := truemin: aNumber  ^self sliderInput min: aNumberbuildWidgetAutoRefresh  ^UpdatingMenuItemMorph new     target: self;     balloonTextSelector: #balloonText;     subMenuSelector: #subMenu;     nameSelector: #name;     selector: #performMenuActionWith:;     argumentsBlock: self actionArguments;     getStateSelector: #state;     iconSelector: #icon;     enablementSelector: #enabled;     keyText: self shortcutText;     yourselfinitializeWidgets  defineOutputPorts  ^{SpDropListSelectionPort new}execute  self selectedContact name: self context newName.  self contactBookPresenter updateViewmessages  ^listModel itemsclassToTest  ^SpDropListPresenteraddSpecialFields: elements  elements add: (DynamicEyeElement host: self object label: 'year' value: [ self object year ]).  elements add: (DynamicEyeElement host: self object label: 'month of year' value: [ self object monthIndex ]).  elements add: (DynamicEyeElement host: self object label: 'day of month' value: [ self object dayOfMonth ]).  elements add: (DynamicEyeElement host: self object label: 'full hours' value: [ self object hours ]).  elements add: (DynamicEyeElement host: self object label: 'full minutes' value: [ self object minutes ]).  elements add: (DynamicEyeElement host: self object label: 'full seconds' value: [ self object seconds ]).  elements add: (DynamicEyeElement host: self object label: 'utc' value: [ self object asUTC ])bold: anObject  bold := anObjecttestInitializePackageListShouldBeSelectTheFistItem  self assert: biChooseMethod packageList selection selectedIndex equals: 1resetSelection  self dropList resetSelectioninitializePresenters  | passwordInput |  passwordInput := self newTextInput     bePassword;     yourself.  email := self instantiate: (SpLabelledPresenter label: 'Email' input: self newTextInput description: 'Email you will use to send activations mails to your users.').  password := self instantiate: (SpLabelledPresenter label: 'Password' input: passwordInput description: 'Password of the email account used.').  self focusOrder     add: email;     add: passworddefaultColor  ^nilcenterWidget: aWindow  self deprecated: 'This feature is to tight to Morphic to be in Spec. If you want this feature in a Morphic specific Spec application you should apply it yourself on the widget.		aWindow			fullBounds;			center: self adatper widget center' on: '2019-06-25' in: #Pharo8codePaneMenu: aMenu shifted: shifted  | menuPresenter |  menuPresenter := self model contextMenu.  menuPresenter ifNil: [ ^nil ].  ^SpBindings value: self model application adapterBindings during: [ menuPresenter value buildWithSpec ]setUp  super setUp.  menuBuilder := SpMenuPresenterBuilder new.  commandsGroup := (CmCommandGroup named: 'root') asSpecGroup beRoot     register: (CmBlockCommand new           name: 'c1';           block: [  ];           yourself) asSpecCommand;     register: ((CmCommandGroup named: 'sub1') asSpecGroup           register: (CmBlockCommand new                 name: 'c2';                 block: [  ];                 yourself) asSpecCommand;           register: (CmBlockCommand new                 name: 'c3';                 block: [  ];                 yourself) asSpecCommand);     register: (CmBlockCommand new           name: 'c4';           block: [  ];           yourself) asSpecCommand;     yourselfisNonEditableRow: aRow column: aColumn  ^(self widget dataSource cellColumn: (self widget columns at: aColumn) row: aRow) submorphs allSatisfy: [:e |  e asReadOnlyMorph == e ]testSetSelectItemRaisesSelectionItemChangeEventWithSelectedItem  | selectedItem |  presenter whenSelectionChangedDo: [:selection |  selectedItem := selection selectedItem ].  presenter selectItem: 10.  self assert: selectedItem equals: 10accessorCode  ^'(self tempNamed: ' , self tempName printString , ')'placeholder: aText  ^self model placeholder: aTextactualPageMorph: anObject  actualPageMorph := anObjectswitchAutoscale  autoScale := autoScale notsyncMorphPosition  currentVerticalScrollPosition = text scrollValue y ifTrue: [ ^self ].  currentVerticalScrollPosition := text scrollValue y.  self needRebuild: false.  text needRebuild: false.  self buildWithSpecLayout: self defaultSpecLayouttestSelectPathsThenSelectInvalidPathKeepsElements  presenter     selectPaths: {#(1 3) .         #(2 2)};     selectPaths: {#(50) .         #(60 2)}.  self assert: (presenter selection includesItems: #(10 6))headerColumn: column  column id ifNil: [ ^nil ].  ^FTCellMorph new     listCentering: #left;     addMorph: column id asMorph asReadOnlyMorph;     yourselfstate  ^self presenter statesetSelectedIndex: anIndex  self deprecated: 'Use #selectIndex: instead' transformWith: '`@receiver setSelectedIndex: `@argument' -> '`@receiver selectIndex: `@argument'.  self selectIndex: anIndexinitializePresenters  self class keys do: [:aKey |  self additionalSubpresentersMap at: aKey put: (self newButton label: aKey) ].  subpresenter4 := self newButton label: 'subpresenter4'allowMenuOnNoItem  ^allowMenuOnNoItem valueiconNamed: aSymbol  aSymbol ~= #banana ifTrue: [ self error: 'Only #banana icon is needed for tests.' ].  ^self bananatestScrollUpToPreviousIndexScrollsTopToIndex  self flag: #pharo7.  SystemVersion current major < 8 ifTrue: [ self skip ].  presenter items: (1 to: 500).  presenter verticalAlignment desiredVisibleRow: 100.  self openInstance.  presenter verticalAlignment desiredVisibleRow: 50.  self assert: presenter verticalAlignment firstVisibleRowIndex equals: 50removeAll  collection := #().  self refreshList.  self announcer announce: (ValueChanged newValue: self)label: anObject  labelBlock := anObjectnewColumn: aBlock width: aNumber  self newColumn: aBlock origin: 0 @ 0 corner: 0 @ 1 offsetOrigin: 0 @ 0 offsetCorner: aNumber @ 0hideColumnHeaders  showColumnHeaders := falsecurrentMethod  self deprecated: 'Use #selectedMessage instead' transformWith: '`@receiver currentMethod' -> '`@receiver selectedMessage'.  ^self selectedMessageclasses: aList  classListPresenter items = aList ifTrue: [ ^self ].  classListPresenter     items: aList;     selectIndex: 1testSelectItemOutsideRangeHasNoSelectedItems  presenter selectItem: 4000.  self assert: presenter selection selectedItems isEmptyautoDeselect: aBoolean  self deprecated: 'Should not use. This feature is not supported anymore'.  autoDeselect := aBooleannewIndex: anObject  newIndex := anObjectisStyleClass  ^falseacceptDroppingMorph: draggedMorph event: event inMorph: source  ^self model acceptDroppingMorph: draggedMorph event: event inMorph: sourcetestUnselectSelectedItemRemovesItFromSelectionList  presenter     selectItem: 10;     unselectItem: 10.  self assert: presenter selection isEmptyvalue  ^self host basicAt: self indexcollection  ^collectionselectionInterval  ^self widget selectionIntervaltestSelectMultiplePathsAddsAllToSelectedPathList  presenter     selectPath: #(1 2);     selectPath: #(2 2).  self assert: (presenter selection includesItem: 3).  self assert: (presenter selection includesItem: 6).  self assert: (presenter selection includesPath: #(1 2)).  self assert: (presenter selection includesPath: #(2 2))mouseDown: anEvent  (self bounds containsPoint: anEvent cursorPoint) ifTrue: [ self fillStyle: self pressedFillStyle ].  lastMouse := anEvent cursorPoint - self position.  self eventHandler ifNotNil: [:handler |  handler mouseDown: anEvent fromMorph: self ]isHorizontal  ^isHorizontaltestModelSettingValueHolderToValueHolder  | point point2 valueHolder presenter |  point := 40 @ 54.  point2 := 1 @ 0.  presenter := SpTestingPresenterWithModel on: point.  valueHolder := NewValueHolder value: point2.  self assert: presenter announcingObject isSpAnnouncingObject.  self assert: presenter announcingObject isValueHolder.  self deny: point2 isSpAnnouncingObject.  self assert: valueHolder isValueHolder.  presenter model: valueHolder.  self assert: presenter announcingObject isSpAnnouncingObject.  self assert: presenter announcingObject isValueHolder.  self assert: presenter model == point2.  self assert: presenter announcingObject == valueHolder.  self assert: presenter announcingObject announcer numberOfSubscriptions > 0updateTree  tree updateTreeautoAccept: aBoolean  input autoAccept: aBooleanrebuildDynamicPresenter  | allCards showedCards |  allCards := ((1 to: self cardPairsCount) , (1 to: self cardPairsCount)) shuffled.  showedCards := OrderedCollection new.  builder := SpDynamicPresentersListBuilder new     modelObjects: allCards;     presenter: SpButtonPresenter configuredAs: [:presenter :modelObject |  self gameLogicWithShowedCards: showedCards objectConcerned: modelObject andAssociatedPresenter: presenter ];     layoutBuilder: (SpDynamicLeftToRightColumnsLayout columns: 10);     yourself.  self newDynamicPresentersListIn: #dynamicPresenter usingBuilder: builderbuildClassDescriptionFor: changeSet class: class  ^String streamContents: [:stream |  (changeSet classChangeAt: class name) do: [:each |  stream nextPutAll: (self classDescriptionsMap at: each) ] separatedBy: [ stream cr ] ]redMorphTab  | tab |  tab := SpTabPresenter new.  tab     label: 'Red Morph';     icon: (tab iconNamed: #smallBackIcon);     contents: (Morph new           color: Color red;           yourself).  ^tabdefaultPage  ^self availablePages firstwhenSelectionIndexChanged: aBlock  self deprecated: 'Use #selection whenChangedDo: instead' transformWith: '`@receiver whenSelectionIndexChanged: `@argument' -> '`@receiver selection whenChangedDo: [ :selection | `@argument value: selection selectedIndex ]'.  ^self selection whenChangedDo: [:selection |  aBlock value: selection selectedIndex ]modelChanged  cancel  owner ifNil: [ self delete ] ifNotNil: [ owner delete ]dragPassengersFor: item inMorph: dragSource  ^{(self dragTransformationBlock cull: item cull: dragSource)}menu: anObject  menu := anObjectcenteredRelativeTo: aModel  self withWindowDo: [:w |  w centeredRelativeTo: aModel ]initialize  super initializex: anObject  x := anObjectitemAtPath: anArray  ^self itemAt: anArray first of: self roots then: anArray allButFirstleftLabel  ^self model leftLabeltestSelectMultipleIndexesAddsAllToSelectedItemList  presenter selectIndex: 1.  presenter selectIndex: 3.  self assert: (presenter selection includesItem: 10).  self assert: (presenter selection includesItem: 30)readSelectionBlock: aBlock  ^readSelection := aBlocksetIndex: anIndex  self dropList setIndex: anIndextestUnselectAllInWidgetRaisesEmptySelectionChangeEvent  | gotSelection |  self adapter selectIndex: 1.  presenter selection whenChangedDo: [:selection |  gotSelection := selection ].  self adapter selectIndex: 0.  self assert: gotSelection isEmptydisplayValueAt: anIndex  ^self displayValueOf: (model at: anIndex)additionalSubpresentersMap  self flag: #TOREMOVE.  ^additionalSubpresentersMap ifNil: [ additionalSubpresentersMap := Dictionary new ]printOn: aStream  super printOn: aStream.  aStream     nextPutAll: '[ ';     print: self value;     nextPutAll: ' ]'setUp  super setUp.  self initializeSemaphorenewPanel  ^super newPanel     layoutPolicy: SpMorphicGridLayout new;     yourselfbuildMorph: aPresenter constraints: constraints  | childMorph |  childMorph := aPresenter buildWithSpec: constraints spec.  self applyStyle: aPresenter to: childMorph.  childMorph := self addConstraits: constraints toChild: childMorph.  ^childMorphselector  ^selectorlabel  ^'class'packageListAction  packageList transmitTo: classList transform: [:selectedPacakge |  selectedPacakge ifNotNil: [ selectedPacakge classes asOrderedCollection ] ] postTransmission: [ classList selectIndex: 1 ]selectItems: aCollection  aCollection ifEmpty: [ ^self unselectAll ].  self selectItem: aCollection firstsearchedString: searchedString in: aString  | string interval firstIndex |  searchedString ifNil: [ ^0 to: 0 ].  aString isEmptyOrNil ifTrue: [ ^0 to: 0 ].  string := aString asString.  interval := 0 to: 0.  (searchedString includes: $:) ifTrue: [ | list |        list := searchedString substrings: ':'.        list size = 1 ifTrue: [ firstIndex := self findFirstOccurrenceOf: searchedString in: string.              firstIndex isZero ifFalse: [ interval := firstIndex to: firstIndex + searchedString size - 1 ] ] ifFalse: [ | lastIndex |              firstIndex := self findFirstOccurrenceOf: list first , ':' in: string.              firstIndex > 0 ifTrue: [ lastIndex := string findString: list last , ':' startingAt: firstIndex + (list first size - 1).                    interval := firstIndex to: lastIndex + list last size ] ] ] ifFalse: [ firstIndex := self findFirstOccurrenceOf: searchedString in: string.        firstIndex > 0 ifTrue: [ interval := firstIndex to: firstIndex + searchedString size - 1 ] ].  ^intervallayout: aGridLayout  layout := aGridLayoutclassToTest  ^SpCheckBoxExamplelastBaseLine  ^self baseLines lastinitializeTestedInstance  super initializeTestedInstance.  presenter     beSingleSelection;     items: #(10 20 30)height  ^self extent yblockToPerformOnWrappers: aBlock  blockToPerformOnWrappers value: aBlockselectionOrLine  ^self selection ifEmpty: [ self           selectLine;           selection ]showOnlySource: aBoolean  self widgetDo: [:w |  w showOnlySource: aBoolean ]menuHolder  ^menuHoldershortCuts  | shortCuts |  shortCuts := Dictionary new.  shortCuts at: $d meta put: [ self diveIntoSelectedObject ].  shortCuts at: $i meta put: [ self inspectSelectedObjectInNewWindow ].  shortCuts at: $i meta shift put: [ self exploreSelectedObject ].  shortCuts at: $b meta put: [ self browseSelectedObject ].  shortCuts at: $h meta put: [ self browseSelectedObjectClassHierarchy ].  ^shortCutstype  ^typetestSelectIndexThenSelectOutsideRangeKeepsFirstElement  presenter selectIndex: 1.  presenter selectIndex: 50.  self assert: (presenter selection includesItem: 10)takeKeyboardFocus  self widget ifNotNil: [:w |  w takeKeyboardFocus ]hasIcons  ^self icons notNilto: aPresenter port: aSymbol  self toPort: (aPresenter inputPortNamed: aSymbol)hasSelectedObject  ^trueselectedIndex  ^self list selectedIndexdoubleClickAtIndex: anIndex  self selectIndex: anIndex.  activateOnSingleClick ifTrue: [ ^self ].  self doActivateAtIndex: anIndextestSelectAll  presenter beSingleSelection.  presenter selectAll.  self assertEmpty: presenter selection selectedItems.  presenter beMultipleSelection.  presenter selectAll.  self assert: presenter selection selectedItems asArray equals: #(10 20 30)packageNameForItem: anItem  ^anItem package ifNil: [ '' ] ifNotNil: [:package |  package name ]whenIconsChanged: aBlock  self deprecated: 'Use #whenIconsChangedDo: instead.' transformWith: '`@receiver whenIconsChanged: `@statements' -> '`@receiver whenIconsChangedDo: `@statements'.  self whenIconsChangedDo: aBlockclassesListPresenter  ^classesListPresenterobject: anObject  object := anObjectpresenter: aPresenter  aPresenter owner: self.  self retrievingBlock: [ aPresenter buildWithSpec ]selectedIndex  ^self presenter selection selectedPath ifNotEmpty: #first ifEmpty: [ 0 ]buildLabelFrom: aString  ^LabelMorph newLabel: aStringtestSelectItemsThenSelectOutsideRangeKeepsElements  presenter selectItems: {10 .         20}.  presenter selectItems: {4000 .         5000}.  self assert: (presenter selection includesItems: {10 .               20})beHorizontalAlignmentStart  self hAlign: SpGridAlignment starttestCloseWindowRemovesItFromWindowCollection  | window |  window := (application newPresenter: SpButtonPresenter) openWithSpec.  window close.  self deny: (application windows includes: window)emitStore: aMethodBuilder  | temp |  temp := Object new.  aMethodBuilder addTemp: temp.  aMethodBuilder storeTemp: temp.  aMethodBuilder popTop.  aMethodBuilder pushInstVar: index.  aMethodBuilder pushTemp: temp.  aMethodBuilder send: #value:showBoth  self property: #showOnlySource rawValue: false.  self property: #showOnlyDestination rawValue: false.  self changed: #showBoth with: {}foreground  ^foregroundmessage: aString  message := aStringtestTypePerformsSearch  self presenter selection selectIndex: 1.  self adapter type: '2'.  self assert: self presenter selection selectedIndex equals: 2add: aSpec origin: originPoint corner: cornerPoint  self add: aSpec origin: originPoint corner: cornerPoint offsetOrigin: 0 @ 0 offsetCorner: 0 @ 0execute  self context acceptpreventUpdatesDuring: aBlock  isUpdating ifTrue: [ ^self ].  isUpdating := true.  aBlock ensure: [ isUpdating := false ]initializePresenters  actionBar := self newActionBar     add: (self newButton           label: 'Add';           icon: (self iconNamed: #smallOk);           help: 'Add.';           action: [ World defer: [ self inform: 'Add' ] ];           yourself);     add: (self newButton           label: 'Remove';           icon: (self iconNamed: #smallCancel);           help: 'Remove.';           action: [ World defer: [ self inform: 'Remove' ] ];           yourself);     addLast: (self newButton           label: 'Other';           help: 'Other.';           action: [ World defer: [ self inform: 'Other' ] ];           yourself);     yourself.  text := self newTextclearFilterButton  ^clearFilterButtontransmitDo: aBlock  self newTransmission     from: self;     do: aBlock;     applyinitialize  super initialize.  currentVerticalScrollPosition := 0browseInstVarRefs  ^self systemNavigation browseInstVarRefs: self hostClasswrapWith: aBlock  listModel display: aBlockmorph  ^presenter adapter widgetremoveItem: anObject  self items remove: anObject.  list selection unselectAllfirstLabel: firstLabel secondLabel: secondLabel  self firstButton label: firstLabel.  self secondButton label: secondLabelaskOkToClose  ^askOkToCloseminimize  self widgetDo: [:w |  w minimize ]initializeWindow: aWindowPresenter  aWindowPresenter initialExtent: 900 @ 530.  aWindowPresenter title: self titleargumentBlock  ^[ Array with: self model ]matchTokenFilter: aFilter  ^self matchTokenFilterBlock value: aFiltertransferFor: passenger from: source  ^self transferBlock value: passenger value: sourcewhenSelectedItemChanged: aBlock  self deprecated: 'Use #whenSelectedItemChangedDo: instead.' transformWith: '`@receiver whenSelectedItemChanged: `@statements' -> '`@receiver whenSelectedItemChangedDo: `@statements'.  self whenSelectedItemChangedDo: aBlocktestDoesNotShowIcons  backendForTest assertIcon: self adapter displayedIcon equals: nilclicked  widget performAction.  self model state: widget isPressedupdateLabel  label label: (String streamContents: [:s |  {button1 .               button2 .               button3} do: [:button |  s                       << button label;                       << ' : ';                       << (button state ifTrue: [ 'V' ] ifFalse: [ 'X' ]) ] separatedBy: [ s << ' - ' ] ])rightFraction  ^rightFractioncontent  ^'I am a modal demo with custom actions buttons.  I set closeOnBackdropClick to false so that the user cannot click on the backdrop to close the modal.'testColumnsAreDynamicallySetInWidget  self presenter     displayBlock: [:item |  {item .         42} ];     items: {1 .         2 .         3}.  self assert: self widget columns size equals: 2shown: anObject  shown := anObjectupdateBlock: aBlock  updateBlock := aBlockchanged  self world ifNil: [ ^self ].  ^fullBounds ifNil: [ self invalidRect: self bounds ] ifNotNil: [ self invalidRect: fullBounds ]dragPassengersFor: item inMorph: dragSource  ^self model dragPassengersFor: item inMorph: dragSourcetestIfSingleRadioButtonStartsSelected  self assert: self adapter statehasEditingConflicts: aBoolean  self widgetDo: [:w |  w hasEditingConflicts: aBoolean ]autoFractionComputation  | delta |  delta := numberOfProportionals isZero ifTrue: [ 0 ] ifFalse: [ 1 / numberOfProportionals ].  self commands doWithIndex: [:e :idx |  e layoutFrame hasNoOffsets ifTrue: [ self setWidgetLayoutWithNoOffset: e at: idx delta: delta ] ifFalse: [ self setWidgetLayoutWithOffset: e at: idx ] ]sortingBlock: aBlock  ^self list sortingBlock: aBlockregisterCancelButtonEvents  cancelButton     label: 'Cancel';     enabled: true;     state: falsesetOffsetsFor: widget top: top left: left bottom: bottom right: right borderWidth: windowBorderWidth  self setRightOffset: right for: windowBorderWidth borderWidth: widget.  self setLeftOffset: left for: widget borderWidth: windowBorderWidth.  self setBottomOffset: bottom for: widget borderWidth: windowBorderWidth.  self setTopOffset: top for: widget borderWidth: windowBorderWidthchangeSetMenuFrom: sourcePanel to: destinationPanel  ^sourcePanel changeSetMenu     addGroup: [:aGroup |  aGroup           addItem: [:anItem |  anItem                 name: 'Copy all to the other change set';                 shortcut: $s meta;                 action: [ self copyAllFrom: sourcePanel to: destinationPanel ] ];           addItem: [:anItem |  anItem                 name: 'Submerge into the other change set';                 action: [ self submerge: sourcePanel into: destinationPanel ] ];           addItem: [:anItem |  anItem                 name: 'Subtract the other change set';                 shortcut: $- meta;                 action: [ self subtractFrom: sourcePanel to: destinationPanel ] ] ];     yourselfwindow: aWindowPresenter  window := aWindowPresenterresetSelection  tree resetSelectioninitializePresenters  list1 := self newList.  list2 := self newList.  list3 := self newList.  label := self newLabel.  multiLabel := self newLabel.  list1     items: self class environment allClasses;     contextMenu: self list1Menu.  list2     items: self class environment allClasses;     sortingBlock: [:a :b |  a asString size < b asString size ];     beMultipleSelection.  list3     items: self class environment allClasses;     itemFilter: [:item :string |  item asString includesSubstring: string ];     icons: [:elem |  self iconFor: elem ].  label label: 'No selection'.  multiLabel label: 'No multi selection (from list 2 only)'index  ^indexwhenSelectedItemChanged: aBlock  self deprecated: 'Use #whenSelectedItemChangedDo: instead' transformWith: '`@receiver whenSelectedItemChanged: `@argument' -> '`@receiver whenSelectedItemChangedDo: `@argument'.  ^self whenSelectionChangedDo: [:selection |  aBlock cull: selection selectedItem ]styleName: aString  styleName := aStringadd: aPresenter  self add: aPresenter constraints: SpBoxConstraints newisDisplayModeIcons  ^self displayMode = SpToolBarDisplayMode modeIconremoveAllItems  leftItems := OrderedCollection new.  rightItems := OrderedCollection newsurface  ^widget surfacenewRadioButton  ^self instantiate: SpRadioButtonPresentertestResult  | dialog app |  app := SpMockApplication new.  dialog := SpVersatileDialogPresenter newApplication: app.  dialog mainMessage: 'Save content' asText allBold.  dialog addButton: #save text: 'Save' value: true.  dialog addButton: #cancel text: 'Cancel' value: false.  dialog mainIcon: (self iconNamed: #question).  dialog moreOptionsArea: (dialog newCheckBox label: 'Save header').  dialog openModalWithSpec.  dialog withWindowDo: [:w |  w title: 'Confirmation' ].  (dialog buttons at: #save) performAction.  dialog moreOptionsArea click.  self assert: dialog result.  self assert: dialog moreOptionsArea statepageIndex  ^pageIndexacceptAction  ^acceptActiontestTakeKeyboardFocus  mock := SpMockFocusOrderPresenter new     openWithSpec;     yourself.  self takeKeyboardFocus: mock.  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenter.  self takeKeyboardFocus: (mock presenterAt: #secondPresenter).  self deny: (mock presenterAt: #firstPresenter) equals: self focusedPresenter.  self assert: (mock presenterAt: #secondPresenter) equals: self focusedPresenter.  self takeKeyboardFocus: (mock presenterAt: #firstPresenter).  self assert: (mock presenterAt: #firstPresenter) equals: self focusedPresenter.  self deny: (mock presenterAt: #secondPresenter) equals: self focusedPresenterdynamicPage  ^SpNotebookPage title: 'Dynamic' icon: (self iconNamed: #nautilusIcon) provider: [ SpDynamicWidgetChange new ]model  ^widget modelinitializePresenters  element11 := self newButton label: #element11.  element21 := self newButton label: #element21.  element12 := self newButton label: #element12.  element22 := self newButton label: #element22.  #('element11' 'element12' 'element21' 'element22' 'Row1' 'Row2') do: [:ele |  properties at: ele put: (Dictionary with: #expanded -> true with: #filled -> true with: #padding -> 5).        self presenterAt: ele , 'Expanded' put: (self newCheckBox                 label: 'Expanded';                 state: true;                 whenChangedDo: [:value |  (properties at: ele) at: #expanded put: value.                    self refresh ];                 yourself).        self presenterAt: ele , 'Filled' put: (self newCheckBox                 label: 'Filled';                 state: true;                 whenChangedDo: [:value |  (properties at: ele) at: #filled put: value.                    self refresh ];                 yourself).        self presenterAt: ele , 'Padding' put: (self newSlider                 min: 0;                 max: 50;                 value: 5;                 whenValueChangedDo: [:value |  (properties at: ele) at: #padding put: value.                    self refresh ];                 yourself) ]testDeactivateRaisesChangedEvent  presenter state: true.  self assertEvent: #whenChangedDo: isRaisedInPresenter: presenter whenDoing: [ presenter state: false ]addInitialPanel  min: anObject  min := anObjectwhenValueChangedDo: aBlock  self property: #value whenChangedDo: aBlockisCheckList  ^self model isCheckListdesiredVisibleRow: anInteger  desiredVisibleRow := anIntegercontents  ^contentsregisterEvents  self whenSelectionModeChangedDo: [:selection |  self withAdapterDo: #refreshWidgetSelection ].  self whenMenuChangedDo: [ self withAdapterDo: #updateMenu ]includesContact: aContact  ^contents includes: aContactname: anObject  name := anObjectisMethodDefinition: anItem  anItem ifNil: [ ^false ].  ^(anItem isRingObject and: [ anItem isMethod and: [ anItem compiledMethod isNotNil ] ]) or: [ anItem isCompiledMethod ]expandRoots  self tree expandRootswhenIconChangedDo: aBlock  self property: #icon whenChangedDo: aBlockbrowseSelectedObjectClass  self selectedObjectDo: [:anObject |  Smalltalk tools browser openOnClass: anObject class ]windowPresenter: aDialogWindowPresenter  windowPresenter := aDialogWindowPresenterdefaultWaitDuration  ^500 milliSecondtestUnselectSelectedIndexRaisesSelectionEventOnce  | counter |  counter := 0.  presenter     selectIndex: 1;     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectIndex: 1.  self assert: counter equals: 1labelHolder  ^labelHoldertestChangingLabelAffectTheWidget  presenter label: 'ALabel'.  self assert: self widget label equals: 'ALabel'execute: state  self setSelection: state.  self action cull: state cull: selfinitializeButtons  self subclassResponsibilityhasSelectedItem  ^selectionHolder value isNotEmptywhenSelectionIndexChanged: aBlock  self dropList whenSelectionIndexChanged: aBlocksave: aValue  | oldElement |  oldElement := self host array at: self index.  self host     remove: oldElement;     add: aValuedisplayBlock  self deprecated: 'Please use #display instead' transformWith: '`@receiver displayBlock' -> '`@receiver display'.  ^displaysetSelection: interval  selection := intervalx  ^xinitializePresenters  super initializePresenters.  cancelButton := self newButton.  self registerCancelButtonEvents.  self focusOrder add: cancelButtoninitialize  super initialize.  self registerToAnnouncements.  self announcer when: SpWidgetBuilt send: #buildUpdateTitle to: selfselectedIndex: anInteger  self inspector selectedIndex: anIntegersearchText: aString  | search text result |  aString isEmptyOrNil ifTrue: [ ^#() ].  result := OrderedCollection new.  search := aString trimBoth asLowercase.  1 to: self numberOfRows do: [:rowIndex |  text := (self model displayValueAt: rowIndex) contents trimBoth asLowercase.        (text beginsWith: search) ifTrue: [ result add: rowIndex ] ].  ^result asArraytestAdapterForBindings  | layout |  layout := SpAbstractWidgetLayout for: #ListAdapter.  self assert: (layout adapterFor: SpListPresenter new bindings: SpStubAdapterBindings new) class equals: SpStubListAdapterallowedToClose  super allowedToClose ifFalse: [ ^false ].  ^self model askOkToClose ifTrue: [ self model requestWindowClose ] ifFalse: [ true ]setUp  super setUp.  menuBuilder := SpMenuBarPresenterBuilder newstate: aBoolean  state := aBooleangetText  ^Text newtriggerCancelAction  self performCancelActiondragEnabled  ^falseinspectSelectedObjectInNewWindow  self selectedObjectDo: [:anObject |  self inspectInNewWindow: anObject ]mouseUp: anEvent from: aMorph  aMorph color: self urlHoverColor.  self action valueselectionMode: aMode  selectionMode ifNotNil: [ selectionMode transferSubscriptionsTo: aMode ].  selectionMode := aModeleftText: aText  self widgetDo: [:w |  w sourceTextModel setText: aText.        w updateText ]resetArrayComputation  super resetArrayComputation.  size := self commands size.  numberOfProportionals := 0.  lastFractionIndex := 0.  autoFractionComputation := true.  currentOffset := 0.  currentProportional := 0removeButton  ^removeButtonemphasis: anEmphasis  self widgetDo: [:w |  w emphasis: (self emphasisCodeFor: anEmphasis) ]autoMultiSelection: aBoolean  tree autoMultiSelection: aBooleanmouseMove: anEvent  self target ifNil: [ ^self ].  self setTargetLayoutSizing.  self resetLayoutPosition.  self positionPoint: anEvent cursorPoint - lastMouse.  self setTargetBoundshasCustomSearch  ^searchBlock notNiltext: aText  text := aTextinspectorType: anInspectorClass  | oldScriptAreaTextModel |  oldScriptAreaTextModel := self inspector text.  anInspectorClass = self inspector class ifTrue: [ ^self ].  anInspectorClass isNil ifTrue: [ ^self ].  (self inspectorTypes includes: anInspectorClass) ifFalse: [ ^self ].  self basicInspector: (anInspectorClass new           inspect: self object;           yourself).  self inspector text     text: oldScriptAreaTextModel getText;     setSelection: oldScriptAreaTextModel getSelection.  history replaceCurrentWith: self inspector.  self toolbar updatemaxWidth  ^self lookupProperty: SpStyleGeometry valueOf: #maxWidthopenDialog: aPresenter withSpecLayout: aSpecLayout  ^self open: aPresenter withSpecLayout: aSpecLayout using: SpDialogWindowPresenternextInspectorType  | index types |  types := self inspectorTypes.  index := types indexOf: self inspectorType ifAbsent: [ ^types first ].  ^types atWrap: index + 1open: aPresenter  ^self open: aPresenter withSpecLayout: aPresenter defaultSpec using: aPresenter defaultWindowPresenterClasscloseable: aBoolean  closeableHolder value: aBooleanwidget  ^widgetadd: aSpec origin: originPoint corner: cornerPoint offsetOrigin: ooPoint offsetCorner: ocPoint  commands add: (SpLayoutAdd subwidget: aSpec layoutFrame: ((originPoint corner: cornerPoint) asSpLayoutFrame                 topLeftOffset: ooPoint;                 bottomRightOffset: ocPoint))testWhenOpenedDo  | opened |  opened := false.  presenter whenOpenedDo: [ opened := true ].  self openInstance.  self assert: openedtestSelectPresenterItemSetsSelectedIndexInWidget  presenter selectItem: 20.  self assert: (self adapter selectedIndexes includes: 2)updateRootFor: aText  | aFilter |  aFilter := SpTokenTreeFilter token: aText.  tree filterWith: aFilteropenInstance  window ifNil: [ window := presenter openWithSpec ]changesPresenterOn: aShortcut do: aBlock  changesListPresenter bindKeyCombination: aShortcut toAction: aBlockitemNotFoundAction  whenLabelChangedDo: aBlock  self property: #label whenChangedDo: aBlockmouseLeave: anEvent from: aMorph  aMorph color: self urlColor.  self currentHand showTemporaryCursor: niltitle  ^titleHoldertearDown  specInterpreterClass := nil.  specInterpreter := nil.  super tearDownwindowIcon: aForm  windowIcon := aFormvalueClass  ^self value wrappedObject classcanDeselectByClick  ^canDeselectByClick valueclassToTest  ^SpScrollSyncExamplesetUsersModel  usersModel     state: false;     label: 'Users';     action: [ self usersMethod ]testFirstActionSecondAction  | action1 action2 |  action1 := false.  action2 := false.  presenter firstAction: [ action1 := true ] secondAction: [ action2 := true ].  presenter firstButton performAction.  presenter secondButton performAction.  self assert: action1.  self assert: action2selected: aBoolean  selectedHolder value: aBooleaninitialize  super initialize.  state := true.  initialStateSet := true.  associatedRadioButtons := #()whenPagesChangedDo: aBlock  pagesHolder whenChangedDo: aBlockwhenChildrenBlockChangedDo: aBlock  childrenBlockHolder whenChangedDo: aBlockheaderFont: aFont  headerFont value: aFonttitle  ^'Keymap Browser'whenContentChangedDo: aBlock  content whenChangedDo: aBlocknewProgressBar  ^self instantiate: SpProgressBarPresenterapplyStyle: morph  self style applyTo: morphlabel  ^labelBlock valuecloseOnBackdropClick  ^closeOnBackdropClicksearchText: aString  ^(self class perform: (self searchStrategy , 'Strategy') asSymbol) searchWith: aString dataSource: selfleftPanel: anObject  leftPanel := anObjectminimum  ^minimumplaceHolderText  ^widget ghostText asStringerrorWhileAccessing: selector do: aBlock  [ self perform: selector ] on: Error do: [:error |  aBlock cull: error cull: selector ]contextMenuFromCommandsGroup: aValuable  self contextMenu: [ aValuable value beRoot asMenuPresenter ]list3  ^list3testDeactivateDoesNotRaiseActivateEvent  presenter state: true.  self assertWith: [:times |  times = 1 ] timesRaisedEvent: #whenActivatedDo: inPresenter: presenter whenDoing: [ presenter state: false ]leftOffset: anObject  leftOffset := anObjectcenteredRelativeTo: aModel  self changed: #centeredRelativeTo: with: {aModel}attachTransmission: aTransmission  self destinationPresenter whenSelectionChangedDo: [:selection |  self transmitWith: aTransmission value: selection transmission ]parentNode: aNode  parentNode value: aNodeclassToTest  ^SpDropListButtonbuildWidget  | alphaImage |  alphaImage := AlphaImageMorph new.  alphaImage model: self.  alphaImage     getImageSelector: #getImage;     vResizing: #spaceFill;     hResizing: #spaceFill;     layout: self layoutValue;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     setBalloonText: self help;     update: #getImage.  self model     whenImageChangeDo: [ alphaImage image: (self getImage ifNil: [ Form extent: 1 @ 1 depth: 32 ]) ];     whenAutoScaleChangeDo: [ widget layout: self layoutValue ].  ^alphaImageisExpanded  ^isExpanded valueremoveKeyCombination: aShortcut  self widgetDo: [:w |  w removeKeyCombination: aShortcut ]icon  ^iconremoveTabNumber: anIndex  self removeTab: (tabs at: anIndex)initializePresenters  changeSorterLeft := self instantiate: ChangeSorterPresenter.  changeSorterRight := self instantiate: ChangeSorterPresenter.  self menusRegistration.  self shortcutsRegistration.  self setFocusOrdergtInspectorPreviewIn: composite  < gtInspectorPresentationOrder: 30>  self widgetDo: [:w |  w gtInspectorMorphIn: composite ]showOnlySource  ^showOnlySourceborderWidth  ^borderWidthnotifyPropertyChanged: aName  self flag: #todo.  (self observablePropertyNamed: aName) valueChangedfindFirstOccurrenceOf: searchedString in: textToSearchIn  | firstIndex |  firstIndex := textToSearchIn findString: searchedString startingAt: 1.  [ firstIndex > 1 and: [ (textToSearchIn at: firstIndex - 1) isAlphaNumeric ] ] whileTrue: [ firstIndex := textToSearchIn findString: searchedString startingAt: firstIndex + 1 ].  ^firstIndextestTextIsSet  presenter text: 'aText'.  self assert: presenter text equals: 'aText'icon: aSymbol  self deprecated: 'Use #iconNamed: instead' transformWith: '`@receiver icon: `@statements' -> '`@receiver iconNamed: `@statements'.  ^self iconNamed: aSymbolbuildWithSpec: aString  ^self buildWithSpecbuildWithSpecLayout: aSpecLayout  ^SpBindings value: self application adapterBindings during: [ self basicBuildWithSpecLayout: aSpecLayout ]phone  ^phoneselectItem: item  sourcePresenter ifNil: [ ^self ].  self setSourceContentWith: (self textConverter           method: item;           getText).  sourcePresenter clearUndoManager.  self installIconStylerFor: itemnumRows  ^numRowsrightFraction  ^layoutFrame rightFractionbuildWidget  | label |  label := LabelMorph new model: self.  label     getEnabledSelector: #enabled;     getTextSelector: #getText;     vResizing: #shrinkWrap;     hResizing: #spaceFill;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     setBalloonText: self help;     color: self model color;     emphasis: (self emphasisCodeFor: self model emphasis);     setProperty: #minWidth toValue: 3.  ^labelbeNotShrinkable  shrink := falseselectIndex: aNumber  (aNumber = 0 and: [ widget selectedIndexes isEmpty ]) ifTrue: [ ^self ].  (widget selectedIndexes includes: aNumber) ifTrue: [ ^self ].  widget selectIndex: aNumberaddItem: anObject into: aToolbar  self subclassResponsibilitybaseRowHeight  ^(bounds height / numRows) asIntegerthumbnailSize  ^morphPresenter morph extentexecute  self editor pasteRecentisEmpty  ^self selectedIndex = 0testUnselectAll  presenter beMultipleSelection.  presenter     selectPath: #(1);     selectPath: #(2).  self assert: presenter selection selectedPaths equals: #(#(1) #(2)).  presenter unselectAll.  self assertEmpty: presenter selection selectedPathswidth  ^widthtestSelectItemsOutsideRangeIsEmpty  presenter selectItems: {4000 .         5000}.  self assert: presenter selection isEmptyselectedChangeSet  ^changesListPresenter selection selectedItemwhenSortingBlockChanged: aBlock  self deprecated: 'Use #whenSortingBlockChangedDo: instead.' transformWith: '`@receiver whenSortingBlockChanged: `@statements' -> '`@receiver whenSortingBlockChangedDo: `@statements'.  self whenSortingBlockChangedDo: aBlocknullPresentersNeededFor: aDynamicPresentersListBuilder  ^self subclassResponsibilityincludesIndexes: aCollection  ^aCollection allSatisfy: [:anIndex |  self selectedIndexes includes: anIndex ]objectVariableSize  ^self object basicSizeaddConstraits: constraints toChild: childMorph  | theMorph |  theMorph := childMorph.  theMorph setProperty: #constraints toValue: constraints.  ^theMorphisRoot  self withWindowDo: [:w |  ^w presenter = self ].  ^falseforgetClass  self okToChange ifFalse: [ ^self ].  self selectedClass ifNotNil: [:class |  self model removeClass: class from: self selectedChangeSet.        self setSelectedChangeSet: self selectedChangeSet ]accessorCode  ^self labelcreateWidgets  buttons withIndexDo: [:each :i |  self assign: each to: ('radio' , i asString) asSymbol ]testPropertyReturnsValueOf  | block |  themeDecorator property: #foo returnsValueOf: 42.  self assert: (themeDecorator objectAtProperty: #foo) equals: 42.  block := [ 42 ].  themeDecorator property: #fooBlock returnsValueOf: block.  self assert: (themeDecorator objectAtProperty: #fooBlock) equals: blockacceptOnCR  ^acceptOnCRtestChangePlaceholderTextUpdatesPresenter  presenter placeholder: 'some text'.  self assert: self adapter placeHolderText equals: 'some text'classMenu  ^self newMenu     title: 'Class list';     addGroup: [:aGroup |  aGroup           addItem: [:anItem |  anItem                 name: 'Delete class from change set';                 shortcut: $d meta;                 action: [ self forgetClass ] ];           addItem: [:anItem |  anItem                 name: 'Remove class from system';                 shortcut: $x meta;                 action: [ self removeClass ] ] ];     addGroup: [:aGroup |  aGroup addItem: [:anItem |  anItem                 name: 'Browse full';                 shortcut: $b meta;                 action: [ self browseMethodFull ] ] ];     addGroup: [:aGroup |  aGroup addItem: [:anItem |  anItem                 name: 'FileOut';                 action: [ self fileOutClass ] ] ];     yourselfwidgetsDo: aBlock  self deprecated: 'Use #presentersDo: instead' transformWith: '`@receiver widgetsDo: `@statements1' -> '`@receiver presentersDo: `@statements1'.  self presentersDo: aBlockchange  boolean := boolean not.  boolean ifTrue: [ self changeToList ] ifFalse: [ self changeToButton ].  self needRebuild: false.  button needRebuild: false.  self buildWithSpecaddModelTo: aNotebook  self model pages ifEmpty: [ ^self ].  self model pages do: [:each |  self addPage: each to: aNotebook ].  self model selectedPage ifNil: [ self model selectPageIndex: 1 ].  aNotebook selectedPageIndex: self model selectedPageIndex.  aNotebook announcer when: SpNotebookPageChanged send: #pageChanged: to: selfadd: aBlock top: aNumber  self add: aBlock top: aNumber bottom: nil left: nil right: nilvalue  ^hosttestWhenLabelChangedDo  presenter label: 'label1'.  presenter whenLabelChangedDo: [:new :old |  self assert: old equals: 'label1'.        self assert: new equals: 'label2' ].  self assert: presenter label equals: 'label1'.  self openInstance.  presenter label: 'label2'.  self assert: presenter label equals: 'label2'add: contactName phone: phone  | contact |  contact := SpContact named: contactName phone: phone.  self addContact: contact.  ^contactregisterOkButtonEvents  okButton     label: 'Ok';     enabled: true;     state: falsehasPresenter: aButtonPresenter  ^aButtonPresenter isNotNil and: [ aButtonPresenter adapter notNil and: [ self adapter hasWidget: aButtonPresenter adapter ] ]acceptColumnVisitor: aBuilder  ^aBuilder visitCheckboxColumn: selftestSelectItemSetsSelectedItem  presenter selectItem: 20.  self assert: presenter selection selectedItem equals: 20handleClassRenamed: anAnnouncement  | items selectedIndex |  items := self messages collect: [:rgMethod |  | interestedClassName interestedClass |        interestedClassName := anAnnouncement oldName.        interestedClass := anAnnouncement classRenamed.        rgMethod isMetaSide ifTrue: [ interestedClassName := interestedClassName , ' class'.              interestedClass := interestedClass classSide ].        rgMethod parentName = interestedClassName ifTrue: [ (interestedClass >> rgMethod selector) asFullRingDefinition ] ifFalse: [ rgMethod ] ].  selectedIndex := messageList selectedIndex.  self messages: items.  self setSelectedIndex: selectedIndexdropEnabled  ^self presenter dropEnabledwhenAllowToSelectChangedDo: aBlock  self deprecated: 'Should not use. Use #selectionMode instead'.  self property: #allowToSelect whenChangedDo: aBlockbeText  self bePassword: falseconnectPresenters  super connectPresenters.  addButton action: [ | newItem |        newItem := addItemBlock value.        newItem ifNotNil: [ self items add: newItem.              self refresh ] ].  removeButton action: [ removeItemBlock cull: self selectedItem ].  topButton action: [ self moveElementAt: self selectedIndex to: 1 ].  bottomButton action: [ self moveElementAt: self selectedIndex to: self items size ].  upButton action: [ self moveElementAt: self selectedIndex to: self selectedIndex - 1 ].  downButton action: [ self moveElementAt: self selectedIndex to: self selectedIndex + 1 ]whenLabelClickableChanged: aBlock  self deprecated: 'Use #whenLabelClickableChangedDo: instead.' transformWith: '`@receiver whenLabelClickableChanged: `@statements' -> '`@receiver whenLabelClickableChangedDo: `@statements'.  self whenLabelClickableChangedDo: aBlockclassToTest  ^SpLabelledListfillWith: aCommandGroup  self removeAllItems.  SpToolBarPresenterBuilder new     toolbarPresenter: self;     visit: aCommandGrouprootMenu  ^self owner rootMenutestPresenterConfiguredAs  | block |  self     assert: builder presenterBlock isNil;     assert: builder configurationBlock isNil.  block := [:p :m |   ].  builder presenter: SpButtonPresenter configuredAs: block.  self     assert: (builder presenterBlock value: nil) equals: SpButtonPresenter;     assert: builder configurationBlock equals: blockclassToTest  ^SpSearchableTreelabel  ^self index printStringbrowseClassRefs  self hostClass isTrait ifTrue: [ self systemNavigation browseAllUsersOfTrait: self hostClass ] ifFalse: [ self systemNavigation browseAllCallsOnClass: self hostClass ]getAction  self deprecated: 'Use #action instead' transformWith: '`@receiver getAction' -> '`@receiver action'.  ^self actionwhenSelectionIndexChangedDo: aBlock  self deprecated: 'Use whenSelectionChanged:'.  selection whenSelectionChanged: aBlocktearDown  window ifNotNil: [ window delete ].  super tearDowndrawBlock: aBlock  drawBlock := aBlockdragTransformationBlock  ^dragTransformationBlocktestAddingIconsShowTheIcon  #(pharo add book) do: [:each |  self presenter addItemLabeled: each do: [  ] icon: (self iconNamed: each) ].  self presenter selectItem: #pharo.  self assert: self adapter selectedIndexes equals: #(4).  backendForTest assertIcon: self adapter displayedIcon equals: (self iconNamed: #pharo)position: anObject  position := anObjectsortClassesInCachedHierarchy: aMethodDefinition b: otherMethodDefinition  | aMethodHierarchy otherMethodHierarchy minSize |  aMethodHierarchy := cachedHierarchy at: aMethodDefinition.  otherMethodHierarchy := cachedHierarchy at: otherMethodDefinition.  minSize := aMethodHierarchy size min: otherMethodHierarchy size.  1 to: minSize do: [:i |  | compare |        compare := (aMethodHierarchy at: i) printString compare: (otherMethodHierarchy at: i) printString.        compare ~~ 2 ifTrue: [ ^compare == 1 ] ].  ^aMethodHierarchy size < otherMethodHierarchy sizeemulateCenterClick  self emulateClick: MouseButtonEvent blueButtonhasEditingConflicts: aBoolean  ^self changed: #hasEditingConflicts: with: {aBoolean}newVSplitterAt: aPosition  self widgetDo: [:w |  w newVSplitterAt: aPosition ]deactivationAction: aBlock  actionWhenDeactivated := aBlockaddItem: aToolbarItem  self addItem: aToolbarItem position: SpToolBarItemPosition leftencrypted: aBoolean  ^self input encrypted: aBooleanaccept: text notifying: notifyer  ^self selectedMessage ifNotNil: [:message |  message methodClass compile: text classified: message protocol notifying: notifyer ]entity  ^entityhRigid  self subclassResponsibilityselectedContact  ^self contactBookPresenter selectedContactitems: aCollection  ^super items: (aCollection collect: [:each |  each asPresenter                 owner: self;                 yourself ])fractions  ^layoutFrame fractionRectanglecellExtents  ^cellExtentsadapt: aPresenter  model := aPresenter.  aPresenter addDependent: self.  widget := self buildWidgetvalue: anObject  value := EyePointerWrapper wrap: anObjectproperty: aName rawValue: anObject  (self observablePropertyNamed: aName) rawValue: anObjectchildrenForObject: aMorph  ^aMorph submorphs collect: [:each |  DynamicEyeElement host: aMorph value: each ]testUnselectAllInWidgetRaisesSelectionIndexChangeEventOnce  | counter |  counter := 0.  self adapter selectPath: #(1).  presenter selection whenChangedDo: [:selection |  counter := counter + 1 ].  self adapter selectPath: #().  self assert: counter equals: 1setWidgetLayoutWithOffset: widget at: index  height := widget bottomOffset - widget topOffset.  index = size ifTrue: [ widget layoutFrame: ((0 @ 1 corner: 1 @ 1) asSpLayoutFrame                 topLeftOffset: widget leftOffset @ height negated;                 bottomRightOffset: widget rightOffset @ 0) ] ifFalse: [ widget layoutFrame: ((0 @ currentProportional corner: 1 @ currentProportional) asSpLayoutFrame                 topLeftOffset: widget leftOffset @ currentOffset;                 bottomRightOffset: widget rightOffset @ (currentOffset + height)).        currentOffset := currentOffset + height ]arguments  ^{}testSetRootModelManyTimesPushesOnlyOnePresenterToList  self presenter presenterBlock: [:model |  SpNullMillerPresenter on: (SpLabelPresenter new label: model asString) ].  1 to: 3 do: [:each |  self presenter setRootModel: each ].  self assert: self presenter size equals: 1whenAcceptBlockChanged: aBlock  self deprecated: 'Use #whenAcceptBlockChangedDo: instead.' transformWith: '`@receiver whenAcceptBlockChanged: `@statements' -> '`@receiver whenAcceptBlockChangedDo: `@statements'.  self whenAcceptBlockChangedDo: aBlockhasStatusBar  ^self statusBar notNilnewNullPresenter  ^self instantiate: SpNullPresenterprepareToRunAgain  backendForTest runTest: [ super prepareToRunAgain ]classToTest  ^SpClassMethodBrowsertestSetColumnTitleInPresenterPutsColumnHeaderMorph  SystemVersion current major = 7 ifTrue: [ ^self skip ].  self presenter headerTitle: 'test'.  backendForTest assertListHeaderOf: self adapter equals: #('test')initialize  super initializetakeKeyboardFocus  ^self list takeKeyboardFocusinitializePresenters  selectItem: item  toolbarPresenter method: item.  textModel behavior: (item ifNotNil: [ item methodClass ]).  textModel doItReceiver: textModel behavior.  textModel text: (self textConverter           method: item;           getText).  textModel clearUndoManager.  self installIconStylerFor: itemtestOnePresenterShowsOneWidget  self presenter addPresenter: (SpNullMillerPresenter on: SpLabelPresenter new).  self assert: self adapter childrenWidgets size equals: 1rowIndex: anObject  rowIndex := anObjectisResizeable: aBoolean  isResizeable := aBooleantestAddButtonToToolbar  | toolbar button |  toolbar := SpToolBarPresenter new.  button := SpToolBarButton new.  self assertEmpty: toolbar items.  CmUIRightPositionStrategy new addButton: button toToolbar: toolbar.  self assert: toolbar rightItems size equals: 1.  self assert: toolbar rightItems anyOne equals: button.  self assertEmpty: toolbar leftItemsparent  ^parentupdateList  self withAdapterDo: #refreshWidgetList.  self unselectAllmaxNumberOfWeeksToDisplay  ^6setSelection: anInterval  self deprecated: 'Use #selection: instead.' transformWith: '`@receiver setSelection: `@statement' -> '`@receiver selection: `@statement'.  self selection: anIntervaltestSelectedPage  presenter selectPageIndex: 2.  self assert: self adapter selectedPageName equals: 'Mock2'visit: aTableColumn  aTableColumn acceptColumnVisitor: selfselectPath: aPath  aPath ifEmpty: [ ^self unselectAll ].  presenter itemAtPath: aPath ifAbsent: [ ^self ].  selection := aPathdisplayBlock  ^displayBlockaddTab: aTab  tabs value add: aTab.  aTab owner: self.  self selectedTab ifNil: [ selectedTab value: aTab ].  self changed: #addTab: with: {aTab}initializePresenters  text := self instantiate: SpTextInputFieldPresenter.  text     text: 'Object is nil';     enabled: falsetestAddPresenterToComponentListRaisesSingleEvent  | button raised |  raised := 0.  button := SpButtonPresenter new.  presenter whenPresentersChangedDo: [ raised := raised + 1 ].  presenter addPresenter: button.  self assert: raised equals: 1mouseDown: event  self nodeModel mouseDownAction cull: eventupdateInspectorType  self inspectorType ifNotNil: [:inspectorClass |  inspectorChoice selectedItem = inspectorClass ifTrue: [ ^self ].        inspectorChoice selectedItem: inspectorClass ]pageClass  ^SpDemoModalPresenterclassToTest  ^SpLabelledDropListButtoncustomizeMorphicBar: aProgressBarMorph  self subclassResponsibilitycontent: anObject  content value: anObjectcanChangeFonts  ^truenewActionBar  ^self instantiate: SpActionBarPresentervalue: aNumber  value := aNumbermessageMenu  ^self newMenu     title: 'Message list';     addGroup: [:group |  group           addItem: [:anItem |  anItem                 name: 'Delete method from changeSet';                 shortcut: $d meta;                 action: [ self forgetMessage ] ];           addItem: [:anItem |  anItem                 name: 'Remove method from system';                 shortcut: $x meta;                 action: [ self removeMessage ] ] ];     addGroup: [:group |  group addItem: [:anItem |  anItem                 name: 'Browse full';                 shortcut: $b meta;                 action: [ self browseMethodFull ] ] ];     addGroup: [:group |  group           addItem: [:anItem |  anItem                 name: 'FileOut';                 action: [ self fileOutMessage ] ];           addItem: [:anItem |  anItem                 name: 'Senders of...';                 shortcut: $n meta;                 action: [ self browseSendersOfMessages ] ];           addItem: [:anItem |  anItem                 name: 'Implementors of...';                 shortcut: $m meta;                 action: [ self browseImplementorsOfMessages ] ];           addItem: [:anItem |  anItem                 name: 'Versions';                 shortcut: $v meta;                 action: [ self browseVersions ] ] ];     yourselfaddItemBlock: aBlock  addItemBlock := aBlockcentered  self widgetDo: [:w |  w           fullBounds;           position: (Display extent - w extent) // 2 ]dropList  ^self dropListButton dropListclassToTest  ^SpMultiColumnListPresentertestOpenWindowWithDifferentApplicationShouldFail  | secondApplication presenterInSecondApplication |  secondApplication := SpApplication new.  presenterInSecondApplication := secondApplication newPresenter: SpButtonPresenter.  self should: [ application open: presenterInSecondApplication ] raise: SpInvalidApplicationErrorinitializePresenters  classToTest  ^self subclassResponsibilitybuttonWithMenu  ^buttonWithMenuvResizing  ^vResizingupdatePagesWith: aCollection  | pagesToRemove |  self widget ifNil: [ ^self ].  pagesToRemove := self widget pages reject: [:pageMorph |  aCollection anySatisfy: [:page |  page = pageMorph model ] ].  pagesToRemove do: [:pageMorph |  self widget removePage: pageMorph ].  aCollection reject: [:page |  self widget hasPageWithModel: page ] thenDo: [:page |  self addPage: page to: self widget ]isPassword  ^isPasswordcancelled  self flag: #TODO.  self withWindowDo: #cancelledremove: aPresenter  | morph |  needRecalculatePages := true.  morph := aPresenter adapter widget.  innerWidget removeMorph: morphwhenSelectionIndexChanged: aBlock  self dropList whenSelectionIndexChanged: aBlocktestUnselectAllInWidgetWithoutSelectionDoesNotRaiseEvent  | counter |  counter := 0.  presenter selection whenChangedDo: [:selection |  counter := counter + 1 ].  self adapter selectIndex: 0.  self assert: counter equals: 0executeDefaultAction  defaultButton ifNil: [ ^self ].  defaultButton action cull: selftextWithStyle  ^self widget getTextbrowseMethod  self method ifNotNil: [:aMethod |  aMethod browse ]maleButton  ^maleButtonisShowingColumnHeaders  ^self model isShowingColumnHeaderstestSetSelectIndexOutsideRangeDoesNotModifySelection  presenter whenSelectionChangedDo: [:selection |  self fail ].  presenter selectIndex: 4addVariableFields: elements  self sortedKeys do: [:key |  elements add: (IndexedEyeElement host: self object index: key) ]testSelectIndexTwiceAddsIndexToSelectedIndexListOnlyOnce  presenter     selectIndex: 1;     selectIndex: 1.  self assert: presenter selection selectedIndexes asArray equals: #(1)whenMinimumChangedDo: aBlock  self property: #minimum whenChangedDo: aBlockcomputeWidgetSizes  rowHeights := self calculateRowHeights.  columnWidths := self calculateColumnWidthsaddItemLabeled: aString do: aBlock icon: anIcon  | item |  item := SpDropListItem on: aString do: aBlock.  item icon: anIcon.  model add: item.  self selection isEmpty ifTrue: [ self selection selectItem: item ]isRowExpandable: rowNumber  ^(layout rowConstraintsAt: rowNumber) ifNotNil: [:c |  c isExpand ] ifNil: [ false ]drawBlock  ^drawBlockadd: aPresenter withConstraints: aBlock  super add: aPresenter withConstraints: aBlock.  adapter ifNotNil: [:theAdapter |  theAdapter add: aPresenter constraints: (children at: aPresenter) ]notifyInfo: aSpecNotification  self subclassResponsibilitynewRow: aBlock  self newRow: aBlock origin: 0 @ 0 corner: 1 @ 1accept: aText  | textToSet |  textToSet := (self shouldAccept: aText asString) ifTrue: [ aText ] ifFalse: [ self model text ].  super accept: textToSetvSpaceFill  selectedItem  | selectedIndex |  selectedIndex := self widget selectedIndex.  selectedIndex = 0 ifTrue: [ ^nil ].  ^(self widget dataSource elementAt: selectedIndex) datalistPresenter  ^listPresentertestExplicitNotificationRaisesEventWithNewValue  | newValue |  point x: 17.  point property: #x whenChangedDo: [:new |  newValue := new ].  point notifyPropertyChanged: #x.  self assert: newValue equals: 17refreshDelay: aDelay  refreshDelay := aDelayaddItemLabeled: aString do: aBlock  dropListModel addItemLabeled: aString do: aBlockitemFilter: aBlock  itemFilter := aBlockdisplayBlock: aBlock  ^self dropList display: aBlocktestSelectMultipleIndexesRaisesSelectionChangeEventMultipleTimes  | events |  events := 0.  presenter whenSelectionChangedDo: [:selection |  events := events + 1 ].  presenter selectIndex: 1.  presenter selectIndex: 3.  self assert: events equals: 2subMenu  ^self newMenu     addItem: [:item |  item           name: 'Open';           icon: (self iconNamed: #openIcon);           shortcut: $o meta;           action: [ self inform: 'Open' ] ];     addItem: [:item |  item           name: 'Save';           icon: (self iconNamed: #smallSaveIcon);           shortcut: $s meta;           action: [ self inform: 'Save' ] ];     addItem: [:item |  item           name: 'Print';           shortcut: $p meta;           icon: (self iconNamed: #smallPrintIcon);           action: [ self inform: 'Print' ] ];     addItem: [:item |  item           name: 'Kill';           shortcut: $k meta;           icon: (self iconNamed: #smallCancelIcon);           action: [ self inform: 'Kill' ] ];     yourselftoolbarModel  ^toolbarModelcontainer  ^container valuenewDataSourceMatching: aFTFilter  | newElements wrappedItem text newDataSource modelCopy |  newElements := self elements select: [:each |  wrappedItem := self model displayValueOf: each.        table columns anySatisfy: [:column |  text := column transform: wrappedItem.              aFTFilter matches: text ] ].  newDataSource := self copy.  modelCopy := self model copy.  modelCopy prepareForFilteredDataSourceWith: newElements.  newDataSource model: modelCopy.  ^newDataSourcecanDeselectByClick: aBoolean  canDeselectByClick value: aBooleancalculateWidthFor: aMorph base: aNumber  ^aNumbertraversePresentersDo: aBlock excluding: excludes  super traversePresentersDo: aBlock excluding: excludes.  presenter traversePresentersDo: aBlock excluding: excludesclassToTest  ^SpTablePresenteraction  ^actionupdateChangesList  | sel |  sel := self selectedChangeSet.  changesListPresenter items: self model allChanges.  changesListPresenter selectItem: selid  ^idadd: aName target: targetObject selector: aSelector  self flag: #TODO.  self addItem: [:item |  item           name: aName;           action: [ targetObject perform: aSelector ] ].  ^self menuItems lastdependentPackages  | lastBaseLineName packageNames |  lastBaseLineName := self lastBaseLine.  packageNames := OrderedCollection new.  (self configurationClass project version: lastBaseLineName) record loadDirective packageDirectivesDo: [:directive |  packageNames add: directive file ].  ^packageNames collect: [:p |  (p includes: $.) ifTrue: [ (p includes: $-) ifTrue: [ p copyUpToLast: $- ] ifFalse: [ p copyUpTo: $. ] ] ifFalse: [ p ] ]currentIcon  ^currentIconnumber2Input  ^number2Inputselected  ^self nodeModel selectedaddMenuItemsToWindowMenu: aMenu  announce: anAnnouncement  self announcer announce: anAnnouncementtestDoesNotUnderstand  presenter content: SpListPresenter.  presenter items: {'aaa' .         'bbb' .         'ccc'}.  self assertCollection: presenter model items hasSameElements: {'aaa' .         'bbb' .         'ccc'}addModelTo: aMorph  self model message ifNotNil: [:message |  self pushMessage: message to: aMorph ]action: aBlock  action := aBlockvisible: aBoolean  rootItems  ^self model rootsplaceholder  ^placeholder ifNil: [ '' ]testInBounds  presenter maximum: nil.  presenter minimum: nil.  self assert: (adapter inBounds: 100) equals: 100.  self assert: (adapter inBounds: 160) equals: 160.  self assert: (adapter inBounds: 80) equals: 80.  presenter maximum: 150.  presenter minimum: 90.  self assert: (adapter inBounds: 100) equals: 100.  self assert: (adapter inBounds: 160) equals: 150.  self assert: (adapter inBounds: 80) equals: 90testIconProvider  self assert: command iconProvider equals: Smalltalk ui icons.  command iconProvider: self.  self assert: command iconProvider equals: self.  command iconName: #banana.  self assert: command icon equals: self bananamorph  ^morphvisiblePages: aNumber  layout visiblePages: aNumberpresenter: anObject  presenter := anObjectdropEnabled  ^dropEnabledlastClicked: aBoolean  self nodeModel lastClicked: aBoolean.  aBoolean ifTrue: [ self model highlightedItem: self nodeModel ] ifFalse: [ self model highlightedItem: nil ]beforeAssertInTest: aSpecTest  whenChangedDo: aBlock  self property: #selection whenChangedDo: aBlockdisabledDropList  ^disabledDropListresetLayoutPosition  self owner layoutPolicy resetPositiontestUnselectUnselectedIndexRaisesNoSelectionEvent  | counter |  counter := 0.  presenter     selectIndex: 1;     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectIndex: 2.  self assert: counter equals: 0extent  ^45 @ 40initializeTSearchable  self searchMatching: [:item :pattern |  self performDefaultSearch: item matching: pattern ]emitValue: aMethodBuilder  aMethodBuilder pushInstVar: index.  aMethodBuilder send: #valueselectedPage  ^selectedPagelayout: aLayout  self subclassResponsibilitytearDown  application close.  super tearDownwhenAllowToSelectChanged: aBlock  self deprecated: 'Use #whenAllowToSelectChangedDo: instead.' transformWith: '`@receiver whenAllowToSelectChanged: `@statements' -> '`@receiver whenAllowToSelectChangedDo: `@statements'.  self whenAllowToSelectChangedDo: aBlockclearSelection  self selectionInterval: (0 to: 0)testNonOpenPresenterDoesNotRaiseBuiltEvent  | built |  built := false.  presenter whenBuiltDo: [ built := true ].  self deny: builtupdatePageContent: aPage  self widgetDo: [:w |  (w pageWithModel: aPage) reset.        aPage = self model selectedPage ifTrue: [ w updatePageIndex: self model selectedPageIndex ] ]whenSelectedItemChanged: aBlock  tree whenSelectedItemChanged: aBlockremove: aPresenter  children removeKey: aPresenter.  adapter ifNotNil: [:theAdapter |  theAdapter remove: aPresenter ]whenActivatedDo: aBlock  activationBlock := aBlockbuildWidget  ^SpStubDialogWindowView newwhenSelectedItemChanged: aBlock  self dropList whenSelectedItemChanged: aBlockdefineInputPorts  ^{SpMorphPort new}fixed: anObject  fixed := anObjectaddIn: aContainer  aContainer addMorph: morph fullFrame: layoutdoesNotUnderstand: aMessage  ^self presenterAt: aMessage selector ifAbsent: [ super doesNotUnderstand: aMessage ]dragPassengerFor: item inMorph: dragSource  ^self model dragPassengerFor: item inMorph: dragSourceshiftLastWidgets  | index ante |  (lastFractionIndex > 0 and: [ lastFractionIndex < size ]) ifFalse: [ ^self ].  index := size - 1.  [ index > lastFractionIndex ] whileTrue: [ | myHeight |        ante := self commands at: index.        index := index - 1.        myHeight := ante bottomOffset - ante topOffset.        ante           topOffset: (height + myHeight) negated;           bottomOffset: height negated.        height := height + myHeight ].  self assert: index = lastFractionIndex.  ante := self commands at: index.  ante bottomOffset: height negatedaddInstancesVariable: elements  configureWith: displayModel item: itemPresenter  displayModel configureDropList: self item: itemPresenterroots  ^rootsHolder valueselectedPaths  ^self subclassResponsibilitywhenSelectionIndexChanged: aBlock  self dropList whenSelectionIndexChanged: aBlockcancelAction: aBlock  ^cancelAction := aBlocktext  ^texttestActivationOnDoubleClickShouldActivateOnDoubleClick  | activatedItem |  activatedItem := nil.  presenter     activateOnDoubleClick;     whenActivatedDo: [:selection |  activatedItem := selection selectedItem ].  presenter doubleClickAtIndex: 1.  self assert: activatedItem label equals: '10'testSelectLine  self initializationText.  self openInstance.  presenter selectLine.  self assert: presenter selectionInterval equals: (1 to: 15)aboutTitle  ^self model model ifNotNil: [:m |  (m respondsTo: #aboutTitle) ifTrue: [ m aboutTitle ] ifFalse: [ m class name ] ]allAdapters  ^self abstractAdapterClass allAdaptersasMenuPresenter  ^SpMenuPresenterBuilder new     visit: self;     menuPresenterfrom: aPresenter to: anotherPresenter transform: aValuable postTransmission: anotherValuable  self     from: aPresenter;     to: anotherPresenter;     transform: aValuable;     postTransmission: anotherValuable;     applybuildWidget  ^self menuItems select: #isVisible thenCollect: #buildWithSpecnewContact  | rawData splitted |  rawData := self request: 'Enter new contact name and phone (split by comma)' initialAnswer: '' title: 'Create new contact'.  splitted := rawData splitOn: $,.  (splitted size = 2 and: [ splitted allSatisfy: #isNotEmpty ]) ifFalse: [ SpInvalidUserInput signal: 'Please enter contact name and phone (split by comma)' ].  ^SpContact new     name: splitted first;     phone: splitted second;     yourselfinitializeDialogWindow: aDialogWindowPresenter  aDialogWindowPresenter     addButton: 'Ok' do: [:presenter |  presenter triggerOkAction.        presenter close ];     addButton: 'Cancel' do: [:presenter |  presenter triggerCancelAction.        presenter close ]evaluated: aValuable  evaluation := aValuableinitializePresenters  buttonPresenter := self newButtonnewNotebookPage  self flag: #TODO.  ^SpNotebookPage newclassToTest  ^SpTreeTablePresenterlayout  ^layoutinitialize  super initialize.  container := nil asValueHolder.  displayBlock := [:node |  node printString ] asValueHolder.  initialWidth := 100 asValueHolder.  resizable := true asValueHolder.  headerLabel := nil asValueHolder.  headerFont := self class defaultFont asValueHolder.  headerIcon := nil asValueHolder.  headerAction := nil asValueHolder.  self registerEventsselector: anObject  selector := anObjectjulianDaysIntervalFor: aDate  | start end |  start := aDate julianDayNumber - aDate dayOfMonth - (self dayBeforeMonthOf: aDate) + 1.  end := aDate julianDayNumber + (aDate month daysInMonth - aDate dayOfMonth) + (self daysAfterMonthOf: aDate).  ^start to: endinspectorWrapper  ^self ownersuspendSelectionEventsDuring: aBlock  | registry subscriptions |  registry := self widget announcer subscriptions.  subscriptions := Set new.  registry subscriptionsOf: self do: [:each |  ({FTSelectionChanged .         FTStrongSelectionChanged} includes: each announcementClass) ifTrue: [ subscriptions add: each ] ].  subscriptions do: [:each |  registry remove: each ].  aBlock ensure: [ subscriptions do: [:each |  registry add: each ] ]connectPresenters  radio1 state: false.  radio2 state: true.  radio3 state: falseisExpandable  ^expandable and: [ self width isNil ]whenMultiSelectionChanged: aBlock  self deprecated: 'Should not use'classToTest  ^SpTextInputFieldPresenterselectFileTitle: aString  ^self backend selectFileTitle: aStringsortByColumn: aColumn event: anEvent morph: aMorph  aColumn sortDataSource: selfsurname: anObject  surname := anObjectlazyPageMorphCreation: anObject  lazyPageMorphCreation := anObjectmultiSelection  ^self model multiSelectiondiveInto: anObject  self inspect: anObjectopenOnString  | ui temp object |  object whenChangedDo: [:o |  ui label label: o asString ].  temp := object valuedefaultCommandsContext  ^selfbuildHierarchyForMessages: messages  | result classes |  self topologicSort ifFalse: [ result := IdentityDictionary new.        messages do: [:m |  result at: m put: {} ].        ^result ].  result := Dictionary new.  classes := (messages collect: #methodClass) asSet.  messages do: [:message |  | level class |        class := message methodClass.        level := OrderedCollection new.        class allSuperclassesDo: [:superClass |  (classes includes: superClass) ifTrue: [ level addFirst: superClass ] ].        level addLast: class.        level addLast: message selector.        result at: message put: level ].  ^resulttransform: aBlock  transformBlock := aBlocktestSetLabelInPresenterSetsInInMorph  presenter label: 'something'.  self assert: self adapter label equals: 'something'whenColumnsChangedDo: aBlockClosure  self property: #columns whenChangedDo: aBlockClosuremessageMenuFrom: sourcePanel to: destinationPanel  ^sourcePanel messageMenu     addGroup: [:aGroup |  aGroup           addItem: [:anItem |  anItem                 name: 'Copy method to the other change set';                 action: [ self copyMethodFrom: sourcePanel to: destinationPanel ] ];           addItem: [:anItem |  anItem                 name: 'Move method to the other change set';                 action: [ self moveMethodFrom: sourcePanel to: destinationPanel ] ] ];     yourselfdescription: aString  aString ifNil: [ ^self ].  descriptionPresenter := self newLabel     label: aString;     emphasis: #italic;     yourselfclassToTest  ^SpComponentListPresenterautoAccept: aBoolean  inputField autoAccept: aBooleanlistElementAt: anIndex ifAbsent: aBlock  ^self listItems at: anIndex ifAbsent: aBlockiconHolder  ^iconHoldertestColumnHomogeneousDiferentRowsAndColumns  | layout |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 2.  self place: label2 at: 3 @ 3.  self place: morph2 at: 4 @ 4.  layout := self newLayout.  layout layout beColumnHomogeneous.  (self styleMinExtent: 100 @ 20) applyTo: label2.  layout layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 100 @ 20).  self assert: morph1 bounds equals: (100 @ 20 corner: 200 @ 40).  self assert: label2 bounds equals: (200 @ 40 corner: 300 @ 60).  self assert: morph2 bounds equals: (300 @ 60 corner: 400 @ 80)testWhenActionPerformedDoAfterAction  | actionExecuted actionPerformed |  actionExecuted := 0.  actionPerformed := 0.  self assert: actionExecuted equals: 0.  self assert: actionPerformed equals: 0.  presenter action: [ actionExecuted := Time microsecondClockValue.        1 milliSecond wait ].  presenter whenActionPerformedDo: [ actionPerformed := Time microsecondClockValue ].  self openInstance.  self assert: actionExecuted equals: 0.  self assert: actionPerformed equals: 0.  presenter adapter action.  self assert: actionExecuted < actionPerformedtriggerCancelAction  value: aNumber  ^self sliderInput value: aNumbernewHorizontal  ^self newPanel     listDirection: #leftToRight;     addMorphBack: (self newPanel           listDirection: #leftToRight;           yourself);     addMorphBack: (self newPanel           listDirection: #leftToRight;           hResizing: #shrinkWrap;           width: 0;           yourself);     yourselfstyleName  ^'toolBar.iconsAndLabel'addItemLeft: aToolBarItem  aToolBarItem owner: self.  leftItems add: aToolBarItem.  self notifyPropertyChanged: #leftItemsinput  ^inputinitialize  super initialize.  boolean := truesetSelectedClassIndex: anIndex  ^classesListPresenter setSelectedIndex: anIndexbuildLayoutFor: aDynamicPresentersListBuilder  ^self subclassResponsibilityvisitIndexColumn: aTableColumn  self addCell: self rowIndex column: aTableColumntestAdapterBindings  self assert: application adapterBindings class equals: SpStubAdapterBindings.  application useBackend: #Morphic.  self assert: application adapterBindings class equals: SpMorphicAdapterBindingsfrom: aPresenter port: aSymbol to: anotherPresenter transform: aValuable postTransmission: anotherValuable  self     from: aPresenter port: aSymbol;     to: anotherPresenter;     transform: aValuable;     postTransmission: anotherValuable;     applyclassToTest  ^SpToggleButtonPresentertestSelectingAnElementSelectsIt  self presenter selectItem: 10.  self assert: self presenter selectedItem equals: 10.  self assert: self adapter selectedIndexes equals: #(1)icon: anIcon  icon value: anIconcodeFont  ^StandardFonts codeFontname  | name |  name := self model name.  ^(name isBlock or: [ name isMessageSend ]) ifTrue: [ name cull: self model ] ifFalse: [ name ]borderWidth: width  self widget ifNotNil: [:w |  w borderWidth: width ]cellExtentAt: aPoint  ^self cellExtents at: aPointmax: anObject  max := anObjectghostText  self deprecated: 'This API is too tight to Morph. Use #placeholder instead.' transformWith: '`@receiver ghostText' -> '`@receiver placeholder'.  ^self placeholderinitializePresenters  methodBrowser := self instantiate: MessageBrowser.  textField := self newTextInput.  textField     placeholder: 'Enter a class name';     autoAccept: true;     removeEntryCompletion.  methodBrowser sortingBlock: [:a :b |  a selector < b selector ]label: anObject  label := anObjectacceptDropBlock  ^self model acceptDropBlocktestLabelBottom  self openInstance: #labelBottomclickTab: anIndex  | evt tab |  evt := MouseButtonEvent new setType: nil position: widget center which: MouseButtonEvent redButton buttons: MouseButtonEvent redButton hand: nil stamp: nil.  tab := self widget tabSelectorMorph tabs at: anIndex.  (tab handlesMouseDown: evt) ifTrue: [ tab mouseDown: evt.        tab mouseUp: evt ]checkboxNormal  ^checkboxNormalbeep  self adapter beepaccessorCode  ^'(self occurrencesOf: ' , self label , ')'testUnselectSelectedPathRaisesSingleEvent  | counter |  counter := 0.  presenter     selectPath: #(1 1);     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectPath: #(1 1).  self assert: counter equals: 1testSwitchAutoScale  | autoState |  autoState := presenter autoScale.  presenter switchAutoscale.  self assert: presenter autoScale equals: autoState notinitialize  super initialize.  bindings := Dictionary new.  self initializeBindingsisVisible  ^visible valueaddCell: anObject column: aTableColumn  | morph |  anObject ifNil: [ ^self ].  morph := anObject asMorph asReadOnlyMorph.  self addCellMorph: morph column: aTableColumnbuildLabelFrom: aStringOrMorph withAction: aMorph  | innerLabel |  innerLabel := aStringOrMorph isMorph ifTrue: [ aStringOrMorph ] ifFalse: [ self buildLabelFrom: aStringOrMorph ].  ^aMorph ifNotNil: [ aMorph vResizing: #spaceFill.        PanelMorph new           addMorphBack: innerLabel;           addMorphBack: aMorph;           yourself ] ifNil: [ innerLabel ]headerTitle  ^headerTitlewhenSortingBlockChangedDo: aBlock  self property: #sorting whenChangedDo: aBlockinitialize  super initialize.  actionWhenActivated := [  ].  actionWhenDeactivated := [  ].  state := false.  labelClickable := true.  label := ''.  self whenLabelClickableChangedDo: [:aBoolean |  self changed: {#labelClickable: .               aBoolean} ]roots  ^{(RootEyeElement host: self object)}connectPresenters  list selectItem: self selectedPage.  list whenSelectionChangedDo: [:selection |  selection selectedItem ifNotNil: [:newPageClass |  newPageClass = self selectedPage ifFalse: [ self selectedPage: newPageClass.                    page := self instantiate: newPageClass.                    self needRebuild: false.                    self buildWithSpec.                    list selectItem: self selectedPage ] ] ifNil: [ list setSelectedItem: self selectedPage ] ]pages: aCollection  aCollection do: [:each |  each owner: self ].  pagesHolder rawValue: aCollection.  pagesHolder valueChanged: nilhost  ^hostinitializeTestedInstance  manager := SpTabManagerPresenter newwhenDisplayBlockChanged: aBlock  self deprecated: 'Use #whenDisplayBlockChangedDo: instead.' transformWith: '`@receiver whenDisplayBlockChanged: `@statements' -> '`@receiver whenDisplayBlockChangedDo: `@statements'.  self whenDisplayBlockChangedDo: aBlockensureAtLeastOneColumnIn: tableMorph  self model columns ifNotEmpty: [ ^self ].  tableMorph addColumn: (self newColumnFrom: self defaultColumn)openOnNil  ui := SpOpenOnNilExample new.  ui     extent: 200 @ 100;     openWithSpecextent  ^extentusersMethod  self method methodClass ifNotNil: [:class |  self model browseClassRefsOf: class ]addHorizontalPadding: aNumber toMorph: aMorph  ^self newWrapMorph     hResizing: aMorph hResizing;     vResizing: aMorph vResizing;     width: aMorph width + (aNumber * 2);     height: aMorph height;     addMorph: (aMorph           hResizing: #spaceFill;           vResizing: #spaceFill;           yourself) fullFrame: (LayoutFrame identity           leftOffset: aNumber;           rightOffset: aNumber negated);     yourselfasArray  ^(OrderedCollection new     add: self type;     addAll: self privateAsArray;     yourself) asArrayisMatching: anItem  ^dataSource model performSearch: anItem data matching: patternlistSize  ^self list listSizemodel  ^modelsuperiorToMinimum: aNumber  ^self model minimum ifNil: [ aNumber ] ifNotNil: [:min |  aNumber max: min ]connectPresenters  inputField whenTextChangedDo: [:text |  self updateRootFor: text ].  tree whenTreeUpdatedDo: [ inputField text: '' ]initialize  super initialize.  self     changeTableLayout;     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #spaceFill;     color: self color;     extent: 0 @ 0.  self initializePanelsselectedMessage: aMessage  messageList selectMessage: aMessagesetTargetLayoutSizing  self target hResizing = #rigid ifTrue: [ ^self ].  self target hResizing: #rigid.  self targetAfter hResizing: #spaceFillinitializeShortcuts  self shortCuts keysAndValuesDo: [:key :value |  self tree bindKeyCombination: key toAction: value ]labelClickable: aBoolean  labelClickable := aBooleanaddMenuItemsToWindowMenu: aMenu  self presenter addMenuItemsToWindowMenu: aMenubottomFraction  ^layoutFrame bottomFractionimage  ^widget scaledImageresetSelection  self selectedItems: {}accessorCode  ^super labelpackageOf: anItem  ^'[' , (self packageNameForItem: anItem) , ']'escapePressed  self model triggerCancelActionhasSelectedContact  ^self contactBookPresenter isContactSelectedinitialize  super initializerightLabel  ^self model rightLabelmaxHeight  ^self maxExtent ifNotNil: [:aPoint |  aPoint y ]isResizable  ^self presenter isResizabletestDefaultMaxLengthIsZero  self assert: presenter maxLength equals: 0button  ^buttonresultPane: anObject  resultPane := anObjecttitle  ^self object printStringtransmitTo: aPresenter transform: aValuable  ^self newTransmission     from: self;     to: aPresenter;     transform: aValuable;     applytestInsertAt  self initializationText.  self openInstance.  presenter insert: 'insertion ' at: 9.  self assert: presenter text equals: 'Text for insertion tests.'indeterminate  self state: SpProgressBarIndeterminated newtestLabelRight  self openInstance: #labelRightborderColor: color  self widget ifNotNil: [:w |  w borderColor: color ]refeshedChangeSet: changeSet  isRefreshing ifTrue: [ ^self ].  isRefreshing := true.  changeSet updateChangesList.  isRefreshing := falsewhenCurrentlyActivatedChangedDo: aBlock  currentlyActivated whenChangedDo: aBlocknewIconList  self deprecated: 'Please use #newList instead.' transformWith: '`@receiver newIconList' -> '`@receiver newList'.  ^self instantiate: SpIconListPresentersetWidgetColor: button  | normalColorBlock clickedColorBlock |  normalColorBlock := [:aButton |  (aButton valueOfProperty: #noFill ifAbsent: [ false ]) ifTrue: [ SolidFillStyle color: Color transparent ] ifFalse: [ SolidFillStyle color: self color ] ].  clickedColorBlock := [:aButton |  SolidFillStyle color: self color muchDarker ].  button theme: ((SpUIThemeDecorator theme: button theme)           property: #buttonNormalFillStyleFor: returnsValueOf: normalColorBlock;           property: #buttonMouseOverFillStyleFor: returnsValueOf: normalColorBlock;           property: #buttonPressedFillStyleFor: returnsValueOf: clickedColorBlock;           yourself)unselectPath: aPath  self selectPaths: (self selectedPaths copyWithout: aPath)realMenu  ^realMenusubmitButton: anObject  submitButton := anObjectinitialize  super initialize.  action := [  ].  autoScale := falseheight  ^self extent ifNotNil: [:aPoint |  aPoint y ]askOkToClose  ^self model askOkToCloselabelFor: anEyeElement  ^anEyeElement labeltestShouldAcceptFloat  presenter     beFloat;     minimum: 90;     maximum: 120;     digits: 3.  self assert: (adapter shouldAccept: '').  self assert: (adapter shouldAccept: '100').  self assert: (adapter shouldAccept: '100.1').  self deny: (adapter shouldAccept: '80.1').  self deny: (adapter shouldAccept: '150.1').  self deny: (adapter shouldAccept: 'string').  self deny: (adapter shouldAccept: '10string').  self deny: (adapter shouldAccept: '100.1111')topFraction: aNumber  ^0initialize  super initialize.  pushedMessages := OrderedCollection newopenDialogWithSpec  ^self application openDialog: self withSpecLayout: self retrieveDefaultSpecunselectAll  self clearSelectionaddPresenterIn: widgetToBuild withSpecLayout: aSpec  self model initialPosition ifNotNil: [:position |  widgetToBuild position: position ].  self model initialExtent ifNotNil: [:extent |  widgetToBuild extent: extent ].  self addContent: (self model presenter buildWithSpecLayout: aSpec) toWindow: widgetToBuildtestSelectIndexOutsideRangeHasNoSelectedIndexes  presenter selectIndex: 4.  self assert: presenter selection selectedIndexes isEmptyremoveKeyCombination: aShortcut  self contextKeyBindings removeKey: aShortcut ifAbsent: [ ^self ].  self withAdapterDo: [:anAdapter |  anAdapter removeKeyCombination: aShortcut ]toolbarItemSize  ^self displayMode heightcheckboxWithColor  ^checkboxWithColortestSetSelectItemRaisesSelectionChangeEventWithSelectedItem  | selectedElement |  presenter whenSelectionChangedDo: [:selection |  selectedElement := selection selectedItem ].  presenter selectItem: 20.  self assert: selectedElement equals: 20rowSpacing  ^self layout rowSpacingbuildWidget  ^SpStubTreeNodeView newassertIcon: anIcon equals: aForm  backendForTest assertIcon: anIcon equals: aFormtitle  ^'Example of using #prepareWindow:'whenShownDo: aBlock  self property: #shown whenChangedDo: aBlocksortElements: aSortFunction  unsortedElements ifNil: [ unsortedElements := self rootsItems ].  self rootItem data: ((self rootItem children collect: #data) sorted: aSortFunction)whenIconsChangedDo: aBlock  self property: #icon whenChangedDo: aBlockrecalculatePageWidths  | newWidth widgets width |  widgets := self childrenWidgets.  width := self widget width.  newWidth := widgets size = 1 ifTrue: [ width ] ifFalse: [ width / (layout visiblePages min: widgets size) - (layout spacing / (layout visiblePages min: widgets size)) ].  widgets reverseWithIndexDo: [:each :index |  each           left: (index - 1) * newWidth;           width: newWidth ]listSize  ^self listItems sizeselectedSelector  ^methodsListPresenter selection selectedItemaddDefaultButton: aButtonPresenter  defaultButton := self addButton: aButtonPresenter.  defaultButton addStyle: 'default'.  ^defaultButtonaddHSplitter  self commands add: (SpSplitterHorizontal commands: self commands)instVarNamesFrom: aDynamicPresentersListBuilder  ^aDynamicPresentersListBuilder instVarNames , aDynamicPresentersListBuilder nullPresentersInstVarNamesbeHorizontal  direction := SpLayoutDirection horizontaltestWhenPlaceholderChangesRaisesSingleEvent  self assertWith: [:times |  times = 1 ] timesRaisedEvent: #whenPlaceholderChangedDo: inPresenter: presenter whenDoing: [ presenter placeholder: 'test' ]menuItems  ^items valueupdateSelectionOf: tableMorph  self selectInto: tableMorph paths: self model selection selectedPathsdiveIntoSelectedObject  self inspector diveIntoSelectedObjectupdateSearch  self presenter isSearchEnabled ifTrue: [ widget enableSearch ] ifFalse: [ widget disableFunction ]whenChangesListChanges: aBlock  changesListPresenter whenModelChangedDo: aBlockselectAll  self selectIndexes: (1 to: self model size)resetRootNodes  rootNodes := nilremovePageIndex: anInteger  self removePage: (self pages at: anInteger)radioButtonsAction  radioButtonClassSide whenActivatedDo: [ self fillWith: self selectedClass class ].  radioButtonInstanceSide whenActivatedDo: [ self fillWith: self selectedClass ]buildWidget  ^Morph new     color: Color transparent;     hResizing: #spaceFill;     vResizing: #spaceFill;     yourselfcopySelectedItemAccessorCode  self hasSelectedObject ifFalse: [ ^self ].  self selectedElement copyAccessorCoderesolvePresenter: presenterNameOrLayout presenter: aPresenter bindings: bindings  presenterNameOrLayout isSymbol ifTrue: [ ^(self subpresenterOrLayoutNamed: presenterNameOrLayout of: aPresenter) ifNil: [ self error: 'You presenter named "' , presenterNameOrLayout , '" from ' , aPresenter printString , ' was not initialized.' ] ].  presenterNameOrLayout isSpLayout ifTrue: [ ^presenterNameOrLayout buildAdapterFor: aPresenter bindings: bindings ].  ^presenterNameOrLayout asPresenter     owner: aPresenter;     yourselfnew: aPresenter  ^self newPresenter: aPresentertestModelObjects  builder modelObjects: {3 .         2 .         1}.  self assertCollection: builder instVarToModelObject hasSameElements: {(#var1 -> 3) .         (#var2 -> 2) .         (#var3 -> 1)}getIconFor: anItem  ^self icons cull: anItem cull: selftestSelectPathsTwiceAddsPathssToSelectedPathListOnlyOnce  | paths |  paths := {#(1 3) .   #(2 2)}.  presenter     selectPaths: paths;     selectPaths: paths.  self assertCollection: presenter selection selectedPaths hasSameElements: pathsexecute  'OK' crLoginstVarNamesFrom: aDynamicPresentersListBuilder  | names streams |  names := super instVarNamesFrom: aDynamicPresentersListBuilder.  streams := names groupsOf: names size / self rowsCount atATimeCollect: [:a |  a readStream ].  ^OrderedCollection streamContents: [:s |  [ streams noneSatisfy: #atEnd ] whileTrue: [ streams do: [:subS |  s nextPut: subS next ] ] ]defineInputPorts  ^{SpListItemsPort new}registerEvents  rootsHolder whenChangedDo: [ self updateTree ].  childrenBlockHolder whenChangedDo: [ self updateTree ].  hasChildrenBlockHolder whenChangedDo: [ self updateTree ].  displayBlock whenChangedDo: [ self updateTree ].  iconBlock whenChangedDo: [ self updateTree ].  autoDeselection whenChangedDo: [:boolean |  self update: {#autoDeselection: .               boolean} ].  columns whenChangedDo: [:col |  col do: [:each |  each container: self ].        self changed: #columns: with: {col} ].  selectionHolder whenChangedDo: [:items |  self changed: {#selectItems .               items} ].  rootNodeHolder whenChangedDo: [:aBlock |  self updateTree ].  isCheckList whenChangedDo: [:boolean |  self changed: #isCheckList: with: {boolean} ].  oddRowColor whenChangedDo: [:aColor |  self changed: #oddRowColor: with: {aColor} ].  evenRowColor whenChangedDo: [:aColor |  self changed: #evenRowColor: with: {aColor} ].  menuBlockHolder whenChangedDo: [:aMenuModel :oldMenuModel |  oldMenuModel ifNotNil: [ | oldMenu |              oldMenuModel isBlock ifTrue: [ oldMenu := SpMenuPresenter new.                    oldMenuModel cull: oldMenu cull: false ] ifFalse: [ oldMenu := oldMenuModel ].              oldMenu applyTo: self ].        aMenuModel ifNotNil: [ | newMenu |              aMenuModel isBlock ifTrue: [ newMenu := SpMenuPresenter new.                    aMenuModel cull: newMenu cull: false ] ifFalse: [ newMenu := aMenuModel ].              newMenu applyTo: self ] ].  self announcer when: SpWidgetBuilt send: #onWidgetBuilt to: selfremoveTabIndex: anInteger  self tabs removeAt: anInteger.  self tabs ifNotEmpty: [ self selectedIndex: (self selectedIndex - 1) \\ self tabs size + 1 ] ifEmpty: [ self selectedIndex: 0 ].  self updateTabsnumber  ^self text asNumberremoveSubWidgets  self subclassResponsibilitydropListButton  ^subwidgetdefineOutputPorts  ^#()entryCompletion: anEntryCompletion  ^self input entryCompletion: anEntryCompletionelementChanged  self text doItReceiver: self selectedElement value.  self text ifNotNil: [:w |  w behavior: self selectedElement value class ]buildWidget  ^SpStubTextView newcontents  ^self childrenItems collect: [:child |  self childNodeFromItem: child ]whenLabelChangedDo: aValuable  self property: #label whenChangedDo: aValuablepresenter  ^presentercommands: anObject  commands := anObjecthasContentToShow  ^self model hasContentToShownotify: aSpecNotification  self withAdapterDo: [:anAdapter |  aSpecNotification type notify: aSpecNotification on: anAdapter ]displayBlock  self deprecated: 'Please use #display instead' transformWith: '`@receiver displayBlock' -> '`@receiver display'.  ^displayBlockunselectAll  self subclassResponsibilitygameLogicWithShowedCards: showedCards objectConcerned: modelObject andAssociatedPresenter: presenter  presenter     icon: self hiddenIcon;     action: [ (presenter icon = self hiddenIcon and: [ showedCards size < 2 ]) ifTrue: [ showedCards add: presenter.              presenter                 icon: nil;                 label: modelObject asString.              showedCards size = 2 ifTrue: [ [ (1 / 2) second wait.                    showedCards first label asString = showedCards second label asString ifTrue: [ showedCards do: [:p |  p                                   icon: self foundIcon;                                   label: nil ] ] ifFalse: [ showedCards do: [:p |  p                                   icon: self hiddenIcon;                                   label: nil ] ].                    showedCards removeAll ] fork ] ] ]date: aDate  | dateString |  date := aDate.  dateString := self display value: date.  self dateModel text: dateStringattachTransmission: aTransmission  self destinationPresenter whenTextChangedDo: [:selection |  self transmitWith: aTransmission value: selection text ]whenChangedDo: aBlockClosure  self property: #desiredVisibleRow whenChangedDo: aBlockClosurelabel  ^labelasArray  ^{leftFraction .   topFraction .   rightFraction .   bottomFraction .   leftOffset .   topOffset .   rightOffset .   bottomOffset}autoRefresh  | autoRefresh |  autoRefresh := self model autoRefresh.  ^(autoRefresh isBlock or: [ autoRefresh isMessageSend ]) ifTrue: [ autoRefresh cull: self model ] ifFalse: [ autoRefresh ]testSelectItemOutsideRangeUnsetsSelectedItem  presenter selectItem: 4000.  self assert: presenter selection selectedItem equals: niltestSelectIndexAddsIndexToSelectedIndexList  presenter selectIndex: 1.  self assert: (presenter selection includesIndex: 1)value: aValue  value := aValuehRigid  self widgetDo: [:w |  w hResizing: #rigid ]testRowColorsBeforeBuild  treeWithItems oddRowColor: Color red.  treeWithItems evenRowColor: Color green.  treeWithItems buildWithSpec.  self assert: treeWithItems adapter widget rowColors equals: (Array with: Color green with: Color red)codeTab  ^SpNotebookPage title: 'Code' icon: (self iconNamed: #changeUpdate) provider: [ self newText           text: (self codeFor: self pageClass);           yourself ]setTopOffset: top for: widget borderWidth: windowBorderWidth  widget topFraction = 0 ifTrue: [ top isZero ifTrue: [ widget topOffset: windowBorderWidth ] ifFalse: [ widget topOffset: top + self splitterWidth ] ] ifFalse: [ widget topFraction = 1 ifFalse: [ widget topOffset: top + self splitterWidth ] ]numberOfRows  ^model ifNil: [ 0 ] ifNotNil: [ self listModel size ]askBeforeChanging  ^askBeforeChangingbuildWidget  ^SpStubIconListView newadapter  backendForTest openInstanceOf: self.  ^presenter adapterpresentersDo: aBlock  self class allSlots reject: [:each |  each name = #owner ] thenDo: [:each |  | var |        var := self readSlot: each.        (var isKindOf: SpAbstractPresenter) ifTrue: [ aBlock value: var ] ]refreshDescription: item  | newDescription |  item ifNil: [ ^self ].  newDescription := [ item description ] on: Error do: [ 'Error while printing ' , item accessorCode ].  description text = newDescription ifTrue: [ ^self ].  self keepScrollPositionOf: description during: [ description text: newDescription ]tick  timeline ticktestInterpretASpecModelMorphAssociation  | spec model morph |  model := SpAbstractWidgetPresenter new.  spec := {#MenuRegistration .   #help: .   #icon:}.  morph := specInterpreterClass interpretASpec: spec presenter: model.  self assert: model adapter == morphcheckboxWithHelp: anObject  checkboxWithHelp := anObjectbasicBuildWithSpecLayout: presenterSpecLayout  | widget |  (self spec isNil or: [ self needRebuild ]) ifTrue: [ self buildWindowWithLayout: self retrieveDefaultSpec presenterLayout: presenterSpecLayout ] ifFalse: [ widget := self widget ].  ^widgetadd: aBlock withSpec: aSpec right: aNumber  self add: aBlock withSpec: aSpec top: nil bottom: nil left: nil right: aNumberclassToTest  ^SpTextPresenterwhenBorderColorChanged: aBlock  self deprecated: 'Use #whenBorderColorChangedDo: instead.' transformWith: '`@receiver whenBorderColorChanged: `@statements' -> '`@receiver whenBorderColorChangedDo: `@statements'.  self whenBorderColorChangedDo: aBlocknormalBorderStyle  ^BorderStyle simple     width: 0;     baseColor: Color transparentinitMinMax  presenter     min: 0;     max: 100gtInspectorPreviewIn: composite  < gtInspectorPresentationOrder: 30>  self adapter ifNotNil: [:w |  w gtInspectorPreviewIn: composite ]compareToOtherVersion  | labels versions index selected |  versions := self changeList.  labels := versions collect: #stamp.  index := UIManager default chooseFrom: labels.  index > 0 ifFalse: [ ^self ].  selected := versions at: index.  self compareTo: selected withLabel: selected stampupdateTitle  DisplayScreen hostWindowTitle: self titlemodel  ^modelfileOut  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  self selectedChangeSet fileOutbuildWidget  ^SpStubDropListView newrightPanel: anObject  rightPanel := anObjectemail  ^emailopenOnString: aString  ui := SpOpenOnStringExample new: aString.  ui     extent: 300 @ 200;     openWithSpecselection: anInterval  self deprecated: '#selection: was used to set an interval, and did not convey the correct meaning. Use #selectionInterval: instead.' transformWith: '`@receiver selection: `@arg' -> '`@receiver selectionInterval: `@arg'.  self selectionInterval: anIntervalwhenDisplayDo: aBlockClosure  self announcer when: SpWidgetDisplayed do: aBlockClosureaddLast: aButtonPresenter  (items at: #end ifAbsentPut: [ OrderedCollection new ]) add: aButtonPresentersetIndex: anIndex  ^self dropList setIndex: anIndexcolumns: aCollection  columns := aCollectionroots: aCollection  roots := aCollection.  self selection clearSelectionunselectItem: anInteger  self selection unselectItem: anIntegerchildrenForObject: aFileReference  aFileReference isDirectory ifFalse: [ ^#() ].  ^aFileReference children collect: [:each |  DynamicEyeElement host: aFileReference value: each ]openInstanceOf: aTest  aTest window ifNil: [ aTest presenter application: app.        aTest window: aTest presenter openWithSpec ].  self waitUntilUIRedrawedclassToTest  ^SpCheckBoxPresenterinitialize  buttons := OrderedCollection new.  currentActivated := nil asValueHolder.  super initializewrapItem: anItem index: anIndex  ^self model wrapItem: anItem index: anIndexnewRow: aBlock origin: originPoint corner: cornerPoint offsetOrigin: ooPoint offsetCorner: ocPoint  | block |  block := aBlock.  block isBlock ifFalse: [ block := [:r |  r add: aBlock ] ].  commands add: (SpLayoutAddRow block: block layoutFrame: ((originPoint corner: cornerPoint) asSpLayoutFrame                 topLeftOffset: ooPoint;                 bottomRightOffset: ocPoint))adapterName  ^#PanedAdapterisVisible  ^widget visibleinspectMethod  self currentMethod ifNotNil: [:m |  m inspect ]nodeModel: anObject  nodeModel := anObjectwhenCodeCompletionAllowedChanged: aBlock  self deprecated: 'Use #whenTextIsAcceptedDo: instead or nothing. Currently, both those methods are doing the same thing but my name is really missleading. Thus, I''ll be removed.' transformWith: '`@receiver whenCodeCompletionAllowedChanged: `@statements' -> '`@receiver whenTextIsAcceptedDo: `@statements'.  self whenTextIsAcceptedDo: aBlockedgeName  ^#bottomassertImage: actual equals: expected  (expected isNil and: [ actual isNil or: [ actual width = 1 and: [ actual height = 1 ] ] ]) ifTrue: [ ^self ].  self assert: actual width = expected width.  self assert: actual height = expected height.  self assert: actual bits = expected bitsaboutText  ^self model aboutTextmatches: anObject  ^self block cull: anObject cull: patternselectAll  self changed: #selectAdd with: #()direction  ^self layout directiondaysAfterMonthOf: aDate  ^self daysToDisplayCount - aDate month daysInMonth - (self dayBeforeMonthOf: aDate)encrypted: aBoolean  self input encrypted: aBooleanexecute  self action cull: selfrowInset: anInteger  tree rowInset: anIntegerdayNames  ^#('Sun' 'Mon' 'Tue' 'Wed' 'Thu' 'Fri' 'Sat')setWidgetLayoutWithNoOffset: widget at: index delta: delta  widget layoutFrame: ((0 @ currentProportional corner: 1 @ (currentProportional + delta)) asSpLayoutFrame           topOffset: currentOffset;           yourself).  currentOffset := 0.  currentProportional := currentProportional + delta.  lastFractionIndex := indexmodalRelativeTo: aWindow  self deprecated: 'Do not use this directly. Use #openModalWithSpec (and family) instead.' on: '2019-02-26' in: #Pharo8.  self changed: #modalRelativeTo: with: {aWindow}redraw  self surface drawDuring: [:canvas |  drawBlock cull: canvas ]takeKeyboardFocus  ^self listModel takeKeyboardFocustearDown  window ifNotNil: [ window delete ].  super tearDownselectedObjectDo: aBlock  aBlock value: self selectedObjectwidgetBuilt: ann  | exampleLayout |  exampleLayout := self layout presenters first.  borderWidth value: exampleLayout borderWidth.  columnSpacing value: exampleLayout columnSpacing.  rowSpacing value: exampleLayout rowSpacing.  columnHomogeneous state: exampleLayout isColumnHomogeneous.  rowHomogeneous state: exampleLayout isRowHomogeneouschildNodeFromItem: anItem  ^(anItem     container: self model;     buildWithSpec)     parentNode: self;     yourselfpackageNameForItem: anItem  ^anItem package ifNil: [ '' ] ifNotNil: [:package |  package name ]buildWidget  widget := FTTableMorph new     beRowNotHomogeneous;     dataSource: self newDataSource;     setMultipleSelection: self presenter isMultipleSelection;     hideColumnHeaders;     hResizing: #spaceFill;     vResizing: #spaceFill;     setBalloonText: self help;     onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self;     onAnnouncement: FTStrongSelectionChanged send: #strongSelectionChanged: to: self;     yourself.  self presenter whenPresentersChangedDo: [ self refreshList ].  self refreshWidgetSelection.  self presenter whenSelectionChangedDo: [ self refreshWidgetSelection ].  ^widgetnotifyPropertyChanged: aName  self flag: #todo.  (self observablePropertyNamed: aName) valueChangedaddFocusRotationKeyBindings  applyPostTransmissionWith: aTransmittedObject  self postTransmission ifNil: [ ^self ].  self postTransmission cull: self toPresenter cull: self fromPresenter cull: aTransmittedObjecttestInitializeIsInstanceButtonSelectedShouldBetrue  self assert: biChooseMethod isInstanceSideSelectedtestRemoveBlockExecutedWhenSelectedItemRemoved  | executed selectedItem |  executed := false.  presenter     items: #(1 2 3) asOrderedCollection;     removeItemBlock: [:item |  executed := true.        selectedItem := item ];     selectItem: 2.  presenter removeButton click.  self assert: executed description: 'removeBlock not exeuted when selected item removed!'.  self assert: selectedItem equals: 2parent: aStyle  parent := aStyleinitialize  super initialize.  kmCategory := KMCategory newitems: aList  self dropList items: aListbehavior  self deprecated: 'This method is an horrible hack because the VersionBrowser was using Code or Diff presenter but was only using the APIof the Code presenter... This method and other methods from the CodePresenter APIwill be removed.'.  ^self contextClassadd: aBlock top: top bottom: bottom left: left right: right  | layout |  layout := self computeLayoutFromTop: top bottom: bottom left: left right: right.  self add: aBlock origin: layout first corner: layout second offsetOrigin: layout third offsetCorner: layout fourthvalue  ^self host valuesAndCounts at: self indexicon: anIcon  self button icon: anIconselectedItem  ^self dropList selectedItemwhenMenuChanged: aBlock  tree whenMenuChanged: aBlocknextMonthButton  ^nextMonthButtonlistSize  self dropList listSizeemptyList  ^self dropList emptyListlabelHolder  self deprecated: 'Nobody should access directly to internals of Spec. Now this variable is not a value holder anymore.'connectPresenters  super connectPresenters.  moreOptionsButton action: [ moreOptionsVisible := moreOptionsVisible not.        self needRebuild: false.        self buildWithSpec ]itemsLabel: anObject  itemsLabel := anObjecttestOpening  | aPresenter |  aPresenter := application newPresenter: SpTestingPresenterWithAdditionalPresenters.  aPresenter openWithSpec.  #(subpresenter1 subpresenter2 subpresenter3) do: [:aKey |  self assert: (aPresenter additionalSubpresentersMap at: aKey) owner equals: aPresenter ]scrollValue: aPoint  ^scrollValue := aPointaskOkToClose: aBoolean  self deprecated: 'With Spec 2, SpPresenter was refactored to move all window management to WindowPresenter.	From now on, if you want to interact with a window you need to:	- Implement #initializeWindow: method (#initializeDialog: for dialogs) to manage window elements before the presenter is opened	- Use the method #window or #withWindowDo: to interact with windows after it has been opened.'.  self window ifNil: [ askOkToClose := aBoolean ] ifNotNil: [:window |  window askOkToClose: aBoolean ]activePresenter  ^activePresenterscale: anObject  scale := anObjectstatusBar: aStatusbarPresenter  aStatusbarPresenter ifNotNil: [ aStatusbarPresenter owner: self ].  ^statusbar := aStatusbarPresenterexecute  'OK' crLogtearDown  mock ifNotNil: [ mock hasWindow ifTrue: [ mock window close ] ].  super tearDownredraw  widget redrawtitle  ^self object class printStringdropList  ^dropListrightText: anObject  rightText := anObjectcontextMenuFromCommandsGroup: aValuable  self contextMenu: [ aValuable value beRoot asMenuPresenter ]evaluate: aString andDo: aBlock  | stream result receiver evaluationContext |  stream := aString readStream.  receiver := self context doItReceiver.  evaluationContext := self context doItContext.  result := receiver class compiler     source: stream;     context: evaluationContext;     receiver: receiver;     requestor: receiver;     failBlock: [ ^nil ];     evaluate.  ^aBlock value: resultsetRGMethodFrom: aMethod  rgMethod := aMethod asRingDefinition asHistoricalcalculatedExtent  self extent ifNotNil: [:aPoint |  ^aPoint ].  self minExtent ifNotNil: [:aPoint |  aPoint ].  ^10 @ 10isPresenter  ^falsecolor: anObject  color := anObjecttitle  ^String streamContents: [:stream |  stream << self class title << ' on: ' << self model currentChangeSet name ]initializeTestedInstance  presenter     numberOfColumns: 2;     displayBlock: [:item |  {item .         42 .         1} ];     items: {1 .         2 .         3}testSetSelectItemOutsideRangeRaisesSelectionChangeEventWithUnsetPath  | selectedPath |  presenter whenSelectionChangedDo: [:selection |  selectedPath := selection selectedPath ].  presenter selectItem: 4000.  self assert: selectedPath equals: #()initializePresenters  list := self newListneglect: aModel  aModel neglectMenuModel: selfwidth: anObject  width := anObjectpresenters  ^self basicPresenters valuesinBounds: aNumber  ^self inferiorToMaximum: (self superiorToMinimum: aNumber)widget  self deprecated: 'Should use #adapter instead' transformWith: '`@receiver widget' -> '`@receiver adapter'.  ^self spectestIsPresenter  self deny: application isPresenterautoAccept  ^self sliderInput autoAcceptinstallIconStylerFor: anItem  (self isMethodDefinition: anItem) ifFalse: [ ^self ].  IconStyler styleText: self textModel withAst: anItem astaddSelf: elements  elements add: (SelfEyeElement host: self object)bottomFraction: aNumber  layoutFrame bottomFraction: aNumbertriggerCancelAction  self cancelcolumn  ^self position xat: anIndex ifAbsent: aBlock  ^collection at: anIndex ifAbsent: aBlocknotify: aSpecNotification  aSpecNotification dispatchTo: self backenddeepPresenters  ^self presenters inject: #() into: [:all :each |  all , (each isSpLayout ifTrue: [ each deepPresenters ] ifFalse: [ {each} ]) ]interpretASpec: aSpec presenter: aPresenter  self presenter: aPresenter.  ^self interpretASpec: aSpecadd: aPresenter width: anInteger  self add: aPresenter withConstraints: [:constraints |  constraints width: anInteger ]buttonHighlighted  ^buttonHighlightedtestMaxLengthIsSet  presenter maxLength: 10.  self assert: presenter maxLength equals: 10elementAt: rowIndex  ^self presenters at: rowIndexadoptPaneColor: paneColor  super adoptPaneColor: paneColor.  self fillStyle: self normalFillStylewhenDaySelectedBlock  ^whenDaySelectedBlockgetIndex  ^selection selectedIndexinitializePresenters  radioButtonExample := self instantiate: SpRadioButtonExamplechildrenForObject: anObject  | objects |  objects := anObject wrappedObject pointersToExcept: {self .         anObject}.  objects := objects reject: [:each |  each class = EyePointerWrapper ].  onlyStrong ifTrue: [ objects := objects reject: [:each |  each pointsOnlyWeaklyTo: anObject wrappedObject ] ].  ^objects collect: [:each |  PointerEyeElement host: anObject wrappedObject value: each ]buttonWithMenu: anObject  buttonWithMenu := anObjectrebuildWidget  self widgets removeAll.  self createWidgets.  self needFullRebuild: false.  self buildWithSpecLayout: self dynamicLayoutcalculateRowHeights  ^layout isRowHomogeneous ifTrue: [ self calculateHomogeneousRowHeights ] ifFalse: [ self calculateNotHomogeneousRowHeights ]pushHistory  history add: self inspector.  self toolbar updateicon  ^(self value iconOrThumbnailOfSize: 16) ifNil: [ self value class systemIcon ]versionMethod  self method ifNotNil: [:aMethod |  self model browseVersionsFrom: aMethod ]buildWithSpec: aString  ^self buildWithSpeclabel: aString  labelHolder value: aStringtestSelectIndexesAddsIndexesToSelectedIndexList  presenter selectIndexes: {1 .         2}.  self assert: (presenter selection includesIndexes: {1 .               2})popMessage  self widgetDo: [:w |  self popMessageFrom: w ]testSelectItemsThenSelectOutsideRangeKeepsElements  presenter selectItems: {10 .         20}.  presenter selectItems: {4000 .         5000}.  self assert: (presenter selection includesItems: {10 .               20})icon  | icon |  icon := self model icon.  ^(icon isBlock or: [ icon isMessageSend ]) ifTrue: [ icon cull: self model ] ifFalse: [ icon ]selectAll  ^self input selectAllselectIndex: anIndex  self basicSelectIndex: (self withinRangeIndex: anIndex)generateSpec  | str spec |  str := layoutFrame asArray readStream.  spec := OrderedCollection with: #SpLayoutFrame.  #(leftFraction: topFraction: rightFraction: bottomFraction: leftOffset: topOffset: rightOffset: bottomOffset:) do: [:sel |  spec add: sel.        str next ifNil: [ spec add: 0 ] ifNotNil: [:value |  spec add: value ] ].  ^spec asArraycheckboxWithHelp  ^checkboxWithHelpstate: anObject  state := anObjecttestSelectItemAddsIndexToSelectedIndexList  presenter selectItem: 10.  self assert: (presenter selection includesIndex: 1)updatePageTitle: aPage  self widgetDo: [:w |  w relabelPage: (w pageWithModel: aPage) with: (self buildLabelForPage: aPage) ]setUp  super setUp.  presentersBuilder := SpDynamicPresentersListBuilder new     modelObjects: (1 to: 14);     presenter: SpButtonPresenter configuredAs: [:button :i |   ];     buildDynamicPresenter;     yourself.  layout := SpDynamicTopToBottomRowsLayout rows: 7width  ^self lookupProperty: SpStyleGeometry valueOf: #widthsetScrollValue: aValue  self widgetDo: [:w |  w scrollPane           hScrollbarValue: aValue x;           vScrollbarValue: aValue y;           updateScrollbars ]click  ^self model action valueactivateOnDoubleClick  activateOnSingleClick := falseswitchAutoscale  self widgetDo: [:w |  w layout: self layoutValue ]initialize  super initialize.  title := 'Title'.  okBlock := [  ].  removeItemBlock := [:item |  self items remove: item.  self refresh ]addConstraits: constraints toChild: childMorph  self subclassResponsibilitydayClicked: aDate  self whenDaySelectedBlock cull: aDate cull: selftestSelectItemSetsSelectedItem  presenter selectItem: 20.  self assert: presenter selection selectedItem equals: 20bottomButton  ^bottomButtonsetIndexes: aCollectionOfIndexes  self deprecated: 'Use the #selection object instead. This method assumes multiple selection' transformWith: '`@receiver setIndexes: `@arg' -> '`@receiver selection selectIndexes: `@arg'.  self selection selectIndexes: aCollectionOfIndexestext: aText  self input text: aTextkeyStroke: aKeyStroke  ^self model keyStroke: aKeyStroketextModel1  ^textModel1whenDisplayBlockChangedDo: aBlock  displayBlock whenChangedDo: aBlockgetIndex  ^self model getIndexneglectMenuModel: aMenuModel  aMenuModel menuGroups do: [:group |  group menuItems do: [:item |  item shortcut ifNotNil: [:shortcut |  self removeKeyCombination: shortcut ].              item subMenu ifNotNil: [:subMenu |  subMenu neglect: self ] ] ]configurationClass  ^Smalltalk globals at: workingCopy package name asSymboltestRadio3StartsDeselected  self openInstance.  self deny: self presenter radio3 statetestLabelChangeRaisesEvent  self assertEvent: #whenChangedDo: isRaisedInPresenter: presenter whenDoing: [ presenter label: 'test' ]removeTab: aTab  self basicRemoveTab: aTab.  self changed: #removeTab: with: {aTab}contextClass  ^contextClassshortcutGroup: aKeyGroup  shortcutGroup := aKeyGrouptestSetSelectPathOutsideRangeRaisesSelectionChangeEventWithUnsetItem  | selectedItem |  presenter whenSelectionChangedDo: [:selection |  selectedItem := selection selectedItem ].  presenter selectPath: #(4).  self assert: selectedItem equals: nilwhenMenuChangedDo: aBlock  self property: #contextMenu whenChangedDo: aBlockwantsDroppedMorph: draggedMorph event: anEvent inMorph: source  draggedMorph isTransferable ifFalse: [ ^false ].  ^self wantDropBlock cull: draggedMorph passenger cull: anEvent cull: sourcegetLabelSelector  ^getLabelSelectorhasUnacceptedEdits: aBoolean  self model hasUnacceptedEdits: aBooleaninitializeTestedInstance  presenter     addColumn: (SpStringTableColumn title: 'Value' evaluated: #printString);     hideColumnHeaders;     roots: #(1 2 3);     children: [:aNumber |  {(aNumber * 2) .         (aNumber * 3) .         (aNumber * 10)} ]addPaneHSplitters  | remaining targetBottom sameBottom sameTop |  remaining := paneMorphs reject: [:each |  each layoutFrame bottomFraction = 1 or: [ each layoutFrame bottomFraction = 0 ] ].  [ remaining notEmpty ] whileTrue: [ targetBottom := remaining first layoutFrame bottomFraction.        sameBottom := remaining select: [:each |  each layoutFrame bottomFraction = targetBottom ].        sameTop := paneMorphs select: [:each |  each layoutFrame topFraction = targetBottom ].        remaining := remaining copyWithoutAll: (self addPaneHSplitterBetween: sameBottom and: sameTop) ]testContextMenu  | menu changed |  self assert: presenter contextMenu isNil.  menu := SpMenuPresenter new.  changed := false.  presenter whenMenuChangedDo: [ changed := true ].  presenter contextMenu: menu.  self assert: presenter contextMenu equals: menu.  self assert: changeddatesToDisplayFor: aDate  ^(self julianDaysIntervalFor: aDate) collect: [:julianNumber |  Date julianDayNumber: julianNumber ]keyStrokeAction: aBlock  keyStroke value: aBlockfileOutClass  self model fileOutClass: self selectedClass from: self selectedChangeSettestSelectIndexOutsideRangeUnsetsSelectedItem  presenter selectIndex: 4.  self assert: presenter selection selectedItem equals: nilpushMessage  count := count + 1.  statusBar pushMessage: ('StatusBar message {1}...' format: {count})waitUntilUIRedrawed  self isRunningInUIProcess ifTrue: [ self currentWorld doOneCycle.        ^self ].  self currentWorld defer: [ uiWaitingSemaphore ifNotNil: #signal ].  uiWaitingSemaphore wait: self defaultWaitDurationcontactBookPresenter  ^self contextcontextMenu  ^contextMenuperformTest  specInitializationStrategy beforeTest: self.  super performTestlabel  ^displayBlock cull: modelwithoutScrollBars  wrapScrollBars := falseinitializePresenters  browseButton := self newButton.  configButton := self newButton.  packageButton := self newButton.  self setBrowseButton.  self setConfigButton.  self setPackageButton.  self setSliceButtonbuildAdapterFor: aPresenter bindings: adapterBindings  ^SpInterpreter interpretASpec: self presenter: aPresenterdoItContext  ^self objectfillFormWithWorkingModel  | aModel |  aModel := self workingModel.  self nameTextInput text: aModel name.  self surnameTextInput text: aModel surname.  self number1Input text: aModel number1 asString.  self number2Input text: aModel number2 asString.  self scaleInput value: aModel scale.  self passwordInput text: aModel password.  self checkboxInput state: aModel rememberMe.  self dateInput date: aModel date.  (genderButtons at: aModel gender) state: true.  self itemsInput selectItems: self workingModel selectedItemsrecalculatePages  self widget ifNil: [ ^self ].  self childrenWidgets ifEmpty: [ ^self ].  (needRecalculatePages not and: [ lastExtent = self widget extent and: [ lastPageSize = self childrenWidgets size ] ]) ifTrue: [ ^self ].  needRecalculatePages := false.  lastExtent := self widget extent.  lastPageSize := self childrenWidgets size.  layout direction recalculatePages: selfchanged  ^self widgetDo: [:w |  w changed ]classToTest  ^SpTabPresenterselectPaths: pathArray  (pathArray isEmpty or: [ pathArray size = 1 and: [ pathArray first isEmpty ] ]) ifTrue: [ ^self unselectAll ].  pathArray do: [:path |  presenter itemAtPath: path ifAbsent: [ ^self ] ].  selection = pathArray ifTrue: [ ^self ].  selection := pathArraycontextMenu: aValuable  contextMenu := aValuableproperty: aName rawValue: anObject  (self observablePropertyNamed: aName) rawValue: anObjectrowIndex  ^rowIndexpresenter  ^presenterhasChildrenBlock  ^hasChildrenBlockHolder valuepageTitleChanged: aPage  self changed: #updatePageTitle: with: {aPage}accessorCode  ^'self class'copyMethodFrom: src to: dest  | other |  self checkThatSidesDiffer: [ ^self ].  other := dest selectedChangeSet.  src selectedSelector ifNotNil: [:selector |  | class |        class := src selectedClass.        self model copySelector: selector inClass: class from: src selectedChangeSet to: other.        dest updateClassesListAndMessagesList ]testSelectIndexesOutsideRangeIsEmpty  presenter selectIndexes: {4 .         5}.  self assert: presenter selection isEmptybasicSelectionChanged: ann  | selection |  selection := self presenter selection.  ann newSelectedIndexes ifEmpty: [ ^selection unselectAll ].  (ann newSelectedIndexes difference: ann oldSelectedIndexes) ifEmpty: [ ^self ].  selection selectPaths: (ann newSelectedIndexes collect: [:index |  self widget dataSource pathFromIndex: index ])emphasis: anEmphasis  emphasis := anEmphasis isSymbol ifTrue: [ {anEmphasis} ] ifFalse: [ anEmphasis ].  self changed: #emphasis: with: {emphasis}start  setRigidityOfNonExpandedMorph: aMorph  self subclassResponsibilityaskBeforeDiscardingEdits: aBoolean  self widget askBeforeDiscardingEdits: aBooleantestExecute  self flag: #TODOisFill  ^fill ifNil: [ self class defaultFill ]retrieveDefaultSpec  ^self retrieveSpec: self defaultSpecSelectorindexFromPath: anArray  ^anArray sumpresenters  ^self items values flattenedtestUnselectUnselectedItemRaisesNoSelectionEvent  | counter |  counter := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectItem: 20.  self assert: counter equals: 0gender  ^genderradio2  ^radio2page  ^pagetestIconFor  presenter     items: #(#add #back #catalog);     icons: [:item |  Smalltalk ui icons iconNamed: item asSymbol ].  self assert: (presenter iconFor: #add) equals: (Smalltalk ui icons iconNamed: #add)evaluation  ^evaluationgetList  ^model itemswindowClosed: aWindowPresenter  self windows remove: aWindowPresenter ifAbsent: [  ]defaultInitialExtent  ^self currentWorld extentwhenValueChangedDo: aBlock  self property: #value whenChangedDo: aBlockselectIndexes: aCollection  self subclassResponsibilitydoubleClick  doubleClick value valueshowOnlySource  ^self model showOnlySourcecloseable  ^closeableHolder valuewindowIsClosing  SystemAnnouncer uniqueInstance unsubscribe: selftestAddColumnRaisesColumnChangedEvent  | columnsChanged |  columnsChanged := false.  presenter whenColumnsChangedDo: [ columnsChanged := true ].  presenter addColumn: (SpStringTableColumn new evaluated: #yourself).  self assert: columnsChangedurlHoverColor  ^self urlColor darkerrightOffset: aNumber  ^0initialize  super initialize.  selectedIndexes := OrderedCollection newheaderMorph  ^headerMorphuseBackend: aName  backend := SpApplicationBackend findBackendNamed: aNameautoScale  ^autoScalemodel: aDomainObject  (aDomainObject isSpAnnouncingObject not and: [ self announcingObject isValueHolder ]) ifTrue: [ self announcingObject value: aDomainObject ] ifFalse: [ self setAnnouncingObject: aDomainObject ]isRedrawable  ^falsebrowseButton  ^browseButtontestRemoveTabUnsetOwner  presenter addTab: redTab.  self assert: redTab owner equals: presenter.  presenter removeTab: redTab.  self assert: redTab owner isNilfrom: aPresenter to: anotherPresenter  self from: aPresenter to: anotherPresenter transform: nilselectOnlyLastHighlighted  ^self model selectOnlyLastHighlightedreadSelectionBlock  ^readSelectionbuildWidget  | m p |  m := Morph new     changeProportionalLayout;     hResizing: #spaceFill;     vResizing: #spaceFill;     yourself.  p := (self progressBarState progressBarMorph from: 0 to: 1)     changeProportionalLayout;     hResizing: #spaceFill;     vResizing: #spaceFill;     yourself.  self progressBarState customizeMorphicBar: p.  m addMorph: p fullFrame: LayoutFrame identity.  ^mmodel: aTablePresenter  model := aTablePresentericon  ^icontestWhenNumberChangedDo  | count result |  count := 0.  presenter whenNumberChangedDo: [:value |  count := count + 1.        result := value ].  presenter number: 10.  self assert: count equals: 1.  self assert: result equals: 10testChangingHelpAffectTheWidget  presenter help: 'ALabel'.  self assert: self adapter helpText equals: 'ALabel'testInferiorToMaximum  presenter maximum: nil.  self assert: (adapter inferiorToMaximum: 100) equals: 100.  presenter maximum: 150.  self assert: (adapter inferiorToMaximum: 100) equals: 100.  presenter maximum: 90.  self assert: (adapter inferiorToMaximum: 100) equals: 90objectChanged  self text doItReceiver: self object.  self text ifNotNil: [:w |  w behavior: self object class ].  self tree     roots: self roots;     expandRootsinitialize  super initialize.  self beExpandablelabelClickable  ^labelClickableselectedIndexes  ^selectedIndexesverticalAlignment  ^vAlignwhenModelChangedDo: aBlock  model whenChangedDo: aBlockselectPath: aPath  self subclassResponsibilitytestSelectAllDoesNotRaiseEvent  | events |  events := 0.  presenter whenSelectionChangedDo: [:selection |  events := events + 1 ].  presenter selectAll.  self assert: events equals: 0model  ^modeltestIsClosed  self assert: presenter isClosed.  self openInstance.  self deny: presenter isClosed.  presenter close.  self assert: presenter isClosedcancelButton  ^cancelButtonhistory  ^historybeVertical  direction := SpLayoutDirection verticalinitialize  super initialize.  calculating := falsetestInitializeClassListShouldBeSelectTheFistItem  self assert: biChooseMethod classList selection selectedIndex equals: 1autoRefresh  ^autoRefreshwidthPositionIn: aPoint  ^self position < 1 ifTrue: [ (aPoint x * self position) asInteger ] ifFalse: [ self position ]resetArrayComputation  postTransmission  ^postTransmissionnotify: errorMessage at: position in: sourceCode  self flag: #TOMOVE.  self widgetDo: [:w |  w notify: errorMessage at: position in: sourceCode ]instVarName: aString  instVarName := aStringtestMaxLengthIsSetInWidget  presenter maxLength: 10.  self assert: self widget maxLength equals: 10y: anInteger  y := anIntegerdoActivateAtPath: aPath  self itemAtPath: aPath ifAbsent: [ ^self ].  activationBlock cull: ((SpTreeSingleSelectionMode on: self)           selectPath: aPath;           yourself)syntaxHighlight: aBoolean  syntaxHighlight := aBooleanheaderLabel  ^headerLabel valuepresenterAt: aName ifAbsent: aBlock  ^self basicPresenters at: aName ifAbsent: [ [ self readSlotNamed: aName ] on: SlotNotFound do: aBlock ]testAddPresenterAddsWidget  | button |  button := SpButtonPresenter new.  presenter addPresenter: button.  backendForTest waitUntilUIRedrawed.  self assert: self adapter children first equals: button adapter widgettestActivationOnSingleClickShouldNotActivateOnClickOutside  | activatedItem |  presenter     activateOnSingleClick;     whenActivatedDo: [:selection |  activatedItem := selection selectedItem ].  presenter clickAtPath: #(4).  self assert: activatedItem isNilactivateOnDoubleClick  activateOnSingleClick := falseremoveChangeSet: aChangeSet prompting: doPrompt  | message aName changeSetNumber msg |  aName := aChangeSet name.  aChangeSet okayToRemove ifFalse: [ ^self ].  (aChangeSet isEmpty or: [ doPrompt not ]) ifFalse: [ message := 'Are you certain that you want to remove (destroy) the change setnamed  "' , aName , '" ?'.        (self confirm: message) ifFalse: [ ^self ] ].  doPrompt ifTrue: [ msg := aChangeSet hasPreamble ifTrue: [ aChangeSet hasPostscript ifTrue: [ 'a preamble and a postscript' ] ifFalse: [ 'a preamble' ] ] ifFalse: [ aChangeSet hasPostscript ifTrue: [ 'a postscript' ] ifFalse: [ '' ] ].        msg isEmpty ifFalse: [ (self confirm: 'Caution!  This change set has' , msg , ' which will belost if you destroy the change set.Do you really want to go ahead with this?') ifFalse: [ ^self ] ] ].  changeSetNumber := aChangeSet name initialIntegerOrNil.  changeSetNumber ifNotNil: [ SystemVersion current unregisterUpdate: changeSetNumber ].  ChangeSet removeChangeSet: aChangeSetvRigid  selectedObjectDo: aBlock  self selectedElement ifNotNil: [:element |  aBlock value: element value wrappedObject ]index  ^indexdisableSearch  searchEnabled := falsependingText: aText  self widgetDo: [:w |  w setText: aText.        w hasUnacceptedEdits: true ]testWithSyntaxHighlight  presenter withSyntaxHighlight.  self assert: self adapter hasSyntaxHighlightEnabledinitialWidth: anInteger  initialWidth value: anIntegerupdate: aSymbol  aSymbol = #pushMessage ifTrue: [ self pushMessage ].  aSymbol = #popMessage ifTrue: [ self popMessage ].  ^super update: aSymbolflattenClasses  ^(self styles inject: (OrderedCollection with: self) into: [:all :each |  each isStyleClass ifTrue: [ all addAll: each flattenClasses ].        all ]) flattenedchildNodeClass: aBlock  childNodeClass value: aBlockselectItem: anIndex  list selectItem: anIndextestSelectPresenterIndexOutsideRangeUnsetsSelectedIndexInWidget  presenter selectPath: #(100).  self assert: self adapter selectedPaths isEmptyinitialize  self class initializeSlots: self.  super initialize.  needRebuild := truetestSelectIndexTwiceMakesIsListedOnceInSelectedIndexes  presenter     selectIndex: 3;     selectIndex: 3.  self assert: presenter selection selectedIndexes asArray equals: #(3)menu  ^menunewHorizontal  ^self newPanel     listDirection: #leftToRight;     yourselfbuildWithSpecAsPopup  ^self buildWithSpec: #popupselectedPage  ^selectedPageasToolBarPresenter  self deprecated: 'Use #asToolbarPresenter instead.' transformWith: '`@receiver asToolBarPresenter' -> '`@receiver asToolbarPresenter'.  ^self asToolbarPresenterretrievingBlock: aBlock  retrievingBlockHolder value: aBlockpassenger  ^passengerapplyStyle: aMorph  super applyStyle: aMorph.  aMorph fitContentsmaxLength: anInteger  maxLength := anInteger.  self updateTextselectedMethods  self deprecated: 'I have the impression this method is not use. If it end up been call, please open an issue on pharo-spec/Spec'.  ^{self selectedMessage} asOrderedCollectionextent  ^extentheight: anObject  self expand: false.  height := anObjectmethodRemoved: anAnnouncement  UIManager default defer: [ self handleMethodRemoved: anAnnouncement ]testSetSelectInvalidPathDoesNotModifySelection  presenter whenSelectionChangedDo: [:selection |  self fail ].  presenter selectPath: #(50 1)passwordLabel  ^passwordLabeltestAddPage  self assertEmpty: presenter pages.  presenter addPage: self mockPage.  self assert: presenter pages size equals: 1selectedPage: anObject  selectedPage := anObjecttopFraction  ^0buildWidget  ^SpStubFastTableView newpassenger: aBlock  passenger := aBlock valueheight: aNumber  self vRigid.  self widgetDo: [:w |  w height: aNumber ]applyTextStyle  self setText: self presenter text to: self widgetoutputPortNamed: aSymbol  ^self outputPorts detect: [:each |  each name = aSymbol ]property: aName whenChangedDo: aBlockClosure  (self observablePropertyNamed: aName) whenChangedDo: aBlockClosurewhenBehaviorChangedDo: aBlock  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8widgetFor: aPresenter  aPresenter adapter ifNotNil: [:adapter |  ^adapter widget ].  ^aPresenter buildWithSpec     vResizing: #shrinkWrap;     yourselfwhenSelectedItemsChanged: aBlock  self deprecated: 'Use #whenSelectedItemsChangedDo: instead.' transformWith: '`@receiver whenSelectedItemsChanged: `@statements' -> '`@receiver whenSelectedItemsChangedDo: `@statements'.  self whenSelectedItemsChangedDo: aBlocktestHideHeaderTitleUnsetsTitle  presenter     headerTitle: 'title';     hideHeaderTitle.  self deny: presenter hasHeaderTitleasSpecCommand  ^super asSpecCommand     shortcutKey: $n meta;     yourselftestRemoveTab  presenter addTab: redTab.  self assertCollection: presenter tabs hasSameElements: {redTab}.  presenter removeTab: redTab.  self assertCollection: presenter tabs hasSameElements: #()beColumnNotHomogeneous  self columnHomogeneous: falsecancelAction: aBlock  self toolbar cancelAction: aBlockclassDescriptionsMap  ^self class classDescriptionsMaptestOpenPresenterIsBuilt  self openInstance.  self assert: presenter isBuiltactivate  self activateHelpWithoutArguments ifTrue: [ ^self ].  (self hasOption: 'list') ifTrue: [ ^self listApplications ].  self runApplicationisEmpty  ^self contents isEmptyisEmpty  ^self presenters isEmptypageAt: index  ^(self pages at: index) actualPageMorphisAboutToStyle  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8runCase  self resources do: [:each |  each availableFor: self ].  [ super setUp.  backendForTest runTest: [ presenter := self classToTest new.        self performTest ] ] ensure: [ self tearDown.        self cleanUpInstanceVariables ]testUnselectAllInWidgetWithoutSelectionDoesNotRaiseEvent  | counter |  counter := 0.  presenter selection whenChangedDo: [:selection |  counter := counter + 1 ].  self adapter selectPath: #().  self assert: counter equals: 0label  ^self model labelitems  ^list model itemssetVersionModel  versionModel     state: false;     label: 'Version';     action: [ self versionMethod ]subwidget: sub spec: aSpecSelector layoutFrame: aFrameLayout  self subwidget: sub.  self specSelector: aSpecSelector.  self layoutFrame: aFrameLayoutwhenPasswordChangedDo: aBlockClosure  self property: #isPassword whenChangedDo: aBlockClosureupdateClassesListAndMessagesList  | sel |  sel := methodsListPresenter selectedItem.  self updateClassesList.  methodsListPresenter setSelectedItem: sel.  self updateMessagesListtestWhenActivatedDo  | actionExecuted |  actionExecuted := false.  presenter whenActivatedDo: [ actionExecuted := true ].  self emulateLeftClick.  self assert: actionExecutedparentNode  ^parentNode valuetestSelectPathSetsSelectedPath  presenter selectPath: #(1 1).  self assert: presenter selection selectedPath equals: #(1 1)asSpLayout  ^selfregisterShortcut: newShortcut  | receiver |  receiver := self window.  (receiver isNil or: [ newShortcut isNil ]) ifTrue: [ ^self ].  receiver presenter bindKeyCombination: newShortcut toAction: [ self performAction ]presentersInFocusOrder  ^focusOrder ifNil: [ self layoutPresenters select: [:each |  each isVisible and: [ each canTakeKeyboardFocus ] ] ]testSuceedToOpenInstance  self shouldnt: [ self openInstance ] raise: ErrorsetSelectedIndex: anIndex  self deprecated: 'Use #selectedIndex: instead' transformWith: '`@receiver setSelectedIndex: `@argument' -> '`@receiver selectedIndex:`@argument'.  ^self selectedIndex: anIndextestSuperiorToMinimum  presenter minimum: nil.  self assert: (adapter superiorToMinimum: 100) equals: 100.  presenter minimum: 90.  self assert: (adapter superiorToMinimum: 100) equals: 100.  presenter minimum: 120.  self assert: (adapter superiorToMinimum: 100) equals: 120initialize  super initialize.  self hResizing: nil.  self vResizing: nilwhenSelectedPageChanged: aBlock  self deprecated: 'Use #whenSelectedPageChangedDo: instead.' transformWith: '`@receiver whenSelectedPageChanged: `@statements' -> '`@receiver whenSelectedPageChangedDo: `@statements'.  self whenSelectedPageChangedDo: aBlocky  ^yaddKeyBindingsTo: aMorph  leftText  ^self model leftTextsetSelectedClass: aClass  ^classesListPresenter setSelectedItem: aClasswhenSelectedChangedDo: aBlock  selected whenChangedDo: aBlockclimbRate: aNumber  climbRate := aNumberselectAll  self selection selectAlltestAsButtonPresenter2  | buttonPresenter |  command := CmCommand forSpec     name: 'foo';     description: 'bar';     iconName: #blank;     yourself.  buttonPresenter := command asButtonPresenter.  self assert: buttonPresenter label equals: 'foo'.  self assert: buttonPresenter help equals: 'bar'.  self assert: buttonPresenter icon equals: (buttonPresenter iconNamed: #blank)testSelectItemsThenSelectOutsideRangeKeepsPaths  presenter selectItems: {10 .         20}.  presenter selectItems: {5000 .         6000}.  self assertCollection: presenter selection selectedPaths hasSameElements: {#(1 1 3) .         #(1 3)}whenDeactivationActionChanged: aBlock  self deprecated: 'Use #whenDeactivationActionChangedDo: instead.' transformWith: '`@receiver whenDeactivationActionChanged: `@statements' -> '`@receiver whenDeactivationActionChangedDo: `@statements'.  self whenDeactivationActionChangedDo: aBlockwhenOpenedDo: aBlock  self property: #isClosed whenChangedDo: [:value |  value ifFalse: [ aBlock value ] ]emulateLeftClick  self emulateClick: MouseButtonEvent redButtonaddKeyBindingsTo: aMorph  self addFocusRotationKeyBindings.  self presenter contextKeyBindings ifNotNil: [:aCategory |  aCategory allEntries keymaps do: [:each |  self bindKeyCombination: each shortcut toAction: each action ] ]itemAtPath: aPath  ^self itemAtPath: aPath expanding: falseresetSelection  self dropList resetSelectioninitializeDialogWindow: aDialog  super initializeDialogWindow: aDialog.  aDialog     closeOnBackdropClick: true;     okAction: [:presenter |  self inform: 'Ok action' ];     cancelAction: [:presenter |  self inform: 'Cancel' ]initialExtent  ^initialExtent ifNil: [ self defaultInitialExtent ]multiSelection: aBoolean  multiSelection value: aBooleaninitializePresenters  checkboxNormal := self newCheckBox label: 'normal'.  checkboxDisabled := self newCheckBox     label: 'disabled';     disable;     yourself.  checkboxWithColor := self newCheckBox     label: 'red';     color: Color red;     yourself.  checkboxWithHelp := self newCheckBox     label: 'with help';     help: 'this is checkbox with help';     yourself.  checkboxWithLabelOnLeft := self newCheckBox     label: 'left';     yourself.  checkboxExample := self instantiate: SpCheckBoxExample.  self whenBuiltDo: [ checkboxWithLabelOnLeft labelOnLeft ]description  ^descriptionshiftLastWidgets  | index ante |  (lastFractionIndex > 0 and: [ lastFractionIndex < size ]) ifFalse: [ ^self ].  index := size - 1.  [ index > lastFractionIndex ] whileTrue: [ | myWidth |        ante := self commands at: index.        index := index - 1.        myWidth := ante rightOffset - ante leftOffset.        ante           leftOffset: (width + myWidth) negated;           rightOffset: width negated.        width := width + myWidth ].  self assert: index = lastFractionIndex.  ante := self commands at: index.  ante layoutFrame rightOffset: width negatedowner: aPresenter  owner := aPresenterdecreaseValueOf: aTextMorph  aTextMorph setText: (self decreasedValueFrom: aTextMorph getText)possibleEntities  ^possibleEntities ifNil: [ #() ] ifNotNil: [ possibleEntities value ]initialize  super initialize.  self beNotHomogeneous.  self spacing: 0.  self borderWidth: 0newMockContext  ^SpCodeCommandContextMock newmodel: aModel  model := aModelnewVertical  ^self newPanel     listDirection: #topToBottom;     yourselfaddSpecialFields: elements  elements add: (DynamicEyeElement host: self object label: 'sign' value: [ self object sign ]).  elements add: (DynamicEyeElement host: self object label: 'significand' value: [ self object significand ]).  elements add: (DynamicEyeElement host: self object label: 'exponent' value: [ self object exponent ]).  elements add: (DynamicEyeElement host: self object label: 'binary' value: [ self object binaryLiteralString ])selectedItems  ^self selectedIndexes collect: [:idx |  self model at: idx ]headerColumn: column  | headerMorph |  column id ifNil: [ ^nil ].  headerMorph := SpHeaderCellMorph new     addMorph: column id asMorph asReadOnlyMorph;     yourself.  column isSortable ifTrue: [ headerMorph eventHandler: (MorphicEventHandler new on: #click send: #sortByColumn:event:morph: to: self withValue: column) ].  ^headerMorphcustomSubMenu: aMenu  aMenu addGroup: [:aGroup |  aGroup           addItem: [:anItem |  anItem                 name: 'List Methods Using "' , self instVarName , '"';                 action: [ self referencesToInstanceVariable ] ];           addItem: [:anItem |  anItem                 name: 'List Methods Storing into "' , self instVarName , '"';                 action: [ self storingsIntoInstanceVariable ] ] ]leftFraction  ^0isRedrawable  ^trueclassToTest  ^SpListPresentermoreOptionsArea: aTextOrPresenter  moreOptionsArea := aTextOrPresenteruniformDropList  ^uniformDropListnewToolbarItem  ^SpToolBarButton newadd: aSpec  self add: aSpec origin: 0 @ 0 corner: 1 @ 1emptyList  model collection: OrderedCollection newinitialize  super initialize.  labelHolder := '' asValueHolder.  iconHolder := self defaultIcon asValueHolder.  morphHolder := nil asValueHolder.  retrievingBlockHolder := nil asValueHolder.  menuHolder := nil asValueHolder.  actionsHolder := OrderedCollection new asValueHolder.  closeableHolder := true asValueHolder.  tabSelectedActionHolder := [  ] asValueHolder.  selectedHolder := false asValueHolderaddContact: newContact after: contactAfter  contents add: newContact after: contactAfterpropertyAt: aKey ifAbsentPut: aBlock  ^self properties at: aKey ifAbsentPut: aBlockwhenChangedDo: aBlock  subscriptions add: aBlockokToChange  ^self model okToChangeat: anIndex  ^collection at: anIndexretrievingBlockHolder  ^retrievingBlockHoldersetTargetBounds  | target |  target := self target.  target bounds: (target bounds withRight: self left - 1)tempIndex: anObject  tempIndex := anObjectbuildWidget  | panelMorph |  panelMorph := PanelMorph new     changeTableLayout;     listDirection: self listDirection;     hResizing: #spaceFill;     vResizing: #rigid;     cellInset: self class defaultItemSeparation;     height: self class defaultHeight;     yourself.  self addModelTo: panelMorph.  ^panelMorphtitle  ^'Point'beEncrypted  ^self input beEncryptednewLayout  ^SpMorphicGridLayout new     layout: (SpGridLayout new           borderWidth: 0;           columnSpacing: 0;           rowSpacing: 0;           columnHomogeneous: false;           rowHomogeneous: false;           yourself);     yourselftearDown  aClass ifNotNil: [:e |  e removeFromSystem ].  super tearDownselectedObject  ^self valuewhenAboutToStyleBlockChanged: aBlock  self deprecated: 'Use #whenAboutToStyleBlockChangedDo: instead.' transformWith: '`@receiver whenAboutToStyleBlockChanged: `@statements' -> '`@receiver whenAboutToStyleBlockChangedDo: `@statements'.  self whenAboutToStyleBlockChangedDo: aBlockwhenDisplayBlockChanged: aBlock  self deprecated: 'Use #whenDisplayBlockChangedDo: instead.' transformWith: '`@receiver whenDisplayBlockChanged: `@statements' -> '`@receiver whenDisplayBlockChangedDo: `@statements'.  self whenDisplayBlockChangedDo: aBlockremovePicked: item  pickedItemsHolder remove: item ifAbsent: [ ^self ]testUnselectUnselectedItemRaisesNoSelectionEvent  | counter |  counter := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectItem: 20.  self assert: counter equals: 0testLabelIsSet  presenter label: 'test'.  self assert: presenter label equals: 'test'acceptColumnVisitor: aBuilder  ^aBuilder visitCompositeColumn: selfrowSpacing  ^rowSpacing ifNil: [ self class defaultRowSpacing ]incomingTransmission: anObject from: outPort  self destinationPresenter items: anObjectleftText  ^leftTexttestSelectItemThenSelectOutsideRangeKeepsFirstIndex  presenter selectItem: 10.  presenter selectItem: 500.  self assert: (presenter selection includesIndex: 1)cell: anObject  cell := anObjecttestSelectIndexOutsideRangeHasNoSelectedItems  presenter selectIndex: 4.  self assert: presenter selection selectedItems isEmptyselectedMethod  ^messageList selectedMethodmodel  self deprecated: 'Use #presenter instead' transformWith: '`@receiver model' -> '`@receiver presenter'.  ^self presenteropenDialogWithSpec: aSelector  ^self application openDialog: self withSpecLayout: (self retrieveSpec: aSelector)selectDialog: anObject  selectDialog := anObjectwhenTextIsAccepted: aBlock  self input whenTextIsAccepted: aBlockprogressBarState  ^self model stateparseStyleClass  | name reference style |  [ reference := self newReference.  name := self parseStyleName.  style := self styleClass new     name: name;     parent: currentStyle;     yourself.  self pushStyle: style during: [ style fromSton: self ].  self setReference: reference to: style ] on: NotFound do: [:notFound |  acceptUnknownClasses ifTrue: [ style := STON mapClass new.              self storeReference: style.              self parseMapDo: [:key :value |  style at: key put: value ].              style at: STON classNameKey put: notFound object ] ifFalse: [ self error: 'Cannot resolve class named ' , notFound object printString ] ].  ^styletestAddPresenterPushesItToPresenterList  self presenter addPresenter: (SpNullMillerPresenter on: SpLabelPresenter new).  self assert: self presenter size equals: 1withProgressionBlock  ^withProgressionBlockstyleName  ^'toolBar.icons'removePageAt: anIndex  pagesHolder removeAt: anIndexcanTakeKeyboardFocus  ^falsepresenterAt: aName put: aPresenter  ^self basicPresenters at: aName put: aPresentertitle  ^idcolor: color  self widgetDo: [:w |  w color: color ]setTargetBounds  | target |  target := self target.  target bounds: (target position corner: target right @ (self top - 1))calculateColumnWidths  ^layout isColumnHomogeneous ifTrue: [ self calculateHomogeneousColumnWidths ] ifFalse: [ self calculateNotHomogeneousColumnWidths ]connectPresenters  button action: [ input text: textToReset ].  input whenTextChangedDo: [:text |  label label: text ].  check     whenActivatedDo: [ self needRebuild: false.        self buildWithSpecLayout: self class defaultSpec ];     whenDeactivatedDo: [ self needRebuild: false.        self buildWithSpecLayout: self class bottomLayout ]beMultipleSelection  self selectionMode: (SpMultipleSelectionMode on: self)color: aColor  ^color := aColorvisitStringColumn: aTableColumn  initializePresenters  computeNonSplitterWidgetsIn: result  (self commands reject: #isSplitter) do: [:widget |  self setOffsetsFor: widget top: widget topOffset left: widget leftOffset bottom: widget bottomOffset right: widget rightOffset borderWidth: self class windowBorderWidth.        result addAll: widget asSpecElements ]drawBlock: aBlockClosure  drawBlock := aBlockClosureobject  ^objectapplyVisibility  width: anObject  width := anObjectbuildWidget  ^SpStubSliderView newtraverseInFocusOrderDo: aBlock excluding: excludes  excludes add: self.  aBlock value: self.  self selectedPage ifNil: [ ^self ].  self selectedPage activePresenter traverseInFocusOrderDo: aBlock excluding: excludesdefineInputPorts  ^{SpRootsPresenterPort new}initializeDropList  toolbarPresenter     addItemLabeled: 'Source' do: [ self textConverter: SourceMethodConverter new ];     addItemLabeled: 'Time stamp' do: [ self textConverter: TimeStampMethodConverter new ]visitCompositeColumn: aTableColumn  aTableColumn columns do: [:each |  self visit: each ]toPrintableString: printString  self flag: #TODO.  ^String streamContents: [:stream |  stream << ' "' << printString << '"' ]index: anObject  index := anObjecthelp  ^helpheaderAction: aBlock  headerAction value: aBlockadd: aBlock top: top bottom: bottom  self add: aBlock top: top bottom: bottom left: nil right: nilcontextMenu  ^contextMenutype: aString  self text: aStringwhenSelectedItemChangedDo: aBlockClosure  self whenSelectionChangedDo: [:selection |  aBlockClosure cull: selection second ]wantDropBlock  ^self model wantDropBlockflattenProperties  ^(self flattenClasses inject: self properties into: [:all :each |  all , each properties ]) flattenedconnectPresenters  sliders whenChangedDo: [ preview image: self makeNewForm ]headerFontChanged  self widgetDo: [:w |  w header label: self headerLabel font: self headerFont.        w container resizerChanged ]transform: anObject  ^anObjecttestClassSideRadioButtonState  biChooseMethod radioButtonClassSide click.  self deny: biChooseMethod isInstanceSideSelectedlayoutFrame: aFrame  self activate.  super layoutFrame: aFramepageClass  ^SpDemoTablePresenterposition  ^positionapplyStyleTo: aString  ^aStringpropertyAt: aKey ifPresent: aBlock ifAbsentPut: absentBlock  ^self properties at: aKey ifPresent: aBlock ifAbsentPut: absentBlockbeEncrypted  self input beEncryptedtestNewPresenterIsNotDisplayed  self deny: presenter isDisplayednewExampleMenu  | loremIpsumWorlds |  loremIpsumWorlds := String loremIpsum substrings.  ^SpMenuPresenter new     addGroup: [:group |  1 to: 10 atRandom do: [:index |  group addItem: [:item |  item                       name: ('{1}: {2}' format: {index .                                 loremIpsumWorlds atRandom});                       action: [ button label: item name ] ] ] ];     yourselfinitializeWindow: aWindowPresenter  aWindowPresenter title: 'Calendar'testStayingActiveDoesNotRaiseChangedEvent  presenter state: true.  self denyEvent: #whenChangedDo: isRaisedInPresenter: presenter whenDoing: [ presenter state: true ]y  ^yremoveSubWidgets  innerWidget removeAllMorphsmodel  ^modelinitializePrivateHooks  self flag: #todo.  self initializeWidgets.  self initializePresenters.  self initializePresenter.  self connectPresenters.  self updatePresenteraddToolBarTo: aMorph  | toolbarMorph |  toolbarMorph := self model toolBar buildWithSpec.  aMorph addMorphBack: toolbarMorph.  toolbarMorph     hResizing: #spaceFill;     vResizing: #rigidpresentersDo: aBlock  self basicPresenters valuesDo: aBlockuseProportionalLayout  self widgetDo: [:w |  w changeProportionalLayout ]testSelectionStartsEmptyIfStartWithoutSelectionIsSet  self assert: self presenter selectedItem equals: nil.  self assert: self adapter selectedIndexes equals: #()icon: anIcon  icon := anIconitem  ^itemwhenSearchChangedDo: aBlock  self property: #searchEnabled whenChangedDo: aBlockmoreOptionsText  ^moreOptionsTextmenu  ^self newMenu     title: 'Context menu example';     addGroup: [:aGroup |  aGroup           addItem: [:anItem |  anItem                 name: 'Print in transcript';                 shortcut: $p meta;                 description: 'Print the selected class on Transcript';                 action: [ table1 selectedItem traceCr ] ];           addItem: [:anItem |  anItem                 name: 'Browse';                 iconName: #open;                 action: [ table1 selectedItem browse ] ];           addItem: [:anItem |  anItem                 name: 'Print infos';                 subMenu: (self newMenu addGroup: [:aSubGroup |  aSubGroup                             addItem: [:item |  item                                   name: 'Print number of methods';                                   action: [ table1 selectedItem methods size traceCr ] ];                             addItem: [:item |  item                                   name: 'Print number of variables';                                   action: [ table1 selectedItem instanceVariables size traceCr ] ] ]) ] ];     addGroup: [:aGroup |  aGroup           addItem: [:anItem |  anItem                 name: 'Item showing only if item a odd number of letters';                 visibleIf: [ table1 selectedItem printString size odd ];                 action: [ table1 selectedItem traceCr ] ];           addItem: [:anItem |  anItem                 name: 'Disabled in second group';                 disable;                 action: [ table1 selectedItem traceCr ] ];           addItem: [:anItem |  anItem                 name: 'Disabled if class begins with A';                 enabled: [ table1 selectedItem printString first ~= $A ];                 action: [ table1 selectedItem traceCr ] ] ]beInteger  self numberType: Integersubscriptions  ^subscriptionswhenSelectDialogChanged: aBlock  self property: #selectDialog whenChangedDo: aBlockupdateMenu  instVarNames  ^self instVarToModelObject collect: #keybuildLabelForPage: aPage  | labelMorph |  labelMorph := Morph new     changeTableLayout;     vResizing: #spaceFill;     hResizing: #shrinkWrap;     cellInset: self class cellInset;     color: Color transparent;     listDirection: #leftToRight;     yourself.  aPage icon ifNotNil: [:icon |  labelMorph addMorphBack: icon asMorph ].  labelMorph addMorphBack: aPage title asMorph.  ^labelMorphaddDefaultButton: aString do: aBlock  defaultButton := self addButton: aString do: aBlock.  defaultButton addStyle: 'default'.  ^defaultButtoninitialize  super initialize.  self whenLabelChangedDo: [ self changed: #getText ]classToTest  ^SpEditableListPresentercontextMenu: aValuable  contextMenu := aValuableexecute  self editor copySelectionconnectPresenters  okButton action: self okActionBlocktree  ^tree ifNil: [ tree := self instantiate: SpTreePresenter.        tree whenBuiltDo: [ self initializeShortcuts ].        tree           whenSelectedItemChanged: [:item |  item ifNotNil: [ self elementChanged ] ];           childrenBlock: [:anObject |  self childrenFor: anObject ];           iconBlock: [:treeNode |  self iconFor: treeNode ];           displayBlock: [:anObject |  self labelFor: anObject ];           menu: [:menu |  self inspectionMenu: menu ];           doubleClick: [ self diveInto: self selectedObject ];           yourself ]dropEnabled: aBoolean  self widget ifNotNil: [:w |  w dropEnabled: aBoolean ]buildWithSpecLayout: aSpecLayout  | widget |  adapter := self basicBuildAdapterWithSpecLayout: aSpecLayout.  widget := adapter widget.  self announce: (SpWidgetBuilt model: self widget: widget).  ^widgetinitializePresenters  button1 := self newCheckBox.  button2 := self newCheckBox.  button3 := self newCheckBox.  label := self newLabel.  button1 label: 'Button 1'.  button2 label: 'Button 2'.  button3 label: 'Button 3'.  self updateLabel.  self setFocusmoveClassFrom: src to: dest  self checkThatSidesDiffer: [ ^self ].  (self okToChange and: [ src selectedClass notNil ]) ifFalse: [ ^self ].  self copyClassFrom: src to: dest.  src forgetClasstestSubscribeToChangeRaisesEventWithNewValue  | newValue |  point property: #x whenChangedDo: [:new |  newValue := new ].  point x: 17.  self assert: newValue equals: 17options: anObject  options := anObjectautoAccept  ^input autoAccepttextToReset  ^textToResettestSelectPathThenSelectInvalidPathKeepsFirstElement  presenter selectPath: #(1 3).  presenter selectPath: #(50).  self assert: (presenter selection includesItem: 10)initialExtent  ^self inspector initialExtenttestChangeDeactivatedAfterOpenCheckboxDectivatesIt  presenter state: true.  self openInstance.  presenter state: false.  self deny: presenter statesubtractFrom: src to: dest  | source destination |  source := src selectedChangeSet.  destination := dest selectedChangeSet.  self checkThatSidesDiffer: [ ^self ].  self model subtractFrom: source to: destination.  changeSorterRight setSelectedChangeSet: sourcependingText  ^self widgetDo: [:w |  w text ]stepTime  ^50cancelled  ^falsetestSelectingAPathUpdatesSelectionInPresenter  self presenter selection selectPath: #(2 3).  self assert: self presenter selectedItem equals: 20multiLabel  ^multiLabelfieldDisabled  ^fieldDisabledtestSelectPresenterItemSetsSelectedIndexInWidget  presenter selectItem: (presenter items at: 2).  self assert: (self adapter selectedIndexes includes: 2)doesNotUnderstand: aMessage  ^aMessage sendTo: subwidgetnameLabel: anObject  nameLabel := anObjectclassToTest  ^SpListPresenterspecSpacer  ^SpSpacerPresenter newtestSelectItemsOutsideRangeHasNoSelectedItems  presenter selectItems: {300 .         400}.  self assert: presenter selection selectedItems isEmptyclose  self isOpen ifFalse: [ ^self ].  self changed: #close with: #().  self application windowClosed: selftestSelectInvalidPathsHasNoSelectedPaths  presenter selectPaths: {#(10 20) .         #(20 20)}.  self assert: presenter selection selectedPaths isEmptyaddPresenter: aPresenter  aPresenter owner: self.  self model add: aPresenternotify: aSpecNotification  aSpecNotification type notify: aSpecNotification on: selfaddGroup: aBlock  | group |  group := self instantiate: SpMenuGroupPresenter.  aBlock value: group.  self addMenuGroup: grouplayoutTopToBottom: aMorph in: newBounds  self ensureHeightPosition: aMorph in: newBounds.  super layoutTopToBottom: aMorph in: newBoundswithSyntaxHighlight  self syntaxHighlight: trueplaceholder: aText  ^self input placeholder: aTexttriggerCancelAction  cancelAction ifNil: [ ^self ].  cancelAction cull: selfsetToolbarFrom: aBlock  | newToolbar |  newToolbar := aBlock value.  self toolbar: newToolbar.  self model presenter focusOrder addLast: toolbar.  toolbar focusOrder addLast: self modelbuildWidget  ^SpStubMenuGroupView newminHeight  ^self lookupProperty: SpStyleGeometry valueOf: #minHeightmethodClassNameForItem: anItem  ^anItem methodClass ifNotNil: [:class |  class name ] ifNil: [ '' ]initializeWindow  super initializeWindow.  self presenter initializeDialogWindow: selfnumber2Label: anObject  number2Label := anObjectnewTabManager  self deprecated: 'Use newNotebook instead' on: '2019-01-24' in: #Pharo8.  ^self instantiate: SpTabManagerPresenterinitialize  super initialize.  moreOptionsVisible := false.  buttons := OrderedDictionary newbrowseSelectedObject  self selectedObjectDo: [:anObject |  anObject browse ]classToTest  ^SpTreeTablePresenterindeterminateStepIncrease  ^oddPassage ifTrue: [ 40 ] ifFalse: [ 15 ]childrenBlock  ^[ self model buildChildren ]testSelectionStartsSelectingFirst  self assert: self presenter selectedItem equals: 10.  self assert: self adapter selectedIndexes equals: #(1)initializeWindow: aWindowPresenter  super initializeWindow: aWindowPresenter.  aWindowPresenter title: 'Recent versions of ' , rgMethod displayNamewhenIsResizableChangedDo: aBlock  self property: #isResizable whenChangedDo: aBlockhasContents: aBlock  hasContents := aBlockmessages: aCollection  messageList messages: aCollectionspacing: aNumber  spacing := aNumbervalue  ^slider valueitems: aList  self dropList items: aListdragEnabled  ^dragEnabledposition  ^positionaddConstraits: constraints toChild: childMorph  layout direction setRigidityOfNonExpandedMorph: childMorph.  ^childMorphadapt: aPresenter  widget := self buildWidgetWith: aPresenter.  aPresenter addDependent: widget.  self bindModel: aPresenter andWidget: widgetcolumns  ^tree columnsleftPanel  ^leftPanelcanTakeKeyboardFocus  ^falsebuildMenuBar  ^self newMenuBar addGroup: [:group |  group addItem: [:item |  item                 name: 'File';                 subMenu: self buildFileMenu ] ]selectedIndexes  self deprecated: 'Use the #selection object instead. This method assumes multiple selection' transformWith: '`@receiver selectedIndexes' -> '`@receiver selection selectedIndexes'.  ^self selection selectedIndexesisRedrawable  ^trueaddItemRight: aToolBarItem  aToolBarItem owner: self.  rightItems add: aToolBarItem.  self notifyPropertyChanged: #rightItemspageClass  ^SpDemoImagePresenteraddSpecialFields: elements  elements add: (DynamicEyeElement host: self object label: 'unicode' description: [ self objectAsUnicodeCodePoint ] value: [ self object codePoint ])visitCommand: aCmCommand  aCmCommand hasShortcutKey ifFalse: [ ^self ].  kmCategory addKeymapEntry: (KMKeymap shortcut: aCmCommand shortcutKey action: [ aCmCommand canBeExecuted ifTrue: [ aCmCommand execute ] ])columnInset: anInteger  columnInset value: anIntegerpresentersDo: aBlock  self basicPresenters valuesDo: aBlockinitializeWindow: aWindowPresenter  self flag: #TODOapplyTo: aMorph  self properties do: [:each |  each applyTo: aMorph ]enabled: aBoolean  testWhenSelectedPageChangedDo  | mock mock2 counter selected |  counter := 0.  mock := self mockPage.  mock2 := SpNotebookPage title: 'test' provider: [ SpButtonPresenter new ].  presenter whenSelectedPageChangedDo: [:page |  selected := page.        counter := counter + 1 ].  presenter addPage: mock.  presenter addPage: mock2.  presenter selectPageIndex: 2.  self assert: counter equals: 1.  self assert: selected equals: mock2testHasIcon  self deny: command hasIcon.  command iconName: #banana.  self assert: command hasIconwhenChangedDo: aBlock  self property: #selectedIndexes whenChangedDo: [ aBlock cull: self ]initialize  super initialize.  self     name: 'Rename';     description: 'Rename the selected contact.'ensureWidthPosition: aMorph in: aRect  | firstMorph |  self position ifNil: [ ^self ].  firstMorph := aMorph submorphs first.  firstMorph hResizing = #rigid ifFalse: [ firstMorph hResizing: #rigid ].  firstMorph privateBounds: (firstMorph bounds withWidth: (self widthPositionIn: aRect extent))shortcutCharacter  ^self shortcut ifNotNil: [:s |  s platformCharacter ]selected: aBoolean  selected value: aBooleantestVisitCommandThatCantBeRunWithHideStrategy  self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.  (CmBlockCommand new     name: 'c';     description: 'desc';     context: [ 41 ];     canBeExecutedBlock: [:x |  x = 42 ];     block: [:x |  42 ];     yourself) asSpecCommand beHiddenWhenCantBeRun acceptVisitor: menuBuilder.  self assert: menuBuilder menuPresenter defaultGroup menuItems isEmptyinitialize  textConverter := SourceMethodConverter new.  super initializewrappers  ^associationsWrapperToItem keysinspector: anEyeInspector  self basicInspector: anEyeInspector.  self pushHistoryselectionMode: aMode  selectionMode ifNotNil: [ selectionMode transferSubscriptionsTo: aMode ].  selectionMode := aModeopenWithSpecLayout: aSpec  self buildWithSpecLayout: aSpec.  self changed: #open with: #().  self allPresenters do: [:each |  each announceDisplayed ].  self updateTitlenumber2Input: anObject  number2Input := anObjecttestSelectItemOutsideRangeUnsetsSelectedIndex  presenter selectItem: 40.  self assert: presenter selection selectedIndex equals: 0cancelled: aBoolean  cancelled := aBooleanassertHasHeader: anAdapter  self waitUntilUIRedrawed.  self assert: (anAdapter widget instVarNamed: #showColumnHeaders)showColumnHeaders  showColumnHeaders := truetestSelectItemOutsideRangeHasNoSelectedPath  presenter selectItem: 4000.  self assert: presenter selection selectedPaths isEmptydynamicPresenter  ^dynamicPresenterwhenMenuHolderChanged: aBlock  self deprecated: 'Use #whenMenuHolderChangedDo: instead.' transformWith: '`@receiver whenMenuHolderChanged: `@statements' -> '`@receiver whenMenuHolderChangedDo: `@statements'.  self whenMenuHolderChangedDo: aBlockstyleSheet  ^self application styleSheettestSelectAbsentItemGivesEmptySelection  presenter selectItem: 4000.  self assert: presenter selection isEmptyadapterName  ^adapterNamelabelClickable  ^labelClickableHolder valuemorph: aMorph  morph := aMorphgetText  ^self model labelsetEditingModeFor: textArea  self hasSyntaxHighlight ifTrue: [ self setEditingModeFor: textArea withBehavior: self behavior ] ifFalse: [ super setEditingModeFor: textArea ]testSetSelectIndexRaisesSelectionChangeEventWithSelectedItem  | selectedElement |  presenter whenSelectionChangedDo: [:selection |  selectedElement := selection selectedItem ].  presenter selectIndex: 1.  self assert: selectedElement equals: 10doubleClickAction: aBlockClosure  self deprecated: 'Use whenActivatedDo: instead' transformWith: '`@receiver whenActivatedDo: `@argument' -> '`@receiver doubleClickAction: `@argument'.  self whenActivatedDo: [:sel |  aBlockClosure value: sel selectedItem ]testSetSortingBlockBeforeItems  | count |  count := 0.  presenter whenSortingBlockChangedDo: [:sortFunction |  count := count + 1 ].  presenter sortingBlock: [:each |  each label asNumber ] ascending.  presenter items: #(3 8 1 0).  self assert: count equals: 1.  self assert: (presenter model at: 1) label equals: '0'monthYearLabel  ^monthYearLabelstoringsIntoInstanceVariable  ^self systemNavigation browseAllStoresInto: self instVarName from: self hostClasspresenters  ^self model presenterspresenter: aPresenterClass configuredAs: twoArgumentsBlock  self presenterProvidedBy: [:modelObject |  aPresenterClass ] configuredAs: twoArgumentsBlockcontentArea: aTextOrPresenter  contentArea := aTextOrPresentersetText: text to: aWidget  aWidget setText: texttestSetSelectPathRaisesSelectionPathChangeEventWithSelectedPath  | selectedPath |  presenter selection whenChangedDo: [:selection |  selectedPath := selection ].  presenter selectPath: #(1 2).  self assert: selectedPath equals: #(1 2)selectDirectoryTitle: aString  ^UIManager default chooseDirectory: aString path: ''name  ^namegenders  ^#(male female)testHidePresenterHidesWidget  self presenter hide.  self deny: self adapter isVisiblelist1Menu  ^self newMenu     title: 'Context menu example';     addGroup: [:aGroup |  aGroup           addItem: [:anItem |  anItem                 name: 'Print in transcript';                 shortcut: $p meta;                 description: 'Print the selected class on Transcript';                 action: [ list1 selectedItem traceCr ] ];           addItem: [:anItem |  anItem                 name: 'Browse';                 iconName: #open;                 action: [ list1 selectedItem browse ] ];           addItem: [:anItem |  anItem                 name: 'Print infos';                 subMenu: (self newMenu addGroup: [:aSubGroup |  aSubGroup                             addItem: [:item |  item                                   name: 'Print number of methods';                                   action: [ list1 selectedItem methods size traceCr ] ];                             addItem: [:item |  item                                   name: 'Print number of variables';                                   action: [ list1 selectedItem instanceVariables size traceCr ] ] ]) ] ];     addGroup: [:aGroup |  aGroup           addItem: [:anItem |  anItem                 name: 'Item showing only if item a odd number of letters';                 visibleIf: [ list1 selectedItem printString size odd ];                 action: [ list1 selectedItem traceCr ] ];           addItem: [:anItem |  anItem                 name: 'Disabled in second group';                 disable;                 action: [ list1 selectedItem traceCr ] ];           addItem: [:anItem |  anItem                 name: 'Disabled if class begins with A';                 enabled: [ list1 selectedItem printString first ~= $A ];                 action: [ list1 selectedItem traceCr ] ] ]isMultipleSelection  ^truey  ^yallowMenuOnNoItem: aBoolean  allowMenuOnNoItem value: aBooleannewHeaderMorph  ^(self theme newRowIn: self theme for: {self tabSelectorMorph})     cellInset: 0;     cellPositioning: #bottomCenter;     borderWidth: 0testListBox  | dialog app listPresenter |  app := SpMockApplication new.  dialog := SpVersatileDialogPresenter newApplication: app.  listPresenter := dialog newList.  listPresenter items: #(one two three).  dialog contentArea: listPresenter.  dialog addButton: #ok text: 'OK' value: #ok condition: [ listPresenter selection isEmpty not ].  dialog addButton: #cancel text: 'Cancel' value: nil.  dialog mainIcon: (self iconNamed: #question).  dialog openModalWithSpec.  dialog withWindowDo: [:w |  w title: 'Confirmation' ].  dialog contentArea selection selectIndex: 2.  (dialog buttons at: #ok) click.  self assert: dialog result equals: #ok.  self assert: dialog contentArea selection selectedItem equals: #twosetUp  super setUp.  presenter := SpNumberInputFieldPresenter new.  adapter := self actualClass adapt: presenterrightItems  ^rightItemstestSubscribeToUnexistentPropertyRaisesError  self should: [ point property: #z whenChangedDo: [ self fail: 'This event shouldnt have been subscribed at all' ] ] raise: SlotNotFoundtitle  ^'OpenOnStringExample'aboutText: aString  aboutText := aStringinitialize  super initialize.  self initializeTSearchable.  showColumnHeaders := true.  columns := #().  isResizable := falseisSpLayout  ^truesetRightOffset: right for: windowBorderWidth borderWidth: widget  widget rightFraction = 1 ifTrue: [ right isZero ifTrue: [ widget rightOffset: windowBorderWidth negated ] ifFalse: [ widget rightOffset: right - self splitterWidth ] ]tearDown  window ifNotNil: [ window delete ].  super tearDowntestSelectMultipleItemAddsAllToSelectedIndexList  presenter selectItem: 10.  presenter selectItem: 30.  self assert: (presenter selection includesIndex: 1).  self assert: (presenter selection includesIndex: 3)newStatusBar  ^self instantiate: SpStatusBarPresenterrefreshShowColumnHeaders  self presenter isShowingColumnHeaders ifTrue: [ self widget           showColumnHeaders;           refresh ] ifFalse: [ self widget           hideColumnHeaders;           refresh ]model: anObject  model := anObjecttestListWithoutColumnsHasSingleColumn  self assert: self adapter columns size equals: 1initializeTestedInstance  presenter     addColumn: (SpStringTableColumn title: 'Value' evaluated: #printString);     hideColumnHeaders;     beMultipleSelection;     roots: #(1 2 3);     children: [:aNumber |  {(aNumber * 2) .         (aNumber * 3) .         (aNumber * 10)} ]setFocusOrder  self focusOrder     add: browseModel;     add: usersModel;     add: sendersModel;     add: implementorsModel;     add: versionModelresolveSymbol: aSymbol  ^Smalltalk at: aSymbolhAlign: anObject  hAlign := anObjectnotify: errorMessage at: position in: sourceCode  self changed: #notify:at:in: with: {errorMessage .         position .         sourceCode}displayBlock: aBlock  self deprecated: 'Please use #display: instead' transformWith: '`@receiver displayBlock: `@arg' -> '`@receiver display: `@arg'.  self dropList display: aBlockwhenFontChangedDo: aBlock  self property: #font whenChangedDo: aBlockinitializePresenters  x := self newTextInput.  y := self newTextInputimage: aForm  image := aFormconnectPresenters  self submitButton action: [ self submit ].  self restoreButton action: [ self restore ]testScrollDownToPosteriorIndexScrollsBottomToIndex  self flag: #pharo7.  SystemVersion current major < 8 ifTrue: [ self skip ].  presenter items: (1 to: 500).  presenter verticalAlignment desiredVisibleRow: 100.  self openInstance.  self assert: (presenter verticalAlignment lastVisibleRowIndex between: 100 and: 101)createRingMethodForRemovedSelector: aSelector inClass: aClass  | removalInfo method |  method := RGMethodDefinition class: aClass selector: aSelector.  removalInfo := (self selectedChangeSet changeRecorderFor: aClass) methodChanges at: aSelector ifAbsent: [ ^method ].  method sourcePointer: removalInfo methodInfoFromRemoval first.  ^methodinstVarToModelObjectDo: aBlock  self instVarToModelObject do: [:assoc |  aBlock value: assoc key value: assoc value ]activatesOnDoubleClick  ^activateOnSingleClick notsetRefreshedToTrue  canBeRefreshed := trueclearSelection  selection := #()selectedProtocol  ^protocolList selection selectedItemwhenBehaviorChangedDo: aBlock  self property: #behavior whenChangedDo: aBlockselector  ^selectorbadge: aString  badge := aStringinitialize  self class initializeSlots: self.  super initialize.  desiredVisibleRow := 1whenSelectedChanged: aBlock  self deprecated: 'Use #whenSelectedChangedDo: instead.' transformWith: '`@receiver whenSelectedChanged: `@statements' -> '`@receiver whenSelectedChangedDo: `@statements'.  self whenSelectedChangedDo: aBlocklistItems  ^self getList collect: [:e |  e model ]isPresenterSymbol: aSymbol  self flag: #todo.  ^#(#model #presenter) anySatisfy: [:symbol |  symbol = aSymbol ]hasWidget: aMorph  ^self allMorphs includes: aMorphoddRowColor  ^oddRowColor valueopenAt: aPoint  self widgetDo: [:w |  w invokeAt: aPoint + (2 @ 7) in: self currentWorld allowKeyboard: true ]initializePresenters  dynamicPresenter := self newNullPresenter.  differentCardsCountSlider := self newSlider.  differentCardsCountSlider     min: 1;     max: 50;     label: '# cards';     whenValueChangedDo: [ self rebuildDynamicPresenter ];     value: 25nameTextInput: anObject  nameTextInput := anObjecttestInitializeMethodListShouldBeSelectTheFistItem  self assert: biChooseMethod methodList selection selectedIndex equals: 1items  ^self model collectionborderWidth  ^borderWidth ifNil: [ self class defaultBorderWidth ]searchMatching: aBlock  searchBlock := aBlock.  self enableSearchtabSelected: aTab  self model selectedTab: aTab modeltestRemovePageAt  | page |  presenter addPage: self mockPage.  page := SpNotebookPage title: 'test' provider: [ SpButtonPresenter new ].  presenter addPage: page.  self assert: presenter pages size equals: 2.  presenter removePageAt: 1.  self assertCollection: presenter pages hasSameElements: {page}ghostText: aText  self deprecated: 'This API is too tight to Morph. Use #placeholder: instead.' transformWith: '`@receiver ghostText: `@statement' -> '`@receiver placeholder: `@statement'.  self placeholder: aTextnotEmpty  ^self isEmpty notwrapItem: anObject  ^self model wrapItem: anObjectselectItems: aCollection  self selectIndexes: (aCollection collect: [:anItem |  self indexOfItem: anItem ])cellColumn: column row: rowIndex  | cell builder |  cell := FTCellMorph new.  builder := SpMorphicTableCellBuilder on: self.  builder     cell: cell;     rowIndex: rowIndex;     visit: column model.  ^celltopologicSort  ^topologySorticon  ^icontestMaxLengthTruncatesText  presenter maxLength: 10.  presenter text: '1234567890 ---'.  self assert: presenter text equals: '1234567890'addPaneVSplitterBetween: leftMorphs and: rightMorphs  | targetX fixed bottomFraction topFrame bottomFrame sorted morph leftGroup rightGroup splitter offset |  leftMorphs ifEmpty: [ ^self ].  targetX := leftMorphs first layoutFrame rightFraction.  fixed := leftMorphs select: [:m |  m layoutFrame leftFraction = m layoutFrame rightFraction ].  sorted := ((leftMorphs reject: [:m |  m layoutFrame leftFraction = m layoutFrame rightFraction ]) asSortedCollection: [:a :b |  a layoutFrame bottomFraction = b layoutFrame bottomFraction ifTrue: [ a layoutFrame topFraction <= b layoutFrame topFraction ] ifFalse: [ a layoutFrame bottomFraction <= b layoutFrame bottomFraction ] ]) readStream.  sorted contents ifEmpty: [ ^fixed ].  leftGroup := OrderedCollection new.  bottomFraction := sorted contents first layoutFrame topFraction.  [ sorted atEnd or: [ morph := sorted next.        morph layoutFrame topFraction ~= bottomFraction and: [ morph layoutFrame bottomFraction ~= bottomFraction ] ] ] whileFalse: [ leftGroup add: morph.        bottomFraction := morph layoutFrame bottomFraction ].  topFrame := leftGroup first layoutFrame.  bottomFrame := leftGroup last layoutFrame.  rightGroup := (rightMorphs reject: [:m |  m layoutFrame leftFraction = m layoutFrame rightFraction ]) select: [:m |  m layoutFrame topFraction between: topFrame topFraction and: bottomFrame bottomFraction ].  offset := (leftGroup collect: [:m |  m layoutFrame rightOffset ]) max.  splitter := ProportionalSplitterMorph new.  splitter layoutFrame: ((targetX @ topFrame topFraction corner: targetX @ bottomFrame bottomFraction) asLayoutFrame           leftOffset: offset;           topOffset: topFrame topOffset;           rightOffset: 4 + offset;           bottomOffset: bottomFrame bottomOffset).  leftGroup := leftGroup , fixed.  leftGroup do: [:m |  splitter addLeftOrTop: m ].  rightGroup do: [:m |  splitter addRightOrBottom: m ].  self addMorphBack: splitter.  ^leftGroupcheckboxDisabled: anObject  checkboxDisabled := anObjectselectionChanged: ann  | diff |  self presenter selection isMultipleSelection ifTrue: [ self presenter selection selectIndexes: (ann newSelectedIndexes reject: [:e |  e = 0 ]) ].  self presenter selection isMultipleSelection ifFalse: [ self presenter selection selectIndex: (ann newSelectedIndexes ifNotEmpty: [:indexes |  indexes first ] ifEmpty: [ 0 ]) ].  diff := ann newSelectedIndexes difference: ann oldSelectedIndexes.  (diff notEmpty and: [ self presenter activatesOnSingleClick ]) ifTrue: [ self presenter doActivateAtIndex: diff last ].  ann newSelectedIndexes ifNotEmpty: [ ^self ].  self presenter selection unselectAllnewNotebook  ^self instantiate: SpNotebookPresenterincreaseValueOf: aTextMorph  aTextMorph setText: (self increasedValueFrom: aTextMorph getText)applyMenuModel: aMenuModel  aMenuModel menuGroups do: [:group |  group menuItems do: [:item |  item shortcut ifNotNil: [:shortcut |  self bindKeyCombination: shortcut toAction: [ item performMenuActionWith: #() ] ].              item subMenu ifNotNil: [:subMenu |  subMenu applyTo: self ] ] ]initialize  super initialize.  children := [ self container childrenFor: self content ] asValueHolder.  hasChildren := [ self container hasChildrenFor: self content ] asValueHolder.  content := nil asValueHolder.  icon := nil asValueHolder.  container := nil asValueHolder.  matchTokenFilter := [:aFilter |  false ] asValueHolder.  parentNode := nil asValueHolder.  childNodeClass := self class asValueHolder.  selected := false asValueHolder.  lastClicked := false asValueHolder.  mouseDownAction := [:event |   ] asValueHolder.  hasContentToShow := false asValueHolder.  isExpanded := false asValueHolder.  selected whenChangedDo: [:aBoolean |  self changed: #selected: with: {aBoolean} ].  isExpanded whenChangedDo: [:aBoolean |  self changed: #isExpanded: with: {aBoolean} ]testShouldAccept  presenter     beInteger;     minimum: 90;     maximum: 120.  self assert: (adapter shouldAccept: '').  self assert: (adapter shouldAccept: '100').  self deny: (adapter shouldAccept: 'string').  self deny: (adapter shouldAccept: '10string')initialize  super initialize.  titleHolder := self class defaultTitle.  isClosed := true.  isResizeable := true.  centered := false.  askOkToClose := true.  self property: #titleHolder whenChangedDo: [:m |  self changed: #title: with: {m} ].  self property: #centered whenChangedDo: [:m |  self changed: #centered with: #() ]action: aBlock  actionBlock := aBlockhasChildren  ^hasChildren valuehasWindow  ^self root isWindowPresenteracceptOnCR: aBoolean  ^self input acceptOnCR: aBooleanconstraintsClass  ^SpGridConstraintstoken: anObject  token := anObjectnewPresenterFor: aModel  ^newPresenterBlock value: aModelprepareForFilteredDataSourceWith: items  model := itemsconstraintsClass  ^SpBoxConstraintsbottomOffset: aNumber  ^0headerFont  ^headerFont valuewhenDisplayBlockChanged: aBlock  tree whenDisplayBlockChanged: aBlockrowPositions  ^rowPositionsheaderFont  ^self model headerFontselectedClassOrMetaClass  ^self behaviortestUnselectSelectedIndexRemovesSelection  presenter     selectIndex: 1;     unselectIndex: 1.  self assert: presenter selection isEmptyname  ^nameapplyStyle: aMorph  sortingBlock: aBlock  listModel sortingBlock: aBlockselectedItem  selection ifEmpty: [ ^nil ].  ^presenter itemAtPath: selectionusePreviousInspectorType  self inspectorType: self previousInspectorTypeinitialize  model := AbstractTool new.  super initializeinitializeShortcuts  self shortCuts keysAndValuesDo: [:key :value |  self list bindKeyCombination: key toAction: value ]borderWidth: anInteger  borderWidth := anIntegertestOpenWindowWithDifferentApplicationDoesNotAddItToWindowCollection  | secondApplication presenterInSecondApplication windowsBefore |  secondApplication := SpApplication new.  presenterInSecondApplication := secondApplication newPresenter: SpButtonPresenter.  windowsBefore := application windows copy.  self should: [ application open: presenterInSecondApplication withSpecLayout: SpButtonPresenter defaultSpec ] raise: SpInvalidApplicationError.  self assert: application windows equals: windowsBeforeinitializeTestedInstance  presenter drawBlock: [  ].  presenter surfaceExtent: 800 @ 600resizerWidth  ^resizerWidth valuehelpText  ^self widget balloonTextextentOrDefault  ^extent ifNil: [ 0 @ 0 ]icon: anIcon  ^self button icon: anIconunselectAll  self selectIndexes: #()childrenItems: aCollection  childrenItems := aCollectionchangeSelection: selection from: aPresenter  | selectedPresenterIndex |  selectedPresenterIndex := self presenters indexOf: aPresenter.  columnsWillChangeBlock ifNotNil: [ columnsWillChangeBlock cull: selectedPresenterIndex ].  self resetTo: selectedPresenterIndex.  self pushModel: selectiondisableSearch  searchEnabled := falseactForSpec  self flag: #TODOselectedItems  ^self selectedItem ifNotNil: [:anItem |  {anItem} ] ifNil: [ #() ]close  backdropMorph ifNotNil: #delete.  backdropMorph := nilproperty: aName rawValue: anObject  (self observablePropertyNamed: aName) rawValue: anObjectlayout  | main content subLayout subLayout2 options |  main := SpBoxLayout newVertical.  subLayout := SpBoxLayout newHorizontal.  self add: #element11 to: subLayout.  self add: #element12 to: subLayout.  subLayout2 := SpBoxLayout newHorizontal.  self add: #element21 to: subLayout2.  self add: #element22 to: subLayout2.  content := SpBoxLayout newVertical.  self add: subLayout properties: 'Row1' to: content.  self add: subLayout2 properties: 'Row2' to: content.  main add: content.  self flag: #todo.  options := SpBoxLayout newVertical.  #('Row1' 'Row2' 'element11' 'element12' 'element21' 'element22') doWithIndex: [:ele :ind |  options add: (SpBoxLayout newVertical                 add: ele capitalized;                 add: (SpBoxLayout newHorizontal                       add: (self presenterAt: ele , 'Expanded');                       add: (self presenterAt: ele , 'Filled');                       yourself);                 add: (SpBoxLayout newHorizontal                       add: 'Padding';                       add: (self presenterAt: ele , 'Padding');                       yourself);                 yourself) ].  main add: options.  ^maintestSelectMultiplePathsAddsAllToSelectedItemList  presenter     selectPath: #(1 2);     selectPath: #(2 2).  self assert: (presenter selection includesItem: 3).  self assert: (presenter selection includesItem: 6)configureDropList: aSpDropListMorph item: aSpDropListPresenter  self flag: 'TODO: maybe customize the drop list to have a better look''n feel'sortFunction  ^self model sortFunctioninitialize  super initialize.  instVarCount := 0.  nullPresentersInstVarNames := #()moreOptionsButton  ^moreOptionsButtontestAddNoPresenterToComponentListDoesNotRaiseEvent  | raised |  raised := false.  presenter whenPresentersChangedDo: [ raised := true ].  self deny: raisedtestModelSettingObjectToModel  | point model presenter |  model := SpTestingPointModel x: 1 y: 2.  point := 40 @ 54.  presenter := SpTestingPresenterWithModel on: model.  self assert: presenter announcingObject isSpAnnouncingObject.  self deny: presenter announcingObject isValueHolder.  self deny: point isSpAnnouncingObject.  self deny: point isValueHolder.  presenter model: point.  self assert: presenter announcingObject isSpAnnouncingObject.  self assert: presenter announcingObject isValueHolder.  self assert: presenter model == point.  self deny: presenter announcingObject == model.  self assert: presenter announcingObject announcer numberOfSubscriptions > 0testSetSelectItemRaisesSelectionPathChangeEventWithSelectedPath  | selectedPath |  presenter selection whenChangedDo: [:selection |  selectedPath := selection ].  presenter selectItem: 10.  self assert: selectedPath equals: #(1 3)pendingText  self withAdapterDo: [:adpt |  adpt isMorphicAdapter ifTrue: [ ^adpt pendingText ] ].  ^self getTextchildrenFor: anItem  ^self childrenBlock cull: anItem cull: selfdisplayForItem: anItem  ^self display cull: anItem model cull: anItemmin  ^self presenter mintestShowingColumnDisplayColumn  self presenter showColumnHeaders.  backendForTest assertHasHeader: self adapterinitialExtent  ^self model initialExtentroots  ^self childrenForObject: self objectminExtent: anObject  minExtent := anObjectinstVarNamesFrom: aDynamicPresentersListBuilder  | names streams |  names := super instVarNamesFrom: aDynamicPresentersListBuilder.  streams := names groupsOf: names size / self columnsCount atATimeCollect: [:a |  a readStream ].  ^OrderedCollection streamContents: [:s |  [ streams noneSatisfy: #atEnd ] whileTrue: [ streams do: [:subS |  s nextPut: subS next ] ] ]refreshWidgetSelection  | rowIndexes |  rowIndexes := self presenter selection selectedIndexes.  rowIndexes = self widget selectedIndexes ifTrue: [ ^self ].  rowIndexes isEmpty ifTrue: [ self widget basicSelectIndexes: #() ] ifFalse: [ self widget basicSelectIndexes: rowIndexes ].  self refreshListtestShowColumnHeadersInPresenterShowsThemInWidget  SystemVersion current major = 7 ifTrue: [ ^self skip ].  self presenter showColumnHeaders.  self assert: self adapter isShowColumnHeaderswhenCanDeselectByClickChanged: aBlock  self deprecated: 'Use #whenCanDeselectByClickChangedDo: instead.' transformWith: '`@receiver whenCanDeselectByClickChanged: `@statements' -> '`@receiver whenCanDeselectByClickChangedDo: `@statements'.  self whenCanDeselectByClickChangedDo: aBlockleftOffset  ^0visible: aBoolean  widget: anObject  widget := anObjectinitializeWidgets  super initializeWidgets.  morphPresenter := self newMorph.  morphPresenter morph: (PanelMorph new           changeProportionalLayout;           vResizing: #spaceFill;           hResizing: #spaceFill;           yourself)windowIcon  ^windowIcontestFromSpecSubMenu  | root subMenuRoot parent subMenu |  root := PluggableMenuSpec withModel: nil.  parent := root add: 'parent'.  subMenuRoot := PluggableMenuSpec withModel: nil.  subMenuRoot add: 'child'.  parent subMenu: subMenuRoot.  presenter fromSpec: root.  subMenu := presenter menuGroups first menuItems first subMenu.  self assert: subMenu menuGroups size equals: 1.  self assert: subMenu menuGroups first menuItems size equals: 1.  self assert: subMenu menuGroups first menuItems first name equals: 'child'.  self openInstancetestRemovePageAt  presenter addPage: (SpNotebookPage title: 'Mock3' provider: [ SpLabelPresenter new ]).  self assert: self adapter numberOfTabs equals: 3.  presenter removePageAt: 2.  self assert: self adapter numberOfTabs equals: 2.  self assert: self adapter selectedPageName equals: 'Mock'closeOnBackdropClick: aBoolean  closeOnBackdropClick := aBooleanabstractAdapterClass  ^SpAbstractMorphicAdaptercolumns  ^columns valueaccessorCode  self subclassResponsibilityfileOutSelector: selector from: aClass  aClass fileOutMethod: selectortestSelectPathsThenSelectInvalidPathKeepsPaths  | paths |  paths := {#(1 3) .   #(2 2)}.  presenter     selectPaths: paths;     selectPaths: {#(50) .         #(60 2)}.  self assert: (presenter selection includesPaths: paths)testWhenIconChangedDo  presenter iconName: #glamorousCancel.  presenter whenLabelChangedDo: [:new :old |  self assert: new equals: (self iconNamed: #glamorousCancel) ].  self assert: presenter icon equals: (self iconNamed: #glamorousCancel).  self openInstance.  presenter iconName: #pharo.  self assert: presenter icon equals: (self iconNamed: #pharo)testUnselectPresenterIndexUnselectsIndexInWidget  presenter     selectIndex: 1;     unselectIndex: 1.  self assert: self adapter selectedIndexes isEmptyinitializeWindow: aWindowPresenter  aWindowPresenter     title: 'Box layout example';     initialExtent: 600 @ 800showSourceWithConverter: aConverter  sourcePresenter := self newCode.  isShowingDiff := false.  self needRebuild: false.  self buildWithSpec.  self textConverter: aConverter.  sourcePresenter acceptBlock: [:text :notifyer |  (self accept: text notifying: notifyer) notNil ].  sourcePresenter behavior: self selectedMessage methodClass.  messageList selectIndex: messageList selectedIndexopen: aPresenter withSpecLayout: aSpecLayout using: aWindowClass  | window |  self validateApplicationOfPresenter: aPresenter.  window := aWindowClass presenter: aPresenter.  self windows add: window.  window openWithSpecLayout: aSpecLayout.  ^windowbePassword  self bePassword: truetestSelectMultipleItemsAddsAllToSelectedItemList  presenter selectItem: 10.  presenter selectItem: 30.  self assert: (presenter selection includesItem: 10).  self assert: (presenter selection includesItem: 30)externalIndex  ^externalIndexisHomogeneous  ^homogeneousbrowseValueClassHierarchy  ^self valueClass browseHierarchytestClickingRadio3DeselectsRadio1  self openInstance.  self presenter radio3 adapter clicked.  self deny: self presenter radio1 stateinitialize  super initialize.  children := OrderedDictionary newresetAllPageContents  self pages do: #resetContenthasToolbar  ^self toolBar notNil and: [ self toolBar notEmpty ]testSetSelectPathRaisesSelectionItemChangeEventWithSelectedItem  | selectedItem |  presenter whenSelectionChangedDo: [:selection |  selectedItem := selection selectedItem ].  presenter selectPath: #(1 3).  self assert: selectedItem equals: 10scrollValue  ^scrollValuelayoutMorph: aMorph staringAt: originPoint withComputation: computation  | constraints pos extent |  constraints := aMorph valueOfProperty: #gridConstraints.  pos := originPoint + (computation positionAt: constraints position).  aMorph vResizing: (self resizingSyle: self isRowHomogeneous).  aMorph hResizing: (self resizingSyle: self isColumnHomogeneous).  (layout rowConstraintsAt: constraints position y) ifNotNil: [:c |  c expand ifNotNil: [:expand |  aMorph vResizing: (self resizingSyle: expand) ] ].  (layout columnConstraintsAt: constraints position x) ifNotNil: [:c |  c expand ifNotNil: [:expand |  aMorph hResizing: (self resizingSyle: expand) ] ].  extent := (aMorph hResizing = #spaceFill and: [ aMorph vResizing = #spaceFill ]) ifTrue: [ computation cellExtentAt: constraints position ] ifFalse: [ self calculateExtentFor: aMorph constraint: constraints computation: computation ].  aMorph bounds: (pos extent: extent)buttonDisabled: anObject  buttonDisabled := anObjectclassToTest  ^SpComponentListPresenterclassToTest  ^SpLabelledSliderInputstepTime  ^20registerToAnnouncements  SystemAnnouncer uniqueInstance weak     when: MethodAdded send: #methodAdded: to: self;     when: MethodModified send: #methodModified: to: self;     when: MethodRecategorized send: #methodRecategorized: to: self;     when: MethodRemoved send: #methodRemoved: to: self;     when: ClassRenamed send: #classRenamed: to: selftreeModel  ^treeModelspan: anObject  span := anObjectcanDeselectByClick: aBoolean  self deprecated: 'This option is removed in Spec 2'initialize  isShowingDiff := false.  super initializeinitialize  super initialize.  tabs := OrderedCollection new asValueHolder.  tabSelectedAction := [  ] asValueHolder.  selectedTab := nil asValueHolder.  self myDependents: WeakSet new.  tabs whenChangedDo: [:new |  self widget ifNotNil: [:w |  w tabs: self getTabs value ] ].  selectedTab whenChangedDo: [:newTab |  tabSelectedAction value cull: newTab cull: self ]selectedElementDo: aBlock  self selectedElement ifNotNil: aBlockinitializePresenters  button := self newButton.  bottom := self newList.  button     label: 'Change';     action: [ self change ];     state: false.  bottom items: (1 to: 10) asOrderedCollectiontestMaxLengthTruncatesAlreadyTypedText  presenter text: '1234567890 ---'.  presenter maxLength: 10.  self assert: presenter text equals: '1234567890'labelOnRight  ^self widgetDo: [:w |  w listDirection: #rightToLeft ]item  ^self model contentconnectPresenters  messageList     whenSelectionChangedDo: [:selection |  [:item |  self selectItem: item ] cull: selection selectedItem ];     whenModelChangedDo: [ self updateTitle ].  textModel acceptBlock: [:text :notifyer |  (self accept: text notifying: notifyer) notNil ]testColor  | random red green blue |  random := Random new.  red := random nextInt: 255.  green := random nextInt: 255.  blue := random nextInt: 255.  presenter redSlider value: red.  presenter greenSlider value: green.  presenter blueSlider value: blue.  self assert: presenter color equals: (Color r: red g: green b: blue range: 255)hash  ^super hash bitXor: instVarName hashsurnameTextInput  ^surnameTextInputtestRemovePage  | page |  presenter addPage: self mockPage.  page := SpNotebookPage title: 'test' provider: [ SpButtonPresenter new ].  presenter addPage: page.  self assert: presenter pages size equals: 2.  presenter removePage: page.  self assert: presenter pages size equals: 1add: modelGetter withSpec: aSymbol  self add: modelGetter withSpec: aSymbol origin: 0 @ 0 corner: 1 @ 1variants  | variants defaultInspectorClass |  variants := OrderedCollection new.  defaultInspectorClass := self object class inspectorClass.  variants add: defaultInspectorClass.  defaultInspectorClass = Object inspectorClass ifFalse: [ variants add: EyeBasicInspector ].  variants add: EyeTreeInspector.  variants addAll: self object class additionalInspectorClasses.  ^variantsnewDataSource  ^SpMorphicTableDataSource new     model: self model;     yourselflist2  ^list2doubleClickAtPath: aPath  self selectPath: aPath.  activateOnSingleClick ifTrue: [ ^self ].  self doActivateAtPath: aPathroots  ^self childrenForObject: self objectinitialize  super initialize.  self initializeTSearchable.  self withScrollBars.  activationBlock := [  ].  showColumnHeaders := true.  columns := #().  isResizable := false.  childrenBlock := [:item |  #() ].  roots := #().  self beSingleSelection.  self activateOnDoubleClick.  self registerEventslabel  ^widget contentswhenAcceptBlockChangedDo: aBlock  self property: #actionToPerform whenChangedDo: aBlockclassMenuFrom: sourcePanel to: destinationPanel  ^sourcePanel classMenu     addGroup: [:aGroup |  aGroup           addItem: [:anItem |  anItem                 name: 'Copy class to the other change set';                 action: [ self copyClassFrom: sourcePanel to: destinationPanel ] ];           addItem: [:anItem |  anItem                 name: 'Move class to the other change set';                 action: [ self moveClassFrom: sourcePanel to: destinationPanel ] ] ];     yourselftext  ^texttestHideColumnHeadersDoesNotShowHeaders  presenter hideColumnHeaders.  self deny: presenter isShowingColumnHeaderscommands  ^commandsselectedMessage  ^nilbrowseSelectedObjectClassHierarchy  self selectedObjectDo: [:anObject |  anObject class browseHierarchy ]observablePropertyNamed: aName  | slot |  slot := self class slotNamed: aName.  slot isObservableSlot ifFalse: [ SpNonObservableSlotError signal: aName ].  ^slot rawRead: selftestActivationWithoutActivationBlockDoesNothing  | activatedItem |  activatedItem := nil.  presenter activateOnSingleClick.  presenter clickAtIndex: 1.  self assert: activatedItem equals: nilmodel  ^modelperformNextSelectorAndIncrementIndex  | args aSelector |  aSelector := arrayToInterpret at: index.  self assert: aSelector isArray not description: 'Before there was an #ifTrue:ifFalse: on `aSelector isArray` but it seems that the aSelector could never be an Array. If one day we have an array here, please report the problem and link it to https://github.com/pharo-spec/Spec/issues/60'.  aSelector := aSelector asSymbol.  args := (arrayToInterpret copyFrom: index + 1 to: index + aSelector numArgs) collect: [:each |  self class interpretASpec: each presenter: self presenter ].  index := index + aSelector numArgs + 1.  ^self actionToPerformWithSelector: aSelector arguments: argschildrenBlock: aBlock  childrenBlockHolder value: aBlockinitialize  wrapHolder := [:i |  i printString ] asValueHolder.  pickedItemsHolder := OrderedCollection new asValueHolder.  associationsWrapperToItem := Dictionary new asValueHolder.  associationsItemToWrapper := Dictionary new asValueHolder.  associationsIndexToWrapper := Dictionary new asValueHolder.  labelClickableHolder := true asValueHolder.  defaultValueHolder := false asValueHolder.  blockToPerformOnWrappers := [:wrapper |   ] asValueHolder.  super initializeheaderLabel  ^self model headerLabelsetIndex: anIndex  self dropList setIndex: anIndexwantsSteps  ^truewhenColumnsWillChangeDo: aBlock  columnsWillChangeBlock := aBlockselectedItem: anItem  self deprecated: 'Use #selectItem: instead' transformWith: '`@receiver selectedItem: `@arg' -> '`@receiver selectItem: `@arg'.  self selectItem: anIteminitialize  super initialize.  self bePlacedAtStartwidget  ^widgetpendingText: aText  self withAdapterDo: [:adpt |  adpt isMorphicAdapter ifTrue: [ ^adpt pendingText: aText ] ].  self text: aTextselectEntity  ^selectEntitydaysButtons  ^daysButtons, joinStyle  ^self class new     styles: self styles , joinStyle styles;     yourselftestUnselectPresenterItemUnselectsIndexInWidget  presenter     selectItem: 20;     unselectItem: 20.  self assert: self adapter selectedIndexes isEmptyisResizable: aBoolean  isResizable := aBooleansetFocus  self focusOrder     add: button1;     add: button2;     add: button3selectAdd  self widgetDo: [:w |  w selectAll ]moreOptionsArea  ^moreOptionsAreabuttonHighlighted: anObject  buttonHighlighted := anObjectconnectPresenters  minus action: [ | currentValue |        currentValue := text label asInteger.        text label: (currentValue - 1) asString ].  plus action: [ | currentValue |        currentValue := text label asInteger.        text label: (currentValue + 1) asString ]initializeTestedInstance  presenter content: SpTestingPresenterextent  ^self subclassResponsibilitytestInitialStatus  | layout |  layout := SpGridLayout new.  self assert: layout isColumnHomogeneous.  self assert: layout isRowHomogeneous.  self assert: layout columnSpacing equals: 10.  self assert: layout rowSpacing equals: 5.  self assert: layout borderWidth equals: 20title  ^'Dynamic Examples'menuPresenter: anObject  menuPresenter := anObjectrootNodes  ^rootNodes ifNil: [ rootNodes := super rootNodes ]addFocusRotationKeyBindings  ^super addFocusRotationKeyBindingscontextMenu: aMenuPresenter  listModel contextMenu: aMenuPresenteradapterName  ^#OverlayAdapterregisterEvents  super registerEvents.  self property: #autoDeselect whenChangedDo: [:aBoolean |  self changed: #autoDeselect: with: {aBoolean} ].  self whenDisplayBlockChangedDo: [ self withAdapterDo: #refreshWidgetList ].  self property: #headerTitle whenChangedDo: [ self withAdapterDo: #refreshWidgetHeaderTitle ]beVerticalAlignmentCenter  self vAlign: SpGridAlignment centeradd: aWidget  self subclassResponsibilityisRunningInUIProcess  ^UIManager default uiProcess == Processor activeProcesstitle  ^self inspector titlewithoutScrollBars  wrapScrollBars := falsenumber1Input: anObject  number1Input := anObjecttestClickOnPage  self adapter clickTab: 2.  self assert: self adapter selectedPageName equals: 'Mock2'isDisplayModeBoth  ^self displayMode = SpToolBarDisplayMode modeIconAndLabelplus  ^pluswhenFilteringBlockChanged: aBlock  self deprecated: 'Use #whenFilteringBlockChangedDo: instead.' transformWith: '`@receiver whenFilteringBlockChanged: `@statements' -> '`@receiver whenFilteringBlockChangedDo: `@statements'.  self whenFilteringBlockChangedDo: aBlockisShowingColumnHeaders  ^showColumnHeadersconstraintsClass  ^self subclassResponsibilitywhenSelectionIndexChanged: aBlock  listPresenter whenSelectionIndexChanged: aBlockaccessorCode  ^'(self array at: ' , self index asString , ')'sortedKeys  ^[ [ self object keys sort ] on: Error do: [ self object keys ] ] on: Error do: [ #() ]testSelectPathsAddsPathsToSelectedPathList  | paths |  paths := {#(1 2) .   #(2 2)}.  presenter selectPaths: paths.  self assert: (presenter selection includesPaths: paths)items: aList  ^self dropList items: aListbeNotResizable  self isResizable: falsesetBalloonText: aString  self widget ifNotNil: [:w |  w setBalloonText: aString ]registerForChanges  self property: #method whenChangedDo: [:contents |  | boolean |        boolean := contents ifNil: [ false ] ifNotNil: [ true ].        browseModel state: boolean.        usersModel state: boolean.        sendersModel state: boolean.        versionModel state: boolean.        implementorsModel state: boolean ]whenClosedDo: aBlock  self property: #isClosed whenChangedDo: [:value |  value ifTrue: [ aBlock value ] ]testDynamicBuild  | model widget1 widget2 widget3 |  model := SpTestingPresenter new.  model openWithSpec close.  widget1 := model list adapter.  model openWithSpec close.  widget2 := model list adapter.  self deny: widget1 identicalTo: widget2.  model list needRebuild: false.  model needRebuild: false.  model openWithSpec close.  widget3 := model list adapter.  self assert: widget2 identicalTo: widget3.  self assert: model needRebuilddisplayMode: aDisplayMode  displayMode ifNotNil: [ self removeStyle: displayMode styleName ].  displayMode := aDisplayMode.  self addStyle: displayMode styleNamewhenValueChangedDo: aBlock  self sliderInput whenValueChangedDo: aBlockfilterField  ^filterFieldtestUnselectAllRaisesSelectionEventOnce  | events |  events := 0.  presenter selectIndex: 1.  presenter whenSelectionChangedDo: [:selection |  events := events + 1 ].  presenter unselectAll.  self assert: events equals: 1removeSubWidgets  self widgetDo: [:w |  w removeAllMorphs ]addPage: aPage  aPage owner: self.  pagesHolder add: aPagesetSelectedChangeSet: aChangeSet  ^changesListPresenter setSelectedItem: aChangeSettimeline: aTimeline  self flag: #comment.  timeline := aTimeline.  timeline whenTickDo: [:tick |  self updateModelToMoment: tick ]askBeforeChanging: aBoolean  askBeforeChanging := aBooleantoolBar: aToolbarPresenter  aToolbarPresenter ifNotNil: [ aToolbarPresenter owner: self ].  ^toolBar := aToolbarPresentertestUpdateModelWithValueHolder  | aPoint aValueHolder presenter anAnnouncer |  aPoint := 40 @ 54.  aValueHolder := NewValueHolder value: aPoint.  self assert: aValueHolder value == aPoint.  anAnnouncer := aValueHolder announcer.  self assert: aValueHolder announcer subscriptions subscriptions size equals: 0.  presenter := SpTestingPresenterWithModel on: aValueHolder.  self assert: anAnnouncer == aValueHolder announcer.  self assert: presenter x text equals: aPoint x asString.  self assert: presenter y text equals: aPoint y asString.  aPoint setX: 1 setY: 2.  self assert: aValueHolder value == aPoint.  aValueHolder valueChanged.  self assert: anAnnouncer == aValueHolder announcer.  self assert: presenter x text equals: aPoint x asString.  self assert: presenter y text equals: aPoint y asStringwhenIsExpandedChangedDo: aBlock  isExpanded whenChangedDo: aBlocktakeKeyboardFocus: aPresenter  aPresenter takeKeyboardFocus.  self waitUntilUIRedrawedtestSelectPathOutsideRangeUnsetsSelectedItem  presenter selectPath: {4}.  self assert: presenter selection selectedItem equals: nilname  ^nameupdateTitle  self changed: #title: with: {self title}downButton  ^downButtontestMethodListContentWhenClassSideIsSelected  biChooseMethod radioButtonClassSide click.  biChooseMethod packageList selectItem: SpMethodChooserMockClass package.  biChooseMethod classList selectItem: SpMethodChooserMockClass.  self denyEmpty: biChooseMethod methodList items.  self assert: biChooseMethod methodList selection selectedIndex equals: 1.  self assertCollection: SpMethodChooserMockClass class methods hasSameElements: biChooseMethod methodList itemsvalue  ^self host at: self indextestModelSettingModelToModel  | model model2 presenter |  model := SpTestingPointModel x: 1 y: 2.  model2 := SpTestingPointModel x: 4 y: 5.  presenter := SpTestingPresenterWithModel on: model.  self assert: presenter announcingObject isSpAnnouncingObject.  self deny: presenter announcingObject isValueHolder.  self assert: model2 isSpAnnouncingObject.  self deny: model2 isValueHolder.  presenter model: model2.  self assert: presenter announcingObject isSpAnnouncingObject.  self deny: presenter announcingObject isValueHolder.  self assert: presenter announcingObject == model2.  self assert: presenter announcingObject announcer numberOfSubscriptions > 0testwhenChangedDo  | numberOfChanges |  numberOfChanges := 0.  presenter whenChangedDo: [ numberOfChanges := numberOfChanges + 1 ].  presenter redSlider value: 66.  presenter greenSlider value: 17.  presenter blueSlider value: 200.  self assert: numberOfChanges equals: 3onDateChosen: aChoseDate  aChoseDate calendar delete.  self date: aChoseDate dateobservablePropertyNamed: aName  | slot |  slot := self class slotNamed: aName.  slot isObservableSlot ifFalse: [ SpNonObservableSlotError signal: aName ].  ^slot rawRead: selfpageClass  ^SpDemoCheckboxesPresentertestSubscriptionsAreTransfered  self subclassResponsibilityrow: aNumber withConstraints: aBlock  | constraints |  constraints := SpGridAxisConstraints new.  aBlock value: constraints.  rowConstraints at: aNumber put: constraintsnewSlider  ^self instantiate: SpSliderPresenteraddPadding: aNumber toMorph: aMorph  aNumber = 0 ifTrue: [ ^aMorph ].  ^layout direction addPadding: aNumber toMorph: aMorph into: selfobservablePropertyNamed: aName  | slot |  slot := self class slotNamed: aName.  slot isObservableSlot ifFalse: [ SpNonObservableSlotError signal: aName ].  ^slot rawRead: selfaddAllColumns: aCollection  aCollection do: [:each |  self addColumn: each ]action  ^actionBlockwhenBackgroundColorBlockChanged: aBlock  self deprecated: 'Should not use. This feature is not supported anymore. This feature depends on the theme'privateAsArray  | result |  result := OrderedCollection new.  self resetArrayComputation.  self computeNonSplitterWidgetsIn: result.  self computeSplittersIn: result.  ^result asArraychildrenForObject: anObject  ^(EyeInspector inspector: anObject) elements select: [:element |  element shouldShowInTree ]mockPage  ^SpNotebookPage title: 'Mock' icon: (self iconNamed: #changeUpdate) provider: [ SpButtonPresenter new ]topFraction  ^topFractiondelete  enabled: aBooleanOrValuable  enabled := aBooleanOrValuableinitializePanels  leftPanel := self newPanelMorph.  rightPanel := self newPanelMorph     listDirection: #rightToLeft;     hResizing: #spaceFill.  self     addMorphBack: leftPanel;     addMorphBack: rightPanelfieldEncrypted  ^fieldEncryptedtestAddPage  self assert: self adapter numberOfTabs equals: 2.  presenter addPage: (SpNotebookPage title: 'Mock3' provider: [ SpLabelPresenter new ]).  self assert: self adapter numberOfTabs equals: 3subwidgetArguments  ^self subwidget isArray ifTrue: [ #(presenter) , self subwidget , {#retrieveSpec: .               self specSelector} ] ifFalse: [ {#presenter .         self subwidget .         #retrieveSpec: .         self specSelector} ]includesItems: anItemList  ^self selectedItems includesAll: anItemListtestTransmissionFromPackageToClassList  | package |  package := RPackage named: 'TestPackageForSpecTests' asSymbol.  biChooseMethod packageList items: {package}.  biChooseMethod packageList selectItem: package.  self assertEmpty: biChooseMethod classList items.  self assert: biChooseMethod selectedClass isNilupdateTextContents  | text |  text := self model setContentsOfChangeSet: self selectedChangeSet forClass: self selectedClass andSelector: self selectedSelector.  (text asString lines anySatisfy: [:line |  self model classDescriptionsMap values , {'Method was added, but cannot be found!' .               'Added then removed (see versions)' .               'Method has been removed (see versions)' .               'Class organization was changed.'} includes: line ]) ifTrue: [ textPresenter withoutSyntaxHighlight ] ifFalse: [ textPresenter withSyntaxHighlight ].  textPresenter text: textinitializePresenters  table1 := self newTable.  label := self newLabel.  self resetLabel.  table1     addColumn: ((SpCheckBoxTableColumn title: ' ' evaluated: [:class |  selectedClasses includes: class ])           onActivation: [:class |  selectedClasses add: class.              self resetLabel ];           onDesactivation: [:class |  selectedClasses remove: class.              self resetLabel ];           width: 20;           yourself);     addColumn: ((SpImageTableColumn title: 'Icon' evaluated: #systemIcon)           width: 50;           yourself);     addColumn: (SpStringTableColumn title: 'Name' evaluated: #name);     addColumn: (SpStringTableColumn title: 'Number of subclasses' evaluated: [:class |  class subclasses size asString ]);     items: self class environment allClasses;     beResizablesetFocus  self focusOrder     add: uniformDropList;     add: heterogeneousDropList;     add: disabledDropListtestSelectWidgetIndexRaisesSelectionIndexChangeEventOnce  | counter |  counter := 0.  presenter selection whenChangedDo: [:selection |  counter := counter + 1 ].  self adapter selectPath: #(1).  self assert: counter equals: 1testSelectItemOutsideRangeHasNoSelectedIndexes  presenter selectItem: 400.  self assert: presenter selection selectedIndexes isEmptywrapHolder  ^wrapHolderpageClass  ^SpDemoActionBarPresenterrefreshDescription  self refreshDescription: self selectedElementbasicPresenters  ^presenters ifNil: [ presenters := OrderedDictionary new ]list  ^list ifNil: [ list := self newList           activateOnDoubleClick;           whenSelectionChangedDo: [:selection |  [:item |  self refreshDescription: item ] cull: selection selectedItem ];           whenActivatedDo: [ self diveIntoSelectedObject ];           yourself ]itemFilterBlock  self deprecated: 'Use #itemFilter instead' transformWith: '`@receiver itemFilterBlock' -> '`@receiver itemFilter'.  ^self itemFiltercanBeRefreshed  ^canBeRefreshedtext  ^self input textvRigid  self widgetDo: [:w |  w vResizing: #rigid ]badgeSelector: aSymbol  badgeSelector := aSymbolproperty: aName whenChangedDo: aBlockClosure  (self observablePropertyNamed: aName) whenChangedDo: aBlockClosurenewPhone  ^newPhonecolor  ^sliders colorinspectInNewWindow: anObject  anObject inspecttoolbar  ^toolbarlist  ^self subwidgettestUnselectAllUnselectsall  presenter     selectIndex: 1;     unselectAll.  self assert: presenter selection isEmptydefaultButtonId  ^defaultButtonIdtestUnselectAll  presenter beMultipleSelection.  presenter selectAll.  self assert: presenter selection selectedItems asArray equals: #(10 20 30).  presenter unselectAll.  self assertEmpty: presenter selection selectedItemsencrypted: aBoolean  self widgetDo: [:w |  w encrypted: aBoolean.        w changed ]input  ^self subwidgetwithProgressionBlock: anObject  withProgressionBlock := anObjectvalue  ^self host array at: self indexbuildWidget  self model model whenChangedDo: [ self changed: #getList.        self changed: #getIndex ].  self model selection whenChangedDo: [ self changed: #getIndex ].  ^SpDropListMorph new     wrapSelector: #wrap:withIndex:;     on: self list: #getList selected: #getIndex changeSelected: #setIndex:;     hResizing: #spaceFill;     vResizing: #spaceFill;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     enabled: self enabled;     setBalloonText: self help;     yourselfclassToTest  ^SpMillerColumnPresenterdateLabel  ^dateLabeltestSelectPresenterItemSetsSelectedIndexInWidget  presenter selectItem: (presenter items at: 2).  self assert: (self adapter selectedIndexes includes: 2)setLayoutSizing  self subclassResponsibilityautoDeselection  ^autoDeselection valueinitializeTestedInstance  label: anObject  displayBlock := [ anObject ]selectedIndexes  ^widget selectedIndexeslistApplications  | nl |  nl := Smalltalk platform lineEnding.  self stdout << 'List of applications: ' << nl << '---- ' << nl.  SpApplication findAll do: [:each |  self stdout << each applicationName << nl ].  self exitSuccessinitialize  super initialize.  self     name: 'Change phone';     description: 'Change the phone number of the contact.'focusedPresenter  ^mock allPresentersInFocusOrder detect: [:each |  each adapter widget hasKeyboardFocus ] ifNone: [ nil ]initializeTestedInstance  presenter     addColumn: (SpStringTableColumn title: 'Value' evaluated: #printString);     addColumn: (SpImageTableColumn title: 'Icon' evaluated: [:x |  self iconNamed: #add ]);     hideColumnHeaders;     roots: #(1 2 3);     children: [:aNumber |  {(aNumber * 2) .         (aNumber * 3) .         (aNumber * 10)} ]entityText: anObject  entityText := anObjectnewDataSource  ^SpMorphicTreeTableDataSource new     model: self model;     rootItem: (self rootForItems: self model roots);     childrenBlock: [:data :item |  self model childrenFor: data ];     yourselfborderColor  ^borderColortestSelectPresenterIndexSetsSelectedIndexInWidget  presenter selectIndex: 1.  self assert: (self adapter selectedIndexes includes: 1)initialize  super initialize.  self flag: #REVIEW.  scrollValue := 0 @ 0.  self withScrollBarsbuildStatusBar  ^SpStatusBarPresenter newlabel  ^'self'pressedFillStyle  ^self theme splitterPressedFillStyleFor: selfisFloat  ^self numberType = FloattestResetingSelectionResetsSelection  self presenter selectItem: 10.  self presenter resetSelection.  self assert: self presenter selectedItem equals: nil.  self assert: self adapter selectedIndexes isEmptytestSelectItemsOutsideRangeIsEmpty  presenter selectItems: {4000 .         5000}.  self assert: presenter selection isEmptynewCloseButtonFor: aPage  ^SpButtonPresenter new     icon: self theme windowCloseForm;     action: [ self removePage: aPage ];     buildWithSpecisInput  ^true= anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^self label = anObject label and: [ action = anObject action ]number2  ^number2add: aBlock withSpec: aSpec bottom: aNumber  self add: aBlock withSpec: aSpec top: nil bottom: aNumber left: nil right: niluseBasicInspector  self inspectorType: EyeBasicInspectormodelObjects: aCollectionOfObjects  instVarToModelObject := aCollectionOfObjects collect: [:o |  self generateUniqueInstanceVariableName -> o ]buildWidget  ^SpStubTickingWindowView newname: aString  name := aStringwithErrorsDo: aBlock  self errorPropertySelectors do: [:selector |  self errorWhileAccessing: selector do: aBlock ]defineOutputPorts  ^{SpSelectionPort new .   SpActivationPort new}canTakeKeyboardFocus  ^falseinitialize  super initialize.  self type: SpNotificationType inforegisterEvents  self whenTextChangedDo: [ self changed: #getText ].  self whenReadSelectionIsChangedDo: [ self changed: #readSelection ].  self property: #hasUnacceptedEdits whenChangedDo: [:bool |  self changed: #setHasUnacceptedEdits: with: {bool} ].  self property: #selection whenChangedDo: [:block |  self changed: #setSelectionFromModel: with: {block value} ].  self whenAutoAcceptChangedDo: [:bool |  self changed: #autoAccept: with: {bool} ].  self property: #wantsVisualFeedback whenChangedDo: [:bool |  self changed: #changed with: #() ].  self property: #askBeforeDiscardingEdits whenChangedDo: [:bool |  self changed: #askBeforeDiscardingEdits: with: {bool} ]autoMultiSelection  ^self model autoMultiSelectionselectedClass  ^classesListPresenter selection selectedItemtitle  ^titlewhenCanDeselectByClickChangedDo: aBlock  self deprecated: 'This option is removed in Spec 2'protocolNameForItem: anItem  ^anItem category ifNil: [ '' ]initializeTestedInstance  presenter     addPage: (SpNotebookPage title: 'Mock' icon: (self iconNamed: #changeUpdate) provider: [ SpButtonPresenter new ]);     addPage: (SpNotebookPage title: 'Mock2' icon: (self iconNamed: #changeUpdate) provider: [ SpLabelPresenter new ])testSelectAllDoesNotSelect  presenter selectAll.  self assert: presenter selection isEmptyspacing: aNumber  spacing := aNumberisExpand  ^expand ifNil: [ self class defaultExpand ]addContent: aView toWindow: aSpecWindow  removePage: aPage  pagesHolder remove: aPagewhenValueChangedDo: aBlock  whenEntryCompletionChangedDo: aBlock  self property: #entryCompletion whenChangedDo: aBlockdefaultColor  ^self theme backgroundColorconnectPresenters  self registerChangeActions.  self registerClassActions.  self registerSelectorActions.  changesListPresenter items ifNotEmpty: [ changesListPresenter selectIndex: 1 ]surfaceExtent  ^surfaceExtentwhenSelectionChanged: aBlock  self dropList whenSelectionChanged: aBlockiconFor: anItem  ^nilinitialize  selectedClasses := OrderedCollection with: ASTCache with: ASTEvaluationTest with: Abort.  super initializeobservablePropertyNamed: aName  | slot |  slot := self class slotNamed: aName.  slot isObservableSlot ifFalse: [ SpNonObservableSlotError signal: aName ].  ^slot rawRead: selfpushMessage: aString  self message: aString.  self changed: #pushMessageclassToTest  ^SpTextFieldExampleaddVariableFields: elements  self variableFieldsToShow do: [:index |  elements add: (BasicIndexedEyeElement host: self object index: index) ]asMorphicLayout  ^LayoutFrame identity     topFraction: self topFraction;     topOffset: self topOffset;     bottomFraction: self bottomFraction;     bottomOffset: self bottomOffset;     rightFraction: self rightFraction;     rightOffset: self rightOffset;     leftFraction: self leftFraction;     leftOffset: self leftOffset;     yourselfname: aString  name := aStringdisplayBlock: aBlock  wrapHolder value: aBlocknewWidgetOn: anAdapter  ^anAdapter newHorizontalnewTree  self deprecated: 'Use #newTreeTable instead'.  ^self instantiate: SpTreePresenteraskBeforeDiscardingEdits: aBoolean  askBeforeDiscardingEdits := aBooleantestRowSpacing  | layout |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1.  self place: label2 at: 1 @ 2.  self place: morph2 at: 2 @ 2.  (layout := self newLayout) layout rowSpacing: 5.  layout layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 50 @ 20).  self assert: morph1 bounds equals: (50 @ 0 corner: 100 @ 20).  self assert: label2 bounds equals: (0 @ 25 corner: 50 @ 45).  self assert: morph2 bounds equals: (50 @ 25 corner: 100 @ 45)testEmptyMillerListHasNoWidgets  self assert: self adapter childrenWidgets isEmptyextent  ^30 @ 30showOnlySource: aBoolean  showOnlySource := aBooleantestSetSelectItemOutsideRangeRaisesSelectionChangeEventWithUnsetItem  | selectedItem |  presenter whenSelectionChangedDo: [:selection |  selectedItem := selection selectedItem ].  presenter selectItem: 40.  self assert: selectedItem equals: nilmodel  self deprecated: 'User should not use model directly.'.  ^messageList modeladdDependent: aMorph  self myDependents add: aMorphurlColor  ^self color ifNil: [ self theme urlColor ]newDataSourceMatching: aFTFilter  | newElements wrappedItem text newDataSource modelCopy |  newElements := self elements select: [:each |  wrappedItem := self model displayValueOf: each.        table columns anySatisfy: [:column |  text := column transform: wrappedItem.              aFTFilter matches: text ] ].  newDataSource := self copy.  modelCopy := self model copy.  modelCopy prepareForFilteredDataSourceWith: newElements.  newDataSource model: modelCopy.  ^newDataSourcelabel  ^self instVarNamecalculateNotHomogeneousColumnWidths  | newColumnWidths expandables |  newColumnWidths := Array new: numColumns withAll: 0.  morphs do: [:each |  | column |        column := (each valueOfProperty: #gridConstraints) column.        (self isColumnExpandable: column) ifFalse: [ newColumnWidths at: column put: ((newColumnWidths at: column) max: (self styleOf: each) width) ] ].  expandables := newColumnWidths count: [:each |  each isZero ].  expandables > 0 ifTrue: [ | width accumulatedWidth |        accumulatedWidth := (newColumnWidths reject: [:each |  each isZero ]) ifNotEmpty: [:nonZeroWidths |  nonZeroWidths sum ] ifEmpty: [ 0 ].        width := ((bounds width - accumulatedWidth) / expandables) asInteger.        newColumnWidths := newColumnWidths collect: [:each |  each = 0 ifTrue: [ width ] ifFalse: [ each ] ] ].  ^newColumnWidthswhenSelectedItemChangedDo: aBlock  self deprecated: 'Use #whenSelectionChangedDo: instead' transformWith: '`@receiver whenSelectedItemChangedDo: `@argument' -> '`@receiver whenSelectionChangedDo: [ :selection | `@argument cull: selection selectedItem ]'.  self selection whenChangedDo: [:selection |  aBlock cull: selection selectedItem ]selectIndex: anInteger  (anInteger = 0 and: [ widget selectedIndexes isEmpty ]) ifTrue: [ ^self ].  (widget selectedIndexes includes: anInteger) ifTrue: [ ^self ].  widget selectIndex: anIntegertextStyler  ^textStylertestDefaultPlaceholderIsEmpty  self assert: presenter placeholder isEmptyborderWidth  ^borderWidthbrowseClassRefs  self currentMethod ifNotNil: [:method |  model browseClassRefsOf: method methodClass ]subscribeToAnnouncements: aWindow  aWindow announcer     when: SpWindowWillClose send: #announce: to: self presenter announcer;     when: WindowResizing send: #announce: to: self presenter announcerwhenBorderWidthChangedDo: aBlock  self property: #borderWidth whenChangedDo: aBlocktestSelectAllRaisesSelectionEventOnce  | events |  events := 0.  presenter whenSelectionChangedDo: [:selection |  events := events + 1 ].  presenter selectAll.  self assert: events equals: 1testSelectItemsAddsItemsToSelectedItemList  presenter selectItems: {10 .         20}.  self assert: (presenter selection includesItems: {10 .               20})contextClass  ^self model contextClassprogress: aBlock every: aDelay  self state: (SpProgressBarProgressing progression: aBlock every: aDelay)message  ^messagerightPanel  ^rightPanelclassToTest  ^SpMockDynamicPresentersetSendersModel  sendersModel     state: false;     label: 'Senders';     action: [ self sendersMethod ]state: aBoolean  ^self presenter state: aBooleanallGridConstraints  ^morphs collect: [:each |  each valueOfProperty: #gridConstraints ifAbsent: [ self error: 'Constraints not defined for ' , each asString ] ]exampleTab  ^SpNotebookPage title: 'Example' icon: (self iconNamed: #smallPaint) provider: [ self instantiate: self pageClass ]ensureExtentFor: aWidget  self extent ifNotNil: [:ext |  DisplayScreen hostWindowSize: ext ].  self initialExtent ifNotNil: [:ext |  DisplayScreen hostWindowSize: ext ]x: anInteger  x := anIntegernewRow: aBlock top: aNumber  self newRow: aBlock top: aNumber bottom: nilisBold  ^bold == truedefaultWindowModelClass  self deprecated: 'Use #defaultWindowPresenterClass instead' transformWith: '`@receiver defaultWindowModelClass' -> '`@receiver defaultWindowPresenterClass'.  ^self defaultWindowPresenterClassprogressBarMorph  ^ProgressBarMorphmaximize  self widgetDo: [:w |  w maximize ]initialize  super initialize.  self     removeMorph: self contentMorph;     removeMorph: self tabSelectorMorph;     headerMorph: self newHeaderMorph;     addMorph: self headerMorph;     addMorph: self contentMorphselection  | selection |  self flag: 'I wonder about the naming of the classes: should actions based on selection not be available also on text presenters?'.  selection := context selection.  selection ifEmpty: [ ^'' ].  self flag: 'The following code has been commented: it seems wrong and provokes the current context to be restarted in the debugger'.  ^context text copyFrom: selection first to: selection lastisMatch: anObject pattern: aString  | text |  text := (self toString: anObject) trimBoth asLowercase.  ^text beginsWith: aStringcheckboxInput: anObject  checkboxInput := anObjectisExpanded: aBoolean  whenAbsoluteValueChangedDo: aBlock  self property: #absoluteValue whenChangedDo: aBlockstate: aBoolean  ^self presenter state: aBooleanexecute  self context inspectbuildWidget  ^SpStubTransferView newmodelClass  ^SpTreePresentersaveElement: newText  | newValue |  newValue := description doItReceiver class compiler     source: newText;     context: self doItContext;     receiver: description doItReceiver;     failBlock: [ ^self ];     evaluate.  self selectedElement save: newValue.  self objectChangedadapterBindingsClass  self subclassResponsibilityadd: aName  self add: aName withConstraints: [:constraints |   ]widget  ^widgetwhenTextChangedDo: aBlock  self property: #text whenChangedDo: aBlocknewListMorph  ^(self listMorphClass on: self list: #list selected: #listSelectionIndex changeSelected: #listSelectionIndex: menu: nil keystroke: nil)     getIconSelector: #getIconFor:;     autoDeselect: false;     wrapSelector: #wrapItem:index:;     roundedCorners: #(2 3);     setProperty: #morphicLayerNumber toValue: 5;     borderStyle: (self theme dropListNormalListBorderStyleFor: self);     on: #mouseDown send: #listMouseDown: to: self;     yourselfprintOn: aStream  aStream     print: self label;     << '->';     << (self value printStringLimitedTo: 50)hasScrollBars  ^wrapScrollBarsasSpecCommand  ^super asSpecCommand     iconName: #removeIcon;     shortcutKey: $x meta;     yourselfinitializePresenters  link1 := self newLink.  link2 := self newLink.  link3 := self newLink.  link4 := self newLink.  link1 url: 'https://pharo.org'.  link2     url: 'https://pharo.org';     label: 'Pharo website'.  link3     url: 'https://pharo.org';     label: 'Pharo website';     color: Color purple.  link4     action: [ Object browse ];     label: 'Browse Object'connectPresenters  list1 whenSelectionChangedDo: [:selection |  [:elem |  label label: (elem ifNil: [ 'Deselection from list 1' ] ifNotNil: [ 'Selection from list 1: ' , elem asString ]) ] cull: selection selectedItem ].  list2 whenSelectionChangedDo: [:selection |  [:elems |  multiLabel label: (elems ifEmpty: [ 'Not multi selection (from list 2 only)' ] ifNotEmpty: [ 'Multi-selection from list 2: ' , elems asString ]) ] cull: selection selectedItems ].  list3 whenSelectionChangedDo: [:selection |  [:elem |  label label: (elem ifNil: [ 'Deselection from list 3' ] ifNotNil: [ 'Selection from list 3: ' , elem asString ]) ] cull: selection selectedItem ]number1  ^number1displayBlock  self deprecated: 'Please use #display instead' transformWith: '`@receiver displayBlock' -> '`@receiver display'.  ^displayBlockeventKeyStrokesForNextFocus  ^{Character arrowRight asKeyCombination .   Character tab asKeyCombination}multiSelection  ^multiSelection valuetestSelectIndexThenSelectOutsideRangeKeepsSingleSelectedItem  presenter selectIndex: 1.  presenter selectIndex: 50.  self assert: presenter selection selectedItems size equals: 1widgets  self deprecated: 'Use #basicPresenters instead' transformWith: '`@receiver widgets' -> '`@receiver basicPresenters'.  ^self basicPresentersaddSettingsTo: aMorph  self widget ifNotNil: [ self applyVisibility ]includesItem: anItem  self subclassResponsibilitydefineInputPorts  ^{SpListItemsPort new}notifyPropertyChanged: aName  self flag: #todo.  (self observablePropertyNamed: aName) valueChangedaddAllInstVars: elements  elements add: (AllInstVarsEyeElement host: self object)classToTest  ^SpLabelPresentercreateVersionForBlessing: blessingSelector  | existingVersions msg initialAnswer newVersionNumber selectorName stream mcWorkingCopy |  existingVersions := self configurationClass methods select: [:cm |  cm selector beginsWith: 'version' ].  existingVersions := (existingVersions collect: [:m |  m pragmas first argumentAt: 1 ]) asSortedCollection.  msg := ''.  existingVersions size > 4 ifTrue: [ msg := 'Last 4 versions: ' , (existingVersions copyFrom: existingVersions size - 4 to: existingVersions size) asArray printString , String cr ].  initialAnswer := existingVersions size > 0 ifTrue: [ existingVersions last , '.1' ] ifFalse: [ '1.0' ].  newVersionNumber := UIManager default request: msg initialAnswer: initialAnswer.  newVersionNumber ifNil: [ ^self ].  selectorName := newVersionNumber copyWithoutAll: '.-'.  stream := WriteStream on: String new.  stream nextPutAll: 'version'.  stream nextPutAll: selectorName.  stream nextPutAll: ': spec         <version: '''.  stream nextPutAll: newVersionNumber.  stream     nextPutAll: ''' imports: #(''';     nextPutAll: self lastBaseLine;     nextPutAll: ''')>        spec for: #common do: [                spec blessing: ';     nextPutAll: blessingSelector printString;     nextPutAll: '.'.  self dependentPackages do: [:pName |  stream           nextPutAll: '			spec package: ''';           nextPutAll: pName;           nextPutAll: ''' with: '''.        mcWorkingCopy := (MCPackage named: pName) workingCopy.        mcWorkingCopy needsSaving ifTrue: [ self inform: 'The configuration you want to save depends on the package ' , pName , '. You first need to save this package in order to create the version'.              ^self ].        stream nextPutAll: mcWorkingCopy ancestry ancestors first name.        stream           nextPutAll: '''.';           nextPutAll: String cr ].  stream nextPutAll: '                ].'.  self configurationClass compile: stream contents classified: 'versions'needRebuild: aBoolean  needRebuild := aBooleanisHorizontal  ^self direction = SpLayoutDirection horizontalspacing  ^spacingbuildUpdateTitle  self updateTitle.  textModel text: textModel texticon  ^self model iconopenModal: aPresenter  ^self openModal: aPresenter withSpecLayout: aPresenter defaultSpecactionToPerformWithSelector: aSelector arguments: args  ^[ spec perform: aSelector withArguments: args ] on: MessageNotUnderstood do: [:ex |  (aSelector last ~= $: and: [ args isEmpty ]) ifTrue: [ self subpresenterNamed: aSelector ] ifFalse: [ ex pass ] ]root  ^self owner ifNotNil: [:presenter |  presenter root ] ifNil: [ self ]setBalloonText: aString  cellColumn: column row: rowIndex  | cell item |  item := self elementAt: rowIndex.  cell := FTCellMorph new     cellInset: 5;     yourself.  cell addMorphBack: (self widgetFor: item).  ^cellupdate  self preventUpdatesDuring: [ self updateInspectorChoice.        self updateInspectorType.        previousButton enabled: self history hasPrevious.        nextButton enabled: self history hasNext ]testHideColumnHeadersRaisesOneEventOnly  | count |  count := 0.  presenter whenShowColumnHeadersChangedDo: [ count := count + 1 ].  presenter hideColumnHeaders.  self assert: count equals: 1input  ^inputselectorOf: anItem  ^anItem selectorselectionChanged: ann  self suspendSelectionEventsDuring: [ self basicSelectionChanged: ann ]execute  self editor cutselectIndex: anInteger  listModel selectIndex: anIntegersetTargetLayoutSizing  self subclassResponsibilityadapt: aPresenter  super adapt: aPresenter.  self addSettingsTo: self widget.  self addKeyBindingsTo: self widget.  self flag: #TODOinitialize  super initialize.  okAction := [ true ]iconMorph  ^ImageMorph new form: (self iconNamed: #calendarIcon)doesNotUnderstand: aMessage  (self treeModel respondsTo: aMessage selector) ifFalse: [ ^super doesNotUnderstand: aMessage ].  ^self treeModel perform: aMessage selector withArguments: aMessage argumentsisRunningInUIProcess  ^UIManager default uiProcess == Processor activeProcessdragEnabled: aBoolean  self widget ifNotNil: [:w |  w dragEnabled: aBoolean ]add: anItem  collection := collection copyWith: anItem.  self refreshList.  self announcer announce: (ValueChanged newValue: self)newHorizontal  ^self newPanel     listDirection: #leftToRight;     yourselfbutton  ^buttonbeforeTest: aSpecTest  testWhenSyntaxHighlightChangedDo  | count result |  count := 0.  result := true.  presenter whenSyntaxHighlightChangedDo: [:syntaxHighlight |  count := count + 1.        result := syntaxHighlight ].  presenter withoutSyntaxHighlight.  self assert: count equals: 1.  self deny: resulttestNonOpenPresenterDoesNotRaiseDisplayedEvent  | displayed |  displayed := false.  presenter whenDisplayDo: [ displayed := true ].  self deny: displayedaddItem: aToolbarItem  self addItem: aToolbarItem position: SpToolBarItemPosition leftreadObject: anObject  ^self model readObject: anObjectaction  ^textModel acceptBlockmainIcon: aFrom  mainIcon := aFromclassToTest  ^SpRGBWidgettestKeyBindings  | handled |  handled := false.  presenter bindKeyCombination: $t meta toAction: [ handled := true ].  self adapter keyPressed: $t asciiValue shift: false meta: true control: false option: false.  self assert: handledbuildWidget  ^SpStubListView newopenInstance  window ifNil: [ window := presenter openWithSpec ].  self currentWorld doOneCyclehasBadge  ^self badge notNillayoutFrame: newFrame  layoutFrame := newFrame asSpLayoutFrameincomingTransmission: anObject from: outPort  self destinationPresenter text: anObjectprivateAsArray  self resetArrayComputation.  self countNumberOfProportionals.  autoFractionComputation ifTrue: [ self autoFractionComputation ] ifFalse: [ self manualFractionComputation ].  self shiftLastWidgets.  ^super privateAsArrayremove: aPresenter  | morph |  morph := aPresenter adapter widget.  widget submorphs first removeMorph: morph.  widget submorphs second removeMorph: morphtestContextMenu  | menu changed |  self assert: presenter contextMenu isNil.  menu := SpMenuPresenter new.  changed := false.  presenter whenMenuChangedDo: [ changed := true ].  presenter contextMenu: menu.  self assert: presenter contextMenu equals: menu.  self assert: changedbuttonWithShortcut: anObject  buttonWithShortcut := anObjecttestClickingRadio3SelectsIt  self openInstance.  self presenter radio3 adapter clicked.  self assert: self presenter radio3 statehSpaceFill  self widgetDo: [:w |  w hResizing: #spaceFill ]selectItem: anItem  self basicSelectIndex: (self indexOfItem: anItem)highlightedItem: anItem  highlightedItem value: anItemlistModel  ^model modelpreviousMonthButton  ^previousMonthButtonclassToTest  ^SpTestPresenterWithThreeRadioButtonsleftFraction: aNumber  layoutFrame leftFraction: aNumbertestDeactivatePresenterIsNotActive  presenter state: false.  self deny: presenter stateclassToTest  ^SpWindowPresenterdefineOutputPorts  ^{SpSelectionPort new .   SpActivationPort new}rootNodeHolder  ^rootNodeHolder valuewhenItemFilterBlockChangedDo: aBlock  self property: #itemFilter whenChangedDo: aBlocknameLabel  ^nameLabelupdate  self needRebuild: false.  self buildWithSpecdeselectAll  self changed: #deselectAll with: #()= aTag  ^self foreground = aTag foregrounddefaultValue: aBoolean  defaultValueHolder value: aBooleantestCanCancelAddNewItem  presenter     items: #(1 2 3) asOrderedCollection;     addItemBlock: [ nil ].  presenter addButton click.  self assertCollection: presenter items hasSameElements: #(1 2 3)selectFirstElement  list selectIndex: 1rowMorphFor: aNode  | node rowMorph |  node := aNode nodeModel.  rowMorph := self rowMorphGetSelector ifNil: [ node rowMorphForColumn: self ] ifNotNil: [ self rowMorphGetterBlock value: node value: self container ].  rowMorph := rowMorph asMorph.  rowMorph ifNotNil: [ rowMorph borderWidth: 0 ] ifNil: [ rowMorph := self defaultRowMorph ].  ^rowMorph rowMorphForNode: node inColumn: selftabs: aCollection  tabs value: aCollectionoddRowColor: aColor  oddRowColor value: aColorwhenChangedDo: aBlock  redSlider whenValueChangedDo: aBlock.  greenSlider whenValueChangedDo: aBlock.  blueSlider whenValueChangedDo: aBlockchangeSets  ^self changesListPresenter listItemsarguments  ^{(self commands identityIndexOf: self)}testSelectInvalidPathsHasNoSelectedItems  presenter selectPaths: {#(10 20) .         #(20 20)}.  self assert: presenter selection selectedItems isEmptyinitialize  super initialize.  count := 0isRowHomogeneous  ^self layout isRowHomogeneousclickFirstRowAndColumn: anAdapter  self waitUntilUIRedrawed.  anAdapter widget mouseDown: (MouseEvent new           setHand: HandMorph new;           setPosition: anAdapter widget submorphs first submorphs first bounds center;           yourself)okButton  ^okButtoninitializeShortcuts  self bindKeyCombination: $[ meta toAction: [ self inspectPrevious ].  self bindKeyCombination: $] meta toAction: [ self inspectNext ].  self bindKeyCombination: $[ meta shift toAction: [ self usePreviousInspectorType ].  self bindKeyCombination: $] meta shift toAction: [ self useNextInspectorType ].  self bindKeyCombination: $0 meta toAction: [ self useBasicInspector ].  self bindKeyCombination: $0 meta shift toAction: [ self useDefaultInspector ].  self bindKeyCombination: $1 meta toAction: [ self useInspectorAt: 1 ].  self bindKeyCombination: $2 meta toAction: [ self useInspectorAt: 2 ].  self bindKeyCombination: $3 meta toAction: [ self useInspectorAt: 3 ].  self bindKeyCombination: $4 meta toAction: [ self useInspectorAt: 4 ].  self bindKeyCombination: $5 meta toAction: [ self useInspectorAt: 5 ].  self bindKeyCombination: $6 meta toAction: [ self useInspectorAt: 6 ].  self bindKeyCombination: $7 meta toAction: [ self useInspectorAt: 7 ].  self bindKeyCombination: $8 meta toAction: [ self useInspectorAt: 8 ].  self bindKeyCombination: $9 meta toAction: [ self useInspectorAt: 9 ]defaultValue  ^defaultValueHolder valuecloseableHolder  ^closeableHolderborderColor: color  property: aName whenChangedDo: aBlockClosure  (self observablePropertyNamed: aName) whenChangedDo: aBlockClosurenumberOfItems  ^self widget leftPanel submorphs size + self widget rightPanel submorphs sizeisMorphicAdapter  ^falseitemSubstringFilter  self deprecated: 'Use #enableItemSubstringFilter instead' transformWith: '`@receiver itemSubstringFilter' -> '`@receiver enableItemSubstringFilter'.  self enableItemSubstringFilterdefineInputPorts  ^#()selectEntity: anObject  selectEntity := anObjectpresenters  ^self itemsicons: aBlock  icon := aBlocktestSelectItemThenSelectOutsideRangeKeepsFirstElement  presenter selectItem: 10.  presenter selectItem: 5000.  self assert: (presenter selection includesItem: 10)forceChangesListRefresh  | sel |  sel := self selectedChangeSet.  changesListPresenter items: self model allChanges.  changesListPresenter setSelectedItem: selhighlightedItem: aTreeNodePresenter  tree highlightedItem: aTreeNodePresenterbuildWidget  | newWidget |  self flag: #pharo7.  newWidget := ((self class environment at: #SpRubTextFieldMorph ifAbsent: [ RubTextFieldMorph ]) on: self)     getTextSelector: #getText;     setTextSelector: #accept:notifying:;     getSelectionSelector: #readSelection;     menuProvider: self selector: #codePaneMenu:shifted:;     setSelectionSelector: #setSelection:;     entryCompletion: self entryCompletion;     ghostText: self placeholder;     encrypted: self encrypted;     enabled: self enabled;     askBeforeDiscardingEdits: self askBeforeDiscardingEdits;     autoAccept: self autoAccept;     vResizing: #spaceFill;     hResizing: #spaceFill;     setBalloonText: self help;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     maxLength: self presenter maxLength;     yourself.  self presenter whenTextChangedDo: [:text |  newWidget setText: text ].  self presenter whenPlaceholderChangedDo: [:text |  newWidget ghostText: text ].  self presenter whenPasswordChangedDo: [:isPassword |  newWidget encrypted: isPassword ].  self presenter whenMaxLengthChangedDo: [:length |  newWidget maxLength: length ].  ^newWidgetlistModel  ^listModelshowSubMenu: aMenu  aMenu menuGroups ifNil: [ ^self ].  subMenuWidget ifNotNil: [ subMenuWidget delete.        subMenuWidget := nil ].  subMenuWidget := (SpMorphicMenuAdapter adaptAsPopup: aMenu) widget.  subMenuWidget popUpAdjacentTo: {self widget bounds bottomLeft .         self widget bounds bottomRight} forHand: ActiveHand from: self widget.  subMenuWidget popUpOwner: selfisShowColumnHeaders  ^widget isShowColumnHeaderstestSelectItemRaiseEvent  | called |  self presenter whenSelectionChangedDo: [ called := true ].  self presenter selection selectPath: #(2 3).  self assert: called equals: truepreferedPaneColor: aColor  preferedPaneColor value: aColortopOffset  ^0buildWidget  | checkButton |  checkButton := PluggableToggleButtonMorph on: self getState: #state action: #toggleAction: label: #label menu: nil.  checkButton     icon: self icon;     label: self label;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     setBalloonText: self help;     getEnabledSelector: #enabled;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled.  self presenter whenLabelChangedDo: [:newLabel |  checkButton label: newLabel ].  self presenter whenIconChangedDo: [ checkButton icon: self icon ].  self presenter whenChangedDo: [ checkButton pressed: self model state ].  ^checkButtonkmTable  ^kmTableselectedIndexes  ^widget selectedIndexesdrawOn: aCanvas  super drawOn: aCanvas.  self hasBadge ifTrue: [ self drawBadgeOn: aCanvas ]initializePresenters  listModel := self newList.  textModel1 := self newText.  textModel2 := self newCode.  listModel beMultipleSelection.  listModel items: self class environment allClasseswhenActivatedDo: aBlock  testSetHeaderTitleSetsTitle  presenter headerTitle: 'title'.  self assert: presenter headerTitle equals: 'title'description: aString  description := aStringexploreSubMenu: aMenu  aMenu addGroup: [:aGroup |  aGroup addItem: [:anItem |  anItem                 name: 'Explore Pointers';                 action: [ self explorePointers ] ] ]object  ^objectobservablePropertyNamed: aName  | slot |  slot := self class slotNamed: aName.  slot isObservableSlot ifFalse: [ SpNonObservableSlotError signal: aName ].  ^slot rawRead: selfnameTextInput  ^nameTextInputaboutText  ^aboutText ifNil: [ aboutText := 'The about text for this window has not been set.' ]filterWith: aFilter  self selection: nil.  self updateTree.  self expandAll.  self changed: #filterWith: with: {aFilter}.  self expandAlllayoutBuilder: anObject  layoutBuilder := anObjectobjectChanged  self subclassResponsibilityheaderMorph: anObject  headerMorph := anObject.  headerMorph clipSubmorphs: truetestChangeActivatedAfterOpenCheckboxDectivatesIt  presenter state: false.  self openInstance.  presenter state: true.  self assert: presenter staterewind  ticks := lowestValueselected  ^self model selectedbottomOffset  ^0testRadio1StartsDeselected  self deny: self presenter radio1 statedescription  ^descriptionvisitCheckboxColumn: aTableColumn  | presenter |  presenter := SpCheckBoxPresenter new     state: (aTableColumn readObject: self item);     yourself.  aTableColumn onActivation ifNotNil: [:valuable |  presenter whenActivatedDo: [ valuable cull: self item ] ].  aTableColumn onDesactivation ifNotNil: [:valuable |  presenter whenDeactivatedDo: [ valuable cull: self item ] ].  self addCellMorph: presenter buildWithSpec column: aTableColumnheight: aNumber  self extent: self extentOrDefault x @ aNumberpickedItems  ^pickedItemsHolder valueon: anAnnouncement send: aSelector to: aTarget  self announcer when: anAnnouncement send: aSelector to: aTargetnumberOfTabs  ^self widget tabSelectorMorph tabs sizeaddPadding: aNumber toMorph: aMorph into: anAdapter  ^anAdapter addHorizontalPadding: aNumber toMorph: aMorphtestSelectInvalidPathHasNoSelectedItems  presenter selectPath: #(4).  self assert: presenter selection selectedItems isEmptytestUnselectSelectedPathRemovesItFromSelectionList  presenter     selectPath: #(1 2);     unselectPath: #(1 2).  self assert: presenter selection isEmptycustomMenuActions: anObject  customMenuActions := anObjecttestSmokeOpenPresenterWithItems  window := presenter     items: #(1 2 3);     openWithSpecvalue  ^valueisOutput  ^truenewWrapMorph  ^Morph new     layoutPolicy: ProportionalLayout new;     color: Color transparent;     borderColor: Color transparent yourselfbrowseInstVarDefs  ^self systemNavigation browseInstVarDefs: self hostClassiconBlock: aBlock  tree iconBlock: aBlocktext  ^self input textuseDefaultInspector  self inspectorType: self object class inspectorClassaddVSplitter  self commands add: (SpSplitterVertical commands: self commands)minHeight: aNumber  self widgetDo: [:w |  w minHeight: aNumber ]cellColumn: column row: rowIndex  | cell builder item |  item := self elementAt: rowIndex.  cell := FTIndentedCellMorph new.  cell indentBy: (self cellIndentFor: item).  (self isFirstColumn: column) ifTrue: [ cell addMorphBack: (self buttonFor: item) ].  builder := SpMorphicTreeTableCellBuilder on: self.  builder     cell: cell;     item: item data;     visit: column model.  ^cellbuttons  ^buttonstestSettingAnImageSetsTheImageAndThrowsEvent  | happened |  self presenter whenImageChangeDo: [ happened := true ].  self presenter image: self imageForm.  backendForTest assertImage: self adapter image equals: self imageForm.  self assert: happenedentity: anObject  entity := anObject.  anObject ifNotNil: [ self entityText text: (anObject perform: self displaySymbol) ] ifNil: [ self entityText text: '' ]borderColor  ^borderColorwhenLabelClickableChangedDo: aBlock  self property: #labelClickable whenChangedDo: aBlockautoSelect: aSelector  textModel readSelectionBlock: [:text |  self selectedMessage ifNotNil: [:msg |  (self isMethodDefinition: msg) ifFalse: [ self intervalOf: aSelector inCommentText: text ] ifTrue: [ self intervalOf: aSelector inCode: text of: msg ] ] ]testSetSelectPathRaisesSelectionChangeEventWithSelectedItem  | selectedElement |  presenter whenSelectionChangedDo: [:selection |  selectedElement := selection selectedItem ].  presenter selectPath: #(1 3).  self assert: selectedElement equals: 10setUp  super setUp.  themeDecorator := SpUIThemeDecorator exampleDecoratorToMakePluggableButtonRedmanualFractionComputation  self commands doWithIndex: [:e :idx |  e layoutFrame hasNoOffsets ifTrue: [ | delta |              delta := e layoutFrame bottomFraction - e layoutFrame topFraction.              self setWidgetLayoutWithNoOffset: e at: idx delta: delta ] ifFalse: [ self setWidgetLayoutWithOffset: e at: idx ] ]readObject: anObject  ^self transform: (table displayBlock value: anObject)testSelectItemOutsideRangeHasNoSelectedItems  presenter selectItem: 400.  self assert: presenter selection selectedItems isEmptyinitialize  cancelled := false.  cancelAction := [ true ].  super initializetable  ^tableselection: aSelection  self changed: #selection: with: {aSelection}backgroundColor  ^backgroundColorfillTag: tag withAttribute: attr  attr class = TextColor ifTrue: [ tag foreground: attr color ].  self flag: #TODOtext  self input textscaleLabel: anObject  scaleLabel := anObjectoutputPorts  ^self defineOutputPorts collect: [:each |  each presenter: self ]testExample  self flag: #todo.  (self classToTest respondsTo: #example) ifFalse: [ self skip ].  [ window := self classToTest example ] on: Error do: [:e |  self fail: 'Broken class example: ' , self classToTest asString , '' , e signalerContext shortStack ]wrappedPresenter  ^wrappedPresenterisInteger  ^self numberType = IntegerinitializePresenters  messageList := self instantiate: MessageList.  toolbarPresenter := self instantiate: SpMethodToolbar.  messageList     topologicSort: false;     sortingBlock: [:a :b |  (a annotationNamed: #versionIndex ifAbsent: [ 0 ]) < (b annotationNamed: #versionIndex ifAbsent: [ 0 ]) ];     contextMenu: self messageListMenu.  toolbarPresenter     addItemLabeled: 'Side By Side' do: [ self showDiffMorphWithConverter: (DiffMorphChangeRecordConverter methodReference: self textConverter method referencesList: self changeList) ];     addItemLabeled: 'Source' do: [ self showSourceWithConverter: (SourceMethodConverter method: self textConverter method) ];     addItemLabeled: 'Diff' do: [ self showSourceWithConverter: (DiffChangeRecordConverter methodReference: self textConverter method referencesList: self changeList) ].  toolbarPresenter versionModel     label: 'Revert';     action: [ self revert: self selectedMessage ]borderWidth: aNumber  borderWidth := aNumberproperty: aName rawValue: anObject  (self observablePropertyNamed: aName) rawValue: anObjecttestActivationOnSingleClickShouldActivateOnClick  | activatedItem |  activatedItem := nil.  presenter     activateOnSingleClick;     whenActivatedDo: [:selection |  activatedItem := selection selectedItem ].  presenter clickAtIndex: 1.  self assert: activatedItem label equals: '10'applyTo: aMorph  (aMorph respondsTo: #font:) ifFalse: [ ^self ].  aMorph font: self definedFontbeSelected  self setSelection: truetestVisibilityWithBlock  presenter visibleIf: [ true ].  self assert: self adapter isVisibleroots  ^tree rootsowner: anObject  owner := anObjectnumber1Input  ^number1InputclassToTest  ^SpRadioButtonExampleselectLine  self widgetDo: [:w |  w textArea editor selectLine ]tick  self ticks: ticks + stepByevenRowColor: aColor  tree evenRowColor: aColoradd: aName at: aPoint span: spanPoint  ^self add: aName withConstraints: [:constraints |  constraints           position: aPoint;           span: spanPoint ]selected: aBoolean  aBoolean ifTrue: [ self select ] ifFalse: [ self deselect ]associatedRadioButtons  ^associatedRadioButtonstestAddTabOpened  self openInstance.  self assertCollection: presenter tabs hasSameElements: #().  presenter addTab: redTab.  self assertCollection: presenter tabs hasSameElements: {redTab}beHorizontalAlignmentEnd  self hAlign: SpGridAlignment endselectedIndex  ^selectedIndextextModel2  ^textModel2value: aValue  ^self presenter value: aValuedefault: aButton  aButton privateSetState: true.  aButton takeKeyboardFocus.  aButton whenBuiltDo: [ aButton privateSetState: true.        self currentActivated: aButton ]add: aBlock right: aNumber  self add: aBlock top: nil bottom: nil left: nil right: aNumberoddRowColor  ^self model oddRowColorpreferedPaneColor: aColor  tree preferedPaneColor: aColorchangeSorterRight  ^changeSorterRightwhenIsResizableChangedDo: aBlock  self property: #isResizable whenChangedDo: aBlockallPresenters  | allPresenters |  allPresenters := OrderedCollection new.  self traversePresentersDo: [:each |  allPresenters add: each ].  ^allPresenterssetFilter: aFilterText  aFilterText ifEmpty: [ self collectAllShortcuts ] ifNotEmpty: [:filter |  self kmTable items: (self shortcuts select: [:shortcut |  {shortcut realValue shortcut asString .                     shortcut shortcutName .                     shortcut categoryName} anySatisfy: [:s |  s includesSubstring: filter caseSensitive: false ] ]) ]whenMaxChangedDo: aBlock  self property: #max whenChangedDo: aBlockinitializePresenters  | progress progress2 |  indeterminated := self newProgressBar.  fixed := self newProgressBar.  withProgressionBlock := self newProgressBar.  withText := self newProgressBar.  label := self newLabel.  indeterminated indeterminate.  fixed fixedPercentage: 30.  progress := 0.  withProgressionBlock progress: [ progress := progress + 0.01 ] every: 0.5 second.  progress2 := 0.  withText progress: [ progress2 := progress2 + 0.01 ] every: 0.1 second.  label label: 'This is a progress bar'initializeWidgets  text := self newCoderunApplication  | appClass |  appClass := SpApplication findNamed: self applicationName ifNone: [ ^self exitFailure: ('Application {1} not found.' format: {self applicationName}) ].  [ appClass new     prepareAsStandaloneApplication;     run ] forknewSplitter  ^self subclassResponsibilitytakeKeyboardFocus  self widget tabSelectorMorph takeKeyboardFocusinitialize  super initialize.  self     hResizing: #spaceFill;     vResizing: #spaceFill;     setLayoutSizing;     extent: self defaultWidth @ self defaultHeightinitializePresenters  messageList := self instantiate: MessageList.  toolbarPresenter := self instantiate: SpMethodToolbarmorph  ^presenter adapter widgetbadge  badgeSelector ifNil: [ ^nil ].  ^self model perform: badgeSelectorheaderLabelChanged  self widgetDo: [:w |  w header label: self headerLabel.        w container resizerChanged ]displayIn: aMenuGroupOrPresenter do: aBlock  self displayStrategy display: self in: aMenuGroupOrPresenter do: aBlockbrowseSendersOfMessage  self currentMethod ifNotNil: [:method |  model browseSendersOfMessagesFrom: method selector ]printObject: anObject  | printString |  printString := [ anObject printString ] on: Error do: [ '<error in printString: try ''Inspect it'' to debug>' ].  self afterSelectionInsertAndSelect: (self toPrintableString: printString)title  ^titlepage: anObject  page := anObjectexecute  self browserClientProvider browseAllSendersOf: self selectorinitialExtent  ^600 @ 300testSpanColumn  | layout |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1.  self place: label2 at: 3 @ 1.  self place: morph2 at: 2 @ 2 span: 2 @ 1.  layout := self newLayout.  layout layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 50 @ 20).  self assert: morph1 bounds equals: (50 @ 0 corner: 100 @ 20).  self assert: label2 bounds equals: (100 @ 0 corner: 150 @ 20).  self assert: morph2 bounds equals: (50 @ 20 corner: 150 @ 40)newList  ^self instantiate: SpListPresenterbuildWidget  ^StringMorph new     contents: self label;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     vResizing: #shrinkWrap;     hResizing: #spaceFill;     setBalloonText: self help;     color: self urlColor;     on: #mouseEnter send: #mouseEnter:from: to: self;     on: #mouseLeave send: #mouseLeave:from: to: self;     on: #mouseDown send: #mouseDown:from: to: self;     on: #mouseUp send: #mouseUp:from: to: self;     yourselfinitializePresenters  dateModel := self newTextInput.  chooseDateButton := self newButton.  chooseDateButton     icon: self iconMorph;     action: [ self chooseDate ];     extent: self iconMorph extentnewButton  ^PluggableButtonMorph on: self getState: nil action: #action label: #label icon: #icon menu: niltestSelectItemSelectsTheGivenElementAndExpandsTheBranches  self presenter selection selectPath: #(2 3).  self assert: self adapter selectedItem equals: 20whenIsExpandedChanged: aBlock  self deprecated: 'Use #whenIsExpandedChangedDo: instead.' transformWith: '`@receiver whenIsExpandedChanged: `@statements' -> '`@receiver whenIsExpandedChangedDo: `@statements'.  self whenIsExpandedChangedDo: aBlockbasicBuildAdapterWithSpecLayout: aSpecLayout  self announcer announce: (SpWidgetWillBeBuilt model: self).  self adapter: (aSpecLayout asSpLayout buildAdapterFor: self bindings: SpBindings value).  self announcer announce: (SpWidgetBuilt model: self widget: adapter widget).  ^adaptercurrentlyActivated: anObject  currentlyActivated := anObjectwhenValueChangedDo: aBlock  self state whenValueChangedDo: aBlockexecute  self evaluateSelectionAndDo: [:result |  self printObject: result ]buildWidget  ^SpSpinnerMorph newminWidth  ^self lookupProperty: SpStyleGeometry valueOf: #minWidthtestSelectWidgetIndexRaisesSelectionIndexChangeEventOnce  | counter |  counter := 0.  presenter selection whenChangedDo: [:selection |  counter := counter + 1 ].  self adapter selectIndex: 1.  self assert: counter equals: 1rootNodeHolder  ^tree rootNodeHoldertestWhenClimbRateChangedDo  | count result |  count := 0.  presenter whenClimbRateChangedDo: [:value |  count := count + 1.        result := value ].  presenter climbRate: 1.  self assert: count equals: 1.  self assert: result equals: 1action: aBlock  ^self button action: aBlocklinkSplittersToSplitters  self splitters do: [:each |  each splitsTopAndBottom ifTrue: [ self splitters do: [:eachMorph |  eachMorph splitsTopAndBottom ~= each splitsTopAndBottom ifTrue: [ eachMorph layoutFrame bottomFraction = each layoutFrame topFraction ifTrue: [ each addLeftOrTop: eachMorph ].                          eachMorph layoutFrame topFraction = each layoutFrame bottomFraction ifTrue: [ each addRightOrBottom: eachMorph ] ] ] ] ifFalse: [ self splitters do: [:eachMorph |  eachMorph splitsTopAndBottom ~= each splitsTopAndBottom ifTrue: [ eachMorph layoutFrame rightFraction = each layoutFrame leftFraction ifTrue: [ each addLeftOrTop: eachMorph ].                          eachMorph layoutFrame leftFraction = each layoutFrame rightFraction ifTrue: [ each addRightOrBottom: eachMorph ] ] ] ].        each comeToFront ]action: aBlock  action := aBlockfromSpec: aSpec  self addItem: [:item |  item fromSpec: aSpec ]initialize  super initialize.  selectedIndex := 0registerEvents  displayBlock whenChangedDo: [ self changed: #displayBlockChanged ].  resizable whenChangedDo: [ self changed: #resizableChanged ].  headerLabel whenChangedDo: [ self changed: #headerLabelChanged ].  headerFont whenChangedDo: [ self changed: #headerFontChanged ].  headerIcon whenChangedDo: [ self changed: #headerIconChanged ]okButton  ^windowPresenter addButton: 'Ok' do: [:presenter |  presenter triggerOkAction.        presenter close ]add: modelGetter withSpec: aSymbol origin: originPoint corner: cornerPoint offsetOrigin: ooPoint offsetCorner: ocPoint  commands add: (SpLayoutAddWithSpec subwidget: modelGetter spec: aSymbol layoutFrame: ((originPoint corner: cornerPoint) asSpLayoutFrame                 topLeftOffset: ooPoint;                 bottomRightOffset: ocPoint))testStringColumnsShouldBeNonEditable  self assert: (self adapter isNonEditableRow: 4 column: 1)textPresenter  ^textPresenterupdateItemFilterBlockWith: block  ^block ifNotNil: [ widget           enableFilter: (SpFTSpecFilter block: block);           explicitFunction ] ifNil: [ self updateSearch ]defineOutputPorts  ^{SpSelectionPort new .   SpActivationPort new}buildButtonFor: item  ^self theme newButtonIn: widget for: item getState: nil action: #performMenuActionWith: arguments: {widget} getEnabled: #isEnabled label: (IconicListItem text: item name icon: item icon) help: item descriptiongtInspectorSubPresentersIn: composite  < gtInspectorPresentationOrder: 20>  composite tree     title: 'Sub presenters';     rootsExpanded;     display: [:each |  {each} ];     children: [:each |  each presenters ];     when: [:each |  each presenters isNotEmpty ]copyAllChangesFrom: source to: destination  destination assimilateAllChangesFoundIn: sourceinitialize  super initialize.  self     name: 'Print';     description: 'Print the contact book in Transcript.'enabled: aBoolean  self widget ifNotNil: [:w |  w enabled: aBoolean ]basicAdd: aPresenter constraints: constraints to: aPanel  | childMorph |  childMorph := self buildMorph: aPresenter constraints: constraints.  constraints isPlacedAtStart ifTrue: [ aPanel submorphs first addMorphBack: childMorph ] ifFalse: [ aPanel submorphs second addMorphBack: childMorph ].  aPanel height: (aPanel height max: childMorph height).  aPanel width: (aPanel width max: childMorph width).  ^childMorphlabel  ^labelname: anObject  name := anObjectleftOffset: aNumber  ^layoutFrame leftOffset: aNumbertestAutoscale  self presenter image: self imageForm.  self presenter autoScale: false.  self deny: self adapter hasImageAutoscaled.  self presenter autoScale: true.  self assert: self adapter hasImageAutoscaledrightOffset  ^layoutFrame rightOffsetlist  ^listhasAnyBaseline  ^self baseLines notEmptyinitializeWindow: aWindowPresenter  aWindowPresenter initialExtent: (900 min: self currentWorld extent x) @ (550 min: self currentWorld extent y)from: aPresenter port: aSymbol  self fromPort: (aPresenter outputPortNamed: aSymbol)minWidth: aNumber  self minExtent: aNumber @ self minExtentOrDefault ymultiSelection: aBoolean  tree multiSelection: aBooleanbuttonWithIconOnly  ^buttonWithIconOnlyhasToolBar  self deprecated: 'Use #hasToolbar instead. cf https://www.dictionary.com/browse/toolbar' transformWith: '`@receiver hasToolBar' -> '`@receiver hasToolbar'.  ^self hasToolbarbuildWidget  ^DiffMorph new     on: self;     from: self leftText to: self rightText contextClass: self contextClass;     hResizing: #spaceFill;     vResizing: #spaceFill;     setBalloonText: self help;     showOptions: self showOptions;     leftLabel: self leftLabel rightLabel: self rightLabel;     showOnlyDestination: self showOnlyDestination;     yourselfmethods: aList  self listModel items: aListremoveOnlyLastSelected: aBoolean  removeOnlyLastSelected value: aBooleanbasicAdd: aPresenter constraints: constraints to: aPanel  | childMorph |  childMorph := self buildMorph: aPresenter constraints: constraints.  childMorph     hResizing: #spaceFill;     vResizing: #spaceFill.  aPanel scrollTarget: childMorph.  ^childMorphinitializePresenters  firstButton := self instantiate: SpButtonPresenter.  secondButton := self instantiate: SpButtonPresenter.  self initializeButtons.  self focusOrder     add: firstButton;     add: secondButtonselectedChangeSetIndex  ^changesListPresenter selectedIndexbasicLayout: aMorph in: aRect  | computation morphs innerBounds origin |  morphs := aMorph submorphs.  innerBounds := aRect insetBy: self padding.  computation := (SpMorphicGridLayoutComputation layout: self) computeMorphs: morphs bounds: innerBounds.  origin := innerBounds origin.  morphs do: [:each |  self layoutMorph: each staringAt: origin withComputation: computation ]step  self model steptestNullPresentersInstVarNamesAndPresenterNamesArray  builder     modelObjects: {1 .         2 .         3};     presenter: SpCheckBoxPresenter configuredAs: [:presenter :modelObject |   ];     buildDynamicPresenter;     createNullPresenters: 3.  self assertCollection: builder nullPresentersInstVarNamesAndPresenterNamesArray equals: #(var4 #SpNullPresenter var5 #SpNullPresenter var6 #SpNullPresenter)giveFocusToPreviousFrom: aModel  ^self model giveFocusToPreviousFrom: aModelisHorizontal  ^falseshowOptions: aBoolean  showOptions := aBooleantestPasswordIsSetInWidget  presenter bePassword.  self assert: self adapter isPasswordinspectObject: anObject  anObject inspectdisplayValueOf: anObject  ^self display value: anObjectbeVertical  isHorizontal := falseblock  ^blockbeForCode  self deprecated: 'The forCode functionality has moved to TextCodePresenter, please use it instead TextPresenter.' on: '2019-04-05' in: #Pharo8selectedIndex  ^listModel selection selectedIndexsetRigidityOfNonExpandedMorph: aMorph  aMorph     hResizing: #spaceFill;     vResizing: #rigidadapter  backendForTest openInstanceOf: self.  ^presenter adapterdeleteIfPopUp: evt  beNotExpandable  expandable := falseexpand: aBoolean  expand := aBooleanproperty: aSymbol returnsValueOf: anObject  themeOverrideDict at: aSymbol put: anObjectpriorVersionOfAMethod: aChangeRecord  | index mylist |  mylist := referencesList sorted: [:a :b |  a timeStamp > b timeStamp ].  index := mylist indexOf: aChangeRecord.  ^mylist at: index + 1 ifAbsent: [ aChangeRecord ]whenAutoScaleChangeDo: aBlockClosure  self property: #autoScale whenChangedDo: aBlockClosurecentered  centered := truenodeModel  ^nodeModelselectPage: aPage  aPage = self selectedPage ifTrue: [ ^self ].  selectedPage := aPagetestSmokeCreates  self presentercompareTo: anOtherVersion withLabel: aLabel  | versions texts |  versions := Array with: anOtherVersion with: self selectedMessage.  texts := (DiffMorphChangeRecordConverter methodReference: anOtherVersion referencesList: versions) getText.  SpDiffPresenter new     title: ('Comparison from {1} to {2}' format: {versions second stamp .               aLabel});     leftText: texts first;     rightText: texts second;     openWithSpecinsert: aString at: positionIndex  | text |  text := self getText.  text := (text copyFrom: 1 to: positionIndex) , aString , (text copyFrom: positionIndex + 1 to: text size).  self model text: textwhenSelectionIndexChanged: aBlock  self dropList whenSelectionIndexChanged: aBlockisSearchEnabled  ^searchEnabledinitializePresenters  tree := self newTree.  inputField := self newTextInput.  button := self newButton.  tree rootNodeHolder: [:item |  (tree defaultNodeFor: item)           matchTokenFilterBlock: [:aFilter |  aFilter token ifEmpty: [ true ] ifNotEmpty: [ item asString asLowercase includesSubstring: aFilter token asLowercase ] ];           yourself ].  button     label: '';     icon: (self iconNamed: #smallFindIcon);     state: false;     action: [ inputField accept ].  inputField     placeholder: 'Search';     entryCompletion: nil;     acceptOnCR: true.  self focusOrder     add: tree;     add: inputFieldtestSearchWithFunction  self presenter searchMatching: [:item :textToSearch |  (item - 1) asString beginsWith: textToSearch ].  self selectIndex: 1.  self adapter typeForSearch: '2'.  self deny: self selectedIndex equals: 2.  self adapter typeForSearch: '2'.  self assert: self selectedIndex equals: 3presenters  ^layout presentersmoveElementAt: index to: newIndex  | elementToMove |  (newIndex between: 1 and: self items size) ifFalse: [ ^self ].  elementToMove := list itemAt: index.  self items     remove: elementToMove;     add: elementToMove beforeIndex: newIndex.  self refresh.  self list selectIndex: newIndexisMenuPresenter  ^truecheckSplitters  self widgetDo: [:w |  w checkSplitters ]labelHolder  self deprecated: 'Nobody should access directly to internals of Spec. Now this variable is not a value holder anymore.'layout  ^layoutincomingTransmission: anObject from: aTransmission  self destinationPresenter setModel: anObjectcreateReleaseVersion  self hasAnyBaseline ifFalse: [ UIManager default inform: 'Please, define a baseline first'.        ^self ].  ^self createVersionForBlessing: #releaseadd: aBlock withSpec: aSpec top: top bottom: bottom left: left right: right  | layout |  layout := self computeLayoutFromTop: top bottom: bottom left: left right: right.  self add: aBlock withSpec: aSpec origin: layout first corner: layout second offsetOrigin: layout third offsetCorner: layout fourthautoRefreshOnExpand  ^autoRefreshOnExpand valueselectedObject  ^self selectedElement valueunselectIndex: anInteger  self selection unselectIndex: anIntegerclassToTest  ^SpDropListExamplevisitCommand: aCmCommand  aCmCommand displayIn: stack top do: [:item |  self fillItem: item with: aCmCommand ]doItContext  ^self model doItContextbeError  self type: SpNotificationType errorinitialExtent  | fontWidth rowHeight |  fontWidth := StandardFonts defaultFont widthOfString: 'M'.  rowHeight := self class inputTextHeight.  ^90 @ 24 * (fontWidth @ rowHeight)newRow: aBlock top: top bottom: bottom  | layout |  layout := self computeLayoutFromTop: top bottom: bottom left: nil right: nil.  self newRow: aBlock origin: layout first corner: layout second offsetOrigin: layout third offsetCorner: layout fourthlessOptionsText: aText  lessOptionsText := aTextdefineInputPorts  ^{SpModelPort new}initialExtent: anExtent  initialExtent := anExtenttestSubscribeBlockWithoutParametersIsCalled  | called |  called := false.  point property: #x whenChangedDo: [ called := true ].  point x: 17.  self assert: calledselector  ^nilwhenMinChangedDo: aBlock  self property: #min whenChangedDo: aBlockeditor  self flag: 'This is wrong! How can we edit text/code from text/code presenters?'.  self flag: 'Class name is wrong: it also applies to text and not only to code!'.  ^context adapter widget textArea editorlessOptionsText  ^lessOptionsTexttitle  ^'Text editor'shortcutGroup  ^shortcutGroupmenuItems  ^self model menuItemsbuildWidget  ^TabManagerMorph new     model: self model;     setTabs: self getTabs;     when: #tabSelected send: #tabSelected: to: self;     vResizing: #spaceFill;     hResizing: #spaceFill;     yourselfpadding  ^paddingprintDescription: item  self refreshDescription: itemconnectPresenters  filterField whenTextChangedDo: [:text |  clearFilterButton enabled: text isNotEmpty.        self setFilter: text ].  clearFilterButton action: [ filterField text: '' ]buttonWithHelp  ^buttonWithHelpconfigure: anApplication  OSPlatform current configureApplication: anApplication configuration: selfincreasedValueFrom: aString  | newValue |  newValue := aString ifEmpty: [ 0 ] ifNotEmpty: [:text |  text asNumber + self model climbRate ].  newValue := self inBounds: newValue.  ^self model isInteger ifTrue: [ newValue rounded asString ] ifFalse: [ newValue printShowingDecimalPlaces: self model digits ]marks  ^marksobjectChanged  self text doItReceiver: self object.  self text ifNotNil: [:w |  w behavior: self object class ].  self tree roots: self rootsisPlaceAtEnd  ^self isPlaceAtStart nottestPushModelUsesPresenterBlock  | subpresenter |  self presenter presenterBlock: [:model |  subpresenter := SpNullMillerPresenter on: (SpLabelPresenter new label: model asString) ].  self presenter pushModel: 1.  self assert: self presenter presenters first equals: subpresenterisSpLayout  ^truetoolbar  [ self deprecated: 'The way dialogs uses toolbars changed in Pharo 8 and this way is deprecated. 		Before the dialog bar had one or two buttons: Ok and Cancel, but they where not configurable. Now the user can add itself multiple buttons and configure their action more easily.		So here is how the new way works:		If you do not override the method #initializeDialogWindow: in your dialog, two default buttons will be added: "Ok" and "Cancel". You can then configure their actions with the #okAction: and #cancelAction: selectors.		If you do not want those default buttons you can override #initializeDialogWindow: and use this new API:		aWindow 		addButton: ''Debug''		do: [ :presenter | self accept. presenter close ];		addButton: ''Ignore'' 		do: [ :presenter | presenter close ]. 	' ].  ^SpDeprecatedSpecToolbarHelper for: selfinput: anObject  input := anObject.  self focusOrder add: inputtoolBar  ^toolBartestScrollUpToNegativeIndexScrollsTopToFirstIndex  self flag: #pharo7.  SystemVersion current major < 8 ifTrue: [ self skip ].  presenter items: (1 to: 500).  presenter verticalAlignment desiredVisibleRow: 100.  self openInstance.  presenter verticalAlignment desiredVisibleRow: -1.  self assert: presenter verticalAlignment firstVisibleRowIndex equals: 1testClickRaisesChangedEvent  | activated |  activated := false.  presenter whenChangedDo: [ activated := true ].  self emulateLeftClick.  self assert: activatedinitialize  super initialize.  self listCentering: #left.  self indentBy: self class indenthandleMethodRemoved: anAnnouncement  | item selection removeItem |  self isDisplayed ifFalse: [ ^self ].  refreshingBlock ifNil: [ ^self ].  self okToChange ifFalse: [ ^self ].  item := anAnnouncement method.  (item methodClass notNil and: [ item methodClass isObsolete not ]) ifFalse: [ ^self ].  selection := messageList selectedIndex.  removeItem := self selectedMessage.  (removeItem notNil and: [ removeItem methodClass = item methodClass and: [ removeItem selector = item selector ] ]) ifTrue: [ textModel hasUnacceptedEdits: false ].  self messages: (self messages           remove: item asFullRingDefinition ifAbsent: [ nil ];           yourself).  self setSelectedIndex: selectionwhenSelectionChangedDo: aBlockClosure  list whenSelectionChangedDo: aBlockClosuredisplayBlock: aBlock  self deprecated: 'Please use #display: instead' transformWith: '`@receiver displayBlock: `@arg' -> '`@receiver display: `@arg'.  displayBlock := aBlockbuildWithSpec  ^self buildWithSpecLayout: self retrieveDefaultSpecwhenDeactivationActionChangedDo: aBlock  self property: #actionWhenDeactivated whenChangedDo: aBlockfocusPrevious  self presenter withWindowDo: [:window |  | presenters |        presenters := window allPresentersInFocusOrder.        (presenters before: self presenter ifAbsent: [ presenters last ]) takeKeyboardFocus ]testJulianDaysIntervalFor4  | interval |  interval := calendar julianDaysIntervalFor: (Date year: 2018 month: 9 day: 30).  self     assert: interval size equals: calendar daysToDisplayCount;     assert: interval equals: ((Date year: 2018 month: 8 day: 26) julianDayNumber to: (Date year: 2018 month: 10 day: 6) julianDayNumber)browseVersions  self selectedClass ifNotNil: [:class |  self selectedSelector ifNotNil: [:selector |  | method |              method := self createRingMethodForSelector: selector inClass: class.              self model browseVersionsFrom: method ] ]testSelectionExecutesBlock  | selected |  self presenter dropListItems: (#(10 20 30) collect: [:e |  SpDropListItem on: e do: [ selected := e ] ]).  self presenter selectItem: 20.  self assert: selected equals: 20isHorizontal  ^self direction = SpLayoutDirection horizontalnewPresenter: aPresenterClass  ^aPresenterClass newApplication: selftestNullPresentersNeededFor  self assert: (layout nullPresentersNeededFor: presentersBuilder) equals: 0onDesactivation  ^onDesactivationtestSelectPathOutsideRangeUnsetsSelectedPath  presenter selectPath: #(4).  self assert: presenter selection selectedPath equals: #()presenterAt: aName  ^self basicPresenters at: aNametestFirstVisibleRowIsInitiallyFirstRow  presenter items: (1 to: 500).  self openInstance.  self assert: presenter verticalAlignment firstVisibleRowIndex equals: 1clickAtPath: aPath  self selectPath: aPath.  activateOnSingleClick ifFalse: [ ^self ].  self doActivateAtPath: aPathwindow: aWindow  window := aWindowconstraintsClass  ^SpLayoutConstraintsdescription  ^self host longPrintStringLimitedTo: 2000bottomFraction: aNumber  ^0asKMCategory  ^SpKMCategoryBuilder new     visit: self;     kmCategoryadapterBindings  ^adapterBindingsaddTitle: aString  self deprecated: 'Use #title: instead.' transformWith: '`@receiver addTitle: `@argument' -> '`@receiver title: `@argument'.  self title: aStringcanDiscardEdits  ^trueentryCompletion: anEntryCompletion  ^self input entryCompletion: anEntryCompletionrowSpacing: anObject  rowSpacing := anObjectclose  checkboxInput  ^checkboxInputcontainer: aTreePresenter  container value: aTreePresenterinitialize  super initialize.  buttons := OrderedCollection new.  cancelled := true.  self initializeDefaultActionspageClass  ^SpDemoLabelledPresenterinitializePresenters  tabManager := self newNotebook.  tabManager     addPage: self exampleTab;     addPage: self codeTabsetUp  super setUp.  command := SpCommand newsend: aSelector  self send: aSelector withArguments: #()testSetSelectPathRaisesSelectionChangeEventWithSelectedPath  | selectedPath |  presenter whenSelectionChangedDo: [:selection |  selectedPath := selection selectedPath ].  presenter selectPath: #(1 2).  self assert: selectedPath equals: #(1 2)displayBlock  ^displayBlock valuetestWhenPagesChangedDo  | counter |  counter := 0.  self assertEmpty: presenter pages.  presenter whenPagesChangedDo: [ counter := counter + 1 ].  presenter addPage: self mockPage.  self assert: counter equals: 1title  ^titlenotifyPropertyChanged: aName  self flag: #todo.  (self observablePropertyNamed: aName) valueChangedbuildWidget  | tableMorph |  tableMorph := FTTableMorph new     hResizing: #spaceFill;     vResizing: #spaceFill;     intercellSpacing: self class intercellSpacing;     yourself.  self addModelTo: tableMorph.  ^tableMorphpreferedPaneColor  ^self model preferedPaneColoritemAt: index of: anArray then: path  | element |  element := anArray at: index.  ^path ifNotEmpty: [ self itemAt: path first of: (self childrenFor: element) then: path allButFirst ] ifEmpty: [ element ]emulateClick: mouseButtonCode onTest: anAdapterTest  anAdapterTest openInstance.  MouseButtonEvent yellowButton = mouseButtonCode ifTrue: [ anAdapterTest adapter rightClicked ].  MouseButtonEvent redButton = mouseButtonCode ifTrue: [ anAdapterTest adapter clicked ]layout: aLayout  widget ifNil: [ widget := PanelMorph new           layoutPolicy: SpMorphicOverlayLayout new;           hResizing: #spaceFill;           vResizing: #spaceFill;           color: Color transparent;           borderColor: Color transparent;           yourself ].  super layout: aLayoutbrowseSenders  SystemNavigation new browseSendersOf: rgMethod selector name: 'Senders of ' , rgMethod selector autoSelect: rgMethod selectorselectedTab  ^selectedTab valuetitle  ^'OpenOnNilExample'testShouldAcceptInteger  presenter     beInteger;     minimum: 90;     maximum: 120.  self assert: (adapter shouldAccept: '').  self assert: (adapter shouldAccept: '100').  self deny: (adapter shouldAccept: '100.10').  self deny: (adapter shouldAccept: '80').  self deny: (adapter shouldAccept: '150').  self deny: (adapter shouldAccept: 'string').  self deny: (adapter shouldAccept: '10string')prepareWithinContext: anObject  behavior := anObject behaviorclose  self windows copy do: #closeinitializePresenters  dynamicPresenter := self newNullPresenter.  self rebuildDynamicPresenterkeepTreeNode: aNode  ^falsepresenters  ^self basicPresenters valueslayout: aLayout  number1Label  ^number1LabelsecondSelection: anItem  tree secondSelection: anItembrowseSendersOfMessages  self model browseSendersOfMessagesFrom: self selectedSelectormenu: aValuable  menu := aValuablelabel  self subclassResponsibilitybrowseMethod  self currentMethod ifNotNil: [:method |  method browse ]createPackage  | name |  name := UIManager default request: 'Name of package:'.  name isEmptyOrNil ifTrue: [ ^self ].  RPackageOrganizer default registerPackageNamed: name.  MCWorkingCopy forPackage: (MCPackage new name: name)unselectItem: anInteger  self unselectIndex: (self indexOfItem: anInteger)actualClass  ^SpMorphicNumberInputFieldAdapterpresenters  ^self basicPresenters valuesaddCellMorph: morph column: aTableColumn  aTableColumn isExpandable ifFalse: [ morph           hResizing: #rigid;           width: (aTableColumn width ifNil: [ morph width ]) ].  cell addMorphBack: morphinitializeBindings  self allAdapters do: [:each |  bindings at: each adaptingName put: each name.        each adaptingAliases do: [:eachAlias |  bindings at: eachAlias put: each name ] ]digits  ^digitsselectedObject: anObject  self list setSelectedIndex: 1.  self list listItems withIndexDo: [:item :index |  item value == anObject ifTrue: [ self list setSelectedIndex: index ] ]classToTest  ^SpLabelledContainernewMorph  ^self instantiate: SpMorphPresenterinitializeButtons  applyTo: aMorph  aMorph setProperty: #style toValue: self.  self styles do: [:each |  each applyTo: aMorph ]basicAssociatedRadioButtons: aCollection  associatedRadioButtons := aCollection copyWithout: selfitems: items  items ifNotEmpty: [ self numberOfColumns: (displayBlock value: items first) size ].  super items: itemscolor  ^self model colorinspectionMenu: aMenu  self     exploreSubMenu: aMenu;     browseSubMenu: aMenu;     customSubMenu: aMenu;     endSubMenu: aMenu;     errorSubMenu: aMenuitemBlock  ^[ self item ]selectIndexes: aCollection  | indexes |  indexes := (aCollection collect: [:each |  self withinRangeIndex: each ]) asSet.  (indexes isNotEmpty and: [ indexes allSatisfy: [:each |  each = 0 ] ]) ifTrue: [ ^self ].  indexes := indexes reject: [:each |  each = 0 ].  indexes = self selectedIndexes asSet ifTrue: [ ^self ].  ^selectedIndexes := indexes asOrderedCollectioninitializePresenters  = anObject  self == anObject ifTrue: [ ^true ].  self class = anObject class ifFalse: [ ^false ].  ^host == anObject hosthost: anObject  host := anObjecttestRowColorsAfterBuild  treeWithItems buildWithSpec.  treeWithItems oddRowColor: Color red.  treeWithItems evenRowColor: Color green.  self assert: treeWithItems adapter widget rowColors equals: (Array with: Color green with: Color red)rangeMinimum: minNumber maximum: maxNumber  self minimum: minNumber.  self maximum: maxNumbernewPanel  ^Morph new     changeTableLayout;     hResizing: #spaceFill;     vResizing: #spaceFill;     color: Color transparent;     borderColor: Color transparent;     clipSubmorphs: true;     beSticky;     borderWidth: 0;     extent: 0 @ 0;     yourselfaddSpecialFields: elements  elements add: (DynamicEyeElement host: self object label: 'hex' description: [ self object printStringRadix: 16 ] value: [ self object ]).  elements add: (DynamicEyeElement host: self object label: 'octal' description: [ self object printStringRadix: 8 ] value: [ self object ]).  elements add: (DynamicEyeElement host: self object label: 'binary' description: [ self object printStringRadix: 2 ] value: [ self object ]).  (self object between: 0 and: 16r10FFFF) ifTrue: [ elements add: (DynamicEyeElement host: self object label: 'character' description: [:value |  value printString ] value: [ self object asCharacter ]) ]label: aStringOrImageMorph  label := aStringOrImageMorphapplyStyleTo: aString  ^self subclassResponsibilityclimbRate  ^climbRatetestInstVarNames  builder modelObjects: {3 .         2 .         1}.  self assertCollection: builder instVarNames hasSameElements: #(var1 var2 var3)isColumnHomogeneous  ^columnHomogeneousbindModel: aTabModel andWidget: aWidget  aWidget when: #tabSelected send: #tabSelected to: aTabModel.  aTabModel actionsHolder whenChangedDo: [:new |  aWidget actions: new ].  aTabModel closeableHolder whenChangedDo: [:new |  aWidget closeable: new ].  aTabModel iconHolder whenChangedDo: [:new |  aWidget icon: new ].  aTabModel labelHolder whenChangedDo: [:new |  aWidget label: new ].  aTabModel menuHolder whenChangedDo: [:new |  aWidget menu: new ].  aTabModel morphHolder whenChangedDo: [:new |  aWidget morph: new ].  aTabModel retrievingBlockHolder whenChangedDo: [:new |  aWidget retrievingBlock: new ].  aTabModel selectedHolder whenChangedDo: [:new |  aWidget selected: new ]initialize  updating := false.  super initializeclassToTest  ^SpNotebookPresentertestWhenHelpChanged  presenter help: 'label1'.  presenter whenHelpChangedDo: [:new :old |  self assert: old equals: 'label1'.        self assert: new equals: 'label2' ].  self assert: presenter help equals: 'label1'.  self openInstance.  presenter help: 'label2'.  self assert: presenter help equals: 'label2'setUp  super setUp.  self error: 'Do not override me.... use #initializeTestedInstance'testBuildAdapterForBindings  | layout |  layout := SpAbstractWidgetLayout for: #ListAdapter.  self assert: (layout buildAdapterFor: SpListPresenter new bindings: SpStubAdapterBindings new) widget class equals: SpStubListViewwhenPlaceholderChanged: aBlock  self property: #placeholder whenChangedDo: aBlocksetCurrentChangeSet  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  self model setCurrentChangeSet: self selectedChangeSet.  self updateWindowTitlehasOwner  ^self owner notNilrootNodeFor: item  | node |  node := self rootNodeHolder cull: item.  node container: self.  ^nodebrowseSelectedObjectClassHierarchy  self selectedObjectDo: [:anObject |  anObject class browseHierarchy ]dropEnabled: aBoolean  dropEnabled := aBooleanadapterBindings  ^self backend adapterBindingswhenImageChangeDo: aBlockClosure  self property: #image whenChangedDo: aBlockClosurewhenChangedDo: aBlock  self subclassResponsibilityexecute: state  buttonGroup unselectAll.  self beSelected.  self action cull: state cull: selfwhenRootsChangedDo: aBlock  rootsHolder whenChangedDo: aBlockwhenAboutToStyleBlockChangedDo: aBlock  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8testColumnsAreExplicitlySetEvenIfDisplayBlockContainsMoreItems  self assert: presenter columns size equals: 2firstButton  ^firstButtontitle: aString  ^DisplayScreen hostWindowTitle: aStringwhenDeactivatedDo: aBlock  self whenChangedDo: [:bool |  bool ifFalse: aBlock ]isAboutToStyle  self deprecated: 'Use #okToStle instead' transformWith: '`@receiver isAboutToStyle' -> '`@receiver okToStyle'.  ^self okToStyletestBeNotPasswordIsSet  presenter bePassword: false.  self deny: presenter isPasswordwhenCanDeselectByClickChangedDo: aBlock  canDeselectByClick whenChangedDo: aBlockgetText  self deprecated: 'This method is an horrible hack because the VersionBrowser was using Code or Diff presenter but was only using the APIof the Code presenter... This method and other methods from the CodePresenter APIwill be removed.'.  ^self rightTextokToChange  self flag: #TODO.  self presenter canDiscardEdits ifTrue: [ ^true ].  self changed: #wantToChange.  ^self canDiscardEditswhenActivatedDo: aBlock  activationBlock := aBlockvSpaceFill  self subclassResponsibilitypresenter  ^presenterdefaultOnce: aButton  aButton privateSetState: true.  self currentActivated: aButtonadapt: aPresenter bindings: adapterBindings  | adapter |  adapter := self adapterFor: aPresenter bindings: adapterBindings.  adapter adapt: aPresenter.  ^adaptersetModal: aWindow  self widgetDo: [:w |  w spSetModal: aWindow ]fromPort  ^fromPortsetSelection: aBoolean  selected := aBoolean.  self changed: #isSelectedinitialize  super initialize.  self beResizeableprivateSetState: aBoolean  self deprecated: 'Do not use it'.  state := aBoolean.  self changed: #stateselectedIndex: anIndex  self deprecated: 'Use #selectIndex: instead' transformWith: '`@receiver selectedIndex: `@arg' -> '`@receiver selectIndex: `@arg'.  self selectIndex: anIndexnewCode  ^self instantiate: SpCodePresenterinitializePrivateAnnouncer  announcer := Announcer newisSortable  ^self model isSortabletestSubscribeToEventDoesNotRaiseEvent  presenter selection whenChangedDo: [:selection |  self fail ]icon  ^icon valuesetSelectedIndex: anIndex  self deprecated: 'Use #selectedIndex: instead' transformWith: '`@receiver setSelectedIndex: `@argument' -> '`@receiver selectedIndex: `@argument'.  ^self selectIndex: anIndextestUnselectNonSelectedIndexRaisesNoEvent  | counter |  counter := 0.  presenter     selectIndex: 1;     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectIndex: 2.  self assert: counter equals: 0testSelectPathsAddsItemsToSelectedItemList  | paths |  paths := {#(1 2) .   #(2 2)}.  presenter selectPaths: paths.  self assert: (presenter selection includesItems: {3 .               6})buildWidget  | panelMorph |  panelMorph := PanelMorph new     changeTableLayout;     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #spaceFill;     cellInset: self class defaultItemSeparation;     height: self class defaultHeight;     yourself.  self addModelTo: panelMorph.  ^panelMorphaction: aBlock  action := aBlockheight  ^self lookupProperty: SpStyleGeometry valueOf: #heightinitializePresenters  button1 := self newButton.  button2 := self newButton.  button1     label: 'Open 1';     action: [ SpDemoModal1Presenter new openModalWithSpec ].  button2     label: 'Open 2';     action: [ SpDemoModal2Presenter new openModalWithSpec ]tabSelected  tabSelectedActionHolder value cull: selfname  ^name ifNil: [ self class portName ]initialize  super initialize.  pagesHolder := OrderedCollection new asValueHolder.  pagesHolder whenChangedDo: [ self pagesChanged ]bottomOffset  ^layoutFrame bottomOffsetpageClass  ^SpDemoLinksPresentertearDown  instance ifNotNil: [ instance close.        instance := nil ].  super tearDownbindKeyCombination: aShortcut toAction: aBlock  contextKeyBindings ifNil: [ contextKeyBindings := KMCategory new ].  contextKeyBindings addKeymapEntry: (KMKeymap shortcut: aShortcut action: aBlock).  self withAdapterDo: [:anAdapter |  anAdapter bindKeyCombination: aShortcut toAction: aBlock ]blockToPerformOnWrappers  ^blockToPerformOnWrappers valuedefaultTransferFor: passenger from: source  ^SpTransferPresenter new     transfer: passenger;     from: source;     yourselfwhenChildrenBlockChanged: aBlock  self deprecated: 'Use #whenChildrenBlockChangedDo: instead.' transformWith: '`@receiver whenChildrenBlockChanged: `@statements' -> '`@receiver whenChildrenBlockChangedDo: `@statements'.  self whenChildrenBlockChangedDo: aBlocktestUnselectAllRaisesSelectionEventOnce  | nbEvents |  nbEvents := 0.  presenter selectPath: #(1 1).  presenter whenSelectionChangedDo: [:selection |  nbEvents := nbEvents + 1 ].  presenter unselectAll.  self assert: nbEvents equals: 1acceptOnCR  ^self model acceptOnCRadd: aBlock bottom: aNumber  self add: aBlock top: nil bottom: aNumber left: nil right: nilhasPageWithModel: anObject  ^self pages anySatisfy: [:each |  each model = anObject ]footnoteArea  ^footnoteAreawhenRootsChanged: aBlock  self deprecated: 'Use #whenRootsChangedDo: instead.' transformWith: '`@receiver whenRootsChanged: `@statements' -> '`@receiver whenRootsChangedDo: `@statements'.  self whenRootsChangedDo: aBlockconfirm: queryString label: titleString  ^UIManager default confirm: queryString label: titleStringvisitCheckboxColumn: aCheckboxTableColumn  fromPresenter  ^self fromPort presenterinitialize  super initialize.  self beInteger.  self digits: self class defaultDigits.  self climbRate: self class defaultClimbRatehResizing: aBoolean  hResizing := aBooleanroots  ^self model rootslabelClickable  ^self presenter labelClickablebrowseImplementorsOfMessages  self model browseMessagesFrom: self selectedSelectorinitialize  super initialize.  text := ''.  placeholder := ''.  actionToPerform := [:txt |   ].  readSelection := [ selection ].  actionPerformed := ''.  hasUnacceptedEdits := false.  selection := 1 to: 0.  autoAccept := false.  wantsVisualFeedback := true.  askBeforeDiscardingEdits := true.  self registerEventsbuildWidget  ^SpStubMultiColumnListView newevenRowColor: aColor  evenRowColor value: aColorincomingTransmission: anObject from: aTransmission  self destinationPresenter morph: anObjectbuildWidget  ^self class newclassToTest  ^self subclassResponsibilityhasError  self withErrorsDo: [ ^true ].  ^falseiconHolder: aBlock  self deprecated: 'Use iconBlock: instead' transformWith: '`@receiver iconHolder: `@statements1' -> '`@receiver iconBlock: `@statements1'.  self iconBlock: aBlocknumber2Label  ^number2LabelonlyStrong  onlyStrong := truecolumnSpan  ^self span xradioButtonClassSide  ^radioButtonClassSidewhenTextIsAccepted: aBlock  self deprecated: 'Use #whenTextIsAcceptedDo: instead.' transformWith: '`@receiver whenTextIsAccepted: `@statements' -> '`@receiver whenTextIsAcceptedDo: `@statements'.  self whenTextIsAcceptedDo: aBlockadd: anObject properties: symbol to: aLayout  aLayout add: anObject withConstraints: [:constraints |  constraints           expand: ((properties at: symbol) at: #expanded);           fill: ((properties at: symbol) at: #filled);           padding: ((properties at: symbol) at: #padding) ]lastVisibleRowIndex  ^lastVisibleRowIndexshowOnlyDestination  ^self model showOnlyDestinationconnectPresenters  listModel whenSelectionChangedDo: [ self updateText ]interpretASpec: aSpec model: aPresenter selector: aSelector  self deprecated: 'Use `interpretASpec: aSpec presenter: aPresenter` instead' transformWith: '`@receiver interpretASpec: `@statements1 model: `@statements2 selector: `@statements3' -> '`@receiver interpretASpec: `@statements1 presenter: `@statements2'.  ^self interpretASpec: aSpec presenter: aPresentercontactBook  ^contactBookposition  ^positiondrawOn: aMorphicCanvas  self redraw.  self surface displayOnMorphicCanvas: aMorphicCanvas at: bounds originitemsLabel  ^itemsLabelsearchPresenter  ^searchPresentercircle: aSurface  ^aSurface createPath: [:builder |  builder           absolute;           moveTo: 50 @ 150;           ccwArcTo: 150 @ 250 angle: 90 degreesToRadians;           ccwArcTo: 250 @ 150 angle: 90 degreesToRadians;           ccwArcTo: 150 @ 50 angle: 90 degreesToRadians;           ccwArcTo: 50 @ 150 angle: 90 degreesToRadians ]resetListSelection  self selectIndex: 0selectionHolder  ^self observablePropertyNamed: #selectionticks  ^ticksselectedItems  ^selectedItemswantDropBlock  ^wantDropBlockwhenSelectedItemChanged: aBlock  | newBlock |  newBlock := [:item |  aBlock cull: (associationsWrapperToItem at: item ifAbsent: [ nil ]) ].  listPresenter whenSelectedItemChanged: newBlockchangeSorterLeft  ^changeSorterLeftnewDataSource  ^SpComponentListDataSource new     model: self presenter;     yourselfexplorePointers  ^Smalltalk tools pointerExplorer openStrongOn: self valueunselectAll  self selection unselectAlltoolbar: anObject  | content |  toolbar := anObject.  self removeMorph: (content := self submorphs last).  self addMorph: (self newDialogPanel           addMorphBack: content;           addMorphBack: self newButtonRow;           yourself) frame: (0 @ 0 corner: 1 @ 1)urlHolder  self deprecated: 'Nobody should access directly to internals of Spec. Now this variable is not a value holder anymore.'pathFromIndex: anInteger  | item |  item := self allShownItems at: anInteger ifAbsent: [ ^#() ].  ^self pathOfItem: item root: rootItemtransferSubscriptionsTo: aSpValueHolder  aSpValueHolder subscriptions: subscriptionstopOffset  ^topOffsettestAddingAnItemSelectsItIfThereIsNone  self presenter addItemLabeled: 40 do: [  ].  self assert: self presenter selectedItem equals: 40.  self assert: self adapter selectedIndexes equals: #(4)iconName: aSymbol  iconHolder value: (self iconNamed: aSymbol)addPresenterIn: widgetToBuild withSpecLayout: aSpec  actForSpec  UIManager default inform: self messageText.  self flag: #TODOwhenSelectedItemsChangedDo: aBlock  selectionHolder whenChangedDo: [:col |  aBlock cull: (col collect: [:e |  e content ]) ]askBeforeDiscardingEdits  ^askBeforeDiscardingEditsbuildWidget  ^SpStubDiffView newlistSize  ^self model sizeshouldShowInTree  ^falsebottom  ^bottompages  ^pagesHolder valueinitializePresenters  < script: 'self new openWithSpec'>  table := self newTable     addColumn: (SpCompositeTableColumn new           title: 'Classes';           addColumn: (SpImageTableColumn evaluated: #systemIcon) beNotExpandable;           addColumn: (SpStringTableColumn evaluated: #name);           yourself);     items: Smalltalk allClassesAndTraits;     itemFilter: [:each :pattern |  each crTrace.        each asLowercase includesSubstring: pattern asLowercase ];     yourselfwidgetDo: aBlock  ^self widget ifNotNil: aBlockcheckboxFor: anItem  ^associationsItemToWrapper at: anItem ifAbsent: [ nil ]model  ^modelhasSyntaxHighlightEnabled  ^(self widget textArea editingMode isKindOf: RubPlainTextMode) notneedRebuild  ^needRebuildautoDeselect  self deprecated: 'Should not use. This feature is not supported anymore'.  ^autoDeselectselectedItems: aCollection  selectionHolder value: aCollectionsetUp  super setUp.  presenter     beMultipleSelection;     items: #(10 20 30)removeSubWidgets  inputPortDefault  ^self inputPorts firstunscaledInitialExtent  ^15 @ 26iconBlock  ^[:each |  self iconFor: each ]defaultTitle  ^'Change Sorter'prepareWithinContext: anObject  nullPresentersNeededFor: aDynamicPresentersListBuilder  ^self rowsCount - ((aDynamicPresentersListBuilder modelObjects size - 1) % self rowsCount + 1)applyTo: aMorph  self subclassResponsibilitytoolbar: anObject  toolbar := anObjectclassToTest  ^SpOpenOnStringExamplematchTokenFilterBlock: aBlock  matchTokenFilter value: aBlockspacing: aNumber  layout spacing: aNumbergenerateUniqueInstanceVariableName  instVarCount := instVarCount + 1.  ^(#var , instVarCount asString) asSymbolsourceIntervalOf: aSelector in: aMethodNode  | senderNode |  senderNode := aMethodNode allChildren detect: [:x |  x isMessage and: [ x selector = aSelector ] ] ifNone: [ ^#() ].  ^senderNode keywordsPositions first to: senderNode keywordsPositions last + senderNode keywords last size - 1initializePresenters  label := self instantiate: SpLabelPresenter.  check := self instantiate: SpCheckBoxPresenter.  input := self instantiate: SpTextInputFieldPresenter.  button := self instantiate: SpButtonPresenter.  button     label: 'reset';     action: [ input text: textToReset ].  check     label: 'Label on top';     state: falsewhenActionChangedDo: aBlock  self property: #action whenChangedDo: aBlocktransferFor: passenger from: source  ^(self transferBlock cull: passenger cull: self model) buildWithSpecprintString  ^wrapped printStringeventKeyStrokesForNextFocus  ^{Character tab asKeyCombination}canBeExecuted  ^self context isContactSelectedwhenIconsChanged: aBlock  self deprecated: 'Use #whenIconsChangedDo: instead' transformWith: '`@receiver whenIconsChanged: `@argument' -> '`@receiver whenIconsChangedDo: `@argument'.  self whenIconsChangedDo: aBlockrowsCount  ^rowsCounttestClassIsDisplayedWithCorrectAlignment  | presenter table |  presenter := SpBoxLayoutWithTableForTestPresenter new.  instance := presenter openWithSpec.  table := presenter table adapter widget.  self assert: instance window left <= table left.  self assert: table left <= table submorphs first leftcontext  ^contextresetSelection  self deprecated: 'Please use #unselectAll instead' transformWith: '`@receiver resetSelection' -> '`@receiver unselectAll'.  self unselectAllinitializePresenters  table1 := self newTreeTable.  table1     addColumn: (SpCompositeTableColumn new           title: 'Classes';           addColumn: ((SpImageTableColumn evaluated: #systemIcon)                 width: 20;                 yourself);           addColumn: (SpStringTableColumn evaluated: #name);           yourself);     addColumn: (SpStringTableColumn title: 'Number of subclasses' evaluated: [:class |  class subclasses size asString ]);     addColumn: (SpStringTableColumn title: 'Number of methods' evaluated: [:class |  class methods size asString ]);     roots: {Object};     children: [:aClass |  aClass subclasses ];     beResizable;     contextMenu: self menu;     activateOnDoubleClick;     whenActivatedDo: [:selection |  selection selectedItem browse ]sliderInput  ^subwidgetwhenItemsChangeDo: aBlockClosure  self     property: #leftItems whenChangedDo: aBlockClosure;     property: #rightItems whenChangedDo: aBlockClosurerowInset  ^rowInset valuetitle: aString  title := aStringautoAccept: aBoolean  autoAccept := aBooleandoItContext  ^nilwithoutSyntaxHighlight  self syntaxHighlight: falsemethodAdded: anAnnouncement  UIManager default defer: [ self handleMethodAdded: anAnnouncement ]newTabSelectorMorph  ^SpNotebookTabSelectorMorph new     vResizing: #shrinkWrap;     hResizing: #spaceFill;     cellInset: self class tabCellInset;     yourselfstate  ^self presenter statesetModelBeforeInitialization: aMethod  self setRGMethodFrom: aMethoddeleteDiscardingChanges  | announcement |  announcement := SpWindowWillClose new     window: self;     yourself.  self announce: announcement.  self currentWorld announcer announce: announcement.  ^super deleteDiscardingChangesnewSplitter  ^SpPanedResizerMorph newHorizontaladoptPaneColor: paneColor  self assureExtension.  extension fillStyle ifNil: [ self color: paneColor ].  self borderStyle baseColor: paneColor darker.  self submorphsDo: [:m |  m adoptPaneColor: paneColor ]resizerWidth: anInteger  resizerWidth value: anIntegerinitializeSemaphore  uiWaitingSemaphore := Semaphore newon: aShortcut do: aBlock  self deprecated: 'Use #bindKeyCombination:toAction: instead.' transformWith: '`@receiver on: `@statements1 do: `@statements2' -> '`@receiver bindKeyCombination: `@statements1 toAction: `@statements2'.  self bindKeyCombination: aShortcut toAction: aBlockitems: aCollection  model collection: aCollectionroots  ^self childrenForObject: self objectinitialize  super initialize.  columns := OrderedCollection new: 2buttonWithIcon  ^buttonWithIconfastForward  ticks := highestValuetestUnselectSelectedItemRaisesSelectionEventOnce  | counter |  counter := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectItem: 10.  self assert: counter equals: 1buildWidget  ^self autoRefresh ifTrue: [ self buildWidgetAutoRefresh ] ifFalse: [ self buildWidgetNoRefresh ]keyText: aString  self flag: #TODO.  self shortcut: aString first metawhenDrawBlockChangedDo: aBlockClosure  self property: #drawBlock whenChangedDo: aBlockClosureurlDuringClickColor  ^self urlHoverColor darkerinitializeTestedInstance  redTab := self redMorphTabbrowseMethodFull  self selectedClass ifNotNil: [:myClass |  Smalltalk tools browser openOnClass: myClass selector: self selectedSelector ]homogeneous: aBoolean  homogeneous := aBooleancanDeselectByClick  self deprecated: 'This option is removed in Spec 2'.  ^falseinitializeWindow: aWindowPresenter  super initializeWindow: aWindowPresenter.  aWindowPresenter     title: self title;     windowIcon: self taskbarIcon;     askOkToClose: truesortingBlock  ^self model sortingBlocktestSetSortingBlockBeforeItems  | count |  count := 0.  presenter whenSortingBlockChangedDo: [:sortFunction |  count := count + 1 ].  presenter sortingBlock: #yourself ascending.  presenter items: #(3 8 1 0).  self assert: count equals: 1.  self assert: (presenter model at: 1) equals: 0testOpenDialogWindowAddsItToWindowCollection  | window |  window := (application newPresenter: SpButtonPresenter) openDialogWithSpec.  self assert: (application windows includes: window)buildWidget  | notebookMorph |  notebookMorph := SpNotebookMorph new     vResizing: #spaceFill;     hResizing: #spaceFill;     setBalloonText: self help;     yourself.  self addModelTo: notebookMorph.  self model whenPagesChangedDo: [:pages |  self updatePagesWith: pages ].  self model whenSelectedPageChangedDo: [:page |  self selectPage: page ].  ^notebookMorphbindKeyCombination: aShortcut toAction: aBlock  add: aBlock withSpec: aSpec top: aNumber  self add: aBlock withSpec: aSpec top: aNumber bottom: nil left: nil right: niltestSelectIndexAddsItemToSelectedItemList  presenter selectIndex: 1.  self assert: (presenter selection includesItem: 10)extent: aPoint  ^self widget extent: aPointtabs  ^tabsgetIconFor: anItem  ^self model getIconFor: anItemwhenRootsChangedDo: aBlockClosure  self property: #roots whenChangedDo: aBlockClosuresetSourceContentWith: content  isShowingDiff ifTrue: [ (content isText or: [ content isString ]) ifTrue: [ sourcePresenter leftText: ''.              sourcePresenter rightText: content ] ifFalse: [ sourcePresenter leftText: content first.              sourcePresenter rightText: content second ] ] ifFalse: [ sourcePresenter text: content ]mouseDown: anEvent from: aMorph  aMorph color: self urlDuringClickColorlabel: aText  label := aTexttopOffset: aNumber  layoutFrame topOffset: aNumbertypeForSearch: aString  self type: aStringdelete  self widgetDo: [:w |  w delete ]initialize  | wheelImageMorph |  super initialize.  self color: Color transparent.  wheelImageMorph := self newSpinnerMorph.  transformationMorph := TransformationMorph new asFlexOf: wheelImageMorph.  self addMorph: transformationMorphinspectHistoryItem: historyItem  self inspector: historyItem keymenu  ^menubindKeyCombination: aShortcut toAction: aBlock  banana  ^42testDecreasedValueFrom  presenter     beInteger;     minimum: 80;     climbRate: 2.  self assert: (adapter decreasedValueFrom: '85') equals: '83'.  self assert: (adapter decreasedValueFrom: '81') equals: '80'.  self assert: (adapter decreasedValueFrom: '80') equals: '80'.  presenter     beFloat;     climbRate: 2.5;     digits: 1.  self assert: (adapter decreasedValueFrom: '85') equals: '82.5'.  self assert: (adapter decreasedValueFrom: '81') equals: '80.0'whenStateChangedDo: aBlock  self property: #state whenChangedDo: aBlockwhenSelectedItemChanged: aBlock  self dropList whenSelectedItemChanged: aBlockmodelChanged  x text: self model x asString.  y text: self model y asStringrowInset  ^self model rowInsetconnectPresenters  classListPresenter transmitTo: methodListPresenter transform: [:class |  class methods sort: #selector descending ] postTransmission: [:destination |  destination selectIndex: 1 ].  methodListPresenter transmitTo: textPresenter transform: [:method |  method ifNil: [ '' ] ifNotNil: #sourceCode ] postTransmission: [:destination :origin :transmited |  transmited ifNotNil: [ destination behavior: transmited methodClass ] ]stepTime  ^self presenter stepTimefixedPercentage: aNumber  self fixedAt: aNumber / 100registerMethodShortcuts: aWidget  aWidget bindKeyCombination: PharoShortcuts current browseShortcut toAction: [ self selectedSelector ifNotNil: [ self browseMethodFull ] ].  aWidget bindKeyCombination: $d meta toAction: [ self selectedSelector ifNotNil: [ self forgetMessage ] ].  aWidget bindKeyCombination: PharoShortcuts current browseImplementorsShortcut toAction: [ self selectedSelector ifNotNil: [ self browseImplementorsOfMessages ] ].  aWidget bindKeyCombination: PharoShortcuts current browseSendersShortcut toAction: [ self selectedSelector ifNotNil: [ self browseSendersOfMessages ] ].  aWidget bindKeyCombination: PharoShortcuts current browseVersionsShortcut toAction: [ self selectedSelector ifNotNil: [ self browseVersions ] ].  aWidget bindKeyCombination: PharoShortcuts current removeShortcut toAction: [ self selectedSelector ifNotNil: [ self removeMessage ] ]setUp  super setUp.  presenter     beSingleSelection;     items: #(10 20 30)adapterFor: aPresenter bindings: adapterBindings  ^self class environment at: (adapterBindings translateSymbol: self adapterName) ifPresent: [:class |  class owner: aPresenter ] ifAbsent: [ self error: 'No binding for ' , self adapterName , ' found.' ]list: anObject  list := anObjecttraverseInFocusOrderDo: aBlock excluding: excludes  self presenter traverseInFocusOrderDo: aBlock excluding: excludeshandleMethodModified: anAnnouncement  | item oldItem sel index text list edits |  self isDisplayed ifFalse: [ ^self ].  refreshingBlock ifNil: [ ^self ].  item := anAnnouncement newMethod.  oldItem := anAnnouncement oldMethod.  sel := self selectedMessage.  sel ifNil: [ ^self ].  (sel methodClass = oldItem methodClass and: [ sel selector = oldItem selector ]) ifFalse: [ ^self ].  (self shouldRefreshItem: item fromAnnouncement: anAnnouncement) ifFalse: [ ^self ].  edits := textModel hasUnacceptedEdits.  edits ifTrue: [ text := textModel pendingText ].  index := messageList selectedIndex.  list := self messages     remove: sel ifAbsent: [  ];     add: item asFullRingDefinition;     yourself.  self messages: list.  self setSelectedIndex: index.  edits ifFalse: [ ^self ].  textModel pendingText: text.  textModel hasEditingConflicts: trueborderWidth: width  presenter: aPresenter  presenter := aPresenterhasIcons  ^iconBlock isNotNil and: [ self model collection anySatisfy: [:e |  e icon isNotNil ] ]arguments  subwidgetArguments ifNil: [ subwidgetArguments := self subwidgetArguments ].  ^{{subwidgetArguments .   #layout: .   self generateSpec}}whenShortcutsChanged: aBlock  self deprecated: 'This event does not has sense in Spec2'unselectAll  self selectIndex: 0testSelectIndexesTwiceAddsIndexesToSelectedIndexListOnlyOnce  presenter     selectIndexes: {1 .         2};     selectIndexes: {1 .         2}.  self assertCollection: presenter selection selectedIndexes hasSameElements: {1 .         2}layoutProperties: props  self widgetDo: [:w |  w layoutProperties: props ]accessorCode  ^'(self basicAt: ' , self index asString , ')'testSpanRow  | layout |  self place: label1 at: 1 @ 1.  self place: morph1 at: 2 @ 1 span: 1 @ 2.  self place: label2 at: 1 @ 2.  self place: morph2 at: 3 @ 2.  layout := self newLayout.  layout layout: panel in: (0 @ 0 corner: 100 @ 100).  self assert: label1 bounds equals: (0 @ 0 corner: 50 @ 20).  self assert: morph1 bounds equals: (50 @ 0 corner: 100 @ 40).  self assert: label2 bounds equals: (0 @ 20 corner: 50 @ 40).  self assert: morph2 bounds equals: (100 @ 20 corner: 150 @ 40)whenHasChildrenBlockChangedDo: aBlock  hasChildrenBlockHolder whenChangedDo: aBlockselectLine  self withAdapterDo: [:anAdapter |  anAdapter selectLine ].  ^self selectionIntervalbold  ^bolddisplay: aBlock  displayBlock := aBlocktransmitDo: aBlock transform: transformBlock  self newTransmission     from: self;     do: aBlock;     transform: transformBlock;     applytransferFor: passenger from: source  ^self model transferFor: passenger from: sourceicon  ^iconbuildWidget  | datasource |  datasource := SpMorphicListDataSource new.  datasource model: self model.  widget := FTTableMorph new     dataSource: datasource;     hideColumnHeaders;     enableSearch;     beResizable;     columns: {self newListColumn};     setMultipleSelection: self model isMultipleSelection;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     setBalloonText: self help;     hResizing: #spaceFill;     vResizing: #spaceFill;     onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self;     onAnnouncement: FTStrongSelectionChanged send: #strongSelectionChanged: to: self;     yourself.  self presenter whenModelChangedDo: [ widget refresh ].  self presenter whenSelectionChangedDo: [ self refreshWidgetSelection ].  self presenter selection whenChangedDo: [ self refreshWidgetSelection ].  self presenter whenSearchChangedDo: [ self updateSearch ].  self refreshWidgetHeaderTitle.  self refreshWidgetSelection.  self presenter whenItemFilterBlockChangedDo: [:block |  self updateItemFilterBlockWith: block ].  self updateItemFilterBlockWith: self itemFilter.  self configureScrolling.  widget bindKeyCombination: Character space toAction: [ self model clickOnSelectedItem ].  ^widgetaddShortcutTipFor: aString  ^self addShortcutTipFor: self shortcutCharacter on: aStringtestRemoveTabFromMorphic  presenter addTab: redTab.  self openInstance.  self assertCollection: presenter tabs hasSameElements: {redTab}.  presenter removeTab: redTab.  self assertCollection: presenter tabs hasSameElements: #().  self assertCollection: (self morphicTabsFor: presenter) hasSameElements: #()mouseDownAction: aBlock  mouseDownAction value: aBlockname: aString  name := aStringloremIpsum  ^String loremIpsum: 2854initialize  model := ChangeSorterModel new.  SystemAnnouncer uniqueInstance weak when: CurrentChangeSetChanged send: #updateTitle to: self.  super initialize.  self initializeAnnouncementsinteractionModel  ^selftestUnselectUnselectedPathKeepsSelectionList  presenter     selectPath: #(1 2);     unselectPath: #(2 2).  self assert: presenter selection selectedPaths equals: {#(1 2)}value: aNumber  value = aNumber ifTrue: [ ^self ].  value := aNumbermakeNewForm  ^(Form extent: 30 @ 30 depth: 32) fillColor: self colorcontainer  ^containerbuildLayout  ^self layoutBuilder buildFor: selfstyle  ^SpMorphStyle fromStylesheet: self styleSheet adapter: selftext: aText  ^self input text: aTexttestInitializeProtocolListShouldSelectedItemSetToAll  self assert: biChooseMethod selectedProtocol name equals: '-- all --'initializeWidgets  super initializeWidgets.  description := self newTextlabel: aString  label := aStringicon  ^icontestAutoScale  | count result |  count := 0.  presenter whenAutoScaleChangeDo: [:value |  result := value.        count := count + 1 ].  presenter autoScale: true.  self assert: count equals: 1.  self assert: resulttestShouldAcceptFloatWithMaxDigits  presenter     beFloat;     minimum: 0;     maximum: 120;     digits: 5.  self assert: (adapter shouldAccept: '1.1111').  self assert: (adapter shouldAccept: '1.11111').  self deny: (adapter shouldAccept: '1.111111')testConvertRandomSymbolOfClassToInstance  | symbol instance |  symbol := #MenuRegistration.  instance := specInterpreter convertSymbolOfClassToInstance: symbol.  self assert: instance class name equals: symboleventKeyStrokesForPreviousFocus  ^{Character arrowLeft command ctrl asKeyCombination}newPanel  ^super newPanel     extent: 1 @ 1;     yourselfisMultipleSelection  ^falsepadding: aNumber  padding := aNumberchangeSetMenu  ^self newMenu     title: 'Change Set';     addGroup: [:aGroup |  aGroup           addItem: [:anItem |  anItem                 name: 'Make changes go to me';                 shortcut: $m meta;                 action: [ self setCurrentChangeSet ] ];           addItem: [:anItem |  anItem                 name: 'New change set...';                 shortcut: $n meta;                 action: [ self newSet ] ];           addItem: [:anItem |  anItem                 name: 'Find...';                 shortcut: $f meta;                 action: [ self findChangeSet ] ] ];     addGroup: [:aGroup |  aGroup           addItem: [:anItem |  anItem                 name: 'Rename change set';                 shortcut: $r meta;                 action: [ self rename ] ];           addItem: [:anItem |  anItem                 name: 'File out';                 shortcut: $o meta;                 action: [ self fileOut ] ];           addItem: [:anItem |  anItem                 name: 'Browse methods';                 shortcut: $b meta;                 action: [ self browseChangeSet ] ];           addItem: [:anItem |  anItem                 name: 'Browse change set';                 shortcut: $B meta;                 action: [ self openChangeSetBrowser ] ];           addItem: [:anItem |  anItem                 name: 'Add/Edit preamble';                 shortcut: $p meta;                 action: [ self addPreamble ] ];           addItem: [:anItem |  anItem                 name: 'Remove preamble';                 action: [ self removePreamble ] ];           addItem: [:anItem |  anItem                 name: 'Add/Edit postscript...';                 action: [ self editPostscript ] ];           addItem: [:anItem |  anItem                 name: 'Remove postscript';                 action: [ self removePostscript ] ] ];     addGroup: [:aGroup |  aGroup addItem: [:anItem |  anItem                 name: 'Destroy change set';                 shortcut: $x meta;                 action: [ self remove ] ] ];     yourselfselectionChanged  self changed: #selectionChanged with: #()inspectionSubMenu: aMenu  aMenu addGroup: [:aGroup |  aGroup addItem: [:item |  item                 name: 'Inspect' translated;                 action: [ self inspectSelectedObjectInNewWindow ];                 shortcut: $i meta ].        aGroup addItem: [:item |  item                 name: 'Explore' translated;                 action: [ self exploreSelectedObject ];                 shortcut: $i meta shift ].        self customMenuActions cull: aMenu cull: aGroup ]state: aBoolean  ^self presenter state: aBooleanaddPaneVSplitters  | remaining targetRight sameRight sameLeft |  remaining := paneMorphs reject: [:each |  each layoutFrame rightFraction = 1 or: [ each layoutFrame rightFraction = 0 ] ].  [ remaining notEmpty ] whileTrue: [ targetRight := remaining first layoutFrame rightFraction.        sameRight := remaining select: [:each |  each layoutFrame rightFraction = targetRight ].        sameLeft := paneMorphs select: [:each |  each layoutFrame leftFraction = targetRight and: [ each layoutFrame rightFraction ~= targetRight ] ].        remaining := remaining copyWithoutAll: (self addPaneVSplitterBetween: sameRight and: sameLeft) ]classToTest  ^SpListPresenterdisplay  ^displayBlockselectedPackage  ^packageList selectedItemwhenSelectedItemChanged: aBlock  self dropList whenSelectedItemChanged: aBlockproperties  ^properties ifNil: [ properties := SmallDictionary new ]testContextKeyBindings  | contextKeyBindings |  contextKeyBindings := presenter contextKeyBindings.  self assert: contextKeyBindings notNil.  self assert: (contextKeyBindings isKindOf: KMCategory)isRowHomogeneous  ^rowHomogeneoustext: aPairOfString  self deprecated: 'This method is an horrible hack because the VersionBrowser was using Code or Diff presenter but was only using the APIof the Code presenter... This method and other methods from the CodePresenter APIwill be removed.'.  (aPairOfString isText or: [ aPairOfString isString ]) ifTrue: [ self leftText: ''.        self rightText: aPairOfString ] ifFalse: [ self leftText: aPairOfString first.        self rightText: aPairOfString second ]requestWindowClose  ^trueacceptBlock: aBlockWithOneArgument  ^self input acceptBlock: aBlockWithOneArgumentwhenSelectedItemsChanged: aBlock  tree whenSelectedItemsChanged: aBlockincomingTransmission: anObject from: outPort  self action cull: anObject cull: outPorttestAddColumnRaisesOneEventOnly  | count |  count := 0.  presenter whenColumnsChangedDo: [ count := count + 1 ].  presenter addColumn: (SpStringTableColumn new evaluated: #yourself).  self assert: count equals: 1resizable  ^self model resizableinitialize  super initialize.  leftText := ''.  rightText := ''.  showOptions := true.  showOnlyDestination := false.  showOnlySource := false.  self property: #leftText whenChangedDo: [:newText |  self changed: #leftText: with: {newText} ].  self property: #rightText whenChangedDo: [:newText |  self changed: #rightText: with: {newText} ].  self property: #contextClass whenChangedDo: [:newClass |  self changed: #contextClass: with: {newClass} ].  self property: #showOptions whenChangedDo: [:aBoolean |  self changed: #showOptions: with: {aBoolean} ].  self property: #showOnlyDestination whenChangedDo: [:aBoolean |  self changed: #showOnlyDestination: with: {aBoolean} ].  self property: #showOnlySource whenChangedDo: [:aBoolean |  self changed: #showOnlySource: with: {aBoolean} ].  self property: #leftLabel whenChangedDo: [:newText |  self changed: #leftLabel: with: {newText} ].  self property: #rightLabel whenChangedDo: [:newText |  self changed: #rightLabel: with: {newText} ]testSetSelectItemRaisesSelectionChangeEventWithSelectedIndex  | selectedIndex |  presenter whenSelectionChangedDo: [:selection |  selectedIndex := selection selectedIndex ].  presenter selectItem: 20.  self assert: selectedIndex equals: 2whenMenuChanged: aBlock  self deprecated: 'Use #whenMenuChangedDo: instead.' transformWith: '`@receiver whenMenuChanged: `@statements' -> '`@receiver whenMenuChangedDo: `@statements'.  self whenMenuChangedDo: aBlockvisiblePages: aNumber  visiblePages := aNumberaddFocusRotationKeyBindings  self presenter canTakeKeyboardFocus ifFalse: [ ^self ].  self bindKeyCombination: Character tab asKeyCombination toAction: [ self focusNext ].  self bindKeyCombination: Character tab shift asKeyCombination toAction: [ self focusPrevious ]source  ^sourcecontext: anObject  context := anObjectsubwidget: aSpec layoutFrame: aLayoutFrame  subwidget := aSpec isSymbol ifTrue: [ {#presenter .         aSpec} ] ifFalse: [ aSpec isCollection ifTrue: [ aSpec isEmpty ifTrue: [  ] ifFalse: [ self flag: #todo.                    (#(#model #presenter) anySatisfy: [:symbol |  aSpec first = symbol ]) ifTrue: [ aSpec ] ifFalse: [ {#presenter} , aSpec ] ] ] ifFalse: [ aSpec ] ].  layoutFrame := aLayoutFramedescription: aBlock  descriptionBlock := aBlockpresenters  ^self itemsvisitCommand: aCmCommand  aCmCommand hasShortcutKey ifFalse: [ ^self ].  self presenter bindKeyCombination: aCmCommand shortcutKey toAction: [ aCmCommand canBeExecuted ifTrue: [ aCmCommand execute ] ]testVisitCommand  | menuItem evaluationResult |  evaluationResult := nil.  self assert: menuBuilder menuPresenter defaultGroup menuItems isEmpty.  (CmBlockCommand new     name: 'c';     description: 'desc';     context: [ 41 ];     block: [:x |  evaluationResult := x + 1 ];     yourself) asSpecCommand acceptVisitor: menuBuilder.  self assert: menuBuilder menuPresenter defaultGroup menuItems size equals: 1.  menuItem := menuBuilder menuPresenter defaultGroup menuItems first.  self assert: menuItem class equals: SpMenuItemPresenter.  self assert: menuItem name equals: 'c'.  self assert: menuItem description equals: 'desc'.  self assert: evaluationResult isNil.  menuItem action value.  self assert: evaluationResult equals: 42decreasedValueFrom: aString  | newValue |  newValue := aString ifEmpty: [ 0 ] ifNotEmpty: [:text |  text asNumber - self model climbRate ].  newValue := self inBounds: newValue.  ^self model isInteger ifTrue: [ newValue rounded asString ] ifFalse: [ newValue printShowingDecimalPlaces: self model digits ]initializePresenters  packages := self newList display: #name.  classes := self newList display: #name.  protocols := self newList display: [:aPair |  aPair value name ].  methods := self newList display: #selector.  code := self newCode.  packages transmitTo: classes transform: [:aPackage |  aPackage definedClasses asArray ].  packages transmitTo: code transform: [:aPackage |  self classTemplateFor: aPackage ].  classes transmitTo: protocols transform: [:aClass |  aClass organization allProtocols collect: [:each |  aClass -> each ] as: OrderedCollection ] postTransmission: [:destination :origin |  destination selectIndex: 1 ].  classes transmitTo: code transform: #definitionWithSlots.  protocols transmitTo: methods transform: [:aPair |  aPair value methods collect: [:each |  aPair key >> each ] as: OrderedCollection ].  protocols transmitTo: code transform: [:aPair |  aPair key sourceCodeTemplate ].  methods transmitTo: code transform: #sourceCode.  packages items: RPackageOrganizer default packagesmenu: aMenu shifted: aBoolean  ^(self model menu: aMenu shifted: aBoolean) ifNotNil: [:menuModel |  menuModel buildWithSpecAsPopup ]rightFraction  ^0newTreeTable  ^self instantiate: SpTreeTablePresenterselectedItem  self dropList selectedIteminitialize  self class initializeSlots: self.  super initialize.  value := 0addStatusBarTo: aMorph  | statusBarMorph |  statusBarMorph := self model statusBar buildWithSpec.  aMorph addMorphBack: statusBarMorph.  statusBarMorph     hResizing: #spaceFill;     vResizing: #rigidresult: anObject  result := anObjecticonNamed: aSymbol  ^self class iconNamed: aSymbolsetUp  super setUp.  presenter := self classToTest new.  self initializeTestedInstanceresetContent  self owner updatePageContent: selfselectInto: aFTTableMorph paths: aCollectionOfPaths  | indexes items |  items := aCollectionOfPaths collect: [:aPath |  | item |        item := aFTTableMorph dataSource itemAtPath: aPath expanding: true.        item ifNil: [ aFTTableMorph selectIndex: 0.              ^self ].        item ].  aFTTableMorph refresh.  indexes := items collect: [:item |  aFTTableMorph dataSource indexOfItem: item ].  aFTTableMorph selectIndexes: indexessetUp  super setUp.  label1 := Morph new.  morph1 := Morph new.  label2 := Morph new.  morph2 := Morph new.  panel := Morph new     extent: 100 @ 100;     yourself.  {label1 .   morph1 .   label2 .   morph2} do: [:each |  panel addMorphBack: each.        self style applyTo: each ]columnInset: anInteger  tree columnInset: anIntegersurface  ^surface ifNil: [ surface := AthensCairoSurface extent: self extent ]type: anObject  type := anObjectisStyleClassChar: char  ^char = $.isSortable  ^self sortFunction notNilbuildWidget  ^SpTreeColumn new     resizable: self resizable;     startWidth: self initialWidth;     setHeaderButtonLabel: self headerLabel font: self headerFont icon: self headerIcon target: self actionSelector: self performHeaderActionSelector;     rowMorphGetSelector: self displayBlockclassToTest  ^SpOpenOnNilExampletestSetSelectItemOutsideRangeRaisesSelectionChangeEventWithUnsetIndex  | selectedIndex |  presenter whenSelectionChangedDo: [:selection |  selectedIndex := selection selectedIndex ].  presenter selectItem: 40.  self assert: selectedIndex equals: 0execute  self browserClientProvider browseMethodsWithSourceString: self selection matchCase: falsebottomOffset  ^bottomOffsetelements  ^self list itemsasPresenter  ^selftestUseBackend  self assert: application backend name equals: #Mock.  application useBackend: #Morphic.  self assert: application backend name equals: #MorphictestUnselectUnselectedItemKeepsSelectionList  presenter     selectItem: 10;     unselectItem: 20.  self assert: presenter selection selectedItems asArray equals: #(10)applicationName  ^applicationName ifNil: [ applicationName := self argumentAt: 1 ]applyVisibility  self presenter ifNil: [ ^self ].  self widget visible: self presenter isVisible.  self presenter whenVisibleChangedDo: [:visible |  self presenter isVisible ifTrue: [ self widget show ] ifFalse: [ self widget hide ] ]findChangeSetIn: aCollectionOfChangeSets  | index pattern candidates nameList |  self okToChange ifFalse: [ ^self ].  pattern := UIManager default request: 'ChangeSet name or fragment?'.  pattern isEmptyOrNil ifTrue: [ ^self ].  nameList := aCollectionOfChangeSets collect: #name.  candidates := aCollectionOfChangeSets select: [:c |  (nameList includes: c name) and: [ c name includesSubstring: pattern caseSensitive: false ] ].  candidates size = 0 ifTrue: [ ^self inform: 'No matching change sets.' ].  candidates size = 1 ifTrue: [ ^candidates first ].  index := UIManager default chooseFrom: (candidates collect: [:each |  each name ]).  index = 0 ifFalse: [ ^candidates at: index ]testShowColumnHeadersShowHeaders  presenter showColumnHeaders.  self assert: presenter isShowingColumnHeadersopenModalWithSpec  self layout ifNil: [ ^super openWithSpec ].  ^self application openModal: self withSpecLayout: self layoutclearItems  leftPanel removeAllMorphs.  rightPanel removeAllMorphsuseProportionalLayout  self subclassResponsibilitychildren  ^self rows collect: [:row |  | cell |        cell := row submorphs first.        cell submorphs first ]add: aSpec height: aNumber  self add: aSpec origin: 0 @ 0 corner: 1 @ 1 offsetOrigin: 0 @ 0 offsetCorner: 0 @ aNumbermodel  ^modelclassToTest  ^SpListPresenterbuildChildren  contents := self children value collect: [:each |  | node |        node := (each isKindOf: SpTreeNodePresenter) ifTrue: [ each ] ifFalse: [ (self childNodeClassFor: each) new content: each ].        node           parentNode: self;           yourself ].  ^contentsparseAST: aString  | ast |  ast := RBParser parseFaultyMethod: aString.  ast isParseError ifFalse: [ ^ast ].  ^RBParser parseFaultyExpression: aStringchildrenItems  ^self model autoRefreshOnExpand ifTrue: [ childrenItemsBlock value ] ifFalse: [ childrenItems ifNil: [ childrenItems := childrenItemsBlock value ] ]title  ^'OpenOnIntExample'icon: anIcon  icon := anIconleftFraction: anObject  leftFraction := anObjectclassToTest  ^SpTreeTablePresentershouldAccept: aText  | regex value |  aText ifEmpty: [ ^true ].  regex := self model isInteger ifTrue: [ '(\-)?[0-9]*' ] ifFalse: [ '(\-)?[0-9]+(\.[0-9]{0,' , self model digits asString , '})?' ].  (regex asRegex matches: aText) ifFalse: [ ^false ].  value := aText asNumber.  self model minimum ifNotNil: [:min |  value < min ifTrue: [ ^false ] ].  self model maximum ifNotNil: [:max |  value > max ifTrue: [ ^false ] ].  ^trueupdateItems: toolBarMorph  toolBarMorph clearItems.  self presenter leftItems do: [:each |  toolBarMorph addItem: (self configureItem: each morph: each buildWithSpec toolBar: toolBarMorph) position: SpToolBarItemPosition left ].  self presenter rightItems do: [:each |  toolBarMorph addItem: (self configureItem: each morph: each buildWithSpec toolBar: toolBarMorph) position: SpToolBarItemPosition right ]font: aFont  self widgetDo: [:w |  w font: aFont ]testOpenDialogWindowWithDifferentApplicationDoesNotAddItToWindowCollection  | secondApplication presenterInSecondApplication windowsBefore |  secondApplication := SpApplication new.  presenterInSecondApplication := secondApplication newPresenter: SpButtonPresenter.  windowsBefore := application windows copy.  self should: [ application openDialog: presenterInSecondApplication ] raise: SpInvalidApplicationError.  self assert: application windows equals: windowsBeforeinitialize  super initialize.  childrenBlockHolder := [ {} ] asValueHolder.  hasChildrenBlockHolder := [:item |  (self childrenFor: item) notEmpty ] asValueHolder.  rootsHolder := {} asValueHolder.  selectionHolder := {} asValueHolder.  menuBlockHolder := [  ] asValueHolder.  displayBlock := [:item |  item asString ] asValueHolder.  removeOnlyLastSelected := false asValueHolder.  autoDeselection := true asValueHolder.  autoMultiSelection := false asValueHolder.  columnInset := 5 asValueHolder.  doubleClick := [  ] asValueHolder.  allowMenuOnNoItem := false asValueHolder.  isCheckList := false asValueHolder.  keyStroke := [:key |   ] asValueHolder.  multiSelection := false asValueHolder.  evenRowColor := self theme backgroundColor asValueHolder.  oddRowColor := self theme backgroundColor asValueHolder.  preferedPaneColor := self theme backgroundColor asValueHolder.  resizerWidth := 2 asValueHolder.  rowInset := 2 asValueHolder.  iconBlock := [:each :node |  node icon ] asValueHolder.  highlightedItem := nil asValueHolder.  rootNodeHolder := [:item |  SpTreeNodePresenter new     content: item;     children: [ self childrenFor: item ] ] asValueHolder.  columns := {(SpTreeColumnPresenter new displayBlock: [:node |  self wrapItem: node content ])} asValueHolder.  autoRefreshOnExpand := false asValueHolder.  self dragTransformationBlock: [:item :source |  item complexContents ].  treeUpdated := nil asValueHolder.  self registerEventswhenShowColumnHeadersChangedDo: aBlock  self property: #showColumnHeaders whenChangedDo: aBlockrefresh  self items: self itemsisVertical  ^self isHorizontal notwhenBorderColorChangedDo: aBlock  self property: #borderColor whenChangedDo: aBlockopenDialog: aPresenter  ^self openDialog: aPresenter withSpecLayout: aPresenter defaultSpecinitialize  super initialize.  self position: 50 percentcontentAreaPresenter  ^contentAreaPresenterisComposite  ^falsewhenIconsChangedDo: aBlock  self property: #icon whenChangedDo: aBlockghostText: aText  self deprecated: 'This API is too tight to Morph. Use #placeholder: instead.' transformWith: '`@receiver ghostText: `@statement' -> '`@receiver placeholder: `@statement'.  self placeholder: aTextinitialize  super initialize.  selected := falsewhenSelectedIndexChangedDo: aBlockClosure  self whenSelectionChangedDo: [:selection |  aBlockClosure cull: selection first ]date: anObject  date := anObjectplaceholder: aText  ^self input placeholder: aTextadd: aPresenter height: anInteger  self add: aPresenter withConstraints: [:constraints |  constraints height: anInteger ]itemBeginsWithFilter  self deprecated: 'Use #enableItemBeginsWithFilter instead' transformWith: '`@receiver itemBeginsWithFilter' -> '`@receiver enableItemBeginsWithFilter'.  self enableItemBeginsWithFilternotifyPropertyChanged: aName  self flag: #todo.  (self observablePropertyNamed: aName) valueChangedinitializeTestedInstance  presenter startWithoutSelection.  super initializeTestedInstancewhenActivatedDo: aBlock  self subclassResponsibilityabstractAdapterClass  ^self subclassResponsibilitysetUp  super setUp.  presenter := SpListPresenter new.  presenter items: (1 to: 10)getList  ^self model getListtestLabelChangeRaisesEventOnce  self assertWith: [:times |  times = 1 ] timesRaisedEvent: #whenChangedDo: inPresenter: presenter whenDoing: [ presenter label: 'test' ]padding  ^self layout borderWidthsetIndex: anIndex  ^self dropList setIndex: anIndexbaseLines  | existingBaselines |  existingBaselines := self configurationClass methods select: [:cm |  cm selector beginsWith: 'baseline' ].  existingBaselines := (existingBaselines collect: [:m |  m pragmas first argumentAt: 1 ]) asSortedCollection.  ^existingBaselineslastClicked  ^lastClicked valueresultPane  ^resultPaneshowSubMenuIfPresent  self model contextMenu ifNil: [ ^self ].  self showSubMenu: self model contextMenulinkRadioButton: aButton  buttons do: [:b |  aButton whenActivatedDo: [ b privateSetState: false ].        b whenActivatedDo: [ aButton privateSetState: false ] ].  aButton whenActivatedDo: [ self currentActivated: aButton ]initialize  super initializeconnectPresenters  withText whenValueChangedDo: [:value |  label label: (value * 100) asInteger asString , '%' ]buildWidget  ^SpStubTableContainerView newvalue: anObject  lock ifTrue: [ ^self ].  lock := true.  [ | oldValue |  oldValue := value.  value := anObject.  self valueChanged: oldValue ] ensure: [ lock := false ]execute  | classToBrowse |  classToBrowse := self findClassOn: self selectionOrLine trimmed.  classToBrowse ifNil: [ ^self ].  self browseClass: classToBrowsedisplay: aBlock  list display: aBlocksetWidgetLayoutWithOffset: e at: idx  | y0 y1 |  width := e offsets width.  y0 := e offsets top.  y1 := e offsets bottom.  idx = size ifTrue: [ e layoutFrame: ((1 @ 0 corner: 1 @ 1) asSpLayoutFrame                 topLeftOffset: width negated @ y0;                 bottomRightOffset: 0 @ y1) ] ifFalse: [ e layoutFrame: ((currentProportional @ 0 corner: currentProportional @ 1) asSpLayoutFrame                 topLeftOffset: currentOffset @ y0;                 bottomRightOffset: (currentOffset + width) @ y1).        currentOffset := currentOffset + width ]testAddTabSetOwner  self assert: redTab owner isNil.  presenter addTab: redTab.  self assert: redTab owner equals: presenternumColumns  ^numColumnsselectedItems  ^self selection selectedItemsaddKeyBindingsTo: aMorph  whenClimbRateChangedDo: aBlock  self property: #climbRate whenChangedDo: aBlockbuildWidget  ^SpStubPanedView newtestSelectMultipleItemsRaisesSelectionChangeEventMultipleTimes  | events |  events := 0.  presenter whenSelectionChangedDo: [:selection |  events := events + 1 ].  presenter selectItem: 10.  presenter selectItem: 30.  self assert: events equals: 2geometryValueBetween: baseNumber and: otherNumber  ^baseNumber = 0 ifTrue: [ otherNumber ] ifFalse: [ baseNumber ]testAbsoluteValue  self initMinMax.  presenter absoluteValue: 0.5.  self assert: presenter value == 50title: aTitle  title := aTitleupdateTitle  self flag: #TODO.  self withWindowDo: #updateTitleisSelected  ^selectedtestLabelIsUrlByDefault  self assert: presenter label isNil.  presenter url: 'Test'.  self assert: presenter label equals: 'Test'.  presenter label: 'Label'.  self assert: presenter label equals: 'Label'morph: anObject  widget := anObjectselectedItem  ^self selection selectedItem ifNotNil: #modelfootnoteIcon: aForm  footnoteIcon := aFormcustomSubMenu: aMenu  customMenuActions  ^[:aMenu :currentGroup |  currentGroup addItem: [:item |  item           name: 'Dive Into' translated;           action: [ self diveIntoSelectedObject ];           shortcut: $d meta ].  (history hasPrevious or: [ history hasNext ]) ifTrue: [ aMenu addGroup: [:aGroup |  history hasPrevious ifTrue: [ aGroup addItem: [:item |  item                             name: 'Back' translated;                             action: [ self inspectPrevious ];                             shortcut: $[ meta ] ].              history hasNext ifTrue: [ aGroup addItem: [:item |  item                             name: 'Forward' translated;                             action: [ self inspectNext ];                             shortcut: $] meta ] ] ] ] ]classToTest  ^SpNotebookPresenternextButton  ^nextButtonclassRenamed: anAnnouncement  UIManager default defer: [ self handleClassRenamed: anAnnouncement ]setTargetBounds  self subclassResponsibilitywhenVisiblePagesChangedDo: aBlock  self property: #visiblePages whenChangedDo: aBlocktestInstanceCreation  | aPoint presenter |  aPoint := 40 @ 54.  presenter := SpTestingPresenterWithModel on: aPoint.  self assert: presenter model equals: aPoint.  self deny: (aPoint dependents includes: presenter)classToTest  ^SpListSelectionPresenterasSpecElements  ^{self selector} , self argumentsobservablePropertyNamed: aName  | slot |  slot := self class slotNamed: aName.  slot isObservableSlot ifFalse: [ SpNonObservableSlotError signal: aName ].  ^slot rawRead: selftestSelectIndexTwiceMakesIndexSelected  presenter     selectIndex: 3;     selectIndex: 3.  self assert: (presenter selection includesIndex: 3)openModalWithSpecLayout: aSpecLayout  ^self application openModal: self withSpecLayout: aSpecLayoutbasicInspector: anEyeInspector  inspector ifNotNil: [:inspect |  inspect owner: nil ].  inspector := anEyeInspector.  anEyeInspector     owner: self;     ownerChangedcolumnInset  ^columnInset valuevalue: anInteger  value := anIntegerlabelOnRight  ^self changed: #labelOnRight with: #()endSubMenu: aMenu  aMenu addGroup: [:aGroup |  aGroup addItem: [:anItem |  anItem                 name: 'Copy Name';                 action: [ self copyAccessorCode ];                 shortcut: $c meta ] ]checkboxNormal: anObject  checkboxNormal := anObjectuseTreeInspector  self inspectorType: EyeTreeInspectorisCancelled  ^cancelledrefresh  self shouldBeImplementeddefaultSpec  ^self class perform: self defaultSpecSelectoruseBackend: aName with: aConfiguration  self useBackend: aName.  configuration := aConfiguration.  aConfiguration configure: selfactionPerformed  actionPerformed := self textinitializePresenters  super initializePresenters.  self content: SpDropListPresentertestSelectWidgetIndexRaisesSelectionIndexChangeEventOnce  | counter |  counter := 0.  presenter selection whenChangedDo: [:selection |  counter := counter + 1 ].  self adapter selectPath: #(1).  self assert: counter equals: 1color  ^colorisPartialMatch  | result |  result := false.  self children value do: [:each |  (each selected or: [ each isPartialMatch ]) ifTrue: [ result := true ] ].  ^resultdoItReceiver  self deprecated: 'This has been moved to specific presenters (check children)' on: '2019-04-15' in: #Pharo8resizingStringFor: expand  ^expand ifTrue: [ #spaceFill ] ifFalse: [ #rigid ]traverseInFocusOrderDo: aBlock excluding: excludes  self presentersInFocusOrder do: [:each |  each traverseInFocusOrderDo: aBlock excluding: excludes ]notifyPropertyChanged: aName  self flag: #todo.  (self observablePropertyNamed: aName) valueChangedtestEmptyPresenterHasEmptyAdapter  backendForTest waitUntilUIRedrawed.  self assertEmpty: self adapter childreninitializePresenter  inspectorChoice whenSelectedItemChanged: [:inspectorType |  self preventUpdatesDuring: [ self inspectorType: inspectorType ] ]setChildren: aBlock  self childrenItemsBlock: aBlockwidget: anObject  widget := anObjecttheme: anObject  theme := anObjecttestWhenWillCloseDo  | willClose closed |  willClose := false.  closed := false.  presenter whenWillCloseDo: [ willClose := true ].  presenter whenClosedDo: [ closed := willClose ].  self openInstance.  presenter close.  self assert: willClose.  self assert: closedremoveClass  (self model removeClass: self selectedClass) ifTrue: [ self setSelectedChangeSet: self selectedChangeSet ]rebuildWithSpecLayout: aSpec  self changed: #rebuildWithSpecLayout: with: {aSpec}cancel  self cancelled: truehostClass  ^host classcommands  ^commandsasSpecCommand  | command |  command := super asSpecCommand.  self shortcutKey ifNotNil: [:key |  command shortcutKey: key ].  self defaultIconName ifNotNil: [:iconName |  command iconName: iconName ].  ^commandsubtractFrom: source to: destination  source forgetAllChangesFoundIn: destinationcanChangeText  ^self widget textArea canChangeTextlayout  ^layoutmenu  ^menuinitialPosition  ^initialPositionlistModel  ^listModelcomputeColumnPositions  columnPositions := Array new: numColumns.  columnPositions at: 1 put: 0.  2 to: numColumns do: [:index |  columnPositions at: index put: (columnPositions at: index - 1) + (columnWidths at: index - 1) + self layout columnSpacing ]widget  ^self adapter widgettestShouldAcceptNegativeFloat  presenter     beFloat;     maximum: 120;     digits: 3;     minimum: -150.  self assert: (adapter shouldAccept: '-100.1').  self deny: (adapter shouldAccept: '-200.1')initializeTestedInstance  presenter     beSingleSelection;     addColumn: (SpStringTableColumn title: 'Test' evaluated: #asString);     roots: #(10 20 30)inspect: anObject  | oldInspectorType |  oldInspectorType := self inspectorType.  self     inspector: (EyeInspector inspector: anObject);     inspectorType: oldInspectorTypetextConverter  ^textConverterpageClass  self subclassResponsibilitymax  ^self presenter maxisEmpty  ^selection isEmptybuildWidget  ^PanelMorph new     changeProportionalLayout;     vResizing: #spaceFill;     hResizing: #spaceFill;     yourselferrorSubMenu: aMenu  self hasError ifFalse: [ ^self ].  aMenu addGroup: [:aGroup |  self withErrorsDo: [:accessError :itemSelector |  aGroup addItem: [:anItem |  anItem                       name: 'Debug Accessing ' , itemSelector printString , ' of ' , self accessorCode;                       icon: (self iconNamed: #smallWarningIcon);                       action: [ [ self perform: itemSelector ] fork ] ] ] ]sendersModel  ^sendersModelnewSimpleButtonMorph: aLabel color: aColor  ^SimpleButtonMorph new     label: aLabel;     color: aColor;     target: [ self inform: 'Test' ];     actionSelector: #value;     helpText: 'Button at ' , aLabel asString;     yourselfsaveBlock: anObject  saveBlock := anObjectlabel: aString  label label: aStringgetSelectionStateFor: anIndex  self deprecated: 'This method from the old API will be removed.' transformWith: '`@receiver getSelectionStateFor: `@statements' -> '`@receiver selection selectedIndexes includes: `@statements'.  ^self selection selectedIndexes includes: anIndexselectMessage: aMessage  listModel selectItem: aMessageextent  ^self columnWidths sum @ self rowHeights sumtestWhenMinimumChangedDo  | count result |  count := 0.  presenter whenMinimumChangedDo: [:value |  count := count + 1.        result := value ].  presenter minimum: 10.  self assert: count equals: 1.  self assert: result equals: 10initialize  super initialize.  displayBlock := #yourself.  icon := [:item |  nil ].  handlesDoubleClick := falsemethodShortcuts: event from: aMorph  self selectedSelector ifNotNil: [ event keyString = '<Cmd-b>' ifTrue: [ ^self browseMethodFull ].        event keyString = '<Cmd-d>' ifTrue: [ ^self forgetMessage ].        event keyString = '<Cmd-m>' ifTrue: [ ^self browseImplementorsOfMessages ].        event keyString = '<Cmd-n>' ifTrue: [ ^self browseSendersOfMessages ].        event keyString = '<Cmd-v>' ifTrue: [ ^self browseVersions ].        event keyString = '<Cmd-x>' ifTrue: [ ^self removeMessage ] ]recalculatePages: anAdaptor  ^anAdaptor recalculatePageWidthspreservePositionProportionOn: layoutedMorph  | referenceMorph |  referenceMorph := layoutedMorph submorphs first.  position := self isHorizontal ifTrue: [ (referenceMorph width * 100 / layoutedMorph width) asInteger percent ] ifFalse: [ (referenceMorph height * 100 / layoutedMorph height) asInteger percent ]addMenuTo: aMorph  | menuMorph |  menuMorph := self model menu buildWithSpec.  aMorph addMorphBack: menuMorph.  menuMorph     hResizing: #spaceFill;     vResizing: #rigidconnectPresenters  selectEntity action: [ | select |        select := self selectDialog value.        select openDialogWithSpec okAction: [ self entity: select selectedItem ] ]labelMorph: anObject  labelMorph := anObjectenabled  self deprecated: 'Please use #isEnabled instead' transformWith: '`@receiver enabled' -> '`@receiver isEnabled'.  ^self isEnabledtestHidePresenterHidesWidget  self skipsecondButton  ^secondButtonapplyStyle: aPresenter to: aMorph  self flag: #TODO.  aPresenter adapter ifNil: [ ^self ].  aPresenter adapter applyStyle: aMorphposition: anObject  position := anObjectfindClassFrom: aString  | ast |  ast := RBParser parseExpression: aString onError: [ ^nil ].  ast nodesDo: [:node |  (node isVariable and: [ node name first isUppercase ]) ifTrue: [ (self class environment classNamed: node name) ifNotNil: [:aClass |  ^aClass ] ] ].  ^nilautoScale: aBoolean  autoScale := aBooleandisplay  ^displayBlockenableSearch  searchEnabled := truehasNoOffsets  ^leftOffset = 0 and: [ rightOffset = 0 and: [ topOffset = 0 and: [ bottomOffset = 0 ] ] ]acceptBlock: aBlockWithOneArgument  actionToPerform := aBlockWithOneArgumentwhenContentChanged: aBlock  self deprecated: 'Use #whenContentChangedDo: instead.' transformWith: '`@receiver whenContentChanged: `@statements' -> '`@receiver whenContentChangedDo: `@statements'.  self whenContentChangedDo: aBlockwhenSelectionIndexChanged: aBlock  self dropList whenSelectionIndexChanged: aBlockwrapItem: anItem  ^displayBlock value cull: anItem cull: selfmethod1  testSelectItemsThenSelectOutsideRangeKeepsIndexes  presenter selectItems: {10 .         20}.  presenter selectItems: {500 .         600}.  self assert: (presenter selection includesIndexes: {1 .               2})open  self model windowIsOpening.  backdropMorph := FullscreenMorph new     color: self theme modalBackdropColor;     on: #click send: #mouseClick:onBackdrop: to: self;     openInWorld;     yourself.  self widget     toggleStickiness;     openCenteredInWorld.  [ self widget world notNil ] whileTrue: [ self widget outermostWorldMorph doOneCycle ]defer: aBlock  self backend defer: aBlockedgeName  ^self subclassResponsibilitywindow: aWindowPresenter  window := aWindowPresenterinitializeShortcuts  font  ^self lookupProperty: SpStyleFont valueOf: #definedFonttakeKeyboardFocus  self withAdapterDo: [:anAdapter |  anAdapter takeKeyboardFocus ]initializeTestedInstance  presenterAt: aName put: aPresenter  ^self basicPresenters at: aName put: aPresenterselectedIndex  ^self getIndexlistPresenter  ^listPresentercomputeLayoutFromTop: top bottom: bottom left: left right: right  | originY offsetCornerX cornerX offsetOriginY offsetCornerY cornerY originX offsetOriginX |  originX := left isFloat ifTrue: [ left ] ifFalse: [ 0 ].  originY := top isFloat ifTrue: [ top ] ifFalse: [ 0 ].  cornerX := right isFloat ifTrue: [ 1 - right ] ifFalse: [ 1 ].  cornerY := bottom isFloat ifTrue: [ 1 - bottom ] ifFalse: [ 1 ].  offsetOriginX := left isInteger ifTrue: [ left ] ifFalse: [ 0 ].  offsetOriginY := top isInteger ifTrue: [ top ] ifFalse: [ 0 ].  offsetCornerX := right isInteger ifTrue: [ right negated ] ifFalse: [ 0 ].  offsetCornerY := bottom isInteger ifTrue: [ bottom negated ] ifFalse: [ 0 ].  ^{(originX @ originY) .   (cornerX @ cornerY) .   (offsetOriginX @ offsetOriginY) .   (offsetCornerX @ offsetCornerY)}attachTransmission: aTransmission  self subclassResponsibilitybottomOffset: anObject  bottomOffset := anObjectcomputeMorphs: anArray bounds: aRect  morphs := anArray.  bounds := aRect.  self computeNumberOfRowsAndColumns.  self computeWidgetSizes.  self computeRowPositions.  self computeColumnPositions.  self computeCellExtentsitems  ^collectionhRigid  scaleInput: anObject  scaleInput := anObjecttestChangeWidgetTextUpdatesPresenter  self adapter text: 'some text'.  self assert: presenter text equals: 'some text'instVarToModelObject  ^instVarToModelObjectactualPageMorph  ^actualPageMorph ifNil: [ actualPageMorph := self lazyPageMorphCreation value           hResizing: #spaceFill;           vResizing: #spaceFill;           yourself ]buildWidget  ^SpStubTabView newaddButton: aButtonPresenter  buttons add: aButtonPresenter.  ^aButtonPresentermenuGroups  ^groupstestSelectItemThenSelectOutsideRangeKeepsFirstPath  presenter selectItem: 10.  presenter selectItem: 5000.  self assertCollection: presenter selection selectedPaths hasSameElements: #(#(1 3))rightText  ^self model rightTextsubwidget  ^subwidgetselectedItem: anItem  self selectedItems: {anItem}table: anObject  table := anObjectbuildWidget  ^SpStubCheckBoxView newbuildWidget  ^nilrowHomogeneous: anObject  rowHomogeneous := anObjecttestFiltering  presenter items: {'aa' .         'bb' .         'ab' .         'ba'}.  presenter searchPresenter text: 'a'.  self assertCollection: presenter listPresenter items hasSameElements: {'aa' .         'ab'}padding  ^padding ifNil: [ self class defaultPadding ]