pageWithModel: anObject  ^self pages detect: [:each |  each model = anObject ]classToTest  ^SpDemocolumnInset  ^self model columnInsetquantum: aNumber  quantum := aNumberaccept  self changed: #accept with: #().  self actionPerformednumber1Label: anObject  number1Label := anObjectminimize  self changed: #minimize with: #()defineOutputPorts  ^{SpTextChangedPort new}windowIcon  ^windowIconobjectChanged  self updateList.  self text doItReceiver: self object.  self description doItReceiver: self object.  self text doItContext: self doItContext.  self description doItContext: self doItContext.  self text ifNotNil: [:w |  w behavior: self objectClass ]instantiatePresenters: aCollectionOfPairs  aCollectionOfPairs pairsDo: [:k :v |  self presenterAt: k asSymbol put: (self createInstanceFor: v) ]addItem: anObject into: aToolbar  aToolbar addItemLeft: anObjectnewSpinnerMorph  ^self spinnerForm asMorphhandleMethodAdded: anAnnouncement  | item sel text boolean |  self isDisplayed ifFalse: [ ^self ].  refreshingBlock ifNil: [ ^self ].  item := anAnnouncement method.  (self shouldRefreshItem: item fromAnnouncement: anAnnouncement) ifFalse: [ ^self ].  (item methodClass notNil and: [ item methodClass isObsolete not ]) ifFalse: [ ^self ].  boolean := textModel hasUnacceptedEdits.  boolean ifTrue: [ text := textModel pendingText ].  sel := self selectedMessage.  self messages: (self messages           add: item asFullRingDefinition;           yourself).  self selectedMessage: sel.  boolean ifTrue: [ textModel pendingText: text ]instantiate: aPresenterClass on: aModel  ^aPresenterClass owner: self on: aModeladdAll: aWindow withSpecLayout: aSpec  aWindow addMorph: (self buildWithSpecLayout: aSpec) frame: (0 @ 0 corner: 1 @ 1)update: aSymbol  aSymbol == #displayBlockChanged ifTrue: [ ^self displayBlockChanged ].  aSymbol == #resizableChanged ifTrue: [ ^self resizableChanged ].  aSymbol == #headerLabelChanged ifTrue: [ ^self headerLabelChanged ].  aSymbol == #headerFontChanged ifTrue: [ ^self headerFontChanged ].  aSymbol == #headerIconChanged ifTrue: [ ^self headerIconChanged ].  ^super update: aSymbolclassToTest  ^SpOpenOnIntExamplemenu  self deprecated: 'Use #contextMenu instead.' transformWith: '`@receiver menu' -> '`@receiver contextMenu'.  ^self contextMenuspec  self flag: #TODO.  ^self adapterrightLabel: aText  self widgetDo: [:w |  w leftLabel: self leftLabel rightLabel: aText ]isHorizontal  ^truenewColumn: aBlock  self newColumn: aBlock origin: 0 @ 0 corner: 1 @ 1property: aName rawValue: anObject  (self observablePropertyNamed: aName) rawValue: anObjectinitializeTestedInstance  presenter drawBlock: [  ].  presenter surfaceExtent: 800 @ 600buildWidget  ^PluggableMultiColumnListMorph new     wrapSelector: #wrapItem:index:;     model: self;     getListSizeSelector: #listSize;     getIndexSelector: #getIndex;     setIndexSelector: #setIndex:;     getListElementSelector: #listElementAt:;     resetListSelector: #resetListSelection;     getMenuSelector: #menu:shifted:;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     setMultipleSelection: self multiSelection;     setBalloonText: self help;     hResizing: #spaceFill;     vResizing: #spaceFill;     yourselftestWhenSelectAProtocolShouldMethodListOnlyContainsMethodWithSelectedProtocol  biChooseMethod packageList selectItem: self class package.  biChooseMethod classList selectItem: self class.  biChooseMethod protocolList selectIndex: ((biChooseMethod protocolList items collect: #name) indexOf: 'running').  self assert: (biChooseMethod methodList items allSatisfy: [:method |  method category = 'running' ])minWidth: aNumber  self widgetDo: [:w |  w minWidth: aNumber ]popMessage  statusBar popMessagetestApplyTo  | styleResolver morph |  styleResolver := self newLookup: '.application [ 		Geometry { #width: 11 },		.other [			Geometry { #width: 22 },			.deep1 [				Geometry { #width: 33 }			],			.deep2 [				Geometry { #width: 42 }			]		]	]'.  morph := Morph new.  styleResolver applyTo: morph.  self assert: morph width equals: 42customizeMorphicBar: aProgressBarMorph  aProgressBarMorph value: self valuesetAnnouncingObject: aDomainObject  announcingObject := aDomainObject isSpAnnouncingObject ifFalse: [ aDomainObject asValueHolder ] ifTrue: [ aDomainObject ].  announcingObject whenChangedDo: [ self modelChanged ]visitCommandGroup: aCmCommandsGroup  aCmCommandsGroup isRoot ifTrue: [ super visitCommandGroup: aCmCommandsGroup.        ^self ].  aCmCommandsGroup displayIn: stack top do: [:specGroupOrSubMenu |  stack push: specGroupOrSubMenu.        super visitCommandGroup: aCmCommandsGroup.        stack pop ]initializePresenters  preview := self instantiate: SpImagePresenter.  sliders := self instantiate: SpRGBSliders.  preview image: (Form extent: 30 @ 30 depth: 32).  preview image: self makeNewForm.  self focusOrder add: sliderswhenAboutToStyleChanged: aBlock  self deprecated: 'Use #whenAboutToStyleChangedDo: instead.' transformWith: '`@receiver whenAboutToStyleChanged: `@statements' -> '`@receiver whenAboutToStyleChangedDo: `@statements'.  self whenAboutToStyleChangedDo: aBlockwhenHelpChanged: aBlock  self deprecated: 'Use #whenHelpChangedDo: instead.' transformWith: '`@receiver whenHelpChanged: `@statements' -> '`@receiver whenHelpChangedDo: `@statements'.  self whenHelpChangedDo: aBlockblueSlider  ^blueSliderbuildWidget  | button |  button := self newButton.  button     getEnabledSelector: #enabled;     getFontSelector: #font;     hResizing: #spaceFill;     vResizing: #spaceFill;     askBeforeChanging: self askBeforeChanging;     setBalloonText: self model help;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     eventHandler: (MorphicEventHandler new on: #keyStroke send: #keyStroke:fromMorph: to: self).  self color ifNotNil: [ self setWidgetColor: button ].  button bindKeyCombination: Character space toAction: [ self action ].  ^buttoninvokeModal  self shown: trueisForSmalltalkCode  ^falsesecondSelection: anItem  self widget ifNotNil: [:w |  w listManager secondSelection: anItem ]item: anObject  item := anObjectwithAdapterDo: aBlock  ^adapter ifNotNil: aBlockinitialize  super initialize.  roots := OrderedCollection newresetSelection  ^self dropList resetSelectionremovePreamble  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  self selectedChangeSet hasPreamble ifFalse: [ ^self inform: 'Change set has no preamble' ].  self selectedChangeSet removePreamble.  changesListPresenter setSelectedItem: self selectedChangeSetdefaultColumn  ^SpStringTableColumn new evaluated: #yourselfhasUnacceptedEdits  ^hasUnacceptedEditsadaptAsPopup: aPresenter  model := aPresenter.  aPresenter addDependent: self.  widget := self buildWidgetPopuphash  ^self label hash bitXor: action hashselectionChanged: ann  | diff selection |  selection := self presenter selection.  selection selectIndexes: (selection isMultipleSelection ifTrue: [ ann newSelectedIndexes reject: [:e |  e = 0 ] ] ifFalse: [ {(ann newSelectedIndexes ifNotEmpty: [:indexes |  indexes first ] ifEmpty: [ 0 ])} ]).  diff := ann newSelectedIndexes difference: ann oldSelectedIndexes.  (diff notEmpty and: [ self presenter activatesOnSingleClick ]) ifTrue: [ self presenter doActivateAtIndex: diff last ].  ann newSelectedIndexes ifEmpty: [ selection unselectAll ]showColumnHeaders  showColumnHeaders := trueowner  ^ownerlabel  self button labelinitialize  super initialize.  themeOverrideDict := Dictionary newtestRemoveAll  self assert: self adapter numberOfTabs equals: 2.  presenter removeAll.  self assert: self adapter numberOfTabs equals: 0selectedObjectDo: aBlock  aBlock value: self selectedObject wrappedObjecttestGenerateNullPresentersInstVarNames  builder modelObjects: {1 .         2 .         3}.  self assertCollection: (builder generateNullPresentersInstVarNames: 3) equals: #(var4 var5 var6)customizeMorphicBar: aProgressBarMorph  y: anObject  y := anObjectperformSearch: item matching: pattern  ^searchBlock value: item value: patterninitializePresenters  table := self newTable.  table     addColumn: (SpStringTableColumn title: 'Name' evaluated: #name);     addColumn: (SpStringTableColumn title: 'Phone' evaluated: #phone).  table contextMenuFromCommandsGroup: [ self rootCommandsGroup / 'Context Menu' ].  table items: contactBook contents.  menuBar := (self rootCommandsGroup / 'MenuBar') asMenuBarPresentertestUnselectPresenterItemUnselectsIndexInWidget  self skipwantsInitialization  ^trueinitializeLayout: aLayout  self initialize.  layout := aLayoutrootItem: anItem  super rootItem: anItem.  self addSourceToRootItemisNonEditableRow: aRow column: aColumn  ^(self widget dataSource cellColumn: (self widget columns at: aColumn) row: aRow) submorphs allSatisfy: [:e |  e asReadOnlyMorph == e ]menu: menu shifted: b  ^self model menu: menu shifted: bmodel  ^modelindexFor: aCheckbox  ^listPresenter listItems indexOf: aCheckboxwhenSelectionChangedDo: aBlock  self selection whenChangedDo: aBlockclassToTest  ^SpListPresentertestAddItem  presenter addItem: SpToolBarButton new.  self assert: presenter items size equals: 1transferSubscriptionsTo: anotherSelectionMode  self selectionHolder transferSubscriptionsTo: anotherSelectionMode selectionHolderfullName  ^self parent ifNotNil: [ | parentName |        parentName := self parent fullName.        parentName = 'application' ifTrue: [ self name ] ifFalse: [ parentName , '.' , self name ] ] ifNil: [ self name ]add: symbol to: aLayout  self add: symbol properties: symbol to: aLayoutlayoutValue  ^self model autoScale ifTrue: [ #scaledAspect ] ifFalse: [ #center ]notifyPropertyChanged: aName  self flag: #todo.  (self observablePropertyNamed: aName) valueChangedchildrenForObject: aNode  ^aNode children collect: [:each |  DynamicEyeElement host: aNode label: each class name description: [:node |  node formattedCode ] value: [ each ] ]buttonWithShortcut  ^buttonWithShortcutacceptColumnVisitor: aBuilder  ^aBuilder visitStringColumn: selfclassToTest  ^SpRadioButtonPresentertestUnselectSelectedIndexRemovesItFromSelectionList  presenter     selectIndex: 1;     unselectIndex: 1.  self assert: presenter selection isEmptyinspectorType  ^self inspectorWrapper inspectorTypeautoFractionComputation  self commands doWithIndex: [:e :idx |  e layoutFrame hasNoOffsets ifTrue: [ | delta |              delta := e layoutFrame rightFraction - e layoutFrame leftFraction.              self setWidgetLayoutWithNoOffset: e at: idx delta: delta ] ifFalse: [ self setWidgetLayoutWithOffset: e at: idx ] ]layoutLeftToRight: aMorph in: newBounds  self ensureWidthPosition: aMorph in: newBounds.  super layoutLeftToRight: aMorph in: newBoundslayout: aLayout  widget ifNil: [ widget := self newPanel.        widget layoutPolicy layout: aLayout ].  super layout: aLayoutcurrentValue: aNumber  currentValue := aNumberprivateAsArray  self resetArrayComputation.  self countNumberOfProportionals.  autoFractionComputation ifTrue: [ self manualFractionComputation ] ifFalse: [ self autoFractionComputation ].  self shiftLastWidgets.  ^super privateAsArraytopologicSort  ^messageList topologicSortshortcut  | shortcut |  shortcut := self model shortcut.  ^(shortcut isBlock or: [ shortcut isMessageSend ]) ifTrue: [ shortcut cull: self model ] ifFalse: [ shortcut ]recalculatePages: anAdaptor  ^anAdaptor recalculatePageHeightsbuildWidget  | textMorph iconsContainer |  textMorph := super buildWidget.  iconsContainer := Morph new     extent: 12 @ 12;     color: Color transparent;     changeTableLayout;     listDirection: #topToBottom;     addMorph: (IconicButton new           target: self;           actionSelector: #clearText;           labelGraphic: (self iconNamed: #glamorousRemove);           color: Color transparent;           extent: 16 @ 8;           borderWidth: 0;           yourself);     yourself.  textMorph     changeProportionalLayout;     addMorph: iconsContainer fullFrame: (LayoutFrame identity           bottomFraction: 0;           leftFraction: 1;           topOffset: 4;           leftOffset: -25;           yourself).  ^textMorphwhenHasChildrenBlockChanged: aBlock  self deprecated: 'Use #whenHasChildrenBlockChangedDo: instead.' transformWith: '`@receiver whenHasChildrenBlockChanged: `@statements' -> '`@receiver whenHasChildrenBlockChangedDo: `@statements'.  self whenHasChildrenBlockChangedDo: aBlocktestSetSelectItemRaisesSelectionIndexChangeEventWithSelectedIndex  | selectedIndex |  presenter selection whenChangedDo: [:selection |  selectedIndex := selection selectedIndex ].  presenter selectItem: 10.  self assert: selectedIndex equals: 1positionAt: aPoint  ^(self columnPositions at: aPoint x) @ (self rowPositions at: aPoint y)setEditingModeFor: textArea  textArea beForPlainTextedgeName  ^#rightupdateInspectorChoice  self inspectorTypes ifNotNil: [:variants |  inspectorChoice listItems = variants ifTrue: [ ^self ].        inspectorChoice items: variants ]doubleClick  self model doubleClickcolumnSpacing  ^self layout columnSpacingtopButton  ^topButtonindexOf: anIndex ifAbsent: aBlock  ^collection indexOf: anIndex ifAbsent: aBlockdefaultWidth  ^self class splitterWidthtestClickOnClassSideRadioButtonShouldFillTheMethodList  biChooseMethod packageList selectItem: SpMethodChooserMockClass package.  biChooseMethod classList selectItem: SpMethodChooserMockClass.  biChooseMethod radioButtonClassSide click.  self assertCollection: biChooseMethod methodList items hasSameElements: SpMethodChooserMockClass class methodsroots  ^rootscolumnCount  ^self widget columns sizedisplayBlock: aBlock  self deprecated: 'Please use #display: instead' transformWith: '`@receiver displayBlock: `@arg' -> '`@receiver display: `@arg'.  displayBlock := aBlocktestAddButtonToToolbar  | toolbar button |  toolbar := SpToolBarPresenter new.  button := SpToolBarButton new.  self assertEmpty: toolbar items.  CmUILeftPositionStrategy new addButton: button toToolbar: toolbar.  self assert: toolbar leftItems size equals: 1.  self assert: toolbar leftItems anyOne equals: button.  self assertEmpty: toolbar rightItemscalculateHeightFor: aMorph base: aNumber  ^aNumberwidget  self openInstance.  self currentWorld doOneCycle.  ^self adapter widgetfont  ^fonttestWhenActionChangedDo  | count result |  count := 0.  presenter whenActionChangedDo: [:block |  count := count + 1.        result := block ].  presenter action: [ 'Test' ].  self assert: result isBlock.  self assert: result value equals: 'Test'.  self assert: count equals: 1fieldDisabled: anObject  fieldDisabled := anObjectnewColumn: aBlock left: aNumber  self newColumn: aBlock left: aNumber right: nilcollapseAll  self treeModel collapseAllhasCustomSearch  ^searchBlock notNilregisterChangeActions  changesListPresenter whenSelectionChangedDo: [:selection |  self updateTextContents.        selection selectedItem ifNil: [ classesListPresenter items: {}.              methodsListPresenter items: {} ] ifNotNil: [:change |  classesListPresenter unselectAll.              classesListPresenter items: change changedClasses ] ]testFindClassOn  | command |  command := self commandToTest.  self assert: (command findClassOn: '') equals: nil.  self assert: (command findClassOn: 'Object') equals: Object.  self assert: (command findClassOn: 'Object.') equals: Object.  self assert: (command findClassOn: '.Object.') equals: Object.  self assert: (command findClassOn: 'somethingBefore := 42.Object') equals: Object.  self assert: (command findClassOn: 'somethingBefore := 42.Object. somethingAfter := 11') equals: Object.  self assert: (command findClassOn: 'NonExistingClass.Object.') equals: ObjectbuildWidget  ^SpStubTreeColumnView newresetSelection  self selection unselectAllitalic: anObject  italic := anObjectnewColumn: aBlock origin: originPoint corner: cornerPoint offsetOrigin: ooPoint offsetCorner: ocPoint  | block |  block := aBlock.  block isBlock ifFalse: [ block := [:c |  c add: aBlock ] ].  commands add: (SpLayoutAddColumn block: block layoutFrame: ((originPoint corner: cornerPoint) asSpLayoutFrame                 topLeftOffset: ooPoint;                 bottomRightOffset: ocPoint))initialize  super initialize.  label := ''.  self whenLabelChangedDo: [ self changed: #label ].  self whenIconChangedDo: [ self changed: #label ]selectAll  ^self subclassResponsibilityapplication  ^self presenter applicationlabelFor: anEyeElement error: error  ^'Error while accessing label of ' , anEyeElement accessorCode printStringitemFor: aCheckbox  ^associationsWrapperToItem at: aCheckbox ifAbsent: [ nil ]testContextMenu  | menu changed |  self assert: presenter contextMenu isNil.  menu := SpMenuPresenter new.  changed := false.  presenter whenMenuChangedDo: [ changed := true ].  presenter contextMenu: menu.  self assert: presenter contextMenu equals: menu.  self assert: changedsubmergeFrom: src into: dest  | source destination index |  source := src selectedChangeSet.  destination := dest selectedChangeSet.  index := src selectedChangeSetIndex.  (self model submerge: source into: destination) ifFalse: [ ^self ].  src updateChangesList.  src setSelectedChangeSetIndex: indextitle  ^self model titlehResizing  ^hResizinglabel  ^self externalIndex printStringapplyTo: aMorph  self borderColor ifNotNil: [:aColor |  aMorph borderColor: aColor ].  self borderWidth ifNotNil: [:aNumber |  aMorph borderWidth: aNumber ].  self padding ifNotNil: [:aNumber |  aMorph cellInset: aNumber ]testRightClickShouldNotExecuteAction  | actionExecuted |  actionExecuted := false.  presenter action: [ actionExecuted := true ].  self emulateRightClick.  self deny: actionExecutedticks: anAmount  ticks := anAmount.  highestValue := anAmount max: highestValue.  lowestValue := anAmount min: lowestValuewhenVisibleChangedDo: aBlock  self property: #visible whenChangedDo: aBlockdisplay: aBlock  displayBlock := aBlockdefineInputPorts  ^{SpLabelPort new}buildContentForPage: aPage  ^aPage retrievePresenter ifNotNil: [:presenter |  presenter owner: self presenter.        aPage layoutSpec ifNil: [ presenter buildWithSpec ] ifNotNil: [:spec |  presenter buildWithSpec: spec ] ]childrenFor: anEyeElement  ^self childrenForObject: anEyeElement valueevenRowColor  ^self model evenRowColorautoRefresh: aBlock  autoRefresh := aBlocktestChangingFromSingleToMultipleSelection  presenter beSingleSelection.  self deny: presenter isMultipleSelection.  presenter beMultipleSelection.  self assert: presenter isMultipleSelectionnewTransmission  ^SpTransmission newitems: aList  ^self dropList items: aListvalue: anObject  valueBlock := anObjectdropEnabled  ^falseoddRowColor: aColor  ^self widget rowColorForOdd: aColorconstraintsClass  ^SpOverlayConstraintswhenRootsChanged: aBlock  self property: #roots whenChangedDo: aBlockrecalculatePageHeights  | newHeight widgets height |  height := self widget height.  widgets := self childrenWidgets.  newHeight := widgets size = 1 ifTrue: [ height ] ifFalse: [ height / (layout visiblePages min: widgets size) - (layout spacing / (layout visiblePages min: widgets size)) ].  widgets reverseWithIndexDo: [:each :index |  each           top: (index - 1) * newHeight;           height: newHeight ]tempName  ^tempNameupdateList  | elements |  elements := self generateElements.  self list items = elements ifTrue: [ ^self ].  self list displayBlock: [:eyeElement |  self labelFor: eyeElement ].  self list items: elements.  self list selection selectedIndex > self list items size ifTrue: [ self list setSelectedIndex: self list listItems size ].  self list selectIndex: self list selection selectedIndex.  self list menu: [:aMenu |  self inspectionMenu: aMenu ]initialize  super initialize.  self menuPresenter: self class menuPresenterClass new.  stack := Stack new     push: self menuPresenter;     yourselfcolumnHomogeneous: anObject  columnHomogeneous := anObjectbuildWindowWithLayout: windowSpecLayout presenterLayout: presenterSpecLayout  self adapter: (windowSpecLayout asSpLayout buildAdapterFor: self bindings: SpBindings value).  self window: self adapter widget.  self addPresenterIn: self window withSpecLayout: presenterSpecLayout.  self announce: (SpWidgetBuilt model: self widget: self window).  self presenter announce: (SpWindowBuilt model: self).  ^self windowbeResizable  self isResizable: truetestSettingNilResetsGeneratesEvent  | changed |  self presenter selectItem: 10.  self presenter whenSelectionChangedDo: [ changed := true ].  self presenter selectItem: nil.  self assert: changedhasChildrenFor: anItem  ^self hasChildrenBlock cull: anItem cull: selfselectedItems  ^selectionHolder valuewhenLabelChangedDo: aBlock  self property: #label whenChangedDo: aBlocktestBeTextIsSet  presenter beText.  self deny: presenter isPasswordbeNotResizable  self isResizable: falsetestNewComponentListIsEmpty  self assertEmpty: self classToTest newtestChangingRootsResetsSelection  self presenter selection selectPath: #(2 3).  self presenter roots: #(10 11 12).  self assert: self adapter selectedItem equals: niltestUnselectNonSelectedItemDoesNotRemovesSelection  presenter     selectItem: 10;     unselectItem: 30.  self assert: presenter selection selectedItem equals: 10initializeDialogWindow: aDialog  aDialog     closeOnBackdropClick: false;     addButton: 'Validate' do: [:presenter |  self inform: 'Validate'.        presenter close ];     addButton: 'Reset' do: [:presenter |  self inform: 'This action does not close the modal' ];     addButton: 'Cancel' do: [:presenter |  self inform: 'Cancel'.        presenter close ]initialStateNotSet  initialStateSet := falsetestAction  | actionExecuted |  actionExecuted := false.  self assert: actionExecuted equals: false.  presenter action: [ actionExecuted := true ].  self openInstance.  self assert: actionExecuted equals: false.  presenter adapter action.  self assert: actionExecuted equals: truehasChildren: aBlock  hasChildren value: aBlockclassToTest  ^SpCodePresentercodeCommandGroup  | group |  group := CmCommandGroup forSpec     beDisplayedAsGroup;     yourself.  self flag: #TODO.  {SpCodeDoItCommand .   SpCodePrintItCommand .   SpCodeInspectItCommand .   SpCodeDebugItCommand .   SpCodeProfileItCommand .   SpCodeBrowseItCommand} do: [:eachClass |  group register: (eachClass forSpecContext: self) ].  ^grouptopFraction  ^layoutFrame topFractionopenWithSpec: aSelector  ^self application open: self withSpecLayout: (self retrieveSpec: aSelector)testModelSettingObjectToValueHolder  | point point2 presenter |  point := 40 @ 54.  point2 := 1 @ 0.  presenter := SpTestingPresenterWithModel on: point.  self assert: presenter announcingObject isSpAnnouncingObject.  self assert: presenter announcingObject isValueHolder.  self deny: point2 isSpAnnouncingObject.  self deny: point2 isValueHolder.  presenter model: point2.  self assert: presenter announcingObject isSpAnnouncingObject.  self assert: presenter announcingObject isValueHolder.  self assert: presenter model == point2.  self assert: presenter announcingObject announcer numberOfSubscriptions > 0autoMultiSelection: aBoolean  autoMultiSelection value: aBooleanmodel: anObject  model := anObjectmainIconPresenter  ^mainIconPresentervisitImageColumn: aTableColumn  maximum  ^maximumlabel  ^'root'shouldCopy  ^self dragHand shiftPressedinitializePresenters  explanation := self newText.  explanation text: self contenttestUnselectAll  presenter beMultipleSelection.  presenter selectAll.  self assert: (presenter selection selectedItems collect: #label as: Array) equals: #('10' '20' '30').  presenter unselectAll.  self assertEmpty: presenter selection selectedItemsadd: aBlock left: left right: right  self add: aBlock top: nil bottom: nil left: left right: rightinitializeWindow: aWindowPresenter  super initializeWindow: aWindowPresenter.  self rootCommandsGroup installShortcutsIn: aWindowPresenterreturn: anObject  self result: anObject.  self window closeicon: aForm  iconHolder value: aFormhasSelectedObject  ^self selectedElement isNotNilnotify: aSpecNotification on: aNotificationAware  self subclassResponsibilitycopySelector: selector inClass: class from: source to: destination  destination absorbMethod: selector class: class from: sourcetestActivatePresenterIsActive  presenter state: true.  self assert: presenter statetitle: aString  self deprecated: 'With Spec 2, SpPresenter was refactored to move all window management to WindowPresenter.	From now on, if you want to interact with a window you need to:	- Implement #initializeWindow: method (#initializeDialog: for dialogs) to manage window elements before the presenter is opened	- Use the method #window or #withWindowDo: to interact with windows after it has been opened.'.  self window ifNil: [ titleHolder := aString ] ifNotNil: [:window |  window title: aString ]setRigidityOfNonExpandedMorph: aMorph  aMorph     vResizing: #spaceFill;     hResizing: #rigidbuildWithSpec  ^SpMockMenu new     realMenu: super buildWithSpec;     whenShownDo: [ shown := true ];     yourselfnewButton  ^self instantiate: SpButtonPresenterclassToTest  ^SpMillerColumnPresenterevaluation: anObject  evaluation := anObjectacceptOnCR: aBoolean  ^self input acceptOnCR: aBooleanselectedItem  ^self selection selectedItemdefaultIcon  ^self application iconNamed: #arrowDownbehavior: aClass  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8subMenu  ^self newMenu     addItem: [:item |  item           name: 'Open';           icon: (self iconNamed: #openIcon);           shortcut: $o meta;           action: [ self inform: 'Open' ] ];     addItem: [:item |  item           name: 'Save';           icon: (self iconNamed: #smallSaveIcon);           shortcut: $s meta;           action: [ self inform: 'Save' ] ];     addItem: [:item |  item           name: 'Print';           shortcut: $p meta;           icon: (self iconNamed: #smallPrintIcon);           action: [ self inform: 'Print' ] ];     addItem: [:item |  item           name: 'Kill';           shortcut: $k meta;           icon: (self iconNamed: #smallCancelIcon);           action: [ self inform: 'Kill' ] ];     yourselfscrollToShowLastPage  self widget defer: [ self widget scrollToShow: innerWidget submorphs last bounds ]selectedIndexes  ^self isEmpty ifTrue: [ #() ] ifFalse: [ {self selectedIndex} ]initializeDialogWindow: aWindow  aWindow addButton: 'Ok' do: [:presenter |  self performOkAction.        presenter close ]selectedObject  ^self inspector selectedObjectintervalOf: aSelector inCommentText: aText  ^self searchedString: aSelector asString in: aTexttestWhenClassSideRadioClickShouldChangeProtocolList  biChooseMethod packageList selectItem: self class package.  biChooseMethod classList selectItem: SpMethodChooserMockClass.  biChooseMethod radioButtonClassSide click.  self assertCollection: (biChooseMethod protocolList items collect: #name) hasSameElements: SpMethodChooserMockClass class protocolstestIcon  self assert: command icon isNil.  command iconName: #add.  self assert: command icon equals: (command iconNamed: #add)selectLine  self context selectLine.  ^self selectionexploreSelectedObject  self selectedObjectDo: [:anObject |  anObject inspect ]model  ^modelexpand  ^expandselectedPageName  ^(self widget tabSelectorMorph selectedTab label submorphs detect: [:each |  each isKindOf: StringMorph ]) contentsstate: aBoolean  state := aBooleaniconBlock: aBlock  iconBlock value: aBlockacceptDropBlock: aBlock  acceptDropBlock := aBlockheaderLabel: aString  headerLabel value: aStringcurrentValue  ^currentValueisPassword  ^self widget font isKindOf: FixedFaceFontclassToTest  ^SpTablePresentersetBottomOffset: bottom for: widget borderWidth: windowBorderWidth  widget bottomFraction = 1 ifTrue: [ bottom isZero ifTrue: [ widget bottomOffset: windowBorderWidth negated ] ifFalse: [ widget bottomOffset: bottom - self splitterWidth ] ]buildWithSpecLayout: aSpecLayout  ^(self buildAdapterWithSpecLayout: aSpecLayout) widgettestSelectPathAddsIndexToSelectedPathList  presenter selectPath: #(1).  self assert: (presenter selection includesPath: #(1))acceptOnCR: aBoolean  self input acceptOnCR: aBooleanclassToTest  ^SpComponentListPresenterobservablePropertyNamed: aName  | slot |  slot := self class slotNamed: aName.  slot isObservableSlot ifFalse: [ SpNonObservableSlotError signal: aName ].  ^slot rawRead: selfisExpanded: aBoolean  self nodeModel isExpanded: aBooleanisResizable  ^isResizableproperty: aName rawValue: anObject  (self observablePropertyNamed: aName) rawValue: anObjecttestSortingBlock  | count |  count := 0.  presenter whenSortingBlockChangedDo: [:sortFunction |  count := count + 1 ].  presenter items: #(3 8 1 0).  presenter sortingBlock: #yourself ascending.  self assert: count equals: 1.  self assert: (presenter model at: 1) equals: 0label: aString  slider label: aStringtoolbarPresenter  ^toolbarPresenterwhenShowColumnHeadersChangedDo: aBlockClosure  self property: #showColumnHeaders whenChangedDo: aBlockClosurebeSingleSelection  self selectionMode: (SpTreeSingleSelectionMode on: self)textArea  self flag: #REMOVEME.  ^self adapter widgetisItalic  ^italic == trueactivatesOnDoubleClick  ^activateOnSingleClick notitemAt: anInteger  ^self model at: anIntegerpressTab  self keyPressed: Character tab asciiValue shift: false meta: false control: false option: false.  self waitUntilUIRedrawedtestWhenSelectPathTwiceThenIsListedOnceInSelectedPaths  presenter     selectPath: #(3 1);     selectPath: #(3 1).  self assertCollection: presenter selection selectedPaths hasSameElements: {#(3 1)}showOptions  ^self model showOptionstestWhenActionChangedDo  | actionModified newBlock oldBlock |  actionModified := false.  newBlock := [ 1 ].  oldBlock := presenter action.  self assert: actionModified equals: false.  presenter whenActionChangedDo: [:new :old |  self assert: old equals: oldBlock.        self assert: new equals: newBlock.        actionModified := true ].  self openInstance.  self assert: actionModified equals: false.  presenter action: newBlock.  self assert: actionModified equals: trueaddConstraits: constraints toChild: childMorph  childMorph hResizing: #spaceFill.  childMorph vResizing: #spaceFill.  childMorph setProperty: #gridConstraints toValue: constraints.  ^childMorpharray: aCollection  specArray := aCollectioninitializePresenters  entityText := self newTextInput     placeholder: self placeholder;     autoAccept: true;     entryCompletion: self entitiesEntryCompletion;     yourself.  selectEntity := self newButton     icon: (self iconNamed: #glamorousSearch);     help: 'Open a selection dialog'.  self focusOrder     add: entityText;     add: selectEntitybuttons  ^buttonscomputeSplittersIn: result  (self commands select: #isSplitter) ifNotEmpty: [:spliters |  spliters do: [:spliter |  result addAll: spliter asSpecElements ].        result add: #checkSplitters ]pagesChanged  self changed: #updatePagesvisitIndexColumn: aTableColumn  isCheckList: aBoolean  isCheckList value: aBooleanentryCompletion  ^entryCompletionwhenSelectionChangedDo: aBlock  listModel whenSelectionChangedDo: aBlocklistItems  self deprecated: 'Please use the #model instead' transformWith: '`@receiver listItems' -> '`@receiver model items'.  ^self model itemsfieldNormal: anObject  fieldNormal := anObjectinitializePresenters  firstPresenter := self newButton label: 'First'.  secondPresenter := self newButton label: 'Second'.  thirdPresenter := self newButton label: 'Third'keepTreeNode: aNode  ^aNode matchTokenFilter: selfselectedItems  ^tree selectedItemsclassToTest  ^SpMenuButtonPresenterconnectPresenters  searchPresenter whenTextChangedDo: [:newText |  searchPresenter text asLowercase ifEmpty: [ listPresenter items: baseItems ] ifNotEmpty: [:text |  listPresenter items: (baseItems select: [:element |  element asLowercase beginsWith: text ]) ] ]rootNodeFromItem: item  ^self model rootNodeFromItem: itemshowDiffMorphWithConverter: aConverter  sourcePresenter := self newDiff.  isShowingDiff := true.  self needRebuild: false.  self buildWithSpec.  self textConverter: aConverter.  sourcePresenter contextClass: self selectedMessage methodClass.  messageList selectIndex: messageList selectedIndexclassToTest  ^SpTextPresenterselectedMessage  ^listModel selection selectedItemtestStayingInactiveDoesNotRaiseChangedEvent  presenter state: false.  self denyEvent: #whenChangedDo: isRaisedInPresenter: presenter whenDoing: [ presenter state: false ]label: aString  label label: aStringselectPath: anArray  | index |  ((anArray isEmpty or: [ anArray first = 0 ]) and: [ widget selectedIndexes isEmpty ]) ifTrue: [ ^self ].  index := anArray ifNotEmpty: [ widget dataSource indexFromPath: anArray ] ifEmpty: [ 0 ].  (widget selectedIndexes includes: index) ifTrue: [ ^self ].  widget selectIndex: indextable: anObject  table := anObjectsplitterWidth  ^4namesOfDaysLabels: anObject  namesOfDaysLabels := anObjecttestUnselectNonSelectedItemRaisesNoEvent  | counter |  counter := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ counter := counter + 1 ];     unselectItem: 20.  self assert: counter equals: 0place: aMorph at: aPoint  aMorph setProperty: #gridConstraints toValue: (SpGridConstraints at: aPoint)initialize  super initialize.  self toolbarPresenter: SpToolBarPresenter newneedFullRebuild: aBoolean  self needRebuild: aBoolean.  self presentersDo: [:w |  w needRebuild: aBoolean ]add: aPresenter constraints: constraints  testUnselectUnselectedIndexKeepsSelectionList  presenter     selectIndex: 1;     unselectIndex: 2.  self assert: presenter selection selectedIndexes asArray equals: #(1)classToTest  ^SpAthensStaticPresenteradapterName  ^self subclassResponsibilityinitializePresenters  (table := self newTable)     items: Smalltalk allClassesAndTraits;     addColumn: (SpCompositeTableColumn new           title: 'Test';           addColumn: ((SpImageTableColumn evaluated: [:each |  each systemIcon ]) width: 20);           addColumn: (SpStringTableColumn evaluated: [:each |  each name ]))testSetRootModelWithoutPresenterBlockFails  self should: [ self presenter setRootModel: 1 ] raise: ErrorbuildWithSpec  ^self widgetcontextMenu: aValuable  contextMenu := aValuableselectedIndexes  self subclassResponsibilityinitializePresenters  nameLabel := self newLabel label: 'name:'.  nameTextInput := self newTextInput autoAccept: true.  surnameLabel := self newLabel label: 'surname:'.  surnameTextInput := self newTextInput autoAccept: true.  surnameTextInput placeholder: 'empty'.  number1Label := self newLabel label: 'number 1:'.  number1Input := self newNumberInput autoAccept: true.  number2Label := self newLabel label: 'number 2:'.  number2Input := self newNumberInput     autoAccept: true;     beFloat;     digits: 3;     climbRate: 0.005;     minimum: 10.005;     maximum: 20.05.  scaleLabel := self newLabel label: 'scale:'.  scaleInput := self newSlider.  passwordLabel := self newLabel label: 'password:'.  passwordInput := self newTextInput     bePassword;     autoAccept: true.  checkboxLabel := self newLabel label: 'remember me'.  checkboxInput := self newCheckBox state: true.  dateLabel := self newLabel label: 'date:'.  dateInput := self instantiate: SpDatePresenter.  dateInput display: [:item |  item yyyymmdd ].  maleButton := self newRadioButton label: 'male'.  femaleButton := self newRadioButton label: 'female'.  maleButton associatedRadioButtons: {femaleButton}.  genderButtons := Dictionary newFrom: {(#male -> maleButton) .         (#female -> femaleButton)}.  genderLabel := self newLabel label: 'gender:'.  itemsLabel := self newLabel label: 'items:'.  itemsInput := self newList.  itemsInput beMultipleSelection.  itemsInput items: self model items.  submitButton := self newButton label: 'Submit'.  restoreButton := self newButton label: 'Restore'.  self focusOrder     add: nameTextInput;     add: surnameTextInput;     add: number1Input;     add: number2Input;     add: scaleInput;     add: passwordInput;     add: checkboxInputcontextMenuFromCommandsGroup: aValuable  self contextMenu: [ aValuable value beRoot asMenuPresenter ]addColumns: aCollection  aCollection do: [:each |  self addColumn: each ]message  ^messagetestNewPresenter  | presenter |  presenter := application newPresenter: SpButtonPresenter.  self assert: presenter application equals: applicationinitialize  super initialize.  buttons := OrderedCollection new.  canDeselectByClick := false asValueHolder.  currentlyActivated := nil asValueHolderselection  ^selectiondisplayIn: aMenuPresenter do: aBlock  self displayStrategy display: self in: aMenuPresenter do: aBlockwhenSearchChangedDo: aBlock  self property: #searchEnabled whenChangedDo: aBlockbuttonDisabled  ^buttonDisabledhelp  ^self model helpmax  ^maxhasWindow: aWindow  ^self windows includes: aWindowlabel: aString  labelPresenter label: aStringbePlacedAtEnd  placedAtStart := falsetestChangeLabel  self redMorphTab.  manager addTab: presenter.  self assert: presenter label equals: 'Red Morph'.  presenter label: 'Change Before Opening'.  self assert: presenter label equals: 'Change Before Opening'.  window := manager openWithSpec.  presenter label: 'Change After Opening'.  self assert: presenter label equals: 'Change After Opening'rootNodeFromItem: item  | node |  node := (item isKindOf: SpTreeNodePresenter) ifTrue: [ item ] ifFalse: [ self rootNodeHolder cull: item ].  node container: self model.  ^node buildWithSpecbuildWidget  ^SpDialogWindow new     model: self model;     yourselfminExtentOrDefault  ^minExtent ifNil: [ 0 @ 0 ]nullPresentersInstVarNames  ^nullPresentersInstVarNamesinitializePresenters  uniformDropList := self newDropList.  heterogeneousDropList := self newDropList.  container := self newMorph.  disabledDropList := self newDropList.  container morph: PanelMorph new.  self instantiateMorphs.  self containerMorph     changeTableLayout;     listDirection: #bottomToLeft.  disabledDropList     items: #('Disabled' 'Two' 'Three');     display: [:each |  each ];     disable.  uniformDropList     items: {morph1 .         morph2 .         morph3};     display: [:m |  m color name capitalized , ' morph' ];     iconBlock: [:e |  self iconNamed: #testGreenIcon ];     whenSelectedItemChangedDo: [:m |  self containerMorph           removeAllMorphs;           addMorph: m ].  heterogeneousDropList     addItemLabeled: 'Open workspace' do: [ Smalltalk tools workspace open ] icon: (self iconNamed: #smallOkIcon);     addItemLabeled: 'Inspect current morph' do: [ uniformDropList selectedItem inspect ] icon: (self iconNamed: #testRedIcon).  uniformDropList selectIndex: 1.  self setFocusasMenuBarPresenterWith: aBlock  | builder |  builder := SpMenuBarPresenterBuilder new.  aBlock value: builder menuPresenter.  ^builder     visit: self;     menuPresenterisEditable  ^falsewhenActivatedDo: aBlock  ^self whenActionPerformedDo: aBlockselectIndex: anInteger  self selectionMode selectIndex: anIntegernewDiff  ^self instantiate: SpDiffPresenterinspectNext  history hasNext ifFalse: [ ^self ].  self inspectHistoryItem: history nextdisplayBlock: aBlock  self deprecated: 'Please use #display: instead' transformWith: '`@receiver displayBlock: `@arg' -> '`@receiver display: `@arg'.  ^self list display: aBlockinstallShortcutsIn: aPresenter  SpShortcutInstaller new     presenter: aPresenter;     visit: selfmethodNamed: methodSelector  ^(self isInstanceSideSelected ifTrue: [ self selectedClass ] ifFalse: [ self selectedClass class ]) methodNamed: methodSelectortopFraction: aNumber  layoutFrame topFraction: aNumbertestChangingLabelAffectTheWidget  presenter label: 'ALabel'.  self assert: self widget label equals: 'ALabel'resizable  ^resizable valuedropListModel  ^dropListModelclose  tabSelectedAction  ^tabSelectedActionHolder valuetestUnselectWidgetIndexRaisesSelectionIndexChangeEventOnce  | counter |  counter := 0.  self adapter selectIndex: 1.  presenter selection whenChangedDo: [:selection |  counter := counter + 1 ].  self adapter selectIndex: 0.  self assert: counter equals: 1maximum: aNumber  maximum := aNumberwhenLabelChangedDo: aBlock  self property: #label whenChangedDo: aBlocktestSelectPathRaisesSelectionChangeEventWithSelectedPath  | selectedPaths |  presenter whenSelectionChangedDo: [:selection |  selectedPaths := selection selectedPaths ].  presenter selectPath: #(1 2).  self assert: (selectedPaths includes: #(1 2))menu: aBlock  tree menu: aBlockselectedPaths  selection ifEmpty: [ ^#() ].  ^{selection}selectedItem: anItem  tree selectedItem: anItemasSpLayoutFrame  ^selfdefaultWaitDuration  ^500 milliSecondabsoluteValue  ^self sliderInput absoluteValuebeCheckList  self isCheckList: truedoItReceiver: anObject  doItReceiver := anObjectperformCancelAction  ^self cancelAction value == false ifFalse: [ cancelled := true.        owner ifNil: [ self delete ] ifNotNil: [ owner delete ] ]defaultColumn  ^SpStringTableColumn new evaluated: #yourselfprintTimeout  ^10 secondsisColumnHomogeneous  ^self layout isColumnHomogeneouscomputeSpecFrom: aSymbol  | res |  res := (aSymbol isSymbol and: [ (self isPresenterSymbol: aSymbol) not ]) ifTrue: [ | result |        result := self convertSymbolOfClassToInstance: aSymbol.        (result isKindOf: SpContainerPresenter) ifTrue: [ result := self getAdaptorWithDefaultSpecOf: result.              self presenter addDependent: result ].        result ] ifFalse: [ self class interpretASpec: aSymbol presenter: self presenter ].  selector ifNotNil: [:sel |  res selector: sel ].  ^restestDefaultRowColors  | defaultColor |  defaultColor := Smalltalk ui theme backgroundColor.  treeWithItems buildWithSpec.  self assert: treeWithItems adapter widget rowColors equals: (Array with: defaultColor with: defaultColor)selectedPageIndex: aNumber  self deprecated: 'Use #selectPageIndex: instead' transformWith: '`@receiver selectedPageIndex: `@statements1' -> '`@receiver selectPageIndex: `@statements1'.  self selectPageIndex: aNumberrightLabel: anObject  rightLabel := anObjectwhenAboutToStyleChangedDo: aBlock  self whenAboutToStyleBlockChanged: [:block :old :announcement :anAnnouncer |  aBlock cull: block value cull: old cull: announcement cull: anAnnouncer ]testFFGoesToNegativeInfinity  timeline fastForward.  self assert: timeline ticks equals: Float negativeInfinitytestRewindGoesToPositiveInfinity  timeline rewind.  self assert: timeline ticks equals: Float infinityrawValue: aValue  value := aValueokToChange  ^self hasWindow ifTrue: [ self window okToChange ] ifFalse: [ true ]whenEnabledChangedDo: aBlock  self property: #enabled whenChangedDo: aBlockwhenSelectionChanged: aBlock  self deprecated: 'Use #whenSelectionChangedDo: instead.' transformWith: '`@receiver whenSelectionChanged: `@statements' -> '`@receiver whenSelectionChangedDo: `@statements'.  self whenSelectionChangedDo: aBlockmodel: anObject  model := anObjecttestUnselectPresenterIndexUnselectsIndexInWidget  presenter     selectPath: #(1);     unselectPath: #(1).  self assert: self adapter selectedPaths isEmptyinitialWidth  ^self model initialWidthmessageListMenu  ^self newMenu     addGroup: [:aGroup |  aGroup           addItem: [:anItem |  anItem                 name: 'Browse full...';                 shortcut: $b meta;                 action: [ self selectedMethod browse ] ];           addItem: [:anItem |  anItem                 name: 'Inspect method...';                 shortcut: $i meta;                 action: [ self selectedMethod inspect ] ] ];     addGroup: [:aGroup |  aGroup           addItem: [:anItem |  anItem                 name: 'Remove method...';                 shortcut: $x meta;                 action: [ self selectedMethod removeFromSystem ] ];           addItem: [:anItem |  anItem                 name: 'Senders of...';                 shortcut: $n meta;                 action: [ model browseSendersOfMessagesFrom: self selectedMethod selector ] ];           addItem: [:anItem |  anItem                 name: 'Implementors of...';                 shortcut: $m meta;                 action: [ model browseMessagesFrom: self selectedMethod selector ] ] ];     addItem: [:anItem |  anItem           name: 'Users of...';           shortcut: $N meta;           action: [ model browseClassRefsOf: self selectedMethod methodClass ] ];     addItem: [:anItem |  anItem           name: 'Versions...';           shortcut: $v meta;           action: [ model browseVersionsFrom: self selectedMethod ] ] yourselfclick  self executebeVerticalAlignmentStart  self vAlign: SpGridAlignment startupdateBlock  ^updateBlockisShowingColumnHeaders  ^self presenter isShowingColumnHeadersmaxLength  ^maxLengthplace: aMorph at: aPoint span: spanPoint  aMorph setProperty: #gridConstraints toValue: (SpGridConstraints at: aPoint span: spanPoint)traversePresentersDo: aBlock excluding: excludes  excludes add: self.  aBlock value: selftestUnselectAllInWidgetRaisesSelectionIndexChangeEventOnce  | counter |  counter := 0.  self adapter selectIndex: 1.  presenter selection whenChangedDo: [:selection |  counter := counter + 1 ].  self adapter selectIndex: 0.  self assert: counter equals: 1subMenu  | subMenu |  subMenu := self model subMenu.  subMenu ifNil: [ ^nil ].  ^(subMenu isBlock or: [ subMenu isMessageSend ]) ifTrue: [ subMenu cull: self model ] ifFalse: [ subMenu buildWithSpecAsPopup ]absoluteValue: aFloat  absoluteValue := aFloatcodeFor: aClass  ^TonelWriter sourceCodeOf: aClassselectAll  ^self list selectAllnewPanelMorph  ^Morph new     changeTableLayout;     hResizing: #spaceFill;     vResizing: #rigid;     height: self class defaultHeight;     cellInset: self class defaultItemSeparation;     color: Color random;     yourselfobjectAsUTF8String  ^String streamContents: [:out |  | in encoder |        encoder := ZnUTF8Encoder new.        in := self object readStream.        [ in atEnd ] whileFalse: [ out nextPut: (encoder nextFromStream: in) ] ] limitedTo: 5000browseDefinitionOfSelectedShortcut  | selection action class selector |  selection := self kmTable selection selectedItem ifNil: [ ^self ].  action := selection realValue keymap action ifNil: [ ^self ].  class := action method methodClass.  selector := action method selector.  Smalltalk tools browser openOnClass: class selector: selector highlight: selection shortcutNametestSelectItemSelectsTheGivenElement  self presenter selection selectPath: #(2).  self assert: self adapter selectedItem equals: 2buildCodeKeyBindings  ^self codeCommandGroup asKMCategorymethod3  resetSelection  ^self dropList resetSelectiontestAddPresenterToComponentListRaisesEvent  | button raised |  raised := false.  button := SpButtonPresenter new.  presenter whenPresentersChangedDo: [ raised := true ].  presenter addPresenter: button.  self assert: raisedclassOrMetaClass: aClass  self setEditingModeFor: self widget withBehavior: aClasstestSetSelectItemOutsideRangeDoesNotModifySelection  presenter whenSelectionChangedDo: [:selection |  self fail ].  presenter selectItem: 100testPresenterProvidedByConfiguredAs  | block |  self     assert: builder presenterBlock isNil;     assert: builder configurationBlock isNil.  block := [:p :m |   ].  builder presenterProvidedBy: [:integer |  integer even ifTrue: [ SpButtonPresenter ] ifFalse: [ SpLabelPresenter ] ] configuredAs: block.  self     assert: (builder presenterBlock value: 1) equals: SpLabelPresenter;     assert: (builder presenterBlock value: 2) equals: SpButtonPresenter;     assert: builder configurationBlock equals: blockaddInstancesVariable: elements  self object class allInstVarNames do: [:name |  elements add: (InstanceVariableEyeElement host: self object instVarName: name) ]okAction: aBlock  self toolbar okAction: aBlockclassToTest  ^SpTablePresentermodel  self deprecated: 'Model was renamed Presenter in Pharo 7' transformWith: '`@receiver model' -> '`@receiver presenter'.  ^self presenterselectedItemsAtIndexes: aCollectionOfIndex  ^aCollectionOfIndex collect: [:anIndex |  self listElementAt: anIndex ]enableItemSubstringFilter  self itemFilter: [:each :pattern |  each asLowercase includesSubstring: pattern asLowercase ]whenSelectionModeChangedDo: aBlock  selectionMode whenChangedDo: aBlockdoesNotUnderstand: aMessage  (self hasProperty: aMessage selector) ifTrue: [ | objOrBlock |        objOrBlock := self objectAtProperty: aMessage selector.        ^objOrBlock isBlock ifTrue: [ objOrBlock valueWithPossibleArgs: aMessage arguments ] ifFalse: [ objOrBlock value ] ].  self theme ifNotNil: [:t |  ^t perform: aMessage selector withArguments: aMessage arguments ].  ^super doesNotUnderstand: aMessagebasicBuildAdapterWithSpecLayout: aSpecLayout  self flag: #TODO.  layout := aSpecLayout.  ^super basicBuildAdapterWithSpecLayout: aSpecLayoutitems  ^leftItems , rightItemsinitialize  properties := Dictionary new.  super initializedragPassengerFor: item inMorph: dragSource  ^self dragTransformationBlock cull: item cull: dragSourceautoAccept  ^autoAccepttestActivationOnSingleClickShouldNotActivateOnClickOutside  | activatedItem |  activatedItem := nil.  presenter     activateOnSingleClick;     whenActivatedDo: [:selection |  activatedItem := selection selectedIndex ].  presenter clickAtIndex: 100.  self assert: activatedItem equals: niltestDefaultIsNotPassword  self deny: presenter isPasswordinspector  ^inspectorinspectorTypes  ^self inspectorWrapper inspectorTypeswindowIsClosing  self model windowIsClosingmethodsMenu: aBlock  methodsListPresenter contextMenu: aBlocktestSetSelectIndexRaisesSelectionChangeEventWithSelectedIndex  | selectedIndex |  presenter whenSelectionChangedDo: [:selection |  selectedIndex := selection selectedIndex ].  presenter selectIndex: 1.  self assert: selectedIndex equals: 1selectFileTitle: aString  self subclassResponsibilitybuildActionButton: aButtonPresenter  | morph |  self flag: #TODO.  morph := aButtonPresenter buildWithSpec.  aButtonPresenter adapter     styleName: 'actionButton';     applyStyle: morph.  ^morphpresenter: aPresenter  aPresenter owner: self.  presenter := aPresenterabsoluteValue  ^absoluteValuebeEncrypted  self deprecated: 'Use #bePassword instead' transformWith: '`@receiver beEncrypted' -> '`@receiver bePassword'.  self bePasswordlayout: aMorph in: aRect  calculating ifTrue: [ ^self ].  [ calculating := true.  self basicLayout: aMorph in: aRect ] ensure: [ calculating := false ]width: aNumber  self extent: aNumber @ self extentOrDefault yprogress: aBlock  self progress: aBlock every: 0.2 secondsortingBlock: aBlock  messageList sortingBlock: aBlockdefaultModifierShortcut  ^self shortcut first isUppercase ifTrue: [ OSPlatform current defaultModifier + KMModifier shift + self shortcut first ] ifFalse: [ OSPlatform current defaultModifier + self shortcut first ]openWithSpec  ^self application open: self withSpecLayout: self retrieveDefaultSpectestInitialPosition  presenter initialPosition: 100 @ 100.  self openInstance.  self assert: window adapter widget position equals: 100 @ 100isExpand  ^expand == truetestSettingAnImageSetsTheImage  self presenter image: self imageForm.  backendForTest assertImage: self adapter image equals: self imageFormheaderIcon: anIcon  headerIcon value: anIconwhenScrollValueChanged: aBlock  self deprecated: 'Use #whenScrollValueChangedDo: instead.' transformWith: '`@receiver whenScrollValueChanged: `@statements' -> '`@receiver whenScrollValueChangedDo: `@statements'.  self whenScrollValueChangedDo: aBlockpageClass  ^SpProgressBarDemoforgetMessage  self okToChange ifFalse: [ ^self ].  self selectedSelector ifNotNil: [:selector |  self model forgetSelector: selector inClass: self selectedClass fromChangeSet: self selectedChangeSet.        self updateClassesList.        self setSelectedClassIndex: self selectedClassIndex ]addModelTo: aMorph  self flag: #TODO.  (self model items at: #start ifAbsent: [ #() ]) do: [:each |  aMorph submorphs first addMorphBack: (self buildActionButton: each) ].  (self model items at: #end ifAbsent: [ #() ]) reverseDo: [:each |  aMorph submorphs second addMorphBack: (self buildActionButton: each) ]classToTest  ^SpImagePresentertestSelectPresenterIndexOutsideRangeUnsetsSelectedIndexInWidget  presenter selectPath: #(100).  self assert: self adapter selectedPaths isEmptyaddModelTo: tableMorph  self presenter columns do: [:each |  tableMorph addColumn: (self newColumnFrom: each) ].  self ensureAtLeastOneColumnIn: tableMorph.  self presenter selection isMultipleSelection ifTrue: [ tableMorph beMultipleSelection ].  self isShowingColumnHeaders ifTrue: [ tableMorph showColumnHeaders ] ifFalse: [ tableMorph hideColumnHeaders ].  self isResizable ifTrue: [ tableMorph beResizable ] ifFalse: [ tableMorph beNotResizable ].  self isSearchEnabled ifTrue: [ tableMorph enableSearch ] ifFalse: [ tableMorph disableFunction ].  tableMorph setBalloonText: self model help.  tableMorph dataSource: self newDataSource.  self presenter selection isEmpty ifFalse: [ self updateSelectionOf: tableMorph ].  self presenter whenSelectionChangedDo: [ self updateSelectionOf: tableMorph ].  self presenter whenRootsChangedDo: [ tableMorph selectIndexes: #().        tableMorph dataSource: self newDataSource ].  self presenter whenShowColumnHeadersChangedDo: [ self isShowingColumnHeaders ifTrue: [ tableMorph showColumnHeaders ] ifFalse: [ tableMorph hideColumnHeaders ] ].  self presenter whenColumnsChangedDo: [ tableMorph columns: #().        self presenter columns do: [:each |  tableMorph addColumn: (self newColumnFrom: each) ].        tableMorph dataSource: self newDataSource ].  tableMorph     onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self;     onAnnouncement: FTStrongSelectionChanged send: #strongSelectionChanged: to: selftextHolder  self deprecated: 'Nobody should access directly to internals of Spec. Now the text is an observable slot and not a value holder.'defaultHeight  ^self class splitterWidthisInput  ^falsewhenColumnsChangedDo: aBlock  self property: #columns whenChangedDo: aBlockiconName: aSymbol  self icon: (self iconNamed: aSymbol)selectPath: aPath  aPath ifEmpty: [ ^self unselectAll ].  (selection includes: aPath) ifTrue: [ ^self ].  presenter itemAtPath: aPath ifAbsent: [ ^self ].  selection := selection copyWith: aPathvalueChanged  self valueChanged: nilselectedItem  ^self dropList selectedItemaskBeforeChanging  ^falseisResizable: aBoolean  isResizable := aBooleanaddButton  ^addButtonsetGhostText: text to: aWidget  aWidget ghostText: textpackageList  ^packageListaddItem: aToolbarItem position: aPosition  aPosition addItem: aToolbarItem into: self.  self width: self width + aToolbarItem width.  self refreshadapter  ^presenter adapteraddFocusRotationKeyBindings  self widget tabSelectorMorph     bindKeyCombination: Character tab asKeyCombination toAction: [ self focusNext ];     bindKeyCombination: Character tab shift asKeyCombination toAction: [ self focusPrevious ]padding: aNumber  padding := aNumbershowOptions  ^showOptionsclearUndoManager  self widget textArea editingState clearUndoManager: nilfindClassOn: aString  | ast |  ast := RBParser parseExpression: aString onError: [ ^nil ].  ast nodesDo: [:node |  (node isVariable and: [ node name first isUppercase ]) ifTrue: [ (self class environment classNamed: node name) ifNotNil: [:aClass |  ^aClass ] ] ].  ^niltraverseInFocusOrderDo: aBlock excluding: excludes  self pages do: [:each |  each traverseInFocusOrderDo: aBlock excluding: excludes ]initialize  topologySort := true.  model := AbstractTool new.  super initializeinspectorType: anInspectorClass  ^self inspectorWrapper inspectorType: anInspectorClassbasicAdd: aPresenter constraints: constraints to: aWidget  | childMorph |  childMorph := self buildMorph: aPresenter constraints: constraints.  aWidget addMorph: childMorph.  ^childMorphhandlesDoubleClick  ^handlesDoubleClickstate  ^self presenter statetabSelectedAction  ^tabSelectedAction valuenewVertical  ^self newPanel     listDirection: #topToBottom;     addMorphBack: (self newPanel           listDirection: #topToBottom;           yourself);     addMorphBack: (self newPanel           listDirection: #topToBottom;           vResizing: #shrinkWrap;           height: 0;           yourself);     yourselfinitialExtent  ^900 @ 550list  ^listtestSetHeaderTitleHasTitle  presenter headerTitle: 'title'.  self assert: presenter hasHeaderTitlenewComponentList  ^self instantiate: SpComponentListPresenterbindings  ^self class bindingsaddKeyBindingsTo: aMorph  isExecutable  ^falseconstraintsClass  ^SpPanedConstraintswidth: aNumber  self hRigid.  self widgetDo: [:w |  w width: aNumber ]okActionBlock  ^[ self okAction value == false ifFalse: [ owner ifNil: [ self delete ] ifNotNil: [ owner delete ] ] ]transform: anArray  ^anArray at: self indextext  ^textnewScrollPaneFor: aWidget  ^MillerScrollPane new     changeScrollerTableLayout;     hResizing: #spaceFill;     vResizing: #spaceFill;     color: Color transparent;     borderColor: Color transparent;     scrollTarget: aWidget;     onLayoutChange: [ self recalculatePages ];     yourselfrunTest: aBlock  app := SpApplication new.  app useBackend: #Morphic.  aBlock valuepushModel: aModel  self addPresenter: (self newPresenterFor: aModel)packageButton  ^packageButtonaddVerticalPadding: aNumber toMorph: aMorph  ^self newWrapMorph     hResizing: aMorph hResizing;     vResizing: aMorph vResizing;     width: aMorph width;     height: aMorph height + (aNumber * 2);     addMorph: (aMorph           hResizing: #spaceFill;           vResizing: #spaceFill;           yourself) fullFrame: (LayoutFrame identity           topOffset: aNumber;           bottomOffset: aNumber negated);     yourselftestSelectItemAddsItemToSelectedItemList  presenter selectItem: 10.  self assert: (presenter selection includesItem: 10)reset  self actualPageMorph: nilresetLabel  label label: (selectedClasses ifEmpty: [ 'No class checked' ] ifNotEmpty: [ (selectedClasses collect: #printString) joinUsing: ' - ' ])filteringBlock  self deprecated: 'This feature is now removed from Spec 2. If the visible elements of the list need to be changed, it''s the users of the lists that should manage it and update the list of items of the list.'.  ^nilrebuildDynamicPresenter  builder := SpDynamicPresentersListBuilder new     modelObjects: (1 to: 15);     presenter: SpButtonPresenter configuredAs: [:presenter :modelObject |  presenter label: modelObject asString ];     layoutBuilder: (SpDynamicLeftToRightColumnsLayout columns: 5);     yourself.  self newDynamicPresentersListIn: #dynamicPresenter usingBuilder: builderbeep  buildSelectorDescriptionFor: changeSet class: class selector: selector  | changeType code |  changeType := changeSet atSelector: selector class: class.  changeType == #remove ifTrue: [ ^'Method has been removed (see versions)' ].  changeType == #addedThenRemoved ifTrue: [ ^'Added then removed (see versions)' ].  class ifNil: [ ^'Method was added, but cannot be found!' ].  (class includesSelector: selector) ifFalse: [ ^'Method was added, but cannot be found!' ].  code := class sourceCodeAt: selector.  ^code asTextprogression: aValuable  progression := aValuabledisplay: aBlock  displayBlock := aBlockadd: aName  self add: aName withConstraints: [:constraints |   ]retrieveSpecFrom: aSpec  self presenter needRebuild ifTrue: [ spec := self computeSpecFrom: arrayToInterpret first ] ifFalse: [ spec := self presenter spec.        self presenter needRebuild: true.        spec ifNil: [ spec := self computeSpecFrom: arrayToInterpret first ] ifNotNil: [ spec isRedrawable ifTrue: [ spec removeSubWidgets ] ifFalse: [ ^spec ] ] ].  ^nilparseStyleName  | styleName |  readStream next.  styleName := self stringStreamContents: [:stream |  [ readStream atEnd not and: [ self isClassChar: readStream peek ] ] whileTrue: [ stream nextPut: readStream next ] ].  self consumeWhitespace.  ^styleName asStringrow  ^self position yrecalculatePages: anAdaptor  self subclassResponsibilitypropertiesLike: aClass  ^(self styles inject: OrderedCollection new into: [:all :eachStyle |  eachStyle properties select: [:eachProperty |  eachProperty class = aClass ] thenDo: [:eachProperty |  all add: eachProperty ].        all ]) flattenedborderWidth: anObject  borderWidth := anObjectisResizable  ^isResizablesetModel: aDomainObject  ghostText: aText  self deprecated: 'This API is too tight to Morph. Use #placeholder: instead.' transformWith: '`@receiver ghostText: `@statement' -> '`@receiver placeholder: `@statement'.  self placeholder: aTextperformOkAction  okBlock valuenewSet  | aSet |  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  self okToChange ifFalse: [ ^self ].  aSet := self model createNewSet.  aSet ifNotNil: [ self updateChangesList.        changesListPresenter setSelectedItem: aSet.        self updateWindowTitle ]label  ^labelinitializePresenters  buttonNormal := self newButton label: 'normal'.  buttonDisabled := self newButton     label: 'disabled';     disable;     yourself.  buttonWithIcon := self newButton     label: 'with icon';     icon: ((self iconNamed: #pharo) scaledToSize: 16 @ 16);     yourself.  buttonWithIconOnly := self newButton     icon: ((self iconNamed: #pharo) scaledToSize: 16 @ 16);     help: 'This button has only icon, no label';     yourself.  buttonHighlighted := self newButton     label: 'highlighted';     state: true;     yourself.  buttonWithColor := self newButton     label: 'red';     color: Color red;     yourself.  buttonWithMenu := self newButton     label: 'with menu';     contextMenu: self subMenu;     yourself.  buttonWithShortcut := self newButton     shortcut: $o meta;     label: 'with shortcut';     yourself.  buttonWithHelp := self newButton     label: 'with help';     help: 'This button showsa multiline help';     yourself.  buttonWithDifferentFont := self newButton     label: 'different font';     font: StandardFonts codeFont;     yourself.  self focusOrder     add: buttonNormal;     add: buttonDisabled;     add: buttonWithIcon;     add: buttonWithIconOnly;     add: buttonHighlighted;     add: buttonWithColor;     add: buttonWithMenu;     add: buttonWithShortcut;     add: buttonWithHelp;     add: buttonWithDifferentFonttestSettingNilClearsTheImage  self presenter image: self imageForm.  self presenter image: nil.  backendForTest assertImage: self adapter image equals: nilwhenPlaceholderChangedDo: aBlock  self property: #placeholder whenChangedDo: aBlockautoAccept: aBoolean  ^self input autoAccept: aBooleansave: aValue  self host tempNamed: self tempName put: aValueselectedItem  ^self selectedPaths ifEmpty: [ #() ] ifNotEmpty: [:paths |  presenter itemAtPath: paths first ]testActivateRaisesChangedEventOnce  presenter state: false.  self assertWith: [:times |  times = 1 ] timesRaisedEvent: #whenChangedDo: inPresenter: presenter whenDoing: [ presenter state: true ]add: modelGetter withSpec: aSymbol origin: originPoint corner: cornerPoint  self add: modelGetter withSpec: aSymbol origin: originPoint corner: cornerPoint offsetOrigin: 0 @ 0 offsetCorner: 0 @ 0isEmpty  ^items isEmptyindeterminated  ^indeterminatedtestTickIncrementsStepBy  timeline stepBy: 10.  timeline tick.  self assert: timeline ticks equals: 10keystroke: aRubricEvent  aRubricEvent event keyCharacter = Character arrowUp ifTrue: [ self increaseValueOf: aRubricEvent morph.        ^true ].  aRubricEvent event keyCharacter = Character arrowDown ifTrue: [ self decreaseValueOf: aRubricEvent morph.        ^true ].  ^falseusersModel  ^usersModeldropList  ^dropListname  ^nameselectAll  self changed: #selectAll with: #()layoutChanged  updating ifTrue: [ ^self ].  updating := true.  [ super layoutChanged.  layoutChangeAction ifNotNil: [ layoutChangeAction value ] ] ensure: [ updating := false ]presenter  ^modelinspectorChoice  ^inspectorChoicedoItReceiver  | receiver |  receiver := doItReceiver.  receiver isBehavior ifTrue: [ receiver := receiver instanceSide ].  ^receiverslider  ^subwidget sliderstep  self inspector stepdirection  ^directiondayBeforeMonthOf: aDate  ^aDate month dates first dayOfWeek - 1initialize  super initialize.  self position: 1 @ 1.  self span: 1 @ 1removePage: aPage  | removedPageIndex |  removedPageIndex := self pages indexOf: aPage.  self suspendAnnouncementsDuring: [ super removePage: aPage ].  self announcer announce: (SpNotebookPageRemoved new           tabs: self;           page: aPage;           pageIndex: removedPageIndex;           newIndex: self tabSelectorMorph selectedIndex).  self pages ifEmpty: [ self contentMorph removeAllMorphs ]labelPresenter  ^labelPresenterwhenAutoAcceptChangedDo: aBlock  self property: #autoAccept whenChangedDo: aBlocktestDoubleClickActivatesRowInDoubleClickActivationMode  | activated |  activated := false.  self presenter activateOnDoubleClick.  self presenter whenActivatedDo: [ activated := true ].  backendForTest doubleClickFirstRowAndColumn: self adapter.  self assert: activatedcomputeCellExtents  cellExtents := SmallDictionary new.  self allGridConstraints do: [:constraint |  | width height |        width := (columnWidths copyFrom: constraint column to: constraint column + constraint columnSpan - 1) sum.        height := (rowHeights copyFrom: constraint row to: constraint row + constraint rowSpan - 1) sum.        cellExtents at: constraint position put: width @ height ]aboutToStyle: aBoolean  self deprecated: 'This method is an horrible hack because the VersionBrowser was using Code or Diff presenter but was only using the API of the Code presenter... This method and other methods from the CodePresenter API will be removed.'selectedItem  self dropList selectedItemcolor: color  label  ^self tempNamepreTransmission: aValuable  preTransmission := aValuablewrapItem: anItem  ^self model wrapItem: anItemobjectChanged  text doItReceiver: self object.  morphPresenter morph removeAllMorphs.  morphPresenter morph addMorph: self thumbnailMorph fullFrame: LayoutFrame identityinitializeTestedInstance  presenter     addColumn: (SpStringTableColumn title: 'Value' evaluated: #printString);     addColumn: (SpImageTableColumn title: 'Icon' evaluated: [:x |  self iconNamed: #add ]);     hideColumnHeaders;     beMultipleSelection;     roots: #(1 2 3);     children: [:aNumber |  {(aNumber * 2) .         (aNumber * 3) .         (aNumber * 10)} ]instVarNamesAndPresenterNamesArray  ^(self instVarToModelObject inject: OrderedCollection new into: [:col :instVarToModelObjectAssoc |  col           add: instVarToModelObjectAssoc key;           add: (self presenterBlock value: instVarToModelObjectAssoc value) name;           yourself ]) asArrayrawRead: anObject  ^super read: anObjectheightPositionIn: aPoint  ^self position < 1 ifTrue: [ (aPoint y * self position) asInteger ] ifFalse: [ self position ]taskbarIcon  ^self inspector ifNil: [ super taskbarIcon ] ifNotNil: [:anInspector |  anInspector taskbarIcon ]removeAll  widget submorphs first removeAllMorphs.  widget submorphs second removeAllMorphsisVertical  ^self direction = SpLayoutDirection verticalactionHolder  self deprecated: 'Nobody should access directly to internals of Spec. Now the action not a value holder anymore because it was not used.'inputPortNamed: aSymbol  ^self inputPorts detect: [:each |  each name = aSymbol ]container  ^container valuetestAddWithPaddingVertical  | base presenter layout |  base := SpBoxLayoutWithTableForTestPresenter new.  presenter := SpLabelPresenter new.  layout := SpBoxLayout newVertical     add: presenter expand: false fill: false padding: 10;     yourself.  base buildAdapterWithSpecLayout: layout.  self assert: presenter adapter widget extent equals: presenter adapter widget owner extent - (0 @ 20)findChangeSet  | set |  set := self model findChangeSetIn: self changeSets.  changesListPresenter setSelectedItem: settestSubscribeToEventDoesNotRaiseEvent  presenter selection whenChangedDo: [:selection |  self fail ]beOverlay  ^overlay := trueaddRadioButton: aButton  buttons do: [:b |  aButton whenActivatedDo: [ b privateSetState: false ].        b whenActivatedDo: [ aButton privateSetState: false ] ].  aButton whenActivatedDo: [ self currentlyActivated: aButton ].  buttons add: aButton.  aButton privateSetState: falsemenusRegistrationFrom: src to: dest  src changesMenu: (self changeSetMenuFrom: src to: dest).  src classesMenu: (self classMenuFrom: src to: dest).  src methodsMenu: (self messageMenuFrom: src to: dest)acceptText: aString  self property: #text rawValue: aStringimage  ^imagesize  ^collection sizegetIconFor: anItem  ^self iconBlock cull: anItem model cull: anItembackgroundColor: anObject  backgroundColor := anObjectcontents  ^contents ifNil: [ self buildChildren.        contents ]browserPage  ^SpNotebookPage title: 'Browser' icon: (self iconNamed: #nautilusIcon) provider: [ SpClassMethodBrowser new           classes: self class environment allClasses;           yourself ]refreshWidgetList  connectPresenters  slider whenValueChangedDo: [:sliderValue |  | inputValue |        inputValue := input text asNumber.        sliderValue == inputValue ifFalse: [ input text: sliderValue asString ] ].  input whenTextChangedDo: [:text |  | inputValue |        inputValue := text asNumber.        slider value == inputValue ifFalse: [ slider value: inputValue ] ]testRightClickShowsMenu  | menu |  presenter contextMenu: (menu := SpMockMenuPresenter new).  self deny: menu shown.  self emulateRightClick.  self assert: menu shownunselectIndex: anInteger  self selectedIndex = anInteger ifTrue: [ self basicSelectIndex: 0 ]setIndex: anIndex  ^self model selectIndex: anIndexlocationOf: anItem  ^String streamContents: [:aStream |  3 to: (cachedHierarchy at: anItem) size do: [:i |  aStream << '    ' ].        aStream << (self methodClassNameForItem: anItem) << ' ('.        anItem isFromTrait ifTrue: [ aStream                 << anItem compiledMethod origin name;                 space ].        aStream << (self protocolNameForItem: anItem) << ')' ]moreOptionsText: aText  moreOptionsText := aTextnotifyInfo: aSpecNotification  GrowlMorph openWithLabel: 'Information' translated contents: aSpecNotification messagedesiredVisibleRow  ^desiredVisibleRowallPresentersInFocusOrder  | allPresenters |  allPresenters := OrderedCollection new.  self traverseInFocusOrderDo: [:each |  allPresenters add: each ].  ^allPresentersbehavior  ^self model behavioraddPresenterIn: widget withSpecLayout: aSpec  self presenter ifNil: [ ^self ].  self initializeWindow.  self changed: #addPresenterIn:withSpecLayout: with: {widget .         aSpec}widthOrUndefined  ^self width ifNil: [ self class undefinedColumnWidth ]whenBehaviorChanged: aBlock  self deprecated: 'Use #whenBehaviorChangedDo: instead.' transformWith: '`@receiver whenBehaviorChanged: `@statements' -> '`@receiver whenBehaviorChangedDo: `@statements'.  self whenBehaviorChangedDo: aBlocktestAsButtonPresenter  | buttonPresenter |  command := CmCommand forSpec     name: 'foo';     description: 'bar';     yourself.  buttonPresenter := command asButtonPresenter.  self assert: buttonPresenter label equals: 'foo'.  self assert: buttonPresenter help equals: 'bar'.  self assert: buttonPresenter icon isNilsetCurrentChangeSet: aChangeSet  ChangeSet newChanges: aChangeSetinitialWidth  ^initialWidth valuepopUpEvent: evt in: aWorld  self shown: trueunselectAll  self selection unselectAllcanTakeKeyboardFocus  ^falseisDisplayed  ^self window ifNotNil: [:w |  w isDisplayed ] ifNil: [ false ]displayBlockChanged  self widgetDo: [:w |  w rowMorphGetSelector: self displayBlock.        w container updateList ]dragEnabled: aBoolean  dragEnabled := aBooleaninitializeWindow: aWindowPresenter  super initializeWindow: aWindowPresenter.  aWindowPresenter     menu: (menu := self buildMenuBar);     toolBar: (toolBar := self buildToolBar);     statusBar: (statusBar := self buildStatusBar)openInstance  backendForTest openInstanceOf: selfpresenterBlock  ^presenterBlockinitialExtent  ^600 @ 400addSpacer  self add: #specSpacerbuildWidget  ^SpStubRadioButtonView newexpandAll  self treeModel expandAlllimit1  ^100sortingBlock: aBlock  sorting := aBlock.  self refreshListselectedIndex  ^list selection selectedIndextestClickDeactivatedCheckboxActivatesIt  presenter state: false.  self emulateLeftClick.  self assert: presenter stateremoveAll  children removeAll.  adapter ifNotNil: [:anAdapter |  anAdapter removeAll ]initialize: anObject  super write: SpValueHolder new to: anObjecttestEnabledAffectWidget  ^self skipsetConfigButton  configButton     state: false;     label: '+Config';     help: 'Add a new metacello configuration';     action: [ self createConfiguration ]methodList  ^methodListtestReset  self initMinMax.  presenter     value: 50;     reset.  self assert: presenter value == 0dateModel  ^dateModelencrypted  self deprecated: 'Use #isPassword instead' transformWith: '`@receiver encrypted' -> '`@receiver isPassword'.  ^self isPasswordspinnerForm  ^self class spinnerFormnullPresentersNeededFor: aDynamicPresentersListBuilder  ^self columnsCount - ((aDynamicPresentersListBuilder modelObjects size - 1) % self columnsCount + 1)postTransmission: aValuable  postTransmission := aValuablesetUp  super setUp.  presenter := self classToTest new.  self initializeTestedInstancewhenTabSelected: aBlock  tabSelectedAction value: aBlockbuttonWithDifferentFont  ^buttonWithDifferentFontchildrenWidgets  ^innerWidget submorphsitems: aList  ^self list items: aListpushStyle: aStyle during: aBlock  | oldStyle |  oldStyle := currentStyle.  currentStyle := aStyle.  aBlock ensure: [ currentStyle := oldStyle ]browseSelectedObjectClass  self selectedObjectDo: [:anObject |  Smalltalk tools browser openOnClass: anObject class ]observablePropertyNamed: aName  | slot |  slot := self class slotNamed: aName.  slot isObservableSlot ifFalse: [ SpNonObservableSlotError signal: aName ].  ^slot rawRead: selfmessages  ^messageList messagestestColumnsAreDynamicallySetInPresenter  self presenter     displayBlock: [:item |  {item .         42} ];     items: {1 .         2 .         3}.  self assert: self presenter columns size equals: 2activatesOnSingleClick  ^activateOnSingleClicktestIsEmpty  self assert: presenter isEmpty.  presenter addItem: SpToolBarButton new.  self deny: presenter isEmptystyles: anObject  styles := anObjecttransformed: anObject  transformBlock ifNil: [ ^anObject ].  ^transformBlock value: anObjectclassList  ^classListinitialize  self class initializeSlots: self.  super initializeupButton  ^upButtonfemaleButton  ^femaleButtontestTypePerformsSearch  self selectIndex: 1.  self adapter typeForSearch: '2'.  self assert: self selectedIndex equals: 2whenWillCloseDo: aBlock  self announcer when: SpWindowWillClose do: aBlocktestUnselectAllInWidgetRaisesSelectionIndexChangeEventOnce  | counter |  counter := 0.  self adapter selectPath: #(1).  presenter selection whenChangedDo: [:selection |  counter := counter + 1 ].  self adapter selectPath: #().  self assert: counter equals: 1testSetSelectIndexRaisesSelectionChangeEventWithSelectedItem  | selectedItems |  presenter whenSelectionChangedDo: [:selection |  selectedItems := selection selectedItems ].  presenter selectIndex: 1.  self assert: (selectedItems includes: 10)beFloat  self numberType: FloathasHeaderTitle  ^headerTitle isEmptyOrNil notsurname  ^surnametestWhenDigitsChangedDo  | count result |  count := 0.  presenter whenDigitsChangedDo: [:value |  count := count + 1.        result := value ].  presenter digits: 2.  self assert: count equals: 1.  self assert: result equals: 2objectInspectorPage  ^SpNotebookPage title: 'Object inspector' icon: (self iconNamed: #nautilusIcon) provider: [ self flag: #TODO.        (self class environment at: #EyeInspector) new           inspect: Object;           yourself ] layoutSpec: #inspectorSpecbuttonWithHelp: anObject  buttonWithHelp := anObjectvalueClass  ^self value classobservablePropertyNamed: aName  | slot |  slot := self class slotNamed: aName.  slot isObservableSlot ifFalse: [ SpNonObservableSlotError signal: aName ].  ^slot rawRead: selfmodel: aModel  model := aModel.  model whenChangedDo: [ self withAdapterDo: #refreshList ]testUnselectAllInWidgetNotRaisesEmptySelectionChangeEvent  | gotSelection |  presenter selection whenChangedDo: [:selection |  gotSelection := selection ].  self adapter selectPath: #().  self assert: gotSelection isNil