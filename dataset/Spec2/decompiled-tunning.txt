pageWithModel: arg1  ^self pages detect: [:arg2 |  arg2 model = arg1 ]classToTest  ^SpDemocolumnInset  ^self model columnInsetquantum: arg1  quantum := arg1accept  self changed: #accept with: #().  self actionPerformednumber1Label: arg1  number1Label := arg1minimize  self changed: #minimize with: #()defineOutputPorts  ^{SpTextChangedPort new}windowIcon  ^windowIconobjectChanged  self updateList.  self text doItReceiver: self object.  self description doItReceiver: self object.  self text doItContext: self doItContext.  self description doItContext: self doItContext.  self text ifNotNil: [:arg1 |  arg1 behavior: self objectClass ]instantiatePresenters: arg1  arg1 pairsDo: [:arg2 :arg3 |  self presenterAt: arg2 asSymbol put: (self createInstanceFor: arg3) ]addItem: arg1 into: arg2  arg2 addItemLeft: arg1newSpinnerMorph  ^self spinnerForm asMorphhandleMethodAdded: arg1  | tmp1 tmp2 tmp3 tmp4 |  self isDisplayed ifFalse: [ ^self ].  refreshingBlock ifNil: [ ^self ].  tmp1 := arg1 method.  (self shouldRefreshItem: tmp1 fromAnnouncement: arg1) ifFalse: [ ^self ].  (tmp1 methodClass notNil and: [ tmp1 methodClass isObsolete not ]) ifFalse: [ ^self ].  tmp4 := textModel hasUnacceptedEdits.  tmp4 ifTrue: [ tmp3 := textModel pendingText ].  tmp2 := self selectedMessage.  self messages: (self messages           add: tmp1 asFullRingDefinition;           yourself).  self selectedMessage: tmp2.  tmp4 ifTrue: [ textModel pendingText: tmp3 ]instantiate: arg1 on: arg2  ^arg1 owner: self on: arg2addAll: arg1 withSpecLayout: arg2  arg1 addMorph: (self buildWithSpecLayout: arg2) frame: (0 @ 0 corner: 1 @ 1)update: arg1  arg1 == #displayBlockChanged ifTrue: [ ^self displayBlockChanged ].  arg1 == #resizableChanged ifTrue: [ ^self resizableChanged ].  arg1 == #headerLabelChanged ifTrue: [ ^self headerLabelChanged ].  arg1 == #headerFontChanged ifTrue: [ ^self headerFontChanged ].  arg1 == #headerIconChanged ifTrue: [ ^self headerIconChanged ].  ^super update: arg1classToTest  ^SpOpenOnIntExamplemenu  self deprecated: 'Use #contextMenu instead.' transformWith: '`@receiver menu' -> '`@receiver contextMenu'.  ^self contextMenuspec  self flag: #TODO.  ^self adapterrightLabel: arg1  self widgetDo: [:arg2 |  arg2 leftLabel: self leftLabel rightLabel: arg1 ]isHorizontal  ^truenewColumn: arg1  self newColumn: arg1 origin: 0 @ 0 corner: 1 @ 1property: arg1 rawValue: arg2  (self observablePropertyNamed: arg1) rawValue: arg2initializeTestedInstance  presenter drawBlock: [  ].  presenter surfaceExtent: 800 @ 600buildWidget  ^PluggableMultiColumnListMorph new     wrapSelector: #wrapItem:index:;     model: self;     getListSizeSelector: #listSize;     getIndexSelector: #getIndex;     setIndexSelector: #setIndex:;     getListElementSelector: #listElementAt:;     resetListSelector: #resetListSelection;     getMenuSelector: #menu:shifted:;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     setMultipleSelection: self multiSelection;     setBalloonText: self help;     hResizing: #spaceFill;     vResizing: #spaceFill;     yourselftestWhenSelectAProtocolShouldMethodListOnlyContainsMethodWithSelectedProtocol  biChooseMethod packageList selectItem: self class package.  biChooseMethod classList selectItem: self class.  biChooseMethod protocolList selectIndex: ((biChooseMethod protocolList items collect: #name) indexOf: 'running').  self assert: (biChooseMethod methodList items allSatisfy: [:arg1 |  arg1 category = 'running' ])minWidth: arg1  self widgetDo: [:arg2 |  arg2 minWidth: arg1 ]popMessage  statusBar popMessagetestApplyTo  | tmp1 tmp2 |  tmp1 := self newLookup: '.application [ 		Geometry { #width: 11 },		.other [			Geometry { #width: 22 },			.deep1 [				Geometry { #width: 33 }			],			.deep2 [				Geometry { #width: 42 }			]		]	]'.  tmp2 := Morph new.  tmp1 applyTo: tmp2.  self assert: tmp2 width equals: 42customizeMorphicBar: arg1  arg1 value: self valuesetAnnouncingObject: arg1  announcingObject := arg1 isSpAnnouncingObject ifFalse: [ arg1 asValueHolder ] ifTrue: [ arg1 ].  announcingObject whenChangedDo: [ self modelChanged ]visitCommandGroup: arg1  arg1 isRoot ifTrue: [ super visitCommandGroup: arg1.        ^self ].  arg1 displayIn: stack top do: [:arg2 |  stack push: arg2.        super visitCommandGroup: arg1.        stack pop ]initializePresenters  preview := self instantiate: SpImagePresenter.  sliders := self instantiate: SpRGBSliders.  preview image: (Form extent: 30 @ 30 depth: 32).  preview image: self makeNewForm.  self focusOrder add: sliderswhenAboutToStyleChanged: arg1  self deprecated: 'Use #whenAboutToStyleChangedDo: instead.' transformWith: '`@receiver whenAboutToStyleChanged: `@statements' -> '`@receiver whenAboutToStyleChangedDo: `@statements'.  self whenAboutToStyleChangedDo: arg1whenHelpChanged: arg1  self deprecated: 'Use #whenHelpChangedDo: instead.' transformWith: '`@receiver whenHelpChanged: `@statements' -> '`@receiver whenHelpChangedDo: `@statements'.  self whenHelpChangedDo: arg1blueSlider  ^blueSliderbuildWidget  | tmp1 |  tmp1 := self newButton.  tmp1     getEnabledSelector: #enabled;     getFontSelector: #font;     hResizing: #spaceFill;     vResizing: #spaceFill;     askBeforeChanging: self askBeforeChanging;     setBalloonText: self model help;     dragEnabled: self dragEnabled;     dropEnabled: self dropEnabled;     eventHandler: (MorphicEventHandler new on: #keyStroke send: #keyStroke:fromMorph: to: self).  self color ifNotNil: [ self setWidgetColor: tmp1 ].  tmp1 bindKeyCombination: Character space toAction: [ self action ].  ^tmp1invokeModal  self shown: trueisForSmalltalkCode  ^falsesecondSelection: arg1  self widget ifNotNil: [:arg2 |  arg2 listManager secondSelection: arg1 ]item: arg1  item := arg1withAdapterDo: arg1  ^adapter ifNotNil: arg1initialize  super initialize.  roots := OrderedCollection newresetSelection  ^self dropList resetSelectionremovePreamble  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  self selectedChangeSet hasPreamble ifFalse: [ ^self inform: 'Change set has no preamble' ].  self selectedChangeSet removePreamble.  changesListPresenter setSelectedItem: self selectedChangeSetdefaultColumn  ^SpStringTableColumn new evaluated: #yourselfhasUnacceptedEdits  ^hasUnacceptedEditsadaptAsPopup: arg1  model := arg1.  arg1 addDependent: self.  widget := self buildWidgetPopuphash  ^self label hash bitXor: action hashselectionChanged: arg1  | tmp1 tmp2 |  tmp2 := self presenter selection.  tmp2 selectIndexes: (tmp2 isMultipleSelection ifTrue: [ arg1 newSelectedIndexes reject: [:arg2 |  arg2 = 0 ] ] ifFalse: [ {(arg1 newSelectedIndexes ifNotEmpty: [:arg3 |  arg3 first ] ifEmpty: [ 0 ])} ]).  tmp1 := arg1 newSelectedIndexes difference: arg1 oldSelectedIndexes.  (tmp1 notEmpty and: [ self presenter activatesOnSingleClick ]) ifTrue: [ self presenter doActivateAtIndex: tmp1 last ].  arg1 newSelectedIndexes ifEmpty: [ tmp2 unselectAll ]showColumnHeaders  showColumnHeaders := trueowner  ^ownerlabel  self button labelinitialize  super initialize.  themeOverrideDict := Dictionary newtestRemoveAll  self assert: self adapter numberOfTabs equals: 2.  presenter removeAll.  self assert: self adapter numberOfTabs equals: 0selectedObjectDo: arg1  arg1 value: self selectedObject wrappedObjecttestGenerateNullPresentersInstVarNames  builder modelObjects: {1 .         2 .         3}.  self assertCollection: (builder generateNullPresentersInstVarNames: 3) equals: #(var4 var5 var6)customizeMorphicBar: arg1  y: arg1  y := arg1performSearch: arg1 matching: arg2  ^searchBlock value: arg1 value: arg2initializePresenters  table := self newTable.  table     addColumn: (SpStringTableColumn title: 'Name' evaluated: #name);     addColumn: (SpStringTableColumn title: 'Phone' evaluated: #phone).  table contextMenuFromCommandsGroup: [ self rootCommandsGroup / 'Context Menu' ].  table items: contactBook contents.  menuBar := (self rootCommandsGroup / 'MenuBar') asMenuBarPresentertestUnselectPresenterItemUnselectsIndexInWidget  self skipwantsInitialization  ^trueinitializeLayout: arg1  self initialize.  layout := arg1rootItem: arg1  super rootItem: arg1.  self addSourceToRootItemisNonEditableRow: arg1 column: arg2  ^(self widget dataSource cellColumn: (self widget columns at: arg2) row: arg1) submorphs allSatisfy: [:arg3 |  arg3 asReadOnlyMorph == arg3 ]menu: arg1 shifted: arg2  ^self model menu: arg1 shifted: arg2model  ^modelindexFor: arg1  ^listPresenter listItems indexOf: arg1whenSelectionChangedDo: arg1  self selection whenChangedDo: arg1classToTest  ^SpListPresentertestAddItem  presenter addItem: SpToolBarButton new.  self assert: presenter items size equals: 1transferSubscriptionsTo: arg1  self selectionHolder transferSubscriptionsTo: arg1 selectionHolderfullName  ^self parent ifNotNil: [ | tmp1 |        tmp1 := self parent fullName.        tmp1 = 'application' ifTrue: [ self name ] ifFalse: [ tmp1 , '.' , self name ] ] ifNil: [ self name ]add: arg1 to: arg2  self add: arg1 properties: arg1 to: arg2layoutValue  ^self model autoScale ifTrue: [ #scaledAspect ] ifFalse: [ #center ]notifyPropertyChanged: arg1  self flag: #todo.  (self observablePropertyNamed: arg1) valueChangedchildrenForObject: arg1  ^arg1 children collect: [:arg2 |  DynamicEyeElement host: arg1 label: arg2 class name description: [:arg3 |  arg3 formattedCode ] value: [ arg2 ] ]buttonWithShortcut  ^buttonWithShortcutacceptColumnVisitor: arg1  ^arg1 visitStringColumn: selfclassToTest  ^SpRadioButtonPresentertestUnselectSelectedIndexRemovesItFromSelectionList  presenter     selectIndex: 1;     unselectIndex: 1.  self assert: presenter selection isEmptyinspectorType  ^self inspectorWrapper inspectorTypeautoFractionComputation  self commands doWithIndex: [:arg1 :arg2 |  arg1 layoutFrame hasNoOffsets ifTrue: [ | tmp1 |              tmp1 := arg1 layoutFrame rightFraction - arg1 layoutFrame leftFraction.              self setWidgetLayoutWithNoOffset: arg1 at: arg2 delta: tmp1 ] ifFalse: [ self setWidgetLayoutWithOffset: arg1 at: arg2 ] ]layoutLeftToRight: arg1 in: arg2  self ensureWidthPosition: arg1 in: arg2.  super layoutLeftToRight: arg1 in: arg2layout: arg1  widget ifNil: [ widget := self newPanel.        widget layoutPolicy layout: arg1 ].  super layout: arg1currentValue: arg1  currentValue := arg1privateAsArray  self resetArrayComputation.  self countNumberOfProportionals.  autoFractionComputation ifTrue: [ self manualFractionComputation ] ifFalse: [ self autoFractionComputation ].  self shiftLastWidgets.  ^super privateAsArraytopologicSort  ^messageList topologicSortshortcut  | tmp1 |  tmp1 := self model shortcut.  ^(tmp1 isBlock or: [ tmp1 isMessageSend ]) ifTrue: [ tmp1 cull: self model ] ifFalse: [ tmp1 ]recalculatePages: arg1  ^arg1 recalculatePageHeightsbuildWidget  | tmp1 tmp2 |  tmp1 := super buildWidget.  tmp2 := Morph new     extent: 12 @ 12;     color: Color transparent;     changeTableLayout;     listDirection: #topToBottom;     addMorph: (IconicButton new           target: self;           actionSelector: #clearText;           labelGraphic: (self iconNamed: #glamorousRemove);           color: Color transparent;           extent: 16 @ 8;           borderWidth: 0;           yourself);     yourself.  tmp1     changeProportionalLayout;     addMorph: tmp2 fullFrame: (LayoutFrame identity           bottomFraction: 0;           leftFraction: 1;           topOffset: 4;           leftOffset: -25;           yourself).  ^tmp1whenHasChildrenBlockChanged: arg1  self deprecated: 'Use #whenHasChildrenBlockChangedDo: instead.' transformWith: '`@receiver whenHasChildrenBlockChanged: `@statements' -> '`@receiver whenHasChildrenBlockChangedDo: `@statements'.  self whenHasChildrenBlockChangedDo: arg1testSetSelectItemRaisesSelectionIndexChangeEventWithSelectedIndex  | tmp1 |  presenter selection whenChangedDo: [:arg1 |  tmp1 := arg1 selectedIndex ].  presenter selectItem: 10.  self assert: tmp1 equals: 1positionAt: arg1  ^(self columnPositions at: arg1 x) @ (self rowPositions at: arg1 y)setEditingModeFor: arg1  arg1 beForPlainTextedgeName  ^#rightupdateInspectorChoice  self inspectorTypes ifNotNil: [:arg1 |  inspectorChoice listItems = arg1 ifTrue: [ ^self ].        inspectorChoice items: arg1 ]doubleClick  self model doubleClickcolumnSpacing  ^self layout columnSpacingtopButton  ^topButtonindexOf: arg1 ifAbsent: arg2  ^collection indexOf: arg1 ifAbsent: arg2defaultWidth  ^self class splitterWidthtestClickOnClassSideRadioButtonShouldFillTheMethodList  biChooseMethod packageList selectItem: SpMethodChooserMockClass package.  biChooseMethod classList selectItem: SpMethodChooserMockClass.  biChooseMethod radioButtonClassSide click.  self assertCollection: biChooseMethod methodList items hasSameElements: SpMethodChooserMockClass class methodsroots  ^rootscolumnCount  ^self widget columns sizedisplayBlock: arg1  self deprecated: 'Please use #display: instead' transformWith: '`@receiver displayBlock: `@arg' -> '`@receiver display: `@arg'.  displayBlock := arg1testAddButtonToToolbar  | tmp1 tmp2 |  tmp1 := SpToolBarPresenter new.  tmp2 := SpToolBarButton new.  self assertEmpty: tmp1 items.  CmUILeftPositionStrategy new addButton: tmp2 toToolbar: tmp1.  self assert: tmp1 leftItems size equals: 1.  self assert: tmp1 leftItems anyOne equals: tmp2.  self assertEmpty: tmp1 rightItemscalculateHeightFor: arg1 base: arg2  ^arg2widget  self openInstance.  self currentWorld doOneCycle.  ^self adapter widgetfont  ^fonttestWhenActionChangedDo  | tmp1 tmp2 |  tmp1 := 0.  presenter whenActionChangedDo: [:arg1 |  tmp1 := tmp1 + 1.        tmp2 := arg1 ].  presenter action: [ 'Test' ].  self assert: tmp2 isBlock.  self assert: tmp2 value equals: 'Test'.  self assert: tmp1 equals: 1fieldDisabled: arg1  fieldDisabled := arg1newColumn: arg1 left: arg2  self newColumn: arg1 left: arg2 right: nilcollapseAll  self treeModel collapseAllhasCustomSearch  ^searchBlock notNilregisterChangeActions  changesListPresenter whenSelectionChangedDo: [:arg1 |  self updateTextContents.        arg1 selectedItem ifNil: [ classesListPresenter items: {}.              methodsListPresenter items: {} ] ifNotNil: [:arg2 |  classesListPresenter unselectAll.              classesListPresenter items: arg2 changedClasses ] ]testFindClassOn  | tmp1 |  tmp1 := self commandToTest.  self assert: (tmp1 findClassOn: '') equals: nil.  self assert: (tmp1 findClassOn: 'Object') equals: Object.  self assert: (tmp1 findClassOn: 'Object.') equals: Object.  self assert: (tmp1 findClassOn: '.Object.') equals: Object.  self assert: (tmp1 findClassOn: 'somethingBefore := 42.Object') equals: Object.  self assert: (tmp1 findClassOn: 'somethingBefore := 42.Object. somethingAfter := 11') equals: Object.  self assert: (tmp1 findClassOn: 'NonExistingClass.Object.') equals: ObjectbuildWidget  ^SpStubTreeColumnView newresetSelection  self selection unselectAllitalic: arg1  italic := arg1newColumn: arg1 origin: arg2 corner: arg3 offsetOrigin: arg4 offsetCorner: arg5  | tmp1 |  tmp1 := arg1.  tmp1 isBlock ifFalse: [ tmp1 := [:arg6 |  arg6 add: arg1 ] ].  commands add: (SpLayoutAddColumn block: tmp1 layoutFrame: ((arg2 corner: arg3) asSpLayoutFrame                 topLeftOffset: arg4;                 bottomRightOffset: arg5))initialize  super initialize.  label := ''.  self whenLabelChangedDo: [ self changed: #label ].  self whenIconChangedDo: [ self changed: #label ]selectAll  ^self subclassResponsibilityapplication  ^self presenter applicationlabelFor: arg1 error: arg2  ^'Error while accessing label of ' , arg1 accessorCode printStringitemFor: arg1  ^associationsWrapperToItem at: arg1 ifAbsent: [ nil ]testContextMenu  | tmp1 tmp2 |  self assert: presenter contextMenu isNil.  tmp1 := SpMenuPresenter new.  tmp2 := false.  presenter whenMenuChangedDo: [ tmp2 := true ].  presenter contextMenu: tmp1.  self assert: presenter contextMenu equals: tmp1.  self assert: tmp2submergeFrom: arg1 into: arg2  | tmp1 tmp2 tmp3 |  tmp1 := arg1 selectedChangeSet.  tmp2 := arg2 selectedChangeSet.  tmp3 := arg1 selectedChangeSetIndex.  (self model submerge: tmp1 into: tmp2) ifFalse: [ ^self ].  arg1 updateChangesList.  arg1 setSelectedChangeSetIndex: tmp3title  ^self model titlehResizing  ^hResizinglabel  ^self externalIndex printStringapplyTo: arg1  self borderColor ifNotNil: [:arg2 |  arg1 borderColor: arg2 ].  self borderWidth ifNotNil: [:arg3 |  arg1 borderWidth: arg3 ].  self padding ifNotNil: [:arg3 |  arg1 cellInset: arg3 ]testRightClickShouldNotExecuteAction  | tmp1 |  tmp1 := false.  presenter action: [ tmp1 := true ].  self emulateRightClick.  self deny: tmp1ticks: arg1  ticks := arg1.  highestValue := arg1 max: highestValue.  lowestValue := arg1 min: lowestValuewhenVisibleChangedDo: arg1  self property: #visible whenChangedDo: arg1display: arg1  displayBlock := arg1defineInputPorts  ^{SpLabelPort new}buildContentForPage: arg1  ^arg1 retrievePresenter ifNotNil: [:arg2 |  arg2 owner: self presenter.        arg1 layoutSpec ifNil: [ arg2 buildWithSpec ] ifNotNil: [:arg3 |  arg2 buildWithSpec: arg3 ] ]childrenFor: arg1  ^self childrenForObject: arg1 valueevenRowColor  ^self model evenRowColorautoRefresh: arg1  autoRefresh := arg1testChangingFromSingleToMultipleSelection  presenter beSingleSelection.  self deny: presenter isMultipleSelection.  presenter beMultipleSelection.  self assert: presenter isMultipleSelectionnewTransmission  ^SpTransmission newitems: arg1  ^self dropList items: arg1value: arg1  valueBlock := arg1dropEnabled  ^falseoddRowColor: arg1  ^self widget rowColorForOdd: arg1constraintsClass  ^SpOverlayConstraintswhenRootsChanged: arg1  self property: #roots whenChangedDo: arg1recalculatePageHeights  | tmp1 tmp2 tmp3 |  tmp3 := self widget height.  tmp2 := self childrenWidgets.  tmp1 := tmp2 size = 1 ifTrue: [ tmp3 ] ifFalse: [ tmp3 / (layout visiblePages min: tmp2 size) - (layout spacing / (layout visiblePages min: tmp2 size)) ].  tmp2 reverseWithIndexDo: [:arg1 :arg2 |  arg1           top: (arg2 - 1) * tmp1;           height: tmp1 ]tempName  ^tempNameupdateList  | tmp1 |  tmp1 := self generateElements.  self list items = tmp1 ifTrue: [ ^self ].  self list displayBlock: [:arg1 |  self labelFor: arg1 ].  self list items: tmp1.  self list selection selectedIndex > self list items size ifTrue: [ self list setSelectedIndex: self list listItems size ].  self list selectIndex: self list selection selectedIndex.  self list menu: [:arg2 |  self inspectionMenu: arg2 ]initialize  super initialize.  self menuPresenter: self class menuPresenterClass new.  stack := Stack new     push: self menuPresenter;     yourselfcolumnHomogeneous: arg1  columnHomogeneous := arg1buildWindowWithLayout: arg1 presenterLayout: arg2  self adapter: (arg1 asSpLayout buildAdapterFor: self bindings: SpBindings value).  self window: self adapter widget.  self addPresenterIn: self window withSpecLayout: arg2.  self announce: (SpWidgetBuilt model: self widget: self window).  self presenter announce: (SpWindowBuilt model: self).  ^self windowbeResizable  self isResizable: truetestSettingNilResetsGeneratesEvent  | tmp1 |  self presenter selectItem: 10.  self presenter whenSelectionChangedDo: [ tmp1 := true ].  self presenter selectItem: nil.  self assert: tmp1hasChildrenFor: arg1  ^self hasChildrenBlock cull: arg1 cull: selfselectedItems  ^selectionHolder valuewhenLabelChangedDo: arg1  self property: #label whenChangedDo: arg1testBeTextIsSet  presenter beText.  self deny: presenter isPasswordbeNotResizable  self isResizable: falsetestNewComponentListIsEmpty  self assertEmpty: self classToTest newtestChangingRootsResetsSelection  self presenter selection selectPath: #(2 3).  self presenter roots: #(10 11 12).  self assert: self adapter selectedItem equals: niltestUnselectNonSelectedItemDoesNotRemovesSelection  presenter     selectItem: 10;     unselectItem: 30.  self assert: presenter selection selectedItem equals: 10initializeDialogWindow: arg1  arg1     closeOnBackdropClick: false;     addButton: 'Validate' do: [:arg2 |  self inform: 'Validate'.        arg2 close ];     addButton: 'Reset' do: [:arg2 |  self inform: 'This action does not close the modal' ];     addButton: 'Cancel' do: [:arg2 |  self inform: 'Cancel'.        arg2 close ]initialStateNotSet  initialStateSet := falsetestAction  | tmp1 |  tmp1 := false.  self assert: tmp1 equals: false.  presenter action: [ tmp1 := true ].  self openInstance.  self assert: tmp1 equals: false.  presenter adapter action.  self assert: tmp1 equals: truehasChildren: arg1  hasChildren value: arg1classToTest  ^SpCodePresentercodeCommandGroup  | tmp1 |  tmp1 := CmCommandGroup forSpec     beDisplayedAsGroup;     yourself.  self flag: #TODO.  {SpCodeDoItCommand .   SpCodePrintItCommand .   SpCodeInspectItCommand .   SpCodeDebugItCommand .   SpCodeProfileItCommand .   SpCodeBrowseItCommand} do: [:arg1 |  tmp1 register: (arg1 forSpecContext: self) ].  ^tmp1topFraction  ^layoutFrame topFractionopenWithSpec: arg1  ^self application open: self withSpecLayout: (self retrieveSpec: arg1)testModelSettingObjectToValueHolder  | tmp1 tmp2 tmp3 |  tmp1 := 40 @ 54.  tmp2 := 1 @ 0.  tmp3 := SpTestingPresenterWithModel on: tmp1.  self assert: tmp3 announcingObject isSpAnnouncingObject.  self assert: tmp3 announcingObject isValueHolder.  self deny: tmp2 isSpAnnouncingObject.  self deny: tmp2 isValueHolder.  tmp3 model: tmp2.  self assert: tmp3 announcingObject isSpAnnouncingObject.  self assert: tmp3 announcingObject isValueHolder.  self assert: tmp3 model == tmp2.  self assert: tmp3 announcingObject announcer numberOfSubscriptions > 0autoMultiSelection: arg1  autoMultiSelection value: arg1model: arg1  model := arg1mainIconPresenter  ^mainIconPresentervisitImageColumn: arg1  maximum  ^maximumlabel  ^'root'shouldCopy  ^self dragHand shiftPressedinitializePresenters  explanation := self newText.  explanation text: self contenttestUnselectAll  presenter beMultipleSelection.  presenter selectAll.  self assert: (presenter selection selectedItems collect: #label as: Array) equals: #('10' '20' '30').  presenter unselectAll.  self assertEmpty: presenter selection selectedItemsadd: arg1 left: arg2 right: arg3  self add: arg1 top: nil bottom: nil left: arg2 right: arg3initializeWindow: arg1  super initializeWindow: arg1.  self rootCommandsGroup installShortcutsIn: arg1return: arg1  self result: arg1.  self window closeicon: arg1  iconHolder value: arg1hasSelectedObject  ^self selectedElement isNotNilnotify: arg1 on: arg2  self subclassResponsibilitycopySelector: arg1 inClass: arg2 from: arg3 to: arg4  arg4 absorbMethod: arg1 class: arg2 from: arg3testActivatePresenterIsActive  presenter state: true.  self assert: presenter statetitle: arg1  self deprecated: 'With Spec 2, SpPresenter was refactored to move all window management to WindowPresenter.	From now on, if you want to interact with a window you need to:	- Implement #initializeWindow: method (#initializeDialog: for dialogs) to manage window elements before the presenter is opened	- Use the method #window or #withWindowDo: to interact with windows after it has been opened.'.  self window ifNil: [ titleHolder := arg1 ] ifNotNil: [:arg2 |  arg2 title: arg1 ]setRigidityOfNonExpandedMorph: arg1  arg1     vResizing: #spaceFill;     hResizing: #rigidbuildWithSpec  ^SpMockMenu new     realMenu: super buildWithSpec;     whenShownDo: [ shown := true ];     yourselfnewButton  ^self instantiate: SpButtonPresenterclassToTest  ^SpMillerColumnPresenterevaluation: arg1  evaluation := arg1acceptOnCR: arg1  ^self input acceptOnCR: arg1selectedItem  ^self selection selectedItemdefaultIcon  ^self application iconNamed: #arrowDownbehavior: arg1  self deprecated: 'This has been moved to specific presenters' on: '2019-04-15' in: #Pharo8subMenu  ^self newMenu     addItem: [:arg1 |  arg1           name: 'Open';           icon: (self iconNamed: #openIcon);           shortcut: $o meta;           action: [ self inform: 'Open' ] ];     addItem: [:arg1 |  arg1           name: 'Save';           icon: (self iconNamed: #smallSaveIcon);           shortcut: $s meta;           action: [ self inform: 'Save' ] ];     addItem: [:arg1 |  arg1           name: 'Print';           shortcut: $p meta;           icon: (self iconNamed: #smallPrintIcon);           action: [ self inform: 'Print' ] ];     addItem: [:arg1 |  arg1           name: 'Kill';           shortcut: $k meta;           icon: (self iconNamed: #smallCancelIcon);           action: [ self inform: 'Kill' ] ];     yourselfscrollToShowLastPage  self widget defer: [ self widget scrollToShow: innerWidget submorphs last bounds ]selectedIndexes  ^self isEmpty ifTrue: [ #() ] ifFalse: [ {self selectedIndex} ]initializeDialogWindow: arg1  arg1 addButton: 'Ok' do: [:arg2 |  self performOkAction.        arg2 close ]selectedObject  ^self inspector selectedObjectintervalOf: arg1 inCommentText: arg2  ^self searchedString: arg1 asString in: arg2testWhenClassSideRadioClickShouldChangeProtocolList  biChooseMethod packageList selectItem: self class package.  biChooseMethod classList selectItem: SpMethodChooserMockClass.  biChooseMethod radioButtonClassSide click.  self assertCollection: (biChooseMethod protocolList items collect: #name) hasSameElements: SpMethodChooserMockClass class protocolstestIcon  self assert: command icon isNil.  command iconName: #add.  self assert: command icon equals: (command iconNamed: #add)selectLine  self context selectLine.  ^self selectionexploreSelectedObject  self selectedObjectDo: [:arg1 |  arg1 inspect ]model  ^modelexpand  ^expandselectedPageName  ^(self widget tabSelectorMorph selectedTab label submorphs detect: [:arg1 |  arg1 isKindOf: StringMorph ]) contentsstate: arg1  state := arg1iconBlock: arg1  iconBlock value: arg1acceptDropBlock: arg1  acceptDropBlock := arg1headerLabel: arg1  headerLabel value: arg1currentValue  ^currentValueisPassword  ^self widget font isKindOf: FixedFaceFontclassToTest  ^SpTablePresentersetBottomOffset: arg1 for: arg2 borderWidth: arg3  arg2 bottomFraction = 1 ifTrue: [ arg1 isZero ifTrue: [ arg2 bottomOffset: arg3 negated ] ifFalse: [ arg2 bottomOffset: arg1 - self splitterWidth ] ]buildWithSpecLayout: arg1  ^(self buildAdapterWithSpecLayout: arg1) widgettestSelectPathAddsIndexToSelectedPathList  presenter selectPath: #(1).  self assert: (presenter selection includesPath: #(1))acceptOnCR: arg1  self input acceptOnCR: arg1classToTest  ^SpComponentListPresenterobservablePropertyNamed: arg1  | tmp1 |  tmp1 := self class slotNamed: arg1.  tmp1 isObservableSlot ifFalse: [ SpNonObservableSlotError signal: arg1 ].  ^tmp1 rawRead: selfisExpanded: arg1  self nodeModel isExpanded: arg1isResizable  ^isResizableproperty: arg1 rawValue: arg2  (self observablePropertyNamed: arg1) rawValue: arg2testSortingBlock  | tmp1 |  tmp1 := 0.  presenter whenSortingBlockChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  presenter items: #(3 8 1 0).  presenter sortingBlock: #yourself ascending.  self assert: tmp1 equals: 1.  self assert: (presenter model at: 1) equals: 0label: arg1  slider label: arg1toolbarPresenter  ^toolbarPresenterwhenShowColumnHeadersChangedDo: arg1  self property: #showColumnHeaders whenChangedDo: arg1beSingleSelection  self selectionMode: (SpTreeSingleSelectionMode on: self)textArea  self flag: #REMOVEME.  ^self adapter widgetisItalic  ^italic == trueactivatesOnDoubleClick  ^activateOnSingleClick notitemAt: arg1  ^self model at: arg1pressTab  self keyPressed: Character tab asciiValue shift: false meta: false control: false option: false.  self waitUntilUIRedrawedtestWhenSelectPathTwiceThenIsListedOnceInSelectedPaths  presenter     selectPath: #(3 1);     selectPath: #(3 1).  self assertCollection: presenter selection selectedPaths hasSameElements: {#(3 1)}showOptions  ^self model showOptionstestWhenActionChangedDo  | tmp1 tmp2 tmp3 |  tmp1 := false.  tmp2 := [ 1 ].  tmp3 := presenter action.  self assert: tmp1 equals: false.  presenter whenActionChangedDo: [:arg1 :arg2 |  self assert: arg2 equals: tmp3.        self assert: arg1 equals: tmp2.        tmp1 := true ].  self openInstance.  self assert: tmp1 equals: false.  presenter action: tmp2.  self assert: tmp1 equals: trueaddConstraits: arg1 toChild: arg2  arg2 hResizing: #spaceFill.  arg2 vResizing: #spaceFill.  arg2 setProperty: #gridConstraints toValue: arg1.  ^arg2array: arg1  specArray := arg1initializePresenters  entityText := self newTextInput     placeholder: self placeholder;     autoAccept: true;     entryCompletion: self entitiesEntryCompletion;     yourself.  selectEntity := self newButton     icon: (self iconNamed: #glamorousSearch);     help: 'Open a selection dialog'.  self focusOrder     add: entityText;     add: selectEntitybuttons  ^buttonscomputeSplittersIn: arg1  (self commands select: #isSplitter) ifNotEmpty: [:arg2 |  arg2 do: [:arg3 |  arg1 addAll: arg3 asSpecElements ].        arg1 add: #checkSplitters ]pagesChanged  self changed: #updatePagesvisitIndexColumn: arg1  isCheckList: arg1  isCheckList value: arg1entryCompletion  ^entryCompletionwhenSelectionChangedDo: arg1  listModel whenSelectionChangedDo: arg1listItems  self deprecated: 'Please use the #model instead' transformWith: '`@receiver listItems' -> '`@receiver model items'.  ^self model itemsfieldNormal: arg1  fieldNormal := arg1initializePresenters  firstPresenter := self newButton label: 'First'.  secondPresenter := self newButton label: 'Second'.  thirdPresenter := self newButton label: 'Third'keepTreeNode: arg1  ^arg1 matchTokenFilter: selfselectedItems  ^tree selectedItemsclassToTest  ^SpMenuButtonPresenterconnectPresenters  searchPresenter whenTextChangedDo: [:arg1 |  searchPresenter text asLowercase ifEmpty: [ listPresenter items: baseItems ] ifNotEmpty: [:arg2 |  listPresenter items: (baseItems select: [:arg3 |  arg3 asLowercase beginsWith: arg2 ]) ] ]rootNodeFromItem: arg1  ^self model rootNodeFromItem: arg1showDiffMorphWithConverter: arg1  sourcePresenter := self newDiff.  isShowingDiff := true.  self needRebuild: false.  self buildWithSpec.  self textConverter: arg1.  sourcePresenter contextClass: self selectedMessage methodClass.  messageList selectIndex: messageList selectedIndexclassToTest  ^SpTextPresenterselectedMessage  ^listModel selection selectedItemtestStayingInactiveDoesNotRaiseChangedEvent  presenter state: false.  self denyEvent: #whenChangedDo: isRaisedInPresenter: presenter whenDoing: [ presenter state: false ]label: arg1  label label: arg1selectPath: arg1  | tmp1 |  ((arg1 isEmpty or: [ arg1 first = 0 ]) and: [ widget selectedIndexes isEmpty ]) ifTrue: [ ^self ].  tmp1 := arg1 ifNotEmpty: [ widget dataSource indexFromPath: arg1 ] ifEmpty: [ 0 ].  (widget selectedIndexes includes: tmp1) ifTrue: [ ^self ].  widget selectIndex: tmp1table: arg1  table := arg1splitterWidth  ^4namesOfDaysLabels: arg1  namesOfDaysLabels := arg1testUnselectNonSelectedItemRaisesNoEvent  | tmp1 |  tmp1 := 0.  presenter     selectItem: 10;     whenSelectionChangedDo: [ tmp1 := tmp1 + 1 ];     unselectItem: 20.  self assert: tmp1 equals: 0place: arg1 at: arg2  arg1 setProperty: #gridConstraints toValue: (SpGridConstraints at: arg2)initialize  super initialize.  self toolbarPresenter: SpToolBarPresenter newneedFullRebuild: arg1  self needRebuild: arg1.  self presentersDo: [:arg2 |  arg2 needRebuild: arg1 ]add: arg1 constraints: arg2  testUnselectUnselectedIndexKeepsSelectionList  presenter     selectIndex: 1;     unselectIndex: 2.  self assert: presenter selection selectedIndexes asArray equals: #(1)classToTest  ^SpAthensStaticPresenteradapterName  ^self subclassResponsibilityinitializePresenters  (table := self newTable)     items: Smalltalk allClassesAndTraits;     addColumn: (SpCompositeTableColumn new           title: 'Test';           addColumn: ((SpImageTableColumn evaluated: [:arg1 |  arg1 systemIcon ]) width: 20);           addColumn: (SpStringTableColumn evaluated: [:arg1 |  arg1 name ]))testSetRootModelWithoutPresenterBlockFails  self should: [ self presenter setRootModel: 1 ] raise: ErrorbuildWithSpec  ^self widgetcontextMenu: arg1  contextMenu := arg1selectedIndexes  self subclassResponsibilityinitializePresenters  nameLabel := self newLabel label: 'name:'.  nameTextInput := self newTextInput autoAccept: true.  surnameLabel := self newLabel label: 'surname:'.  surnameTextInput := self newTextInput autoAccept: true.  surnameTextInput placeholder: 'empty'.  number1Label := self newLabel label: 'number 1:'.  number1Input := self newNumberInput autoAccept: true.  number2Label := self newLabel label: 'number 2:'.  number2Input := self newNumberInput     autoAccept: true;     beFloat;     digits: 3;     climbRate: 0.005;     minimum: 10.005;     maximum: 20.05.  scaleLabel := self newLabel label: 'scale:'.  scaleInput := self newSlider.  passwordLabel := self newLabel label: 'password:'.  passwordInput := self newTextInput     bePassword;     autoAccept: true.  checkboxLabel := self newLabel label: 'remember me'.  checkboxInput := self newCheckBox state: true.  dateLabel := self newLabel label: 'date:'.  dateInput := self instantiate: SpDatePresenter.  dateInput display: [:arg1 |  arg1 yyyymmdd ].  maleButton := self newRadioButton label: 'male'.  femaleButton := self newRadioButton label: 'female'.  maleButton associatedRadioButtons: {femaleButton}.  genderButtons := Dictionary newFrom: {(#male -> maleButton) .         (#female -> femaleButton)}.  genderLabel := self newLabel label: 'gender:'.  itemsLabel := self newLabel label: 'items:'.  itemsInput := self newList.  itemsInput beMultipleSelection.  itemsInput items: self model items.  submitButton := self newButton label: 'Submit'.  restoreButton := self newButton label: 'Restore'.  self focusOrder     add: nameTextInput;     add: surnameTextInput;     add: number1Input;     add: number2Input;     add: scaleInput;     add: passwordInput;     add: checkboxInputcontextMenuFromCommandsGroup: arg1  self contextMenu: [ arg1 value beRoot asMenuPresenter ]addColumns: arg1  arg1 do: [:arg2 |  self addColumn: arg2 ]message  ^messagetestNewPresenter  | tmp1 |  tmp1 := application newPresenter: SpButtonPresenter.  self assert: tmp1 application equals: applicationinitialize  super initialize.  buttons := OrderedCollection new.  canDeselectByClick := false asValueHolder.  currentlyActivated := nil asValueHolderselection  ^selectiondisplayIn: arg1 do: arg2  self displayStrategy display: self in: arg1 do: arg2whenSearchChangedDo: arg1  self property: #searchEnabled whenChangedDo: arg1buttonDisabled  ^buttonDisabledhelp  ^self model helpmax  ^maxhasWindow: arg1  ^self windows includes: arg1label: arg1  labelPresenter label: arg1bePlacedAtEnd  placedAtStart := falsetestChangeLabel  self redMorphTab.  manager addTab: presenter.  self assert: presenter label equals: 'Red Morph'.  presenter label: 'Change Before Opening'.  self assert: presenter label equals: 'Change Before Opening'.  window := manager openWithSpec.  presenter label: 'Change After Opening'.  self assert: presenter label equals: 'Change After Opening'rootNodeFromItem: arg1  | tmp1 |  tmp1 := (arg1 isKindOf: SpTreeNodePresenter) ifTrue: [ arg1 ] ifFalse: [ self rootNodeHolder cull: arg1 ].  tmp1 container: self model.  ^tmp1 buildWithSpecbuildWidget  ^SpDialogWindow new     model: self model;     yourselfminExtentOrDefault  ^minExtent ifNil: [ 0 @ 0 ]nullPresentersInstVarNames  ^nullPresentersInstVarNamesinitializePresenters  uniformDropList := self newDropList.  heterogeneousDropList := self newDropList.  container := self newMorph.  disabledDropList := self newDropList.  container morph: PanelMorph new.  self instantiateMorphs.  self containerMorph     changeTableLayout;     listDirection: #bottomToLeft.  disabledDropList     items: #('Disabled' 'Two' 'Three');     display: [:arg1 |  arg1 ];     disable.  uniformDropList     items: {morph1 .         morph2 .         morph3};     display: [:arg2 |  arg2 color name capitalized , ' morph' ];     iconBlock: [:arg3 |  self iconNamed: #testGreenIcon ];     whenSelectedItemChangedDo: [:arg2 |  self containerMorph           removeAllMorphs;           addMorph: arg2 ].  heterogeneousDropList     addItemLabeled: 'Open workspace' do: [ Smalltalk tools workspace open ] icon: (self iconNamed: #smallOkIcon);     addItemLabeled: 'Inspect current morph' do: [ uniformDropList selectedItem inspect ] icon: (self iconNamed: #testRedIcon).  uniformDropList selectIndex: 1.  self setFocusasMenuBarPresenterWith: arg1  | tmp1 |  tmp1 := SpMenuBarPresenterBuilder new.  arg1 value: tmp1 menuPresenter.  ^tmp1     visit: self;     menuPresenterisEditable  ^falsewhenActivatedDo: arg1  ^self whenActionPerformedDo: arg1selectIndex: arg1  self selectionMode selectIndex: arg1newDiff  ^self instantiate: SpDiffPresenterinspectNext  history hasNext ifFalse: [ ^self ].  self inspectHistoryItem: history nextdisplayBlock: arg1  self deprecated: 'Please use #display: instead' transformWith: '`@receiver displayBlock: `@arg' -> '`@receiver display: `@arg'.  ^self list display: arg1installShortcutsIn: arg1  SpShortcutInstaller new     presenter: arg1;     visit: selfmethodNamed: arg1  ^(self isInstanceSideSelected ifTrue: [ self selectedClass ] ifFalse: [ self selectedClass class ]) methodNamed: arg1topFraction: arg1  layoutFrame topFraction: arg1testChangingLabelAffectTheWidget  presenter label: 'ALabel'.  self assert: self widget label equals: 'ALabel'resizable  ^resizable valuedropListModel  ^dropListModelclose  tabSelectedAction  ^tabSelectedActionHolder valuetestUnselectWidgetIndexRaisesSelectionIndexChangeEventOnce  | tmp1 |  tmp1 := 0.  self adapter selectIndex: 1.  presenter selection whenChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  self adapter selectIndex: 0.  self assert: tmp1 equals: 1maximum: arg1  maximum := arg1whenLabelChangedDo: arg1  self property: #label whenChangedDo: arg1testSelectPathRaisesSelectionChangeEventWithSelectedPath  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedPaths ].  presenter selectPath: #(1 2).  self assert: (tmp1 includes: #(1 2))menu: arg1  tree menu: arg1selectedPaths  selection ifEmpty: [ ^#() ].  ^{selection}selectedItem: arg1  tree selectedItem: arg1asSpLayoutFrame  ^selfdefaultWaitDuration  ^500 milliSecondabsoluteValue  ^self sliderInput absoluteValuebeCheckList  self isCheckList: truedoItReceiver: arg1  doItReceiver := arg1performCancelAction  ^self cancelAction value == false ifFalse: [ cancelled := true.        owner ifNil: [ self delete ] ifNotNil: [ owner delete ] ]defaultColumn  ^SpStringTableColumn new evaluated: #yourselfprintTimeout  ^10 secondsisColumnHomogeneous  ^self layout isColumnHomogeneouscomputeSpecFrom: arg1  | tmp1 |  tmp1 := (arg1 isSymbol and: [ (self isPresenterSymbol: arg1) not ]) ifTrue: [ | tmp2 |        tmp2 := self convertSymbolOfClassToInstance: arg1.        (tmp2 isKindOf: SpContainerPresenter) ifTrue: [ tmp2 := self getAdaptorWithDefaultSpecOf: tmp2.              self presenter addDependent: tmp2 ].        tmp2 ] ifFalse: [ self class interpretASpec: arg1 presenter: self presenter ].  selector ifNotNil: [:arg2 |  tmp1 selector: arg2 ].  ^tmp1testDefaultRowColors  | tmp1 |  tmp1 := Smalltalk ui theme backgroundColor.  treeWithItems buildWithSpec.  self assert: treeWithItems adapter widget rowColors equals: (Array with: tmp1 with: tmp1)selectedPageIndex: arg1  self deprecated: 'Use #selectPageIndex: instead' transformWith: '`@receiver selectedPageIndex: `@statements1' -> '`@receiver selectPageIndex: `@statements1'.  self selectPageIndex: arg1rightLabel: arg1  rightLabel := arg1whenAboutToStyleChangedDo: arg1  self whenAboutToStyleBlockChanged: [:arg2 :arg3 :arg4 :arg5 |  arg1 cull: arg2 value cull: arg3 cull: arg4 cull: arg5 ]testFFGoesToNegativeInfinity  timeline fastForward.  self assert: timeline ticks equals: Float negativeInfinitytestRewindGoesToPositiveInfinity  timeline rewind.  self assert: timeline ticks equals: Float infinityrawValue: arg1  value := arg1okToChange  ^self hasWindow ifTrue: [ self window okToChange ] ifFalse: [ true ]whenEnabledChangedDo: arg1  self property: #enabled whenChangedDo: arg1whenSelectionChanged: arg1  self deprecated: 'Use #whenSelectionChangedDo: instead.' transformWith: '`@receiver whenSelectionChanged: `@statements' -> '`@receiver whenSelectionChangedDo: `@statements'.  self whenSelectionChangedDo: arg1model: arg1  model := arg1testUnselectPresenterIndexUnselectsIndexInWidget  presenter     selectPath: #(1);     unselectPath: #(1).  self assert: self adapter selectedPaths isEmptyinitialWidth  ^self model initialWidthmessageListMenu  ^self newMenu     addGroup: [:arg1 |  arg1           addItem: [:arg2 |  arg2                 name: 'Browse full...';                 shortcut: $b meta;                 action: [ self selectedMethod browse ] ];           addItem: [:arg2 |  arg2                 name: 'Inspect method...';                 shortcut: $i meta;                 action: [ self selectedMethod inspect ] ] ];     addGroup: [:arg1 |  arg1           addItem: [:arg2 |  arg2                 name: 'Remove method...';                 shortcut: $x meta;                 action: [ self selectedMethod removeFromSystem ] ];           addItem: [:arg2 |  arg2                 name: 'Senders of...';                 shortcut: $n meta;                 action: [ model browseSendersOfMessagesFrom: self selectedMethod selector ] ];           addItem: [:arg2 |  arg2                 name: 'Implementors of...';                 shortcut: $m meta;                 action: [ model browseMessagesFrom: self selectedMethod selector ] ] ];     addItem: [:arg2 |  arg2           name: 'Users of...';           shortcut: $N meta;           action: [ model browseClassRefsOf: self selectedMethod methodClass ] ];     addItem: [:arg2 |  arg2           name: 'Versions...';           shortcut: $v meta;           action: [ model browseVersionsFrom: self selectedMethod ] ] yourselfclick  self executebeVerticalAlignmentStart  self vAlign: SpGridAlignment startupdateBlock  ^updateBlockisShowingColumnHeaders  ^self presenter isShowingColumnHeadersmaxLength  ^maxLengthplace: arg1 at: arg2 span: arg3  arg1 setProperty: #gridConstraints toValue: (SpGridConstraints at: arg2 span: arg3)traversePresentersDo: arg1 excluding: arg2  arg2 add: self.  arg1 value: selftestUnselectAllInWidgetRaisesSelectionIndexChangeEventOnce  | tmp1 |  tmp1 := 0.  self adapter selectIndex: 1.  presenter selection whenChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  self adapter selectIndex: 0.  self assert: tmp1 equals: 1subMenu  | tmp1 |  tmp1 := self model subMenu.  tmp1 ifNil: [ ^nil ].  ^(tmp1 isBlock or: [ tmp1 isMessageSend ]) ifTrue: [ tmp1 cull: self model ] ifFalse: [ tmp1 buildWithSpecAsPopup ]absoluteValue: arg1  absoluteValue := arg1codeFor: arg1  ^TonelWriter sourceCodeOf: arg1selectAll  ^self list selectAllnewPanelMorph  ^Morph new     changeTableLayout;     hResizing: #spaceFill;     vResizing: #rigid;     height: self class defaultHeight;     cellInset: self class defaultItemSeparation;     color: Color random;     yourselfobjectAsUTF8String  ^String streamContents: [:arg1 |  | tmp1 tmp2 |        tmp2 := ZnUTF8Encoder new.        tmp1 := self object readStream.        [ tmp1 atEnd ] whileFalse: [ arg1 nextPut: (tmp2 nextFromStream: tmp1) ] ] limitedTo: 5000browseDefinitionOfSelectedShortcut  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self kmTable selection selectedItem ifNil: [ ^self ].  tmp2 := tmp1 realValue keymap action ifNil: [ ^self ].  tmp3 := tmp2 method methodClass.  tmp4 := tmp2 method selector.  Smalltalk tools browser openOnClass: tmp3 selector: tmp4 highlight: tmp1 shortcutNametestSelectItemSelectsTheGivenElement  self presenter selection selectPath: #(2).  self assert: self adapter selectedItem equals: 2buildCodeKeyBindings  ^self codeCommandGroup asKMCategorymethod3  resetSelection  ^self dropList resetSelectiontestAddPresenterToComponentListRaisesEvent  | tmp1 tmp2 |  tmp2 := false.  tmp1 := SpButtonPresenter new.  presenter whenPresentersChangedDo: [ tmp2 := true ].  presenter addPresenter: tmp1.  self assert: tmp2classOrMetaClass: arg1  self setEditingModeFor: self widget withBehavior: arg1testSetSelectItemOutsideRangeDoesNotModifySelection  presenter whenSelectionChangedDo: [:arg1 |  self fail ].  presenter selectItem: 100testPresenterProvidedByConfiguredAs  | tmp1 |  self     assert: builder presenterBlock isNil;     assert: builder configurationBlock isNil.  tmp1 := [:arg1 :arg2 |   ].  builder presenterProvidedBy: [:arg3 |  arg3 even ifTrue: [ SpButtonPresenter ] ifFalse: [ SpLabelPresenter ] ] configuredAs: tmp1.  self     assert: (builder presenterBlock value: 1) equals: SpLabelPresenter;     assert: (builder presenterBlock value: 2) equals: SpButtonPresenter;     assert: builder configurationBlock equals: tmp1addInstancesVariable: arg1  self object class allInstVarNames do: [:arg2 |  arg1 add: (InstanceVariableEyeElement host: self object instVarName: arg2) ]okAction: arg1  self toolbar okAction: arg1classToTest  ^SpTablePresentermodel  self deprecated: 'Model was renamed Presenter in Pharo 7' transformWith: '`@receiver model' -> '`@receiver presenter'.  ^self presenterselectedItemsAtIndexes: arg1  ^arg1 collect: [:arg2 |  self listElementAt: arg2 ]enableItemSubstringFilter  self itemFilter: [:arg1 :arg2 |  arg1 asLowercase includesSubstring: arg2 asLowercase ]whenSelectionModeChangedDo: arg1  selectionMode whenChangedDo: arg1doesNotUnderstand: arg1  (self hasProperty: arg1 selector) ifTrue: [ | tmp1 |        tmp1 := self objectAtProperty: arg1 selector.        ^tmp1 isBlock ifTrue: [ tmp1 valueWithPossibleArgs: arg1 arguments ] ifFalse: [ tmp1 value ] ].  self theme ifNotNil: [:arg2 |  ^arg2 perform: arg1 selector withArguments: arg1 arguments ].  ^super doesNotUnderstand: arg1basicBuildAdapterWithSpecLayout: arg1  self flag: #TODO.  layout := arg1.  ^super basicBuildAdapterWithSpecLayout: arg1items  ^leftItems , rightItemsinitialize  properties := Dictionary new.  super initializedragPassengerFor: arg1 inMorph: arg2  ^self dragTransformationBlock cull: arg1 cull: arg2autoAccept  ^autoAccepttestActivationOnSingleClickShouldNotActivateOnClickOutside  | tmp1 |  tmp1 := nil.  presenter     activateOnSingleClick;     whenActivatedDo: [:arg1 |  tmp1 := arg1 selectedIndex ].  presenter clickAtIndex: 100.  self assert: tmp1 equals: niltestDefaultIsNotPassword  self deny: presenter isPasswordinspector  ^inspectorinspectorTypes  ^self inspectorWrapper inspectorTypeswindowIsClosing  self model windowIsClosingmethodsMenu: arg1  methodsListPresenter contextMenu: arg1testSetSelectIndexRaisesSelectionChangeEventWithSelectedIndex  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedIndex ].  presenter selectIndex: 1.  self assert: tmp1 equals: 1selectFileTitle: arg1  self subclassResponsibilitybuildActionButton: arg1  | tmp1 |  self flag: #TODO.  tmp1 := arg1 buildWithSpec.  arg1 adapter     styleName: 'actionButton';     applyStyle: tmp1.  ^tmp1presenter: arg1  arg1 owner: self.  presenter := arg1absoluteValue  ^absoluteValuebeEncrypted  self deprecated: 'Use #bePassword instead' transformWith: '`@receiver beEncrypted' -> '`@receiver bePassword'.  self bePasswordlayout: arg1 in: arg2  calculating ifTrue: [ ^self ].  [ calculating := true.  self basicLayout: arg1 in: arg2 ] ensure: [ calculating := false ]width: arg1  self extent: arg1 @ self extentOrDefault yprogress: arg1  self progress: arg1 every: 0.2 secondsortingBlock: arg1  messageList sortingBlock: arg1defaultModifierShortcut  ^self shortcut first isUppercase ifTrue: [ OSPlatform current defaultModifier + KMModifier shift + self shortcut first ] ifFalse: [ OSPlatform current defaultModifier + self shortcut first ]openWithSpec  ^self application open: self withSpecLayout: self retrieveDefaultSpectestInitialPosition  presenter initialPosition: 100 @ 100.  self openInstance.  self assert: window adapter widget position equals: 100 @ 100isExpand  ^expand == truetestSettingAnImageSetsTheImage  self presenter image: self imageForm.  backendForTest assertImage: self adapter image equals: self imageFormheaderIcon: arg1  headerIcon value: arg1whenScrollValueChanged: arg1  self deprecated: 'Use #whenScrollValueChangedDo: instead.' transformWith: '`@receiver whenScrollValueChanged: `@statements' -> '`@receiver whenScrollValueChangedDo: `@statements'.  self whenScrollValueChangedDo: arg1pageClass  ^SpProgressBarDemoforgetMessage  self okToChange ifFalse: [ ^self ].  self selectedSelector ifNotNil: [:arg1 |  self model forgetSelector: arg1 inClass: self selectedClass fromChangeSet: self selectedChangeSet.        self updateClassesList.        self setSelectedClassIndex: self selectedClassIndex ]addModelTo: arg1  self flag: #TODO.  (self model items at: #start ifAbsent: [ #() ]) do: [:arg2 |  arg1 submorphs first addMorphBack: (self buildActionButton: arg2) ].  (self model items at: #end ifAbsent: [ #() ]) reverseDo: [:arg2 |  arg1 submorphs second addMorphBack: (self buildActionButton: arg2) ]classToTest  ^SpImagePresentertestSelectPresenterIndexOutsideRangeUnsetsSelectedIndexInWidget  presenter selectPath: #(100).  self assert: self adapter selectedPaths isEmptyaddModelTo: arg1  self presenter columns do: [:arg2 |  arg1 addColumn: (self newColumnFrom: arg2) ].  self ensureAtLeastOneColumnIn: arg1.  self presenter selection isMultipleSelection ifTrue: [ arg1 beMultipleSelection ].  self isShowingColumnHeaders ifTrue: [ arg1 showColumnHeaders ] ifFalse: [ arg1 hideColumnHeaders ].  self isResizable ifTrue: [ arg1 beResizable ] ifFalse: [ arg1 beNotResizable ].  self isSearchEnabled ifTrue: [ arg1 enableSearch ] ifFalse: [ arg1 disableFunction ].  arg1 setBalloonText: self model help.  arg1 dataSource: self newDataSource.  self presenter selection isEmpty ifFalse: [ self updateSelectionOf: arg1 ].  self presenter whenSelectionChangedDo: [ self updateSelectionOf: arg1 ].  self presenter whenRootsChangedDo: [ arg1 selectIndexes: #().        arg1 dataSource: self newDataSource ].  self presenter whenShowColumnHeadersChangedDo: [ self isShowingColumnHeaders ifTrue: [ arg1 showColumnHeaders ] ifFalse: [ arg1 hideColumnHeaders ] ].  self presenter whenColumnsChangedDo: [ arg1 columns: #().        self presenter columns do: [:arg2 |  arg1 addColumn: (self newColumnFrom: arg2) ].        arg1 dataSource: self newDataSource ].  arg1     onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self;     onAnnouncement: FTStrongSelectionChanged send: #strongSelectionChanged: to: selftextHolder  self deprecated: 'Nobody should access directly to internals of Spec. Now the text is an observable slot and not a value holder.'defaultHeight  ^self class splitterWidthisInput  ^falsewhenColumnsChangedDo: arg1  self property: #columns whenChangedDo: arg1iconName: arg1  self icon: (self iconNamed: arg1)selectPath: arg1  arg1 ifEmpty: [ ^self unselectAll ].  (selection includes: arg1) ifTrue: [ ^self ].  presenter itemAtPath: arg1 ifAbsent: [ ^self ].  selection := selection copyWith: arg1valueChanged  self valueChanged: nilselectedItem  ^self dropList selectedItemaskBeforeChanging  ^falseisResizable: arg1  isResizable := arg1addButton  ^addButtonsetGhostText: arg1 to: arg2  arg2 ghostText: arg1packageList  ^packageListaddItem: arg1 position: arg2  arg2 addItem: arg1 into: self.  self width: self width + arg1 width.  self refreshadapter  ^presenter adapteraddFocusRotationKeyBindings  self widget tabSelectorMorph     bindKeyCombination: Character tab asKeyCombination toAction: [ self focusNext ];     bindKeyCombination: Character tab shift asKeyCombination toAction: [ self focusPrevious ]padding: arg1  padding := arg1showOptions  ^showOptionsclearUndoManager  self widget textArea editingState clearUndoManager: nilfindClassOn: arg1  | tmp1 |  tmp1 := RBParser parseExpression: arg1 onError: [ ^nil ].  tmp1 nodesDo: [:arg2 |  (arg2 isVariable and: [ arg2 name first isUppercase ]) ifTrue: [ (self class environment classNamed: arg2 name) ifNotNil: [:arg3 |  ^arg3 ] ] ].  ^niltraverseInFocusOrderDo: arg1 excluding: arg2  self pages do: [:arg3 |  arg3 traverseInFocusOrderDo: arg1 excluding: arg2 ]initialize  topologySort := true.  model := AbstractTool new.  super initializeinspectorType: arg1  ^self inspectorWrapper inspectorType: arg1basicAdd: arg1 constraints: arg2 to: arg3  | tmp1 |  tmp1 := self buildMorph: arg1 constraints: arg2.  arg3 addMorph: tmp1.  ^tmp1handlesDoubleClick  ^handlesDoubleClickstate  ^self presenter statetabSelectedAction  ^tabSelectedAction valuenewVertical  ^self newPanel     listDirection: #topToBottom;     addMorphBack: (self newPanel           listDirection: #topToBottom;           yourself);     addMorphBack: (self newPanel           listDirection: #topToBottom;           vResizing: #shrinkWrap;           height: 0;           yourself);     yourselfinitialExtent  ^900 @ 550list  ^listtestSetHeaderTitleHasTitle  presenter headerTitle: 'title'.  self assert: presenter hasHeaderTitlenewComponentList  ^self instantiate: SpComponentListPresenterbindings  ^self class bindingsaddKeyBindingsTo: arg1  isExecutable  ^falseconstraintsClass  ^SpPanedConstraintswidth: arg1  self hRigid.  self widgetDo: [:arg2 |  arg2 width: arg1 ]okActionBlock  ^[ self okAction value == false ifFalse: [ owner ifNil: [ self delete ] ifNotNil: [ owner delete ] ] ]transform: arg1  ^arg1 at: self indextext  ^textnewScrollPaneFor: arg1  ^MillerScrollPane new     changeScrollerTableLayout;     hResizing: #spaceFill;     vResizing: #spaceFill;     color: Color transparent;     borderColor: Color transparent;     scrollTarget: arg1;     onLayoutChange: [ self recalculatePages ];     yourselfrunTest: arg1  app := SpApplication new.  app useBackend: #Morphic.  arg1 valuepushModel: arg1  self addPresenter: (self newPresenterFor: arg1)packageButton  ^packageButtonaddVerticalPadding: arg1 toMorph: arg2  ^self newWrapMorph     hResizing: arg2 hResizing;     vResizing: arg2 vResizing;     width: arg2 width;     height: arg2 height + (arg1 * 2);     addMorph: (arg2           hResizing: #spaceFill;           vResizing: #spaceFill;           yourself) fullFrame: (LayoutFrame identity           topOffset: arg1;           bottomOffset: arg1 negated);     yourselftestSelectItemAddsItemToSelectedItemList  presenter selectItem: 10.  self assert: (presenter selection includesItem: 10)reset  self actualPageMorph: nilresetLabel  label label: (selectedClasses ifEmpty: [ 'No class checked' ] ifNotEmpty: [ (selectedClasses collect: #printString) joinUsing: ' - ' ])filteringBlock  self deprecated: 'This feature is now removed from Spec 2. If the visible elements of the list need to be changed, it''s the users of the lists that should manage it and update the list of items of the list.'.  ^nilrebuildDynamicPresenter  builder := SpDynamicPresentersListBuilder new     modelObjects: (1 to: 15);     presenter: SpButtonPresenter configuredAs: [:arg1 :arg2 |  arg1 label: arg2 asString ];     layoutBuilder: (SpDynamicLeftToRightColumnsLayout columns: 5);     yourself.  self newDynamicPresentersListIn: #dynamicPresenter usingBuilder: builderbeep  buildSelectorDescriptionFor: arg1 class: arg2 selector: arg3  | tmp1 tmp2 |  tmp1 := arg1 atSelector: arg3 class: arg2.  tmp1 == #remove ifTrue: [ ^'Method has been removed (see versions)' ].  tmp1 == #addedThenRemoved ifTrue: [ ^'Added then removed (see versions)' ].  arg2 ifNil: [ ^'Method was added, but cannot be found!' ].  (arg2 includesSelector: arg3) ifFalse: [ ^'Method was added, but cannot be found!' ].  tmp2 := arg2 sourceCodeAt: arg3.  ^tmp2 asTextprogression: arg1  progression := arg1display: arg1  displayBlock := arg1add: arg1  self add: arg1 withConstraints: [:arg2 |   ]retrieveSpecFrom: arg1  self presenter needRebuild ifTrue: [ spec := self computeSpecFrom: arrayToInterpret first ] ifFalse: [ spec := self presenter spec.        self presenter needRebuild: true.        spec ifNil: [ spec := self computeSpecFrom: arrayToInterpret first ] ifNotNil: [ spec isRedrawable ifTrue: [ spec removeSubWidgets ] ifFalse: [ ^spec ] ] ].  ^nilparseStyleName  | tmp1 |  readStream next.  tmp1 := self stringStreamContents: [:arg1 |  [ readStream atEnd not and: [ self isClassChar: readStream peek ] ] whileTrue: [ arg1 nextPut: readStream next ] ].  self consumeWhitespace.  ^tmp1 asStringrow  ^self position yrecalculatePages: arg1  self subclassResponsibilitypropertiesLike: arg1  ^(self styles inject: OrderedCollection new into: [:arg2 :arg3 |  arg3 properties select: [:arg4 |  arg4 class = arg1 ] thenDo: [:arg4 |  arg2 add: arg4 ].        arg2 ]) flattenedborderWidth: arg1  borderWidth := arg1isResizable  ^isResizablesetModel: arg1  ghostText: arg1  self deprecated: 'This API is too tight to Morph. Use #placeholder: instead.' transformWith: '`@receiver ghostText: `@statement' -> '`@receiver placeholder: `@statement'.  self placeholder: arg1performOkAction  okBlock valuenewSet  | tmp1 |  self selectedChangeSet ifNil: [ ^self inform: 'No change set selected' ].  self okToChange ifFalse: [ ^self ].  tmp1 := self model createNewSet.  tmp1 ifNotNil: [ self updateChangesList.        changesListPresenter setSelectedItem: tmp1.        self updateWindowTitle ]label  ^labelinitializePresenters  buttonNormal := self newButton label: 'normal'.  buttonDisabled := self newButton     label: 'disabled';     disable;     yourself.  buttonWithIcon := self newButton     label: 'with icon';     icon: ((self iconNamed: #pharo) scaledToSize: 16 @ 16);     yourself.  buttonWithIconOnly := self newButton     icon: ((self iconNamed: #pharo) scaledToSize: 16 @ 16);     help: 'This button has only icon, no label';     yourself.  buttonHighlighted := self newButton     label: 'highlighted';     state: true;     yourself.  buttonWithColor := self newButton     label: 'red';     color: Color red;     yourself.  buttonWithMenu := self newButton     label: 'with menu';     contextMenu: self subMenu;     yourself.  buttonWithShortcut := self newButton     shortcut: $o meta;     label: 'with shortcut';     yourself.  buttonWithHelp := self newButton     label: 'with help';     help: 'This button showsa multiline help';     yourself.  buttonWithDifferentFont := self newButton     label: 'different font';     font: StandardFonts codeFont;     yourself.  self focusOrder     add: buttonNormal;     add: buttonDisabled;     add: buttonWithIcon;     add: buttonWithIconOnly;     add: buttonHighlighted;     add: buttonWithColor;     add: buttonWithMenu;     add: buttonWithShortcut;     add: buttonWithHelp;     add: buttonWithDifferentFonttestSettingNilClearsTheImage  self presenter image: self imageForm.  self presenter image: nil.  backendForTest assertImage: self adapter image equals: nilwhenPlaceholderChangedDo: arg1  self property: #placeholder whenChangedDo: arg1autoAccept: arg1  ^self input autoAccept: arg1save: arg1  self host tempNamed: self tempName put: arg1selectedItem  ^self selectedPaths ifEmpty: [ #() ] ifNotEmpty: [:arg1 |  presenter itemAtPath: arg1 first ]testActivateRaisesChangedEventOnce  presenter state: false.  self assertWith: [:arg1 |  arg1 = 1 ] timesRaisedEvent: #whenChangedDo: inPresenter: presenter whenDoing: [ presenter state: true ]add: arg1 withSpec: arg2 origin: arg3 corner: arg4  self add: arg1 withSpec: arg2 origin: arg3 corner: arg4 offsetOrigin: 0 @ 0 offsetCorner: 0 @ 0isEmpty  ^items isEmptyindeterminated  ^indeterminatedtestTickIncrementsStepBy  timeline stepBy: 10.  timeline tick.  self assert: timeline ticks equals: 10keystroke: arg1  arg1 event keyCharacter = Character arrowUp ifTrue: [ self increaseValueOf: arg1 morph.        ^true ].  arg1 event keyCharacter = Character arrowDown ifTrue: [ self decreaseValueOf: arg1 morph.        ^true ].  ^falseusersModel  ^usersModeldropList  ^dropListname  ^nameselectAll  self changed: #selectAll with: #()layoutChanged  updating ifTrue: [ ^self ].  updating := true.  [ super layoutChanged.  layoutChangeAction ifNotNil: [ layoutChangeAction value ] ] ensure: [ updating := false ]presenter  ^modelinspectorChoice  ^inspectorChoicedoItReceiver  | tmp1 |  tmp1 := doItReceiver.  tmp1 isBehavior ifTrue: [ tmp1 := tmp1 instanceSide ].  ^tmp1slider  ^subwidget sliderstep  self inspector stepdirection  ^directiondayBeforeMonthOf: arg1  ^arg1 month dates first dayOfWeek - 1initialize  super initialize.  self position: 1 @ 1.  self span: 1 @ 1removePage: arg1  | tmp1 |  tmp1 := self pages indexOf: arg1.  self suspendAnnouncementsDuring: [ super removePage: arg1 ].  self announcer announce: (SpNotebookPageRemoved new           tabs: self;           page: arg1;           pageIndex: tmp1;           newIndex: self tabSelectorMorph selectedIndex).  self pages ifEmpty: [ self contentMorph removeAllMorphs ]labelPresenter  ^labelPresenterwhenAutoAcceptChangedDo: arg1  self property: #autoAccept whenChangedDo: arg1testDoubleClickActivatesRowInDoubleClickActivationMode  | tmp1 |  tmp1 := false.  self presenter activateOnDoubleClick.  self presenter whenActivatedDo: [ tmp1 := true ].  backendForTest doubleClickFirstRowAndColumn: self adapter.  self assert: tmp1computeCellExtents  cellExtents := SmallDictionary new.  self allGridConstraints do: [:arg1 |  | tmp1 tmp2 |        tmp1 := (columnWidths copyFrom: arg1 column to: arg1 column + arg1 columnSpan - 1) sum.        tmp2 := (rowHeights copyFrom: arg1 row to: arg1 row + arg1 rowSpan - 1) sum.        cellExtents at: arg1 position put: tmp1 @ tmp2 ]aboutToStyle: arg1  self deprecated: 'This method is an horrible hack because the VersionBrowser was using Code or Diff presenter but was only using the API of the Code presenter... This method and other methods from the CodePresenter API will be removed.'selectedItem  self dropList selectedItemcolor: arg1  label  ^self tempNamepreTransmission: arg1  preTransmission := arg1wrapItem: arg1  ^self model wrapItem: arg1objectChanged  text doItReceiver: self object.  morphPresenter morph removeAllMorphs.  morphPresenter morph addMorph: self thumbnailMorph fullFrame: LayoutFrame identityinitializeTestedInstance  presenter     addColumn: (SpStringTableColumn title: 'Value' evaluated: #printString);     addColumn: (SpImageTableColumn title: 'Icon' evaluated: [:arg1 |  self iconNamed: #add ]);     hideColumnHeaders;     beMultipleSelection;     roots: #(1 2 3);     children: [:arg2 |  {(arg2 * 2) .         (arg2 * 3) .         (arg2 * 10)} ]instVarNamesAndPresenterNamesArray  ^(self instVarToModelObject inject: OrderedCollection new into: [:arg1 :arg2 |  arg1           add: arg2 key;           add: (self presenterBlock value: arg2 value) name;           yourself ]) asArrayrawRead: arg1  ^super read: arg1heightPositionIn: arg1  ^self position < 1 ifTrue: [ (arg1 y * self position) asInteger ] ifFalse: [ self position ]taskbarIcon  ^self inspector ifNil: [ super taskbarIcon ] ifNotNil: [:arg1 |  arg1 taskbarIcon ]removeAll  widget submorphs first removeAllMorphs.  widget submorphs second removeAllMorphsisVertical  ^self direction = SpLayoutDirection verticalactionHolder  self deprecated: 'Nobody should access directly to internals of Spec. Now the action not a value holder anymore because it was not used.'inputPortNamed: arg1  ^self inputPorts detect: [:arg2 |  arg2 name = arg1 ]container  ^container valuetestAddWithPaddingVertical  | tmp1 tmp2 tmp3 |  tmp1 := SpBoxLayoutWithTableForTestPresenter new.  tmp2 := SpLabelPresenter new.  tmp3 := SpBoxLayout newVertical     add: tmp2 expand: false fill: false padding: 10;     yourself.  tmp1 buildAdapterWithSpecLayout: tmp3.  self assert: tmp2 adapter widget extent equals: tmp2 adapter widget owner extent - (0 @ 20)findChangeSet  | tmp1 |  tmp1 := self model findChangeSetIn: self changeSets.  changesListPresenter setSelectedItem: tmp1testSubscribeToEventDoesNotRaiseEvent  presenter selection whenChangedDo: [:arg1 |  self fail ]beOverlay  ^overlay := trueaddRadioButton: arg1  buttons do: [:arg2 |  arg1 whenActivatedDo: [ arg2 privateSetState: false ].        arg2 whenActivatedDo: [ arg1 privateSetState: false ] ].  arg1 whenActivatedDo: [ self currentlyActivated: arg1 ].  buttons add: arg1.  arg1 privateSetState: falsemenusRegistrationFrom: arg1 to: arg2  arg1 changesMenu: (self changeSetMenuFrom: arg1 to: arg2).  arg1 classesMenu: (self classMenuFrom: arg1 to: arg2).  arg1 methodsMenu: (self messageMenuFrom: arg1 to: arg2)acceptText: arg1  self property: #text rawValue: arg1image  ^imagesize  ^collection sizegetIconFor: arg1  ^self iconBlock cull: arg1 model cull: arg1backgroundColor: arg1  backgroundColor := arg1contents  ^contents ifNil: [ self buildChildren.        contents ]browserPage  ^SpNotebookPage title: 'Browser' icon: (self iconNamed: #nautilusIcon) provider: [ SpClassMethodBrowser new           classes: self class environment allClasses;           yourself ]refreshWidgetList  connectPresenters  slider whenValueChangedDo: [:arg1 |  | tmp1 |        tmp1 := input text asNumber.        arg1 == tmp1 ifFalse: [ input text: arg1 asString ] ].  input whenTextChangedDo: [:arg2 |  | tmp1 |        tmp1 := arg2 asNumber.        slider value == tmp1 ifFalse: [ slider value: tmp1 ] ]testRightClickShowsMenu  | tmp1 |  presenter contextMenu: (tmp1 := SpMockMenuPresenter new).  self deny: tmp1 shown.  self emulateRightClick.  self assert: tmp1 shownunselectIndex: arg1  self selectedIndex = arg1 ifTrue: [ self basicSelectIndex: 0 ]setIndex: arg1  ^self model selectIndex: arg1locationOf: arg1  ^String streamContents: [:arg2 |  3 to: (cachedHierarchy at: arg1) size do: [:arg3 |  arg2 << '    ' ].        arg2 << (self methodClassNameForItem: arg1) << ' ('.        arg1 isFromTrait ifTrue: [ arg2                 << arg1 compiledMethod origin name;                 space ].        arg2 << (self protocolNameForItem: arg1) << ')' ]moreOptionsText: arg1  moreOptionsText := arg1notifyInfo: arg1  GrowlMorph openWithLabel: 'Information' translated contents: arg1 messagedesiredVisibleRow  ^desiredVisibleRowallPresentersInFocusOrder  | tmp1 |  tmp1 := OrderedCollection new.  self traverseInFocusOrderDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1behavior  ^self model behavioraddPresenterIn: arg1 withSpecLayout: arg2  self presenter ifNil: [ ^self ].  self initializeWindow.  self changed: #addPresenterIn:withSpecLayout: with: {arg1 .         arg2}widthOrUndefined  ^self width ifNil: [ self class undefinedColumnWidth ]whenBehaviorChanged: arg1  self deprecated: 'Use #whenBehaviorChangedDo: instead.' transformWith: '`@receiver whenBehaviorChanged: `@statements' -> '`@receiver whenBehaviorChangedDo: `@statements'.  self whenBehaviorChangedDo: arg1testAsButtonPresenter  | tmp1 |  command := CmCommand forSpec     name: 'foo';     description: 'bar';     yourself.  tmp1 := command asButtonPresenter.  self assert: tmp1 label equals: 'foo'.  self assert: tmp1 help equals: 'bar'.  self assert: tmp1 icon isNilsetCurrentChangeSet: arg1  ChangeSet newChanges: arg1initialWidth  ^initialWidth valuepopUpEvent: arg1 in: arg2  self shown: trueunselectAll  self selection unselectAllcanTakeKeyboardFocus  ^falseisDisplayed  ^self window ifNotNil: [:arg1 |  arg1 isDisplayed ] ifNil: [ false ]displayBlockChanged  self widgetDo: [:arg1 |  arg1 rowMorphGetSelector: self displayBlock.        arg1 container updateList ]dragEnabled: arg1  dragEnabled := arg1initializeWindow: arg1  super initializeWindow: arg1.  arg1     menu: (menu := self buildMenuBar);     toolBar: (toolBar := self buildToolBar);     statusBar: (statusBar := self buildStatusBar)openInstance  backendForTest openInstanceOf: selfpresenterBlock  ^presenterBlockinitialExtent  ^600 @ 400addSpacer  self add: #specSpacerbuildWidget  ^SpStubRadioButtonView newexpandAll  self treeModel expandAlllimit1  ^100sortingBlock: arg1  sorting := arg1.  self refreshListselectedIndex  ^list selection selectedIndextestClickDeactivatedCheckboxActivatesIt  presenter state: false.  self emulateLeftClick.  self assert: presenter stateremoveAll  children removeAll.  adapter ifNotNil: [:arg1 |  arg1 removeAll ]initialize: arg1  super write: SpValueHolder new to: arg1testEnabledAffectWidget  ^self skipsetConfigButton  configButton     state: false;     label: '+Config';     help: 'Add a new metacello configuration';     action: [ self createConfiguration ]methodList  ^methodListtestReset  self initMinMax.  presenter     value: 50;     reset.  self assert: presenter value == 0dateModel  ^dateModelencrypted  self deprecated: 'Use #isPassword instead' transformWith: '`@receiver encrypted' -> '`@receiver isPassword'.  ^self isPasswordspinnerForm  ^self class spinnerFormnullPresentersNeededFor: arg1  ^self columnsCount - ((arg1 modelObjects size - 1) % self columnsCount + 1)postTransmission: arg1  postTransmission := arg1setUp  super setUp.  presenter := self classToTest new.  self initializeTestedInstancewhenTabSelected: arg1  tabSelectedAction value: arg1buttonWithDifferentFont  ^buttonWithDifferentFontchildrenWidgets  ^innerWidget submorphsitems: arg1  ^self list items: arg1pushStyle: arg1 during: arg2  | tmp1 |  tmp1 := currentStyle.  currentStyle := arg1.  arg2 ensure: [ currentStyle := tmp1 ]browseSelectedObjectClass  self selectedObjectDo: [:arg1 |  Smalltalk tools browser openOnClass: arg1 class ]observablePropertyNamed: arg1  | tmp1 |  tmp1 := self class slotNamed: arg1.  tmp1 isObservableSlot ifFalse: [ SpNonObservableSlotError signal: arg1 ].  ^tmp1 rawRead: selfmessages  ^messageList messagestestColumnsAreDynamicallySetInPresenter  self presenter     displayBlock: [:arg1 |  {arg1 .         42} ];     items: {1 .         2 .         3}.  self assert: self presenter columns size equals: 2activatesOnSingleClick  ^activateOnSingleClicktestIsEmpty  self assert: presenter isEmpty.  presenter addItem: SpToolBarButton new.  self deny: presenter isEmptystyles: arg1  styles := arg1transformed: arg1  transformBlock ifNil: [ ^arg1 ].  ^transformBlock value: arg1classList  ^classListinitialize  self class initializeSlots: self.  super initializeupButton  ^upButtonfemaleButton  ^femaleButtontestTypePerformsSearch  self selectIndex: 1.  self adapter typeForSearch: '2'.  self assert: self selectedIndex equals: 2whenWillCloseDo: arg1  self announcer when: SpWindowWillClose do: arg1testUnselectAllInWidgetRaisesSelectionIndexChangeEventOnce  | tmp1 |  tmp1 := 0.  self adapter selectPath: #(1).  presenter selection whenChangedDo: [:arg1 |  tmp1 := tmp1 + 1 ].  self adapter selectPath: #().  self assert: tmp1 equals: 1testSetSelectIndexRaisesSelectionChangeEventWithSelectedItem  | tmp1 |  presenter whenSelectionChangedDo: [:arg1 |  tmp1 := arg1 selectedItems ].  presenter selectIndex: 1.  self assert: (tmp1 includes: 10)beFloat  self numberType: FloathasHeaderTitle  ^headerTitle isEmptyOrNil notsurname  ^surnametestWhenDigitsChangedDo  | tmp1 tmp2 |  tmp1 := 0.  presenter whenDigitsChangedDo: [:arg1 |  tmp1 := tmp1 + 1.        tmp2 := arg1 ].  presenter digits: 2.  self assert: tmp1 equals: 1.  self assert: tmp2 equals: 2objectInspectorPage  ^SpNotebookPage title: 'Object inspector' icon: (self iconNamed: #nautilusIcon) provider: [ self flag: #TODO.        (self class environment at: #EyeInspector) new           inspect: Object;           yourself ] layoutSpec: #inspectorSpecbuttonWithHelp: arg1  buttonWithHelp := arg1valueClass  ^self value classobservablePropertyNamed: arg1  | tmp1 |  tmp1 := self class slotNamed: arg1.  tmp1 isObservableSlot ifFalse: [ SpNonObservableSlotError signal: arg1 ].  ^tmp1 rawRead: selfmodel: arg1  model := arg1.  model whenChangedDo: [ self withAdapterDo: #refreshList ]testUnselectAllInWidgetNotRaisesEmptySelectionChangeEvent  | tmp1 |  presenter selection whenChangedDo: [:arg1 |  tmp1 := arg1 ].  self adapter selectPath: #().  self assert: tmp1 isNil