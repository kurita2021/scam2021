breadcrumbItemTriangleStyleFor: arg1  arg1     height: self breadcrumbTriangleHeight;     hSpaceFill-======-stream  ^stream-======-setAmountVisible: arg1 all: arg2  self amountBrick text: arg1 asString , '/' , arg2 asString.  self amountBrick wrappedBounds markWidthDirty.  self amountBrick doLayout.  self doLayoutForce-======-debugger  ^debugger-======-gtInspectorContentIn: arg1  < gtInspectorPresentationOrder: 0>  arg1 pharoScript     title: 'Content';     display: #content;     installDefaultSelectionActions-======-prepareProcessorInContext: arg1  super prepareProcessorInContext: arg1.  self hasDynamicItems ifTrue: [ allCandidates := nil ]-======-decreaseZindex: arg1  arg1 layoutProperties zIndex: 1-======-implementors: arg1  ^self implementors: arg1 inPackages: self defaultPackages-======-content: arg1  content := arg1 asString-======-errorMessage  ^'error obtaining value'-======-defaultOrder  ^220-======-setTitleAndEnsureInStash: arg1  self title: arg1.  self ensureStashPersistency.  self save-======-showFirst: arg1  self browser showFirst: arg1-======-methodActionsFor: arg1  ^arg1 selector isUnary ifTrue: [ Array with: self evaluationAction ] ifFalse: [ #() ]-======-debugAction: arg1  debugActionHolder value: arg1-======-initialize  super initialize.  self headerBrick: self newHeaderBrick-======-testFailingDate  | tmp1 |  tmp1 := DateAndTime     localTimeZone: TimeZone default;     dosEpoch.  self assert: (tmp1 offset: '0:12:00:00') equals: '1 January 1980 1:00 pm' asDateAndTime-======-basicFilterInContext: arg1  self prepareProcessorInContext: arg1.  (self shouldFilterInContext: arg1) ifTrue: [ allFilteredCandidates := self doFilterInContext: arg1 ].  arg1 stream performSymbol: #onAmountChanged:in: withArguments: {self allFilteredCandidates size .         self}-======-matchContext: arg1  self subclassResponsibility-======-selectedItemBrick  ^selectedItemBrick-======-notifyPaneRemoved  ^notifyPaneRemoved ifNil: [ false ]-======-previewWidthPercent  ^40-======-context: arg1  context := arg1-======-handleException: arg1  ^self handleException: arg1 do: [ ('[Spotter] Exception: ' , arg1 asString) traceCr ]-======-previousStep  < return: #GTSpotterStep>  self assert: self hasPreviousStep.  ^self spotter steps at: (self spotter steps indexOf: self) - 1-======-onChildrenLayouted  super onChildrenLayouted.  self band translateXTo: (self band data ifNil: [ 0 ]).  self scrollToTheLastOne-======-addPage: arg1  self pages addFirst: arg1-======-fileName  ^self page creationTimeForFileName , '.' , GTPlayPage fileExtension-======-size  ^size ifNil: [ size := 0 ]-======-assertDebuggerClosing  debugger close.  self assert: window model equals: nil.  self assert: debugger session interruptedContext equals: nil.  self assert: debugger session interruptedProcess equals: nil-======-pages  ^pages ifNil: [ pages := self defaultPages ]-======-onCandidateSelected: arg1  self updatePreviewWith: arg1 selected-======-detachSession  self flag: 'why silent value?'.  (self browser pane port: #entity) silentValue: nil-======-index: arg1  index := arg1-======-isInteresting  ^self contentString trimBoth isEmpty not-======-testBasic  | tmp1 tmp2 |  tmp2 := self class.  tmp1 := tmp2 definitionForSpotter.  self assert: (tmp1 beginsWith: tmp2 definition)-======-defaultKeymap  ^PharoShortcuts current cancelShortcut-======-id  ^#gtWhereIs-======-candidateLinks: arg1  candidateLinks := arg1-======-originalSession: arg1  originalSession := arg1-======-denySearch: arg1  self basicSearch: arg1.  self assert: previousContext identicalTo: currentContext.  self assert: previousContext identicalTo: spotter currentStep context.  self assert: (previousContext matches: arg1)-======-prepareFilterInContext: arg1  super prepareFilterInContext: arg1.  self regex: (caseSensitive ifTrue: [ self query asRegex ] ifFalse: [ self query asRegexIgnoringCase ])-======-allPragmasWithTag  ^PragmaCollector allSystemPragmas select: [:arg1 |  arg1 key == self tagPragmaKey ]-======-from: arg1  debugActionExecutedAnnouncement := arg1-======-setTitle: arg1  self withWindowDo: [:arg2 |  arg2 title: arg1 ]-======-borderColor  ^Smalltalk ui theme borderColor-======-notifyDiveInCategory: arg1 for: arg2  self announce: (GTSpotterDiveInCategory new           category: arg1;           eventType: arg2)-======-itemsLimit: arg1  candidatesLimit := arg1-======-candidateLinks  ^candidateLinks-======-newPreviewBrick  ^GTSpotterPreviewBrick new-======-history: arg1  history := arg1-======-key  ^self subclassResponsibility-======-order: arg1  order := arg1-======-defaultOrder  ^30-======-shouldEnableProcessorsCreateBy: arg1  ^true-======-helpButton: arg1  | tmp1 tmp2 |  helpButton ifNotNil: [ self removeBrick: helpButton ].  helpButton := arg1.  self themer spotterThemer helpButtonWidgetStyleFor: helpButton.  self themer spotterThemer helpButtonStyleFor: helpButton.  helpButton     hintTitle: 'Spotter help';     action: [ self spotterModel exitDueTo: #actionButton.        tmp1 := HelpBrowser open instVarNamed: #treeMorph.        tmp2 := tmp1 allItems detect: [:arg2 |  arg2 complexContents item key = GTSpotterHelp key ].        tmp1 selection: tmp2 ].  self addBrickBack: helpButton-======-newHelpButton  ^GLMHintableActionButtonBrick new-======-matchSubstrings  self filter: GTFilterSubstrings-======-notifyPaneRemoved: arg1  notifyPaneRemoved := arg1-======-installDebuggingActionsFor: arg1  self installActionsForRootPragmas: self debuggingActionsPragmas in: arg1-======-onSearchFinished  self spotterModel currentStep candidates isEmpty ifTrue: [ self updatePreviewWithEmpty ]-======-select  super select.  self showActionbar-======-spotterModel  ^spotterModel-======-requestNextCategoryStepWith: arg1 for: arg2  | tmp1 |  tmp1 := arg1 processor allFilteredCandidates collect: [:arg3 |  arg3 asSpotterCandidateLink renderingProcessor: arg1 ].  self requestNextStepWith: tmp1 for: arg2-======-childrenNodesFor: arg1  ^self hostObject childrenNodesFor: arg1-======-pragmas: arg1  ^self pragmas: arg1 inPackages: self defaultPackages-======-inspectInstances  self currentClassOrMetaClass ifNotNil: [:arg1 |  arg1 instanceSide inspectAllInstances ]-======-selectPreviousCategory  | tmp1 tmp2 |  self selected ifNil: [ ^self ].  tmp1 := self candidates getProcessorLinkByCandidateLink: self selected.  tmp2 := self candidates previousProcessorLinkOf: tmp1.  self select: tmp2 headLink-======-compose  self pager     minimumPageNumberForScrollbar: 2;     show: [:arg1 :arg2 |  arg1 dynamic display: [:arg3 |  (GLMCompositePresentation new with: [:arg4 |  arg2 gtDebuggerPresentationsIn: arg4 inContext: self.                    self attachExtraBehaviourToPresentationsIn: arg4.                    arg4 ]) startOn: arg3 ] ].  self first when: GLMPaneAdded send: #actOnPaneAdded: to: self.  self first when: GLMPaneRemoved send: #actOnPaneRemoved: to: self-======-onStepPopped  self pop-======-matcher  ^matcher-======-printArray: arg1  | tmp1 tmp2 |  tmp2 := 50000.  tmp1 := String streamContents: [:arg2 |  arg1 gtInspectorFastPrintOn: arg2 ] limitedTo: tmp2.  tmp1 size < tmp2 ifTrue: [ ^tmp1 ].  ^tmp1 , '...etc...'-======-testTestInfinitDebugger  < expectedFailure>  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := [ TestClassForTestingDebuggerTest debug: #bla ] forkAt: 41.  1000 milliSecond asDelay wait.  self currentWorld doOneCycle.  tmp1 := (self currentWorld allMorphs select: [:arg1 |  (arg1 isKindOf: SystemWindow) and: [ arg1 label beginsWith: 'Instance of ' ] ]) first.  tmp2 := (tmp1 allMorphs select: [:arg1 |  (arg1 isKindOf: PluggableButtonMorph) and: [ arg1 label = 'Debug' ] ]) first.  tmp2 performAction.  tmp1 := nil.  tmp2 := nil.  100 milliSecond asDelay wait.  self currentWorld doOneCycle.  tmp3 := (self currentWorld allMorphs select: [:arg1 |  (arg1 isKindOf: SystemWindow) and: [ arg1 label beginsWith: 'Instance of Test' ] ]) first.  tmp4 := (tmp3 allMorphs select: [:arg1 |  (arg1 isKindOf: GLMPluggableButtonMorph) and: [ arg1 label = 'Over' ] ]) first.  tmp4 performAction.  100 milliSecond asDelay wait.  self currentWorld doOneCycle.  tmp5 terminate.  tmp3 close-======-newCompositeBrick  ^GLMCompositeBrick new-======-itemsLimit  ^candidatesLimit ifNil: [ self defaultItemsLimit ]-======-printStackMethodColumnForContext: arg1  | tmp1 tmp2 |  tmp1 := arg1 outerMostContext.  ^String streamContents: [:arg2 |  tmp2 := tmp1 selector ifNil: [ tmp1 method defaultSelector ].        arg2 nextPutAll: tmp2 ]-======-theme  ^Smalltalk ui theme-======-rawValue: arg1  value := arg1-======-filteredItems: arg1  filteredItems := arg1-======-basicContinueFilterInContext: arg1  (self shouldFilterInContext: arg1) ifTrue: [ self doContinueFilterInContext: arg1 ].  arg1 stream performSymbol: #onAmountChanged:in: withArguments: {self allFilteredCandidates size .         self}-======-dropDownBrick: arg1  dropDownBrick ifNotNil: [ self removeBrick: dropDownBrick ].  dropDownBrick := arg1 asBrick.  dropDownBrick morph pagerModel: self spotterModel pagerModel.  self themer spotterThemer dropDownPaneStyleFor: dropDownBrick.  self addBrickBack: dropDownBrick-======-debuggerTransmissionsIn: arg1  arg1 transmit     fromOutsideEntityPort;     to: #stack;     andShow: [:arg2 |  self stackIn: arg2 ].  arg1 transmit     from: #stack port: #entity;     to: #stack port: #selection;     when: [:arg3 |  arg3 notNil ];     transformed: [:arg3 |  self contextToSelectFrom: arg3 ].  arg1 transmit     from: #stack port: #selection;     to: #stack port: #action;     transformed: [:arg4 |  self selectionChanged: arg4 ].  self transmitFromStackToCodeIn: arg1.  arg1 transmit     from: #stack port: #selection;     to: #inspector;     andShow: [:arg2 |  self inspectorIn: arg2 ]-======-defaultOrder  ^10-======-snippetAt: arg1 put: arg2  ^self snippets at: arg1 put: arg2-======-assertionContext  ^assertionContext-======-applyFilterWithQuery  super applyFilterWithQuery.  self filteredItems: (self filteredItems reject: [:arg1 |  arg1 isFromTrait ])-======-renderLeftTriangle: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := arg1 brickBounds width.  tmp5 := arg1 brickBounds height.  tmp1 := arg1 brickBounds topRight + (0 @ (tmp5 / 2 - tmp4 max: 0)).  tmp2 := arg1 brickBounds topRight + (0 @ (tmp5 / 2 + tmp4 min: tmp5)).  tmp3 := arg1 brickBounds topLeft + (0 @ (tmp5 / 2)).  self renderTriangle: arg1 on: arg2 with: {tmp1 asIntegerPoint .         tmp2 asIntegerPoint .         tmp3 asIntegerPoint}-======-isPartiallyVisibleAbove: arg1  ^(self isFullyVisible: arg1) not & (self isAbove: arg1)-======-defaultPagerModel  ^GLMPagerModel new-======-spotterPreviewCodeIn: arg1  < spotterPreview: 10>  arg1 pharoMethod     title: 'Preview';     display: #content;     smalltalkClass: [ nil ];     entity: self.  self flag: 'move "entity: self" somewhere else, maybe'-======-browseClassVarRefs  | tmp1 |  tmp1 := self currentClass.  (tmp1 notNil and: [ tmp1 isTrait not ]) ifTrue: [ self systemNavigation browseClassVarRefs: tmp1 ]-======-close  self withWindowDo: #close-======-query  ^query-======-filter: arg1 item: arg2  self filter: arg1.  self items: arg2 gtIterator-======-rawValue  ^self hostObject tempNamed: tempName-======-errorMessage  ^self hostObject errorMessage-======-variableNodesFor: arg1  | tmp1 |  tmp1 := OrderedCollection new: arg1 class allSlots size.  tmp1 add: (GTInspectorSelfNode hostObject: arg1).  self basicVariableNodesFor: arg1 in: tmp1.  ^tmp1-======-configurationBlockForProcessorsCreatedBy: arg1  ^configurationBlocks at: arg1 printString ifAbsent: [ self nullConfigurationBlock ]-======-buildVariablesFromContext: arg1  ^arg1 gtBytecodeDebuggerRetrieveContextValues-======-nullConfigurationBlock  ^[:arg1 |   ]-======-select: arg1 as: arg2  | tmp1 |  tmp1 := self newAs: arg2.  self do: [:arg3 |  (arg1 value: arg3) ifTrue: [ tmp1 add: arg3 ] ].  ^tmp1-======-initialize  super initialize.  self needsUpdate: false.  self needsValidation: false-======-debuggerToTest  ^GTBytecodeDebugger-======-shouldRefresh  | tmp1 tmp2 |  tmp1 := self generateCacheFor: self entity.  tmp2 := cachedHashes ~= tmp1.  cachedHashes := tmp1.  ^tmp2-======-defaultLabel  ^'Browse'-======-spotterForPackagesFor: arg1  < spotterOrder: 20>  arg1 listProcessor     allCandidates: [ RPackageOrganizer default packages ];     title: 'Packages';     itemName: [:arg2 |  arg2 name ];     itemIcon: [ Smalltalk ui icons iconNamed: #packageIcon ];     filter: self defaultFilterClass;     wantsToDisplayOnEmptyQuery: false-======-hintRevealStyleFor: arg1  arg1 ifNil: [ ^self ].  (arg1 valueOfProperty: #brickSpotterIsReveal ifAbsent: [ false ]) ifTrue: [ ^self ].  arg1 setProperty: #brickSpotterBackupColor toValue: arg1 color.  arg1 setProperty: #brickSpotterBackupBorder toValue: arg1 border.  arg1 setProperty: #brickSpotterIsReveal toValue: true.  arg1 color: self themer popupHelpThemer backgroundColor.  arg1 border: GLMBrickBorder new.  arg1 borderColor: (self themer popupHelpThemer borderColor alpha: 0.6).  arg1 borderWidth: self themer popupHelpThemer borderWidth.  arg1 changed-======-bytecodeIn: arg1 forContext: arg2  (self methodBytecodeWidgetIn: arg1 forContext: arg2)     initialize: [:arg3 |  arg3 selection: (self session symbolicBytecodeForCurrentPCFrom: self currentContext) ];     with: [:arg4 |  self installActionsForRootPragmas: self bytecodeActionsPragmas in: arg4 ]-======-asTruncatedTextFrom: arg1  ^self class asTruncatedTextFrom: arg1-======-methodCodeIn: arg1 forContext: arg2  (self methodCodeWidgetIn: arg1 forContext: arg2)     initialize: [:arg3 |  arg3 selectionInterval: (self session selectedCodeRangeForContext: self currentContext) ];     with: [:arg3 |  self installCodeActionsFor: arg3 ]-======-withItemsLimit: arg1 do: arg2  | tmp1 |  tmp1 := candidatesLimit.  ^[ candidatesLimit := arg1.  arg2 value ] ensure: [ candidatesLimit := tmp1 ]-======-searchFieldTextColor  ^Color white slightlyDarker-======-testMock  self assert: spotter class equals: GTMockSpotter.  self assert: spotter newStep class equals: GTMockSpotterStep.  self assert: spotter newStep asyncTask class equals: GTMockSpotterTask-======-onThemerChanged  super onThemerChanged.  self themer spotterThemer itemActionbarStyleFor: self.  self subbricks do: [:arg1 |  self themer spotterThemer itemActionButtonWidgetStyleFor: arg1 ]-======-label  ^'[' , self key , ']'-======-privateAddIntoWorld: arg1  super privateAddIntoWorld: arg1.  self setAmountVisible: self subbricksCount all: '...'-======-subclassesOf: arg1 inPackage: arg2  ^(RPackageOrganizer default packages detect: [:arg3 |  arg3 packageName = arg2 ] ifNone: [ ^#() ]) classes intersection: arg1 withAllSubclasses-======-interruptedProcess  ^self session interruptedProcess-======-reset  items := nil-======-initialize  super initialize.  self band: self newBand-======-size  ^self items size-======-processors  ^categories ifNil: [ categories := DoubleLinkedList new ]-======-bytecodeActionsPragmas  ^#(bytecodeCodeDebuggingAction)-======-spotterForFilesFor: arg1  < spotterOrder: 40>  self flag: #specialFilter.  arg1 listProcessor     title: 'Files';     itemIcon: [ GLMUIThemeExtraIcons glamorousBrowse ];     itemFilterName: [:arg2 |  arg2 basename ];     filter: GTFilterFileReference item: [:arg3 :arg4 |  self fileReferencesBy: #files inContext: arg4 usingFilter: arg3 ];     wantsToDisplayOnEmptyQuery: false-======-band  ^band-======-printStackClassColumnForContext: arg1  | tmp1 tmp2 tmp3 |  tmp1 := arg1 outerMostContext.  ^String streamContents: [:arg2 |  tmp2 := tmp1 receiver class.        arg2 nextPutAll: tmp2 name.        tmp3 := tmp1 methodClass.        tmp3 == tmp2 ifFalse: [ arg2                 nextPut: $(;                 nextPutAll: tmp3 name;                 nextPut: $) ] ]-======-fileDirectory  ^GTPlayBook stashDirectory-======-nextProcessorLinkOf: arg1  | tmp1 |  arg1 ifNil: [ ^arg1 ].  tmp1 := arg1 nextLink.  tmp1 ifNil: [ tmp1 := self processors head ].  [ tmp1 = arg1 ] whileFalse: [ tmp1 isEmpty ifFalse: [ ^tmp1 ].        tmp1 := tmp1 nextLink.        tmp1 ifNil: [ tmp1 := self processors head ] ].  ^arg1-======-itemNameFor: arg1  ^itemNameBlock ifNil: [ super itemNameFor: arg1 ] ifNotNil: [ itemNameBlock cull: arg1 ]-======-defaultTag: arg1  defaultTag := arg1-======-terminateProcessors  self steps do: [:arg1 |  arg1 terminateProcessors ]-======-creationTime: arg1  creationTime := arg1-======-scrollToTheLastOne  | tmp1 tmp2 tmp3 |  self items isEmpty ifTrue: [ ^self ].  tmp2 := self globalBounds right - self band globalBounds right.  tmp1 := self globalBounds left - self band globalBounds left.  (tmp1 = 0 and: [ self items size <= self maxNumberOfSteps ]) ifTrue: [ ^self ].  tmp3 := self items size <= self maxNumberOfSteps ifTrue: [ tmp1 ] ifFalse: [ tmp2 ].  tmp3 := self band brickBounds left + tmp3 - self band data.  self glmAnimateBrickBounds: tmp3 duration: 400 callback: nil-======-evaluatorIn: arg1  ^arg1 pharoScript     doItReceiver: [:arg2 |  arg2 ];     smalltalkClass: [:arg2 |  arg2 class ];     display: [:arg2 |  String streamContents: [:arg3 |  arg3                 nextPutAll: (self printStringOf: arg2);                 cr;                 nextPutAll: (GTSnippets snippetAt: arg2 class) ] ];     onChangeOfPort: #text act: [:arg4 :arg2 |  GTSnippets snippetAt: arg2 class put: (self stringWithoutInitialCommentFrom: arg4 text asString).        arg4 clearUserEdits ];     installDefaultSelectionActions-======-bytecodePresentation  ^self bytecodePane presentations first-======-innerBorderWidth  ^1-======-exceptionHandler  self flag: 'Bloc -> overrides doesNotUnderstand discarding the current exception context'.  ^GTCurrentSpotterExceptionHandler value ifNil: [ self step exceptionHandler ]-======-applyFilterWithQuery  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp3 := OrderedCollection new.  tmp4 := OrderedCollection new.  tmp1 := OrderedCollection streamContents: [:arg1 |  tmp6 := lowerThreshold * query size.        self allItemsDo: [:arg2 |  | tmp7 |              (tmp7 := (self itemFilterNameFor: arg2) alike: query) > tmp6 ifTrue: [ arg1 nextPut: (Array with: tmp7 with: arg2) ] ] ].  tmp2 := tmp1 asSortedCollection: [:arg3 :arg4 |  arg3 first > arg4 first ].  tmp5 := tmp1 isEmpty ifTrue: [ upperThreshold ] ifFalse: [ (tmp2 collect: [:arg2 |  arg2 first ]) median ].  tmp2 do: [:arg2 |  arg2 first >= tmp5 ifTrue: [ tmp3 add: arg2 last.              tmp3 size > self itemsLimit ifFalse: [ self addItem: arg2 ] ] ifFalse: [ tmp4 add: arg2 last ] ].  tmp3 size < self itemsLimit ifTrue: [ (tmp4 first: (self itemsLimit - tmp3 size min: tmp4 size)) do: [:arg2 |  self addItem: arg2 ] ].  self filteredItems: tmp3 , tmp4-======-hasQuery  ^self query isEmptyOrNil not-======-newTriangleBrick  ^GLMHintableActionButtonBrick new-======-streamed: arg1  streamed := arg1-======-rawValue  ^self subclassResponsibility-======-variableTag  ^'temp'-======-applyFilter  ^self filteredItems-======-itemHoveredBackgroundColor  ^self itemSelectedBackgroundColor alpha: 0.35-======-initialize  super initialize.  self needsUpdate: false-======-hintHideStyleFor: arg1  arg1 ifNil: [ ^self ].  (arg1 valueOfProperty: #brickSpotterIsReveal ifAbsent: [ false ]) ifFalse: [ ^self ].  arg1 setProperty: #brickSpotterIsReveal toValue: false.  (arg1 hasProperty: #brickSpotterBackupColor) ifTrue: [ arg1 color: (arg1 valueOfProperty: #brickSpotterBackupColor) ].  (arg1 hasProperty: #brickSpotterBackupBorder) ifTrue: [ arg1 border: (arg1 valueOfProperty: #brickSpotterBackupBorder) ].  arg1 changed-======-applyFilterInContext: arg1 error: arg2  super applyFilterInContext: arg1 error: arg2.  ^(GTFilterSubstrings new     caseSensitive: self caseSensitive;     yourself) value: arg1-======-getText  ^self text-======-initialize  super initialize.  processorsFilter := GTSpotterSettingsProcessorFilter new-======-testDeploymentExceptionHandlerMock2  self assertResetExceptions.  self shouldntRaise: MessageNotUnderstood process: 'abc' origin: GTSpotterExceptionMock2 new.  self assertException: MessageNotUnderstood.  self assertResetExceptions.  self shouldntRaise: Error process: 'abc' origin: GTSpotterExceptionMock2 new.  self assertException: MessageNotUnderstood-======-exceptionHandler  ^exceptionHandler ifNil: [ exceptionHandler := self defaultExceptionHandler ]-======-defaultLabel  ^'Profile it'-======-addItems: arg1  self context streamed addAll: arg1.  self context addItems: arg1-======-addItem: arg1  self stream addObject: arg1 inProcessor: self processor-======-spotterUsersFor: arg1  < spotterOrder: 50>  ^arg1 listProcessor     title: 'Users';     filter: GTFilterSubstring item: [:arg2 :arg3 |  self users do: [:arg4 |  arg2 value: arg4 ] ]-======-debugger  ^debugger-======-currentStep: arg1  currentStep := arg1.  self notifyCurrentStepChanged-======-formatStackExtraColumnForContext: arg1  ^Text string: (self printStackExtraColumnForContext: arg1) attributes: (self textAttributesForStackEntry: arg1)-======-history  ^history ifNil: [ self class history ]-======-testAddThreeCandidateA1A2A3Shuffled  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 |  tmp10 := candidates addProcessor: GTSpotterA1.  tmp11 := candidates addProcessor: GTSpotterA2.  tmp12 := candidates addProcessor: GTSpotterA3.  tmp4 := candidates addCandidate: 21 in: GTSpotterA2.  tmp5 := candidates addCandidate: 22 in: GTSpotterA2.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp7 := candidates addCandidate: 31 in: GTSpotterA3.  tmp2 := candidates addCandidate: 12 in: GTSpotterA1.  tmp8 := candidates addCandidate: 32 in: GTSpotterA3.  tmp6 := candidates addCandidate: 23 in: GTSpotterA2.  tmp9 := candidates addCandidate: 33 in: GTSpotterA3.  tmp3 := candidates addCandidate: 13 in: GTSpotterA1.  self assert: tmp1 nextLink equals: tmp2.  self assert: tmp1 previousLink equals: tmp9.  self assert: tmp2 nextLink equals: tmp3.  self assert: tmp2 previousLink equals: tmp1.  self assert: tmp3 nextLink equals: tmp4.  self assert: tmp3 previousLink equals: tmp2.  self assert: tmp4 nextLink equals: tmp5.  self assert: tmp4 previousLink equals: tmp3.  self assert: tmp5 nextLink equals: tmp6.  self assert: tmp5 previousLink equals: tmp4.  self assert: tmp6 nextLink equals: tmp7.  self assert: tmp6 previousLink equals: tmp5.  self assert: tmp7 nextLink equals: tmp8.  self assert: tmp7 previousLink equals: tmp6.  self assert: tmp8 nextLink equals: tmp9.  self assert: tmp8 previousLink equals: tmp7.  self assert: tmp9 nextLink equals: tmp1.  self assert: tmp9 previousLink equals: tmp8.  self assert: candidates head equals: tmp1.  self assert: candidates tail equals: tmp9.  self assert: tmp10 headLink equals: tmp1.  self assert: tmp10 tailLink equals: tmp3.  self assert: tmp11 headLink equals: tmp4.  self assert: tmp11 tailLink equals: tmp6.  self assert: tmp12 headLink equals: tmp7.  self assert: tmp12 tailLink equals: tmp9-======-onAddedSelector: arg1  onAddedSelector := arg1-======-itemIconMaxWidth  ^50-======-forDebugger: arg1  debugger := arg1.  newContext := arg1 currentContext-======-stepModel  ^stepModel-======-testArrayPairsOverLimit  | tmp1 tmp2 |  tmp1 := 2 * GTInspector indexableDisplayLimit + 1.  tmp2 := (1 to: tmp1) asArray gtInspectorVariableValuePairs.  self assert: tmp2 size equals: 2 * GTInspector indexableDisplayLimit.  (tmp2 collect: #key) allSatisfy: [:arg1 |  (tmp2 at: arg1) = arg1 ].  self assert: (tmp2 collect: #key) equals: ((1 to: GTInspector indexableDisplayLimit) asOrderedCollection           addAll: (tmp1 - GTInspector indexableDisplayLimit + 1 to: tmp1) asOrderedCollection;           yourself)-======-handlesMouseDown: arg1  ^true-======-diveInCategory  ^self diveInCategoryDueTo: #unknown-======-borderColor: arg1  borderColor := arg1-======-printSignature: arg1  ^arg1 first name , '>>' , arg1 second asString-======-after: arg1 do: arg2 ifTrue: arg3  | tmp1 |  tmp1 := arg3 brickValue: self.  arg1 brickValue: self.  tmp1 ifTrue: [ arg2 brickValue: tmp1 ]-======-itemNormalStyleFor: arg1  arg1     height: [ self itemHeight ];     hSpaceFill-======-title  ^title ifNil: [ 'Page' ]-======-objects  ^objects-======-stepModel: arg1  stepModel := arg1.  self stepModel spotter announcer when: GTSpotterRevealHints send: #onRevealHints to: self.  self stepModel spotter announcer when: GTSpotterHideHints send: #onHideHints to: self.  self     addActActionButton;     addDiveInActionButton-======-defaultStreamed  ^true-======-buildCategoryBrick: arg1  < return: #GTSpotterCategoryBrick>  | tmp1 tmp2 |  tmp1 := self newTitleBrick on: self stepModel category: arg1.  self themer spotterThemer categoryTitleStyleFor: tmp1.  tmp2 := self newCategoryBrick on: self stepModel category: arg1.  self themer spotterThemer categoryStyleFor: tmp2.  tmp2 titleBrick: tmp1.  ^tmp2-======-