breadcrumbItemTriangleStyleFor: aBrick  aBrick     height: self breadcrumbTriangleHeight;     hSpaceFill-======-stream  ^stream-======-setAmountVisible: visible all: all  self amountBrick text: visible asString , '/' , all asString.  self amountBrick wrappedBounds markWidthDirty.  self amountBrick doLayout.  self doLayoutForce-======-debugger  ^debugger-======-gtInspectorContentIn: composite  < gtInspectorPresentationOrder: 0>  composite pharoScript     title: 'Content';     display: #content;     installDefaultSelectionActions-======-prepareProcessorInContext: aContext  super prepareProcessorInContext: aContext.  self hasDynamicItems ifTrue: [ allCandidates := nil ]-======-decreaseZindex: aBrick  aBrick layoutProperties zIndex: 1-======-implementors: aSelector  ^self implementors: aSelector inPackages: self defaultPackages-======-content: aString  content := aString asString-======-errorMessage  ^'error obtaining value'-======-defaultOrder  ^220-======-setTitleAndEnsureInStash: aString  self title: aString.  self ensureStashPersistency.  self save-======-showFirst: aBlock  self browser showFirst: aBlock-======-methodActionsFor: aMethod  ^aMethod selector isUnary ifTrue: [ Array with: self evaluationAction ] ifFalse: [ #() ]-======-debugAction: aDebugAction  debugActionHolder value: aDebugAction-======-initialize  super initialize.  self headerBrick: self newHeaderBrick-======-testFailingDate  | aDateAndTime |  aDateAndTime := DateAndTime     localTimeZone: TimeZone default;     dosEpoch.  self assert: (aDateAndTime offset: '0:12:00:00') equals: '1 January 1980 1:00 pm' asDateAndTime-======-basicFilterInContext: aSpotterContext  self prepareProcessorInContext: aSpotterContext.  (self shouldFilterInContext: aSpotterContext) ifTrue: [ allFilteredCandidates := self doFilterInContext: aSpotterContext ].  aSpotterContext stream performSymbol: #onAmountChanged:in: withArguments: {self allFilteredCandidates size .         self}-======-matchContext: aContext  self subclassResponsibility-======-selectedItemBrick  ^selectedItemBrick-======-notifyPaneRemoved  ^notifyPaneRemoved ifNil: [ false ]-======-previewWidthPercent  ^40-======-context: anObject  context := anObject-======-handleException: anException  ^self handleException: anException do: [ ('[Spotter] Exception: ' , anException asString) traceCr ]-======-previousStep  < return: #GTSpotterStep>  self assert: self hasPreviousStep.  ^self spotter steps at: (self spotter steps indexOf: self) - 1-======-onChildrenLayouted  super onChildrenLayouted.  self band translateXTo: (self band data ifNil: [ 0 ]).  self scrollToTheLastOne-======-addPage: aPage  self pages addFirst: aPage-======-fileName  ^self page creationTimeForFileName , '.' , GTPlayPage fileExtension-======-size  ^size ifNil: [ size := 0 ]-======-assertDebuggerClosing  debugger close.  self assert: window model equals: nil.  self assert: debugger session interruptedContext equals: nil.  self assert: debugger session interruptedProcess equals: nil-======-pages  ^pages ifNil: [ pages := self defaultPages ]-======-onCandidateSelected: ann  self updatePreviewWith: ann selected-======-detachSession  self flag: 'why silent value?'.  (self browser pane port: #entity) silentValue: nil-======-index: anInteger  index := anInteger-======-isInteresting  ^self contentString trimBoth isEmpty not-======-testBasic  | def cls |  cls := self class.  def := cls definitionForSpotter.  self assert: (def beginsWith: cls definition)-======-defaultKeymap  ^PharoShortcuts current cancelShortcut-======-id  ^#gtWhereIs-======-candidateLinks: anObject  candidateLinks := anObject-======-originalSession: aDebugSession  originalSession := aDebugSession-======-denySearch: aString  self basicSearch: aString.  self assert: previousContext identicalTo: currentContext.  self assert: previousContext identicalTo: spotter currentStep context.  self assert: (previousContext matches: aString)-======-prepareFilterInContext: aSpotterContext  super prepareFilterInContext: aSpotterContext.  self regex: (caseSensitive ifTrue: [ self query asRegex ] ifFalse: [ self query asRegexIgnoringCase ])-======-allPragmasWithTag  ^PragmaCollector allSystemPragmas select: [:pragma |  pragma key == self tagPragmaKey ]-======-from: anAnnouncement  debugActionExecutedAnnouncement := anAnnouncement-======-setTitle: aString  self withWindowDo: [:w |  w title: aString ]-======-borderColor  ^Smalltalk ui theme borderColor-======-notifyDiveInCategory: aProcessor for: anEventType  self announce: (GTSpotterDiveInCategory new           category: aProcessor;           eventType: anEventType)-======-itemsLimit: anInteger  candidatesLimit := anInteger-======-candidateLinks  ^candidateLinks-======-newPreviewBrick  ^GTSpotterPreviewBrick new-======-history: aWeakCollection  history := aWeakCollection-======-key  ^self subclassResponsibility-======-order: aNumber  order := aNumber-======-defaultOrder  ^30-======-shouldEnableProcessorsCreateBy: aMethod  ^true-======-helpButton: aBrick  | tree item |  helpButton ifNotNil: [ self removeBrick: helpButton ].  helpButton := aBrick.  self themer spotterThemer helpButtonWidgetStyleFor: helpButton.  self themer spotterThemer helpButtonStyleFor: helpButton.  helpButton     hintTitle: 'Spotter help';     action: [ self spotterModel exitDueTo: #actionButton.        tree := HelpBrowser open instVarNamed: #treeMorph.        item := tree allItems detect: [:each |  each complexContents item key = GTSpotterHelp key ].        tree selection: item ].  self addBrickBack: helpButton-======-newHelpButton  ^GLMHintableActionButtonBrick new-======-matchSubstrings  self filter: GTFilterSubstrings-======-notifyPaneRemoved: anObject  notifyPaneRemoved := anObject-======-installDebuggingActionsFor: aPresentation  self installActionsForRootPragmas: self debuggingActionsPragmas in: aPresentation-======-onSearchFinished  self spotterModel currentStep candidates isEmpty ifTrue: [ self updatePreviewWithEmpty ]-======-select  super select.  self showActionbar-======-spotterModel  ^spotterModel-======-requestNextCategoryStepWith: aProcessorLink for: anEventType  | collection |  collection := aProcessorLink processor allFilteredCandidates collect: [:each |  each asSpotterCandidateLink renderingProcessor: aProcessorLink ].  self requestNextStepWith: collection for: anEventType-======-childrenNodesFor: aVariablesBrowser  ^self hostObject childrenNodesFor: aVariablesBrowser-======-pragmas: aSelector  ^self pragmas: aSelector inPackages: self defaultPackages-======-inspectInstances  self currentClassOrMetaClass ifNotNil: [:aClass |  aClass instanceSide inspectAllInstances ]-======-selectPreviousCategory  | currentCategory previousCategory |  self selected ifNil: [ ^self ].  currentCategory := self candidates getProcessorLinkByCandidateLink: self selected.  previousCategory := self candidates previousProcessorLinkOf: currentCategory.  self select: previousCategory headLink-======-compose  self pager     minimumPageNumberForScrollbar: 2;     show: [:a :each |  a dynamic display: [:x |  (GLMCompositePresentation new with: [:aComposite |  each gtDebuggerPresentationsIn: aComposite inContext: self.                    self attachExtraBehaviourToPresentationsIn: aComposite.                    aComposite ]) startOn: x ] ].  self first when: GLMPaneAdded send: #actOnPaneAdded: to: self.  self first when: GLMPaneRemoved send: #actOnPaneRemoved: to: self-======-onStepPopped  self pop-======-matcher  ^matcher-======-printArray: anArray  | limitedString limit |  limit := 50000.  limitedString := String streamContents: [:aStream |  anArray gtInspectorFastPrintOn: aStream ] limitedTo: limit.  limitedString size < limit ifTrue: [ ^limitedString ].  ^limitedString , '...etc...'-======-testTestInfinitDebugger  < expectedFailure>  | preWindow debugButton debugWindow overButton process |  process := [ TestClassForTestingDebuggerTest debug: #bla ] forkAt: 41.  1000 milliSecond asDelay wait.  self currentWorld doOneCycle.  preWindow := (self currentWorld allMorphs select: [:e |  (e isKindOf: SystemWindow) and: [ e label beginsWith: 'Instance of ' ] ]) first.  debugButton := (preWindow allMorphs select: [:e |  (e isKindOf: PluggableButtonMorph) and: [ e label = 'Debug' ] ]) first.  debugButton performAction.  preWindow := nil.  debugButton := nil.  100 milliSecond asDelay wait.  self currentWorld doOneCycle.  debugWindow := (self currentWorld allMorphs select: [:e |  (e isKindOf: SystemWindow) and: [ e label beginsWith: 'Instance of Test' ] ]) first.  overButton := (debugWindow allMorphs select: [:e |  (e isKindOf: GLMPluggableButtonMorph) and: [ e label = 'Over' ] ]) first.  overButton performAction.  100 milliSecond asDelay wait.  self currentWorld doOneCycle.  process terminate.  debugWindow close-======-newCompositeBrick  ^GLMCompositeBrick new-======-itemsLimit  ^candidatesLimit ifNil: [ self defaultItemsLimit ]-======-printStackMethodColumnForContext: aContext  | outer selector |  outer := aContext outerMostContext.  ^String streamContents: [:aStream |  selector := outer selector ifNil: [ outer method defaultSelector ].        aStream nextPutAll: selector ]-======-theme  ^Smalltalk ui theme-======-rawValue: anObject  value := anObject-======-filteredItems: aCollection  filteredItems := aCollection-======-basicContinueFilterInContext: aSpotterContext  (self shouldFilterInContext: aSpotterContext) ifTrue: [ self doContinueFilterInContext: aSpotterContext ].  aSpotterContext stream performSymbol: #onAmountChanged:in: withArguments: {self allFilteredCandidates size .         self}-======-dropDownBrick: aBrick  dropDownBrick ifNotNil: [ self removeBrick: dropDownBrick ].  dropDownBrick := aBrick asBrick.  dropDownBrick morph pagerModel: self spotterModel pagerModel.  self themer spotterThemer dropDownPaneStyleFor: dropDownBrick.  self addBrickBack: dropDownBrick-======-debuggerTransmissionsIn: browser  browser transmit     fromOutsideEntityPort;     to: #stack;     andShow: [:composite |  self stackIn: composite ].  browser transmit     from: #stack port: #entity;     to: #stack port: #selection;     when: [:session |  session notNil ];     transformed: [:session |  self contextToSelectFrom: session ].  browser transmit     from: #stack port: #selection;     to: #stack port: #action;     transformed: [:context |  self selectionChanged: context ].  self transmitFromStackToCodeIn: browser.  browser transmit     from: #stack port: #selection;     to: #inspector;     andShow: [:composite |  self inspectorIn: composite ]-======-defaultOrder  ^10-======-snippetAt: anObject put: aString  ^self snippets at: anObject put: aString-======-assertionContext  ^assertionContext-======-applyFilterWithQuery  super applyFilterWithQuery.  self filteredItems: (self filteredItems reject: [:each |  each isFromTrait ])-======-renderLeftTriangle: aBrick on: aCanvas  | a b c width height |  width := aBrick brickBounds width.  height := aBrick brickBounds height.  a := aBrick brickBounds topRight + (0 @ (height / 2 - width max: 0)).  b := aBrick brickBounds topRight + (0 @ (height / 2 + width min: height)).  c := aBrick brickBounds topLeft + (0 @ (height / 2)).  self renderTriangle: aBrick on: aCanvas with: {a asIntegerPoint .         b asIntegerPoint .         c asIntegerPoint}-======-isPartiallyVisibleAbove: aBrick  ^(self isFullyVisible: aBrick) not & (self isAbove: aBrick)-======-defaultPagerModel  ^GLMPagerModel new-======-spotterPreviewCodeIn: aComposite  < spotterPreview: 10>  aComposite pharoMethod     title: 'Preview';     display: #content;     smalltalkClass: [ nil ];     entity: self.  self flag: 'move "entity: self" somewhere else, maybe'-======-browseClassVarRefs  | cls |  cls := self currentClass.  (cls notNil and: [ cls isTrait not ]) ifTrue: [ self systemNavigation browseClassVarRefs: cls ]-======-close  self withWindowDo: #close-======-query  ^query-======-filter: aGTFilter item: aGTSpotterIterator  self filter: aGTFilter.  self items: aGTSpotterIterator gtIterator-======-rawValue  ^self hostObject tempNamed: tempName-======-errorMessage  ^self hostObject errorMessage-======-variableNodesFor: anObject  | variableNodes |  variableNodes := OrderedCollection new: anObject class allSlots size.  variableNodes add: (GTInspectorSelfNode hostObject: anObject).  self basicVariableNodesFor: anObject in: variableNodes.  ^variableNodes-======-configurationBlockForProcessorsCreatedBy: aMethod  ^configurationBlocks at: aMethod printString ifAbsent: [ self nullConfigurationBlock ]-======-buildVariablesFromContext: aContext  ^aContext gtBytecodeDebuggerRetrieveContextValues-======-nullConfigurationBlock  ^[:processor |   ]-======-select: aBlock as: aCollectionClass  | collection |  collection := self newAs: aCollectionClass.  self do: [:each |  (aBlock value: each) ifTrue: [ collection add: each ] ].  ^collection-======-initialize  super initialize.  self needsUpdate: false.  self needsValidation: false-======-debuggerToTest  ^GTBytecodeDebugger-======-shouldRefresh  | newCache result |  newCache := self generateCacheFor: self entity.  result := cachedHashes ~= newCache.  cachedHashes := newCache.  ^result-======-defaultLabel  ^'Browse'-======-spotterForPackagesFor: aStep  < spotterOrder: 20>  aStep listProcessor     allCandidates: [ RPackageOrganizer default packages ];     title: 'Packages';     itemName: [:package |  package name ];     itemIcon: [ Smalltalk ui icons iconNamed: #packageIcon ];     filter: self defaultFilterClass;     wantsToDisplayOnEmptyQuery: false-======-hintRevealStyleFor: aBrick  aBrick ifNil: [ ^self ].  (aBrick valueOfProperty: #brickSpotterIsReveal ifAbsent: [ false ]) ifTrue: [ ^self ].  aBrick setProperty: #brickSpotterBackupColor toValue: aBrick color.  aBrick setProperty: #brickSpotterBackupBorder toValue: aBrick border.  aBrick setProperty: #brickSpotterIsReveal toValue: true.  aBrick color: self themer popupHelpThemer backgroundColor.  aBrick border: GLMBrickBorder new.  aBrick borderColor: (self themer popupHelpThemer borderColor alpha: 0.6).  aBrick borderWidth: self themer popupHelpThemer borderWidth.  aBrick changed-======-bytecodeIn: aComposite forContext: aContext  (self methodBytecodeWidgetIn: aComposite forContext: aContext)     initialize: [:bytecodePresentation |  bytecodePresentation selection: (self session symbolicBytecodeForCurrentPCFrom: self currentContext) ];     with: [:bytecode |  self installActionsForRootPragmas: self bytecodeActionsPragmas in: bytecode ]-======-asTruncatedTextFrom: anObject  ^self class asTruncatedTextFrom: anObject-======-methodCodeIn: composite forContext: aContext  (self methodCodeWidgetIn: composite forContext: aContext)     initialize: [:code |  code selectionInterval: (self session selectedCodeRangeForContext: self currentContext) ];     with: [:code |  self installCodeActionsFor: code ]-======-withItemsLimit: aLimit do: aBlock  | previousCandidatesLimit |  previousCandidatesLimit := candidatesLimit.  ^[ candidatesLimit := aLimit.  aBlock value ] ensure: [ candidatesLimit := previousCandidatesLimit ]-======-searchFieldTextColor  ^Color white slightlyDarker-======-testMock  self assert: spotter class equals: GTMockSpotter.  self assert: spotter newStep class equals: GTMockSpotterStep.  self assert: spotter newStep asyncTask class equals: GTMockSpotterTask-======-onThemerChanged  super onThemerChanged.  self themer spotterThemer itemActionbarStyleFor: self.  self subbricks do: [:aBrick |  self themer spotterThemer itemActionButtonWidgetStyleFor: aBrick ]-======-label  ^'[' , self key , ']'-======-privateAddIntoWorld: aBrick  super privateAddIntoWorld: aBrick.  self setAmountVisible: self subbricksCount all: '...'-======-subclassesOf: aClass inPackage: aPackageName  ^(RPackageOrganizer default packages detect: [:each |  each packageName = aPackageName ] ifNone: [ ^#() ]) classes intersection: aClass withAllSubclasses-======-interruptedProcess  ^self session interruptedProcess-======-reset  items := nil-======-initialize  super initialize.  self band: self newBand-======-size  ^self items size-======-processors  ^categories ifNil: [ categories := DoubleLinkedList new ]-======-bytecodeActionsPragmas  ^#(bytecodeCodeDebuggingAction)-======-spotterForFilesFor: aStep  < spotterOrder: 40>  self flag: #specialFilter.  aStep listProcessor     title: 'Files';     itemIcon: [ GLMUIThemeExtraIcons glamorousBrowse ];     itemFilterName: [:reference |  reference basename ];     filter: GTFilterFileReference item: [:filter :context |  self fileReferencesBy: #files inContext: context usingFilter: filter ];     wantsToDisplayOnEmptyQuery: false-======-band  ^band-======-printStackClassColumnForContext: aContext  | outer class methodClass |  outer := aContext outerMostContext.  ^String streamContents: [:aStream |  class := outer receiver class.        aStream nextPutAll: class name.        methodClass := outer methodClass.        methodClass == class ifFalse: [ aStream                 nextPut: $(;                 nextPutAll: methodClass name;                 nextPut: $) ] ]-======-fileDirectory  ^GTPlayBook stashDirectory-======-nextProcessorLinkOf: aProcessorLink  | current |  aProcessorLink ifNil: [ ^aProcessorLink ].  current := aProcessorLink nextLink.  current ifNil: [ current := self processors head ].  [ current = aProcessorLink ] whileFalse: [ current isEmpty ifFalse: [ ^current ].        current := current nextLink.        current ifNil: [ current := self processors head ] ].  ^aProcessorLink-======-itemNameFor: anObject  ^itemNameBlock ifNil: [ super itemNameFor: anObject ] ifNotNil: [ itemNameBlock cull: anObject ]-======-defaultTag: aSymbol  defaultTag := aSymbol-======-terminateProcessors  self steps do: [:each |  each terminateProcessors ]-======-creationTime: anObject  creationTime := anObject-======-scrollToTheLastOne  | leftDelta rightDelta delta |  self items isEmpty ifTrue: [ ^self ].  rightDelta := self globalBounds right - self band globalBounds right.  leftDelta := self globalBounds left - self band globalBounds left.  (leftDelta = 0 and: [ self items size <= self maxNumberOfSteps ]) ifTrue: [ ^self ].  delta := self items size <= self maxNumberOfSteps ifTrue: [ leftDelta ] ifFalse: [ rightDelta ].  delta := self band brickBounds left + delta - self band data.  self glmAnimateBrickBounds: delta duration: 400 callback: nil-======-evaluatorIn: composite  ^composite pharoScript     doItReceiver: [:object |  object ];     smalltalkClass: [:object |  object class ];     display: [:object |  String streamContents: [:stream |  stream                 nextPutAll: (self printStringOf: object);                 cr;                 nextPutAll: (GTSnippets snippetAt: object class) ] ];     onChangeOfPort: #text act: [:textPresentation :object |  GTSnippets snippetAt: object class put: (self stringWithoutInitialCommentFrom: textPresentation text asString).        textPresentation clearUserEdits ];     installDefaultSelectionActions-======-bytecodePresentation  ^self bytecodePane presentations first-======-innerBorderWidth  ^1-======-exceptionHandler  self flag: 'Bloc -> overrides doesNotUnderstand discarding the current exception context'.  ^GTCurrentSpotterExceptionHandler value ifNil: [ self step exceptionHandler ]-======-applyFilterWithQuery  | allItemsPrepocessed allItemsPrepocessedAndSorted alikeMatches otherMatches upper lower |  alikeMatches := OrderedCollection new.  otherMatches := OrderedCollection new.  allItemsPrepocessed := OrderedCollection streamContents: [:allItems |  lower := lowerThreshold * query size.        self allItemsDo: [:each |  | weight |              (weight := (self itemFilterNameFor: each) alike: query) > lower ifTrue: [ allItems nextPut: (Array with: weight with: each) ] ] ].  allItemsPrepocessedAndSorted := allItemsPrepocessed asSortedCollection: [:a :b |  a first > b first ].  upper := allItemsPrepocessed isEmpty ifTrue: [ upperThreshold ] ifFalse: [ (allItemsPrepocessedAndSorted collect: [:each |  each first ]) median ].  allItemsPrepocessedAndSorted do: [:each |  each first >= upper ifTrue: [ alikeMatches add: each last.              alikeMatches size > self itemsLimit ifFalse: [ self addItem: each ] ] ifFalse: [ otherMatches add: each last ] ].  alikeMatches size < self itemsLimit ifTrue: [ (otherMatches first: (self itemsLimit - alikeMatches size min: otherMatches size)) do: [:each |  self addItem: each ] ].  self filteredItems: alikeMatches , otherMatches-======-hasQuery  ^self query isEmptyOrNil not-======-newTriangleBrick  ^GLMHintableActionButtonBrick new-======-streamed: anObject  streamed := anObject-======-rawValue  ^self subclassResponsibility-======-variableTag  ^'temp'-======-applyFilter  ^self filteredItems-======-itemHoveredBackgroundColor  ^self itemSelectedBackgroundColor alpha: 0.35-======-initialize  super initialize.  self needsUpdate: false-======-hintHideStyleFor: aBrick  aBrick ifNil: [ ^self ].  (aBrick valueOfProperty: #brickSpotterIsReveal ifAbsent: [ false ]) ifFalse: [ ^self ].  aBrick setProperty: #brickSpotterIsReveal toValue: false.  (aBrick hasProperty: #brickSpotterBackupColor) ifTrue: [ aBrick color: (aBrick valueOfProperty: #brickSpotterBackupColor) ].  (aBrick hasProperty: #brickSpotterBackupBorder) ifTrue: [ aBrick border: (aBrick valueOfProperty: #brickSpotterBackupBorder) ].  aBrick changed-======-applyFilterInContext: aSpotterContext error: exception  super applyFilterInContext: aSpotterContext error: exception.  ^(GTFilterSubstrings new     caseSensitive: self caseSensitive;     yourself) value: aSpotterContext-======-getText  ^self text-======-initialize  super initialize.  processorsFilter := GTSpotterSettingsProcessorFilter new-======-testDeploymentExceptionHandlerMock2  self assertResetExceptions.  self shouldntRaise: MessageNotUnderstood process: 'abc' origin: GTSpotterExceptionMock2 new.  self assertException: MessageNotUnderstood.  self assertResetExceptions.  self shouldntRaise: Error process: 'abc' origin: GTSpotterExceptionMock2 new.  self assertException: MessageNotUnderstood-======-exceptionHandler  ^exceptionHandler ifNil: [ exceptionHandler := self defaultExceptionHandler ]-======-defaultLabel  ^'Profile it'-======-addItems: aCollection  self context streamed addAll: aCollection.  self context addItems: aCollection-======-addItem: anObject  self stream addObject: anObject inProcessor: self processor-======-spotterUsersFor: aStep  < spotterOrder: 50>  ^aStep listProcessor     title: 'Users';     filter: GTFilterSubstring item: [:filter :context |  self users do: [:sender |  filter value: sender ] ]-======-debugger  ^debugger-======-currentStep: aStepModel  currentStep := aStepModel.  self notifyCurrentStepChanged-======-formatStackExtraColumnForContext: aContext  ^Text string: (self printStackExtraColumnForContext: aContext) attributes: (self textAttributesForStackEntry: aContext)-======-history  ^history ifNil: [ self class history ]-======-testAddThreeCandidateA1A2A3Shuffled  | link11 link12 link13 link21 link22 link23 link31 link32 link33 category1 category2 category3 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  category3 := candidates addProcessor: GTSpotterA3.  link21 := candidates addCandidate: 21 in: GTSpotterA2.  link22 := candidates addCandidate: 22 in: GTSpotterA2.  link11 := candidates addCandidate: 11 in: GTSpotterA1.  link31 := candidates addCandidate: 31 in: GTSpotterA3.  link12 := candidates addCandidate: 12 in: GTSpotterA1.  link32 := candidates addCandidate: 32 in: GTSpotterA3.  link23 := candidates addCandidate: 23 in: GTSpotterA2.  link33 := candidates addCandidate: 33 in: GTSpotterA3.  link13 := candidates addCandidate: 13 in: GTSpotterA1.  self assert: link11 nextLink equals: link12.  self assert: link11 previousLink equals: link33.  self assert: link12 nextLink equals: link13.  self assert: link12 previousLink equals: link11.  self assert: link13 nextLink equals: link21.  self assert: link13 previousLink equals: link12.  self assert: link21 nextLink equals: link22.  self assert: link21 previousLink equals: link13.  self assert: link22 nextLink equals: link23.  self assert: link22 previousLink equals: link21.  self assert: link23 nextLink equals: link31.  self assert: link23 previousLink equals: link22.  self assert: link31 nextLink equals: link32.  self assert: link31 previousLink equals: link23.  self assert: link32 nextLink equals: link33.  self assert: link32 previousLink equals: link31.  self assert: link33 nextLink equals: link11.  self assert: link33 previousLink equals: link32.  self assert: candidates head equals: link11.  self assert: candidates tail equals: link33.  self assert: category1 headLink equals: link11.  self assert: category1 tailLink equals: link13.  self assert: category2 headLink equals: link21.  self assert: category2 tailLink equals: link23.  self assert: category3 headLink equals: link31.  self assert: category3 tailLink equals: link33-======-onAddedSelector: anObject  onAddedSelector := anObject-======-itemIconMaxWidth  ^50-======-forDebugger: aDebugger  debugger := aDebugger.  newContext := aDebugger currentContext-======-stepModel  ^stepModel-======-testArrayPairsOverLimit  | limit pairs |  limit := 2 * GTInspector indexableDisplayLimit + 1.  pairs := (1 to: limit) asArray gtInspectorVariableValuePairs.  self assert: pairs size equals: 2 * GTInspector indexableDisplayLimit.  (pairs collect: #key) allSatisfy: [:e |  (pairs at: e) = e ].  self assert: (pairs collect: #key) equals: ((1 to: GTInspector indexableDisplayLimit) asOrderedCollection           addAll: (limit - GTInspector indexableDisplayLimit + 1 to: limit) asOrderedCollection;           yourself)-======-handlesMouseDown: evt  ^true-======-diveInCategory  ^self diveInCategoryDueTo: #unknown-======-borderColor: aColor  borderColor := aColor-======-printSignature: aSignature  ^aSignature first name , '>>' , aSignature second asString-======-after: afterBlock do: doBlock ifTrue: conditionBlock  | value |  value := conditionBlock brickValue: self.  afterBlock brickValue: self.  value ifTrue: [ doBlock brickValue: value ]-======-itemNormalStyleFor: aBrick  aBrick     height: [ self itemHeight ];     hSpaceFill-======-title  ^title ifNil: [ 'Page' ]-======-objects  ^objects-======-stepModel: anObject  stepModel := anObject.  self stepModel spotter announcer when: GTSpotterRevealHints send: #onRevealHints to: self.  self stepModel spotter announcer when: GTSpotterHideHints send: #onHideHints to: self.  self     addActActionButton;     addDiveInActionButton-======-defaultStreamed  ^true-======-buildCategoryBrick: aProcessor  < return: #GTSpotterCategoryBrick>  | titleBrick categoryBrick |  titleBrick := self newTitleBrick on: self stepModel category: aProcessor.  self themer spotterThemer categoryTitleStyleFor: titleBrick.  categoryBrick := self newCategoryBrick on: self stepModel category: aProcessor.  self themer spotterThemer categoryStyleFor: categoryBrick.  categoryBrick titleBrick: titleBrick.  ^categoryBrick-======-