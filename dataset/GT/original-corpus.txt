hideTriangle  isTriangleVisible := false.  self themer spotterThemer breadcrumbItemTriangleWidgetStyleFor: self triangleBrickselectedVariableName  ^self cache at: #selectedVariableName ifAbsent: [ nil ]diveIn  self diveInDueTo: #undefinedtogglePreview  self isPreviewVisible ifTrue: [ self hidePreview ] ifFalse: [ self showPreview ]itemIcon: aBlockWithOneArgument  itemIconBlock := aBlockWithOneArgumentnotifySelectedCandidateChanged: aCandidateLink for: anEventType  | aCandidate |  self assert: [ aCandidateLink isNotNil ] description: [ 'aCandidateLink must not be nil' ].  aCandidate := aCandidateLink candidate.  self announcer announce: (GTSpotterSelectedCandidateChanged new select: aCandidate).  self spotter notifyCandidateSelected: aCandidate for: anEventTypeisMatchedItem: anItem  ^query match: (self itemFilterNameFor: anItem)stackWidgetIn: composite  ^composite fastTable     title: 'Stack';     useCache;     display: [:aSession |  self retrieveStackFrom: aSession ];     column: 'Class' evaluated: [:aContext |  self formatStackClassColumnForContext: aContext ] width: 300;     column: 'Method' evaluated: [:aContext |  self formatStackMethodColumnForContext: aContext ];     column: 'Other' evaluated: [:aContext |  self formatStackExtraColumnForContext: aContext ];     hideHeaderrelevantProcessorsProcess: aSpotterContext  [ self basicRelevantProcessorsProcess: aSpotterContext ] on: Error do: [:exception |  self exceptionHandler handleException: exception do: [ ('[Spotter] Exception in process: ' , exception asString) traceCr ] ]allActionsForPragmas: aSymbolsCollection  ^self session class debuggingActionsForPragmas: aSymbolsCollection for: selfisEmpty  self deprecated: 'Use hasCandidates instead'.  ^self hasCandidates notinspectorActionsForNode  < return: #Collection of: #GLMAction>  ^self browsingActionsForNodespotterModelDo: aBlock  self spotterModel handleExceptionsDuring: [ aBlock cull: self spotterModel.        self handleProcessorKeyBindings ]resetBindings  ^self inspectorPresentation firstPresentation resetBindingsitemBrick: anObject  candidateBrick := anObjectrenderingProcessor: aProcessorLink  renderingProcessorLink ifNil: [ renderingProcessorLink := aProcessorLink processor asSpotterProcessorLink ].  processorLink ifNil: [ processorLink := aProcessorLink ]onStepAdded  previewObject := nil.  self updatePreviewWithLoadingstreamed: anObject  streamed := anObjectmatch: aBlockWithTwoArguments  self filter: (GTFilterBlock new           matcher: aBlockWithTwoArguments;           yourself)saveContent: aStringOrText  self content: aStringOrText.  self savecacheAt: aSymbol ifAbsentPut: aBlock  ^self cache at: aSymbol ifAbsentPut: aBlockmockProcessorFor: aSpotterStep  < spotterOrder: 1>  aSpotterStep listProcessor     allCandidates: [ #(1 2 3) ];     itemName: [:item |  item / 0 ];     filter: GTFilterSubstringprocessorsFilter  ^processorsFilterorientation: aSymbol  orientation := aSymbolcontext  ^contextdefaultStream  ^GTMockSpotterStream newactOn: anObject for: aStep  anObject spotterActDefault: aStepdefaultKeymap  ^$g metatestPageActionsIn  | actions selector action |  selector := playground class compile: 'mockMethodPageAction	<pageActionOrder: 10>	^ GLMGenericAction new		action: [ :presentation | self inform: ''page action works'' ];		iconNamed: #abstract;		title: ''A mock page action''' classified: '*GTMockTests'.  self assert: selector notNil.  window := playground openOn: (GTPlayPage new saveContent: 'a:=1. b:=a+1').  actions := playground pageActions.  self denyEmpty: actions.  action := actions detect: [:eachAction |  eachAction title = 'A mock page action' ].  self deny: action isNilnewActionbarBrick  ^GLMBrick newtestDeploymentExceptionHandlerMock1  self assertResetExceptions.  self shouldntRaise: AssertionFailure process: 'abc' origin: GTSpotterExceptionMock1 new.  self assertException: AssertionFailure.  self assertResetExceptions.  self shouldntRaise: Error process: 'abc' origin: GTSpotterExceptionMock1 new.  self assertException: AssertionFailurehelp  ^'Open a sytem browser on the current method.'spotterForExpressionsFor: aStep  < spotterOrder: 1>  self flag: #specialFilter.  aStep listProcessor     title: 'Calculator';     filter: GTNullFilter item: [:filter :context |  self evaluateExpressionInContext: context usingFilter: filter ];     wantsToDisplayOnEmptyQuery: falsenewBand  ^GLMBrick newisStash  ^falseitemFilterNameFor: anObject  ^itemFilterNameBlock ifNil: [ super itemFilterNameFor: anObject ] ifNotNil: [ itemFilterNameBlock cull: anObject ]itemFilterNameFor: anObject  ^self itemNameFor: anObjectdebugger: anObject  debugger := anObjectopenInWindowLabeled: aString inWorld: aWorld  self autoHide: false.  ^super openInWindowLabeled: aString inWorld: aWorldhandleFatalException: anException  GTSpotterExceptionsTest fatals add: anExceptionsnippetAt: anObject  ^self snippets at: anObject ifAbsent: [ 'self' ]methodBytecodeWidgetIn: aComposite forContext: aContext  ^aComposite tree     title: 'Bytecode';     rootsExpanded;     display: [ aContext method symbolicBytecodes ];     children: [:each |  each isArray ifTrue: [ each ] ifFalse: #() ];     format: [:each |  self formatBytecode: each ];     onChangeOfPort: #selection act: [:bytecodes |  self codePresentation selectionInterval: (bytecodes selection ifNil: [ 1 to: 0 ] ifNotNil: [:selectedBytecode |  selectedBytecode sourceInterval ]) ]onThemerChanged  super onThemerChanged.  self themer spotterThemer breadcrumbItemLabelWidgetStyleFor: self labelBrick.  self themer spotterThemer breadcrumbItemTriangleWidgetStyleFor: self triangleBrickrequestRefresh  self inspectorPresentation refreshPanesremove  (self ownerThatIsA: GLMFoundationBrick) ifNotNil: [:o |  o delete ]hasCategories: aCollection  | counter |  candidates processors asArray size = aCollection size ifFalse: [ ^false ].  counter := 1.  candidates processors asArray do: [:each |  each = (aCollection at: counter) ifFalse: [ ^false ].        counter := counter + 1 ].  ^trueprivateAddCandidate: aCandidateLink inNotEmpty: aProcessorLink  self candidates add: aCandidateLink afterLink: aProcessorLink tailLink.  aProcessorLink incrementSize.  aProcessorLink tailLink: aCandidateLink.  ^aCandidateLinknotifyActOn: anObject for: anEventType  self announce: (GTSpotterActOn new           element: anObject;           eventType: anEventType)cache  ^cache ifNil: [ cache := Dictionary new ]toggleHints  self visible ifFalse: [ ^self ].  self stepModel spotter isShiftPressed ifTrue: [ self onRevealHints ] ifFalse: [ self onHideHints ]selectedCandidate  < return: #Object>  ^self selected candidatetext: aString  self labelBrick text: aString.  self doLayoutForceemptyTextPadding  ^15update  self debugAction ifNotNil: [:aDebugAction |  self label: aDebugAction label.        self help: aDebugAction help , Character tab asString , (aDebugAction keymap ifNil: [ '' ] ifNotNil: [:k |  k printString ]).        self icon: aDebugAction icon.        self enabled: aDebugAction enabled.        self state: false.        self action: [ aDebugAction execute ] ]processor  ^self context processordeselect  selected := nilexecuteAction  self codePresentation evaluateSelectionAndDo: [:result |  shouldBasicInspect ifTrue: [ result basicInspect ] ifFalse: [ result inspect ] ]selectionInterval: anInterval  ^((self browser paneNamed: #code) port: #selectionInterval) value: anIntervaladdItem: anItem  self context streamed add: anItem.  self context addItem: anItemnewGoButtonFor: anAssociation  ^self newActionButton     hintTitle: 'Go';     hintText: 'open new pane to the right';     icon: self themer bindingThemer goIcon;     action: [:b |  self remove.        self announce: #go event: anAssociation ]defaultItems  ^self defaultItemsClass newannouncer  ^announcer ifNil: [ announcer := Announcer new ]tempIndex  ^tempIndexcontextToSelectFrom: aSession  ^aSession assertionCallerContext ifNil: [ aSession testContext ]previous  ^previouslabelBrick  ^labelBrickdefaultPagesLimit  ^100id  ^#gTProfileSelectionDebugActiontestAddThreeCandidateA1  | link1 link2 link3 category |  category := candidates addProcessor: GTSpotterA1.  link1 := candidates addCandidate: 11 in: GTSpotterA1.  link2 := candidates addCandidate: 12 in: GTSpotterA1.  link3 := candidates addCandidate: 13 in: GTSpotterA1.  self assert: link1 nextLink equals: link2.  self assert: link1 previousLink equals: link3.  self assert: link2 nextLink equals: link3.  self assert: link2 previousLink equals: link1.  self assert: link3 nextLink equals: link1.  self assert: link3 previousLink equals: link2.  self assert: candidates head equals: link1.  self assert: candidates tail equals: link3.  self assert: category headLink equals: link1.  self assert: category tailLink equals: link3handleListenEvent: anEvent  anEvent type = #mouseDown ifTrue: [ ((self fullBoundsInWorld containsPoint: anEvent position) not and: [ self autoHide ]) ifTrue: [ self spotterModel ifNotNil: [:aModel |  aModel exitDueTo: #mouseDown ] ] ].  anEvent type = #keyDown ifTrue: [ self spotterModel ifNotNil: [:s |  s shiftPressed: InputEventSensor default anyModifierKeyPressed not & InputEventSensor default shiftPressed ] ]mouseDown: evt  | selectors |  self isEnabled ifFalse: [ ^self ].  selectors := Array with: #singleClick: with: #doubleClick: with: nil with: nil.  evt hand waitForClicksOrDrag: self event: evt selectors: selectors threshold: 10notifyShowPreview  self announce: GTSpotterShowPreview newdoFilterInContext: aSpotterContext  self subclassResponsibilitybasicVariableNodesFor: anObject in: aCollection  aCollection addAll: ((anObject class allInstVarNames collectWithIndex: [:ivName :index |  GTInspectorProtoObjectNode hostObject: anObject index: index slotName: ivName ]) sort: [:aNode :anotherNode |  aNode label < anotherNode label ])methodHierarchy  self systemNavigation methodHierarchyBrowserForClass: self currentClassOrMetaClass selector: self currentMessageNamecontextToSelectFrom: aSession  ^aSession interruptedContextasSpotterProcessorLink  ^selftestFailingAssestionThroughAHelperMethod  self intermediaryCheckWithFailurecanContinue  ^self step event == #diveIn or: [ self step event isNil ]actionbarBrick  ^actionbarBrickcodePresentation  ^self inspectorPresentation firstPresentationcandidates  ^candidates ifNil: [ candidates := GTSpotterCandidatesList new.        candidates announcer when: GTSpotterCandidateAdded send: #onCandidateAdded to: self.        candidates announcer when: GTSpotterAllCandidatesAdded send: #onCandidateAdded to: self.        candidates announcer when: GTSpotterAllCandidatesRemoved do: [ self deselect ].        candidates ]cacheAt: aSymbol  ^self cacheAt: aSymbol ifAbsent: [ nil ]allItems  | allItems |  allItems := self processor allItemsIn: self context.  ^self context isContinuing ifTrue: [ allItems value fasterDifferencePreservingOrder: self context streamed ] ifFalse: [ allItems ]pages: anObject  pages := anObjectselect: aBlock thenDo: aBlock2  self do: [:each |  (aBlock value: each) ifTrue: [ aBlock2 value: each ] ]checkWithFailure  self assert: false description: 'A failure'interruptedContext  ^self session interruptedContextcategoryNameMarginLeft  ^self itemIconMaxWidthbrowser  ^self firstsettingsLabelTextColor  ^Color whiteaddProcessor: aProcessor  self processors add: aProcessoritemActionbarStyleFor: aBrick  aBrick     useHorizontalLinearLayout;     hShrinkWrap;     vSpaceFill;     marginRight: self outerBorderWidth + 2;     visible: falseprocessorsFilter  ^self spotter processorsFilterdefaultOrder  ^1codePresentationIn: composite  ^composite pharoScriptsettingsLabelPadding  ^4announcer  ^announcer ifNil: [ announcer := Announcer new ]select: aCandidateLink  self select: aCandidateLink dueTo: #unknowntearDown  spotter := currentStep := currentProcessor := currentCandidate := nil.  super tearDownid  ^#gTDebugSelectionDebugActionlowerThreshold: anObject  lowerThreshold := anObjectspotterPaneStyleFor: aBrick  aBrick     useHorizontalLinearLayout;     hSpaceFill;     vSpaceFillplaygroundActionPragma  ^#playgroundActionOrder:defaultUpperThreshold  ^0.45newNameBrick  ^GLMLabelBrick newspotterModel  ^spotterModelsearchField  ^searchFieldisStash  ^truesetUp  super setUp.  a := 42spotterModel  ^spotterModelapplyFilter  self hasQuery ifFalse: [ self applyFilterWithoutQuery.        ^self allItems ].  self applyFilterWithQuery.  ^self filteredItemscontinueItemsLimit  ^self defaultContinueItemsLimit - self itemsLimit max: 0previewPaddingRight  ^self previewPaddingLeftonStepPopped  self updatePreviewWith: self spotterModel steps last selected candidateusers: aSelector inPackages: anArray  | users |  users := OrderedCollection new.  RPackageOrganizer default packages do: [:package |  anArray do: [:packageName |  package packageName = packageName ifTrue: [ package methods do: [:cm |  ((cm refersToLiteral: aSelector) and: [ (cm hasPragmaNamed: aSelector) not ]) ifTrue: [ users add: cm ] ] ] ] ].  ^usersoverridesDefaultSetUpMethod  ^self setUpMethod methodClass ~= TestCasesearch: anObject  search := anObjectattachExtraBehaviourToPresentationsIn: aComposite  aComposite presentations do: [:aPresentation |  aPresentation addAction: ((self closeActionFor: aPresentation) condition: [:currentPresentation |  self panes size > 1 and: [ self isPresentation: aPresentation inPane: self panes last ] ]) ]fileName  ^self page title , '-' , self page creationTimeForFileName , '.' , GTPlayPage fileExtensionitemName: aBlockWithOneArgument  itemNameBlock := aBlockWithOneArgumentcontent  ^contenthandleProcessorKeyBindings  self processorKeyBindingsDo: [ self spotterModel currentStep ifNotNil: [ self spotterModel currentStep processors do: [:processor |  processor keyBinding ifNotNil: [ | keyCombination |                          keyCombination := processor keyBinding asKeyCombination.                          processorKeyBindings at: keyCombination put: processor.                          self kmDispatcher bindKeyCombination: keyCombination toAction: [ self onKeyProcessor: processor ] ] ] ] ]compose  self title: 'Raw'.  self tabulator with: [:browser |  browser           row: #variables;           row: #evaluator.        browser transmit           to: #variables;           andShow: [:a |  self variablesIn: a ].        browser transmit           to: #evaluator;           andShow: [:a |  self evaluatorIn: a ].        browser transmit           from: #variables;           toOutsidePort: #selection;           transformed: [:aNode |  aNode ifNotNil: [ aNode value ] ].        browser transmit           from: #evaluator;           toOutsidePort: #selection ].  self wantsAutomaticRefresh: truesourceIn: a  ^a pharoMethod     smalltalkClass: [:each |  each parents first methodClass ];     display: [:each |  each source ]actionbarBrick: aBrick  actionbarBrick ifNotNil: [ self removeBrick: actionbarBrick ].  actionbarBrick := aBrick.  self addBrickBack: actionbarBricksession  ^(self browser pane port: #entity) valuedefaultFilteredItems  ^OrderedCollection new: 100newEmptyText  ^GLMLabelBrick new     text: 'No bindings';     hSpaceFill;     textPosition: #center;     padding: self themer bindingThemer emptyTextPadding;     textColor: self themer bindingThemer emptyTextColor;     fontSize: self themer bindingThemer emptyTextFontSize;     yourselfexecuteAction  HelpBrowser open selectTopicSatisfying: [:each |  each owner notNil and: [ each owner key = self debugger class helpClass key and: [ each title = 'Overview' ] ] ]hidePreview  self isPreviewVisible ifFalse: [ ^self ].  isPreviewVisible := false.  self class dontShowPreview.  self notifyHidePreviewsearchFieldTextColor  ^Color blackactOnPaneAdded: ann  (self panes atLast: 2 ifAbsent: [ ^self ]) presentations first updateToolbarspotterContentsWidgetStyleFor: aBrick  aBrick     borderColor: self borderColor;     color: self borderColortestWithErrorInSetup  self assert: truetestBasic  | context process debugger printedString |  context := [ 20 factorial ] asContext.  process := Process forContext: context priority: Processor userInterruptPriority.  debugger := GTGenericStackDebugger on: (process newDebugSessionNamed: 'test debugging' startedAt: context).  self assert: debugger stackPresentation selection equals: context.  printedString := '[ 20 factorial ] in GTGenericStackDebuggerTest>>testBasic'.  self assert: debugger selectedContext printString equals: printedString.  debugger send.  debugger send.  debugger update.  self assert: debugger codePresentation entity sourceCode equals: (Integer >> #factorial) sourceCode.  self assert: debugger stackPresentation selection printString equals: 'SmallInteger(Integer)>>factorial'.  process terminatecurrentBindingsSorted  ^self currentBindings associations asSortedCollection: [:first :second |  first key < second key ]renderingProcessor  renderingProcessorLink ifNil: [ self renderingProcessor: processorLink ].  ^renderingProcessorLink valuelabelBrick  ^labelBrickreplaceSelectedSignaturesWith: aList in: aGTInspector  selectedMethodSignatures := aList.  aGTInspector updateprivacyAgreementIsSendingDataColor  ^Color paleGreencodePresentationSelector: aSelector  codePresentationSelector := aSelectorinitialize  super initialize.  objects := OrderedCollection newtitle  ^title ifNil: [ super title ]stepModel  ^stepModelonCandidateMoved  self moveTo: self selectedItemBrickprintStringOf: anObject  | className |  className := anObject class name.  ^(String streamContents: [:s |  s           nextPutAll: (className first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);           nextPutAll: className ]) asCommentsetUpMethod  ^self testObject class lookupSelector: #setUpbasicRelevantProcessorsProcess: aSpotterContext  self basicRelevantProcessorsProcess: aSpotterContext do: [:processor |  processor filterInContext: aSpotterContext ].  aSpotterContext continueFilterrawValue  ^self hostObjectprintStackExtraColumnForContext: aContext  | selector |  ^aContext outerContext ifNil: [ String streamContents: [:aStream |  selector := aContext selector ifNil: [ aContext method defaultSelector ].              selector = #doesNotUnderstand: ifTrue: [ aStream space.                    (aContext tempAt: 1) selector printOn: aStream ] ifFalse: [ '' ] ] ] ifNotNil: [ aContext closure printString ]closeButtonWidgetStyleFor: aBrick  aBrick     normalImage: GLMUIThemeExtraIcons glamorousClose;     pressedColor: self buttonPressedColoreventType: anObject  eventType := anObjectscrollToPane: pageIndex callback: aBlock  self flag: 'this method gets called directly from the gt-spotter model - hmmmmm'.  aBlock valuenewContentsBrick  ^GTSpotterContentsBrick newprivateAddCandidate: aCandidateLink weightedInNotFull: aProcessorLink  | head tail |  head := aProcessorLink headLink.  tail := aProcessorLink tailLink.  aCandidateLink weight > head weight ifTrue: [ head := self candidates add: aCandidateLink beforeLink: head ] ifFalse: [ aCandidateLink weight > tail weight ifFalse: [ tail := self candidates add: aCandidateLink afterLink: tail ] ifTrue: [  ] ]spotterPreviewStyleFor: aBrick  aBrick     borderWidth: self previewBorderWidth;     hSpaceFill: self previewWidthPercent;     vSpaceFill;     margin: {(self headerHeight + self innerBorderWidth) .         0 .         0};     marginLeft: (self previewBorderWidth + self previewArrowWidth) negated.  aBrick layout zIndex: 1executeAction  self session runToBytecode: self debugger bytecodePresentation selection inContext: self currentContextonHideHints  self visible ifFalse: [ ^self ].  self themer spotterThemer hintHideStyleFor: self diveInButton.  self themer spotterThemer hintHideStyleFor: self actOnButtoncategoryTitleNameStyleFor: aBrick  aBrick     vSpaceFill;     textPosition: #leftCenter;     width: [:name |  aBrick owner innerBounds width min: name label textSize x + name label hMargin ].  aBrick label familyName: self titleFamilyNameopenExplorerFor: anObject  self openOn: anObjectcomputeAllItemsIn: aContext  ^allCandidatesBlock cull: aContextisVisible: aBrick in: aRectangle  ^aRectangle intersects: aBrick globalOuterBoundsisAbove: aBrick in: aRectangle  ^aBrick globalOuterBounds origin <= aRectangle originshouldDisplayPresentationCreatedBy: aMethod  ^self presentationFilter shouldDisplayPresentationCreatedBy: aMethodshouldRaise: anError process: aString origin: anOrigin do: aBlock  self shouldRaise: anError process: aString origin: anOrigin during: GTSpotterDebuggingExceptionHandlerMock new do: aBlockonHovered  self titleBrick showActionbarselectNextCategory  self spotterModel hasSelected ifTrue: [ self spotterModel currentStep selectNextCategory ]openListChooseLabeled: sString forInspector: aGTInspector with: allElements select: selectedElements format: aBlockOrSelector actionSelector: aSymbol  | treeModel |  treeModel := MorphTreeModel new.  treeModel     beCheckList;     rootItems: allElements;     wrapBlockOrSelector: aBlockOrSelector;     autoMultiSelection: true.  (treeModel openDialogWindowIn: self currentWorld title: sString selectedtems: selectedElements) ifNotNil: [:selection |  self perform: aSymbol with: selection with: aGTInspector ]candidateLink  ^candidateLinkonScrolled  self stepModel spotter announce: GTSpotterCandidateSelectedMoved neweventType  ^eventTypecacheAt: aSymbol put: anObject  ^self cache at: aSymbol put: anObjectid  ^#gtRunToSelectionunsubscribeListeners  self activeHand removeEventListener: self.  Morph announcer unsubscribe: selftestMultiValuedStreaming  | headers keysAndValues |  headers := ZnHeaders new.  headers at: 'Set-Cookie' put: 'foo=1'.  headers at: 'Set-Cookie' add: 'bar=1'.  headers at: 'Content-TYPE' put: 'text/plain'.  headers at: 'Content-Length' put: '128'.  keysAndValues := OrderedCollection streamContents: [:stream |  headers headersDo: [:key :value |  stream                 nextPut: key;                 nextPut: value ] ].  self assert: keysAndValues equals: #('Set-Cookie' 'foo=1' 'Set-Cookie' 'bar=1' 'Content-Length' '128' 'Content-TYPE' 'text/plain') asOrderedCollectionallowedBounds  ^allowedBoundsonHideHints  self themer spotterThemer hintHideStyleFor: self settingsButton.  self themer spotterThemer hintHideStyleFor: self closeButton.  self themer spotterThemer hintHideStyleFor: self helpButtonnewPageLabel  ^GLMLabelBrick new     hSpaceFill;     vShrinkWrap;     textPosition: #leftCenter;     vAlign: #center;     padding: {0 .         self themer bindingThemer padding}previewArrowWidth  ^self itemHeight / 2 + self previewArrowGapHacksetDebuggerToFirstNonFilteredContext  | selection |  selection := self stackPresentation selection.  (selection isNil or: [ selection method hasPragmaNamed: #debuggerCompleteToSender ]) ifTrue: [ self filteredStack ifNotEmpty: [:stack |  self stackPresentation selection: stack first ] ]codeIn: a  ^(self codePresentationIn: a)     title: [:page |  GTPlaygroundEditableTabLabel new           text: page title;           when: #accepted do: [:text |  page setTitleAndEnsureInStash: text asString ];           yourself ];     format: [:page |  page content ];     act: [:text :page |  text selectionInterval: (1 to: text text size).        text highlightEvaluateAndDo: [:result |  text selection: result ] ] icon: GLMUIThemeExtraIcons glamorousGo on: $G entitled: 'Do it all and go';     act: [:text :page |  page publish ] iconName: #glamorousSaveToUrl entitled: 'Remote publish';     addAction: (GLMPopupAction new           action: [:text :page :popup |  GTPlaygroundBindingsList new                 on: self currentBindingsSorted;                 when: #bindingRemoved do: [:binding |  self removeBinding: binding ];                 when: #inspect do: [:binding |  binding value inspect ];                 when: #go do: [:binding |  text selection: binding value ];                 yourself ];           iconName: #glamorousTable;           title: 'Bindings';           yourself);     addAction: (GLMPopupAction new           action: [:text :page :popup |  GTPlaygroundPlayPagesList new                 on: GTPlayBook instance;                 when: #pageAccepted do: [:playPage |  text entity saveContent: playPage content.                    text update ];                 yourself ];           iconName: #glamorousMore;           title: 'Play pages';           yourself);     with: [:presentation |  self pageActionsIn: presentation ];     dynamicActionsOnSelection: [ self contextMenuActions ];     onChangeOfPort: #text act: [:text :page |  page saveContent: text text.        text clearUserEdits ]query  ^querytestAssertionEqualsDetected  self assertDebuggerInitializationForContext: [ GTSUnitExampleFailingTest new testArrays ] asContext andStepBlock: self stepBlockForTestArrays.  self assert: session testContext method equals: GTSUnitExampleFailingTest >> #testArrays.  self assert: session assertionContext method selector equals: #assert:equals:.  self assert: session assertionCallerContext equals: session testContext.  self assert: session supportsDiff description: 'When #assert:equals: is encountered a diff can be used'.  self assertDebuggerClosingdefaultLabel  ^''deselect  self invalidateWith: [ self labelBrick label           customFont;           beRegular ]timestamp: anObject  timestamp := anObjectdefaultTask  ^GTMockSpotterTask newelement: anObject  element := anObjectaddSeparator  | separator |  separator := self newSeparator.  self themer spotterThemer breadcrumbSeparatorStyleFor: separator.  self themer spotterThemer breadcrumbSeparatorWidgetStyleFor: separator.  self band addBrickBack: separatordefaultLabel  ^'Accept'hasDynamicItems  ^trueisMatchedItem: anItem  | itemName |  itemName := self itemFilterNameFor: anItem.  ^query allSatisfy: [:fragment |  itemName includesSubstring: fragment caseSensitive: self caseSensitive ]initialize  super initialize.  self needsUpdate: falseiconFor: anObject  ^[ anObject gtInspectorIcon ifNil: [ anObject class systemIcon ] ] on: Error do: [:error |  self iconFor: anObject error: error ]headerHeight  ^56element: anObject  element := anObjectspotterImplementorsFor: aStep  < spotterOrder: 30>  self flag: #specialFilter.  aStep listProcessor     title: 'Implementors';     filter: GTFilterImplementor item: [:filter :context |  SystemNavigation default allBehaviorsDo: [:class |  class methodsDo: filter ] ];     keyBinding: $m meta;     wantsToDisplayOnEmptyQuery: falsevariableTag  ^self hostObject variableTagshouldEnableProcessorsCreateBy: aMethod  ^selectedMethodSignatures anySatisfy: [:aSignature |  aSignature first = aMethod methodClass and: [ aSignature second = aMethod selector ] ]inspectorPresentation  ^self presentations firstdefaultOrder  ^20help  ^'Cancel editor changes.'testNewSpotter  | step1 |  self assert: spotter notNil.  self assert: spotter hasSteps not.  self assertEmpty: spotter steps.  self deny: spotter hasMultipleSteps.  self shouldnt: [ step1 := spotter currentStep ] raise: Error.  self flag: '#currentStep is not always cached in spotter - especially when it is a new/empty spotter. In that case #currentStep will always return a new instance of a step. The implementation would be more polymorphic, oo-style, simpler and with much less ifTrue/ifFalse if the initial-state were regarded as a step as well (as an inst-var not in the inst-var-list of #steps). Maybe use a separate type to distinguish? GTSpotterInitialStep ... '.  self assert: step1 notNil.  self assert: spotter hasSteps not.  self assertEmpty: spotter stepspagesLimit  ^pagesLimit ifNil: [ self defaultPagesLimit ]hideActionsOf: aRowBrick  aRowBrick subbricks select: [:each |  each isKindOf: GLMHintableActionButtonBrick ] thenDo: [:each |  each visible: false ]pragmas  ^pragmas ifNil: [ pragmas := OrderedCollection new.        SystemNavigation new allBehaviorsDo: [:each |  Pragma withPragmasIn: each do: [:p |  p selector = self selector ifTrue: [ pragmas add: p ] ] ].        pragmas ]shrinkBottom: aRectangle with: aBrick  ^aRectangle bottom: aRectangle bottom - aBrick globalOuterBounds heightcategory: aProcessor  self assert: aProcessor isNotNil.  category := aProcessorexecuteAction  self debugger codePresentation hasUnacceptedEdits ifTrue: [ self debugger codePresentation clearUserEdits.        self debugger updateCodeEditor ]backgroundColor  ^Color whiteitems  ^items ifNil: [ items := OrderedCollection new ]shortcutBrick: aBrick  shortcutBrick ifNotNil: [ self removeBrick: shortcutBrick ].  shortcutBrick := aBrick.  self themer spotterThemer categoryTitleShortcutStyleFor: shortcutBrick.  self addBrickBack: shortcutBrickcandidate  ^self candidateLink valueassertDiveOut  | previousStepsSize |  previousStepsSize := spotter steps size.  previousStep := spotter currentStep.  self shouldnt: [ spotter popStep ] raise: Error.  currentStep := spotter currentStep.  currentProcessor := currentCandidate := previousContext := currentContext := nil.  self assert: spotter steps size < previousStepsSize.  self assert: spotter steps size equals: previousStepsSize - 1.  self deny: (previousStepsSize > 1 and: [ previousStep = currentStep ]).  self deny: (previousStepsSize > 1 and: [ previousStep = spotter currentStep ]).  self assert: currentStep equals: spotter currentStepcompose  self title: [:anObject |  'Inspector on ' , (self printObjectAsAnItem: anObject) ].  self titleIcon: (self iconNamed: #smallInspectIt).  self act: [:b |  b update ] icon: GLMUIThemeExtraIcons glamorousRefresh entitled: 'Update'.  self act: [:b |  HelpBrowser open selectTopicSatisfying: [:each |  each owner notNil and: [ each owner key = GTInspectorHelp key and: [ each title = 'Overview' ] ] ] ] icon: GLMUIThemeExtraIcons glamorousHelp entitled: 'Help'.  self act: [:b |  b presentationFilter changeFilterRequestFor: b ] entitled: 'Filter presentations'.  self pager with: [:browser |  browser fixedSizePanes: self class numberOfInspectorPanes.        browser show: [:a :each |  a title: [ self printObjectAsAnItem: each ].              a dynamicActions: [:aPresentation |  each gtInspectorActions asOrderedCollection ].              a titleAction: [:aPresentation |  self closeActionFor: aPresentation ].              a dynamic display: [:x |  (GLMCompositePresentation new with: [:d |  each gtInspectorPresentationsIn: d inContext: self ]) startOn: x ] ] ].  self browser when: GLMPaneAdded send: #actOnPaneAdded: to: self.  self browser when: GLMPaneRemoved send: #actOnPaneRemoved: to: self.  self class isStepRefreshEnabled ifTrue: [ self wantsAutomaticRefresh: true.        self wantsSteps: true.        self stepTime: self class stepRefreshRate ]newAcceptButtonFor: aPlayPage  ^self newActionButton     hintTitle: 'Accept';     hintText: 'load saved page into playground';     icon: (self iconNamed: #glamorousAccept);     action: [:b |  self remove.        self announce: #pageAccepted event: aPlayPage ]closeButton: aBrick  closeButton ifNotNil: [ self removeBrick: closeButton ].  closeButton := aBrick.  self themer spotterThemer closeButtonWidgetStyleFor: closeButton.  self themer spotterThemer closeButtonStyleFor: closeButton.  closeButton     hintTitle: 'Close Spotter';     hintText: '<escape>';     action: [ self spotterModel exitDueTo: #actionButton ].  self addBrickBack: closeButtoninitialize  super initialize.  self compositeBrick: self newCompositeBrickdefaultCaseSensitive  ^falseerrorMessage  ^'error obtaining attribute value'layoutAllowedBottom: aBrick  self     translate: aBrick by: (self deltaBottom: aBrick) negated;     increaseZindex: aBrick;     cutAllowedBoundsBottom: aBrickrequestNextStepWith: origin for: anEventType  text := ''.  self pushStep: (self newStep           origin: origin;           event: anEventType;           yourself).  self steps last process: niltriangleBrick: aBrick  triangleBrick := aBrick.  self themer spotterThemer breadcrumbItemTriangleStyleFor: self triangleBrick.  self addBrickBack: self triangleBricknewLabelBrick  self flag: 'find a better number, or at least a better place for the number :)'.  ^GLMLabelBrick new     text: 'Search result with very very long name';     paddingRight: 16users: aSelector  ^self users: aSelector inPackages: self defaultPackagesvariablesIn: composite  ^composite fastTreeTable     useCache;     hasChildren: [:aNode |  aNode key ~= 'self' ];     children: [:aNode |  aNode childrenNodesFor: self ];     icon: [:aNode |  self iconFor: aNode value ];     display: [:anObject |  self variableNodesFor: anObject ];     column: 'Variable' translated evaluated: [:aNode |  GTObjectPrinter asNonTruncatedTextFrom: aNode label ];     column: 'Value' translated evaluated: [:aNode |  | rawValue displayValue |        [ rawValue := aNode rawValue ] on: Error do: [ displayValue := Text string: aNode errorMessage attribute: TextColor red ].        displayValue ifNil: [ GTObjectPrinter asTruncatedTextFrom: rawValue ] ] modified: [:newValue :editedNode :curentPresentation |  self updateVariableNode: editedNode basedOn: newValue.        curentPresentation requestRefresh ];     morphicSelectionAct: [:list |  list selection value browse ] icon: GLMUIThemeExtraIcons glamorousBrowse on: $b entitled: 'Browse' translated;     morphicSelectionAct: [:list |  list selection value inspect ] icon: GLMUIThemeExtraIcons glamorousInspect on: $i entitled: 'Inspect' translated;     dynamicActionsOnSelection: [:presentation |  (presentation rawSelection isKindOf: GTInspectorVariableNode) ifTrue: [ presentation rawSelection inspectorActionsForNode ] ifFalse: [ #() ] ];     selectionAct: [:list |  ((list selection value pointersToExcept: {list selection value}) reject: [:each |  each pointsOnlyWeaklyTo: list selection value ]) inspect ] on: $t entitled: 'Open pointers to' translatedselect: aBlock thenCollect: aBlock2  ^self select: aBlock thenCollect: aBlock2 as: self defaultItemsClassdebugger  ^self owner debuggerannounce: anAnnouncement  self announcer announce: anAnnouncementbreadcrumbSeparatorWidth  ^(self breadcrumbHeight + self outerBorderWidth) / 2 + 4selectedCategory  < return: #GTSpotterProcessor>  ^self selected processoroutOfWorld: aWorld  super outOfWorld: aWorld.  self unsubscribeListeners.  self spotterModel ifNotNil: [:m |  m terminateProcessors ].  focusedMorph ifNotNil: [ focusedMorph takeKeyboardFocus ]matchString  self filter: GTFilterStringMatchwriteToFileSystem  | aFileReference |  aFileReference := self fileReferenceOrNil.  (aFileReference notNil and: [ aFileReference fileSystem isWritable ]) ifTrue: [ aFileReference writeStreamDo: [:stream |  stream                 truncate;                 nextPutAll: self page contentString ] ]save: anObject  self hostObject writeSlot: self slot value: anObjectsetShortcutBrickTextFor: aProcessor  self shortcutBrick text: (ToggleMenuItemShortcut owner: nil keyText: (aProcessor keyBinding printString copyReplaceAll: 'Meta' with: OSPlatform current defaultModifier name)) texttitle: aString  title := aStringsave  self page content isEmpty ifTrue: [ self deleteFromFileSystem ] ifFalse: [ self writeToFileSystem ]defaultOrder  ^10handlesMouseDown: evt  ^trueaddPageIfInteresting: aPage  aPage isInteresting ifFalse: [ ^self ].  self addPage: aPagepresenterAt: aName put: aPresenter  ^self basicPresenters at: aName put: aPresenterpadding  ^5gtDisplayOn: stream  stream     nextPutAll: 'Processor link: ';     nextPutAll: self processor title asStringactLogic: aBlockWithTwoArguments  actBlock := aBlockWithTwoArgumentsshowTriangle  isTriangleVisible := true.  self themer spotterThemer breadcrumbItemTriangleWidgetStyleFor: self triangleBricknewAmountBrick  ^GLMLabelBrick newmatchContext: aContext  ^aContext method isTestMethodactionsForPragmas: aSymbolsCollection  self session interruptedContext ifNil: [ ^#() ].  ^(self allActionsForPragmas: aSymbolsCollection) collect: [:aDebugAction |  aDebugAction asGlamourAction ]contextEvaluatorIn: aComposite  aComposite pharoScript     doItReceiver: [ self debugger selectedContext receiver ];     doItContext: [ self debugger selectedContext ];     smalltalkClass: [ self debugger selectedContext receiver class ];     variableBindings: [ self debugger selectedContext gtDebuggerDoItBindings ];     display: [ String streamContents: [:stream |  stream nextPutAll: (GTSnippets snippetAt: self debugger selectedContext receiver class) ] ];     onChangeOfPort: #text act: [:textPresentation |  GTSnippets snippetAt: self debugger selectedContext receiver class put: textPresentation text asString.        textPresentation clearUserEdits ];     installDefaultSelectionActionsrunCaseManaged  self runCasetestAddTwoCandidateA1A2A3  | link11 link12 link21 link22 link31 link32 category1 category2 category3 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  category3 := candidates addProcessor: GTSpotterA3.  link11 := candidates addCandidate: 11 in: GTSpotterA1.  link12 := candidates addCandidate: 12 in: GTSpotterA1.  link21 := candidates addCandidate: 21 in: GTSpotterA2.  link22 := candidates addCandidate: 22 in: GTSpotterA2.  link31 := candidates addCandidate: 31 in: GTSpotterA3.  link32 := candidates addCandidate: 32 in: GTSpotterA3.  self assert: link11 nextLink equals: link12.  self assert: link11 previousLink equals: link32.  self assert: link12 nextLink equals: link21.  self assert: link12 previousLink equals: link11.  self assert: link21 nextLink equals: link22.  self assert: link21 previousLink equals: link12.  self assert: link22 nextLink equals: link31.  self assert: link22 previousLink equals: link21.  self assert: link31 nextLink equals: link32.  self assert: link31 previousLink equals: link22.  self assert: link32 nextLink equals: link11.  self assert: link32 previousLink equals: link31.  self assert: candidates head equals: link11.  self assert: candidates tail equals: link32.  self assert: category1 headLink equals: link11.  self assert: category1 tailLink equals: link12.  self assert: category2 headLink equals: link21.  self assert: category2 tailLink equals: link22.  self assert: category3 headLink equals: link31.  self assert: category3 tailLink equals: link32onLayoutEvent: aLayoutEvent  super onLayoutEvent: aLayoutEvent.  (aLayoutEvent isKindOf: GLMBrickLayoutStacked) ifTrue: [  ]childrenNodesFor: aVariablesBrowser  < return: #Collection of: #GTInspectorVariableNode>  ^aVariablesBrowser childrenVariableNodesForNode: selfnotifyHideHints  self announce: GTSpotterHideHints newmatchSubstring  self filter: GTFilterSubstringisVisible: aBrick  ^self allowedBounds containsRect: aBrick globalOuterBoundsnewBindingLabel  ^GLMLabelBrick new     hSpaceFill: 50;     vShrinkWrap;     textPosition: #leftCenter;     vAlign: #center;     padding: {0 .         self themer bindingThemer padding}id  ^#gTOpenSelectionDebugActiontearDownMethod  ^self testObject class lookupSelector: #tearDownaddAndSelectAllTags  self allTags do: [:aTag |  self addAndSelectTag: aTag ]defaultAction  ^self class defaultValueexceptionHandler  self flag: 'Bloc -> overrides doesNotUnderstand discarding the current exception context'.  ^GTCurrentSpotterExceptionHandler value ifNil: [ GTSpotterExceptionHandlerNotFound signal ]currentStep  ^currentStep ifNil: [ self hasSteps ifTrue: [ currentStep := self steps last ] ifFalse: [ self newStep origin: self foundationOrigin ] ]event  ^eventtestHistorizingTheSameObjectRemovesPreviousOccurences  | history |  history := OrderedCollection new.  spotter := GTSpotter new history: history.  spotter historize: (GTSpotterCandidateLink new value: 42).  self assert: history size equals: 1.  spotter historize: (GTSpotterCandidateLink new value: 43).  self assert: history size equals: 2.  self assert: history first value equals: 43.  self assert: history last value equals: 42.  spotter historize: (GTSpotterCandidateLink new value: 42).  self assert: history size equals: 2.  self assert: history first value equals: 42.  self assert: history last value equals: 43help  ^'Inspect the currently selected bytecode.'showTriangle  isTriangleVisible := true.  self themer spotterThemer spotterPreviewArrowWidgetStyleFor: self triangleBrick.  self changedbreadcrumbItemTextColor  ^Color whitedecompiledCodeWidgetIn: composite forContext: aContext  ^composite pharoMethod     title: 'Decompiled';     format: [ aContext method codeForNoSource ];     smalltalkClass: [ aContext methodClass ];     doItReceiver: [ aContext receiver ];     doItContext: [ aContext ]actOnPaneAdded: anAnnouncement  (self panes atLast: 2 ifAbsent: [ ^self ]) updateToolbarsupportsDiff  ^assertionContext ifNil: [ false ] ifNotNil: [ assertionContext selector = #assert:equals: ]acceptAction: anAction  label  ^self tempIndexwaitingText  ^'...'generateHashFor: anObject  ^(self basicVariableNodesFor: anObject) inject: anObject gtInspectorHash into: [:hashValue :assoc |  hashValue bitXor: assoc value gtInspectorHash ]amountBrick: aBrick  amountBrick ifNotNil: [ self removeBrick: amountBrick ].  amountBrick := aBrick.  self themer spotterThemer categoryAmountStyleFor: amountBrick.  self addBrickBack: amountBrickitemNameFor: anObject  ^anObject gtDisplayStringdefaultPadding  ^5settingsButtonWidgetStyleFor: aBrick  aBrick     normalImage: (Smalltalk ui icons iconNamed: #glamorousPreferences);     pressedColor: self buttonPressedColorpresenters  ^self basicPresenters valuesplaygroundIcon  ^self iconNamed: #workspacecandidate  ^candidateLink valuetempName  ^tempNameaddCandidate: anObjectOrLink in: aProcessor  | processorLink candidateLink |  processorLink := self getProcessorLink: aProcessor.  candidateLink := anObjectOrLink asSpotterCandidateLink processorLink: processorLink.  candidateLink := processorLink isEmpty ifTrue: [ self privateAddCandidate: candidateLink inEmpty: processorLink ] ifFalse: [ self privateAddCandidate: candidateLink inNotEmpty: processorLink ].  self updateCycleConnectionFor: candidateLink.  self notifyCandidateAdded: candidateLink in: aProcessor.  ^candidateLinktearDownCodeIn: aComposite  aComposite pharoMethod     title: [ self tearDownPresentationTitle ];     format: [ self session tearDownMethod sourceCode ];     smalltalkClass: [ self session testObject class ];     when: [ self session overridesDefaultTearDownMethod ];     doItReceiver: [ self session testObject ]id  ^GTStepToBytecodeDebugAction nameapplyFilterInContext: aSpotterContext  self prepareFilterInContext: aSpotterContext.  ^self applyFilterfileDirectory  ^GTPlayBook cacheDirectoryhelp  ^'Step to a selected bytecode.'snippetAtOrEmpty: anObject  ^self snippets at: anObject ifAbsent: [ '' ]save: aValue  self hostObject at: self index put: aValuesort: aBlockWithTwoArguments  sortBlock := aBlockWithTwoArgumentsdefaultLabel  ^'Cancel'last: anInteger  ^self items last: (self size min: (anInteger max: 0))keyBinding: anObject  keyBinding := anObjectamount  ^amountcurrentBindings  ^self codePresentation currentBindingshandleFatalException: anException  ('[Spotter] Fatal Exception: ' , anException asString) traceCrtestDeploymentHandleException  self assertResetExceptions.  self shouldnt: [ [ 1 / 0 ] on: ZeroDivide do: [:exception |  self assert: (GTSpotterDeploymentExceptionHandlerMock new handleException: exception) notNil ] ] raise: ZeroDivide.  self assertException: ZeroDividekeyword: anObject  keyword := anObjectdefaultPackages  ^{'GT-Spotter' .   'GT-SpotterExtensions-Core'}cache: anObject  cache := anObjectspotterForMessagesFor: aStep  < spotterOrder: 35>  aStep listProcessor     title: 'Messages';     filter: GTNullFilter item: [:filter :context |  GTSelector substring: context textTrimmed filter: filter ];     actLogic: [:each :step |  step exit.        self systemNavigation browseAllImplementorsOf: each name ];     wantsToDisplayOnEmptyQuery: falsedefaultKeymap  ^PharoShortcuts current acceptShortcutfileReferencesBy: aSelector inContext: aSpotterContext usingFilter: aBlock  | split rootDirectory query |  split := aSpotterContext textLowercase piecesCutWhere: [:a :b |  a = FileSystem disk delimiter ].  split size < 1 ifTrue: [ query := aSpotterContext textLowercase.        rootDirectory := FileSystem workingDirectory ] ifFalse: [ split last last = FileSystem disk delimiter ifTrue: [ query := ''.              rootDirectory := aSpotterContext textLowercase asFileReference ] ifFalse: [ query := split last.              rootDirectory := ('' join: split allButLast) asFileReference ] ].  rootDirectory exists ifFalse: [ ^self ].  self flag: 'this is an ugly hack for #queryForFileReference. This iterator has to manipulate the query in order for the filter to work properly'.  aSpotterContext cacheAt: #queryForFileReference put: query.  (rootDirectory perform: aSelector) do: aBlockassertCandidateMatching: aBlock  | candidates |  self assert: currentProcessor notNil.  candidates := currentProcessor allFilteredCandidates select: [:each |  aBlock value: each ].  self denyEmpty: candidates.  self assert: candidates size equals: 1.  currentCandidate := candidates anyOne.  self assert: currentCandidate notNil.  ^currentCandidatekey  ^self indexinitialize  super initialize.  self content: ''.  self creationTime: DateAndTime now.  persistenceStrategies := OrderedCollection with: (GTPlayPageCachePersistence new page: self)overridesDefaultTearDownMethod  ^self tearDownMethod methodClass ~= TestCaseonHidePreview  self triangleBrick renderer border: self themer spotterThemer outerBorderWidth.  self triangleBrick selectedColor: Color transparent.  self changedopenWithFullView  self setDebuggerToFirstNonFilteredContext.  self opencurrentClassOrMetaClass  ^self currentContext methodClassdebuggerClass: aClass  debuggerClass := aClass.  self label: debuggerClass defaultTitlecopy  | link |  link := self class value: self value.  link privateProcessorLink: processorLink.  link privateRenderingProcessorLink: renderingProcessorLink.  link weight: weight.  ^linkbeDebugging  self exceptionHandler: GTSpotterDebuggingExceptionHandler newinitialize  super initialize.  self needsUpdate: falseassertText: aTextualObject do: aBlock  | result |  self shouldnt: [ result := spotter setText: aTextualObject from: self ] raise: Error.  self assert: result.  self deny: spotter hasSteps not.  self denyEmpty: spotter steps.  self shouldnt: [ aBlock value ] raise: ErroritemActionButtonStyleFor: aBrick  aBrick     width: [ (self itemHeight / 1.1) floor ];     vSpaceFill;     margin: #(0 1);     padding: {0 .         self outerBorderWidth}pop  self band layoutAfter: [ self band removeBrick: self items removeLast.        self items size = 1 ifTrue: [ self items first labelBrick paddingLeft: 0 ].        self items isEmpty ifFalse: [ self popSeparator ].        self items do: [:b |  b wrappedBounds markWidthDirty ] ].  self items size = 0 ifTrue: [ self notifyBreadcrumbVisibilityChanged ] ifFalse: [ self items last showTriangle.        self scrollToTheLastOne.        self changed ]amount: anObject  amount := anObjectfoundationOrigin: anObject  foundationOrigin := anObjectisPreviewShown  ^self hasSubbrick: self previewBrickonRevealHints  self themer spotterThemer hintRevealArrowStyleFor: self triangleBrickremove  (self ownerThatIsA: GLMFoundationBrick) ifNotNil: [:o |  o delete ]separators: anObject  separators := anObjectupdatePreviewWith: anObject  | wasNil |  self spotterModel isPreviewVisible ifFalse: [ ^self ].  wasNil := previewObject isNil.  previewObject = anObject ifTrue: [ ^self ].  previewObject := anObject.  previewObject ifNil: [ ^self updatePreviewWithEmpty ].  wasNil ifTrue: [ self updatePreviewWithLoading ].  self asyncTask execute: [:composite :entity |  [ entity spotterPreviewIn: composite inContext: self spotterModel ] on: Error do: [:exception |  self spotterModel exceptionHandler handleException: exception do: [ self handleException: exception forComposite: composite ] ].        composite ] withArguments: {self newCompositeBrick .         anObject} callback: [:composite |  self compositeBrick: composite.        self changed ] priority: Processor userBackgroundPriority delay: 50canDiveIn: aCandidate  | newFakeStep canDiveIn |  canDiveIn := false.  newFakeStep := self spotter newStep origin: self origin.  self spotter addStep: newFakeStep during: [ aCandidate spotterProcessorsFor: newFakeStep.        canDiveIn := newFakeStep processors notEmpty ].  ^canDiveInspotterImplementorsFor: aStep  < spotterOrder: 40>  ^aStep listProcessor     title: 'Implementors';     filter: GTFilterSubstring item: [:filter :context |  self implementors do: filter ];     keyBinding: $m metavariableTag  ^'attribute'initialize  super initialize.  self showScrollBarWhenNeeded: falsereject: aBlock thenCollect: aBlock2 as: aCollectionClass  | collection |  collection := self newAs: aCollectionClass.  self reject: aBlock thenDo: [:each |  collection add: (aBlock2 value: each) ].  ^collectionaddMethod: aCompiledMethod  methods ifNil: [ methods := OrderedCollection new ].  methods add: aCompiledMethodcompose  self title: self defaultPlaygroundTitle.  self titleIcon: self playgroundIcon.  self act: [:b |  b update ] icon: GLMUIThemeExtraIcons glamorousRefresh entitled: 'Update'.  self act: [:b |  HelpBrowser open selectTopicSatisfying: [:each |  each owner notNil and: [ each owner key = GTPlaygroundHelp key and: [ each title = 'Overview' ] ] ] ] icon: GLMUIThemeExtraIcons glamorousHelp entitled: 'Help'.  self act: [:b |  SettingBrowser new           changePackageSet: {(RPackageOrganizer default packageNamed: 'GT-Playground')};           open;           expandAll ] icon: (Smalltalk ui icons iconNamed: #smallCogInitialState) entitled: 'Global Setting'.  self     custom: (GTInspector new           noTitle;           noActions;           wantsAutomaticRefresh: true;           showFirst: [:composite |  self codeIn: composite ];           yourself);     when: GLMBrowserClosing do: [:ann |  self actOnBrowserClosing: ann ].  GTInspector isStepRefreshEnabled ifTrue: [ self wantsAutomaticRefresh: true.        self wantsSteps: true.        self stepTime: GTInspector stepRefreshRate ].  self playgroundActionsIn: selftestSuccessfullTestWithHalt  self assertDebuggerInitializationForContext: [ GTSUnitExampleFailingTest new testWithHalt ] asContext andStepBlock: self stepBlockForTestWithHalt.  self assert: session testContext method equals: GTSUnitExampleFailingTest >> #testWithHalt.  self assert: session assertionContext equals: nil.  self assert: session assertionCallerContext equals: nil.  self deny: session supportsDiff description: 'When there is no assertion no diff is supported'.  self assertDebuggerClosingnotifySearchFinishedFor: aString processors: aCollectionOfProcessors  self announce: (GTSpotterSearchFinished new           query: aString;           processors: aCollectionOfProcessors;           yourself)updatePreviewWithLoading  self compositeBrick: (GLMLabelBrick new           text: 'Loading...';           textPosition: #center;           textColor: Color lightGray;           with: [:b |  b label                 customFont;                 fontSize: 14 ])onKeyProcessor: aProcessor  | searchField newText newTextFragment newSelection oldText oldSelection oldSelectionOffset newSeparator newSeparatorOffset |  aProcessor title isEmptyOrNil ifTrue: [ ^self ].  searchField := [ paneBrick contentsBrick headerBrick searchField ] on: Error do: [ ^self ].  oldText := searchField text asString.  oldSelection := searchField rubric selectionInterval.  oldSelectionOffset := 0.  newTextFragment := '#' , (aProcessor title copyUpTo: Character space).  newSeparatorOffset := 0.  (oldText includesSubstring: newTextFragment caseSensitive: false) ifTrue: [ newSeparatorOffset := -1.        newTextFragment := '' ].  (oldText includesSubstring: '#' caseSensitive: false) ifTrue: [ | oldTextFragmentStart oldTextFragmentStop oldTextFragment |        oldTextFragmentStart := oldText indexOf: $#.        oldTextFragmentStop := oldText indexOf: Character space startingAt: oldTextFragmentStart + 1 ifAbsent: [ oldText size ].        oldTextFragment := (oldText copyFrom: 1 to: oldTextFragmentStart - 1) , (oldText copyFrom: oldTextFragmentStop + 1 to: oldText size).        oldSelectionOffset := 0 - (oldTextFragmentStop - oldTextFragmentStart).        oldText := oldTextFragment ] ifFalse: [ newSeparatorOffset := 1 ].  newSeparator := (newTextFragment isEmpty or: [ (oldText at: 1 ifAbsent: [ nil ]) = Character space ]) ifTrue: [ '' ] ifFalse: [ ' ' ].  newText := newTextFragment , newSeparator , oldText.  newSelection := oldSelectionOffset + newTextFragment size + oldSelection first + newSeparatorOffset to: oldSelectionOffset + newTextFragment size + oldSelection last + newSeparatorOffset.  searchField     text: newText;     selectFrom: newSelection first to: newSelection laststepModel  ^stepModelpreviewBorderWidth  ^self outerBorderWidthselectedColor  ^Color veryVeryLightGray alpha: 0.5executeAction  Smalltalk tools browser openOnClass: self debugger selectedContext methodClass selector: self debugger selectedContext selectornotifyHidePreview  self announce: GTSpotterHidePreview newlowerThreshold  ^lowerThresholdnotifyDiveOut: anObject  self announce: (GTSpotterDiveOut new element: anObject)gtDisplayOn: stream  stream nextPutAll: 'Spotter'newActionButtonBrick  ^GLMHintableActionButtonBrick newonShowPreview  | delta |  self paneBrick isPreviewShown ifTrue: [ ^self ].  delta := (self width * 100 / (100 - self themer spotterThemer previewWidthPercent) - self width) @ 0 / 2.  self bounds: (self bounds expandBy: delta rounded).  self paneBrick showPreview.  self doLayoutitemBrick: anObject  candidateBrick := anObjectopenOn: anObject  ^(super openOn: anObject)     extent: self initialExtent;     title: self session name;     yourselfcollect: aBlock  ^self collect: aBlock as: self defaultItemsClasslabelBrick: aBrick  labelBrick ifNotNil: [ self removeBrick: labelBrick ].  labelBrick := aBrick.  self themer spotterThemer itemLabelStyleFor: labelBrick.  self addBrickBack: labelBrickspotterHistoryFor: aStep  < spotterOrder: 8>  aStep listProcessor     allCandidates: [ self history asArray select: [:each |  each isNotNil and: [ each value isNotNil ] ] ];     title: 'History';     itemName: [:item |  item class = GTSpotterProcessorLink ifTrue: [ item processor itemNameFor: item value ] ifFalse: [ item gtDisplayString ] ];     filter: self defaultFilterClassonStepAdded  self isDropDownPaneVisible ifTrue: [ ^self ].  self showDropDownPanedebuggerTransmissionsIn: browser  super debuggerTransmissionsIn: browser.  browser transmit     from: #stack port: #selection;     to: #bytecode;     andShow: [:composite :aContext |  self bytecodeIn: composite forContext: aContext ]wantsToDisplayOnEmptyQuery: anObject  wantsToDisplayOnEmptyQuery := anObjectonAddedSelector  ^onAddedSelectorbeSelected  self stepModel select: self candidateLinkgtDisplayOn: stream  stream nextPutAll: (self contentString copyReplaceAll: String cr with: String space)indexForItemName: aString andQuery: aQueryString  ^aQueryString isEmpty ifTrue: [ 1 ] ifFalse: [ super indexForItemName: aString andQuery: aQueryString ]matchRegex  self filter: GTFilterRegexhelp  ^'Debug a selected piece of code from the code pane of the debugger.'filteredStack  ^(self session stackOfSize: 50) select: [:aContext |  (aContext method hasPragmaNamed: #debuggerCompleteToSender) not ]updateVariablesForContext  cachedVariables := selfallItemsDo: aBlock  self allItems do: aBlocktestArrayPairsSmall  | pairs |  pairs := (1 to: 10) asArray gtInspectorVariableValuePairs.  self assert: pairs size equals: 10.  (pairs collect: #key) allSatisfy: [:e |  (pairs at: e) = e ]defaultLabel  ^'Inspect it'spotterStyleFor: aBrick  aBrick brickRoot useVerticalLinearLayouttextualDiffIn: composite  ^composite diff     when: [ self session supportsDiff ];     display: [ {self session actualResult gtDebuggerSUnitPrint .         self session expectedResult gtDebuggerSUnitPrint} ]initialize  super initialize.  self codePresentationSelector: #codePresentationinitialize  super initialize.  self needsUpdate: falsebreadcrumbBrick: aBrick  breadcrumbBrick ifNotNil: [ self removeBrick: breadcrumbBrick ].  breadcrumbBrick := aBrick.  breadcrumbBrick announcer when: GTSpotterBreadcrumbVisibilityChanged send: #onBreadcrumbVisibilityChanged to: self.  self themer spotterThemer breadcrumbStyleFor: breadcrumbBrick.  breadcrumbBrick width: [ self paneBrick contentsBrick width ].  breadcrumbBrick layout widthDependency: [ self paneBrick contentsBrick ].  self addBrickBack: breadcrumbBrickcategoryBrickFor: aProcessor  < return: #GTSpotterCategoryBrick>  ^self categories at: aProcessor ifAbsentPut: [ self buildCategoryBrick: aProcessor ]order  ^self category orderprocessor  ^self candidateLink processorbreadcrumbTriangleHeight  ^16cutAllowedBoundsBottom: aBrick  self allowedBounds: (self shrinkBottom: self allowedBounds with: aBrick)initialize  super initialize.  self needsUpdate: falsepushActionButton: aButton  aButton     width: [:b |  b icon width * 1.5 ];     vSpaceFill.  self actionbarBrick addBrickBack: aButton.  self stepModel spotter isShiftPressed ifTrue: [ self themer spotterThemer hintRevealStyleFor: aButton ]onBreadcrumbVisibilityChanged  self changedpageActions  ^(Pragma allNamed: self pageActionPragma from: self class to: Object sortedByArgument: 1) collect: [:eachPragma |  self perform: eachPragma methodSelector ]senders  ^SystemNavigation default allSendersOf: self namehidePreview  self isPreviewShown ifFalse: [ ^self ].  self removeBrick: self previewBrick.  self contentsBrick layout hSpaceFill.  self changedborderWidth  ^1variableTag  ^tag ifNil: [ super variableTag ]handleExceptionsDuring: aBlock  [ GTCurrentSpotterExceptionHandler use: self during: aBlock ] on: self do: [:exception |  [ self handleException: exception ] on: Error do: [:fatalException |  self handleFatalException: fatalException ] ]isMatchedItem: anItem  ^self regex matches: (self itemFilterNameFor: anItem)titleBackgroundColor  ^Color transparentpresentationFilter  < return: #GTInspectorPresentationFilter>  ^presentationFilterdeselect  super deselect.  self hideActionbarcodePresentationSelector  ^codePresentationSelectorfiles  ^self allFilesSorted takeFirst: self pagesLimitsearch  ^searchdefaultNotAvailableText  ^'Preview is not available :('testPlaygroundActionsIn  | actions selector action |  selector := playground class compile: 'mockMethodPlaygrounAction	<playgroundActionOrder: 100>	^ GLMGenericAction new		action: [ :presentation | self inform: ''playground action works'' ];		iconNamed: #abstract;		title: ''A mock playground action''' classified: '*GTMockTests'.  self assert: selector notNil.  window := playground openOn: (GTPlayPage new saveContent: 'a:=1. b:=a+1').  actions := playground playgroundActions.  self denyEmpty: actions.  action := actions detect: [:eachAction |  eachAction title = 'A mock playground action' ].  self deny: action isNilpanes  ^self browser panesspotterPreviewArrowWidgetStyleFor: aBrick  aBrick owner isTriangleVisible ifTrue: [ aBrick color: self previewArrowColor.        aBrick renderer borderColor: self borderColor ] ifFalse: [ aBrick color: Color transparent.        aBrick renderer borderColor: Color transparent ].  GTSpotter isPreviewVisible ifTrue: [ aBrick selectedColor: self borderColor.        aBrick renderer border: 0 ] ifFalse: [ aBrick selectedColor: Color transparent.        aBrick renderer border: self outerBorderWidth ]filter  ^filterformatStackMethodColumnForContext: aContext  ^Text string: (self printStackMethodColumnForContext: aContext) attributes: (self textAttributesForStackEntry: aContext)performSymbol: aSymbol withArguments: aCollection  | time |  time := self timestamp.  Processor yield.  UIManager default defer: [ time = self timestamp ifTrue: [ self receiver perform: aSymbol withEnoughArguments: aCollection ] ]defaultSeparators  ^' 'openOn: aPage  | window |  window := super openOn: aPage.  window extent: self class preferredExtent.  window when: WindowResizing do: [ (window isMinimized or: [ window isMaximized ]) ifFalse: [ self class setPreferredExtentIfWanted: window extent ] ].  ^windowqueryForItem: each  self flag: 'this is an ugly hack for #queryForFileReference. The iterator will manipulate the query being used for each item'.  ^self context cacheAt: #queryForFileReference ifAbsent: [ query ]spotterModel: aModel  spotterModel := aModel.  self searchField morph on: spotterModel.  spotterModel announcer when: GTSpotterCurrentStepChanged send: #onCurrentStepChanged to: self.  self spotterModel announcer when: GTSpotterRevealHints send: #onRevealHints to: self.  self spotterModel announcer when: GTSpotterHideHints send: #onHideHints to: selfonCandidateSelected: ann  self selectedItemBrick: ann itemBrick.  self moveTo: self selectedItemBricksetUp  super setUp.  a := 42headerWidgetStyleFor: aBrick  aBrick color: self backgroundColorspotterStfxFor: aStep  < spotterOrder: 30>  self flag: #specialFilter.  ^aStep listProcessor     title: 'ws.stfx.eu';     filter: GTNullFilter item: [:filter :context |  (context textTrimmed beginsWith: 'http://ws.stfx.eu') ifTrue: [ GTPlayPage loadFromPublishUrl: context textTrimmed thenDo: filter ] ]newCategoryBrick  ^GTSpotterCategoryBrick newensureStashPersistency  (self persistenceStrategies noneSatisfy: [:each |  each isStash ]) ifTrue: [ self persistenceStrategies add: (GTPlayPageStashPersistence new page: self) ]showPreview  self spotterModel showPreviewmaxNumberOfSteps  ^5assertProcessorMatching: aBlock  | processors |  processors := spotter currentStep processors select: [:each |  aBlock value: each ].  self assert: processors notEmpty.  self assert: processors size equals: 1.  currentProcessor := processors anyOne.  self assert: currentProcessor notNil.  ^currentProcessororigin: anObject  origin := anObjectnotifyRevealHints  self announce: GTSpotterRevealHints newcodeActionsPragmas  ^#(codeDebuggingAction)openAndInitialize: aNewDebugger  aNewDebugger color: self color.  aNewDebugger openWithFullView.  aNewDebugger window window     position: self window position;     extent: self window extent.  ^aNewDebuggeronDo: anObject  onDo := anObjectsetUpCodeIn: aComposite  aComposite pharoMethod     title: [ self setUpPresentationTitle ];     format: [ self session setUpMethod sourceCode ];     smalltalkClass: [ self session testObject class ];     when: [ self session overridesDefaultSetUpMethod ];     doItReceiver: [ self session testObject ]urlProvider  ^urlProvider ifNil: [ urlProvider := self class urlProvider ]browseClassRefs  self currentContext ifNotNil: [:aContext |  | class |        class := aContext methodClass instanceSide.        class isTrait ifTrue: [ self systemNavigation browseAllUsersOfTrait: class ] ifFalse: [ self systemNavigation browseAllCallsOnClass: class ] ]intermediaryCheckWithFailure  40 + 2.  self checkWithFailurepresenterAt: aName ifAbsent: aBlock  ^self basicPresenters at: aName ifAbsent: [ [ self readSlotNamed: aName ] on: SlotNotFound do: aBlock ]title  ^super title ifNil: [ self class defaultTitle ] ifNotNil: [:aString |  aString ]concreteMethodsInContext: aContext usingFilter: aFilter  | classAndSelectorStrings class selector |  classAndSelectorStrings := (aContext textTrimmed splitOn: '>>') collect: [:each |  each trimBoth ].  classAndSelectorStrings size = 2 ifFalse: [ ^self ].  classAndSelectorStrings second size < 2 ifTrue: [ ^self ].  selector := classAndSelectorStrings second first = $# ifTrue: [ classAndSelectorStrings second allButFirst asSymbol ] ifFalse: [ classAndSelectorStrings second asSymbol ].  (class := Smalltalk classNamed: classAndSelectorStrings first) ifNil: [ SystemNavigation default allBehaviorsDo: [:aClass |  aClass methodsDo: [:method |  method selector = selector ifTrue: [ aFilter value: method ] ] ].        ^self ].  class withAllSuperclassesDo: [:aClass |  aFilter value: ([ aClass compiledMethodAt: selector ] on: Error do: [ ^self ]) ]searchFieldFontSize  ^15spotterModel: aModel  spotterModel := aModel.  self headerBrick spotterModel: spotterModel.  spotterModel steps isEmpty ifFalse: [ spotterModel currentStep hasCandidates ifTrue: [ self showDropDownPane ] ].  spotterModel announcer when: GTSpotterStepAdded send: #onStepAdded to: selfindex  ^indexsingleClick: evt  self stepModel select: self candidateLink dueTo: #singleClickonCandidateAdded  (self hasSelected or: [ self candidates isEmpty ]) ifFalse: [ self selectFirst ]items: aBlock  allCandidatesBlock := aBlockrender: aBrick on: aCanvas  super renderBackgroundColorOf: aBrick on: aCanvas.  self renderArrow: aBrick on: aCanvastestDebugger  self assertDebuggerInitializationForContext: [ 20 factorial ] asContext andStepBlock: [:aProcess |   ].  self assertDebuggerClosingtestgroupedAndSortedSpotterExtensions  | res |  res := GTSpotterExtensionSettings groupedAndSortedSpotterExtensions.  self assert: res class equals: SortedCollection.  self assert: (res allSatisfy: [:ass |  ass value allSatisfy: [:g |  g class = RGMethodDefinition ] ])defaultStep  ^GTSpotterStep newprivateRenderingProcessorLink: aLink  renderingProcessorLink := aLinksignatureFor: aMethod  ^{aMethod methodClass .   aMethod selector}scrollbarColor  ^Color black alpha: 0.5testDebuggingExceptionHandlerMock3  self shouldRaise: ZeroDivide process: 'abc' origin: GTSpotterExceptionMock3 newopenFullDebugger  | currentDebugger |  currentDebugger := self debugger.  debugger := nil.  self close.  currentDebugger openWithFullViewquery: anObject  query := anObjectfileReference  self fileDirectory ifNil: [ ^nil ].  ^self fileDirectory / self fileNamecontinuing: anObject  continuing := anObjecthasSelected  ^self hasSteps and: [ self currentStep hasSelected ]inspectorPragmaKey  ^#gtInspectorPresentationOrder:candidateLink: anObject  candidateLink := anObjectaddAllCandidates: aCollection in: aProcessor  | allLinks |  allLinks := OrderedCollection new.  aCollection do: [:each |  | processorLink candidateLink |        processorLink := self getProcessorLink: aProcessor.        candidateLink := each asSpotterCandidateLink processorLink: processorLink.        candidateLink := processorLink isEmpty ifTrue: [ self privateAddCandidate: candidateLink inEmpty: processorLink ] ifFalse: [ self privateAddCandidate: candidateLink inNotEmpty: processorLink ].        self updateCycleConnectionFor: candidateLink.        allLinks add: candidateLink ].  self announcer announce: (GTSpotterAllCandidatesAdded new           candidateLinks: allLinks;           category: aProcessor;           yourself)debuggerToTest  self subclassResponsibilityaddAllTags  self allTags do: [:aTag |  self addTag: allTags ]variableTag: aTag  tag := aTagtail  ^self candidates tailon: aBindingsCollection  | model |  model := GLMBrickListModel new on: aBindingsCollection.  model morphAtLogic: [:index |  self newBindingRow: (model origin at: index) in: model origin ].  self model: modeldefaultLabel  ^'Do it and go'overridesDefaultSetOrTearMethods  ^self overridesDefaultTearDownMethod or: [ self overridesDefaultSetUpMethod ]testPreviousA1Category  | link11 link12 link13 category1 |  category1 := candidates addProcessor: GTSpotterA1.  link11 := candidates addCandidate: 11 in: GTSpotterA1.  link12 := candidates addCandidate: 12 in: GTSpotterA1.  link13 := candidates addCandidate: 13 in: GTSpotterA1.  self assert: category1 equals: (candidates previousProcessorLinkOf: category1)iconBrick: aBrick  iconBrick ifNotNil: [ self removeBrick: iconBrick ].  iconBrick := aBrick.  self themer spotterThemer itemIconStyleFor: iconBrick.  self addBrickBack: iconBrickexecuteAction  self codePresentation printSelectionshouldDisplayPresentationCreatedBy: aMethod  self subclassResponsibilityinitialize  self flag: 'error handling'.  self pages: self defaultPages.  self files do: [:each |  [ self pages add: (GTPlayPage fromFileReference: each) ] on: Error do: [  ] ]symbolicBytecodeForCurrentPCFrom: aContext  | pc |  pc := aContext pc.  ^aContext method symbolicBytecodes detect: [:each |  each offset = pc ] ifNone: [ nil ]playgroundActionsIn: aGTPlayground  self playgroundActions do: [:eachAction |  aGTPlayground addAction: eachAction ]isEmptyOrNil  ^self items isEmptyOrNilitems  ^items ifNil: [ items := self defaultItems.        self itemDo: [:each |  items add: each ] ]id  ^#gTExecuteSelectionDebugActionhasDynamicItems  ^allCandidatesBlock hasDynamicItemsbasicSearch: aString  self flag: '#currentStep should be made more stable. This will fail for an empty, uninitialized spotter / but after multiple diveIn/diveOut it will be ok - inconsistent'.  self assert: spotter currentStep identicalTo: spotter currentStep.  previousStep := spotter currentStep.  previousContext := previousStep context.  self shouldnt: [ spotter setText: aString from: nil ] raise: Error.  currentStep := spotter currentStep.  currentContext := spotter currentStep context.  self assert: previousStep identicalTo: currentStepprepareFilterInContext: aSpotterContext  super prepareFilterInContext: aSpotterContext.  lowerThreshold ifNil: [ lowerThreshold := self defaultLowerThreshold ].  upperThreshold ifNil: [ upperThreshold := self defaultUpperThreshold ]headerBrick: aBrick  headerBrick ifNotNil: [ self removeBrick: headerBrick ].  headerBrick := aBrick.  self themer spotterThemer headerStyleFor: headerBrick.  self addBrickBack: headerBrickselectionIntervalForPane: aSymbol  ^((self browser paneNamed: aSymbol) port: #selectionInterval) value ifNil: [ ^1 to: 0 ]appliesToDebugger: aDebugger  ^(aDebugger session isContextPostMortem: aDebugger currentContext) not and: [ aDebugger bytecodePresentation selection offset > aDebugger currentContext pc ]select: aBlock thenCollect: aBlock2 as: aCollectionClass  | collection |  collection := self newAs: aCollectionClass.  self select: aBlock thenDo: [:each |  collection add: (aBlock2 value: each) ].  ^collectionfileDirectory  ^self subclassResponsibilityselected  ^selectedvariableTag: aTag  tag := aTaghelpButtonWidgetStyleFor: aBrick  aBrick     normalImage: GLMUIThemeExtraIcons glamorousHelp;     pressedColor: self buttonPressedColorstepBlockForTestArrays  ^[:aProcess |  aProcess     completeStep: aProcess suspendedContext;     completeStep: aProcess suspendedContext;     step;     completeStep: aProcess suspendedContext;     completeStep: aProcess suspendedContext;     completeStep: aProcess suspendedContext;     step ]layoutStacked: aBrick in: newBounds  | origStackedBricks stackedBricks forward stackedTopBricks stackedBottomBricks stackedTopHeight stackedBottomHeight |  self flag: 'refactor me'.  self allowedBounds: newBounds.  stackedBricks := self gatherStacked: aBrick.  origStackedBricks := DoubleLinkedList new.  origStackedBricks addAll: stackedBricks.  forward := true.  stackedTopHeight := 0.  stackedBottomHeight := 0.  stackedTopBricks := OrderedCollection new.  stackedBottomBricks := OrderedCollection new.  [ stackedBricks isEmpty not & forward ] whileTrue: [ | brick |        brick := stackedBricks removeFirst value.        (self isVisible: brick) ifFalse: [ (self isAbove: brick) ifTrue: [ | delta |                    delta := (self deltaTop: brick) - stackedTopHeight.                    brick translateX: delta negated.                    self increaseZindex: brick.                    stackedTopBricks isEmpty ifTrue: [ stackedTopHeight := stackedTopHeight + brick globalOuterBounds height.                          self cutAllowedBoundsTop: brick ].                    stackedTopBricks add: brick ] ifFalse: [ forward := false.                    stackedBricks addFirst: brick ] ] ifTrue: [ (self isPartiallyVisibleAbove: brick) ifTrue: [ self layoutAllowedTop: brick ] ifFalse: [ forward := false.                    self decreaseZindex: brick.                    stackedBricks addFirst: brick ] ] ].  [ stackedBricks isEmpty not ] whileTrue: [ | brick |        brick := stackedBricks removeLast value.        (self isVisible: brick) ifFalse: [ | delta |              delta := (self deltaBottom: brick) - stackedBottomHeight.              brick translateX: delta negated.              self increaseZindex: brick.              stackedBottomBricks isEmpty ifTrue: [ stackedBottomHeight := stackedBottomHeight + brick globalOuterBounds height.                    self cutAllowedBoundsBottom: brick ].              stackedBottomBricks add: brick ] ifTrue: [ (self isFullyVisible: brick) ifFalse: [ self layoutAllowedBottom: brick ] ifTrue: [ self decreaseZindex: brick ] ] ].  self layoutProportional: stackedTopBricks reverse in: aBrick position: #top.  self layoutProportional: stackedBottomBricks reverse in: aBrick position: #bottom.  ^allowedBoundsselectedVariableForContext: aContext  ^(self variablesFromContext: aContext) detect: [:each |  each key = self debugger selectedVariableName ] ifNone: [ cachedVariables detect: [:each |  each key = 'self' ] ifNone: [ nil ] ]testArrayPairsUnderLimit  | limit pairs |  limit := 2 * GTInspector indexableDisplayLimit - 1.  pairs := (1 to: limit) asArray gtInspectorVariableValuePairs.  self assert: pairs size equals: limit.  (pairs collect: #key) allSatisfy: [:e |  (pairs at: e) = e ].  self assert: (pairs collect: #key) equals: (1 to: limit) asOrderedCollectionclick: evt  super click: evt.  self stepModel spotter popUntil: self stepModel.  ^truetestNextA1A2EmptyCategory  | link11 link12 link13 category1 category2 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  link11 := candidates addCandidate: 11 in: GTSpotterA1.  link12 := candidates addCandidate: 12 in: GTSpotterA1.  link13 := candidates addCandidate: 13 in: GTSpotterA1.  self assert: category1 equals: (candidates nextProcessorLinkOf: category1).  self assert: category1 equals: (candidates nextProcessorLinkOf: category2)defaultOrder  ^100sourceOf: method for: object in: composite  ^composite pharoMethod     display: [:m |  m sourceCode ];     smalltalkClass: [:m |  m methodClass ];     doItReceiver: [ object ];     selectionPopulate: #evaluatedObject on: $g entitled: 'Do it and go' with: [:text |  Smalltalk compiler           receiver: object;           evaluate: text selectedText ];     installDefaultSelectionActions;     selectionAct: [:text |  self updateOuterPaneFrom: text for: method ] icon: GLMUIThemeExtraIcons glamorousAccept on: $s entitled: 'Accept'evaluateExpressionInContext: aSpotterContext usingFilter: filter  | result |  (Number withAllSubclasses anySatisfy: [:class |  class selectors anySatisfy: [:selector |  aSpotterContext textTrimmed includesSubstring: selector caseSensitive: true ] ]) ifFalse: [ ^self ].  Smalltalk compiler silentlyDo: [ result := Smalltalk compiler evaluate: aSpotterContext textTrimmed ] exceptionDo: [ ^self ].  result isNumber ifFalse: [ ^self ].  filter value: result.  (result isFraction and: [ result isInteger not ]) ifTrue: [ filter value: result asFloat ]selectedContext  ^((self browser paneNamed: #stack) port: #selection) valuetempName: aString  tempName := aStringpageActionPragma  ^#pageActionOrder:computeAllItemsIn: aContext  ^OrderedCollection newcompositeBrick: aBrick  self compositeBrick ifNotNil: [ self removeBrick: self compositeBrick ].  compositeBrick := aBrick.  self themer spotterThemer spotterPreviewCompositeStyleFor: self compositeBrick.  self addBrickBack: self compositeBrick.  self doLayoutForcelabel  ^self key asStringname  ^nametitleTextColor  ^self backgroundColor muchLighterhasPreviousStep  < return: #Boolean>  ^self spotter hasSteps and: [ self spotter steps first ~= self ]currentContext  ^self selectedContext ifNil: [ self interruptedContext ] ifNotNil: [ self selectedContext ]isContinuing  ^self continuing and: [ self streamed isEmptyOrNil not and: [ self canContinue ] ]searchFieldStyleFor: aBrick  aBrick     beCentered;     hSpaceFill;     vSpaceFill;     withoutMargins;     withoutAdornment;     withoutBorder;     beTransparent;     withGhostText: self spotterGhostText;     autoAccept: true;     marginLeft: self searchFieldMarginLeft;     rubricTextFamilyName: self searchFieldFamilyName;     rubricTextFontSize: self searchFieldFontSize.  aBrick rubric ghostTextRuler fontName: self searchFieldFamilyName pointSize: self searchFieldFontSizetestObject  ^testContext receivertext  ^self currentTextonCandidatesAmountChanged: ann  | categoryMorph |  categoryMorph := self categoryBrickOf: ann category.  categoryMorph setAmountVisible: categoryMorph submorphs size all: ann amountupperThreshold  ^upperThresholdinitialize  super initialize.  self themer: self themer spotterThemer themer.  self initializeListeners.  self themer spotterThemer spotterStyleFor: self.  self breadcrumbBrick: self newBreadcrumbBrick.  self paneBrick: self newPaneBrickitemDo: aBlock  self subclassResponsibilitydebugger: anObject  debugger := anObjectwantsToDisplayOnEmptyQuery  ^wantsToDisplayOnEmptyQuery ifNil: [ super wantsToDisplayOnEmptyQuery ]removeBinding: anAssociation  | bindings |  bindings := self currentBindings copy.  bindings removeKey: anAssociation key ifAbsent: [  ].  self setBindings: bindingsdebuggerTransmissionsIn: browser  self subclassResponsibilitydefaultKeymap  ^PharoShortcuts current debugItShortcutisEmpty  ^self headLink isNiltitle  ^'undefined'layout  | row |  row := SpBoxLayout newHorizontal.  self basicPresenters keysDo: [:id |  row add: id ].  ^rowdefaultLabel  ^'Step to bytecode'newRow  ^GLMInteractableBrick new     enable;     selectedColor: self themer bindingThemer selectedColor;     vShrinkWrap;     hSpaceFill;     padding: {self themer bindingThemer padding .         0 .         (self themer bindingThemer padding + self themer bindingThemer borderWidth)};     borderColor: self themer bindingThemer borderColorfilter: aGTFilterOrBlockWithOneArgument  filterBlock := aGTFilterOrBlockWithOneArgumentpreDebuggingActions  ^(self session class debuggingActionsForPragmas: {#preDebuggingAction} for: self debugger) do: [:each |  each preDebugWindow: self owner ]cutAllowedBoundsTop: aBrick  self allowedBounds: (self shrinkTop: self allowedBounds with: aBrick)updateCycleConnectionFor: aCandidateLink  self candidates tail = aCandidateLink ifTrue: [ aCandidateLink nextLink: self candidates head.        self candidates head previousLink: aCandidateLink ].  self candidates head = aCandidateLink ifTrue: [ aCandidateLink previousLink: self candidates tail.        self candidates tail nextLink: aCandidateLink ]onRevealHints  self visible ifFalse: [ ^self ].  self themer spotterThemer hintRevealStyleFor: self diveInButton.  self themer spotterThemer hintRevealStyleFor: self actOnButtontestRemoveCandidatesA1A3FromA1A2A3  | link21 link22 link23 category1 category2 category3 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  category3 := candidates addProcessor: GTSpotterA3.  candidates addCandidate: 11 in: GTSpotterA1.  candidates addCandidate: 12 in: GTSpotterA1.  candidates addCandidate: 13 in: GTSpotterA1.  link21 := candidates addCandidate: 21 in: GTSpotterA2.  link22 := candidates addCandidate: 22 in: GTSpotterA2.  link23 := candidates addCandidate: 23 in: GTSpotterA2.  candidates addCandidate: 31 in: GTSpotterA3.  candidates addCandidate: 32 in: GTSpotterA3.  candidates addCandidate: 33 in: GTSpotterA3.  candidates removeAllCandidatesOf: GTSpotterA1.  candidates removeAllCandidatesOf: GTSpotterA3.  self assert: link21 nextLink equals: link22.  self assert: link21 previousLink equals: link23.  self assert: link22 nextLink equals: link23.  self assert: link22 previousLink equals: link21.  self assert: link23 nextLink equals: link21.  self assert: link23 previousLink equals: link22.  self assert: candidates head equals: link21.  self assert: candidates tail equals: link23.  self assert: category1 headLink equals: nil.  self assert: category1 tailLink equals: nil.  self assert: category2 headLink equals: link21.  self assert: category2 tailLink equals: link23.  self assert: category3 headLink equals: nil.  self assert: category3 tailLink equals: nilprocessorLink: anObject  processorLink ifNil: [ self renderingProcessor: anObject ].  processorLink := anObjectcategoryAmountWidgetStyleFor: aBrick  aBrick     textColor: self titleTextColor;     color: self titleBackgroundColornewTitleBrick  ^GTSpotterCategoryTitleBrick newerrorMessage  ^'error obtaining indexed attribute value'hasFilteredCandidates  ^self allFilteredCandidates notEmptyinitialize  super initialize.  self needsUpdate: falsedetect: aBlock  ^self detect: aBlock ifNone: [ NotFound signalFor: aBlock ]onAllCandidatesRemoved  self selectedItemBrick: nilgtListFilter  ^selfactOnBrowserClosing: ann  self session ifNotNil: [:aSession |  aSession terminate ]debug: aContext using: aDebuggerClass  | currentSession newDebugger |  currentSession := self session.  self detachSession.  self browser close.  currentSession updateContextTo: aContext.  newDebugger := aDebuggerClass on: (aDebuggerClass spanNewSessionFrom: currentSession).  ^self openAndInitialize: newDebuggerprintSignature: aSignature  ^aSignature first name , '>>' , aSignature second asStringpagesLimit: anObject  pagesLimit := anObjectfilter  ^filterBlockhideTriangle  isTriangleVisible := false.  self themer spotterThemer spotterPreviewArrowWidgetStyleFor: self triangleBrick.  self changedcurrentText  ^self current ifNil: [ '' ] ifNotNil: [ self current text ]diveOut  self spotterModelDo: [ self spotterModel popStep ]spotterPreviewWidgetStyleFor: aBrick  aBrick     borderColor: self borderColor;     color: self backgroundColorvalue  ^[ self rawValue ] on: Error do: [ nil ]asOrderedCollection  ^self items copyexit  self spotter exitacceptContents: aString  ^(self entity acceptContents: aString) ifTrue: [ self update.        true ]autoHide  ^autoHide ifNil: [ autoHide := true ]context: aGTSpotterContext  context := aGTSpotterContextactOnInspectorPaneRemoved: ann  inspectIcon  ^GLMUIThemeExtraIcons glamorousInspecttestFailingText  self assert: 'I like pie  pizza pie apple pie rad squared pi and other PIes' equals: 'I like pie  pizza pie potato pie rad squared pi and other PIes'notifyAllCandidatesRemoved  self announcer announce: GTSpotterAllCandidatesRemoved newvariableTag  ^'implicit'renderTopTriangle: aBrick on: aCanvas  | a b c width height |  width := aBrick brickBounds width.  height := aBrick brickBounds height.  a := aBrick brickBounds bottomLeft + ((width / 2 - height max: 0) @ 0).  b := aBrick brickBounds bottomLeft + ((width / 2 + height min: width) @ 0).  c := aBrick brickBounds topLeft + ((width / 2) @ 0).  self renderTriangle: aBrick on: aCanvas with: {a asIntegerPoint .         b asIntegerPoint .         c asIntegerPoint}categoryBrickOf: aProcessor ifAbsent: aBlock  < return: #GTSpotterCategoryBrick>  ^self categories at: aProcessor ifAbsent: aBlockdefaultLabel  ^'Go and inspect'eventType: anObject  eventType := anObjecthandleException: anException with: anObject  ^self handleException: anException do: [ anObject ]popSeparator  self band removeBrick: self band lastSubbrickperformSymbol: aSymbol withArguments: aCollection  self receiver perform: aSymbol withEnoughArguments: aCollectionhideActionsOf: aRowBrick  aRowBrick subbricks select: [:each |  each isKindOf: GLMHintableActionButtonBrick ] thenDo: [:each |  each visible: false ]assertProcessorByTitle: aString  ^self assertProcessorMatching: [:processor |  processor title = aString ]itemLabelStyleFor: aBrick  aBrick label highlightingLogic: [:aCanvas :aRectangle |  | bounds |        bounds := aRectangle translateBy: -3 @ 0.        aCanvas line: bounds bottomLeft to: bounds bottomRight width: 1 color: Color lightGray ].  aBrick     hSpaceFill;     vSpaceFill;     marginRight: self outerBorderWidthallItemsIn: aContext  ^allCandidates ifNil: [ allCandidates := (self computeAllItemsIn: aContext) copy ]textTrimmed  ^textTrimmed ifNil: [ textTrimmed := self defaultTextTrimmed ]browseInstVarRefs  | cls |  cls := self currentClassOrMetaClass.  (cls notNil and: [ cls isTrait not ]) ifTrue: [ self systemNavigation browseInstVarRefs: cls ]addItem: aBrick  aBrick width: [:itemBrick |  self calculateItemWidth: itemBrick ].  aBrick layout widthDependency: self.  self items size = 1 ifTrue: [ self items first labelBrick paddingLeft: self themer spotterThemer breadcrumbSeparatorWidth / 2 ].  self items addLast: aBrick.  self band addBrickBack: aBrick.  self items do: [:b |  b wrappedBounds markWidthDirty ].  self band doLayoutForcetestAddCategories  | categories |  categories := {GTSpotterA1 .   GTSpotterA2 .   GTSpotterA3}.  self addCategories: categories.  self assert: (self hasCategories: categories)processors  ^processors ifNil: [ processors := OrderedCollection new.        self origin spotterProcessorsFor: self.        processors do: [:each |  self candidates addProcessor: each ].        processors ]defaultExceptionHandler  ^GTSpotterDebuggingExceptionHandler neweventType  ^eventTypetestInstanceCreation  self assert: spotter notNil.  self assertEmpty: spotter steps.  self deny: spotter hasMultipleStepsinspectorIn: aComposite  (self textualDiffIn: aComposite) title: 'Diff (actual vs. expected)'.  (self inspectorDiffIn: aComposite) title: 'Objects (actual vs. expected)'.  super inspectorIn: aComposite.  self session supportsDiff ifTrue: [ aComposite last title: 'Inspector' ]browseClassVariables  | cls |  cls := self currentClass.  (cls notNil and: [ cls isTrait not ]) ifTrue: [ self systemNavigation browseClassVariables: cls ]setUpPresentationTitle  ^'SetUp' , (self session setUpMethod methodClass ~= self session testContext methodClass ifTrue: [ ' (' , self session setUpMethod methodClass name , ')' ] ifFalse: [ '' ])onThemerChanged  super onThemerChanged.  self themer spotterThemer headerWidgetStyleFor: self.  self themer spotterThemer closeButtonWidgetStyleFor: self closeButton.  self themer spotterThemer searchFieldWidgetStyleFor: self searchField.  self class environment at: #GTEventRecorderSettings ifPresent: [ self themer spotterThemer settingsButtonWidgetStyleFor: self settingsButton ]on: aStepModel category: aProcessor  self stepModel: aStepModel.  self category: aProcessordefaultContinuing  ^falseuncheck  super uncheck.  self hideActionbarremoveAllCandidates  self performSymbol: #removeAllCandidates withArguments: {}.  Processor yieldentities  ^self panes collect: [:each |  (each port: #entity) value ]eventType  ^eventTypenotifyBreadcrumbVisibilityChanged  self announcer announce: GTSpotterBreadcrumbVisibilityChanged newaddObject: anObject inProcessor: aProcessor  objects add: anObjectprivateAddCandidate: aCandidateLink weightedInFull: aProcessorLink  key  ^labelconfigurationBlockForProcessorsCreatedBy: aMethod  ^[:processor |   ]allowProcessorsFrom: aMethod configuredWith: aBlock  self allowProcessorsFrom: aMethod.  configurationBlocks at: aMethod printString put: aBlockitemBrick  ^candidateBricknewTriangleBrick  ^GLMBrick newiconBrick  ^iconBrickchangeFilterRequestFor: aGTInspector  requestRefresh  self updateToolbar.  self refreshPaneselement  ^elementremoveSessionSilently  (self browser pane port: #entity) silentValue: niltitleBrick: aBrick  titleBrick := aBrickallCandidates: aBlockWithOneArgument  self items: aBlockWithOneArgumentnewDebugger  ^newDebuggerupdatePreviewWithEmpty  self removeAllBricks.  self asyncTask execute: [ | emptyBrick |        emptyBrick := GLMLabelBrick new           text: self defaultNotAvailableText;           textPosition: #center;           textColor: Color lightGray;           with: [:b |  b label                 customFont;                 fontSize: 14 ] ] withArguments: {} callback: [:brick |  self compositeBrick: brick ] priority: Processor userBackgroundPriority delay: 50inspectorActionsForNode  ^self hostObject inspectorActionsForNodemockProcessorFor: aSpotterStep  < spotterOrder: 1>  aSpotterStep listProcessor     allCandidates: [ nil ];     itemName: [:item |  item asString ];     filter: GTFilterSubstringdropDownBrick  ^dropDownBrickinspectSubInstances  self currentClassOrMetaClass ifNotNil: [:aClass |  aClass instanceSide inspectSubInstances ]isVisible  ^self items isEmpty notstepModel: aModel  stepModel := aModel.  stepModel announcer when: GTSpotterSelectedCandidateChanged send: #onSelectedChanged: to: self.  stepModel spotter announcer when: GTSpotterStepPopped send: #onStepPopped to: self.  self actionbarBrick stepModel: aModel.  self     highlightQuery;     checkOrUncheckdefaultLabel  ^'Print it'labelBrick: aBrick  labelBrick := aBrick.  self themer spotterThemer breadcrumbItemLabelStyleFor: self labelBrick.  self addBrickBack: self labelBrickexecuteAction  newDebugger := self debugger debug: self interruptedContext using: debuggerClasschangeFilterRequestFor: aGTInspector  self openListChooseLabeled: 'All available presentations' forInspector: aGTInspector with: allMethodSignatures select: selectedMethodSignatures format: [:aSignature |  self printSignature: aSignature ] actionSelector: #replaceSelectedSignaturesWith:in:testInitialText  self flag: 'is this instvar still required ? we have context'.  self assert: spotter getText isEmptyOrNil.  self assert: spotter text isEmptyOrNilisFirst  ^(self previousLink processorLink = self processorLink) notselected  < return: #GTSpotterCandidateLink>  self assert: [ selected isNotNil ] description: [ 'Selected candidate can not be accessed where there is no one' ].  ^selectedshouldDisplayPresentationCreatedBy: aMethod  ^selectedMethodSignatures anySatisfy: [:aSignature |  aSignature first = aMethod methodClass and: [ aSignature second = aMethod selector ] ]browseMethodFull  self currentClassOrMetaClass ifNotNil: [ Smalltalk tools browser openOnClass: self currentClassOrMetaClass selector: self currentMessageName ]candidateLink  ^candidateLinkon: aGTPlayBook  | model |  model := GLMBrickListModel new on: aGTPlayBook pages.  model morphAtLogic: [:index |  self newPageRow: (model origin at: index) in: aGTPlayBook ].  self model: modelnotifyStepPopped  self announce: GTSpotterStepPopped newnewRemoveButtonFor: anAssociation  ^self newActionButton     beError;     hintTitle: 'Remove binding';     hintText: 'will unassign variable';     icon: self themer bindingThemer removeIcon;     action: [:b |  b owner disable.        GLMAnimation swipeLeft           onCompleted: [ self announce: #bindingRemoved event: anAssociation.              self model origin remove: anAssociation.              self invalidate ];           animate: b owner ]addObjects: aCollection inProcessor: aProcessor  self performSymbol: #addAllCandidates:in: withArguments: {aCollection .         aProcessor}.  Processor yieldget: url  | contents |  contents := self httpClient get: url.  ^String new: contents size streamContents: [:stream |  contents linesDo: [:each |  stream                 nextPutAll: each;                 cr ] ]notifyCandidateAdded: aCandidateLink in: aProcessor  self announcer announce: (GTSpotterCandidateAdded new           candidateLink: aCandidateLink;           category: aProcessor;           yourself)removeLastPane  | lastPane |  lastPane := self panes last.  self browser removeLastPane.  self browser announce: (GLMPaneRemoved pane: lastPane fromBrowser: self browser)notifyContextChangedFrom: aPreviousContext to: aCurrentContext  self announce: (GTSpotterContextChanged new           previous: aPreviousContext;           current: aCurrentContext;           yourself)emptyTextColor  ^self themer textLightColor< anotherCandidateLink  ^self weight < anotherCandidateLink weightselectPreviousCategory  self spotterModel hasSelected ifTrue: [ self spotterModel currentStep selectPreviousCategory ]spotterPreviewArrowStyleFor: aBrick  aBrick     hSpaceFill;     renderer: (GTSpotterTriangleRenderer new orientation: #right);     height: [ (self previewArrowWidth - self previewArrowGapHack) * 2 ]spotterContentsStyleFor: aBrick  aBrick     useVerticalLinearLayout;     borderWidth: self outerBorderWidth;     padding: self outerBorderWidth;     hSpaceFill;     vSpaceFill.  aBrick layout zIndex: 2spotterPreviewCompositeStyleFor: aBrick  aBrick     hSpaceFill;     vSpaceFill;     margin: self previewBorderWidth;     paddingLeft: self previewPaddingLefttempIndex: anObject  tempIndex := anObjectaddItem: anItem  self addBrickBack: anItemreject: aBlock  ^self reject: aBlock as: self defaultItemsClassdebugger  ^debuggerinitialize  super initialize.  categories := Dictionary new.  self band hSpaceFill.  self announcer when: GLMBrickScrollPositionChanged send: #onScrolled to: selfspotterForRepositoriesFor: aStep  < spotterOrder: 87>  aStep listProcessor     title: 'Monticello Repositories';     allCandidates: [ MCRepositoryGroup default repositories ];     itemIcon: #systemIcon;     wantsToDisplayOnEmptyQuery: false;     filter: self defaultFilterClasscontext  ^self currenttestContextNodes  | pairs x tempVariables indexVariables instVariables |  x := 42.  pairs := OrderedCollection new.  [:y |  y + 1 + x ] asContext gtInspectorVariableNodesIn: pairs.  pairs := pairs withIndexCollect: [:e :i |  i -> e ].  tempVariables := pairs select: [:e |  e value label beginsWith: '[' ].  indexVariables := pairs select: [:e |  e value key isInteger ].  instVariables := pairs select: [:e |  e value isKindOf: GTInspectorSlotNode ].  self assert: tempVariables sort last key < indexVariables first key.  self assert: indexVariables sort last key < instVariables first keyurlProvider: anUrlObject  urlProvider := anUrlObject asZnUrldefaultBreadcrumbHeight  ^self themer spotterThemer breadcrumbHeight + self themer spotterThemer breadcrumbTriangleHeighttitle: aString  title := aStringhttpClient  ^ZnClient new     systemPolicy;     beOneShot;     accept: ZnMimeType textPlain;     url: self urlProvider;     yourselfonUnhovered  (self stepModel isCategorySelected: self category) ifFalse: [ self hideActionbar ]defaultPlaygroundTitle  ^'Playground'privacyAgreementNotificationStyleFor: aBrick  | color |  color := aBrick sendUsageData ifTrue: [ self privacyAgreementIsSendingDataColor ] ifFalse: [ self privacyAgreementIsNotSendingDataColor ].  aBrick messageBrick rubricTextFamilyName: StandardFonts defaultFont familyName.  aBrick messageBrick rubricTextColor: Color black.  aBrick     color: color;     borderColor: color darker;     borderWidth: self outerBorderWidth;     marginTop: 0applyFilterWithQuery  [ self doApplyFilterWithQuery ] on: GTLimitArrived do: [ ^self ]shouldEnableProcessorsCreateBy: aMethod  self subclassResponsibilitysetUp  super setUp.  debugger := self debuggerToTest newitemDo: aBlock  self onDo cull: aBlock cull: self contextspotterForMetacelloConfigurationsFor: aStep  < spotterOrder: 86>  aStep listProcessor     title: 'Metacello Configurations';     allCandidates: [ Smalltalk allClasses select: [:each |  (each respondsTo: #isMetacelloConfig) and: [ each isMetacelloConfig and: [ each name beginsWith: 'ConfigurationOf' ] ] ] thenCollect: #project ];     itemName: [:each |  each configuration class name ];     itemIcon: [ Smalltalk ui icons iconNamed: #config ];     filter: self defaultFilterClass;     wantsToDisplayOnEmptyQuery: falseonDraw: aCanvas  super onDraw: aCanvas.  aCanvas fillRectangle: ((self brickBounds withWidth: self themer spotterThemer outerBorderWidth) translateBy: (self themer scrollbarWidth + self themer scrollbarOffset + 1) @ 0) color: (self spotterModel isPreviewVisible ifTrue: [ self themer spotterThemer backgroundColor ] ifFalse: [ Color transparent ])isEmpty  < return: #Boolean>  ^self candidates isEmptydeleteFromFileSystem  | aFileReference |  aFileReference := self fileReference.  (aFileReference notNil and: [ aFileReference fileSystem isWritable ]) ifTrue: [ aFileReference ensureDelete ]inspectorActionsForNode  < return: #Collection of: #GLMAction>  ^#()wantsToDisplayOnEmptyQuery  ^truetestDeploymentExceptionHandlerMock3  self assertResetExceptions.  self shouldntRaise: ZeroDivide process: 'abc' origin: GTSpotterExceptionMock3 new.  self assertException: ZeroDivide.  self assertResetExceptions.  self shouldntRaise: Error process: 'abc' origin: GTSpotterExceptionMock3 new.  self assertException: ZeroDividenewInspectButtonFor: anAssociation  ^self newActionButton     hintTitle: 'Inspect';     hintText: 'will open inspector window';     icon: self themer bindingThemer inspectIcon;     action: [:b |  self remove.        self announce: #inspect event: anAssociation ]installCodeActionsFor: aPresentation  self installActionsForRootPragmas: self codeActionsPragmas in: aPresentationbrowsingActionsForNode  ^{(GLMGenericAction new     action: [ self systemNavigation browseAllAccessesTo: self label from: self hostObject class ];     title: 'List methods using this variable') .   (GLMGenericAction new     action: [ self systemNavigation browseAllStoresInto: self label from: self hostObject class ];     title: 'List methods storing into this variable')}mockProcessorFor: aSpotterStep  < spotterOrder: 1>  AssertionFailure signal: self messageTextvariableTag  ^'attribute'onAllCandidatesAdded: anAnnouncement  anAnnouncement candidateLinks ifEmpty: [ ^self ].  self addItems: (anAnnouncement candidateLinks collect: [:each |  self buildItemFor: each in: anAnnouncement category ]) to: (self categoryBrickFor: anAnnouncement category)stackDebuggingActionsPragmas  ^#(stackDebuggingAction)notEmpty  ^self isEmpty notgetCandidateLinks: aProcessorLink  | list head tail current |  head := aProcessorLink headLink.  tail := aProcessorLink tailLink.  list := OrderedCollection new.  head ifNil: [ ^list ].  head = tail ifTrue: [ list add: head.        ^list ].  current := head.  [ current = tail ] whileFalse: [ list add: current.        current := current nextLink ].  list add: current.  ^listassertSearch: aString  self deny: (spotter currentStep context matches: aString).  self basicSearch: aString.  self deny: previousContext identicalTo: currentContext.  self deny: previousContext identicalTo: spotter currentStep context.  self assert: spotter currentStep context text asString equals: aString asStringisTriangleVisible  ^isTriangleVisible ifNil: [ isTriangleVisible := false ]nameBrick  ^nameBrickstream  ^stream ifNil: [ stream := self defaultStream.        stream           onAddedSelector: #addCandidate:in:;           onRemoveSelector: #removeAllCandidatesOf:;           receiver: self candidates.        stream ]gtInspectorProcessorsIn: composite  < gtInspectorPresentationOrder: 40>  composite list     title: 'Processors';     display: [ self processors ];     format: #gtDisplayString;     when: [ self spotter notNil ]initialize  super initialize.  self     emptyBrick: self newEmptyText;     maxHeight: 300;     height: [:b |  b band height ];     width: 300breadcrumbItemStyleFor: aBrick  aBrick vSpaceFillnotifySpotterExitFor: anEventType  self announce: (GTSpotterExitAnnouncement new eventType: anEventType)addAllSignatures  self allPresentationMethods do: [:aMethod |  self addSignatureFor: aMethod ]testNoOverlappingCodeEditorKeyBindings  | context process codeEditor keymaps doubleKeymaps |  self skip.  context := [ 20 factorial ] asContext.  process := Process forContext: context priority: Processor userInterruptPriority.  window := GTGenericStackDebugger openOn: (process newDebugSessionNamed: 'test debugging' startedAt: context).  codeEditor := self findSatisfying: [:morph |  morph model isKindOf: GLMRubricSmalltalkTextModel ] in: window.  keymaps := OrderedCollection new.  codeEditor withAllOwnersDo: [:morph |  keymaps addAll: morph kmDispatcher directKeymaps allEntries keymaps ].  doubleKeymaps := (keymaps groupedBy: [:each |  each shortcut ]) select: [:each |  each value size > 1 ].  self assertEmpty: doubleKeymapsnewSearchField  ^GLMRubTextFieldBrick newtestCategoryLinkByCandidateLinkThreeA1A2A3  | link11 link12 link13 link21 link22 link23 link31 link32 link33 category1 category2 category3 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  category3 := candidates addProcessor: GTSpotterA3.  link11 := candidates addCandidate: 11 in: GTSpotterA1.  link12 := candidates addCandidate: 12 in: GTSpotterA1.  link13 := candidates addCandidate: 13 in: GTSpotterA1.  link21 := candidates addCandidate: 21 in: GTSpotterA2.  link22 := candidates addCandidate: 22 in: GTSpotterA2.  link23 := candidates addCandidate: 23 in: GTSpotterA2.  link31 := candidates addCandidate: 31 in: GTSpotterA3.  link32 := candidates addCandidate: 32 in: GTSpotterA3.  link33 := candidates addCandidate: 33 in: GTSpotterA3.  self assert: category1 equals: (candidates getProcessorLinkByCandidateLink: link11).  self assert: category1 equals: (candidates getProcessorLinkByCandidateLink: link12).  self assert: category1 equals: (candidates getProcessorLinkByCandidateLink: link13).  self assert: category2 equals: (candidates getProcessorLinkByCandidateLink: link21).  self assert: category2 equals: (candidates getProcessorLinkByCandidateLink: link22).  self assert: category2 equals: (candidates getProcessorLinkByCandidateLink: link23).  self assert: category3 equals: (candidates getProcessorLinkByCandidateLink: link31).  self assert: category3 equals: (candidates getProcessorLinkByCandidateLink: link32).  self assert: category3 equals: (candidates getProcessorLinkByCandidateLink: link33)key  ^label ifNil: [ self hostObject key ]categoryTitleNameWidgetStyleFor: aBrick  aBrick     textColor: self titleTextColor;     color: self titleBackgroundColortimestamp  ^timestamprawValue  ^self hostObject rawValueitemSelectedBackgroundColor  ^self backgroundColor darkericon: aForm  self iconBrick normalImage: aForminitialize  super initialize.  debugActionHolder := nil asValueHolder.  debugActionHolder whenChangedDo: [ self update ]render: anObject  ^GTSpotterItemBrick new     icon: (self itemIconFor: anObject);     text: (self itemNameFor: anObject)id  ^#gtClearEditorDebugActiontestDebuggingExceptionHandlerMock4  self shouldRaise: ArithmeticError process: 'abc' origin: GTSpotterExceptionMock4 new do: [:e |  self assert: e messageText equals: 'Error while filtering' ]initialize  super initialize.  self enable.  self announcer when: #onMouseHover send: #onHovered to: self.  self announcer when: #onMouseUnhover send: #onUnhovered to: selfdebuggerToTest  ^GTSUnitDebuggertaskbarIcon  ^self iconNamed: #glamorousBugspotterCatalogProjectsFor: aStep  < spotterOrder: 90>  CatalogSettings displayCatalogProjectsInSpotter ifFalse: [ ^self ].  aStep listProcessor     allCandidates: [ CatalogProvider default projects ];     title: 'Catalog Projects';     itemName: [:item |  item name ];     itemIcon: [:item |  CatalogBrowser iconFor: item ];     filter: GTFilterSubstring;     actLogic: [:item |  aStep exit.        (UIManager default confirm: 'Would you like to install ' , item name , '?') ifTrue: [ item installStableVersion.              UIManager inform: item name , ' installed' ] ];     wantsToDisplayOnEmptyQuery: trueupperThreshold: anObject  upperThreshold := anObjectexecuteAction  self codePresentation evaluateSelectionAndDo: [:result |  self debugger inspect: result ]addStep: aSpotterStep during: aBlock  self assert: aSpotterStep isNotNil.  self assert: aBlock isNotNil.  self steps add: aSpotterStep.  aBlock ensure: [ self steps remove: aSpotterStep ]addItems: aCollection  self stream addObjects: aCollection inProcessor: self processorinitialize  super initialize.  self searchField: self newSearchField.  self class environment at: #GTEventRecorderSettings ifPresent: [ self settingsButton: self newSettingsButton ].  self helpButton: self newHelpButton.  self closeButton: self newCloseButtoninitialize  super initialize.  self     useVerticalLinearLayout;     labelBrick: self newLabelBrick;     triangleBrick: self newTriangleBrick;     enablelayout: aBrick in: newBounds  ^super layout: aBrick in: newBoundstestArrays  self assert: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 51 51 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 81 81 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99) equals: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99)compose  | tabulator |  tabulator := self tabulator.  tabulator row: #main.  tabulator transmit     to: #main;     andShow: [:aComposite |  aComposite tabulator with: [:browser |  browser title: 'Variables'.              browser row: #variables.              browser transmit                 to: #variables port: #entity;                 andShow: [:a |  self variablesIn: a ].              browser transmit                 from: #variables port: #entity;                 to: #variables port: #selection;                 when: [:aContext |  self debugger selectedVariableName notNil and: [ aContext notNil ] ];                 transformed: [:aContext |  self selectedVariableForContext: aContext ].              browser transmit                 from: #variables;                 toOutsidePort: #selection;                 transformed: [:aNode |  aNode value ] ].        aComposite tabulator with: [:browser |  browser title: 'Evaluator'.              browser row: #evaluator.              browser transmit                 to: #evaluator;                 andShow: [:a |  self contextEvaluatorIn: a ].              browser transmit                 from: #evaluator;                 toOutsidePort: #selection ].        aComposite onChangeOfPort: #activePresentation act: [:presentation |  (presentation pane port: #activePresentation) value ifNotNil: [:activePresentation |  self debugger cache at: #activePresentationTitle put: activePresentation title ] ] ].  tabulator transmit     from: #main;     toOutsidePort: #selectionlayoutAllowedTop: aBrick  self     translate: aBrick by: (self deltaTop: aBrick);     increaseZindex: aBrick;     cutAllowedBoundsTop: aBrickactOnPaneRemoved: anAnnouncement  self panes last presentations first updateToolbar.  self notifyPaneRemoved ifTrue: [ self debugger announce: anAnnouncement ]onRemoveSelector: anObject  onRemoveSelector := anObjectpopUntil: aStep  [ self steps last = aStep ] whileFalse: [ self popStep ]save: aValue  foundationOrigin  ^foundationOrigin ifNil: [ foundationOrigin := self ]handleFatalException: anException  GTSpotterExceptionsTest fatals add: anExceptionprivateProcessorLink: aLink  processorLink := aLinksettingsButtonStyleFor: aBrick  aBrick     vSpaceFill;     width: [:m |  m height ];     margin: #(10 0);     marginRight: 2glmAnimateBrickBounds: aValue duration: anInteger callback: aBlock  self animation ifNotNil: #terminate.  animation := GLMAnimation new     linear;     duration: anInteger;     from: self band brickBounds left;     to: self band brickBounds left + aValue;     onCompleted: aBlock;     animation: [:b :v |  b changedWith: [ b                 translateXTo: v asInteger;                 data: b brickBounds left ] ];     animate: self bandtransmitFromStackToCodeIn: browser  browser transmit     from: #stack port: #selection;     to: #code;     andShow: [:composite :aContext |  self methodCodeIn: composite forContext: aContext ]category: aProcessorClass  category := aProcessorClassmakeBasicInspect  shouldBasicInspect := truefileName  self subclassResponsibilitydeltaBottom: aBrick  ^aBrick globalOuterBounds corner y - self allowedBounds corner yhostObject: anObject  self assert: [ hostObject isNil ] description: [ 'Host can be assigned only once' ].  hostObject := anObjecttoggleHints  (self hasSubbrick: self actionbarBrick) ifFalse: [ ^self ].  self stepModel spotter isShiftPressed ifTrue: [ self onRevealHints ] ifFalse: [ self onHideHints ]allFilteredCandidates  ^allFilteredCandidates ifNil: [ allFilteredCandidates := OrderedCollection new ]asArray  ^self items asArrayonAmountChanged: anInteger in: aProcessor  self assert: anInteger >= 0.  anInteger = 0 ifTrue: [ ^self ].  self announcer announce: (GTSpotterCandidatesAmountChanged new           amount: anInteger;           category: aProcessor;           yourself)persistenceStrategies: anObject  persistenceStrategies := anObjectactionbarBrick: anObject  actionbarBrick := anObject.  self actionbarBrick     vSpaceFill;     hShrinkWrapaddCategory: aCategoryBrick  self assert: aCategoryBrick isNotNil.  self assert: aCategoryBrick hasOwner not.  self assert: aCategoryBrick hasSubbricks.  self band hasSubbricks ifFalse: [ self band addBrickBack: aCategoryBrick titleBrick.        self band addBrickBack: aCategoryBrick ] ifTrue: [ | index |        index := 2.        [ index <= self band subbricksCount and: [ (self band subbricks at: index) order <= aCategoryBrick order ] ] whileTrue: [ index := index + 2 ].        index > self band subbricksCount ifTrue: [ self band addBrickBack: aCategoryBrick titleBrick.              self band addBrickBack: aCategoryBrick ] ifFalse: [ self band addBrick: aCategoryBrick titleBrick after: (self band subbricks at: index).              self band addBrick: aCategoryBrick titleBrick after: aCategoryBrick titleBrick ] ]onThemerChanged  super onThemerChanged.  self band subbricks withIndexDo: [:each :index |  index even ifTrue: [ self themer spotterThemer breadcrumbSeparatorWidgetStyleFor: each ] ]newEmptyText  ^GLMLabelBrick new     text: 'No saved pages';     hSpaceFill;     textPosition: #center;     padding: self themer bindingThemer emptyTextPadding;     textColor: self themer bindingThemer emptyTextColor;     fontSize: self themer bindingThemer emptyTextFontSize;     yourselfslot: aSlot  self assert: [ aSlot isNotNil ] description: [ 'Slot can not be nil' ].  slot := aSlotdefaultCandidatesLimit  ^self defaultItemsLimitdefaultIcon  ^GLMUIThemeExtraIcons glamorousHelpassertDebuggerInitializationForContext: aContext andStepBlock: aBlock  self initializeSessionForContext: aContext withStepBlock: aBlock.  self assertDebuggerInitializationgtInspectorUsersIn: composite  < gtInspectorPresentationOrder: 1>  composite list     title: 'Users';     display: [ self users sorted: [:a :b |  a selector < b selector ] ];     format: #gtDisplayStringpreviewBrick  ^previewBrickspotterModel  ^spotterModelcompose  self title: 'Tree'.  self tabulator with: [:browser |  browser           row: #tree;           row: #source.        browser transmit           to: #tree;           andShow: [:a |  self treeIn: a ].        browser transmit           to: #source;           andShow: [:a |  self sourceIn: a ].        browser transmit           from: #tree;           to: #source port: #selectionInterval;           transformed: [:rbNode |  rbNode sourceInterval ].        browser transmit           toOutsidePort: #selection;           from: #tree port: #selectedNode ]stepModel  ^stepModelshouldFilterInContext: aSpotterContext  ^aSpotterContext notEmpty or: [ self wantsToDisplayOnEmptyQuery ]send  self session stepInto: self currentContext.  self updateBrowserborder: anInteger  border := anIntegerinitialize  super initialize.  self filteredItems: self defaultFilteredItemsanySatisfy: aBlock  self do: [:each |  (aBlock value: each) ifTrue: [ ^true ] ].  ^falsespotterModel: aModel  spotterModel := aModel.  spotterModel steps do: [:each |  self pushPane: (self buildPane: each) ].  spotterModel announcer when: GTSpotterStepAdded send: #onStepAdded: to: selfspotterDirtyMonticelloPackagesFor: aStep  < spotterOrder: 85>  aStep listProcessor     allCandidates: [ MCWorkingCopy allManagers select: #modified ];     title: 'Dirty Monticello packages';     itemIcon: [ Smalltalk ui icons iconNamed: #dirtyPackageIcon ];     filter: self defaultFilterClass;     wantsToDisplayOnEmptyQuery: truenotifySelected  self stepModel spotter announce: (GTSpotterCandidateSelected new itemBrick: self).  self stepModel announcer announce: (GTSpotterCandidateSelected new itemBrick: self)candidateLink  ^candidateLinkprivateAddCandidate: aCandidateLink inEmpty: aProcessorLink  | head current |  current := aProcessorLink.  head := nil.  [ head isNil and: [ current isNotNil ] ] whileTrue: [ current := current nextLink.        current ifNotNil: [ head := current headLink ] ifNil: [ nil ] ].  current ifNil: [ self candidates addLast: aCandidateLink ] ifNotNil: [ self candidates add: aCandidateLink beforeLink: head ].  aProcessorLink     headLink: aCandidateLink;     tailLink: aCandidateLink.  aProcessorLink incrementSize.  ^aCandidateLinkisFullyVisible: aBrick  ^self allowedBounds containsRect: aBrick globalOuterBoundsstep  self window ifNil: [ ^self ].  self window isActive ifFalse: [ ^self ].  self wantsAutomaticRefresh ifTrue: [ self requestRefresh ]initialize  super initialize.  self enable.  self themer spotterThemer itemNormalStyleFor: self.  self iconBrick: self newIconBrick.  self labelBrick: self newLabelBrick.  self actionbarBrick: self newActionbarBrickonHovered  self showActionbarhandleException: anException do: aBlock  anException pass.  ^super handleException: anException do: aBlocktagsFrom: aMethod  ^(aMethod pragmas select: [:each |  each key == self tagPragmaKey ]) ifEmpty: [ defaultTag ifNil: [ {} ] ifNotNil: [ {defaultTag} ] ] ifNotEmpty: [:currentPragmas |  currentPragmas collect: [:each |  each argumentAt: 1 ] ]step: anObject  step := anObjectdebuggerStructureIn: browser  browser     row: #stack;     row: [:c |  c           column: #code;           column: #bytecode ] span: 2;     row: #inspectorassertDiveIn: aSelector  | previousStepsSize link |  previousStepsSize := spotter steps size.  previousStep := spotter currentStep.  link := spotter currentStep candidates getCandidateLink: currentCandidate in: currentProcessor.  self assert: link notNil.  self assert: link candidate identicalTo: currentCandidate.  self assert: link processor identicalTo: currentProcessor.  self shouldnt: [ spotter currentStep select: link ] raise: Error.  self assert: spotter currentStep selected identicalTo: link.  self shouldnt: [ spotter currentStep perform: aSelector ] raise: Error.  currentStep := spotter currentStep.  currentProcessor := currentCandidate := previousContext := currentContext := nil.  self denyEmpty: spotter steps.  self assert: spotter steps size > previousStepsSize.  self assert: spotter steps size equals: previousStepsSize + 1.  self deny: previousStep equals: currentStep.  self deny: previousStep equals: spotter currentStep.  self assert: currentStep equals: spotter currentStepprocessor: anObject  processor := anObjectexecuteAction  self debugger updateSelectionIntervaldoFilter: aGTFilter forProcessor: aGTProcessor  self processor: aGTProcessor.  self filter: aGTFilter.  self streamed: (OrderedCollection new: 100).  (self cache at: #processorsAndFilters) at: aGTProcessor put: aGTFilter.  (self cache at: #processorsAndStreamed) at: aGTProcessor put: streamed.  ^aGTFilter value: selfitemsLimit  ^self context itemsLimitgetProcessorLink: aProcessor  ^self processorLinksMap at: aProcessor ifAbsentPut: [ self addProcessor: aProcessor ]breadcrumbItemTriangleWidgetStyleFor: aBrick  aBrick renderer: (GTSpotterTriangleRenderer new orientation: #bottom).  aBrick owner isTriangleVisible ifTrue: [ aBrick color: self breadcrumbItemBackgroundColor ] ifFalse: [ aBrick color: Color transparent ]removeAllCandidates  self processors linksDo: [:each |  each clear ].  self candidates removeAll.  self notifyAllCandidatesRemovedgtPagesIn: composite  < gtInspectorPresentationOrder: 0>  composite list     title: 'Pages';     display: [ self pages ];     format: #gtDisplayString;     filterOn: [:text :each |  text match: each content ]updateBrowser  super updateBrowser.  ((self browser paneNamed: #stack) port: #selection) value: self session interruptedContextprevious: anObject  previous := anObjectremovePage: aPage  self pages remove: aPage ifAbsent: [  ]pageActionsIn: aGLMPharoScriptPresentation  self pageActions do: [:eachAction |  aGLMPharoScriptPresentation addAction: eachAction ]element  ^elementonHideHints  (self hasSubbrick: self actionbarBrick) ifFalse: [ ^self ].  self themer spotterThemer hintHideStyleFor: self diveInButtonbuttonPressedColor  ^self backgroundColor darkerhelp  ^'Save the current method.'defaultOrder  ^15isActive  ^self isActive: self testContextsave  persistenceStrategies do: [:each |  each save ]newRow  ^GLMInteractableBrick new     enable;     enableDoubleClick;     selectedColor: self themer bindingThemer selectedColor;     vShrinkWrap;     hSpaceFill;     padding: self themer bindingThemer padding;     paddingRight: 0listProcessor  | processor |  processor := GTSpotterCandidatesListProcessor new.  self addProcessor: processor.  ^processorpragma: aSelector of: aCompiledMethod  ^aCompiledMethod pragmas detect: [:each |  each selector = aSelector ] ifNone: [ nil ]inspectorIn: aComposite on: anObject  ^anObject gtConstructDebuggerInspectorIn: aComposite for: selfspotter: aSpotter  spotter := aSpotteraddAndSelectAllSignatures  self allPresentationMethods do: [:aMethod |  self addAndSelectSignatureFor: aMethod ]newActionButton  | margin padding |  margin := self themer bindingThemer padding + self themer bindingThemer borderWidth.  padding := (margin / 2) rounded.  ^GLMHintableActionButtonBrick new     padding: padding;     visible: false;     margin: {0 .         padding};     hShrinkWrap;     vAlign: #center;     pressedColor: self themer buttonPressedColorhasCandidates  < return: #Boolean>  ^self candidates isNotEmptyfilterByMethods: aCollection  | filter |  filter := GTSpotterMethodListProcessorFilter new.  aCollection do: [:aMethod |  filter allowProcessorsFrom: aMethod ].  self processorsFilter: filterprocessor  ^self processorLink valuegenerateCacheFor: anObject  | valuesCache |  valuesCache := OrderedDictionary new.  (self basicVariableNodesFor: anObject) do: [:assoc |  valuesCache at: assoc key put: (self generateHashFor: assoc value) ].  ^valuesCachemethodCodeWidgetIn: composite forContext: aContext  ^composite pharoMethod     title: 'Source';     format: [ aContext sourceCode ];     smalltalkClass: [ aContext methodClass ];     doItReceiver: [ aContext receiver ];     doItContext: [ aContext ];     with: [:codePresentation |  self installBindingsForDoItIn: codePresentation from: aContext ]newActionButton  | margin padding |  margin := self themer bindingThemer padding + self themer bindingThemer borderWidth.  padding := (margin / 2) rounded.  ^GLMHintableActionButtonBrick new     padding: padding;     visible: false;     margin: {0 .         padding};     marginRight: margin;     hShrinkWrap;     vAlign: #center;     pressedColor: self themer buttonPressedColorupdateOuterPaneFrom: text for: method  | outerPane newMethod |  newMethod := method methodClass compile: text text notifying: nil.  outerPane := text pane browser pane.  outerPane browser panes do: #update.  self flag: 'This is a huge hack because of so many reasons:				- the presentation accesses the state of the outer browser directly				- the presentation depends on the implementation of the browser 				It should be solved through transmissions.								But, it works for now and the browser is reasonably updated'.  ^outerPane withAllPanesAndPresentationsDo: [:child |  (child isKindOf: self class) ifTrue: [ ((child first paneNamed: #classes) port: #selection) value: method methodClass.              ((child first paneNamed: #methods) port: #selection) value: ((child first paneNamed: #methods) presentations first displayedValue ifNotNil: [:v |  v detect: [:each |  each selector = newMethod ] ]) ] ]newDropDownMorph  ^GTSpotterDropDownMorph newactionbarBrick  ^actionbarBrickvisible: aBoolean  super visible: aBoolean.  self toggleHints> anotherCandidateLink  ^self weight > anotherCandidateLink weightspotterModel: aSpotterModel  spotterModel := aSpotterModel.  self spotterModel announcer when: GTSpotterCandidateSelected send: #onCandidateSelected: to: self.  self spotterModel announcer when: GTSpotterCandidateSelectedMoved send: #onCandidateMoved to: self.  self spotterModel announcer when: GTSpotterStepAdded send: #onStepAdded to: self.  self spotterModel announcer when: GTSpotterShowPreview send: #onShowPreview to: self.  self spotterModel announcer when: GTSpotterHidePreview send: #onHidePreview to: self.  self spotterModel announcer when: GTSpotterRevealHints send: #onRevealHints to: self.  self spotterModel announcer when: GTSpotterHideHints send: #onHideHints to: selfinitializeWindow: aWindowPresenter  aWindowPresenter     whenClosedDo: [ debugger ifNotNil: #windowIsClosing ];     initialExtent: 700 @ 180settingsButton: aBrick  settingsButton ifNotNil: [ self removeBrick: settingsButton ].  settingsButton := aBrick.  self themer spotterThemer settingsButtonWidgetStyleFor: settingsButton.  self themer spotterThemer settingsButtonStyleFor: settingsButton.  settingsButton     hintTitle: 'Settings';     hintText: 'Shows the settings UI';     action: [ self openSettingsBrowser ].  self addBrickBack: settingsButtonremoveAllCandidatesOf: aProcessor  | processorLink head tail current |  processorLink := self getProcessorLink: aProcessor.  processorLink isEmpty ifTrue: [ ^self ].  head := processorLink headLink.  tail := processorLink tailLink.  head = tail ifTrue: [ self candidates removeCycledLink: head.        processorLink clear ].  current := head.  [ current = tail ] whileFalse: [ | nextCurrent |        nextCurrent := current nextLink.        self candidates removeCycledLink: current.        current := nextCurrent ].  self candidates removeCycledLink: current.  processorLink clearhasFilteredItems  ^self filteredItems isEmptyOrNil notitemSelectedBackgroundColor  ^self backgroundColor slightlyDarkerclipSubmorphs  ^truecontextMenuActions  ^(Pragma allNamed: self contextMenuPragma from: self class class to: Object class) flatCollect: [:eachPragma |  self class perform: eachPragma methodSelector with: self ]itemFilterName  ^itemFilterNameBlocknewContext  ^newContexttestResetBindings  | obtainedBindings |  window := playground openOn: (GTPlayPage new saveContent: 'number+1').  playground setBindings: {(#number -> 2)} asDictionary.  obtainedBindings := playground currentBindings.  self assert: obtainedBindings size equals: 1.  playground resetBindings.  obtainedBindings := playground currentBindings.  self assert: obtainedBindings size equals: 0triangleBrick  ^triangleBrickquery: anObject  query := anObjectcontext  ^contextmatches: aContext  ^result := self matchContext: aContextpreviewArrowGapHack  ^self themer scrollbarOffset + self themer scrollbarWidth + self outerBorderWidth + 1testSimpleFailingAssestion  self assert: falsesetUp  super setUp.  spotter := GTMockSpotter new     exceptionHandler: GTSpotterDebuggingExceptionHandler new;     yourselfrunToBytecode: aSymbolicBytecode inContext: aContext  aSymbolicBytecode offset <= aContext pc ifTrue: [ ^self ].  self stepOver: aContext.  [ aContext == self interruptedContext and: [ aContext pc < aSymbolicBytecode offset ] ] whileTrue: [ self stepOver: aContext ]newArrowBrick  ^GTSpotterPreviewArrowBrick newouterBorderWidth  ^4hasMatched  ^self result ifNil: [ ^false ]result  ^resultplaygroundActions  ^(Pragma allNamed: self playgroundActionPragma from: self class to: Object sortedByArgument: 1) collect: [:eachPragma |  self perform: eachPragma methodSelector ]testDeploymentExceptionHandlerDuring  | exceptionHandler |  self exceptionHandler: (exceptionHandler := GTSpotterDeploymentExceptionHandlerMock new) do: [ self shouldnt: [ GTCurrentSpotterExceptionHandler value ] raise: Error.        self assert: GTCurrentSpotterExceptionHandler value notNil.        self assert: GTCurrentSpotterExceptionHandler value identicalTo: exceptionHandler ]incrementSize  size := self size + 1setUp  super setUp.  42 messageThatIsNotUnderstoodonLayouted  super onLayouted.  self isChecked ifTrue: [ self stepModel spotter announce: GTSpotterCandidateSelectedMoved new ]categoryStyleFor: aBrick  aBrick     marginBottom: self categoryMarginBottom;     hSpaceFillpage: anObject  page := anObjectcomputeCandidatesIn: aContext  ^self computeAllItemsIn: aContextitemFilterNameFor: anItem  ^self processor itemFilterNameFor: anItempragmas: aSelector inPackages: anArray  | pragmas |  pragmas := OrderedCollection new.  RPackageOrganizer default packages do: [:package |  anArray do: [:packageName |  package packageName = packageName ifTrue: [ package methods do: [:cm |  cm methodClass isTrait ifFalse: [ (cm pragmas detect: [:p |  p selector = aSelector ] ifNone: [ nil ]) ifNotNil: [:p |  pragmas add: p ] ] ] ] ] ].  ^pragmascreationTimeForFileName  ^(self creationTime asString copyReplaceAll: ':' with: '-') copyReplaceAll: '.' with: '-'isFullyVisible: aBrick in: aRectangle  ^aRectangle containsRect: aBrick globalOuterBoundsinitializeTestContextFrom: aContext  testContext := aContext findContextSuchThat: [:anotherContext |  anotherContext method isTestMethod ].  testContext ifNil: [ testContext := aContext findContextSuchThat: [:anotherContext |  anotherContext receiver class isTestCase ] ].  testContext ifNil: [ testContext := aContext ]itemActionSelectedBackgroundColor  ^self itemSelectedBackgroundColor slightlyDarkertestEmptyTextInput  self assertText: Text new do: [ self assert: spotter text isEmpty ].  self assertText: (Text fromString: '') do: [ self assert: spotter text isEmpty ].  self assertText: '' do: [ self assert: spotter text isEmpty ].  self flag: 'currently: nil is converted to the string "nil"'defaultPages  ^OrderedCollection newmockProcessorFor: aSpotterStep  < spotterOrder: 1>  self assert: GTCurrentSpotterExceptionHandler value notNil.  self assert: GTCurrentSpotterExceptionHandler value == aSpotterStep spotter exceptionHandler.  aSpotterStep listProcessor     allCandidates: [ self assert: GTCurrentSpotterExceptionHandler value notNil.        self assert: GTCurrentSpotterExceptionHandler value == aSpotterStep spotter exceptionHandler.        #(1 2 3) ];     itemName: [:item |  self assert: GTCurrentSpotterExceptionHandler value notNil.        self assert: GTCurrentSpotterExceptionHandler value == aSpotterStep spotter exceptionHandler.        item asString ];     filter: GTSpotterExceptionMock5Filterhead  ^self candidates headhasMultipleSteps  ^self steps size > 1searchFieldWidgetStyleFor: aBrick  aBrick morph     color: Color transparent;     textColor: self searchFieldTextColor;     borderColor: Color transparent.  aBrick morph textArea backgroundColor: Color transparentdoApplyFilterWithQuery  | exactMatches prefixMatches otherMatches nonExactMatches |  exactMatches := OrderedCollection new.  prefixMatches := OrderedCollection new.  otherMatches := OrderedCollection new.  self allItemsDo: [:each |  | index queryString itemName |        itemName := self itemFilterNameFor: each.        queryString := self queryForItem: each.        index := self indexForItemName: itemName andQuery: queryString.        index >= 1 ifTrue: [ index = 1 ifTrue: [ itemName size = queryString size ifTrue: [ exactMatches add: each.                          self addItem: each.                          exactMatches size = self itemsLimit ifTrue: [ self filteredItems: exactMatches.                                GTLimitArrived signal ] ] ifFalse: [ prefixMatches add: each ] ] ifFalse: [ otherMatches add: each ] ] ].  nonExactMatches := prefixMatches , otherMatches.  exactMatches size < self itemsLimit ifTrue: [ | restVisibleItems |        restVisibleItems := nonExactMatches first: (self itemsLimit - exactMatches size min: nonExactMatches size).        self addItems: restVisibleItems ].  self filteredItems: exactMatches , nonExactMatchesshowActionbar  self shouldShowActionbar ifFalse: [ ^self ].  self actionbarBrick visible: trueselectTopContext  ((self browser paneNamed: #stack) port: #selection) value: self interruptedContextnotEmpty  ^self isEmpty notspotterGhostText  ^'Search'tearDown  debugger ifNotNil: [ debugger close ].  window := nil.  debugger := nil.  session := nil.  super tearDowntailLink  ^tailLinkdebugAction  ^debugActionHolder valuebackgroundColor  ^Smalltalk ui theme lightBackgroundColor slightlyLighterpresentationFilter: aPresentationFilter  self assert: [ aPresentationFilter isNotNil ] description: [ 'Presentation filter must not be nil' ].  presentationFilter := aPresentationFilterbytecodePane  ^self browser paneNamed: #bytecoderefreshPanes  self panes do: [:aPane |  aPane updateToolbar.        aPane presentations presentations first withAllPresentations do: [:aPresentation |  aPresentation wantsAutomaticRefresh ifTrue: [ aPresentation requestRefresh ] ] ]initialize  super initialize.  self needsUpdate: falseasSet  ^self items asSetsubclassesOf: aClass filterBySubstring: aString inPackage: aPackageName  ^(self subclassesOf: aClass inPackage: aPackageName) select: [:each |  each name includesSubstring: aString caseSensitive: false ]shrinkTop: aRectangle with: aBrick  ^aRectangle top: aRectangle top + aBrick globalOuterBounds heightexecuteAction  self codePresentation evaluateSelectiondetect: aBlock ifFound: aBlock2 ifNone: aBlock3  self do: [:each |  aBlock value ifTrue: [ ^aBlock2 value: each ] ].  ^aBlock3 valuedefaultPagerModel  ^GLMMockPagerModel newrebuildCacheFor: anObject  cachedHashes := self generateCacheFor: anObjectkeyBinding  ^keyBindingkey  ^'self'actOn: anObject for: aStep  actBlock ifNil: [ super actOn: anObject for: aStep ] ifNotNil: [ actBlock cull: anObject cull: aStep ]categoryTitleShortcutStyleFor: aBrick  aBrick     vSpaceFill;     textPosition: #leftCenter;     textColor: self titleTextColor.  aBrick label familyName: 'Lucida Grande'defaultCache  ^IdentityDictionary new     at: #processorsAndFilters put: (IdentityDictionary new: 100);     at: #processorsAndStreamed put: (IdentityDictionary new: 100);     yourselfspotterWindowsFor: aStep  < spotterOrder: 5>  aStep listProcessor     title: 'Windows';     candidatesLimit: 10;     allCandidates: [ (self currentWorld submorphs select: [:window |  window isKindOf: SystemWindow ]) allButFirst ];     itemName: [:window |  '{1} [{2}]' format: {window label .               window className} ];     itemIcon: [:window |  window taskbarIcon ];     sort: [:window1 :window2 |  window1 label < window2 label ];     filter: GTFilterSubstring;     wantsToDisplayOnEmptyQuery: truetestInspectDoesNotCrash  window := GTInspector openOn: ProtoObject newborderColor  ^borderColorinitializeAssestionContextFrom: aContext  | frameworkTestClasses |  frameworkTestClasses := {TestCase .   TestCase superclass}.  assertionContext := aContext findContextSuchThat: [:anotherContext |  anotherContext = testContext ifTrue: [ ^self ].        anotherContext sender notNil and: [ (frameworkTestClasses anySatisfy: [:aTestClass |  aTestClass includesMethod: anotherContext sender method ]) not ] ].  assertionContext ifNotNil: [ assertionCallerContext := name = 'Halt' ifTrue: [ assertionContext ] ifFalse: [ assertionContext sender ] ]newSeparator  ^GLMBrick newprocess: aString  (self context matches: aString) ifTrue: [ ^self ].  self context: (self newContextForQuery: aString).  self stream updateTimestamp.  self asyncTask execute: [:aCurrentContext |  self spotter notifyContextChangedFrom: lastSearchContext to: self context.        self processContext: aCurrentContext ] withArguments: {self context} callback: [ lastSearchContext := self context.        self spotter notifySearchFinishedFor: aString processors: self processors ] delay: 200spotter  ^self step spotteronRemovedFrom: aBrick  super onRemovedFrom: aBrick.  self stepModel ifNotNil: [ self stepModel announcer unsubscribe: self.        self stepModel spotter announcer unsubscribe: self ]assortCandidatesSize: aNumber  executeAction  self needsUpdate: false.  self codePresentation hasUnacceptedEdits ifTrue: [ self codePresentation compileTextIn: self currentContext from: self session andDo: [ self needsUpdate: true ] ].  self codePresentation flashshouldntRaise: anError process: aString origin: anOrigin  self shouldntRaise: anError process: aString origin: anOrigin during: GTSpotterDeploymentExceptionHandlerMock newhelp  ^'Open an help browser for the currently active debugger.'category  self assert: category isNotNil.  ^categoryspotterForGlobalVarsFor: aStep  < spotterOrder: 40>  aStep listProcessor     allCandidates: [ Smalltalk globals associations select: [:assoc |  assoc value isBehavior not and: [ assoc value isTrait not ] ] ];     title: 'Global variables';     itemName: [:global |  global key ];     filter: self defaultFilterClass;     wantsToDisplayOnEmptyQuery: falsecurrent: anObject  current := anObjectkeymapToggleDebug  < shortcut>  ^KMKeymap shortcut: Character cr command shift action: [ self class openGlobalSpotterDebug ]initialize  super initialize.  self triangleBrick: self newTriangleBrickbreadcrumbStyleFor: aBrick  aBrick     margin: {0 .         0};     marginBottom: self breadcrumbTriangleHeight negated;     height: self breadcrumbHeight + self breadcrumbTriangleHeight.  aBrick layout zIndex: 2doContinueFilterForProcessor: aGTProcessor  self processor: aGTProcessor.  self filter: ((self cache at: #processorsAndFilters) at: aGTProcessor).  self streamed: ((self cache at: #processorsAndStreamed) at: aGTProcessor).  ^aGTProcessor withItemsLimit: aGTProcessor continueItemsLimit do: [ filter value: self ]step  ^self context stepnewStep  ^self defaultStep spotter: selflabel: aString  label := aStringupdateTimestamp  self timestamp: Time microsecondClockValueprocessorsFilter: aFilter  processorsFilter := aFilterprivacyAgreementIsNotSendingDataColor  ^Color paleRedasSpotterCandidateLink  ^selfdefaultKeymap  ^PharoShortcuts current printItShortcutallowedBounds: anObject  allowedBounds := anObjectspotterForPragmasFor: aStep  < spotterOrder: 40>  aStep listProcessor     allCandidates: [ Pragma allInstances collect: [:e |  e selector ] as: Set ];     title: 'Pragmas';     itemName: [:pragma |  pragma ];     filter: self defaultFilterClass;     wantsToDisplayOnEmptyQuery: falseallTags  ^(self allPragmasWithTag collect: [:pragma |  pragma argumentAt: 1 ]) asSet sorted: [:a :b |  a < b ]addActActionButton  actOnButton := self newActionButtonBrick     icon: self themer spotterThemer iconAct;     hintTitle: 'Default action';     hintText: '<enter>';     action: [ self owner beSelected.        self stepModel actDueTo: #actionButton ];     yourself.  self addActionButton: actOnButtonnewBindingRow: anAssociation in: aCollection  ^self newRow     borderWidth: {0 .         0 .         (aCollection last == anAssociation ifTrue: [ 0 ] ifFalse: [ self themer bindingThemer borderWidth ]) .         0};     addAllBricks: {(self newBindingLabel           textColor: self themer textLightColor;           text: anAssociation key) .         (self newBindingLabel text: anAssociation value asString) .         (self newInspectButtonFor: anAssociation) .         (self newGoButtonFor: anAssociation) .         (self newRemoveButtonFor: anAssociation)};     with: [:aRow |  aRow           when: #onMouseHover do: [ self showActionsOf: aRow ];           when: #onMouseUnhover do: [ self hideActionsOf: aRow ] ];     yourselfbreadcrumbBrick  ^breadcrumbBrickonStepAdded  self selectedItemBrick: nil.  self spotterModel steps last candidates announcer when: GTSpotterAllCandidatesRemoved send: #onAllCandidatesRemoved to: selfgtFilter  ^selfid  ^GTSUnitDebuggerJumpToTestAction nametestDevelopmentHandleException  self assertResetExceptions.  self should: [ [ 1 / 0 ] on: ZeroDivide do: [:exception |  GTSpotterDebuggingExceptionHandlerMock new handleException: exception ] ] raise: ZeroDivide.  self assertException: ZeroDividebrowseSendersOfMessages  self currentMessageName ifNotNil: [ self systemNavigation browseAllSendersOf: self currentMessageName ]spotterModel: aSpotter  spotterModel := aSpotter.  aSpotter announcer when: GTSpotterSelectedCandidateChanged send: #onCandidateSelected: to: self.  aSpotter announcer when: GTSpotterStepPopped send: #onStepPopped to: self.  aSpotter announcer when: GTSpotterStepAdded send: #onStepAdded to: self.  aSpotter announcer when: GTSpotterSearchFinished send: #onSearchFinished to: selfdefaultCategory  ^'Available Debuggers'defaultLabel  ^'Spotter'assertProcessorIncludesAll: aCollection  self assert: aCollection notEmpty.  self assert: currentProcessor notNil.  self assert: currentProcessor allFilteredCandidates notEmpty.  aCollection do: [:each |  self assert: (currentProcessor allFilteredCandidates anySatisfy: [:candidate |  candidate = each ]) ]testDeploymentHandleExceptionMock5  self assertResetExceptions.  self shouldnt: [ [ 1 / 0 ] on: ZeroDivide do: [:exception |  self assert: (GTSpotterDeploymentExceptionHandlerMock5 new handleException: exception do: [ 7 ]) identicalTo: 7 ] ] raise: ZeroDivide.  self assertException: ZeroDividefirstPresentation  ^self panes first presentations firstselect: aBlock  ^self select: aBlock as: self defaultItemsClassisEmpty  ^self items isEmptydefaultExceptionHandler  ^GTSpotterDeploymentExceptionHandler newprintOn: stream  stream nextPutAll: self keywordeventType: anObject  eventType := anObjectspotterForReferencesFor: aStep  < spotterOrder: 32>  aStep listProcessor     title: 'References';     filter: GTNullFilter item: [:filter :context |  self class environment at: context textTrimmed ifPresent: [:class |  SystemNavigation default allReferencesTo: class binding do: filter ] ];     keyBinding: $n shift meta;     itemName: [:method |  method gtDisplayString ]mockProcessorFor: aSpotterStep  < spotterOrder: 1>  aSpotterStep listProcessor     allCandidates: [ #(1 2 3) ];     itemName: [:item |  item asString ];     filter: GTSpotterExceptionMock4FilterinstallBindingsForDoItIn: aPresentation from: aContext  (aContext notNil and: [ aContext method isDoIt and: [ aContext receiver isNil ] ]) ifTrue: [ aPresentation variableBindings: aContext gtDebuggerDoItBindings ]page  ^pagescrollpaneBackgroundColor  ^self spotterThemer backgroundColorinitializeWidgets  self preDebuggingActions do: [:action |  self presenterAt: action id asSymbol put: (self buttonFor: action) ].  self presentersDo: [:button |  self focusOrder add: button ]itemFilterName: aBlockWithOneArgument  itemFilterNameBlock := aBlockWithOneArgumentgoIcon  ^GLMUIThemeExtraIcons glamorousGoexecute: aBlock withArguments: aCollection callback: callbackBlock priority: aPriority delay: anIntegerMilliseconds  aBlock valueWithPossibleArgs: aCollection.  aCollection valuegatherStacked: aBrick  | list |  list := DoubleLinkedList new.  aBrick subbricks do: [:each |  each layoutProperties floating = #stack ifTrue: [ list add: each ] ].  ^listbuildVariablesFromContext: aContext  ^aContext gtDebuggerRetrieveVariableValuePairsexit  self exitDueTo: #unknownprepareProcessorInContext: aContext  allFilteredCandidates := nilisActive: aContext  ^aContext ifNil: [ false ] ifNotNil: [ aContext isDead not and: [ aContext ~= self process suspendedContext or: [ aContext willReturn not ] ] ]breadcrumbItemLabelWidgetStyleFor: aBrick  aBrick     color: self breadcrumbItemBackgroundColor;     textColor: self breadcrumbItemTextColorreceiver  ^self debuggerdefaultStep  ^GTMockSpotterStep newsearchFieldMarginLeft  ^20gtIterator  ^selftestInstanceCreationSmokeTest  self shouldnt: [ spotter := GTMockSpotter new ] raise: ErrorresultsPaneWidth  ^100gtDisplaySpotterMorphOn: aComposite  < gtInspectorPresentationOrder: 50>  aComposite morph     title: 'Live';     display: [ GLMBrick new           hSpaceFill;           vSpaceFill;           addMorphBack: (GTSpotterMorph new spotterModel: self);           yourself ]itemIcon  ^itemIconBlockkey  ^self slot nameinitialize  super initialize.  cache := self defaultCache.  text := self defaultText.  continuing := self defaultContinuinginitialize  super initialize.  self needsUpdate: falsedoApplyFilterWithQuery  | unorderedMatchedItems |  unorderedMatchedItems := OrderedCollection new.  self allItemsDo: [:each |  (self isMatchedItem: each) ifTrue: [ unorderedMatchedItems add: each.              self addItem: each.              unorderedMatchedItems size = self itemsLimit ifTrue: [ GTLimitArrived signal ] ] ].  self filteredItems: unorderedMatchedItemstitleTextColor  ^self themer textLightColormethodsIn: a  ^a list     title: 'Methods';     display: [:object :class |  class methods collect: #asRingDefinition ];     filterOn: [:text :each |  text , '*' match: each selector ];     helpMessage: 'Wildcard filtering (e.g., "*pattern*")';     tags: [:method |  method category ];     sorted: [:method1 :method2 |  method1 selector < method2 selector ];     format: [:method |  method selector ];     morphicSelectionAct: [:list :object :class |  Smalltalk tools browser openOnClass: class selector: list selection selector ] icon: GLMUIThemeExtraIcons glamorousBrowse on: $b entitled: 'Browse';     dynamicActionsOnSelection: [:list |  self methodActionsFor: list selection ]tearDown  a := nil.  super tearDowndetect: aBlock ifNone: aBlock2  ^self detect: aBlock ifFound: [:each |  each ] ifNone: aBlock2pushStep: stepModel  self addStep: stepModel.  self currentStep: stepModelassertNoExceptions  self assertEmpty: self class exceptions.  self assertEmpty: self class fatalsopenSettingsBrowser  GLMPrivacyAgreementBrick openSettingsBrowser.  self spotterModel exitDueTo: #openSettingsBrowserbrowseMessages  self currentMessageName ifNotNil: [ self systemNavigation browseAllImplementorsOf: self currentMessageName ]removeCacheAt: aSymbol  ^self cache removeKey: aSymbol ifAbsent: [ nil ]isEmpty  ^self text isNil or: [ self textTrimmed isEmpty ]diveInDueTo: anEventType  self spotterModelDo: [:aSpotter |  aSpotter hasSelected ifTrue: [ aSpotter currentStep diveInDueTo: anEventType ] ]highlightQuery  self labelBrick label highlight: self stepModel context textshiftPressed: aBoolean  self isShiftPressed = aBoolean ifTrue: [ ^self ].  isShiftPressed := aBoolean.  self isShiftPressed ifTrue: [ self notifyRevealHints ] ifFalse: [ self notifyHideHints ]allPresentationMethods  ^(PragmaCollector allSystemPragmas select: [:pragma |  pragma key == self inspectorPragmaKey ]) collect: [:aPragma |  aPragma method ]previousProcessorFrom: aCollection  aCollection do: [:each |  each asSpotterCandidateLink processor ifNotNil: [ ^each processor ] ].  ^GTSpotterCandidatesListProcessor new     title: 'Items';     filter: GTFilterSubstring;     yourselfspotterUsersFor: aStep  < spotterOrder: 50>  ^aStep listProcessor     title: 'Senders';     filter: GTFilterSubstring item: [:filter :context |  self senders do: [:sender |  filter value: sender compiledMethod ] ];     keyBinding: $n metastepScrollPageUp  self spotterModel currentStep announcer announce: GTSpotterScrollPageUp newtestDebuggingExceptionHandlerMock5  self assertResetExceptions.  self shouldntRaise: AssertionFailure process: 'abc' origin: GTSpotterExceptionMock5 new during: GTSpotterDebuggingExceptionHandlerMock new.  self assertNoExceptionspreviousText  ^self previous ifNil: [ '' ] ifNotNil: [ self previous text ]asGlamourAction  | actionBlock |  actionBlock := glamourAction action.  ^glamourAction action: [:presentation :entity |  self precondition ifTrue: [ self preAction.              actionBlock cull: presentation cull: entity.              self postAction ] ]restoreSettings  | currentPane presentationTitle |  presentationTitle := self debugger cache at: #activePresentationTitle ifAbsent: [ ^self ].  currentPane := self presentations first paneNamed: #main.  currentPane presentations presentations detect: [:each |  each title = presentationTitle ] ifFound: [:lastActivePresentation |  currentPane lastActivePresentation: lastActivePresentation ]contextMenuPragma  ^#playgroundContextMenuactOnBrowserClosing: ann  self entity saveContent: self first panes first presentations first text.  GTPlayBook instance addPageIfInteresting: self entityactLogic  ^actBlockdefaultLabel  ^'Jump to test method'classesIn: a  ^a fastList     title: 'Class Hierarchy';     display: [:object |  | all |        all := OrderedCollection new.        object class withAllSuperclassesDo: [:each |  all add: each ].        all ];     format: [:class |  class name ];     enableFilter;     morphicSelectionAct: [:list |  Smalltalk tools browser openOnClass: list selection ] icon: GLMUIThemeExtraIcons glamorousBrowse on: $b entitled: 'Browse'formatBytecode: aBytecode  | textAttributes |  textAttributes := {(TextColor new color: self theme textColor)}.  self selectedContext pc = aBytecode offset ifTrue: [ textAttributes := {(TextColor new color: self theme textColor) .         TextEmphasis italic} ].  self selectedContext pc > aBytecode offset ifTrue: [ textAttributes := {(TextColor new color: Color gray)} ].  ^Text string: aBytecode printString attributes: textAttributesrenderTriangle: aBrick on: aCanvas with: aCollection  self renderTriangle: aBrick on: aCanvas with: aCollection color: (aBrick currentColor ifNil: [ aBrick color ])configurationBlockForProcessorsCreatedBy: aMethod  self subclassResponsibilityiconAct  ^self iconNamed: #glamorousAcceptafter: afterBlock do: doBlock with: withBlock  | value |  value := withBlock brickValue: self.  afterBlock brickValue: self.  doBlock brickValue: valuedefaultLabel  ^'Debug it'stepModel: anObject  stepModel := anObjectshouldntRaise: anError process: aString origin: anOrigin during: exceptionHandler  spotter exceptionHandler: exceptionHandler.  self assert: spotter exceptionHandler identicalTo: exceptionHandler.  self shouldnt: [ self process: aString origin: anOrigin ] raise: anError.  self assert: spotter exceptionHandler identicalTo: exceptionHandlerdoApplyFilterWithQuery  self subclassResponsibilityinitialize  super initialize.  self     hSpaceFill;     with: [:label |  label when: #onAccepted do: [ self announce: #accepted event: label text ] ];     cancelOnEscape;     cancelOnFocusLost;     with: [:b |  b margin: {b themer focusedBorderWidth .               0} ];     with: [:b |  b editBrick           hShrinkWrap;           rubricBackgroundColor: b themer rubricBackgroundColor;           margins: (self defaultPadding @ 0) asMargin ];     with: [:b |  b maxWidth: [ b approximateWidth + b owner hPadding ] ];     with: [:b |  b labelBrick margin: {0 .               (self defaultPadding + 2) .               0 .               self defaultPadding} ];     with: [:b |  b layout widthDependency: [ b owner ] ];     with: [:b |  b editBrick layout widthDependency: [ b ] ];     yourselfdoFilterInContext: aSpotterContext  ^aSpotterContext doFilter: filterBlock gtFilter forProcessor: selfcategoryTitleStyleFor: aBrick  aBrick     useHorizontalLinearLayout;     height: 30;     hSpaceFill;     paddingLeft: self categoryNameMarginLeftcontext: aContext  context := aContext.  self resetrawValue  ^valueisAbove: aBrick  ^aBrick globalOuterBounds origin <= self allowedBounds originamountBrick  ^amountBrickkeymapToggle  < shortcut>  ^KMKeymap shortcut: Character cr shift action: [ self class openGlobalSpotter ]spotterForDirectoriesFor: aStep  < spotterOrder: 50>  self flag: #specialFilter.  aStep listProcessor     title: 'Directories';     itemIcon: [ GLMUIThemeExtraIcons glamorousFolder ];     itemFilterName: [:reference |  reference basename ];     filter: GTFilterFileReference item: [:filter :context |  self fileReferencesBy: #directories inContext: context usingFilter: filter ];     wantsToDisplayOnEmptyQuery: falsetitleFamilyName  ^'Open Sans'assertProcessorIncludes: anObject  self assert: anObject notNil.  self assert: currentProcessor notNil.  self assert: currentProcessor allFilteredCandidates notEmpty.  self assert: (currentProcessor allFilteredCandidates anySatisfy: [:candidate |  candidate = anObject ])select: aCandidateLink dueTo: anEventType  self assert: [ aCandidateLink isNotNil ] description: [ 'Candidate link must not be nil' ].  self assert: [ aCandidateLink processor isNotNil ] description: [ 'Candidate must have assigned category (processor)' ].  (self isSelected: aCandidateLink) ifTrue: [ ^self ].  self spotter after: [ selected := aCandidateLink.        self notifySelectedCandidateChanged: aCandidateLink for: anEventType ] do: [ self spotter notifyCategorySelected: self selected processor ] ifTrue: [ (self isCategorySelected: aCandidateLink processor) not ]selectPreviousCandidateDueTo: anEventType  self spotterModel hasSelected ifTrue: [ self spotterModel currentStep selectPreviousDueTo: anEventType ]streamed  ^streamedselectNextDueTo: anEventType  self select: self selected next dueTo: anEventTypegtDisplayOn: stream  stream nextPutAll: self nameactOnInspectorPaneRemoved: ann  ann browser panes size == 1 ifTrue: [ self selectedVariableName: nil ]moveTo: anItemBrick  | itemBounds delta selfBounds |  anItemBrick ifNil: [ ^self ].  itemBounds := anItemBrick globalBounds.  selfBounds := self globalBounds.  delta := (itemBounds top - selfBounds top max: 0) min: selfBounds height - self triangleBrick height.  self triangleBrick brickBounds top = delta ifTrue: [ ^self ].  self triangleBrick marginTop: delta.  self triangleBrick doLayoutForce.  self owner changedprintString  1 / 0defaultContinueItemsLimit  ^100presenterAt: aName  ^self basicPresenters at: aNameaddSignatureFor: aMethod  | signature |  signature := self signatureFor: aMethod.  (allMethodSignatures includes: signature) ifFalse: [ allMethodSignatures add: signature ]isMatchedItem: anItem  ^falsespotterPragmasFor: aStep  < spotterOrder: 40>  ^aStep listProcessor     title: 'Pragmas';     allCandidates: [ self pragmas ];     itemName: [:pragma |  pragma method printString , ' ' , pragma asString ];     filter: GTFilterSubstringcontext  ^context ifNil: [ context := self newContextForQuery: nil ]processors: anObject  processors := anObjectdefaultIcon  ^niltitle  self subclassResponsibilityprintStringOf: anObject  ^[ ((anObject class == Array ifTrue: [ self printArray: anObject ] ifFalse: [ anObject printString ]) contractTo: 200) asComment ] on: Error do: [ '"Error printing. Try self printString to debug"' ]prepareFilterInContext: aSpotterContext  super prepareFilterInContext: aSpotterContext.  caseSensitive ifNil: [ caseSensitive := self defaultCaseSensitive ].  self query: (caseSensitive ifTrue: [ self context textTrimmed ] ifFalse: [ self context textLowercase ])defaultText  ^''do: aBlock  items ifNotNil: [ items do: aBlock ] ifNil: [ items := self defaultItems.        self itemDo: [:each |  items add: each.              aBlock value: each ] ]hidePreview  self spotterModel hidePreviewid  ^#gTInspectSelectionDebugActionterminateProcessors  self asyncTask terminateonStepAdded: ann  | step origin previousStep selectedCandidate |  self spotterModel steps size <= 1 ifTrue: [ ^self push: (GTSpotterStepBreadcrumbItem new                 text: self spotterModel steps first origin gtDisplayString;                 stepModel: self spotterModel steps first) ].  step := ann stepModel.  previousStep := step spotter steps at: step spotter steps size - 1.  selectedCandidate := previousStep selected candidate.  origin := step origin.  self push: (GTSpotterStepBreadcrumbItem new           stepModel: step;           text: (selectedCandidate = origin ifTrue: [ (previousStep selected renderingProcessor render: selectedCandidate) labelBrick text ] ifFalse: [ (origin isKindOf: Collection) ifTrue: [ step processors first title ] ifFalse: [ origin gtDisplayString ] ]))defaultTextLowercase  ^self textTrimmed asLowercaseremoveIcon  ^GLMUIThemeExtraIcons glamorousRemoveconfigureProcessorsStartingAt: anIndex with: aConfigurationBlock  anIndex > self processors size ifTrue: [ ^self ].  anIndex to: self processors size do: [:processorIndex |  aConfigurationBlock value: (self processors at: processorIndex) ]spotterPreviewArrowContainerStyleFor: aBrick  aBrick     useVerticalLinearLayout;     vSpaceFill;     width: self previewArrowWidth;     margin: {(self headerHeight + self innerBorderWidth + self previewBorderWidth) .         0 .         self previewBorderWidth .         self previewArrowGapHack negated}.  aBrick layout zIndex: 4beDeployment  self exceptionHandler: GTSpotterDeploymentExceptionHandler newhelp  ^'Select in the stack the context containing the test method.'inspectorIn: aComposite  ^aComposite dynamic display: [:anObject |  self inspectorIn: GLMCompositePresentation new on: anObject ]equals: aContext  aContext ifNil: [ ^false ].  ^self matches: aContext searchcompose  self class enableDebuggerWindowDistinctColor ifTrue: [ self color: (Color r: 1.0 g: 0.3 b: 0.3) ].  self installDebuggingActionsFor: self.  self tabulator with: [:browser |  self debuggerStructureIn: browser.        self debuggerTransmissionsIn: browser ].  self registerActionshideActionbar  self shouldShowActionbar ifTrue: [ ^self ].  self actionbarBrick visible: falsevalue: aSpotterContext  ^[ [ self applyFilterInContext: aSpotterContext ] on: Error do: [:exception |  self exceptionHandler handleException: exception do: [ self applyFilterInContext: aSpotterContext error: exception ] ] ] ensure: [ context := nil ]stepToFirstInterestingBytecodeIn: aProcess  ^aProcess suspendedContextgtListFilter  ^GTFilterSubstring newonRemovedFrom: aBrick  super onRemovedFrom: aBrick.  self stepModel spotter announcer unsubscribe: self.  self stepModel announcer unsubscribe: self.  self stepModel candidates announcer unsubscribe: selfitemIconFor: anObject  ^nildiveInButton  ^diveInButtonnewAs: aCollectionClass  ^items ifNil: [ aCollectionClass new ] ifNotNil: [ aCollectionClass new: self size ]contentsBrick: aBrick  contentsBrick ifNotNil: [ self removeBrick: contentsBrick ].  contentsBrick := aBrick.  self themer spotterThemer spotterContentsStyleFor: contentsBrick.  self addBrickBack: contentsBrickfilterUsing: aFilter  self filter: aFilterarrowBrick  ^arrowBrickhistorize: target  (target = self or: [ target isNil ]) ifFalse: [ self history removeAllSuchThat: [:each |  each value = target value ].        self history addFirst: target ]testshouldSpotterIgnoreProcessorDefinedInMethod  spotterModel  ^spotterModeltestPreviousA1A2EmptyCategory  | link11 link12 link13 category1 category2 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  link11 := candidates addCandidate: 11 in: GTSpotterA1.  link12 := candidates addCandidate: 12 in: GTSpotterA1.  link13 := candidates addCandidate: 13 in: GTSpotterA1.  self assert: category1 equals: (candidates previousProcessorLinkOf: category1).  self assert: category1 equals: (candidates previousProcessorLinkOf: category2)testContextChange  self assertSearch: 'a'.  self assert: previousContext text equals: ''.  self denySearch: 'a'.  self assertSearch: 'ab'.  self assert: previousContext text equals: 'a'.  self denySearch: 'ab'.  self assertSearch: 'abc'.  self assert: previousContext text equals: 'ab'.  self denySearch: 'abc'.  self assertSearch: 'ab'.  self assert: previousContext text equals: 'abc'.  self denySearch: 'ab'.  self assertSearch: 'a'.  self assert: previousContext text equals: 'ab'.  self denySearch: 'a'.  self assertSearch: ''.  self assert: previousContext text equals: 'a'.  self flag: 'because the decision for triggering a search is made in multiple places, an empty input will always trigger a search - this should be simplified - one place to make the decision GTSpotter>>#setText:from: <-> #Context>>#matches:'.  self assertSearch: ''.  self assertSearch: ''diveInDueTo: anEventType  self canDiveInSelectedCandidate ifTrue: [ self spotter           historize: self selected;           requestNextStepWith: self selected candidate for: #diveIn;           notifyDiveIn: self selected candidate for: anEventType ]asNonTruncatedTextFrom: anObject  ^self class asNonTruncatedTextFrom: anObjecttestRemoveCandidatesA1A2A3FromA1A2A3  | category1 category2 category3 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  category3 := candidates addProcessor: GTSpotterA3.  candidates addCandidate: 11 in: GTSpotterA1.  candidates addCandidate: 12 in: GTSpotterA1.  candidates addCandidate: 13 in: GTSpotterA1.  candidates addCandidate: 21 in: GTSpotterA2.  candidates addCandidate: 22 in: GTSpotterA2.  candidates addCandidate: 23 in: GTSpotterA2.  candidates addCandidate: 31 in: GTSpotterA3.  candidates addCandidate: 32 in: GTSpotterA3.  candidates addCandidate: 33 in: GTSpotterA3.  candidates removeAllCandidatesOf: GTSpotterA1.  candidates removeAllCandidatesOf: GTSpotterA3.  candidates removeAllCandidatesOf: GTSpotterA2.  self assert: candidates head equals: nil.  self assert: candidates tail equals: nil.  self assert: category1 headLink equals: nil.  self assert: category1 tailLink equals: nil.  self assert: category2 headLink equals: nil.  self assert: category2 tailLink equals: nil.  self assert: category3 headLink equals: nil.  self assert: category3 tailLink equals: niltext  ^text ifNil: [ text := '' asText ]session  ^self debugger sessiontestDeploymentExceptionHandlerMock4  self assertResetExceptions.  self shouldntRaise: ArithmeticError process: 'abc' origin: GTSpotterExceptionMock4 new.  self assertException: ArithmeticError.  self assertResetExceptions.  self shouldntRaise: Error process: 'abc' origin: GTSpotterExceptionMock4 new.  self assertException: ArithmeticErrorelement: anObject  element := anObjectspotterForCachedPlaygroundPagesFor: aStep  < spotterOrder: 100>  aStep listProcessor     allCandidates: [ GTPlayBook instance pages ];     title: 'Playground cached pages';     itemName: [:page |  page content asString contractTo: 100 ];     filter: self defaultFilterClassonCandidateSelected: ann  | processor categoryBrick itemBrick titleBrick scrollTo |  processor := ann itemBrick processor.  categoryBrick := self categoryBrickOf: processor ifAbsent: [ ^self ].  itemBrick := ann itemBrick.  titleBrick := categoryBrick titleBrick.  scrollTo := (itemBrick candidateLink isFirst and: [ titleBrick isFirstInOwner ]) ifTrue: [ titleBrick ] ifFalse: [ itemBrick ].  self scrollTo: scrollToselectPreviousDueTo: anEventType  self select: self selected previous dueTo: anEventTypeimplementors: aSelector inPackages: anArray  | implementors |  implementors := OrderedCollection new.  RPackageOrganizer default packages do: [:package |  anArray do: [:packageName |  package packageName = packageName ifTrue: [ package methods do: [:cm |  cm selector = implementors ifTrue: [ implementors add: cm ] ] ] ] ].  ^implementorsfileOutMessage  self currentMessageName ifNotNil: [ Cursor write showWhile: [ self currentClassOrMetaClass fileOutMethod: self currentMessageName ] ]filteredItems  ^filteredItemsonThemerChanged  super onThemerChanged.  self themer spotterThemer spotterPreviewArrowWidgetStyleFor: self triangleBrickdefaultItemsClass  ^OrderedCollectiondoIt  | result |  Smalltalk compiler silentlyDo: [ result := Smalltalk compiler evaluate: text string trimBoth ] exceptionDo: [:ex |  ^ex ]testPreviousA1A2Category  | link11 link12 link13 link21 link22 link23 category1 category2 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  link11 := candidates addCandidate: 11 in: GTSpotterA1.  link12 := candidates addCandidate: 12 in: GTSpotterA1.  link13 := candidates addCandidate: 13 in: GTSpotterA1.  link21 := candidates addCandidate: 21 in: GTSpotterA2.  link22 := candidates addCandidate: 22 in: GTSpotterA2.  link23 := candidates addCandidate: 23 in: GTSpotterA2.  self assert: category1 equals: (candidates previousProcessorLinkOf: category2).  self assert: category2 equals: (candidates previousProcessorLinkOf: category1)browseReceiver  self currentContext receiver class ifNotNil: [:instance |  Smalltalk tools browser openOnClass: instance ]text  ^textcreationTime  ^creationTimeinitialize  super initialize.  allMethodSignatures := OrderedCollection new.  selectedMethodSignatures := OrderedCollection newbuildItemFor: aCandidateLink in: aProcessor  | itemBrick |  itemBrick := (aCandidateLink renderingProcessor render: aCandidateLink value)     candidateLink: aCandidateLink;     stepModel: self stepModel;     yourself.  ^itemBrickmethodCodeIn: composite forContext: aContext  (self methodCodeWidgetIn: composite forContext: aContext) with: [:code |  self installCodeActionsFor: code ]showPreview  self isPreviewShown ifTrue: [ ^self ].  self addBrickBack: self previewBrick.  self previewBrick spotterModel ifNotNil: [:aSpotter |  aSpotter hasSelected ifTrue: [ self previewBrick updatePreviewWith: aSpotter currentStep selected candidate ] ].  self contentsBrick hSpaceFill: 100 - self previewBrick layout hPercent.  self changedborderColor  ^Color r: 180 g: 180 b: 180 range: 255addCategories: aCollection  aCollection do: [:each |  candidates addProcessor: each ]initialize  super initialize.  self contentsBrick: self newContentsBrick.  self arrowBrick: self newArrowBrick.  self previewBrick: self newPreviewBrickupdateBrowserFrom: anAnnouncement  anAnnouncement action needsUpdate ifTrue: [ self updateBrowser ].  self announcer announce: (GTDebuggerBrowserUpdateRequest from: anAnnouncement)senders: aSelector inPackages: anArray  | senders |  senders := OrderedCollection new.  RPackageOrganizer default packages do: [:package |  anArray do: [:packageName |  package packageName = packageName ifTrue: [ package methods do: [:cm |  (cm refersToLiteral: aSelector) ifTrue: [ senders add: cm ] ] ] ] ].  ^sendersindexForItemName: aString andQuery: aQueryString  ^aString findString: aQueryString startingAt: 1 caseSensitive: self caseSensitiveautoHide: aBoolean  autoHide := aBooleanexecuteAction  self debugger inspect: self debugger bytecodePresentation selectionpopStep  self steps size > 1 ifTrue: [ self after: [ self steps removeLast ] do: [:o |  self notifyDiveOut: o ] with: self currentStep origin.        self notifyStepPopped.        self pagerModel scrollToPane: self steps size callback: [ self pagerModel popPane: false ] ]closeSpotter  self autoHide ifTrue: [ self delete ]breadcrumbSeparatorLineWidth  ^2spotterForClassesFor: aStep  < spotterOrder: 10>  aStep listProcessor     allCandidates: [ Smalltalk allClassesAndTraits ];     title: 'Classes';     filter: self defaultFilterClass;     itemIcon: #systemIcon;     keyBinding: $b meta;     wantsToDisplayOnEmptyQuery: falseusers  ^(self keyword senders collect: [:each |  each compiledMethod ]) \ (self pragmas collect: [:each |  each method ])initialize  super initialize.  self needsUpdate: false.  shouldBasicInspect := falserenderBottomTriangle: aBrick on: aCanvas  | a b c width height |  width := aBrick brickBounds width.  height := aBrick brickBounds height.  a := aBrick brickBounds topLeft + ((width / 2 - height max: 0) @ 0).  b := aBrick brickBounds topLeft + ((width / 2 + height min: width) @ 0).  c := aBrick brickBounds bottomLeft + ((width / 2) @ 0).  self renderTriangle: aBrick on: aCanvas with: {a asIntegerPoint .         b asIntegerPoint .         c asIntegerPoint}showActionsOf: aRowBrick  aRowBrick subbricks select: [:each |  each isKindOf: GLMHintableActionButtonBrick ] thenDo: [:each |  each visible: true ]shouldEnableProcessorsCreateBy: aMethod  ^(GTSpotterExtensionSettings shouldSpotterIgnoreProcessorDefinedInMethod: aMethod) notstepModel  ^stepModelassertText: aTextualObject  self assertText: aTextualObject do: nilhelp  ^'Print the result of a selected piece of code from the code pane of the debugger.'post: string  | entity client url |  entity := ZnEntity text: string asString.  (client := self httpClient)     entity: entity;     post.  url := client response location.  ^url asZnUrl inContextOf: self urlProvideraddDiveInActionButton  (self stepModel canDiveIn: self candidate) ifTrue: [ diveInButton := self newActionButtonBrick           icon: self themer spotterThemer iconDiveIn;           hintTitle: 'Dive in';           hintText: '<' , OSPlatform current defaultModifier name asLowercase , '+right>';           action: [ self owner beSelected.              self stepModel diveInDueTo: #actionButton ];           yourself.        self addActionButton: diveInButton ]itemIconStyleFor: aBrick  self flag: 'figure out why alpha doesn''t work'.  aBrick     width: self itemIconMaxWidth;     vSpaceFillnewIconBrick  ^GLMInteractableBrick new normalImage: ((Form extent: 16 @ 16 depth: 32) fillAlpha: 0)origin: anObject  origin := anObjecticonDiveInCategory  ^self iconNamed: #glamorousDiveAllRightIcondefaultOrder  ^200basicVariableNodesFor: anObject in: aCollection  self subclassResponsibilityitemActionSelectedBackgroundColor  ^self itemSelectedBackgroundColor darkerexitDueTo: anEventType  self notifySpotterExitFor: anEventTypestepModel: anObject  stepModel := anObjectheaderStyleFor: aBrick  aBrick     hSpaceFill;     height: self headerHeightorientation  ^orientation ifNil: [ #bottom ]initialize  super initialize.  border := 0.  borderColor := Color transparentinstallActionsForRootPragmas: aSymbolsCollection in: aPresentation  aPresentation dynamicActions: [:presentation |  self actionsForPragmas: (aSymbolsCollection collect: [:aSymbol |  #gt , aSymbol capitalized ]) ].  aPresentation dynamicActionsOnSelection: [:presentation |  self actionsForPragmas: (aSymbolsCollection collect: [:aSymbol |  #gtContext , aSymbol capitalized ]) ]slot  ^slottestAddThreeCandidateA1A2A3  | link11 link12 link13 link21 link22 link23 link31 link32 link33 category1 category2 category3 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  category3 := candidates addProcessor: GTSpotterA3.  link11 := candidates addCandidate: 11 in: GTSpotterA1.  link12 := candidates addCandidate: 12 in: GTSpotterA1.  link13 := candidates addCandidate: 13 in: GTSpotterA1.  link21 := candidates addCandidate: 21 in: GTSpotterA2.  link22 := candidates addCandidate: 22 in: GTSpotterA2.  link23 := candidates addCandidate: 23 in: GTSpotterA2.  link31 := candidates addCandidate: 31 in: GTSpotterA3.  link32 := candidates addCandidate: 32 in: GTSpotterA3.  link33 := candidates addCandidate: 33 in: GTSpotterA3.  self assert: link11 nextLink equals: link12.  self assert: link11 previousLink equals: link33.  self assert: link12 nextLink equals: link13.  self assert: link12 previousLink equals: link11.  self assert: link13 nextLink equals: link21.  self assert: link13 previousLink equals: link12.  self assert: link21 nextLink equals: link22.  self assert: link21 previousLink equals: link13.  self assert: link22 nextLink equals: link23.  self assert: link22 previousLink equals: link21.  self assert: link23 nextLink equals: link31.  self assert: link23 previousLink equals: link22.  self assert: link31 nextLink equals: link32.  self assert: link31 previousLink equals: link23.  self assert: link32 nextLink equals: link33.  self assert: link32 previousLink equals: link31.  self assert: link33 nextLink equals: link11.  self assert: link33 previousLink equals: link32.  self assert: candidates head equals: link11.  self assert: candidates tail equals: link33.  self assert: category1 headLink equals: link11.  self assert: category1 tailLink equals: link13.  self assert: category2 headLink equals: link21.  self assert: category2 tailLink equals: link23.  self assert: category3 headLink equals: link31.  self assert: category3 tailLink equals: link33previewPaddingLeft  ^self previewArrowWidth * 1.2filterByMethods: aCollection  | filter |  filter := GTInspectorMethodListFilter new.  aCollection do: [:aMethod |  filter addAndSelectSignatureFor: aMethod ].  self presentationFilter: filterreceiver: anObject  receiver := anObjectfileReferenceOrNil  self fileDirectory ifNil: [ ^nil ].  ^self fileDirectory / self fileNameweight: anObject  weight := anObjectcompose  self title: 'Meta'.  self tabulator with: [:browser |  browser           row: [:r |  r                 column: #classes;                 column: #methods span: 3 ];           row: #source.        browser transmit           to: #classes;           andShow: [:a |  self classesIn: a ].        browser transmit           to: #classes port: #selection;           transformed: [:each |  each class ].        browser transmit           fromOutsidePort: #entity;           from: #classes;           to: #methods;           andShow: [:a |  self methodsIn: a ].        browser transmit           from: #methods;           fromOutsidePort: #entity;           to: #source;           when: [:method |  method notNil ];           andShow: [:a :method :object |  self sourceOf: method for: object in: a ].        browser transmit           toOutsidePort: #selection;           from: #methods port: #evaluatedObject.        browser transmit           toOutsidePort: #selection;           from: #source port: #evaluatedObject ]printStringOf: anObject  self subclassResponsibilitydiveInCategoryDueTo: anEventType  self diveInCategory: self selected processor dueTo: anEventTypesetText: aText from: aView  self steps isEmpty ifTrue: [ self addStep: (self newStep origin: self foundationOrigin) ].  (aText asString isEmpty and: [ self text isEmpty not ]) ifTrue: [ self currentStep process: nil ] ifFalse: [ self currentStep process: aText asString ].  text := aText asString asText.  ^truecandidates  ^candidates ifNil: [ candidates := DoubleLinkedList new ]itemIconAlphaValue  ^0.5stream: anObject  stream := anObjectcategory  ^categorynameBrick: aBrick  nameBrick ifNotNil: [ self removeBrick: nameBrick ].  nameBrick := aBrick.  self themer spotterThemer categoryTitleNameStyleFor: nameBrick.  self addBrickBack: nameBrickisCategorySelected: aProcessor  < return: #Boolean>  ^self hasSelected and: [ self selected processor == aProcessor ]defaultOrder  ^260increaseZindex: aBrick  aBrick layoutProperties zIndex: 2queryForItem: each  ^queryhandleException: anException do: aBlock  ^aBlock valuecategoryNameMarginRight  ^10testFloatPairs  | pairs |  pairs := 4.2 gtInspectorVariableValuePairs.  self assert: pairs size equals: 2.  self assert: pairs first equals: '1' -> 1074842828.  self assert: pairs second equals: '2' -> 3435973837testContext  ^testContextclear  self     headLink: nil;     tailLink: nil.  size := 0cache  ^cacheeventType  ^eventTypenewSettingsButton  ^GLMHintableActionButtonBrick newnotifyCategorySelected: aProcessor  self announce: (GTSpotterCategorySelected new category: aProcessor)rawValue  ^self hostObject readSlot: slotheadLink: anObject  headLink := anObjectcategoryBrickOf: aProcessor  < return: #GTSpotterCategoryBrick>  < throws: #Error when: 'Category for aProcessor does not exist'>  ^self categories at: aProcessor ifAbsent: [ Error signal: 'Category for ' , aProcessor asString , ' does not exist' ]keyword  ^keywordspotterPreviewIn: aComposite  < spotterPreview: 10>  aComposite list     title: 'Preview';     display: [:x |  x ];     format: [:method |  GTSpotterItemBrick new           text: method gtDisplayString;           disable;           yourself ];     entity: self implementorscaseSensitive  ^caseSensitiveexecuteAction  self codePresentation profileSelectiontestArrayPairsLong  | limit pairs |  limit := 3 * GTInspector indexableDisplayLimit.  pairs := (1 to: limit) asArray gtInspectorVariableValuePairs.  self assert: pairs size equals: 2 * GTInspector indexableDisplayLimit.  (pairs collect: #key) allSatisfy: [:e |  (pairs at: e) = e ].  self assert: (pairs collect: #key) equals: ((1 to: GTInspector indexableDisplayLimit) asOrderedCollection           addAll: (limit - GTInspector indexableDisplayLimit + 1 to: limit) asOrderedCollection;           yourself)setUp  super setUp.  spotter := GTMockSpotter new.  self shouldnt: [ spotter setText: '' from: self ] raise: Error.  currentStep := currentProcessor := currentCandidate := nilitemsLimit  ^self processor itemsLimitrawValue  ^self hostObject basicAt: indexonThemerChanged  super onThemerChanged.  self themer spotterThemer spotterContentsWidgetStyleFor: selfpaneBrick: aBrick  paneBrick ifNotNil: [ self removeBrick: paneBrick ].  paneBrick := aBrick.  self themer spotterThemer spotterPaneStyleFor: paneBrick.  self addBrickBack: paneBrickselectNextCandidateDueTo: anEventType  self spotterModel hasSelected ifTrue: [ self spotterModel currentStep selectNextDueTo: anEventType ]addTag: aSymbol  (allTags includes: aSymbol) ifFalse: [ allTags add: aSymbol ]initialize  super initialize.  self needsUpdate: falsedeltaTop: aBrick  ^self allowedBounds origin y - aBrick globalOuterBounds origin yitemName  ^itemNameBlocktestDebuggingExceptionHandlerMock2  self shouldRaise: MessageNotUnderstood process: 'abc' origin: GTSpotterExceptionMock2 newspotterClipboardFor: aStep  < spotterOrder: 90>  ^aStep listProcessor     title: 'Clipboard History';     items: [ Clipboard default recentItems ];     itemName: [:item |  item asString contractTo: 100 ];     itemFilterName: [:item |  item asString ];     filter: self defaultFilterClass;     actLogic: [:item :step |  step exit.        item asString inspect ];     wantsToDisplayOnEmptyQuery: falsecloseButton  ^closeButtondoFilterInContext: aSpotterContext  ^aSpotterContext doFilter: GTFilterBlock gtFilter forProcessor: selfbreadcrumbHeight  ^26addItems: aCollectionOfItems  self addAllBricks: aCollectionOfItemsresultsPaneStyleFor: aBrick  aBrick     hSpaceFill: self resultsPaneWidth;     vSpaceFill;     with: [:b |  b band layout: GTSpotterStackedLayout new ]itemIconAlphaValue  ^0.8getProcessorLinkByCandidateLink: aCandidateLink  ^aCandidateLink processorLinkisEmpty  self deprecated: 'Use hasSteps instead'.  ^self hasSteps notcontinueFilter  | processors nonEmptyProcessors |  processors := self cache at: #processorsAndFilters ifAbsent: [ ^self ].  nonEmptyProcessors := processors associations select: [:assoc |  assoc key hasFilteredCandidates ].  nonEmptyProcessors size = 1 ifFalse: [ ^self ].  self canContinue ifFalse: [ ^self ].  self withContinue: true do: [ nonEmptyProcessors do: [:assoc |  assoc key continueFilterInContext: self ] ]variablesIn: aComposite  ^(super variablesIn: aComposite) sorted: nilselectedItemBrick: aBrick  selectedItemBrick isNil & aBrick isNotNil ifTrue: [ self showTriangle ].  selectedItemBrick isNotNil & aBrick isNil ifTrue: [ self hideTriangle ].  selectedItemBrick := aBrickspotterWorldMenuFor: aStep  < spotterOrder: 9>  ^(self currentWorld worldMenu spotterItemsFor: aStep)     candidatesLimit: 15;     allCandidates: [ self currentWorld worldMenu allItems ];     title: 'Menu'spotter  ^spottertestWithErrorInSetup  self assert: a equals: 41assertException: anErrorClass  self denyEmpty: self class exceptions.  self assert: (self class exceptions anySatisfy: [:e |  e class == anErrorClass ]).  self assertEmpty: self class fatalsorder  < return: #Number>  ^orderbasicPresenters  ^presenters ifNil: [ presenters := OrderedDictionary new ]childrenVariableNodesForNode: aNode  | variableNodes |  variableNodes := OrderedCollection new: aNode value class allSlots size.  variableNodes add: (GTInspectorWrapperNode hostObject: aNode label: 'self').  self basicVariableNodesFor: aNode value in: variableNodes.  ^variableNodesdefaultOrder  ^250inspectorDiffIn: aComposite  ^aComposite tabulator with: [:aTabulator |  aTabulator when: [ self session supportsDiff ].        aTabulator           column: #actual;           column: #expected.        aTabulator transmit           to: #actual;           andShow: [:anotherComposite |  anotherComposite dynamic display: [:anObject |  GTDebuggerInspector new startOn: self session actualResult ] ].        aTabulator transmit           to: #expected;           andShow: [:anotherComposite |  anotherComposite dynamic display: [:anObject |  GTDebuggerInspector new startOn: self session expectedResult ] ] ]compositeBrick  ^compositeBrickstackIn: composite  ^(self stackWidgetIn: composite) with: [:stackWidget |  self installStackDebuggingActionsFor: stackWidget ]newActionbarButton  ^GLMHintableActionButtonBrick newnotifySelectedCandidateChanged: aDoubleLink  self notifySelectedCandidateChanged: aDoubleLink for: #unknownpreviousProcessorLinkOf: aProcessorLink  | current |  aProcessorLink ifNil: [ ^aProcessorLink ].  current := aProcessorLink previousLink.  current ifNil: [ current := self processors tail ].  [ current = aProcessorLink ] whileFalse: [ current isEmpty ifFalse: [ ^current ].        current := current previousLink.        current ifNil: [ current := self processors tail ] ].  ^aProcessorLinkdropDownPaneStyleFor: aBrick  aBrick     layoutProperties: GLMBrickLayoutProperties new;     marginTop: self innerBorderWidth;     vSpaceFill;     hSpaceFillitemNormalBackgroundColor  ^Color transparentonCurrentStepChanged  self searchField rubric updateTextWith: self spotterModel currentStep context text.  self searchField rubric selectFrom: self searchField rubric text size + 1 to: self searchField rubric text sizeaddDiveInButton  diveInButton := self newActionbarButton.  self diveInButton     icon: self themer spotterThemer iconDiveInCategory;     pressedColor: (self themer spotterThemer itemActionSelectedBackgroundColor alpha: 0.5);     action: [ self stepModel diveInCategory: self category dueTo: #actionButton ];     beHelp;     hintTitle: 'Show all';     hintText: '<' , OSPlatform current defaultModifier name asLowercase , '+shift+right>'.  self pushActionButton: self diveInButtoninstallDebuggingActionsFor: aPresentation  self subclassResponsibilitydefaultLowerThreshold  ^0.33addAndSelectSignatureFor: aMethod  | signature |  signature := self signatureFor: aMethod.  (allMethodSignatures includes: signature) ifFalse: [ allMethodSignatures add: signature ].  (selectedMethodSignatures includes: signature) ifFalse: [ selectedMethodSignatures add: signature ]popPane: isSmooth  self flag: 'the spotter-model will not pop its step unless the UI allows it by this call - hmmmmm'.  self notifyPagePoped: nilstepModel: aModel  stepModel := aModel.  stepModel candidates announcer when: GTSpotterCandidateAdded send: #onCandidateAdded: to: self.  stepModel candidates announcer when: GTSpotterAllCandidatesRemoved send: #onAllCandidatesRemoved to: self.  stepModel candidates announcer when: GTSpotterAllCandidatesAdded send: #onAllCandidatesAdded: to: self.  stepModel candidates announcer when: GTSpotterCandidatesAmountChanged send: #onCandidatesAmountChanged: to: self.  stepModel announcer when: GTSpotterScrollPageDown send: #scrollPageDown to: self.  stepModel announcer when: GTSpotterScrollPageUp send: #scrollPageUp to: self.  stepModel announcer when: GTSpotterCandidateSelected send: #onCandidateSelected: to: selfkeymapProfileOneCycle  < shortcut>  ^KMKeymap shortcut: $u meta action: [ self class profileOneCycle ]exceptionHandler  self flag: 'Bloc -> overrides doesNotUnderstand discarding the current exception context'.  ^GTCurrentSpotterExceptionHandler value ifNil: [ self context exceptionHandler ]togglePreview  self spotterModel togglePrevieworigin  ^originsetAmountVisible: visible all: all  self titleBrick setAmountVisible: visible all: allscrollpaneBackgroundColor  ^self spotterThemer backgroundColorgtInspectorPragmasIn: composite  < gtInspectorPresentationOrder: 0>  composite list     title: 'Pragmas';     display: [ self pragmas ];     format: #gtDisplayStringinspect: anObject  ((self browser paneNamed: #inspector) port: #entity) silentValue: anObject.  (self browser paneNamed: #inspector) updaterubricBackgroundColor  ^self spotterThemer backgroundColorvalue: aSpotterContext  | currentExceptionHandler |  currentExceptionHandler := GTCurrentSpotterExceptionHandler value.  self assert: currentExceptionHandler notNil.  self assert: currentExceptionHandler == aSpotterContext exceptionHandler.  self assert: currentExceptionHandler == aSpotterContext step exceptionHandler.  self assert: currentExceptionHandler == aSpotterContext spotter exceptionHandler.  ^#('done')onDo  ^onDo ifNil: [ onDo := [:anItemBlock :aContext |   ] ]actualResult  ^actualResulticonDiveIn  ^self iconNamed: #glamorousDiveRightIconprocessors: aCollection  processors := aCollectionclose  self browser ifNotNil: [:aBrowser |  aBrowser close ]check  super check.  self showActionbar.  self notifySelectedcodePresentation  ^self debugger perform: self codePresentationSelectorassertDiveInCategory  self assertDiveIn: #diveInCategoryspotterForSendersFor: aStep  < spotterOrder: 31>  aStep listProcessor     title: 'Senders';     filter: GTNullFilter item: [:filter :context |  SystemNavigation default allSendersToString: context textTrimmed do: filter ];     keyBinding: $n meta;     wantsToDisplayOnEmptyQuery: falsebreadcrumbItemBackgroundColor  ^self borderColoronRemoveSelector  ^onRemoveSelectorsetBindings: aDictionary  self inspectorPresentation firstPresentation     variableBindings: [ aDictionary associations ];     updateVariableBindingsweight  ^weightbreadcrumbSeparatorWidgetStyleFor: aBrick  aBrick     color: self breadcrumbItemBackgroundColor;     borderColor: self breadcrumbSeparatorColor;     renderer: GTSpotterBreadcrumbSeparatorRenderer newtestAddTwoCandidateA1  | link1 link2 category |  category := candidates addProcessor: GTSpotterA1.  link1 := candidates addCandidate: 11 in: GTSpotterA1.  link2 := candidates addCandidate: 12 in: GTSpotterA1.  self assert: link1 nextLink equals: link2.  self assert: link1 previousLink equals: link2.  self assert: link2 nextLink equals: link1.  self assert: link2 previousLink equals: link1.  self assert: candidates head equals: link1.  self assert: candidates tail equals: link2.  self assert: category headLink equals: link1.  self assert: category tailLink equals: link2onLostFocus: event  focusedMorph ifNil: [ focusedMorph := event morph ]spotterModel: aSpotter  spotterModel := aSpotter.  spotterModel announcer when: GTSpotterExitAnnouncement send: #closeSpotter to: self.  spotterModel announcer when: GTSpotterShowPreview send: #onShowPreview to: self.  spotterModel announcer when: GTSpotterHidePreview send: #onHidePreview to: self.  self breadcrumbBrick spotterModel: spotterModel.  self paneBrick spotterModel: spotterModel.  spotterModel class isPreviewVisible ifTrue: [ spotterModel showPreview ].  self spotterModelDo: [ self spotterModel setText: '' from: nil.        self spotterModel currentStep process: nil ]withItemsLimit: aLimit do: aBlock  ^aBlock valueid  ^#gTSaveDebugActionprocessor: aProcessor isRelevantForQuery: aString  | trimmedProcessorTitle |  trimmedProcessorTitle := aProcessor title asLowercase copyReplaceAll: String space with: ''.  ^trimmedProcessorTitle beginsWith: aStringvalue  ^self itemsassertProcessorNotEmpty  self assert: currentProcessor notNil.  self deny: currentProcessor allFilteredCandidates isEmptycategory  ^categoryselectedColor  ^Color veryVeryDarkGray alpha: 0.1assertResetExceptions  self class reset.  self assertNoExceptionsdoApplyFilterWithQuery  self streamed ifTrue: [ | allItems |        self filteredItems: (allItems := OrderedCollection new).        self allItems withIndexDo: [:each :index |  allItems add: each.              self addItem: each.              index = self itemsLimit ifTrue: [ GTLimitArrived signal ] ] ] ifFalse: [ self filteredItems: self allItems.        self addItems: (self allItems first: (self itemsLimit min: self allItems size)) ]breadcrumbItemLabelStyleFor: aBrick  aBrick     textPosition: #center;     padding: {0 .         self outerBorderWidth};     vSpaceFill;     hSpaceFilllabel: aString  self title: aString.  self updatetestNextA1Category  | link11 link12 link13 category1 |  category1 := candidates addProcessor: GTSpotterA1.  link11 := candidates addCandidate: 11 in: GTSpotterA1.  link12 := candidates addCandidate: 12 in: GTSpotterA1.  link13 := candidates addCandidate: 13 in: GTSpotterA1.  self assert: category1 equals: (candidates nextProcessorLinkOf: category1)newStepsBand  ^GLMBrick newbasicVariableNodesFor: anObject in: aCollection  ^anObject gtInspectorVariableNodesIn: aCollectionstackPresentation  ^(self browser paneNamed: #stack) presentations firstonHideHints  self themer spotterThemer hintHideArrowStyleFor: self triangleBrickprivateAddCandidate: aCandidateLink weightedIn: aProcessorLink  ^aProcessorLink isFull ifTrue: [ self privateAddCandidate: aCandidateLink weightedInFull: aProcessorLink ] ifFalse: [ self privateAddCandidate: aCandidateLink weightedInNotFull: aProcessorLink ]spotterModel: aSpotter  self contentsBrick spotterModel: aSpotter.  self arrowBrick spotterModel: aSpotter.  self previewBrick spotterModel: aSpottergtInspectorStepsIn: composite  < gtInspectorPresentationOrder: 40>  composite list     title: 'Steps';     display: [ self steps ];     when: [ self steps notEmpty ]isFull  ^self size = self processor itemsLimitallSatisfy: aBlock  self do: [:each |  (aBlock value: each) ifFalse: [ ^false ] ].  ^truefirst: anInteger  ^self items copyFrom: 1 to: (self size min: (anInteger max: 0))assertDiveIn  self assertDiveIn: #diveInhelp  ^'Evaluate the selection in a code pane of a debugger and push the result in the inspector of the debugger.'headerBrick  ^headerBrickmenu  ^nilhasSelected  < return: #Boolean>  ^selected isNotNildebuggerStructureIn: browser  browser     row: #stack;     row: #code span: 2;     row: #inspectorinitialize  super initialize.  selectedMethodSignatures := OrderedCollection new.  configurationBlocks := Dictionary newdoContinueFilterInContext: aSpotterContext  ^aSpotterContext doContinueFilterForProcessor: selfinitialize  super initialize.  self needsUpdate: falsecontext: aSpotterContext  self current: aSpotterContextsetUp  super setUp.  candidates := GTSpotterCandidatesList newcandidateLink: aDoubleLink  candidateLink := aDoubleLink.  self actionbarBrick candidateLink: self candidateLinkpaneBrick  ^paneBrickhostObject  ^hostObjecttestAddOneCandidateA1A2  | link11 link21 category1 category2 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  link11 := candidates addCandidate: 11 in: GTSpotterA1.  link21 := candidates addCandidate: 21 in: GTSpotterA2.  self assert: link11 nextLink equals: link21.  self assert: link11 previousLink equals: link21.  self assert: link21 nextLink equals: link11.  self assert: link21 previousLink equals: link11.  self assert: candidates head equals: link11.  self assert: candidates tail equals: link21.  self assert: category1 headLink equals: link11.  self assert: category1 tailLink equals: link11.  self assert: category2 headLink equals: link21.  self assert: category2 tailLink equals: link21rawValue  ^thisContext object: self hostObject instVarAt: indexdiveInCategory: aProcessor dueTo: anEventType  self spotter     requestNextCategoryStepWith: (self candidates getProcessorLink: aProcessor) for: #diveInCategory;     notifyDiveInCategory: aProcessor for: anEventTypenotifyStepAdded: aStep  self announce: (GTSpotterStepAdded new stepModel: aStep)testAddOneCandidateA1A2A3  | link11 link21 link31 category1 category2 category3 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  category3 := candidates addProcessor: GTSpotterA3.  link11 := candidates addCandidate: 11 in: GTSpotterA1.  link21 := candidates addCandidate: 21 in: GTSpotterA2.  link31 := candidates addCandidate: 31 in: GTSpotterA3.  self assert: link11 nextLink equals: link21.  self assert: link11 previousLink equals: link31.  self assert: link21 nextLink equals: link31.  self assert: link21 previousLink equals: link11.  self assert: link31 nextLink equals: link11.  self assert: link31 previousLink equals: link21.  self assert: candidates head equals: link11.  self assert: candidates tail equals: link31.  self assert: category1 headLink equals: link11.  self assert: category1 tailLink equals: link11.  self assert: category2 headLink equals: link21.  self assert: category2 tailLink equals: link21.  self assert: category3 headLink equals: link31.  self assert: category3 tailLink equals: link31index: anIndex slotName: aSlotName  index := anIndex.  slotName := aSlotNamerawValue  ^self hostObject at: self tempIndexshouldShowActionbar  < return: #Boolean>  ^self isHovered or: [ self isChecked or: [ self stepModel ifNil: [ false ] ifNotNil: [:sm |  sm isSelected: self candidateLink ] ] ]closeActionFor: aPresentation  ^GLMGenericAction new     action: [ self removeLastPane ];     icon: GLMUIThemeExtraIcons glamorousClose;     condition: [:currentPresentation |  self panes size > 1 and: [ self panes last presentations = currentPresentation ] ];     title: 'Close this inspector column'newCloseButton  ^GLMHintableActionButtonBrick newbuttonFor: anAction  ^(self instantiate: anAction specPresenter)     debugAction: anAction;     yourselftestInspectDoesNotCrash  window := GTInspector openOn: self class neworiginalSession  ^originalSessionsearchFieldFamilyName  ^'Source Sans Pro'printObjectAsAnItem: anObject  | header printString |  header := (anObject class name first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]) , anObject class name.  printString := (GTObjectPrinter asTruncatedTextFrom: anObject) asString.  ^(printString beginsWith: header) ifTrue: [ printString ] ifFalse: [ String streamContents: [:out |  out                 << header;                 << ' (';                 << printString;                 << ')' ] ]messageText  ^self class nametextAttributesForStackEntry: aContext  (self selectedContext isNil or: self class enableStackColoring not) ifTrue: [ ^{(TextColor color: self theme textColor)} ].  ^self theme styleContext: aContext from: selfsnippets  ^snippets ifNil: [ snippets := WeakIdentityKeyDictionary new ]spotterConcreteMethodFor: aStep  < spotterOrder: 30>  self flag: #specialFilter.  ^aStep listProcessor     title: 'Methods';     filter: GTNullFilter item: [:filter :context |  self concreteMethodsInContext: context usingFilter: filter ];     wantsToDisplayOnEmptyQuery: falseitems: anObject  items := anObjectwithContinue: aBoolean do: aBlock  | previousContinuing |  previousContinuing := continuing.  ^[ continuing := aBoolean.  aBlock value ] ensure: [ continuing := previousContinuing ]previous  ^self previousLinkshowActionsOf: aRowBrick  aRowBrick subbricks select: [:each |  each isKindOf: GLMHintableActionButtonBrick ] thenDo: [:each |  each visible: true ]key  ^self tempNameapplyFilterWithQuery  | result |  result := FuzzyMatcher allSortedByScoreMatching: query in: self allItems by: [:each |  self itemFilterNameFor: each ].  self     addItems: (result takeFirst: self itemsLimit);     filteredItems: resulttestAddTwoCandidateA1A2  | link11 link12 link21 link22 category1 category2 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  link11 := candidates addCandidate: 11 in: GTSpotterA1.  link12 := candidates addCandidate: 12 in: GTSpotterA1.  link21 := candidates addCandidate: 21 in: GTSpotterA2.  link22 := candidates addCandidate: 22 in: GTSpotterA2.  self assert: link11 nextLink equals: link12.  self assert: link11 previousLink equals: link22.  self assert: link12 nextLink equals: link21.  self assert: link12 previousLink equals: link11.  self assert: link21 nextLink equals: link22.  self assert: link21 previousLink equals: link12.  self assert: link22 nextLink equals: link11.  self assert: link22 previousLink equals: link21.  self assert: candidates head equals: link11.  self assert: candidates tail equals: link22.  self assert: category1 headLink equals: link11.  self assert: category1 tailLink equals: link12.  self assert: category2 headLink equals: link21.  self assert: category2 tailLink equals: link22onShowPreview  self triangleBrick renderer border: 0.  self triangleBrick selectedColor: self themer spotterThemer borderColor.  self changedtestAddThreeCandidateA1A2  | link11 link12 link13 link21 link22 link23 category1 category2 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  link11 := candidates addCandidate: 11 in: GTSpotterA1.  link12 := candidates addCandidate: 12 in: GTSpotterA1.  link13 := candidates addCandidate: 13 in: GTSpotterA1.  link21 := candidates addCandidate: 21 in: GTSpotterA2.  link22 := candidates addCandidate: 22 in: GTSpotterA2.  link23 := candidates addCandidate: 23 in: GTSpotterA2.  self assert: link11 nextLink equals: link12.  self assert: link11 previousLink equals: link23.  self assert: link12 nextLink equals: link13.  self assert: link12 previousLink equals: link11.  self assert: link13 nextLink equals: link21.  self assert: link13 previousLink equals: link12.  self assert: link21 nextLink equals: link22.  self assert: link21 previousLink equals: link13.  self assert: link22 nextLink equals: link23.  self assert: link22 previousLink equals: link21.  self assert: link23 nextLink equals: link11.  self assert: link23 previousLink equals: link22.  self assert: candidates head equals: link11.  self assert: candidates tail equals: link23.  self assert: category1 headLink equals: link11.  self assert: category1 tailLink equals: link13.  self assert: category2 headLink equals: link21.  self assert: category2 tailLink equals: link23processor  ^processordebuggerStructureIn: browser  self subclassResponsibilitynewActionbarBrick  ^GTSpotterItemActionbarBrick newisDropDownPaneVisible  ^self dropDownBrick isNotNilopenWithNotification: notificationString  (GTSpecPreDebugPresenter on: self)     message: notificationString;     openWithSpec;     setTitle: self titlebreadcrumbSeparatorColor  ^self breadcrumbItemBackgroundColor muchLighter slightlyDarkerconfigurationBlockForProcessorsCreatedBy: aMethod  ^[:processor |   ]regex: anObject  regex := anObjecttestDevelopmentHandleExceptionMock5  self assertResetExceptions.  self should: [ [ 1 / 0 ] on: ZeroDivide do: [:exception |  GTSpotterDebuggingExceptionHandlerMock new handleException: exception do: [ self fail: 'Ups, we shouldnt have reached this statement' ] ] ] raise: ZeroDivide.  self assertException: ZeroDivideassertDebuggerInitialization  self assert: (debugger class handlesContext: session interruptedContext).  window := debugger openOn: session.  self assert: window model equals: debugger.  self assert: debugger session interruptedContext notNil.  self assert: debugger session interruptedProcess notNiladdActionButton: anActionButton  self themer spotterThemer itemActionButtonStyleFor: anActionButton.  self themer spotterThemer itemActionButtonWidgetStyleFor: anActionButton.  self addBrickBack: anActionButton.  self stepModel spotter isShiftPressed ifTrue: [ self themer spotterThemer hintRevealStyleFor: anActionButton ]childrenNodesFor: aVariablesBrowser  < return: #Collection of: #GTInspectorVariableNode>  ^#()rubricBackgroundColor  ^self spotterThemer backgroundColorhideActionbar  (self hasSubbrick: self actionbarBrick) ifTrue: [ self removeBrick: self actionbarBrick ]addObject: firstObject inProcessor: secondObject  self performSymbol: self onAddedSelector withArguments: {firstObject .         secondObject}.  Processor yielddebuggingActionsPragmas  ^#(debuggingAction)closeButtonStyleFor: aBrick  aBrick     vSpaceFill;     width: [:m |  m height ];     margin: 10;     marginLeft: 0testDebugger  self assertDebuggerInitializationForContext: [ 20 factorial ] asContext andStepBlock: [:aProcess |   ].  self assertDebuggerClosingregex  ^regexitemBrick  ^candidateBrickaddItems: aCollectionOfItems to: aCategoryBrick  | shouldAddCategory |  self assert: aCollectionOfItems isNotNil.  self assert: aCollectionOfItems isNotEmpty.  self assert: aCategoryBrick isNotNil.  shouldAddCategory := aCategoryBrick hasSubbricks not.  aCategoryBrick addItems: aCollectionOfItems.  shouldAddCategory ifTrue: [ self addCategory: aCategoryBrick ]stepBlockForTestWithHalt  ^[:aProcess |  aProcess     completeStep: aProcess suspendedContext;     completeStep: aProcess suspendedContext;     step;     stepToSendOrReturn;     completeStep: aProcess suspendedContext;     stepToSendOrReturn ]gtListFilter  ^GTFilterSubstring newpragmas: aCollection  pragmas := aCollectionselectedVariableName: anObject  self cache at: #selectedVariableName put: anObjectallFilesSorted  ^self allFiles sorted: [:a :b |  a modificationTime > b modificationTime ]onThemerChanged  super onThemerChanged.  self doLayoutForceshowActionbar  (self hasSubbrick: self actionbarBrick) ifFalse: [ self addBrickBack: self actionbarBrick.        self toggleHints ]categoryAmountStyleFor: aBrick  aBrick textPosition: #leftCenter.  aBrick label familyName: self titleFamilyName.  aBrick     vSpaceFill;     width: #approximateWidth;     marginLeft: self categoryNameMarginRightlabel  ^labelspotterPreviewItemsIn: aComposite  < spotterPreview: 10>  aComposite list     title: '<' , self gtDisplayString , '>';     display: [:x |  x ];     format: [:pragma |  GTSpotterItemBrick new           text: pragma method gtDisplayString;           disable;           yourself ];     entity: self pragmas asArraystringWithoutInitialCommentFrom: aString  ^(aString trimLeft isEmpty not and: [ aString trimLeft first = $" ]) ifFalse: [ aString trimRight ] ifTrue: [ | startIndex doubleQuoteCounter |        startIndex := aString findAnySubstring: '"' startingAt: (aString indexOf: $") + 1.        doubleQuoteCounter := 1.        [ startIndex <= aString size and: [ doubleQuoteCounter % 2 = 1 or: [ (aString at: startIndex) = $" or: [ (aString at: startIndex) isSeparator ] ] ] ] whileTrue: [ (aString at: startIndex) = $" ifTrue: [ doubleQuoteCounter := doubleQuoteCounter + 1 ].              startIndex := startIndex + 1 ].        startIndex >= (aString size + 1) ifTrue: [ ^'' ].        (aString copyFrom: startIndex to: aString size) trimBoth ]errorMessage  ^'error obtaining field value'scrollbarColor  ^Color lightGray alpha: 0.2text: aString  self labelBrick text: aStringhelpButtonStyleFor: aBrick  aBrick     vSpaceFill;     width: [:m |  m height ];     margin: 10;     marginLeft: 0updateVariableNode: aNode basedOn: aString  | aResult |  aResult := aNode hostObject class compiler     source: aString;     context: nil;     receiver: aNode hostObject;     failBlock: [ ^self ];     evaluate.  aNode save: aResultdebuggerToTest  ^GTGenericStackDebuggersignatureFor: aMethod  ^{aMethod methodClass .   aMethod selector}senders: aSelector  ^self senders: aSelector inPackages: self defaultPackagestestAccessBindings  | obtainedBindings expectedBindings |  expectedBindings := Dictionary new.  expectedBindings add: (WorkspaceVariable key: #a value: 1).  expectedBindings add: (WorkspaceVariable key: #b value: 2).  window := playground openOn: (GTPlayPage new saveContent: 'a:=1. b:=a+1').  playground inspectorPresentation firstPresentation selectLine.  playground inspectorPresentation firstPresentation evaluateSelection.  obtainedBindings := playground currentBindings.  self assert: obtainedBindings equals: expectedBindingsimplementors  ^methods ifNil: [ methods := (SystemNavigation default allImplementorsOf: self name) collect: [:each |  each compiledMethod ] ]onStepPopped  self stepModel spotter steps last = self stepModel & self isChecked ifTrue: [ self notifySelected ]pagerModel  ^pagerModel ifNil: [ pagerModel := self defaultPagerModel defaultNumberOfVisiblePages: 1.        pagerModel announcer when: GLMPagePoped send: #onPagePopped to: self.        pagerModel ]message: aString  textPresenter text: aStringtestDeploymentExceptionHandlerMock5  self assertResetExceptions.  self shouldntRaise: AssertionFailure process: 'abc' origin: GTSpotterExceptionMock5 new during: GTSpotterDeploymentExceptionHandlerMock new.  self assertNoExceptionscategoryTitleWidgetStyleFor: aBrick  aBrick normalColor: self categoryTitleBackgroundColoremptyTextFontSize  ^Smalltalk ui theme textFont pointSizespotterActDefault  | result |  result := GTPlayground new openOn: self.  self title notNil ifTrue: [ self ensureStashPersistency ].  ^resultcodePane  ^self browser paneNamed: #codeonPagePopped  self steps size > 0 ifTrue: [ self currentStep: self steps last ]evaluationAction  ^GLMGenericAction new     action: [:listPresentation :obj |  | result |        result := obj perform: listPresentation selection selector.        (listPresentation pane port: #evaluatedObject) value: result ];     shortcut: $g;     title: 'Do it and go';     yourselfsettingsLabelSelectedTextColor  ^Color blackinitialize  super initialize.  self needsUpdate: falsenewPageRow: playPage in: aGTPlayBook  ^self newRow     addBrickBack: (self newPageLabel           textColor: self themer textColor;           text: (playPage content asString contractTo: 50));     addBrickBack: (self newAcceptButtonFor: playPage);     when: #onDoubleClicked do: [ self remove.        self announce: #pageAccepted event: playPage ];     with: [:aRow |  aRow           when: #onMouseHover do: [ self showActionsOf: aRow ];           when: #onMouseUnhover do: [ self hideActionsOf: aRow ] ];     yourselfnewLabelBrick  ^GLMLabelBrick newbreadcrumbSeparatorStyleFor: aBrick  aBrick     borderWidth: self breadcrumbSeparatorLineWidth;     width: self breadcrumbSeparatorWidth;     height: self breadcrumbHeight + self outerBorderWidthdefaultItemsLimit  ^5candidate  ^self valueisSelected: aCandidateLink  < return: #Boolean>  ^self hasSelected and: [ self selected == aCandidateLink ]prepareFilterInContext: aSpotterContext  super prepareFilterInContext: aSpotterContext.  separators ifNil: [ separators := self defaultSeparators ].  self query: (self query substrings: self separators) asSet asArraystepModel: anObject  stepModel := anObject.  self stepModel announcer when: GTSpotterSelectedCandidateChanged send: #onCandidateSelected to: self.  self stepModel spotter announcer when: GTSpotterRevealHints send: #onRevealHints to: self.  self stepModel spotter announcer when: GTSpotterHideHints send: #onHideHints to: selfregisterActions  self when: GLMBrowserClosing send: #actOnBrowserClosing: to: self.  self when: DebugActionExecuted send: #updateBrowserFrom: to: self.  self when: GLMPaneRemoved send: #actOnInspectorPaneRemoved: to: selfpublish  (self confirm: 'Publish playground content to the cloud?') ifFalse: [ ^self ].  self content ifEmpty: [ self inform: 'Nothing was published because the playground is empty'.        ^self ].  Clipboard clipboardText: (publishedUrl := (GTUrlProvider new post: self contentString) asString).  self inform: publishedUrl , ' was published and the url was copied to clipboard'defaultLabel  ^'Do it'processors  ^processorsdefaultKeymap  ^$g metapreviewBrick: aBrick  previewBrick ifNotNil: [ self removeBrick: aBrick ].  previewBrick := aBrick.  self themer spotterThemer spotterPreviewStyleFor: previewBrickasyncTask  ^asyncTask ifNil: [ asyncTask := GLMAsyncTask new ]transmitFromStackToCodeIn: browser  browser transmit     from: #stack port: #selection;     to: #code;     andShow: [:composite :aContext |  self methodCodeIn: composite forContext: aContext.        self setUpCodeIn: composite.        self tearDownCodeIn: composite ]value: aSpotterContext  ArithmeticError signal: 'Error while filtering'sourceCode: aString  ^((self browser paneNamed: #code) port: #text) value: aStringselectionChanged: aContext  aContext isNotNil ifTrue: [ self announce: (GTGenericStackDebuggerSelectionChanged forDebugger: self) ].  UIManager default defer: [ self session ifNotNil: [ (self browser paneNamed: #stack) presentations updateToolbar ] ].  self class enableStackColoring ifFalse: [ ^self ].  UIManager default defer: [ (self browser paneNamed: #stack) presentations presentations ifNotEmpty: [:p |  self session interruptedProcess ifNotNil: [ p first update ] ] ]isMatchedItem: anItem  ^self matcher ifNotNil: [ self matcher value: anItem value: self context ] ifNil: [ (self itemFilterNameFor: anItem) includesSubstring: query caseSensitive: caseSensitive ]candidateLink: anObject  candidateLink := anObjecttestDebuggingExceptionHandlerDuring  | exceptionHandler |  self exceptionHandler: (exceptionHandler := GTSpotterDebuggingExceptionHandlerMock new) do: [ self shouldnt: [ GTCurrentSpotterExceptionHandler value ] raise: Error.        self assert: GTCurrentSpotterExceptionHandler value notNil.        self assert: GTCurrentSpotterExceptionHandler value identicalTo: exceptionHandler ]updateBrowser  | browserPane session |  session := self session.  session interruptedContext ifNil: [ self close.        UIManager default inform: 'End of debugged execution' ] ifNotNil: [ browserPane := self browser pane.        (browserPane port: #entity) silentValue: nil.        (browserPane port: #entity) value: session ]isShiftPressed  ^isShiftPressed ifNil: [ isShiftPressed := false ]triangleBrick  ^triangleBrickprocessor  ^self valuedefaultTextTrimmed  ^self text trimBothshouldDisplayPresentationCreatedBy: aMethod  ^(self tagsFrom: aMethod) includesAny: selectedTagsonHidePreview  | delta |  self paneBrick isPreviewShown ifFalse: [ ^self ].  delta := ((self width - (self width / 100 * (100 - self themer spotterThemer previewWidthPercent))) @ 0) negated / 2.  self bounds: (self bounds expandBy: delta rounded).  self paneBrick hidePreview.  self doLayoutitemsLimit  ^Float infinityprocess: aString origin: anOrigin  | step |  ((step := GTSpotterStep new)     spotter: spotter;     origin: anOrigin;     yourself) processContext: (step newContextForQuery: aString)handleException: anException do: aBlock  GTSpotterExceptionsTest exceptions add: anExceptionallowProcessorsFrom: aMethod  | signature |  signature := self signatureFor: aMethod.  (selectedMethodSignatures includes: signature) ifFalse: [ selectedMethodSignatures add: signature ]iconFor: anEyeElement error: error  ^self iconNamed: #smallWarningIconhandleExceptionsDuring: aBlock  self exceptionHandler handleExceptionsDuring: aBlockonThemerChanged  super onThemerChanged.  self themer spotterThemer itemNormalWidgetStyleFor: selfsession: aSession  (self browser pane port: #entity) value: aSession.  self title: aSession namedefaultStream  ^GTSpotterUIThreadStream newvalue: aContext  self context: aContextcaseSensitive: anObject  caseSensitive := anObjectbrowseVersions  Smalltalk tools versionBrowser browseVersionsForClass: self currentClassOrMetaClass selector: self currentMessageNameactOnButton  ^actOnButtoncull: aContext  self context: aContextrenderArrow: aBrick on: aCanvas  | height width hW hH aX bX cX aY bY cY a b c overdraw delta |  overdraw := 2.  delta := 1.  height := aBrick brickBounds height.  width := aBrick brickBounds width.  hH := height / 4.  hW := width / 2.  aX := ((hW - hH max: 0) min: width) floor - overdraw - delta.  bX := ((hW + hH max: 0) min: width) floor - delta.  cX := aX.  aY := overdraw negated.  bY := (hH * 2) floor.  cY := height + overdraw.  a := aBrick brickBounds topLeft + (aX @ aY).  b := aBrick brickBounds topLeft + (bX @ bY).  c := aBrick brickBounds topLeft + (cX @ cY).  aCanvas line: a to: b width: aBrick borderWidth first color: aBrick borderColor first.  aCanvas line: b to: c width: aBrick borderWidth first color: aBrick borderColor firsttearDown  window ifNotNil: [ window delete ].  window := nil.  (RPackageOrganizer default packageNamed: 'GTMockTests' ifAbsent: [  ]) ifNotNil: #removeFromSystem.  playground := nil.  super tearDownhasStepModel  ^stepModel isNotNilevent: anObject  event := anObjectcategories  < return: #Dictionary>  ^categoriesbuildPane: aStepModel  | pane |  pane := GTSpotterResultsBrick new stepModel: aStepModel.  self brickThemer spotterThemer resultsPaneStyleFor: pane.  ^paneinitialize  super initialize.  allTags := OrderedCollection new.  selectedTags := OrderedCollection new.  defaultTag := #customhintHideArrowStyleFor: aBrick  aBrick ifNil: [ ^self ].  (aBrick valueOfProperty: #brickSpotterIsReveal ifAbsent: [ false ]) ifFalse: [ ^self ].  aBrick setProperty: #brickSpotterIsReveal toValue: false.  (aBrick hasProperty: #brickSpotterBackupColor) ifTrue: [ aBrick color: (aBrick valueOfProperty: #brickSpotterBackupColor) ].  aBrick changedlayoutProportional: aCollection in: aBrick position: aSymbol  | fullWidth eachWidth index |  aCollection isEmpty ifTrue: [ ^self ].  fullWidth := aBrick innerBounds width.  index := 0.  aCollection inject: aBrick paddingLeft into: [:leftOffset :each |  | layoutBounds |        self sendEvent: (GLMBrickLayoutStacked new                 index: index + 1;                 position: aSymbol;                 yourself) to: each.        eachWidth := ((fullWidth - leftOffset) / (aCollection size - index)) ceiling.        layoutBounds := each wrappedBounds.        index = 0 ifTrue: [ layoutBounds width: (((each layout maxWidth brickValue: each) max: eachWidth) min: fullWidth - leftOffset) ] ifFalse: [ index = (aCollection size - 1) ifFalse: [ layoutBounds width: (eachWidth min: (each layout maxWidth brickValue: each)) ] ifTrue: [ layoutBounds width: eachWidth ] ].        layoutBounds translateBy: leftOffset @ 0.        each brickBounds: layoutBounds.        index := index + 1.        leftOffset + layoutBounds outerBounds width ]step  ^stepseparators  ^separatorshelpButton  ^helpButtonhelp  ^'Execute a selected piece of code from the code pane of the debugger.'variablesFromContext: aContext  ^cachedVariables ifNil: [ cachedVariables := self buildVariablesFromContext: aContext ]onThemerChanged  super onThemerChanged.  self themer spotterThemer categoryTitleWidgetStyleFor: self.  self themer spotterThemer categoryAmountWidgetStyleFor: self amountBrick.  self themer spotterThemer categoryTitleNameWidgetStyleFor: self nameBrickexpectedResult  ^expectedResultsettingsButton  ^settingsButtoncontinueFilterInContext: aSpotterContext  [ self basicContinueFilterInContext: aSpotterContext ] on: Error do: [:exception |  self exceptionHandler handleException: exception do: [ ('[Spotter] Exception in continuing processor <' , self title asString , '>: ' , exception asString) traceCr ] ]newBreadcrumbBrick  ^GTSpotterStepsBreadcrumb newexceptionHandler: anExceptionHandler do: aBlock  self assertResetExceptions.  self shouldnt: [ anExceptionHandler handleExceptionsDuring: aBlock ] raise: Error.  self assertNoExceptions.  self assertResetExceptions.  self shouldnt: [ spotter exceptionHandler: anExceptionHandler.        spotter handleExceptionsDuring: aBlock ] raise: Error.  self assertNoExceptionsband: aBrick  band := aBrick.  band     useHorizontalLinearLayout;     hShrinkWrap;     vSpaceFill.  self band data: 0.  self addBrickBack: banddefaultKeymap  ^PharoShortcuts current doItShortcutonRevealHints  (self hasSubbrick: self actionbarBrick) ifFalse: [ ^self ].  self themer spotterThemer hintRevealStyleFor: self diveInButtonbasicRelevantProcessorsProcess: aSpotterContext do: aBlock  aSpotterContext text substrings detect: [:each |  each beginsWith: '#' ] ifFound: [:categoryQuery |  | categoryQueryPrefix |        aSpotterContext text: (aSpotterContext text copyReplaceAll: categoryQuery with: '').        categoryQueryPrefix := categoryQuery allButFirst asLowercase.        self processors select: [:each |  self processor: each isRelevantForQuery: categoryQueryPrefix ] thenDo: aBlock ] ifNone: [ self processors do: aBlock ]currentMessageName  ^self currentContext methodSelectorcandidatesLimit: anInteger  self itemsLimit: anIntegertextLowercase  ^textLowercase ifNil: [ textLowercase := self defaultTextLowercase ]id  ^self class namereceiver  ^receivervariableTag  ^'attribute'open  | window |  window := super open.  self class environment at: #GTDebuggerEventCollector ifPresent: [:eventCollector |  eventCollector new collectDataFrom: self ].  ^windowreject: aBlock as: aCollectionClass  | collection |  collection := self newAs: aCollectionClass.  self do: [:each |  (aBlock value: each) ifFalse: [ collection add: each ] ].  ^collectionsession  ^self owner sessiondefaultTask  ^GLMAsyncTask newisNotEmpty  < return: #Boolean>  ^self isEmpty notpersistenceStrategies  ^persistenceStrategiescollect: aBlock as: aCollectionClass  | collection |  collection := self newAs: aCollectionClass.  self do: [:each |  collection add: (aBlock value: each) ].  ^collectioninitialize  super initialize.  self     useVerticalLinearLayout;     vShrinkWrap;     initializeListeners;     enableitemNormalWidgetStyleFor: aBrick  aBrick     normalColor: self itemNormalBackgroundColor;     selectedColor: self itemHoveredBackgroundColor;     checkedColor: self itemSelectedBackgroundColorprocessorKeyBindingsDo: aBlock  processorKeyBindings ifNotNil: [ processorKeyBindings keys do: [:each |  self kmDispatcher removeKeyCombination: each ] ].  processorKeyBindings := Dictionary new.  aBlock valuetreeIn: a  ^a tree     rootsExpanded;     display: [:anObject |  {anObject} ];     children: [:each |  each children ];     selectionPopulate: #selectedNode on: $o entitled: 'Open' with: [:tree |  tree selection ];     format: [:each |  String streamContents: [:stream |  stream                 nextPutAll: each class name;                 nextPut: $(;                 nextPutAll: ((each formattedCode truncateTo: 50) copyReplaceAll: String cr with: String space);                 nextPut: $) ] ]reject: aBlock thenDo: aBlock2  self do: [:each |  (aBlock value: each) ifFalse: [ aBlock2 value: each ] ]hintRevealArrowStyleFor: aBrick  aBrick ifNil: [ ^self ].  (aBrick valueOfProperty: #brickSpotterIsReveal ifAbsent: [ false ]) ifTrue: [ ^self ].  aBrick setProperty: #brickSpotterBackupColor toValue: aBrick color.  aBrick setProperty: #brickSpotterIsReveal toValue: true.  aBrick color: self themer popupHelpThemer backgroundColor.  aBrick changedcurrent  ^currentheadLink  ^headLinktestBla  < expectedFailure>  self assert: self bla equals: 1announcer  ^announcer ifNil: [ announcer := Announcer new ]stepModel  ^stepModelcontentsBrick  ^contentsBricktestAddOneCandidateA1  | link category |  category := candidates addProcessor: GTSpotterA1.  link := candidates addCandidate: 11 in: GTSpotterA1.  self assert: link nextLink equals: link.  self assert: link previousLink equals: link.  self assert: candidates head equals: link.  self assert: candidates tail equals: link.  self assert: category headLink equals: link.  self assert: category tailLink equals: linkdefaultOrder  ^5sort  ^sortBlockdefaultKeymap  ^PharoShortcuts current inspectItShortcutpreviewArrowColor  ^self itemSelectedBackgroundColorselect  self invalidateWith: [ self labelBrick label           customFont;           beBold ]canDiveInSelectedCandidate  ^self canDiveIn: self selected candidateinspectIt  | result |  Smalltalk compiler silentlyDo: [ result := Smalltalk compiler evaluate: text string trimBoth ] exceptionDo: [:ex |  ^ex ].  result inspect.  self exitDueTo: #inspectItshouldDisplayPresentationCreatedBy: aMethod  ^true