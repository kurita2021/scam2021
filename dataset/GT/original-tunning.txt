testRemoveCandidatesA1FromA1A2A3  | link21 link22 link23 link31 link32 link33 category1 category2 category3 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  category3 := candidates addProcessor: GTSpotterA3.  candidates addCandidate: 11 in: GTSpotterA1.  candidates addCandidate: 12 in: GTSpotterA1.  candidates addCandidate: 13 in: GTSpotterA1.  link21 := candidates addCandidate: 21 in: GTSpotterA2.  link22 := candidates addCandidate: 22 in: GTSpotterA2.  link23 := candidates addCandidate: 23 in: GTSpotterA2.  link31 := candidates addCandidate: 31 in: GTSpotterA3.  link32 := candidates addCandidate: 32 in: GTSpotterA3.  link33 := candidates addCandidate: 33 in: GTSpotterA3.  candidates removeAllCandidatesOf: GTSpotterA1.  self assert: link21 nextLink equals: link22.  self assert: link21 previousLink equals: link33.  self assert: link22 nextLink equals: link23.  self assert: link22 previousLink equals: link21.  self assert: link23 nextLink equals: link31.  self assert: link23 previousLink equals: link22.  self assert: link31 nextLink equals: link32.  self assert: link31 previousLink equals: link23.  self assert: link32 nextLink equals: link33.  self assert: link32 previousLink equals: link31.  self assert: link33 nextLink equals: link21.  self assert: link33 previousLink equals: link32.  self assert: candidates head equals: link21.  self assert: candidates tail equals: link33.  self assert: category1 headLink equals: nil.  self assert: category1 tailLink equals: nil.  self assert: category2 headLink equals: link21.  self assert: category2 tailLink equals: link23.  self assert: category3 headLink equals: link31.  self assert: category3 tailLink equals: link33titleMarginLeft  ^20onThemerChanged  super onThemerChanged.  self doLayoutForcetestNextA1A2Category  | link11 link12 link13 link21 link22 link23 category1 category2 |  category1 := candidates addProcessor: GTSpotterA1.  category2 := candidates addProcessor: GTSpotterA2.  link11 := candidates addCandidate: 11 in: GTSpotterA1.  link12 := candidates addCandidate: 12 in: GTSpotterA1.  link13 := candidates addCandidate: 13 in: GTSpotterA1.  link21 := candidates addCandidate: 21 in: GTSpotterA2.  link22 := candidates addCandidate: 22 in: GTSpotterA2.  link23 := candidates addCandidate: 23 in: GTSpotterA2.  self assert: category1 equals: (candidates nextProcessorLinkOf: category2).  self assert: category2 equals: (candidates nextProcessorLinkOf: category1)matchAlike  self filter: GTFilterAlikeallCandidatesIn: aContext  ^self allItemsIn: aContextappliesToDebugger: aDebugger  ^aDebugger session class = GTSUnitDebugSession and: [ aDebugger session assertionCallerContext notNil and: [ aDebugger session testContext ~= aDebugger session assertionCallerContext ] ]calculateItemWidth: aBrick  | sWidth bWidth singleWidth lastWidth |  sWidth := self themer spotterThemer breadcrumbSeparatorWidth.  bWidth := self width.  lastWidth := ((aBrick labelBrick approximateWidth min: bWidth / 2) max: (bWidth - ((self maxNumberOfSteps - 1) * sWidth)) / self maxNumberOfSteps) floor.  singleWidth := ((bWidth - lastWidth - ((self maxNumberOfSteps - 1) * sWidth)) / (self maxNumberOfSteps - 1)) floor.  ^aBrick isLastInOwner ifTrue: [ self items size >= self maxNumberOfSteps ifTrue: [ | fullWidth delta |              fullWidth := lastWidth + ((self maxNumberOfSteps - 1) * (sWidth + singleWidth)).              delta := bWidth - fullWidth.              lastWidth := lastWidth + delta ].        lastWidth ] ifFalse: [ singleWidth ]currentClass  ^self currentContext methodClassaddAndSelectTag: aSymbol  self addTag: aSymbol.  (selectedTags includes: aSymbol) ifFalse: [ selectedTags add: aSymbol ]handleException: anException do: aBlock  super handleException: anException do: aBlock.  ^aBlock valuefilterInContext: aSpotterContext  [ self basicFilterInContext: aSpotterContext ] on: Error do: [:exception |  self exceptionHandler handleException: exception do: [ ('[Spotter] Exception in processor <' , self title asString , '>: ' , exception asString) traceCr ] ]executeAction  self debugger stackPresentation selection: self debugger session testContextselectedContext  self subclassResponsibilityaddProcessor: aProcessor  | processorLink |  processorLink := aProcessor asSpotterProcessorLink.  self processorLinksMap add: aProcessor -> processorLink.  self processors addLast: processorLink.  ^processorLinkkey  ^slotNamesetModelBeforeInitialization: aDebugger  debugger := aDebuggerdebugActionExecutedAnnouncement  ^debugActionExecutedAnnouncementprocess: aProcess context: aContext  super process: aProcess context: aContext.  assertionContext ifNil: [ self initializeTestContextFrom: aContext.        self initializeAssestionContextFrom: aContext.        self supportsDiff ifTrue: [ actualResult := assertionContext tempAt: 1.              expectedResult := assertionContext tempAt: 2 ] ]gtDisplayOn: stream  stream     nextPutAll: 'Processor: ';     nextPutAll: self title asStringspotterForStashedPlaygroundPagesFor: aStep  < spotterOrder: 100>  aStep listProcessor     allCandidates: [ | stashFiles |        stashFiles := GTPlayBook stashDirectory files select: [:each |  each extension = GTPlayPage fileExtension ].        stashFiles collect: [:file |  (GTPlayPage fromFileReference: file) title: (file basename copyUpTo: $-) ] ];     title: 'Playground named pages';     itemName: [:page |  page title , ' - ' , page content asString contractTo: 100 ];     filter: self defaultFilterClassstreamed  ^streamed ifNil: [ streamed := self defaultStreamed ]gtDisplayOn: stream  stream nextPutAll: 'Candidate link: '.  self value gtDisplayOn: streamshowDropDownPane  self dropDownBrick: self newDropDownMorph.  self dropDownBrick spotterModel: self spotterModeleventType  ^eventTypeaddItem: anItemBrick to: aCategoryBrick  | shouldAddCategory |  self assert: anItemBrick isNotNil.  self assert: aCategoryBrick isNotNil.  shouldAddCategory := aCategoryBrick hasSubbricks not.  aCategoryBrick addItem: anItemBrick.  shouldAddCategory ifTrue: [ self addCategory: aCategoryBrick ]installStackDebuggingActionsFor: aPresentation  self installActionsForRootPragmas: self stackDebuggingActionsPragmas in: aPresentationactDueTo: anEventType  self assert: [ self hasSelected ] description: [ 'Spotter can not perform an action due to ' , anEventType asString , ' if there is no selected candidate' ].  self spotter     historize: self selected;     notifyActOn: self selectedCandidate for: anEventType.  self selectedCategory actOn: self selectedCandidate for: selfid  ^#gtBrowseMethodDebuggerActioninitializeWidgets  actions := self instantiate: GTSpecPreDebugActionsPresenter.  textPresenter := self newText.  textPresenter disable.  self focusOrder     add: actions;     add: textPresenteracceptContents: aStringOrtext  self flag: #TODO.  self saveContent: aStringOrtext.  ^truenewPaneBrick  ^GTSpotterPaneBrick newisTriangleVisible  ^isTriangleVisible ifNil: [ isTriangleVisible := true ]origin  ^originexceptionHandler  ^GTCurrentSpotterExceptionHandler value ifNil: [ self spotter exceptionHandler ]onThemerChanged  super onThemerChanged.  self themer spotterThemer spotterPreviewWidgetStyleFor: selftestWithErrorInSetup  self assert: a equals: 41testArrayPairsEqualLimit  | limit pairs |  limit := 2 * GTInspector indexableDisplayLimit.  pairs := (1 to: limit) asArray gtInspectorVariableValuePairs.  self assert: pairs size equals: limit.  (pairs collect: #key) allSatisfy: [:e |  (pairs at: e) = e ].  self assert: (pairs collect: #key) equals: (1 to: limit) asOrderedCollectionbrowser  ^self presentations firstupdateSelectionInterval  self selectedContext ifNil: [ ^self ].  self selectionInterval: (self session selectedCodeRangeForContext: self selectedContext)basicVariableNodesFor: anObject  ^#()cacheAt: aSymbol ifAbsent: aBlock  ^self cache at: aSymbol ifAbsent: aBlockfilter: anObject  filter := anObjectrender: anObject  ^GTSpotterItemBrick new     icon: nil;     text: anObject gtDisplayStringisPreviewVisible  ^isPreviewVisible ifNil: [ isPreviewVisible := false ]selectFirst  self assert: [ self candidates isNotEmpty ] description: [ 'There must be at least one candidate in order to select the first' ].  self select: self candidates headnotifyCurrentStepChanged  self announce: GTSpotterCurrentStepChanged newexecuteAction  self codePresentation debugSelectiontestDictionary  self assert: (#(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 51 51 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 81 81 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101) inject: Dictionary new into: [:dict :nr |  dict at: nr put: nr << 5.              dict ]) equals: (#(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101) inject: Dictionary new into: [:dict :nr |  nr \\ 40 == 0 ifTrue: [ dict at: nr put: nr << 6 ] ifFalse: [ dict at: nr put: nr << 5 ].              dict ])triangleBrick: aBrick  triangleBrick := aBrick.  self triangleBrick     hintTitle: 'Toggle preview';     hintText: '<' , OSPlatform current defaultModifier name asLowercase , '+p>';     action: [ self spotterModel togglePreview ].  self themer spotterThemer spotterPreviewArrowStyleFor: self triangleBrick.  self addBrickBack: self triangleBrickreplaceSelectedTagsWith: aListOfSymbols in: aGTInspector  selectedTags := aListOfSymbols.  aGTInspector updatediveInCategoryDueTo: anEventType  self spotterModelDo: [:aSpotter |  aSpotter hasSelected ifTrue: [ aSpotter currentStep diveInCategoryDueTo: anEventType ] ]actOnPaneRemoved: anAnnouncement  self panes last updateToolbarcategoryMarginBottom  ^(self itemHeight * (2 / 3)) ceilingeventType: anObject  eventType := anObjectrenderRightTriangle: aBrick on: aCanvas  | a b c width height gap |  gap := aBrick themer spotterThemer previewArrowGapHack.  aCanvas fillRectangle: (aBrick brickBounds withWidth: (gap - self border max: 0)) color: aBrick color.  width := aBrick brickBounds width - gap.  height := aBrick brickBounds height.  a := aBrick brickBounds topLeft + (gap @ (height / 2 - width max: 0)) - (0 @ 1).  b := aBrick brickBounds topLeft + (gap @ (height / 2 + width min: height)) - (0 @ self border negated) - (0 @ self border).  c := aBrick brickBounds topRight + (0 @ (height / 2)).  self border > 0 ifTrue: [ self renderTriangle: aBrick on: aCanvas with: {a asIntegerPoint .               b asIntegerPoint .               c asIntegerPoint} color: self borderColor.        self renderTriangle: aBrick on: aCanvas with: {(a asIntegerPoint - ((self border + 1) @ 0)) .               (b asIntegerPoint - ((self border + 1) @ 0)) .               (c asIntegerPoint - ((self border + 1) @ 0))} ] ifFalse: [ self renderTriangle: aBrick on: aCanvas with: {a asIntegerPoint .               b asIntegerPoint .               c asIntegerPoint} ]matcher: anObject  matcher := anObjectgetCandidateLink: aCandiate in: aProcessor  (self getCandidateLinks: (self getProcessorLink: aProcessor)) do: [:each |  each value = aCandiate ifTrue: [ ^each ] ].  ^nilnewShortcutBrick  ^GLMLabelBrick newshouldRaise: anErrorClass process: aString origin: anOrigin during: exceptionHandler  self shouldRaise: anErrorClass process: aString origin: anOrigin during: exceptionHandler do: [:e |   ]applyFilterWithoutQuery  [ self streamed ifTrue: [ | reducedItems |        self filteredItems: (reducedItems := OrderedCollection new).        self allItems withIndexDo: [:each :index |  reducedItems add: each.              self addItem: each.              index = self itemsLimit ifTrue: [ GTLimitArrived signal ] ] ] ifFalse: [ self filteredItems: (self allItems first: (self itemsLimit min: self allItems size)).        self addItems: self filteredItems ] ] on: GTLimitArrived do: [ ^self ]changeFilterRequestFor: aGTInspector  self openListChooseLabeled: 'All available tags' forInspector: aGTInspector with: allTags select: selectedTags format: #printString actionSelector: #replaceSelectedTagsWith:in:isPresentation: aPresentation inPane: aPane  ^aPane presentations first cachedPresentation ifNil: [ false ] ifNotNil: [:aCachedPresentation |  aCachedPresentation first includes: aPresentation ]candidatesLimit  ^self itemsLimitid  ^#gTPrintSelectionDebugActionnotifyCandidateSelected: anObject for: anEventType  self announce: (GTSpotterSelectedCandidateChanged new           select: anObject;           eventType: anEventType)itemActionButtonWidgetStyleFor: aBrick  aBrick pressedColor: self itemActionSelectedBackgroundColortestSettingBindings  | obtainedResult |  obtainedResult := nil.  window := playground openOn: (GTPlayPage new saveContent: 'number+1').  playground setBindings: {(#number -> 2)} asDictionary.  playground inspectorPresentation firstPresentation selectLine.  playground inspectorPresentation firstPresentation announce: (GLMEvaluateSelection new           action: [:aResult |  obtainedResult := aResult ];           makeSyncronous).  self assert: obtainedResult equals: 3steps  ^steps ifNil: [ steps := OrderedCollection new ]step  self window ifNil: [ ^self ].  self window isActive ifFalse: [ ^self ].  self wantsAutomaticRefresh ifTrue: [ self requestRefresh ]setUp  super setUp.  spotter := GTSpotter new.  self class resetitemHeight  ^16 + self theme labelFont heightrenderTriangle: aBrick on: aCanvas with: aCollection color: aColor  aCanvas drawPolygon: aCollection color: aColor borderWidth: 0 borderColor: Color transparentstepScrollPageDown  self spotterModel currentStep announcer announce: GTSpotterScrollPageDown newonCandidateAdded: anAnnouncement  self addItem: (self buildItemFor: anAnnouncement candidateLink in: anAnnouncement category) to: (self categoryBrickFor: anAnnouncement category)on: aStepModel category: aProcessor  self stepModel: aStepModel.  self category: aProcessor.  self nameBrick: self newNameBrick.  self nameBrick text: '#' , aProcessor title.  aProcessor keyBinding ifNotNil: [ self shortcutBrick: self newShortcutBrick.        self setShortcutBrickTextFor: aProcessor ].  self amountBrick: self newAmountBrick.  self amountBrick text: '0/0'.  self actionbarBrick: self newActionbarBrick.  self addDiveInButton.  self onCandidateSelected.  self nameBrick wrappedBounds markWidthDirty.  self nameBrick label wrappedBounds markWidthDirty.  self doLayoutForce.  ^selfhasPreviousNavigationFromClass: aClass  < return: #Boolean>  ^self hasPreviousStep and: [ self previousStep origin isKindOf: aClass ]assertionCallerContext  ^assertionCallerContextshowPreview  self isPreviewVisible ifTrue: [ ^self ].  isPreviewVisible := true.  self class showPreview.  self notifyShowPreviewlabel: aString  label := aStringhelp  ^'Profile the execution of a selected piece of code from the code pane of the debugger.'asyncTask  ^asyncTask ifNil: [ asyncTask := self defaultTask ]spotterForHelpTopicFor: aStep  < spotterOrder: 200>  aStep listProcessor     allCandidates: [ SystemHelp asHelpTopic gtAllSubtopics ];     title: 'Help topics';     itemName: [:helpTopic |  helpTopic title ];     itemIcon: [:helpTopic |  helpTopic gtTopicIcon ];     filter: self defaultFilterClass;     wantsToDisplayOnEmptyQuery: truehelp  ^'Switch to another debugger'render: aBrick on: aCanvas  self orientation = #right ifTrue: [ self renderRightTriangle: aBrick on: aCanvas ].  self orientation = #bottom ifTrue: [ self renderBottomTriangle: aBrick on: aCanvas ].  self orientation = #left ifTrue: [ self renderLeftTriangle: aBrick on: aCanvas ].  self orientation = #top ifTrue: [ self renderTopTriangle: aBrick on: aCanvas ]initialExtent  RealEstateAgent standardWindowExtent y < 400 ifTrue: [ ^700 @ 500 ].  ^[ | w h |  w := Display width.  h := Display height.  (w - (w // 3)) @ (h - (h // 5)) ] on: Error do: [ 850 @ 600 ]tailLink: anObject  tailLink := anObjectnotifyDiveIn: anObject for: anEventType  self announce: (GTSpotterDiveInElement new           element: anObject;           eventType: anEventType)stepModel: anObject  stepModel := anObjectbindingDictionnary  ^{(Character escape -> [ self spotterModel exitDueTo: #keyPressedEscape ]) .   ($w meta -> [ self spotterModel exitDueTo: #keyPressedW ]) .   ($p meta -> [ self togglePreview ]) .   ($i meta -> [ self spotterModel inspectIt ]) .   ($d meta -> [ self spotterModel doIt ]) .   (Character arrowUp -> [ self selectPreviousCandidateDueTo: #keyPressedArrowUp ]) .   (Character arrowDown -> [ self selectNextCandidateDueTo: #keyPressedArrowDown ]) .   (Character arrowUp meta -> [ self selectPreviousCandidateDueTo: #keyPressedArrowUp ]) .   (Character arrowDown meta -> [ self selectNextCandidateDueTo: #keyPressedArrowDown ]) .   (Character arrowUp shift -> [ self selectPreviousCandidateDueTo: #keyPressedArrowUp ]) .   (Character arrowDown shift -> [ self selectNextCandidateDueTo: #keyPressedArrowDown ]) .   (Character arrowUp meta shift -> [ self selectPreviousCategory ]) .   (Character arrowDown meta shift -> [ self selectNextCategory ]) .   (Character arrowRight meta -> [ self diveInDueTo: #keyPressed ]) .   (Character arrowLeft meta -> [ self diveOut ]) .   (Character arrowRight meta shift -> [ self diveInCategoryDueTo: #keyPressed ]) .   (Character arrowLeft meta shift -> [ self diveOut ]) .   (Character arrowUp alt -> [ self stepScrollPageUp ]) .   (Character arrowDown alt -> [ self stepScrollPageDown ]) .   (Character pageUp -> [ self stepScrollPageUp ]) .   (Character pageDown -> [ self stepScrollPageDown ]) .   (Character cr asKeyCombination -> [ self actDueTo: #keyPressed ]) .   ($p meta shift -> [ self exportAsPNGSilently ])}exceptionHandler: anObject  exceptionHandler := anObjectonStepAdded: ann  self pushPane: (self buildPane: ann stepModel)processContext: aSpotterContext  self spotter handleExceptionsDuring: [ self stream removeAllCandidates.        self relevantProcessorsProcess: aSpotterContext ]matches: aString  ^self isEmpty not and: [ self search = aString ]onUnhovered  (self stepModel isCategorySelected: self category) ifFalse: [ self titleBrick hideActionbar ]defaultOrder  ^15actDueTo: anEventType  self spotterModelDo: [ self spotterModel hasSteps ifFalse: [ ^self ].        self spotterModel currentStep hasCandidates ifFalse: [ ^self ].        self spotterModel currentStep actDueTo: anEventType ]select: anObject  selected := anObjecthandleException: anException do: aBlock  GTSpotterExceptionsTest exceptions add: anException.  anException passprepareFilterInContext: aSpotterContext  self context: aSpotterContextexecuteAction  self session runToSelection: self debugger selectionInterval inContext: self currentContextinitializeListeners  self announcer when: #onMouseHover send: #onHovered to: self.  self announcer when: #onMouseUnhover send: #onUnhovered to: selfvariableTag  ^tag ifNil: [ 'temp' ]onAllCandidatesRemoved  self removeAllBricks.  categories := Dictionary new.  self changedonCandidateSelected  (self stepModel isCategorySelected: self category) ifTrue: [ self showActionbar ] ifFalse: [ (self isSelected not and: [ self owner isNotNil and: [ (self owner owner categories includesKey: self category) and: [ (self owner owner categoryBrickOf: self category) isSelected not ] ] ]) ifTrue: [ self hideActionbar ] ]element  ^elementtempIndex: anObject  tempIndex := anObjectallFiles  ^self class cacheDirectory files select: [:each |  each extension = GTPlayPage fileExtension ]defaultOrder  ^200newContextForQuery: aString  ^GTSpotterContext new     step: self;     stream: self stream;     text: aString;     search: aString;     yourselfprocessorLink  ^processorLinkwithIndexDo: aBlock  | index |  index := 0.  self do: [:each |  aBlock cull: each cull: (index := index + 1) ]applyFilterInContext: aSpotterContext error: anException  ('[Spotter] Exception in filter <' , self class name , '>: ' , anException asString) traceCr.  ^self defaultFilteredItemsname: anObject  name := anObjecthasSteps  ^self steps isNotEmptynewHeaderBrick  ^GTSpotterHeaderBrick newcategoryTitleBackgroundColor  ^self backgroundColor alpha: 0.95spotterModel  ^spotterModelcontinuing  ^continuingtext: anObject  text := anObject ifNil: [ self defaultText ]itemFilterNameFor: each  self flag: 'this filter wants to filter items by #selector (speed 10x), but dive-in-category wants to filter by #printString. Most filters in dive-in-category wants to filter by #printString, but not all. Others: files, topics, help, ... ?'.  ^each selectorsetUp  super setUp.  playground := GTPlayground newdefaultFilterClass  ^GTFilterFuzzyitemIconFor: anObject  ^itemIconBlock ifNil: [ super itemIconFor: anObject ] ifNotNil: [ itemIconBlock cull: anObject ]retrieveStackFrom: aSession  ^aSession stacktestDebuggingExceptionHandlerMock1  self shouldRaise: AssertionFailure process: 'abc' origin: GTSpotterExceptionMock1 new do: [:e |  self assert: e messageText equals: GTSpotterExceptionMock1 name ]shouldRaise: anErrorClass process: aString origin: anOrigin during: exceptionHandler do: aBlock  self assertResetExceptions.  spotter exceptionHandler: exceptionHandler.  self assert: spotter exceptionHandler identicalTo: exceptionHandler.  self should: [ self process: aString origin: anOrigin ] raise: anErrorClass withExceptionDo: [:exception |  self assert: exception class identicalTo: anErrorClass.        aBlock value: exception ].  self assert: spotter exceptionHandler identicalTo: exceptionHandler.  self assertException: anErrorClasscheckOrUncheck  (self stepModel isSelected: self candidateLink) ifTrue: [ self isChecked ifFalse: [ self check ] ] ifFalse: [ self isChecked ifTrue: [ self uncheck ] ]openOn: aPage  | window |  window := super openOn: aPage.  window extent: self class preferredExtent.  window when: WindowResizing do: [ (window isMinimized or: [ window isMaximized ]) ifFalse: [ self class setPreferredExtentIfWanted: window extent ] ].  ^windowanimation  ^animationvariablesIn: composite  ^composite fastTable     useCache;     display: [:aContext |  self variablesFromContext: aContext ];     column: 'Type' evaluated: [ '' ] width: 75 tags: [:aNode |  {aNode variableTag} ] sortedBy: [:x :y |  x variableTag < y variableTag ];     column: 'Variable' evaluated: [:aNode |  GTObjectPrinter asNonTruncatedTextFrom: aNode key ] width: 175;     column: 'Value' evaluated: [:aNode |  | rawValue displayValue |        [ rawValue := aNode rawValue ] on: Error do: [ displayValue := Text string: aNode errorMessage attribute: TextColor red ].        displayValue ifNil: [ GTObjectPrinter asTruncatedTextFrom: rawValue ] ];     dynamicActionsOnSelection: [:presentation |  (presentation rawSelection isKindOf: GTInspectorVariableNode) ifTrue: [ presentation rawSelection inspectorActionsForNode ] ifFalse: [ #() ] ];     morphicSelectionAct: [:list |  list selection value browse ] icon: GLMUIThemeExtraIcons glamorousBrowse on: $b entitled: 'Browse';     morphicSelectionAct: [:list |  list selection value inspect ] icon: GLMUIThemeExtraIcons glamorousInspect on: $i entitled: 'Inspect';     onChangeOfPort: #rawSelection act: [:aPresentation |  self debugger selectedVariableName: aPresentation rawSelection key ]contentString  ^self content asStringinitialize  super initialize.  self presentationFilter: (GTInspectorTagFilter new           defaultTag: #custom;           addAndSelectTag: #basic;           addAndSelectTag: #custom;           addAndSelectTag: #examples)codePresentation  ^self codePane presentations firstonRevealHints  self themer spotterThemer hintRevealStyleFor: self settingsButton.  self themer spotterThemer hintRevealStyleFor: self closeButton.  self themer spotterThemer hintRevealStyleFor: self helpButtonselectNextCategory  | currentCategory nextCategory |  currentCategory := self candidates getProcessorLinkByCandidateLink: self selected.  nextCategory := self candidates nextProcessorLinkOf: currentCategory.  self select: (currentCategory = nextCategory ifTrue: [ nextCategory tailLink ] ifFalse: [ nextCategory headLink ])push: aBrick  self themer spotterThemer breadcrumbItemStyleFor: aBrick.  self band layoutAfter: [ self items isEmpty ifFalse: [ self items last hideTriangle.              self addSeparator ].        self addItem: aBrick ].  self items size = 1 ifTrue: [ self notifyBreadcrumbVisibilityChanged ] ifFalse: [ self scrollToTheLastOne.        self changed ]formatStackClassColumnForContext: aContext  ^Text string: (self printStackClassColumnForContext: aContext) attributes: (self textAttributesForStackEntry: aContext)testWithHalt  < haltOrBreakpointForTesting>  self assert: true.  self haltdefaultOrder  ^10addStep: aStepModel  self steps add: aStepModel.  self notifyStepAdded: aStepModelspotterModel  ^spotterModelshortcutBrick  ^shortcutBrickonSelectedChanged: anAnnouncement  self checkOrUncheckshouldRaise: anError process: aString origin: anOrigin  self shouldRaise: anError process: aString origin: anOrigin do: [:exception |   ]arrowBrick: aBrick  arrowBrick := aBrick.  self themer spotterThemer spotterPreviewArrowContainerStyleFor: self arrowBrick.  self addBrickBack: self arrowBrickborder  ^bordertitleBrick  ^titleBrickeventType: anObject  eventType := anObjectstepModel  ^stepModelprocessorLinksMap  ^processorLinksMap ifNil: [ processorLinksMap := Dictionary new ]diveInButton  ^diveInButtonfindTriangleEdgeLength: anInteger  ^2 / 3 * 3 sqrt * anIntegerhelp  ^'Inspect the result of a selected piece of code from the code pane of the debugger.'doubleClick: anEvent  self stepModel actDueTo: #doubleClickwindowIsClosing  self flag: 'bug here when an announcement is inspected?'.  self announce: (GLMBrowserClosing new presentation: self)selectedText  ^(self codePane port: #selectedText) valueinitializeListeners  self activeHand addEventListener: self.  Morph announcer weak when: MorphLostFocus send: #onLostFocus: to: self.  self bindingDictionnary associationsDo: [:anAssociation |  self bindKeyCombination: anAssociation key toAction: anAssociation value ].  processorKeyBindings := Dictionary newpresentersDo: aBlock  self basicPresenters valuesDo: aBlockupdateCodeEditor  self codePane update.  self updateSelectionIntervalinitialize  super initialize.  self     emptyBrick: self newEmptyText;     maxHeight: 350;     height: [:b |  b band height ];     width: 250borderColor  ^self themer popupThemer borderColorcategory: anObject  category := anObjectsearchField: aBrick  searchField := aBrick.  self themer spotterThemer searchFieldStyleFor: searchField.  searchField morph takeKeyboardFocus.  self addBrickBack: searchFieldspotterModel: aSpotterModel  spotterModel := aSpotterModel.  spotterModel announcer when: GTSpotterStepAdded send: #onStepAdded: to: self.  spotterModel announcer when: GTSpotterStepPopped send: #onStepPopped to: selfchangeFilterRequestFor: aGTInspector  self subclassResponsibilitytearDownPresentationTitle  ^'TearDown' , (self session tearDownMethod methodClass ~= self session testContext methodClass ifTrue: [ ' (' , self session tearDownMethod methodClass name , ')' ] ifFalse: [ '' ])handleException: exception forComposite: composite  ('[Spotter] Exception while building the preview content: ' , exception asString) traceCr.  composite removeAllBricksrequestRefresh  (self presentations first paneNamed: #variables) presentations first requestRefreshtempIndex  ^tempIndexglamourAction: anObject  glamourAction := anObjectselectionInterval  ^self selectionIntervalForPane: #codeinitializeSessionForContext: aContext withStepBlock: aBlock  | process |  process := Process forContext: aContext priority: Processor userInterruptPriority.  aBlock value: process.  session := self debuggerToTest spanNewSessionLabeled: 'test session' forContext: process suspendedContext fromProcess: processnext  ^self nextLinktagPragmaKey  ^#gtInspectorTag:debugger  ^debugger