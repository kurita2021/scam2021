testRemoveCandidatesA1FromA1A2A3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  tmp7 := candidates addProcessor: GTSpotterA1.  tmp8 := candidates addProcessor: GTSpotterA2.  tmp9 := candidates addProcessor: GTSpotterA3.  candidates addCandidate: 11 in: GTSpotterA1.  candidates addCandidate: 12 in: GTSpotterA1.  candidates addCandidate: 13 in: GTSpotterA1.  tmp1 := candidates addCandidate: 21 in: GTSpotterA2.  tmp2 := candidates addCandidate: 22 in: GTSpotterA2.  tmp3 := candidates addCandidate: 23 in: GTSpotterA2.  tmp4 := candidates addCandidate: 31 in: GTSpotterA3.  tmp5 := candidates addCandidate: 32 in: GTSpotterA3.  tmp6 := candidates addCandidate: 33 in: GTSpotterA3.  candidates removeAllCandidatesOf: GTSpotterA1.  self assert: tmp1 nextLink equals: tmp2.  self assert: tmp1 previousLink equals: tmp6.  self assert: tmp2 nextLink equals: tmp3.  self assert: tmp2 previousLink equals: tmp1.  self assert: tmp3 nextLink equals: tmp4.  self assert: tmp3 previousLink equals: tmp2.  self assert: tmp4 nextLink equals: tmp5.  self assert: tmp4 previousLink equals: tmp3.  self assert: tmp5 nextLink equals: tmp6.  self assert: tmp5 previousLink equals: tmp4.  self assert: tmp6 nextLink equals: tmp1.  self assert: tmp6 previousLink equals: tmp5.  self assert: candidates head equals: tmp1.  self assert: candidates tail equals: tmp6.  self assert: tmp7 headLink equals: nil.  self assert: tmp7 tailLink equals: nil.  self assert: tmp8 headLink equals: tmp1.  self assert: tmp8 tailLink equals: tmp3.  self assert: tmp9 headLink equals: tmp4.  self assert: tmp9 tailLink equals: tmp6titleMarginLeft  ^20onThemerChanged  super onThemerChanged.  self doLayoutForcetestNextA1A2Category  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp7 := candidates addProcessor: GTSpotterA1.  tmp8 := candidates addProcessor: GTSpotterA2.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp2 := candidates addCandidate: 12 in: GTSpotterA1.  tmp3 := candidates addCandidate: 13 in: GTSpotterA1.  tmp4 := candidates addCandidate: 21 in: GTSpotterA2.  tmp5 := candidates addCandidate: 22 in: GTSpotterA2.  tmp6 := candidates addCandidate: 23 in: GTSpotterA2.  self assert: tmp7 equals: (candidates nextProcessorLinkOf: tmp8).  self assert: tmp8 equals: (candidates nextProcessorLinkOf: tmp7)matchAlike  self filter: GTFilterAlikeallCandidatesIn: arg1  ^self allItemsIn: arg1appliesToDebugger: arg1  ^arg1 session class = GTSUnitDebugSession and: [ arg1 session assertionCallerContext notNil and: [ arg1 session testContext ~= arg1 session assertionCallerContext ] ]calculateItemWidth: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self themer spotterThemer breadcrumbSeparatorWidth.  tmp2 := self width.  tmp4 := ((arg1 labelBrick approximateWidth min: tmp2 / 2) max: (tmp2 - ((self maxNumberOfSteps - 1) * tmp1)) / self maxNumberOfSteps) floor.  tmp3 := ((tmp2 - tmp4 - ((self maxNumberOfSteps - 1) * tmp1)) / (self maxNumberOfSteps - 1)) floor.  ^arg1 isLastInOwner ifTrue: [ self items size >= self maxNumberOfSteps ifTrue: [ | tmp5 tmp6 |              tmp5 := tmp4 + ((self maxNumberOfSteps - 1) * (tmp1 + tmp3)).              tmp6 := tmp2 - tmp5.              tmp4 := tmp4 + tmp6 ].        tmp4 ] ifFalse: [ tmp3 ]currentClass  ^self currentContext methodClassaddAndSelectTag: arg1  self addTag: arg1.  (selectedTags includes: arg1) ifFalse: [ selectedTags add: arg1 ]handleException: arg1 do: arg2  super handleException: arg1 do: arg2.  ^arg2 valuefilterInContext: arg1  [ self basicFilterInContext: arg1 ] on: Error do: [:arg2 |  self exceptionHandler handleException: arg2 do: [ ('[Spotter] Exception in processor <' , self title asString , '>: ' , arg2 asString) traceCr ] ]executeAction  self debugger stackPresentation selection: self debugger session testContextselectedContext  self subclassResponsibilityaddProcessor: arg1  | tmp1 |  tmp1 := arg1 asSpotterProcessorLink.  self processorLinksMap add: arg1 -> tmp1.  self processors addLast: tmp1.  ^tmp1key  ^slotNamesetModelBeforeInitialization: arg1  debugger := arg1debugActionExecutedAnnouncement  ^debugActionExecutedAnnouncementprocess: arg1 context: arg2  super process: arg1 context: arg2.  assertionContext ifNil: [ self initializeTestContextFrom: arg2.        self initializeAssestionContextFrom: arg2.        self supportsDiff ifTrue: [ actualResult := assertionContext tempAt: 1.              expectedResult := assertionContext tempAt: 2 ] ]gtDisplayOn: arg1  arg1     nextPutAll: 'Processor: ';     nextPutAll: self title asStringspotterForStashedPlaygroundPagesFor: arg1  < spotterOrder: 100>  arg1 listProcessor     allCandidates: [ | tmp1 |        tmp1 := GTPlayBook stashDirectory files select: [:arg2 |  arg2 extension = GTPlayPage fileExtension ].        tmp1 collect: [:arg3 |  (GTPlayPage fromFileReference: arg3) title: (arg3 basename copyUpTo: $-) ] ];     title: 'Playground named pages';     itemName: [:arg4 |  arg4 title , ' - ' , arg4 content asString contractTo: 100 ];     filter: self defaultFilterClassstreamed  ^streamed ifNil: [ streamed := self defaultStreamed ]gtDisplayOn: arg1  arg1 nextPutAll: 'Candidate link: '.  self value gtDisplayOn: arg1showDropDownPane  self dropDownBrick: self newDropDownMorph.  self dropDownBrick spotterModel: self spotterModeleventType  ^eventTypeaddItem: arg1 to: arg2  | tmp1 |  self assert: arg1 isNotNil.  self assert: arg2 isNotNil.  tmp1 := arg2 hasSubbricks not.  arg2 addItem: arg1.  tmp1 ifTrue: [ self addCategory: arg2 ]installStackDebuggingActionsFor: arg1  self installActionsForRootPragmas: self stackDebuggingActionsPragmas in: arg1actDueTo: arg1  self assert: [ self hasSelected ] description: [ 'Spotter can not perform an action due to ' , arg1 asString , ' if there is no selected candidate' ].  self spotter     historize: self selected;     notifyActOn: self selectedCandidate for: arg1.  self selectedCategory actOn: self selectedCandidate for: selfid  ^#gtBrowseMethodDebuggerActioninitializeWidgets  actions := self instantiate: GTSpecPreDebugActionsPresenter.  textPresenter := self newText.  textPresenter disable.  self focusOrder     add: actions;     add: textPresenteracceptContents: arg1  self flag: #TODO.  self saveContent: arg1.  ^truenewPaneBrick  ^GTSpotterPaneBrick newisTriangleVisible  ^isTriangleVisible ifNil: [ isTriangleVisible := true ]origin  ^originexceptionHandler  ^GTCurrentSpotterExceptionHandler value ifNil: [ self spotter exceptionHandler ]onThemerChanged  super onThemerChanged.  self themer spotterThemer spotterPreviewWidgetStyleFor: selftestWithErrorInSetup  self assert: a equals: 41testArrayPairsEqualLimit  | tmp1 tmp2 |  tmp1 := 2 * GTInspector indexableDisplayLimit.  tmp2 := (1 to: tmp1) asArray gtInspectorVariableValuePairs.  self assert: tmp2 size equals: tmp1.  (tmp2 collect: #key) allSatisfy: [:arg1 |  (tmp2 at: arg1) = arg1 ].  self assert: (tmp2 collect: #key) equals: (1 to: tmp1) asOrderedCollectionbrowser  ^self presentations firstupdateSelectionInterval  self selectedContext ifNil: [ ^self ].  self selectionInterval: (self session selectedCodeRangeForContext: self selectedContext)basicVariableNodesFor: arg1  ^#()cacheAt: arg1 ifAbsent: arg2  ^self cache at: arg1 ifAbsent: arg2filter: arg1  filter := arg1render: arg1  ^GTSpotterItemBrick new     icon: nil;     text: arg1 gtDisplayStringisPreviewVisible  ^isPreviewVisible ifNil: [ isPreviewVisible := false ]selectFirst  self assert: [ self candidates isNotEmpty ] description: [ 'There must be at least one candidate in order to select the first' ].  self select: self candidates headnotifyCurrentStepChanged  self announce: GTSpotterCurrentStepChanged newexecuteAction  self codePresentation debugSelectiontestDictionary  self assert: (#(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 51 51 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 81 81 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101) inject: Dictionary new into: [:arg1 :arg2 |  arg1 at: arg2 put: arg2 << 5.              arg1 ]) equals: (#(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101) inject: Dictionary new into: [:arg1 :arg2 |  arg2 \\ 40 == 0 ifTrue: [ arg1 at: arg2 put: arg2 << 6 ] ifFalse: [ arg1 at: arg2 put: arg2 << 5 ].              arg1 ])triangleBrick: arg1  triangleBrick := arg1.  self triangleBrick     hintTitle: 'Toggle preview';     hintText: '<' , OSPlatform current defaultModifier name asLowercase , '+p>';     action: [ self spotterModel togglePreview ].  self themer spotterThemer spotterPreviewArrowStyleFor: self triangleBrick.  self addBrickBack: self triangleBrickreplaceSelectedTagsWith: arg1 in: arg2  selectedTags := arg1.  arg2 updatediveInCategoryDueTo: arg1  self spotterModelDo: [:arg2 |  arg2 hasSelected ifTrue: [ arg2 currentStep diveInCategoryDueTo: arg1 ] ]actOnPaneRemoved: arg1  self panes last updateToolbarcategoryMarginBottom  ^(self itemHeight * (2 / 3)) ceilingeventType: arg1  eventType := arg1renderRightTriangle: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp6 := arg1 themer spotterThemer previewArrowGapHack.  arg2 fillRectangle: (arg1 brickBounds withWidth: (tmp6 - self border max: 0)) color: arg1 color.  tmp4 := arg1 brickBounds width - tmp6.  tmp5 := arg1 brickBounds height.  tmp1 := arg1 brickBounds topLeft + (tmp6 @ (tmp5 / 2 - tmp4 max: 0)) - (0 @ 1).  tmp2 := arg1 brickBounds topLeft + (tmp6 @ (tmp5 / 2 + tmp4 min: tmp5)) - (0 @ self border negated) - (0 @ self border).  tmp3 := arg1 brickBounds topRight + (0 @ (tmp5 / 2)).  self border > 0 ifTrue: [ self renderTriangle: arg1 on: arg2 with: {tmp1 asIntegerPoint .               tmp2 asIntegerPoint .               tmp3 asIntegerPoint} color: self borderColor.        self renderTriangle: arg1 on: arg2 with: {(tmp1 asIntegerPoint - ((self border + 1) @ 0)) .               (tmp2 asIntegerPoint - ((self border + 1) @ 0)) .               (tmp3 asIntegerPoint - ((self border + 1) @ 0))} ] ifFalse: [ self renderTriangle: arg1 on: arg2 with: {tmp1 asIntegerPoint .               tmp2 asIntegerPoint .               tmp3 asIntegerPoint} ]matcher: arg1  matcher := arg1getCandidateLink: arg1 in: arg2  (self getCandidateLinks: (self getProcessorLink: arg2)) do: [:arg3 |  arg3 value = arg1 ifTrue: [ ^arg3 ] ].  ^nilnewShortcutBrick  ^GLMLabelBrick newshouldRaise: arg1 process: arg2 origin: arg3 during: arg4  self shouldRaise: arg1 process: arg2 origin: arg3 during: arg4 do: [:arg5 |   ]applyFilterWithoutQuery  [ self streamed ifTrue: [ | tmp1 |        self filteredItems: (tmp1 := OrderedCollection new).        self allItems withIndexDo: [:arg1 :arg2 |  tmp1 add: arg1.              self addItem: arg1.              arg2 = self itemsLimit ifTrue: [ GTLimitArrived signal ] ] ] ifFalse: [ self filteredItems: (self allItems first: (self itemsLimit min: self allItems size)).        self addItems: self filteredItems ] ] on: GTLimitArrived do: [ ^self ]changeFilterRequestFor: arg1  self openListChooseLabeled: 'All available tags' forInspector: arg1 with: allTags select: selectedTags format: #printString actionSelector: #replaceSelectedTagsWith:in:isPresentation: arg1 inPane: arg2  ^arg2 presentations first cachedPresentation ifNil: [ false ] ifNotNil: [:arg3 |  arg3 first includes: arg1 ]candidatesLimit  ^self itemsLimitid  ^#gTPrintSelectionDebugActionnotifyCandidateSelected: arg1 for: arg2  self announce: (GTSpotterSelectedCandidateChanged new           select: arg1;           eventType: arg2)itemActionButtonWidgetStyleFor: arg1  arg1 pressedColor: self itemActionSelectedBackgroundColortestSettingBindings  | tmp1 |  tmp1 := nil.  window := playground openOn: (GTPlayPage new saveContent: 'number+1').  playground setBindings: {(#number -> 2)} asDictionary.  playground inspectorPresentation firstPresentation selectLine.  playground inspectorPresentation firstPresentation announce: (GLMEvaluateSelection new           action: [:arg1 |  tmp1 := arg1 ];           makeSyncronous).  self assert: tmp1 equals: 3steps  ^steps ifNil: [ steps := OrderedCollection new ]step  self window ifNil: [ ^self ].  self window isActive ifFalse: [ ^self ].  self wantsAutomaticRefresh ifTrue: [ self requestRefresh ]setUp  super setUp.  spotter := GTSpotter new.  self class resetitemHeight  ^16 + self theme labelFont heightrenderTriangle: arg1 on: arg2 with: arg3 color: arg4  arg2 drawPolygon: arg3 color: arg4 borderWidth: 0 borderColor: Color transparentstepScrollPageDown  self spotterModel currentStep announcer announce: GTSpotterScrollPageDown newonCandidateAdded: arg1  self addItem: (self buildItemFor: arg1 candidateLink in: arg1 category) to: (self categoryBrickFor: arg1 category)on: arg1 category: arg2  self stepModel: arg1.  self category: arg2.  self nameBrick: self newNameBrick.  self nameBrick text: '#' , arg2 title.  arg2 keyBinding ifNotNil: [ self shortcutBrick: self newShortcutBrick.        self setShortcutBrickTextFor: arg2 ].  self amountBrick: self newAmountBrick.  self amountBrick text: '0/0'.  self actionbarBrick: self newActionbarBrick.  self addDiveInButton.  self onCandidateSelected.  self nameBrick wrappedBounds markWidthDirty.  self nameBrick label wrappedBounds markWidthDirty.  self doLayoutForce.  ^selfhasPreviousNavigationFromClass: arg1  < return: #Boolean>  ^self hasPreviousStep and: [ self previousStep origin isKindOf: arg1 ]assertionCallerContext  ^assertionCallerContextshowPreview  self isPreviewVisible ifTrue: [ ^self ].  isPreviewVisible := true.  self class showPreview.  self notifyShowPreviewlabel: arg1  label := arg1help  ^'Profile the execution of a selected piece of code from the code pane of the debugger.'asyncTask  ^asyncTask ifNil: [ asyncTask := self defaultTask ]spotterForHelpTopicFor: arg1  < spotterOrder: 200>  arg1 listProcessor     allCandidates: [ SystemHelp asHelpTopic gtAllSubtopics ];     title: 'Help topics';     itemName: [:arg2 |  arg2 title ];     itemIcon: [:arg2 |  arg2 gtTopicIcon ];     filter: self defaultFilterClass;     wantsToDisplayOnEmptyQuery: truehelp  ^'Switch to another debugger'render: arg1 on: arg2  self orientation = #right ifTrue: [ self renderRightTriangle: arg1 on: arg2 ].  self orientation = #bottom ifTrue: [ self renderBottomTriangle: arg1 on: arg2 ].  self orientation = #left ifTrue: [ self renderLeftTriangle: arg1 on: arg2 ].  self orientation = #top ifTrue: [ self renderTopTriangle: arg1 on: arg2 ]initialExtent  RealEstateAgent standardWindowExtent y < 400 ifTrue: [ ^700 @ 500 ].  ^[ | tmp1 tmp2 |  tmp1 := Display width.  tmp2 := Display height.  (tmp1 - (tmp1 // 3)) @ (tmp2 - (tmp2 // 5)) ] on: Error do: [ 850 @ 600 ]tailLink: arg1  tailLink := arg1notifyDiveIn: arg1 for: arg2  self announce: (GTSpotterDiveInElement new           element: arg1;           eventType: arg2)stepModel: arg1  stepModel := arg1bindingDictionnary  ^{(Character escape -> [ self spotterModel exitDueTo: #keyPressedEscape ]) .   ($w meta -> [ self spotterModel exitDueTo: #keyPressedW ]) .   ($p meta -> [ self togglePreview ]) .   ($i meta -> [ self spotterModel inspectIt ]) .   ($d meta -> [ self spotterModel doIt ]) .   (Character arrowUp -> [ self selectPreviousCandidateDueTo: #keyPressedArrowUp ]) .   (Character arrowDown -> [ self selectNextCandidateDueTo: #keyPressedArrowDown ]) .   (Character arrowUp meta -> [ self selectPreviousCandidateDueTo: #keyPressedArrowUp ]) .   (Character arrowDown meta -> [ self selectNextCandidateDueTo: #keyPressedArrowDown ]) .   (Character arrowUp shift -> [ self selectPreviousCandidateDueTo: #keyPressedArrowUp ]) .   (Character arrowDown shift -> [ self selectNextCandidateDueTo: #keyPressedArrowDown ]) .   (Character arrowUp meta shift -> [ self selectPreviousCategory ]) .   (Character arrowDown meta shift -> [ self selectNextCategory ]) .   (Character arrowRight meta -> [ self diveInDueTo: #keyPressed ]) .   (Character arrowLeft meta -> [ self diveOut ]) .   (Character arrowRight meta shift -> [ self diveInCategoryDueTo: #keyPressed ]) .   (Character arrowLeft meta shift -> [ self diveOut ]) .   (Character arrowUp alt -> [ self stepScrollPageUp ]) .   (Character arrowDown alt -> [ self stepScrollPageDown ]) .   (Character pageUp -> [ self stepScrollPageUp ]) .   (Character pageDown -> [ self stepScrollPageDown ]) .   (Character cr asKeyCombination -> [ self actDueTo: #keyPressed ]) .   ($p meta shift -> [ self exportAsPNGSilently ])}exceptionHandler: arg1  exceptionHandler := arg1onStepAdded: arg1  self pushPane: (self buildPane: arg1 stepModel)processContext: arg1  self spotter handleExceptionsDuring: [ self stream removeAllCandidates.        self relevantProcessorsProcess: arg1 ]matches: arg1  ^self isEmpty not and: [ self search = arg1 ]onUnhovered  (self stepModel isCategorySelected: self category) ifFalse: [ self titleBrick hideActionbar ]defaultOrder  ^15actDueTo: arg1  self spotterModelDo: [ self spotterModel hasSteps ifFalse: [ ^self ].        self spotterModel currentStep hasCandidates ifFalse: [ ^self ].        self spotterModel currentStep actDueTo: arg1 ]select: arg1  selected := arg1handleException: arg1 do: arg2  GTSpotterExceptionsTest exceptions add: arg1.  arg1 passprepareFilterInContext: arg1  self context: arg1executeAction  self session runToSelection: self debugger selectionInterval inContext: self currentContextinitializeListeners  self announcer when: #onMouseHover send: #onHovered to: self.  self announcer when: #onMouseUnhover send: #onUnhovered to: selfvariableTag  ^tag ifNil: [ 'temp' ]onAllCandidatesRemoved  self removeAllBricks.  categories := Dictionary new.  self changedonCandidateSelected  (self stepModel isCategorySelected: self category) ifTrue: [ self showActionbar ] ifFalse: [ (self isSelected not and: [ self owner isNotNil and: [ (self owner owner categories includesKey: self category) and: [ (self owner owner categoryBrickOf: self category) isSelected not ] ] ]) ifTrue: [ self hideActionbar ] ]element  ^elementtempIndex: arg1  tempIndex := arg1allFiles  ^self class cacheDirectory files select: [:arg1 |  arg1 extension = GTPlayPage fileExtension ]defaultOrder  ^200newContextForQuery: arg1  ^GTSpotterContext new     step: self;     stream: self stream;     text: arg1;     search: arg1;     yourselfprocessorLink  ^processorLinkwithIndexDo: arg1  | tmp1 |  tmp1 := 0.  self do: [:arg2 |  arg1 cull: arg2 cull: (tmp1 := tmp1 + 1) ]applyFilterInContext: arg1 error: arg2  ('[Spotter] Exception in filter <' , self class name , '>: ' , arg2 asString) traceCr.  ^self defaultFilteredItemsname: arg1  name := arg1hasSteps  ^self steps isNotEmptynewHeaderBrick  ^GTSpotterHeaderBrick newcategoryTitleBackgroundColor  ^self backgroundColor alpha: 0.95spotterModel  ^spotterModelcontinuing  ^continuingtext: arg1  text := arg1 ifNil: [ self defaultText ]itemFilterNameFor: arg1  self flag: 'this filter wants to filter items by #selector (speed 10x), but dive-in-category wants to filter by #printString. Most filters in dive-in-category wants to filter by #printString, but not all. Others: files, topics, help, ... ?'.  ^arg1 selectorsetUp  super setUp.  playground := GTPlayground newdefaultFilterClass  ^GTFilterFuzzyitemIconFor: arg1  ^itemIconBlock ifNil: [ super itemIconFor: arg1 ] ifNotNil: [ itemIconBlock cull: arg1 ]retrieveStackFrom: arg1  ^arg1 stacktestDebuggingExceptionHandlerMock1  self shouldRaise: AssertionFailure process: 'abc' origin: GTSpotterExceptionMock1 new do: [:arg1 |  self assert: arg1 messageText equals: GTSpotterExceptionMock1 name ]shouldRaise: arg1 process: arg2 origin: arg3 during: arg4 do: arg5  self assertResetExceptions.  spotter exceptionHandler: arg4.  self assert: spotter exceptionHandler identicalTo: arg4.  self should: [ self process: arg2 origin: arg3 ] raise: arg1 withExceptionDo: [:arg6 |  self assert: arg6 class identicalTo: arg1.        arg5 value: arg6 ].  self assert: spotter exceptionHandler identicalTo: arg4.  self assertException: arg1checkOrUncheck  (self stepModel isSelected: self candidateLink) ifTrue: [ self isChecked ifFalse: [ self check ] ] ifFalse: [ self isChecked ifTrue: [ self uncheck ] ]openOn: arg1  | tmp1 |  tmp1 := super openOn: arg1.  tmp1 extent: self class preferredExtent.  tmp1 when: WindowResizing do: [ (tmp1 isMinimized or: [ tmp1 isMaximized ]) ifFalse: [ self class setPreferredExtentIfWanted: tmp1 extent ] ].  ^tmp1animation  ^animationvariablesIn: arg1  ^arg1 fastTable     useCache;     display: [:arg2 |  self variablesFromContext: arg2 ];     column: 'Type' evaluated: [ '' ] width: 75 tags: [:arg3 |  {arg3 variableTag} ] sortedBy: [:arg4 :arg5 |  arg4 variableTag < arg5 variableTag ];     column: 'Variable' evaluated: [:arg3 |  GTObjectPrinter asNonTruncatedTextFrom: arg3 key ] width: 175;     column: 'Value' evaluated: [:arg3 |  | tmp1 tmp2 |        [ tmp1 := arg3 rawValue ] on: Error do: [ tmp2 := Text string: arg3 errorMessage attribute: TextColor red ].        tmp2 ifNil: [ GTObjectPrinter asTruncatedTextFrom: tmp1 ] ];     dynamicActionsOnSelection: [:arg6 |  (arg6 rawSelection isKindOf: GTInspectorVariableNode) ifTrue: [ arg6 rawSelection inspectorActionsForNode ] ifFalse: [ #() ] ];     morphicSelectionAct: [:arg7 |  arg7 selection value browse ] icon: GLMUIThemeExtraIcons glamorousBrowse on: $b entitled: 'Browse';     morphicSelectionAct: [:arg7 |  arg7 selection value inspect ] icon: GLMUIThemeExtraIcons glamorousInspect on: $i entitled: 'Inspect';     onChangeOfPort: #rawSelection act: [:arg8 |  self debugger selectedVariableName: arg8 rawSelection key ]contentString  ^self content asStringinitialize  super initialize.  self presentationFilter: (GTInspectorTagFilter new           defaultTag: #custom;           addAndSelectTag: #basic;           addAndSelectTag: #custom;           addAndSelectTag: #examples)codePresentation  ^self codePane presentations firstonRevealHints  self themer spotterThemer hintRevealStyleFor: self settingsButton.  self themer spotterThemer hintRevealStyleFor: self closeButton.  self themer spotterThemer hintRevealStyleFor: self helpButtonselectNextCategory  | tmp1 tmp2 |  tmp1 := self candidates getProcessorLinkByCandidateLink: self selected.  tmp2 := self candidates nextProcessorLinkOf: tmp1.  self select: (tmp1 = tmp2 ifTrue: [ tmp2 tailLink ] ifFalse: [ tmp2 headLink ])push: arg1  self themer spotterThemer breadcrumbItemStyleFor: arg1.  self band layoutAfter: [ self items isEmpty ifFalse: [ self items last hideTriangle.              self addSeparator ].        self addItem: arg1 ].  self items size = 1 ifTrue: [ self notifyBreadcrumbVisibilityChanged ] ifFalse: [ self scrollToTheLastOne.        self changed ]formatStackClassColumnForContext: arg1  ^Text string: (self printStackClassColumnForContext: arg1) attributes: (self textAttributesForStackEntry: arg1)testWithHalt  < haltOrBreakpointForTesting>  self assert: true.  self haltdefaultOrder  ^10addStep: arg1  self steps add: arg1.  self notifyStepAdded: arg1spotterModel  ^spotterModelshortcutBrick  ^shortcutBrickonSelectedChanged: arg1  self checkOrUncheckshouldRaise: arg1 process: arg2 origin: arg3  self shouldRaise: arg1 process: arg2 origin: arg3 do: [:arg4 |   ]arrowBrick: arg1  arrowBrick := arg1.  self themer spotterThemer spotterPreviewArrowContainerStyleFor: self arrowBrick.  self addBrickBack: self arrowBrickborder  ^bordertitleBrick  ^titleBrickeventType: arg1  eventType := arg1stepModel  ^stepModelprocessorLinksMap  ^processorLinksMap ifNil: [ processorLinksMap := Dictionary new ]diveInButton  ^diveInButtonfindTriangleEdgeLength: arg1  ^2 / 3 * 3 sqrt * arg1help  ^'Inspect the result of a selected piece of code from the code pane of the debugger.'doubleClick: arg1  self stepModel actDueTo: #doubleClickwindowIsClosing  self flag: 'bug here when an announcement is inspected?'.  self announce: (GLMBrowserClosing new presentation: self)selectedText  ^(self codePane port: #selectedText) valueinitializeListeners  self activeHand addEventListener: self.  Morph announcer weak when: MorphLostFocus send: #onLostFocus: to: self.  self bindingDictionnary associationsDo: [:arg1 |  self bindKeyCombination: arg1 key toAction: arg1 value ].  processorKeyBindings := Dictionary newpresentersDo: arg1  self basicPresenters valuesDo: arg1updateCodeEditor  self codePane update.  self updateSelectionIntervalinitialize  super initialize.  self     emptyBrick: self newEmptyText;     maxHeight: 350;     height: [:arg1 |  arg1 band height ];     width: 250borderColor  ^self themer popupThemer borderColorcategory: arg1  category := arg1searchField: arg1  searchField := arg1.  self themer spotterThemer searchFieldStyleFor: searchField.  searchField morph takeKeyboardFocus.  self addBrickBack: searchFieldspotterModel: arg1  spotterModel := arg1.  spotterModel announcer when: GTSpotterStepAdded send: #onStepAdded: to: self.  spotterModel announcer when: GTSpotterStepPopped send: #onStepPopped to: selfchangeFilterRequestFor: arg1  self subclassResponsibilitytearDownPresentationTitle  ^'TearDown' , (self session tearDownMethod methodClass ~= self session testContext methodClass ifTrue: [ ' (' , self session tearDownMethod methodClass name , ')' ] ifFalse: [ '' ])handleException: arg1 forComposite: arg2  ('[Spotter] Exception while building the preview content: ' , arg1 asString) traceCr.  arg2 removeAllBricksrequestRefresh  (self presentations first paneNamed: #variables) presentations first requestRefreshtempIndex  ^tempIndexglamourAction: arg1  glamourAction := arg1selectionInterval  ^self selectionIntervalForPane: #codeinitializeSessionForContext: arg1 withStepBlock: arg2  | tmp1 |  tmp1 := Process forContext: arg1 priority: Processor userInterruptPriority.  arg2 value: tmp1.  session := self debuggerToTest spanNewSessionLabeled: 'test session' forContext: tmp1 suspendedContext fromProcess: tmp1next  ^self nextLinktagPragmaKey  ^#gtInspectorTag:debugger  ^debugger