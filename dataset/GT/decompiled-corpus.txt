hideTriangle  isTriangleVisible := false.  self themer spotterThemer breadcrumbItemTriangleWidgetStyleFor: self triangleBrickselectedVariableName  ^self cache at: #selectedVariableName ifAbsent: [ nil ]diveIn  self diveInDueTo: #undefinedtogglePreview  self isPreviewVisible ifTrue: [ self hidePreview ] ifFalse: [ self showPreview ]itemIcon: arg1  itemIconBlock := arg1notifySelectedCandidateChanged: arg1 for: arg2  | tmp1 |  self assert: [ arg1 isNotNil ] description: [ 'aCandidateLink must not be nil' ].  tmp1 := arg1 candidate.  self announcer announce: (GTSpotterSelectedCandidateChanged new select: tmp1).  self spotter notifyCandidateSelected: tmp1 for: arg2isMatchedItem: arg1  ^query match: (self itemFilterNameFor: arg1)stackWidgetIn: arg1  ^arg1 fastTable     title: 'Stack';     useCache;     display: [:arg2 |  self retrieveStackFrom: arg2 ];     column: 'Class' evaluated: [:arg3 |  self formatStackClassColumnForContext: arg3 ] width: 300;     column: 'Method' evaluated: [:arg3 |  self formatStackMethodColumnForContext: arg3 ];     column: 'Other' evaluated: [:arg3 |  self formatStackExtraColumnForContext: arg3 ];     hideHeaderrelevantProcessorsProcess: arg1  [ self basicRelevantProcessorsProcess: arg1 ] on: Error do: [:arg2 |  self exceptionHandler handleException: arg2 do: [ ('[Spotter] Exception in process: ' , arg2 asString) traceCr ] ]allActionsForPragmas: arg1  ^self session class debuggingActionsForPragmas: arg1 for: selfisEmpty  self deprecated: 'Use hasCandidates instead'.  ^self hasCandidates notinspectorActionsForNode  < return: #Collection of: #GLMAction>  ^self browsingActionsForNodespotterModelDo: arg1  self spotterModel handleExceptionsDuring: [ arg1 cull: self spotterModel.        self handleProcessorKeyBindings ]resetBindings  ^self inspectorPresentation firstPresentation resetBindingsitemBrick: arg1  candidateBrick := arg1renderingProcessor: arg1  renderingProcessorLink ifNil: [ renderingProcessorLink := arg1 processor asSpotterProcessorLink ].  processorLink ifNil: [ processorLink := arg1 ]onStepAdded  previewObject := nil.  self updatePreviewWithLoadingstreamed: arg1  streamed := arg1match: arg1  self filter: (GTFilterBlock new           matcher: arg1;           yourself)saveContent: arg1  self content: arg1.  self savecacheAt: arg1 ifAbsentPut: arg2  ^self cache at: arg1 ifAbsentPut: arg2mockProcessorFor: arg1  < spotterOrder: 1>  arg1 listProcessor     allCandidates: [ #(1 2 3) ];     itemName: [:arg2 |  arg2 / 0 ];     filter: GTFilterSubstringprocessorsFilter  ^processorsFilterorientation: arg1  orientation := arg1context  ^contextdefaultStream  ^GTMockSpotterStream newactOn: arg1 for: arg2  arg1 spotterActDefault: arg2defaultKeymap  ^$g metatestPageActionsIn  | tmp1 tmp2 tmp3 |  tmp2 := playground class compile: 'mockMethodPageAction	<pageActionOrder: 10>	^ GLMGenericAction new		action: [ :presentation | self inform: ''page action works'' ];		iconNamed: #abstract;		title: ''A mock page action''' classified: '*GTMockTests'.  self assert: tmp2 notNil.  window := playground openOn: (GTPlayPage new saveContent: 'a:=1. b:=a+1').  tmp1 := playground pageActions.  self denyEmpty: tmp1.  tmp3 := tmp1 detect: [:arg1 |  arg1 title = 'A mock page action' ].  self deny: tmp3 isNilnewActionbarBrick  ^GLMBrick newtestDeploymentExceptionHandlerMock1  self assertResetExceptions.  self shouldntRaise: AssertionFailure process: 'abc' origin: GTSpotterExceptionMock1 new.  self assertException: AssertionFailure.  self assertResetExceptions.  self shouldntRaise: Error process: 'abc' origin: GTSpotterExceptionMock1 new.  self assertException: AssertionFailurehelp  ^'Open a sytem browser on the current method.'spotterForExpressionsFor: arg1  < spotterOrder: 1>  self flag: #specialFilter.  arg1 listProcessor     title: 'Calculator';     filter: GTNullFilter item: [:arg2 :arg3 |  self evaluateExpressionInContext: arg3 usingFilter: arg2 ];     wantsToDisplayOnEmptyQuery: falsenewBand  ^GLMBrick newisStash  ^falseitemFilterNameFor: arg1  ^itemFilterNameBlock ifNil: [ super itemFilterNameFor: arg1 ] ifNotNil: [ itemFilterNameBlock cull: arg1 ]itemFilterNameFor: arg1  ^self itemNameFor: arg1debugger: arg1  debugger := arg1openInWindowLabeled: arg1 inWorld: arg2  self autoHide: false.  ^super openInWindowLabeled: arg1 inWorld: arg2handleFatalException: arg1  GTSpotterExceptionsTest fatals add: arg1snippetAt: arg1  ^self snippets at: arg1 ifAbsent: [ 'self' ]methodBytecodeWidgetIn: arg1 forContext: arg2  ^arg1 tree     title: 'Bytecode';     rootsExpanded;     display: [ arg2 method symbolicBytecodes ];     children: [:arg3 |  arg3 isArray ifTrue: [ arg3 ] ifFalse: #() ];     format: [:arg3 |  self formatBytecode: arg3 ];     onChangeOfPort: #selection act: [:arg4 |  self codePresentation selectionInterval: (arg4 selection ifNil: [ 1 to: 0 ] ifNotNil: [:arg5 |  arg5 sourceInterval ]) ]onThemerChanged  super onThemerChanged.  self themer spotterThemer breadcrumbItemLabelWidgetStyleFor: self labelBrick.  self themer spotterThemer breadcrumbItemTriangleWidgetStyleFor: self triangleBrickrequestRefresh  self inspectorPresentation refreshPanesremove  (self ownerThatIsA: GLMFoundationBrick) ifNotNil: [:arg1 |  arg1 delete ]hasCategories: arg1  | tmp1 |  candidates processors asArray size = arg1 size ifFalse: [ ^false ].  tmp1 := 1.  candidates processors asArray do: [:arg2 |  arg2 = (arg1 at: tmp1) ifFalse: [ ^false ].        tmp1 := tmp1 + 1 ].  ^trueprivateAddCandidate: arg1 inNotEmpty: arg2  self candidates add: arg1 afterLink: arg2 tailLink.  arg2 incrementSize.  arg2 tailLink: arg1.  ^arg1notifyActOn: arg1 for: arg2  self announce: (GTSpotterActOn new           element: arg1;           eventType: arg2)cache  ^cache ifNil: [ cache := Dictionary new ]toggleHints  self visible ifFalse: [ ^self ].  self stepModel spotter isShiftPressed ifTrue: [ self onRevealHints ] ifFalse: [ self onHideHints ]selectedCandidate  < return: #Object>  ^self selected candidatetext: arg1  self labelBrick text: arg1.  self doLayoutForceemptyTextPadding  ^15update  self debugAction ifNotNil: [:arg1 |  self label: arg1 label.        self help: arg1 help , Character tab asString , (arg1 keymap ifNil: [ '' ] ifNotNil: [:arg2 |  arg2 printString ]).        self icon: arg1 icon.        self enabled: arg1 enabled.        self state: false.        self action: [ arg1 execute ] ]processor  ^self context processordeselect  selected := nilexecuteAction  self codePresentation evaluateSelectionAndDo: [:arg1 |  shouldBasicInspect ifTrue: [ arg1 basicInspect ] ifFalse: [ arg1 inspect ] ]selectionInterval: arg1  ^((self browser paneNamed: #code) port: #selectionInterval) value: arg1addItem: arg1  self context streamed add: arg1.  self context addItem: arg1newGoButtonFor: arg1  ^self newActionButton     hintTitle: 'Go';     hintText: 'open new pane to the right';     icon: self themer bindingThemer goIcon;     action: [:arg2 |  self remove.        self announce: #go event: arg1 ]defaultItems  ^self defaultItemsClass newannouncer  ^announcer ifNil: [ announcer := Announcer new ]tempIndex  ^tempIndexcontextToSelectFrom: arg1  ^arg1 assertionCallerContext ifNil: [ arg1 testContext ]previous  ^previouslabelBrick  ^labelBrickdefaultPagesLimit  ^100id  ^#gTProfileSelectionDebugActiontestAddThreeCandidateA1  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := candidates addProcessor: GTSpotterA1.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp2 := candidates addCandidate: 12 in: GTSpotterA1.  tmp3 := candidates addCandidate: 13 in: GTSpotterA1.  self assert: tmp1 nextLink equals: tmp2.  self assert: tmp1 previousLink equals: tmp3.  self assert: tmp2 nextLink equals: tmp3.  self assert: tmp2 previousLink equals: tmp1.  self assert: tmp3 nextLink equals: tmp1.  self assert: tmp3 previousLink equals: tmp2.  self assert: candidates head equals: tmp1.  self assert: candidates tail equals: tmp3.  self assert: tmp4 headLink equals: tmp1.  self assert: tmp4 tailLink equals: tmp3handleListenEvent: arg1  arg1 type = #mouseDown ifTrue: [ ((self fullBoundsInWorld containsPoint: arg1 position) not and: [ self autoHide ]) ifTrue: [ self spotterModel ifNotNil: [:arg2 |  arg2 exitDueTo: #mouseDown ] ] ].  arg1 type = #keyDown ifTrue: [ self spotterModel ifNotNil: [:arg3 |  arg3 shiftPressed: InputEventSensor default anyModifierKeyPressed not & InputEventSensor default shiftPressed ] ]mouseDown: arg1  | tmp1 |  self isEnabled ifFalse: [ ^self ].  tmp1 := Array with: #singleClick: with: #doubleClick: with: nil with: nil.  arg1 hand waitForClicksOrDrag: self event: arg1 selectors: tmp1 threshold: 10notifyShowPreview  self announce: GTSpotterShowPreview newdoFilterInContext: arg1  self subclassResponsibilitybasicVariableNodesFor: arg1 in: arg2  arg2 addAll: ((arg1 class allInstVarNames collectWithIndex: [:arg3 :arg4 |  GTInspectorProtoObjectNode hostObject: arg1 index: arg4 slotName: arg3 ]) sort: [:arg5 :arg6 |  arg5 label < arg6 label ])methodHierarchy  self systemNavigation methodHierarchyBrowserForClass: self currentClassOrMetaClass selector: self currentMessageNamecontextToSelectFrom: arg1  ^arg1 interruptedContextasSpotterProcessorLink  ^selftestFailingAssestionThroughAHelperMethod  self intermediaryCheckWithFailurecanContinue  ^self step event == #diveIn or: [ self step event isNil ]actionbarBrick  ^actionbarBrickcodePresentation  ^self inspectorPresentation firstPresentationcandidates  ^candidates ifNil: [ candidates := GTSpotterCandidatesList new.        candidates announcer when: GTSpotterCandidateAdded send: #onCandidateAdded to: self.        candidates announcer when: GTSpotterAllCandidatesAdded send: #onCandidateAdded to: self.        candidates announcer when: GTSpotterAllCandidatesRemoved do: [ self deselect ].        candidates ]cacheAt: arg1  ^self cacheAt: arg1 ifAbsent: [ nil ]allItems  | tmp1 |  tmp1 := self processor allItemsIn: self context.  ^self context isContinuing ifTrue: [ tmp1 value fasterDifferencePreservingOrder: self context streamed ] ifFalse: [ tmp1 ]pages: arg1  pages := arg1select: arg1 thenDo: arg2  self do: [:arg3 |  (arg1 value: arg3) ifTrue: [ arg2 value: arg3 ] ]checkWithFailure  self assert: false description: 'A failure'interruptedContext  ^self session interruptedContextcategoryNameMarginLeft  ^self itemIconMaxWidthbrowser  ^self firstsettingsLabelTextColor  ^Color whiteaddProcessor: arg1  self processors add: arg1itemActionbarStyleFor: arg1  arg1     useHorizontalLinearLayout;     hShrinkWrap;     vSpaceFill;     marginRight: self outerBorderWidth + 2;     visible: falseprocessorsFilter  ^self spotter processorsFilterdefaultOrder  ^1codePresentationIn: arg1  ^arg1 pharoScriptsettingsLabelPadding  ^4announcer  ^announcer ifNil: [ announcer := Announcer new ]select: arg1  self select: arg1 dueTo: #unknowntearDown  spotter := currentStep := currentProcessor := currentCandidate := nil.  super tearDownid  ^#gTDebugSelectionDebugActionlowerThreshold: arg1  lowerThreshold := arg1spotterPaneStyleFor: arg1  arg1     useHorizontalLinearLayout;     hSpaceFill;     vSpaceFillplaygroundActionPragma  ^#playgroundActionOrder:defaultUpperThreshold  ^0.45newNameBrick  ^GLMLabelBrick newspotterModel  ^spotterModelsearchField  ^searchFieldisStash  ^truesetUp  super setUp.  a := 42spotterModel  ^spotterModelapplyFilter  self hasQuery ifFalse: [ self applyFilterWithoutQuery.        ^self allItems ].  self applyFilterWithQuery.  ^self filteredItemscontinueItemsLimit  ^self defaultContinueItemsLimit - self itemsLimit max: 0previewPaddingRight  ^self previewPaddingLeftonStepPopped  self updatePreviewWith: self spotterModel steps last selected candidateusers: arg1 inPackages: arg2  | tmp1 |  tmp1 := OrderedCollection new.  RPackageOrganizer default packages do: [:arg3 |  arg2 do: [:arg4 |  arg3 packageName = arg4 ifTrue: [ arg3 methods do: [:arg5 |  ((arg5 refersToLiteral: arg1) and: [ (arg5 hasPragmaNamed: arg1) not ]) ifTrue: [ tmp1 add: arg5 ] ] ] ] ].  ^tmp1overridesDefaultSetUpMethod  ^self setUpMethod methodClass ~= TestCasesearch: arg1  search := arg1attachExtraBehaviourToPresentationsIn: arg1  arg1 presentations do: [:arg2 |  arg2 addAction: ((self closeActionFor: arg2) condition: [:arg3 |  self panes size > 1 and: [ self isPresentation: arg2 inPane: self panes last ] ]) ]fileName  ^self page title , '-' , self page creationTimeForFileName , '.' , GTPlayPage fileExtensionitemName: arg1  itemNameBlock := arg1content  ^contenthandleProcessorKeyBindings  self processorKeyBindingsDo: [ self spotterModel currentStep ifNotNil: [ self spotterModel currentStep processors do: [:arg1 |  arg1 keyBinding ifNotNil: [ | tmp1 |                          tmp1 := arg1 keyBinding asKeyCombination.                          processorKeyBindings at: tmp1 put: arg1.                          self kmDispatcher bindKeyCombination: tmp1 toAction: [ self onKeyProcessor: arg1 ] ] ] ] ]compose  self title: 'Raw'.  self tabulator with: [:arg1 |  arg1           row: #variables;           row: #evaluator.        arg1 transmit           to: #variables;           andShow: [:arg2 |  self variablesIn: arg2 ].        arg1 transmit           to: #evaluator;           andShow: [:arg2 |  self evaluatorIn: arg2 ].        arg1 transmit           from: #variables;           toOutsidePort: #selection;           transformed: [:arg3 |  arg3 ifNotNil: [ arg3 value ] ].        arg1 transmit           from: #evaluator;           toOutsidePort: #selection ].  self wantsAutomaticRefresh: truesourceIn: arg1  ^arg1 pharoMethod     smalltalkClass: [:arg2 |  arg2 parents first methodClass ];     display: [:arg2 |  arg2 source ]actionbarBrick: arg1  actionbarBrick ifNotNil: [ self removeBrick: actionbarBrick ].  actionbarBrick := arg1.  self addBrickBack: actionbarBricksession  ^(self browser pane port: #entity) valuedefaultFilteredItems  ^OrderedCollection new: 100newEmptyText  ^GLMLabelBrick new     text: 'No bindings';     hSpaceFill;     textPosition: #center;     padding: self themer bindingThemer emptyTextPadding;     textColor: self themer bindingThemer emptyTextColor;     fontSize: self themer bindingThemer emptyTextFontSize;     yourselfexecuteAction  HelpBrowser open selectTopicSatisfying: [:arg1 |  arg1 owner notNil and: [ arg1 owner key = self debugger class helpClass key and: [ arg1 title = 'Overview' ] ] ]hidePreview  self isPreviewVisible ifFalse: [ ^self ].  isPreviewVisible := false.  self class dontShowPreview.  self notifyHidePreviewsearchFieldTextColor  ^Color blackactOnPaneAdded: arg1  (self panes atLast: 2 ifAbsent: [ ^self ]) presentations first updateToolbarspotterContentsWidgetStyleFor: arg1  arg1     borderColor: self borderColor;     color: self borderColortestWithErrorInSetup  self assert: truetestBasic  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := [ 20 factorial ] asContext.  tmp2 := Process forContext: tmp1 priority: Processor userInterruptPriority.  tmp3 := GTGenericStackDebugger on: (tmp2 newDebugSessionNamed: 'test debugging' startedAt: tmp1).  self assert: tmp3 stackPresentation selection equals: tmp1.  tmp4 := '[ 20 factorial ] in GTGenericStackDebuggerTest>>testBasic'.  self assert: tmp3 selectedContext printString equals: tmp4.  tmp3 send.  tmp3 send.  tmp3 update.  self assert: tmp3 codePresentation entity sourceCode equals: (Integer >> #factorial) sourceCode.  self assert: tmp3 stackPresentation selection printString equals: 'SmallInteger(Integer)>>factorial'.  tmp2 terminatecurrentBindingsSorted  ^self currentBindings associations asSortedCollection: [:arg1 :arg2 |  arg1 key < arg2 key ]renderingProcessor  renderingProcessorLink ifNil: [ self renderingProcessor: processorLink ].  ^renderingProcessorLink valuelabelBrick  ^labelBrickreplaceSelectedSignaturesWith: arg1 in: arg2  selectedMethodSignatures := arg1.  arg2 updateprivacyAgreementIsSendingDataColor  ^Color paleGreencodePresentationSelector: arg1  codePresentationSelector := arg1initialize  super initialize.  objects := OrderedCollection newtitle  ^title ifNil: [ super title ]stepModel  ^stepModelonCandidateMoved  self moveTo: self selectedItemBrickprintStringOf: arg1  | tmp1 |  tmp1 := arg1 class name.  ^(String streamContents: [:arg2 |  arg2           nextPutAll: (tmp1 first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]);           nextPutAll: tmp1 ]) asCommentsetUpMethod  ^self testObject class lookupSelector: #setUpbasicRelevantProcessorsProcess: arg1  self basicRelevantProcessorsProcess: arg1 do: [:arg2 |  arg2 filterInContext: arg1 ].  arg1 continueFilterrawValue  ^self hostObjectprintStackExtraColumnForContext: arg1  | tmp1 |  ^arg1 outerContext ifNil: [ String streamContents: [:arg2 |  tmp1 := arg1 selector ifNil: [ arg1 method defaultSelector ].              tmp1 = #doesNotUnderstand: ifTrue: [ arg2 space.                    (arg1 tempAt: 1) selector printOn: arg2 ] ifFalse: [ '' ] ] ] ifNotNil: [ arg1 closure printString ]closeButtonWidgetStyleFor: arg1  arg1     normalImage: GLMUIThemeExtraIcons glamorousClose;     pressedColor: self buttonPressedColoreventType: arg1  eventType := arg1scrollToPane: arg1 callback: arg2  self flag: 'this method gets called directly from the gt-spotter model - hmmmmm'.  arg2 valuenewContentsBrick  ^GTSpotterContentsBrick newprivateAddCandidate: arg1 weightedInNotFull: arg2  | tmp1 tmp2 |  tmp1 := arg2 headLink.  tmp2 := arg2 tailLink.  arg1 weight > tmp1 weight ifTrue: [ tmp1 := self candidates add: arg1 beforeLink: tmp1 ] ifFalse: [ arg1 weight > tmp2 weight ifFalse: [ tmp2 := self candidates add: arg1 afterLink: tmp2 ] ifTrue: [  ] ]spotterPreviewStyleFor: arg1  arg1     borderWidth: self previewBorderWidth;     hSpaceFill: self previewWidthPercent;     vSpaceFill;     margin: {(self headerHeight + self innerBorderWidth) .         0 .         0};     marginLeft: (self previewBorderWidth + self previewArrowWidth) negated.  arg1 layout zIndex: 1executeAction  self session runToBytecode: self debugger bytecodePresentation selection inContext: self currentContextonHideHints  self visible ifFalse: [ ^self ].  self themer spotterThemer hintHideStyleFor: self diveInButton.  self themer spotterThemer hintHideStyleFor: self actOnButtoncategoryTitleNameStyleFor: arg1  arg1     vSpaceFill;     textPosition: #leftCenter;     width: [:arg2 |  arg1 owner innerBounds width min: arg2 label textSize x + arg2 label hMargin ].  arg1 label familyName: self titleFamilyNameopenExplorerFor: arg1  self openOn: arg1computeAllItemsIn: arg1  ^allCandidatesBlock cull: arg1isVisible: arg1 in: arg2  ^arg2 intersects: arg1 globalOuterBoundsisAbove: arg1 in: arg2  ^arg1 globalOuterBounds origin <= arg2 originshouldDisplayPresentationCreatedBy: arg1  ^self presentationFilter shouldDisplayPresentationCreatedBy: arg1shouldRaise: arg1 process: arg2 origin: arg3 do: arg4  self shouldRaise: arg1 process: arg2 origin: arg3 during: GTSpotterDebuggingExceptionHandlerMock new do: arg4onHovered  self titleBrick showActionbarselectNextCategory  self spotterModel hasSelected ifTrue: [ self spotterModel currentStep selectNextCategory ]openListChooseLabeled: arg1 forInspector: arg2 with: arg3 select: arg4 format: arg5 actionSelector: arg6  | tmp1 |  tmp1 := MorphTreeModel new.  tmp1     beCheckList;     rootItems: arg3;     wrapBlockOrSelector: arg5;     autoMultiSelection: true.  (tmp1 openDialogWindowIn: self currentWorld title: arg1 selectedtems: arg4) ifNotNil: [:arg7 |  self perform: arg6 with: arg7 with: arg2 ]candidateLink  ^candidateLinkonScrolled  self stepModel spotter announce: GTSpotterCandidateSelectedMoved neweventType  ^eventTypecacheAt: arg1 put: arg2  ^self cache at: arg1 put: arg2id  ^#gtRunToSelectionunsubscribeListeners  self activeHand removeEventListener: self.  Morph announcer unsubscribe: selftestMultiValuedStreaming  | tmp1 tmp2 |  tmp1 := ZnHeaders new.  tmp1 at: 'Set-Cookie' put: 'foo=1'.  tmp1 at: 'Set-Cookie' add: 'bar=1'.  tmp1 at: 'Content-TYPE' put: 'text/plain'.  tmp1 at: 'Content-Length' put: '128'.  tmp2 := OrderedCollection streamContents: [:arg1 |  tmp1 headersDo: [:arg2 :arg3 |  arg1                 nextPut: arg2;                 nextPut: arg3 ] ].  self assert: tmp2 equals: #('Set-Cookie' 'foo=1' 'Set-Cookie' 'bar=1' 'Content-Length' '128' 'Content-TYPE' 'text/plain') asOrderedCollectionallowedBounds  ^allowedBoundsonHideHints  self themer spotterThemer hintHideStyleFor: self settingsButton.  self themer spotterThemer hintHideStyleFor: self closeButton.  self themer spotterThemer hintHideStyleFor: self helpButtonnewPageLabel  ^GLMLabelBrick new     hSpaceFill;     vShrinkWrap;     textPosition: #leftCenter;     vAlign: #center;     padding: {0 .         self themer bindingThemer padding}previewArrowWidth  ^self itemHeight / 2 + self previewArrowGapHacksetDebuggerToFirstNonFilteredContext  | tmp1 |  tmp1 := self stackPresentation selection.  (tmp1 isNil or: [ tmp1 method hasPragmaNamed: #debuggerCompleteToSender ]) ifTrue: [ self filteredStack ifNotEmpty: [:arg1 |  self stackPresentation selection: arg1 first ] ]codeIn: arg1  ^(self codePresentationIn: arg1)     title: [:arg2 |  GTPlaygroundEditableTabLabel new           text: arg2 title;           when: #accepted do: [:arg3 |  arg2 setTitleAndEnsureInStash: arg3 asString ];           yourself ];     format: [:arg2 |  arg2 content ];     act: [:arg3 :arg2 |  arg3 selectionInterval: (1 to: arg3 text size).        arg3 highlightEvaluateAndDo: [:arg4 |  arg3 selection: arg4 ] ] icon: GLMUIThemeExtraIcons glamorousGo on: $G entitled: 'Do it all and go';     act: [:arg3 :arg2 |  arg2 publish ] iconName: #glamorousSaveToUrl entitled: 'Remote publish';     addAction: (GLMPopupAction new           action: [:arg3 :arg2 :arg5 |  GTPlaygroundBindingsList new                 on: self currentBindingsSorted;                 when: #bindingRemoved do: [:arg6 |  self removeBinding: arg6 ];                 when: #inspect do: [:arg6 |  arg6 value inspect ];                 when: #go do: [:arg6 |  arg3 selection: arg6 value ];                 yourself ];           iconName: #glamorousTable;           title: 'Bindings';           yourself);     addAction: (GLMPopupAction new           action: [:arg3 :arg2 :arg5 |  GTPlaygroundPlayPagesList new                 on: GTPlayBook instance;                 when: #pageAccepted do: [:arg7 |  arg3 entity saveContent: arg7 content.                    arg3 update ];                 yourself ];           iconName: #glamorousMore;           title: 'Play pages';           yourself);     with: [:arg8 |  self pageActionsIn: arg8 ];     dynamicActionsOnSelection: [ self contextMenuActions ];     onChangeOfPort: #text act: [:arg3 :arg2 |  arg2 saveContent: arg3 text.        arg3 clearUserEdits ]query  ^querytestAssertionEqualsDetected  self assertDebuggerInitializationForContext: [ GTSUnitExampleFailingTest new testArrays ] asContext andStepBlock: self stepBlockForTestArrays.  self assert: session testContext method equals: GTSUnitExampleFailingTest >> #testArrays.  self assert: session assertionContext method selector equals: #assert:equals:.  self assert: session assertionCallerContext equals: session testContext.  self assert: session supportsDiff description: 'When #assert:equals: is encountered a diff can be used'.  self assertDebuggerClosingdefaultLabel  ^''deselect  self invalidateWith: [ self labelBrick label           customFont;           beRegular ]timestamp: arg1  timestamp := arg1defaultTask  ^GTMockSpotterTask newelement: arg1  element := arg1addSeparator  | tmp1 |  tmp1 := self newSeparator.  self themer spotterThemer breadcrumbSeparatorStyleFor: tmp1.  self themer spotterThemer breadcrumbSeparatorWidgetStyleFor: tmp1.  self band addBrickBack: tmp1defaultLabel  ^'Accept'hasDynamicItems  ^trueisMatchedItem: arg1  | tmp1 |  tmp1 := self itemFilterNameFor: arg1.  ^query allSatisfy: [:arg2 |  tmp1 includesSubstring: arg2 caseSensitive: self caseSensitive ]initialize  super initialize.  self needsUpdate: falseiconFor: arg1  ^[ arg1 gtInspectorIcon ifNil: [ arg1 class systemIcon ] ] on: Error do: [:arg2 |  self iconFor: arg1 error: arg2 ]headerHeight  ^56element: arg1  element := arg1spotterImplementorsFor: arg1  < spotterOrder: 30>  self flag: #specialFilter.  arg1 listProcessor     title: 'Implementors';     filter: GTFilterImplementor item: [:arg2 :arg3 |  SystemNavigation default allBehaviorsDo: [:arg4 |  arg4 methodsDo: arg2 ] ];     keyBinding: $m meta;     wantsToDisplayOnEmptyQuery: falsevariableTag  ^self hostObject variableTagshouldEnableProcessorsCreateBy: arg1  ^selectedMethodSignatures anySatisfy: [:arg2 |  arg2 first = arg1 methodClass and: [ arg2 second = arg1 selector ] ]inspectorPresentation  ^self presentations firstdefaultOrder  ^20help  ^'Cancel editor changes.'testNewSpotter  | tmp1 |  self assert: spotter notNil.  self assert: spotter hasSteps not.  self assertEmpty: spotter steps.  self deny: spotter hasMultipleSteps.  self shouldnt: [ tmp1 := spotter currentStep ] raise: Error.  self flag: '#currentStep is not always cached in spotter - especially when it is a new/empty spotter. In that case #currentStep will always return a new instance of a step. The implementation would be more polymorphic, oo-style, simpler and with much less ifTrue/ifFalse if the initial-state were regarded as a step as well (as an inst-var not in the inst-var-list of #steps). Maybe use a separate type to distinguish? GTSpotterInitialStep ... '.  self assert: tmp1 notNil.  self assert: spotter hasSteps not.  self assertEmpty: spotter stepspagesLimit  ^pagesLimit ifNil: [ self defaultPagesLimit ]hideActionsOf: arg1  arg1 subbricks select: [:arg2 |  arg2 isKindOf: GLMHintableActionButtonBrick ] thenDo: [:arg2 |  arg2 visible: false ]pragmas  ^pragmas ifNil: [ pragmas := OrderedCollection new.        SystemNavigation new allBehaviorsDo: [:arg1 |  Pragma withPragmasIn: arg1 do: [:arg2 |  arg2 selector = self selector ifTrue: [ pragmas add: arg2 ] ] ].        pragmas ]shrinkBottom: arg1 with: arg2  ^arg1 bottom: arg1 bottom - arg2 globalOuterBounds heightcategory: arg1  self assert: arg1 isNotNil.  category := arg1executeAction  self debugger codePresentation hasUnacceptedEdits ifTrue: [ self debugger codePresentation clearUserEdits.        self debugger updateCodeEditor ]backgroundColor  ^Color whiteitems  ^items ifNil: [ items := OrderedCollection new ]shortcutBrick: arg1  shortcutBrick ifNotNil: [ self removeBrick: shortcutBrick ].  shortcutBrick := arg1.  self themer spotterThemer categoryTitleShortcutStyleFor: shortcutBrick.  self addBrickBack: shortcutBrickcandidate  ^self candidateLink valueassertDiveOut  | tmp1 |  tmp1 := spotter steps size.  previousStep := spotter currentStep.  self shouldnt: [ spotter popStep ] raise: Error.  currentStep := spotter currentStep.  currentProcessor := currentCandidate := previousContext := currentContext := nil.  self assert: spotter steps size < tmp1.  self assert: spotter steps size equals: tmp1 - 1.  self deny: (tmp1 > 1 and: [ previousStep = currentStep ]).  self deny: (tmp1 > 1 and: [ previousStep = spotter currentStep ]).  self assert: currentStep equals: spotter currentStepcompose  self title: [:arg1 |  'Inspector on ' , (self printObjectAsAnItem: arg1) ].  self titleIcon: (self iconNamed: #smallInspectIt).  self act: [:arg2 |  arg2 update ] icon: GLMUIThemeExtraIcons glamorousRefresh entitled: 'Update'.  self act: [:arg2 |  HelpBrowser open selectTopicSatisfying: [:arg3 |  arg3 owner notNil and: [ arg3 owner key = GTInspectorHelp key and: [ arg3 title = 'Overview' ] ] ] ] icon: GLMUIThemeExtraIcons glamorousHelp entitled: 'Help'.  self act: [:arg2 |  arg2 presentationFilter changeFilterRequestFor: arg2 ] entitled: 'Filter presentations'.  self pager with: [:arg4 |  arg4 fixedSizePanes: self class numberOfInspectorPanes.        arg4 show: [:arg5 :arg3 |  arg5 title: [ self printObjectAsAnItem: arg3 ].              arg5 dynamicActions: [:arg6 |  arg3 gtInspectorActions asOrderedCollection ].              arg5 titleAction: [:arg6 |  self closeActionFor: arg6 ].              arg5 dynamic display: [:arg7 |  (GLMCompositePresentation new with: [:arg8 |  arg3 gtInspectorPresentationsIn: arg8 inContext: self ]) startOn: arg7 ] ] ].  self browser when: GLMPaneAdded send: #actOnPaneAdded: to: self.  self browser when: GLMPaneRemoved send: #actOnPaneRemoved: to: self.  self class isStepRefreshEnabled ifTrue: [ self wantsAutomaticRefresh: true.        self wantsSteps: true.        self stepTime: self class stepRefreshRate ]newAcceptButtonFor: arg1  ^self newActionButton     hintTitle: 'Accept';     hintText: 'load saved page into playground';     icon: (self iconNamed: #glamorousAccept);     action: [:arg2 |  self remove.        self announce: #pageAccepted event: arg1 ]closeButton: arg1  closeButton ifNotNil: [ self removeBrick: closeButton ].  closeButton := arg1.  self themer spotterThemer closeButtonWidgetStyleFor: closeButton.  self themer spotterThemer closeButtonStyleFor: closeButton.  closeButton     hintTitle: 'Close Spotter';     hintText: '<escape>';     action: [ self spotterModel exitDueTo: #actionButton ].  self addBrickBack: closeButtoninitialize  super initialize.  self compositeBrick: self newCompositeBrickdefaultCaseSensitive  ^falseerrorMessage  ^'error obtaining attribute value'layoutAllowedBottom: arg1  self     translate: arg1 by: (self deltaBottom: arg1) negated;     increaseZindex: arg1;     cutAllowedBoundsBottom: arg1requestNextStepWith: arg1 for: arg2  text := ''.  self pushStep: (self newStep           origin: arg1;           event: arg2;           yourself).  self steps last process: niltriangleBrick: arg1  triangleBrick := arg1.  self themer spotterThemer breadcrumbItemTriangleStyleFor: self triangleBrick.  self addBrickBack: self triangleBricknewLabelBrick  self flag: 'find a better number, or at least a better place for the number :)'.  ^GLMLabelBrick new     text: 'Search result with very very long name';     paddingRight: 16users: arg1  ^self users: arg1 inPackages: self defaultPackagesvariablesIn: arg1  ^arg1 fastTreeTable     useCache;     hasChildren: [:arg2 |  arg2 key ~= 'self' ];     children: [:arg2 |  arg2 childrenNodesFor: self ];     icon: [:arg2 |  self iconFor: arg2 value ];     display: [:arg3 |  self variableNodesFor: arg3 ];     column: 'Variable' translated evaluated: [:arg2 |  GTObjectPrinter asNonTruncatedTextFrom: arg2 label ];     column: 'Value' translated evaluated: [:arg2 |  | tmp1 tmp2 |        [ tmp1 := arg2 rawValue ] on: Error do: [ tmp2 := Text string: arg2 errorMessage attribute: TextColor red ].        tmp2 ifNil: [ GTObjectPrinter asTruncatedTextFrom: tmp1 ] ] modified: [:arg4 :arg5 :arg6 |  self updateVariableNode: arg5 basedOn: arg4.        arg6 requestRefresh ];     morphicSelectionAct: [:arg7 |  arg7 selection value browse ] icon: GLMUIThemeExtraIcons glamorousBrowse on: $b entitled: 'Browse' translated;     morphicSelectionAct: [:arg7 |  arg7 selection value inspect ] icon: GLMUIThemeExtraIcons glamorousInspect on: $i entitled: 'Inspect' translated;     dynamicActionsOnSelection: [:arg8 |  (arg8 rawSelection isKindOf: GTInspectorVariableNode) ifTrue: [ arg8 rawSelection inspectorActionsForNode ] ifFalse: [ #() ] ];     selectionAct: [:arg7 |  ((arg7 selection value pointersToExcept: {arg7 selection value}) reject: [:arg9 |  arg9 pointsOnlyWeaklyTo: arg7 selection value ]) inspect ] on: $t entitled: 'Open pointers to' translatedselect: arg1 thenCollect: arg2  ^self select: arg1 thenCollect: arg2 as: self defaultItemsClassdebugger  ^self owner debuggerannounce: arg1  self announcer announce: arg1breadcrumbSeparatorWidth  ^(self breadcrumbHeight + self outerBorderWidth) / 2 + 4selectedCategory  < return: #GTSpotterProcessor>  ^self selected processoroutOfWorld: arg1  super outOfWorld: arg1.  self unsubscribeListeners.  self spotterModel ifNotNil: [:arg2 |  arg2 terminateProcessors ].  focusedMorph ifNotNil: [ focusedMorph takeKeyboardFocus ]matchString  self filter: GTFilterStringMatchwriteToFileSystem  | tmp1 |  tmp1 := self fileReferenceOrNil.  (tmp1 notNil and: [ tmp1 fileSystem isWritable ]) ifTrue: [ tmp1 writeStreamDo: [:arg1 |  arg1                 truncate;                 nextPutAll: self page contentString ] ]save: arg1  self hostObject writeSlot: self slot value: arg1setShortcutBrickTextFor: arg1  self shortcutBrick text: (ToggleMenuItemShortcut owner: nil keyText: (arg1 keyBinding printString copyReplaceAll: 'Meta' with: OSPlatform current defaultModifier name)) texttitle: arg1  title := arg1save  self page content isEmpty ifTrue: [ self deleteFromFileSystem ] ifFalse: [ self writeToFileSystem ]defaultOrder  ^10handlesMouseDown: arg1  ^trueaddPageIfInteresting: arg1  arg1 isInteresting ifFalse: [ ^self ].  self addPage: arg1presenterAt: arg1 put: arg2  ^self basicPresenters at: arg1 put: arg2padding  ^5gtDisplayOn: arg1  arg1     nextPutAll: 'Processor link: ';     nextPutAll: self processor title asStringactLogic: arg1  actBlock := arg1showTriangle  isTriangleVisible := true.  self themer spotterThemer breadcrumbItemTriangleWidgetStyleFor: self triangleBricknewAmountBrick  ^GLMLabelBrick newmatchContext: arg1  ^arg1 method isTestMethodactionsForPragmas: arg1  self session interruptedContext ifNil: [ ^#() ].  ^(self allActionsForPragmas: arg1) collect: [:arg2 |  arg2 asGlamourAction ]contextEvaluatorIn: arg1  arg1 pharoScript     doItReceiver: [ self debugger selectedContext receiver ];     doItContext: [ self debugger selectedContext ];     smalltalkClass: [ self debugger selectedContext receiver class ];     variableBindings: [ self debugger selectedContext gtDebuggerDoItBindings ];     display: [ String streamContents: [:arg2 |  arg2 nextPutAll: (GTSnippets snippetAt: self debugger selectedContext receiver class) ] ];     onChangeOfPort: #text act: [:arg3 |  GTSnippets snippetAt: self debugger selectedContext receiver class put: arg3 text asString.        arg3 clearUserEdits ];     installDefaultSelectionActionsrunCaseManaged  self runCasetestAddTwoCandidateA1A2A3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  tmp7 := candidates addProcessor: GTSpotterA1.  tmp8 := candidates addProcessor: GTSpotterA2.  tmp9 := candidates addProcessor: GTSpotterA3.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp2 := candidates addCandidate: 12 in: GTSpotterA1.  tmp3 := candidates addCandidate: 21 in: GTSpotterA2.  tmp4 := candidates addCandidate: 22 in: GTSpotterA2.  tmp5 := candidates addCandidate: 31 in: GTSpotterA3.  tmp6 := candidates addCandidate: 32 in: GTSpotterA3.  self assert: tmp1 nextLink equals: tmp2.  self assert: tmp1 previousLink equals: tmp6.  self assert: tmp2 nextLink equals: tmp3.  self assert: tmp2 previousLink equals: tmp1.  self assert: tmp3 nextLink equals: tmp4.  self assert: tmp3 previousLink equals: tmp2.  self assert: tmp4 nextLink equals: tmp5.  self assert: tmp4 previousLink equals: tmp3.  self assert: tmp5 nextLink equals: tmp6.  self assert: tmp5 previousLink equals: tmp4.  self assert: tmp6 nextLink equals: tmp1.  self assert: tmp6 previousLink equals: tmp5.  self assert: candidates head equals: tmp1.  self assert: candidates tail equals: tmp6.  self assert: tmp7 headLink equals: tmp1.  self assert: tmp7 tailLink equals: tmp2.  self assert: tmp8 headLink equals: tmp3.  self assert: tmp8 tailLink equals: tmp4.  self assert: tmp9 headLink equals: tmp5.  self assert: tmp9 tailLink equals: tmp6onLayoutEvent: arg1  super onLayoutEvent: arg1.  (arg1 isKindOf: GLMBrickLayoutStacked) ifTrue: [  ]childrenNodesFor: arg1  < return: #Collection of: #GTInspectorVariableNode>  ^arg1 childrenVariableNodesForNode: selfnotifyHideHints  self announce: GTSpotterHideHints newmatchSubstring  self filter: GTFilterSubstringisVisible: arg1  ^self allowedBounds containsRect: arg1 globalOuterBoundsnewBindingLabel  ^GLMLabelBrick new     hSpaceFill: 50;     vShrinkWrap;     textPosition: #leftCenter;     vAlign: #center;     padding: {0 .         self themer bindingThemer padding}id  ^#gTOpenSelectionDebugActiontearDownMethod  ^self testObject class lookupSelector: #tearDownaddAndSelectAllTags  self allTags do: [:arg1 |  self addAndSelectTag: arg1 ]defaultAction  ^self class defaultValueexceptionHandler  self flag: 'Bloc -> overrides doesNotUnderstand discarding the current exception context'.  ^GTCurrentSpotterExceptionHandler value ifNil: [ GTSpotterExceptionHandlerNotFound signal ]currentStep  ^currentStep ifNil: [ self hasSteps ifTrue: [ currentStep := self steps last ] ifFalse: [ self newStep origin: self foundationOrigin ] ]event  ^eventtestHistorizingTheSameObjectRemovesPreviousOccurences  | tmp1 |  tmp1 := OrderedCollection new.  spotter := GTSpotter new history: tmp1.  spotter historize: (GTSpotterCandidateLink new value: 42).  self assert: tmp1 size equals: 1.  spotter historize: (GTSpotterCandidateLink new value: 43).  self assert: tmp1 size equals: 2.  self assert: tmp1 first value equals: 43.  self assert: tmp1 last value equals: 42.  spotter historize: (GTSpotterCandidateLink new value: 42).  self assert: tmp1 size equals: 2.  self assert: tmp1 first value equals: 42.  self assert: tmp1 last value equals: 43help  ^'Inspect the currently selected bytecode.'showTriangle  isTriangleVisible := true.  self themer spotterThemer spotterPreviewArrowWidgetStyleFor: self triangleBrick.  self changedbreadcrumbItemTextColor  ^Color whitedecompiledCodeWidgetIn: arg1 forContext: arg2  ^arg1 pharoMethod     title: 'Decompiled';     format: [ arg2 method codeForNoSource ];     smalltalkClass: [ arg2 methodClass ];     doItReceiver: [ arg2 receiver ];     doItContext: [ arg2 ]actOnPaneAdded: arg1  (self panes atLast: 2 ifAbsent: [ ^self ]) updateToolbarsupportsDiff  ^assertionContext ifNil: [ false ] ifNotNil: [ assertionContext selector = #assert:equals: ]acceptAction: arg1  label  ^self tempIndexwaitingText  ^'...'generateHashFor: arg1  ^(self basicVariableNodesFor: arg1) inject: arg1 gtInspectorHash into: [:arg2 :arg3 |  arg2 bitXor: arg3 value gtInspectorHash ]amountBrick: arg1  amountBrick ifNotNil: [ self removeBrick: amountBrick ].  amountBrick := arg1.  self themer spotterThemer categoryAmountStyleFor: amountBrick.  self addBrickBack: amountBrickitemNameFor: arg1  ^arg1 gtDisplayStringdefaultPadding  ^5settingsButtonWidgetStyleFor: arg1  arg1     normalImage: (Smalltalk ui icons iconNamed: #glamorousPreferences);     pressedColor: self buttonPressedColorpresenters  ^self basicPresenters valuesplaygroundIcon  ^self iconNamed: #workspacecandidate  ^candidateLink valuetempName  ^tempNameaddCandidate: arg1 in: arg2  | tmp1 tmp2 |  tmp1 := self getProcessorLink: arg2.  tmp2 := arg1 asSpotterCandidateLink processorLink: tmp1.  tmp2 := tmp1 isEmpty ifTrue: [ self privateAddCandidate: tmp2 inEmpty: tmp1 ] ifFalse: [ self privateAddCandidate: tmp2 inNotEmpty: tmp1 ].  self updateCycleConnectionFor: tmp2.  self notifyCandidateAdded: tmp2 in: arg2.  ^tmp2tearDownCodeIn: arg1  arg1 pharoMethod     title: [ self tearDownPresentationTitle ];     format: [ self session tearDownMethod sourceCode ];     smalltalkClass: [ self session testObject class ];     when: [ self session overridesDefaultTearDownMethod ];     doItReceiver: [ self session testObject ]id  ^GTStepToBytecodeDebugAction nameapplyFilterInContext: arg1  self prepareFilterInContext: arg1.  ^self applyFilterfileDirectory  ^GTPlayBook cacheDirectoryhelp  ^'Step to a selected bytecode.'snippetAtOrEmpty: arg1  ^self snippets at: arg1 ifAbsent: [ '' ]save: arg1  self hostObject at: self index put: arg1sort: arg1  sortBlock := arg1defaultLabel  ^'Cancel'last: arg1  ^self items last: (self size min: (arg1 max: 0))keyBinding: arg1  keyBinding := arg1amount  ^amountcurrentBindings  ^self codePresentation currentBindingshandleFatalException: arg1  ('[Spotter] Fatal Exception: ' , arg1 asString) traceCrtestDeploymentHandleException  self assertResetExceptions.  self shouldnt: [ [ 1 / 0 ] on: ZeroDivide do: [:arg1 |  self assert: (GTSpotterDeploymentExceptionHandlerMock new handleException: arg1) notNil ] ] raise: ZeroDivide.  self assertException: ZeroDividekeyword: arg1  keyword := arg1defaultPackages  ^{'GT-Spotter' .   'GT-SpotterExtensions-Core'}cache: arg1  cache := arg1spotterForMessagesFor: arg1  < spotterOrder: 35>  arg1 listProcessor     title: 'Messages';     filter: GTNullFilter item: [:arg2 :arg3 |  GTSelector substring: arg3 textTrimmed filter: arg2 ];     actLogic: [:arg4 :arg5 |  arg5 exit.        self systemNavigation browseAllImplementorsOf: arg4 name ];     wantsToDisplayOnEmptyQuery: falsedefaultKeymap  ^PharoShortcuts current acceptShortcutfileReferencesBy: arg1 inContext: arg2 usingFilter: arg3  | tmp1 tmp2 tmp3 |  tmp1 := arg2 textLowercase piecesCutWhere: [:arg4 :arg5 |  arg4 = FileSystem disk delimiter ].  tmp1 size < 1 ifTrue: [ tmp3 := arg2 textLowercase.        tmp2 := FileSystem workingDirectory ] ifFalse: [ tmp1 last last = FileSystem disk delimiter ifTrue: [ tmp3 := ''.              tmp2 := arg2 textLowercase asFileReference ] ifFalse: [ tmp3 := tmp1 last.              tmp2 := ('' join: tmp1 allButLast) asFileReference ] ].  tmp2 exists ifFalse: [ ^self ].  self flag: 'this is an ugly hack for #queryForFileReference. This iterator has to manipulate the query in order for the filter to work properly'.  arg2 cacheAt: #queryForFileReference put: tmp3.  (tmp2 perform: arg1) do: arg3assertCandidateMatching: arg1  | tmp1 |  self assert: currentProcessor notNil.  tmp1 := currentProcessor allFilteredCandidates select: [:arg2 |  arg1 value: arg2 ].  self denyEmpty: tmp1.  self assert: tmp1 size equals: 1.  currentCandidate := tmp1 anyOne.  self assert: currentCandidate notNil.  ^currentCandidatekey  ^self indexinitialize  super initialize.  self content: ''.  self creationTime: DateAndTime now.  persistenceStrategies := OrderedCollection with: (GTPlayPageCachePersistence new page: self)overridesDefaultTearDownMethod  ^self tearDownMethod methodClass ~= TestCaseonHidePreview  self triangleBrick renderer border: self themer spotterThemer outerBorderWidth.  self triangleBrick selectedColor: Color transparent.  self changedopenWithFullView  self setDebuggerToFirstNonFilteredContext.  self opencurrentClassOrMetaClass  ^self currentContext methodClassdebuggerClass: arg1  debuggerClass := arg1.  self label: debuggerClass defaultTitlecopy  | tmp1 |  tmp1 := self class value: self value.  tmp1 privateProcessorLink: processorLink.  tmp1 privateRenderingProcessorLink: renderingProcessorLink.  tmp1 weight: weight.  ^tmp1beDebugging  self exceptionHandler: GTSpotterDebuggingExceptionHandler newinitialize  super initialize.  self needsUpdate: falseassertText: arg1 do: arg2  | tmp1 |  self shouldnt: [ tmp1 := spotter setText: arg1 from: self ] raise: Error.  self assert: tmp1.  self deny: spotter hasSteps not.  self denyEmpty: spotter steps.  self shouldnt: [ arg2 value ] raise: ErroritemActionButtonStyleFor: arg1  arg1     width: [ (self itemHeight / 1.1) floor ];     vSpaceFill;     margin: #(0 1);     padding: {0 .         self outerBorderWidth}pop  self band layoutAfter: [ self band removeBrick: self items removeLast.        self items size = 1 ifTrue: [ self items first labelBrick paddingLeft: 0 ].        self items isEmpty ifFalse: [ self popSeparator ].        self items do: [:arg1 |  arg1 wrappedBounds markWidthDirty ] ].  self items size = 0 ifTrue: [ self notifyBreadcrumbVisibilityChanged ] ifFalse: [ self items last showTriangle.        self scrollToTheLastOne.        self changed ]amount: arg1  amount := arg1foundationOrigin: arg1  foundationOrigin := arg1isPreviewShown  ^self hasSubbrick: self previewBrickonRevealHints  self themer spotterThemer hintRevealArrowStyleFor: self triangleBrickremove  (self ownerThatIsA: GLMFoundationBrick) ifNotNil: [:arg1 |  arg1 delete ]separators: arg1  separators := arg1updatePreviewWith: arg1  | tmp1 |  self spotterModel isPreviewVisible ifFalse: [ ^self ].  tmp1 := previewObject isNil.  previewObject = arg1 ifTrue: [ ^self ].  previewObject := arg1.  previewObject ifNil: [ ^self updatePreviewWithEmpty ].  tmp1 ifTrue: [ self updatePreviewWithLoading ].  self asyncTask execute: [:arg2 :arg3 |  [ arg3 spotterPreviewIn: arg2 inContext: self spotterModel ] on: Error do: [:arg4 |  self spotterModel exceptionHandler handleException: arg4 do: [ self handleException: arg4 forComposite: arg2 ] ].        arg2 ] withArguments: {self newCompositeBrick .         arg1} callback: [:arg2 |  self compositeBrick: arg2.        self changed ] priority: Processor userBackgroundPriority delay: 50canDiveIn: arg1  | tmp1 tmp2 |  tmp2 := false.  tmp1 := self spotter newStep origin: self origin.  self spotter addStep: tmp1 during: [ arg1 spotterProcessorsFor: tmp1.        tmp2 := tmp1 processors notEmpty ].  ^tmp2spotterImplementorsFor: arg1  < spotterOrder: 40>  ^arg1 listProcessor     title: 'Implementors';     filter: GTFilterSubstring item: [:arg2 :arg3 |  self implementors do: arg2 ];     keyBinding: $m metavariableTag  ^'attribute'initialize  super initialize.  self showScrollBarWhenNeeded: falsereject: arg1 thenCollect: arg2 as: arg3  | tmp1 |  tmp1 := self newAs: arg3.  self reject: arg1 thenDo: [:arg4 |  tmp1 add: (arg2 value: arg4) ].  ^tmp1addMethod: arg1  methods ifNil: [ methods := OrderedCollection new ].  methods add: arg1compose  self title: self defaultPlaygroundTitle.  self titleIcon: self playgroundIcon.  self act: [:arg1 |  arg1 update ] icon: GLMUIThemeExtraIcons glamorousRefresh entitled: 'Update'.  self act: [:arg1 |  HelpBrowser open selectTopicSatisfying: [:arg2 |  arg2 owner notNil and: [ arg2 owner key = GTPlaygroundHelp key and: [ arg2 title = 'Overview' ] ] ] ] icon: GLMUIThemeExtraIcons glamorousHelp entitled: 'Help'.  self act: [:arg1 |  SettingBrowser new           changePackageSet: {(RPackageOrganizer default packageNamed: 'GT-Playground')};           open;           expandAll ] icon: (Smalltalk ui icons iconNamed: #smallCogInitialState) entitled: 'Global Setting'.  self     custom: (GTInspector new           noTitle;           noActions;           wantsAutomaticRefresh: true;           showFirst: [:arg3 |  self codeIn: arg3 ];           yourself);     when: GLMBrowserClosing do: [:arg4 |  self actOnBrowserClosing: arg4 ].  GTInspector isStepRefreshEnabled ifTrue: [ self wantsAutomaticRefresh: true.        self wantsSteps: true.        self stepTime: GTInspector stepRefreshRate ].  self playgroundActionsIn: selftestSuccessfullTestWithHalt  self assertDebuggerInitializationForContext: [ GTSUnitExampleFailingTest new testWithHalt ] asContext andStepBlock: self stepBlockForTestWithHalt.  self assert: session testContext method equals: GTSUnitExampleFailingTest >> #testWithHalt.  self assert: session assertionContext equals: nil.  self assert: session assertionCallerContext equals: nil.  self deny: session supportsDiff description: 'When there is no assertion no diff is supported'.  self assertDebuggerClosingnotifySearchFinishedFor: arg1 processors: arg2  self announce: (GTSpotterSearchFinished new           query: arg1;           processors: arg2;           yourself)updatePreviewWithLoading  self compositeBrick: (GLMLabelBrick new           text: 'Loading...';           textPosition: #center;           textColor: Color lightGray;           with: [:arg1 |  arg1 label                 customFont;                 fontSize: 14 ])onKeyProcessor: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  arg1 title isEmptyOrNil ifTrue: [ ^self ].  tmp1 := [ paneBrick contentsBrick headerBrick searchField ] on: Error do: [ ^self ].  tmp5 := tmp1 text asString.  tmp6 := tmp1 rubric selectionInterval.  tmp7 := 0.  tmp3 := '#' , (arg1 title copyUpTo: Character space).  tmp9 := 0.  (tmp5 includesSubstring: tmp3 caseSensitive: false) ifTrue: [ tmp9 := -1.        tmp3 := '' ].  (tmp5 includesSubstring: '#' caseSensitive: false) ifTrue: [ | tmp10 tmp11 tmp12 |        tmp10 := tmp5 indexOf: $#.        tmp11 := tmp5 indexOf: Character space startingAt: tmp10 + 1 ifAbsent: [ tmp5 size ].        tmp12 := (tmp5 copyFrom: 1 to: tmp10 - 1) , (tmp5 copyFrom: tmp11 + 1 to: tmp5 size).        tmp7 := 0 - (tmp11 - tmp10).        tmp5 := tmp12 ] ifFalse: [ tmp9 := 1 ].  tmp8 := (tmp3 isEmpty or: [ (tmp5 at: 1 ifAbsent: [ nil ]) = Character space ]) ifTrue: [ '' ] ifFalse: [ ' ' ].  tmp2 := tmp3 , tmp8 , tmp5.  tmp4 := tmp7 + tmp3 size + tmp6 first + tmp9 to: tmp7 + tmp3 size + tmp6 last + tmp9.  tmp1     text: tmp2;     selectFrom: tmp4 first to: tmp4 laststepModel  ^stepModelpreviewBorderWidth  ^self outerBorderWidthselectedColor  ^Color veryVeryLightGray alpha: 0.5executeAction  Smalltalk tools browser openOnClass: self debugger selectedContext methodClass selector: self debugger selectedContext selectornotifyHidePreview  self announce: GTSpotterHidePreview newlowerThreshold  ^lowerThresholdnotifyDiveOut: arg1  self announce: (GTSpotterDiveOut new element: arg1)gtDisplayOn: arg1  arg1 nextPutAll: 'Spotter'newActionButtonBrick  ^GLMHintableActionButtonBrick newonShowPreview  | tmp1 |  self paneBrick isPreviewShown ifTrue: [ ^self ].  tmp1 := (self width * 100 / (100 - self themer spotterThemer previewWidthPercent) - self width) @ 0 / 2.  self bounds: (self bounds expandBy: tmp1 rounded).  self paneBrick showPreview.  self doLayoutitemBrick: arg1  candidateBrick := arg1openOn: arg1  ^(super openOn: arg1)     extent: self initialExtent;     title: self session name;     yourselfcollect: arg1  ^self collect: arg1 as: self defaultItemsClasslabelBrick: arg1  labelBrick ifNotNil: [ self removeBrick: labelBrick ].  labelBrick := arg1.  self themer spotterThemer itemLabelStyleFor: labelBrick.  self addBrickBack: labelBrickspotterHistoryFor: arg1  < spotterOrder: 8>  arg1 listProcessor     allCandidates: [ self history asArray select: [:arg2 |  arg2 isNotNil and: [ arg2 value isNotNil ] ] ];     title: 'History';     itemName: [:arg3 |  arg3 class = GTSpotterProcessorLink ifTrue: [ arg3 processor itemNameFor: arg3 value ] ifFalse: [ arg3 gtDisplayString ] ];     filter: self defaultFilterClassonStepAdded  self isDropDownPaneVisible ifTrue: [ ^self ].  self showDropDownPanedebuggerTransmissionsIn: arg1  super debuggerTransmissionsIn: arg1.  arg1 transmit     from: #stack port: #selection;     to: #bytecode;     andShow: [:arg2 :arg3 |  self bytecodeIn: arg2 forContext: arg3 ]wantsToDisplayOnEmptyQuery: arg1  wantsToDisplayOnEmptyQuery := arg1onAddedSelector  ^onAddedSelectorbeSelected  self stepModel select: self candidateLinkgtDisplayOn: arg1  arg1 nextPutAll: (self contentString copyReplaceAll: String cr with: String space)indexForItemName: arg1 andQuery: arg2  ^arg2 isEmpty ifTrue: [ 1 ] ifFalse: [ super indexForItemName: arg1 andQuery: arg2 ]matchRegex  self filter: GTFilterRegexhelp  ^'Debug a selected piece of code from the code pane of the debugger.'filteredStack  ^(self session stackOfSize: 50) select: [:arg1 |  (arg1 method hasPragmaNamed: #debuggerCompleteToSender) not ]updateVariablesForContext  cachedVariables := selfallItemsDo: arg1  self allItems do: arg1testArrayPairsSmall  | tmp1 |  tmp1 := (1 to: 10) asArray gtInspectorVariableValuePairs.  self assert: tmp1 size equals: 10.  (tmp1 collect: #key) allSatisfy: [:arg1 |  (tmp1 at: arg1) = arg1 ]defaultLabel  ^'Inspect it'spotterStyleFor: arg1  arg1 brickRoot useVerticalLinearLayouttextualDiffIn: arg1  ^arg1 diff     when: [ self session supportsDiff ];     display: [ {self session actualResult gtDebuggerSUnitPrint .         self session expectedResult gtDebuggerSUnitPrint} ]initialize  super initialize.  self codePresentationSelector: #codePresentationinitialize  super initialize.  self needsUpdate: falsebreadcrumbBrick: arg1  breadcrumbBrick ifNotNil: [ self removeBrick: breadcrumbBrick ].  breadcrumbBrick := arg1.  breadcrumbBrick announcer when: GTSpotterBreadcrumbVisibilityChanged send: #onBreadcrumbVisibilityChanged to: self.  self themer spotterThemer breadcrumbStyleFor: breadcrumbBrick.  breadcrumbBrick width: [ self paneBrick contentsBrick width ].  breadcrumbBrick layout widthDependency: [ self paneBrick contentsBrick ].  self addBrickBack: breadcrumbBrickcategoryBrickFor: arg1  < return: #GTSpotterCategoryBrick>  ^self categories at: arg1 ifAbsentPut: [ self buildCategoryBrick: arg1 ]order  ^self category orderprocessor  ^self candidateLink processorbreadcrumbTriangleHeight  ^16cutAllowedBoundsBottom: arg1  self allowedBounds: (self shrinkBottom: self allowedBounds with: arg1)initialize  super initialize.  self needsUpdate: falsepushActionButton: arg1  arg1     width: [:arg2 |  arg2 icon width * 1.5 ];     vSpaceFill.  self actionbarBrick addBrickBack: arg1.  self stepModel spotter isShiftPressed ifTrue: [ self themer spotterThemer hintRevealStyleFor: arg1 ]onBreadcrumbVisibilityChanged  self changedpageActions  ^(Pragma allNamed: self pageActionPragma from: self class to: Object sortedByArgument: 1) collect: [:arg1 |  self perform: arg1 methodSelector ]senders  ^SystemNavigation default allSendersOf: self namehidePreview  self isPreviewShown ifFalse: [ ^self ].  self removeBrick: self previewBrick.  self contentsBrick layout hSpaceFill.  self changedborderWidth  ^1variableTag  ^tag ifNil: [ super variableTag ]handleExceptionsDuring: arg1  [ GTCurrentSpotterExceptionHandler use: self during: arg1 ] on: self do: [:arg2 |  [ self handleException: arg2 ] on: Error do: [:arg3 |  self handleFatalException: arg3 ] ]isMatchedItem: arg1  ^self regex matches: (self itemFilterNameFor: arg1)titleBackgroundColor  ^Color transparentpresentationFilter  < return: #GTInspectorPresentationFilter>  ^presentationFilterdeselect  super deselect.  self hideActionbarcodePresentationSelector  ^codePresentationSelectorfiles  ^self allFilesSorted takeFirst: self pagesLimitsearch  ^searchdefaultNotAvailableText  ^'Preview is not available :('testPlaygroundActionsIn  | tmp1 tmp2 tmp3 |  tmp2 := playground class compile: 'mockMethodPlaygrounAction	<playgroundActionOrder: 100>	^ GLMGenericAction new		action: [ :presentation | self inform: ''playground action works'' ];		iconNamed: #abstract;		title: ''A mock playground action''' classified: '*GTMockTests'.  self assert: tmp2 notNil.  window := playground openOn: (GTPlayPage new saveContent: 'a:=1. b:=a+1').  tmp1 := playground playgroundActions.  self denyEmpty: tmp1.  tmp3 := tmp1 detect: [:arg1 |  arg1 title = 'A mock playground action' ].  self deny: tmp3 isNilpanes  ^self browser panesspotterPreviewArrowWidgetStyleFor: arg1  arg1 owner isTriangleVisible ifTrue: [ arg1 color: self previewArrowColor.        arg1 renderer borderColor: self borderColor ] ifFalse: [ arg1 color: Color transparent.        arg1 renderer borderColor: Color transparent ].  GTSpotter isPreviewVisible ifTrue: [ arg1 selectedColor: self borderColor.        arg1 renderer border: 0 ] ifFalse: [ arg1 selectedColor: Color transparent.        arg1 renderer border: self outerBorderWidth ]filter  ^filterformatStackMethodColumnForContext: arg1  ^Text string: (self printStackMethodColumnForContext: arg1) attributes: (self textAttributesForStackEntry: arg1)performSymbol: arg1 withArguments: arg2  | tmp1 |  tmp1 := self timestamp.  Processor yield.  UIManager default defer: [ tmp1 = self timestamp ifTrue: [ self receiver perform: arg1 withEnoughArguments: arg2 ] ]defaultSeparators  ^' 'openOn: arg1  | tmp1 |  tmp1 := super openOn: arg1.  tmp1 extent: self class preferredExtent.  tmp1 when: WindowResizing do: [ (tmp1 isMinimized or: [ tmp1 isMaximized ]) ifFalse: [ self class setPreferredExtentIfWanted: tmp1 extent ] ].  ^tmp1queryForItem: arg1  self flag: 'this is an ugly hack for #queryForFileReference. The iterator will manipulate the query being used for each item'.  ^self context cacheAt: #queryForFileReference ifAbsent: [ query ]spotterModel: arg1  spotterModel := arg1.  self searchField morph on: spotterModel.  spotterModel announcer when: GTSpotterCurrentStepChanged send: #onCurrentStepChanged to: self.  self spotterModel announcer when: GTSpotterRevealHints send: #onRevealHints to: self.  self spotterModel announcer when: GTSpotterHideHints send: #onHideHints to: selfonCandidateSelected: arg1  self selectedItemBrick: arg1 itemBrick.  self moveTo: self selectedItemBricksetUp  super setUp.  a := 42headerWidgetStyleFor: arg1  arg1 color: self backgroundColorspotterStfxFor: arg1  < spotterOrder: 30>  self flag: #specialFilter.  ^arg1 listProcessor     title: 'ws.stfx.eu';     filter: GTNullFilter item: [:arg2 :arg3 |  (arg3 textTrimmed beginsWith: 'http://ws.stfx.eu') ifTrue: [ GTPlayPage loadFromPublishUrl: arg3 textTrimmed thenDo: arg2 ] ]newCategoryBrick  ^GTSpotterCategoryBrick newensureStashPersistency  (self persistenceStrategies noneSatisfy: [:arg1 |  arg1 isStash ]) ifTrue: [ self persistenceStrategies add: (GTPlayPageStashPersistence new page: self) ]showPreview  self spotterModel showPreviewmaxNumberOfSteps  ^5assertProcessorMatching: arg1  | tmp1 |  tmp1 := spotter currentStep processors select: [:arg2 |  arg1 value: arg2 ].  self assert: tmp1 notEmpty.  self assert: tmp1 size equals: 1.  currentProcessor := tmp1 anyOne.  self assert: currentProcessor notNil.  ^currentProcessororigin: arg1  origin := arg1notifyRevealHints  self announce: GTSpotterRevealHints newcodeActionsPragmas  ^#(codeDebuggingAction)openAndInitialize: arg1  arg1 color: self color.  arg1 openWithFullView.  arg1 window window     position: self window position;     extent: self window extent.  ^arg1onDo: arg1  onDo := arg1setUpCodeIn: arg1  arg1 pharoMethod     title: [ self setUpPresentationTitle ];     format: [ self session setUpMethod sourceCode ];     smalltalkClass: [ self session testObject class ];     when: [ self session overridesDefaultSetUpMethod ];     doItReceiver: [ self session testObject ]urlProvider  ^urlProvider ifNil: [ urlProvider := self class urlProvider ]browseClassRefs  self currentContext ifNotNil: [:arg1 |  | tmp1 |        tmp1 := arg1 methodClass instanceSide.        tmp1 isTrait ifTrue: [ self systemNavigation browseAllUsersOfTrait: tmp1 ] ifFalse: [ self systemNavigation browseAllCallsOnClass: tmp1 ] ]intermediaryCheckWithFailure  40 + 2.  self checkWithFailurepresenterAt: arg1 ifAbsent: arg2  ^self basicPresenters at: arg1 ifAbsent: [ [ self readSlotNamed: arg1 ] on: SlotNotFound do: arg2 ]title  ^super title ifNil: [ self class defaultTitle ] ifNotNil: [:arg1 |  arg1 ]concreteMethodsInContext: arg1 usingFilter: arg2  | tmp1 tmp2 tmp3 |  tmp1 := (arg1 textTrimmed splitOn: '>>') collect: [:arg3 |  arg3 trimBoth ].  tmp1 size = 2 ifFalse: [ ^self ].  tmp1 second size < 2 ifTrue: [ ^self ].  tmp3 := tmp1 second first = $# ifTrue: [ tmp1 second allButFirst asSymbol ] ifFalse: [ tmp1 second asSymbol ].  (tmp2 := Smalltalk classNamed: tmp1 first) ifNil: [ SystemNavigation default allBehaviorsDo: [:arg4 |  arg4 methodsDo: [:arg5 |  arg5 selector = tmp3 ifTrue: [ arg2 value: arg5 ] ] ].        ^self ].  tmp2 withAllSuperclassesDo: [:arg4 |  arg2 value: ([ arg4 compiledMethodAt: tmp3 ] on: Error do: [ ^self ]) ]searchFieldFontSize  ^15spotterModel: arg1  spotterModel := arg1.  self headerBrick spotterModel: spotterModel.  spotterModel steps isEmpty ifFalse: [ spotterModel currentStep hasCandidates ifTrue: [ self showDropDownPane ] ].  spotterModel announcer when: GTSpotterStepAdded send: #onStepAdded to: selfindex  ^indexsingleClick: arg1  self stepModel select: self candidateLink dueTo: #singleClickonCandidateAdded  (self hasSelected or: [ self candidates isEmpty ]) ifFalse: [ self selectFirst ]items: arg1  allCandidatesBlock := arg1render: arg1 on: arg2  super renderBackgroundColorOf: arg1 on: arg2.  self renderArrow: arg1 on: arg2testDebugger  self assertDebuggerInitializationForContext: [ 20 factorial ] asContext andStepBlock: [:arg1 |   ].  self assertDebuggerClosingtestgroupedAndSortedSpotterExtensions  | tmp1 |  tmp1 := GTSpotterExtensionSettings groupedAndSortedSpotterExtensions.  self assert: tmp1 class equals: SortedCollection.  self assert: (tmp1 allSatisfy: [:arg1 |  arg1 value allSatisfy: [:arg2 |  arg2 class = RGMethodDefinition ] ])defaultStep  ^GTSpotterStep newprivateRenderingProcessorLink: arg1  renderingProcessorLink := arg1signatureFor: arg1  ^{arg1 methodClass .   arg1 selector}scrollbarColor  ^Color black alpha: 0.5testDebuggingExceptionHandlerMock3  self shouldRaise: ZeroDivide process: 'abc' origin: GTSpotterExceptionMock3 newopenFullDebugger  | tmp1 |  tmp1 := self debugger.  debugger := nil.  self close.  tmp1 openWithFullViewquery: arg1  query := arg1fileReference  self fileDirectory ifNil: [ ^nil ].  ^self fileDirectory / self fileNamecontinuing: arg1  continuing := arg1hasSelected  ^self hasSteps and: [ self currentStep hasSelected ]inspectorPragmaKey  ^#gtInspectorPresentationOrder:candidateLink: arg1  candidateLink := arg1addAllCandidates: arg1 in: arg2  | tmp1 |  tmp1 := OrderedCollection new.  arg1 do: [:arg3 |  | tmp2 tmp3 |        tmp2 := self getProcessorLink: arg2.        tmp3 := arg3 asSpotterCandidateLink processorLink: tmp2.        tmp3 := tmp2 isEmpty ifTrue: [ self privateAddCandidate: tmp3 inEmpty: tmp2 ] ifFalse: [ self privateAddCandidate: tmp3 inNotEmpty: tmp2 ].        self updateCycleConnectionFor: tmp3.        tmp1 add: tmp3 ].  self announcer announce: (GTSpotterAllCandidatesAdded new           candidateLinks: tmp1;           category: arg2;           yourself)debuggerToTest  self subclassResponsibilityaddAllTags  self allTags do: [:arg1 |  self addTag: allTags ]variableTag: arg1  tag := arg1tail  ^self candidates tailon: arg1  | tmp1 |  tmp1 := GLMBrickListModel new on: arg1.  tmp1 morphAtLogic: [:arg2 |  self newBindingRow: (tmp1 origin at: arg2) in: tmp1 origin ].  self model: tmp1defaultLabel  ^'Do it and go'overridesDefaultSetOrTearMethods  ^self overridesDefaultTearDownMethod or: [ self overridesDefaultSetUpMethod ]testPreviousA1Category  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := candidates addProcessor: GTSpotterA1.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp2 := candidates addCandidate: 12 in: GTSpotterA1.  tmp3 := candidates addCandidate: 13 in: GTSpotterA1.  self assert: tmp4 equals: (candidates previousProcessorLinkOf: tmp4)iconBrick: arg1  iconBrick ifNotNil: [ self removeBrick: iconBrick ].  iconBrick := arg1.  self themer spotterThemer itemIconStyleFor: iconBrick.  self addBrickBack: iconBrickexecuteAction  self codePresentation printSelectionshouldDisplayPresentationCreatedBy: arg1  self subclassResponsibilityinitialize  self flag: 'error handling'.  self pages: self defaultPages.  self files do: [:arg1 |  [ self pages add: (GTPlayPage fromFileReference: arg1) ] on: Error do: [  ] ]symbolicBytecodeForCurrentPCFrom: arg1  | tmp1 |  tmp1 := arg1 pc.  ^arg1 method symbolicBytecodes detect: [:arg2 |  arg2 offset = tmp1 ] ifNone: [ nil ]playgroundActionsIn: arg1  self playgroundActions do: [:arg2 |  arg1 addAction: arg2 ]isEmptyOrNil  ^self items isEmptyOrNilitems  ^items ifNil: [ items := self defaultItems.        self itemDo: [:arg1 |  items add: arg1 ] ]id  ^#gTExecuteSelectionDebugActionhasDynamicItems  ^allCandidatesBlock hasDynamicItemsbasicSearch: arg1  self flag: '#currentStep should be made more stable. This will fail for an empty, uninitialized spotter / but after multiple diveIn/diveOut it will be ok - inconsistent'.  self assert: spotter currentStep identicalTo: spotter currentStep.  previousStep := spotter currentStep.  previousContext := previousStep context.  self shouldnt: [ spotter setText: arg1 from: nil ] raise: Error.  currentStep := spotter currentStep.  currentContext := spotter currentStep context.  self assert: previousStep identicalTo: currentStepprepareFilterInContext: arg1  super prepareFilterInContext: arg1.  lowerThreshold ifNil: [ lowerThreshold := self defaultLowerThreshold ].  upperThreshold ifNil: [ upperThreshold := self defaultUpperThreshold ]headerBrick: arg1  headerBrick ifNotNil: [ self removeBrick: headerBrick ].  headerBrick := arg1.  self themer spotterThemer headerStyleFor: headerBrick.  self addBrickBack: headerBrickselectionIntervalForPane: arg1  ^((self browser paneNamed: arg1) port: #selectionInterval) value ifNil: [ ^1 to: 0 ]appliesToDebugger: arg1  ^(arg1 session isContextPostMortem: arg1 currentContext) not and: [ arg1 bytecodePresentation selection offset > arg1 currentContext pc ]select: arg1 thenCollect: arg2 as: arg3  | tmp1 |  tmp1 := self newAs: arg3.  self select: arg1 thenDo: [:arg4 |  tmp1 add: (arg2 value: arg4) ].  ^tmp1fileDirectory  ^self subclassResponsibilityselected  ^selectedvariableTag: arg1  tag := arg1helpButtonWidgetStyleFor: arg1  arg1     normalImage: GLMUIThemeExtraIcons glamorousHelp;     pressedColor: self buttonPressedColorstepBlockForTestArrays  ^[:arg1 |  arg1     completeStep: arg1 suspendedContext;     completeStep: arg1 suspendedContext;     step;     completeStep: arg1 suspendedContext;     completeStep: arg1 suspendedContext;     completeStep: arg1 suspendedContext;     step ]layoutStacked: arg1 in: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  self flag: 'refactor me'.  self allowedBounds: arg2.  tmp2 := self gatherStacked: arg1.  tmp1 := DoubleLinkedList new.  tmp1 addAll: tmp2.  tmp3 := true.  tmp6 := 0.  tmp7 := 0.  tmp4 := OrderedCollection new.  tmp5 := OrderedCollection new.  [ tmp2 isEmpty not & tmp3 ] whileTrue: [ | tmp8 |        tmp8 := tmp2 removeFirst value.        (self isVisible: tmp8) ifFalse: [ (self isAbove: tmp8) ifTrue: [ | tmp9 |                    tmp9 := (self deltaTop: tmp8) - tmp6.                    tmp8 translateX: tmp9 negated.                    self increaseZindex: tmp8.                    tmp4 isEmpty ifTrue: [ tmp6 := tmp6 + tmp8 globalOuterBounds height.                          self cutAllowedBoundsTop: tmp8 ].                    tmp4 add: tmp8 ] ifFalse: [ tmp3 := false.                    tmp2 addFirst: tmp8 ] ] ifTrue: [ (self isPartiallyVisibleAbove: tmp8) ifTrue: [ self layoutAllowedTop: tmp8 ] ifFalse: [ tmp3 := false.                    self decreaseZindex: tmp8.                    tmp2 addFirst: tmp8 ] ] ].  [ tmp2 isEmpty not ] whileTrue: [ | tmp8 |        tmp8 := tmp2 removeLast value.        (self isVisible: tmp8) ifFalse: [ | tmp9 |              tmp9 := (self deltaBottom: tmp8) - tmp7.              tmp8 translateX: tmp9 negated.              self increaseZindex: tmp8.              tmp5 isEmpty ifTrue: [ tmp7 := tmp7 + tmp8 globalOuterBounds height.                    self cutAllowedBoundsBottom: tmp8 ].              tmp5 add: tmp8 ] ifTrue: [ (self isFullyVisible: tmp8) ifFalse: [ self layoutAllowedBottom: tmp8 ] ifTrue: [ self decreaseZindex: tmp8 ] ] ].  self layoutProportional: tmp4 reverse in: arg1 position: #top.  self layoutProportional: tmp5 reverse in: arg1 position: #bottom.  ^allowedBoundsselectedVariableForContext: arg1  ^(self variablesFromContext: arg1) detect: [:arg2 |  arg2 key = self debugger selectedVariableName ] ifNone: [ cachedVariables detect: [:arg2 |  arg2 key = 'self' ] ifNone: [ nil ] ]testArrayPairsUnderLimit  | tmp1 tmp2 |  tmp1 := 2 * GTInspector indexableDisplayLimit - 1.  tmp2 := (1 to: tmp1) asArray gtInspectorVariableValuePairs.  self assert: tmp2 size equals: tmp1.  (tmp2 collect: #key) allSatisfy: [:arg1 |  (tmp2 at: arg1) = arg1 ].  self assert: (tmp2 collect: #key) equals: (1 to: tmp1) asOrderedCollectionclick: arg1  super click: arg1.  self stepModel spotter popUntil: self stepModel.  ^truetestNextA1A2EmptyCategory  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := candidates addProcessor: GTSpotterA1.  tmp5 := candidates addProcessor: GTSpotterA2.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp2 := candidates addCandidate: 12 in: GTSpotterA1.  tmp3 := candidates addCandidate: 13 in: GTSpotterA1.  self assert: tmp4 equals: (candidates nextProcessorLinkOf: tmp4).  self assert: tmp4 equals: (candidates nextProcessorLinkOf: tmp5)defaultOrder  ^100sourceOf: arg1 for: arg2 in: arg3  ^arg3 pharoMethod     display: [:arg4 |  arg4 sourceCode ];     smalltalkClass: [:arg4 |  arg4 methodClass ];     doItReceiver: [ arg2 ];     selectionPopulate: #evaluatedObject on: $g entitled: 'Do it and go' with: [:arg5 |  Smalltalk compiler           receiver: arg2;           evaluate: arg5 selectedText ];     installDefaultSelectionActions;     selectionAct: [:arg5 |  self updateOuterPaneFrom: arg5 for: arg1 ] icon: GLMUIThemeExtraIcons glamorousAccept on: $s entitled: 'Accept'evaluateExpressionInContext: arg1 usingFilter: arg2  | tmp1 |  (Number withAllSubclasses anySatisfy: [:arg3 |  arg3 selectors anySatisfy: [:arg4 |  arg1 textTrimmed includesSubstring: arg4 caseSensitive: true ] ]) ifFalse: [ ^self ].  Smalltalk compiler silentlyDo: [ tmp1 := Smalltalk compiler evaluate: arg1 textTrimmed ] exceptionDo: [ ^self ].  tmp1 isNumber ifFalse: [ ^self ].  arg2 value: tmp1.  (tmp1 isFraction and: [ tmp1 isInteger not ]) ifTrue: [ arg2 value: tmp1 asFloat ]selectedContext  ^((self browser paneNamed: #stack) port: #selection) valuetempName: arg1  tempName := arg1pageActionPragma  ^#pageActionOrder:computeAllItemsIn: arg1  ^OrderedCollection newcompositeBrick: arg1  self compositeBrick ifNotNil: [ self removeBrick: self compositeBrick ].  compositeBrick := arg1.  self themer spotterThemer spotterPreviewCompositeStyleFor: self compositeBrick.  self addBrickBack: self compositeBrick.  self doLayoutForcelabel  ^self key asStringname  ^nametitleTextColor  ^self backgroundColor muchLighterhasPreviousStep  < return: #Boolean>  ^self spotter hasSteps and: [ self spotter steps first ~= self ]currentContext  ^self selectedContext ifNil: [ self interruptedContext ] ifNotNil: [ self selectedContext ]isContinuing  ^self continuing and: [ self streamed isEmptyOrNil not and: [ self canContinue ] ]searchFieldStyleFor: arg1  arg1     beCentered;     hSpaceFill;     vSpaceFill;     withoutMargins;     withoutAdornment;     withoutBorder;     beTransparent;     withGhostText: self spotterGhostText;     autoAccept: true;     marginLeft: self searchFieldMarginLeft;     rubricTextFamilyName: self searchFieldFamilyName;     rubricTextFontSize: self searchFieldFontSize.  arg1 rubric ghostTextRuler fontName: self searchFieldFamilyName pointSize: self searchFieldFontSizetestObject  ^testContext receivertext  ^self currentTextonCandidatesAmountChanged: arg1  | tmp1 |  tmp1 := self categoryBrickOf: arg1 category.  tmp1 setAmountVisible: tmp1 submorphs size all: arg1 amountupperThreshold  ^upperThresholdinitialize  super initialize.  self themer: self themer spotterThemer themer.  self initializeListeners.  self themer spotterThemer spotterStyleFor: self.  self breadcrumbBrick: self newBreadcrumbBrick.  self paneBrick: self newPaneBrickitemDo: arg1  self subclassResponsibilitydebugger: arg1  debugger := arg1wantsToDisplayOnEmptyQuery  ^wantsToDisplayOnEmptyQuery ifNil: [ super wantsToDisplayOnEmptyQuery ]removeBinding: arg1  | tmp1 |  tmp1 := self currentBindings copy.  tmp1 removeKey: arg1 key ifAbsent: [  ].  self setBindings: tmp1debuggerTransmissionsIn: arg1  self subclassResponsibilitydefaultKeymap  ^PharoShortcuts current debugItShortcutisEmpty  ^self headLink isNiltitle  ^'undefined'layout  | tmp1 |  tmp1 := SpBoxLayout newHorizontal.  self basicPresenters keysDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1defaultLabel  ^'Step to bytecode'newRow  ^GLMInteractableBrick new     enable;     selectedColor: self themer bindingThemer selectedColor;     vShrinkWrap;     hSpaceFill;     padding: {self themer bindingThemer padding .         0 .         (self themer bindingThemer padding + self themer bindingThemer borderWidth)};     borderColor: self themer bindingThemer borderColorfilter: arg1  filterBlock := arg1preDebuggingActions  ^(self session class debuggingActionsForPragmas: {#preDebuggingAction} for: self debugger) do: [:arg1 |  arg1 preDebugWindow: self owner ]cutAllowedBoundsTop: arg1  self allowedBounds: (self shrinkTop: self allowedBounds with: arg1)updateCycleConnectionFor: arg1  self candidates tail = arg1 ifTrue: [ arg1 nextLink: self candidates head.        self candidates head previousLink: arg1 ].  self candidates head = arg1 ifTrue: [ arg1 previousLink: self candidates tail.        self candidates tail nextLink: arg1 ]onRevealHints  self visible ifFalse: [ ^self ].  self themer spotterThemer hintRevealStyleFor: self diveInButton.  self themer spotterThemer hintRevealStyleFor: self actOnButtontestRemoveCandidatesA1A3FromA1A2A3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp4 := candidates addProcessor: GTSpotterA1.  tmp5 := candidates addProcessor: GTSpotterA2.  tmp6 := candidates addProcessor: GTSpotterA3.  candidates addCandidate: 11 in: GTSpotterA1.  candidates addCandidate: 12 in: GTSpotterA1.  candidates addCandidate: 13 in: GTSpotterA1.  tmp1 := candidates addCandidate: 21 in: GTSpotterA2.  tmp2 := candidates addCandidate: 22 in: GTSpotterA2.  tmp3 := candidates addCandidate: 23 in: GTSpotterA2.  candidates addCandidate: 31 in: GTSpotterA3.  candidates addCandidate: 32 in: GTSpotterA3.  candidates addCandidate: 33 in: GTSpotterA3.  candidates removeAllCandidatesOf: GTSpotterA1.  candidates removeAllCandidatesOf: GTSpotterA3.  self assert: tmp1 nextLink equals: tmp2.  self assert: tmp1 previousLink equals: tmp3.  self assert: tmp2 nextLink equals: tmp3.  self assert: tmp2 previousLink equals: tmp1.  self assert: tmp3 nextLink equals: tmp1.  self assert: tmp3 previousLink equals: tmp2.  self assert: candidates head equals: tmp1.  self assert: candidates tail equals: tmp3.  self assert: tmp4 headLink equals: nil.  self assert: tmp4 tailLink equals: nil.  self assert: tmp5 headLink equals: tmp1.  self assert: tmp5 tailLink equals: tmp3.  self assert: tmp6 headLink equals: nil.  self assert: tmp6 tailLink equals: nilprocessorLink: arg1  processorLink ifNil: [ self renderingProcessor: arg1 ].  processorLink := arg1categoryAmountWidgetStyleFor: arg1  arg1     textColor: self titleTextColor;     color: self titleBackgroundColornewTitleBrick  ^GTSpotterCategoryTitleBrick newerrorMessage  ^'error obtaining indexed attribute value'hasFilteredCandidates  ^self allFilteredCandidates notEmptyinitialize  super initialize.  self needsUpdate: falsedetect: arg1  ^self detect: arg1 ifNone: [ NotFound signalFor: arg1 ]onAllCandidatesRemoved  self selectedItemBrick: nilgtListFilter  ^selfactOnBrowserClosing: arg1  self session ifNotNil: [:arg2 |  arg2 terminate ]debug: arg1 using: arg2  | tmp1 tmp2 |  tmp1 := self session.  self detachSession.  self browser close.  tmp1 updateContextTo: arg1.  tmp2 := arg2 on: (arg2 spanNewSessionFrom: tmp1).  ^self openAndInitialize: tmp2printSignature: arg1  ^arg1 first name , '>>' , arg1 second asStringpagesLimit: arg1  pagesLimit := arg1filter  ^filterBlockhideTriangle  isTriangleVisible := false.  self themer spotterThemer spotterPreviewArrowWidgetStyleFor: self triangleBrick.  self changedcurrentText  ^self current ifNil: [ '' ] ifNotNil: [ self current text ]diveOut  self spotterModelDo: [ self spotterModel popStep ]spotterPreviewWidgetStyleFor: arg1  arg1     borderColor: self borderColor;     color: self backgroundColorvalue  ^[ self rawValue ] on: Error do: [ nil ]asOrderedCollection  ^self items copyexit  self spotter exitacceptContents: arg1  ^(self entity acceptContents: arg1) ifTrue: [ self update.        true ]autoHide  ^autoHide ifNil: [ autoHide := true ]context: arg1  context := arg1actOnInspectorPaneRemoved: arg1  inspectIcon  ^GLMUIThemeExtraIcons glamorousInspecttestFailingText  self assert: 'I like pie  pizza pie apple pie rad squared pi and other PIes' equals: 'I like pie  pizza pie potato pie rad squared pi and other PIes'notifyAllCandidatesRemoved  self announcer announce: GTSpotterAllCandidatesRemoved newvariableTag  ^'implicit'renderTopTriangle: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := arg1 brickBounds width.  tmp5 := arg1 brickBounds height.  tmp1 := arg1 brickBounds bottomLeft + ((tmp4 / 2 - tmp5 max: 0) @ 0).  tmp2 := arg1 brickBounds bottomLeft + ((tmp4 / 2 + tmp5 min: tmp4) @ 0).  tmp3 := arg1 brickBounds topLeft + ((tmp4 / 2) @ 0).  self renderTriangle: arg1 on: arg2 with: {tmp1 asIntegerPoint .         tmp2 asIntegerPoint .         tmp3 asIntegerPoint}categoryBrickOf: arg1 ifAbsent: arg2  < return: #GTSpotterCategoryBrick>  ^self categories at: arg1 ifAbsent: arg2defaultLabel  ^'Go and inspect'eventType: arg1  eventType := arg1handleException: arg1 with: arg2  ^self handleException: arg1 do: [ arg2 ]popSeparator  self band removeBrick: self band lastSubbrickperformSymbol: arg1 withArguments: arg2  self receiver perform: arg1 withEnoughArguments: arg2hideActionsOf: arg1  arg1 subbricks select: [:arg2 |  arg2 isKindOf: GLMHintableActionButtonBrick ] thenDo: [:arg2 |  arg2 visible: false ]assertProcessorByTitle: arg1  ^self assertProcessorMatching: [:arg2 |  arg2 title = arg1 ]itemLabelStyleFor: arg1  arg1 label highlightingLogic: [:arg2 :arg3 |  | tmp1 |        tmp1 := arg3 translateBy: -3 @ 0.        arg2 line: tmp1 bottomLeft to: tmp1 bottomRight width: 1 color: Color lightGray ].  arg1     hSpaceFill;     vSpaceFill;     marginRight: self outerBorderWidthallItemsIn: arg1  ^allCandidates ifNil: [ allCandidates := (self computeAllItemsIn: arg1) copy ]textTrimmed  ^textTrimmed ifNil: [ textTrimmed := self defaultTextTrimmed ]browseInstVarRefs  | tmp1 |  tmp1 := self currentClassOrMetaClass.  (tmp1 notNil and: [ tmp1 isTrait not ]) ifTrue: [ self systemNavigation browseInstVarRefs: tmp1 ]addItem: arg1  arg1 width: [:arg2 |  self calculateItemWidth: arg2 ].  arg1 layout widthDependency: self.  self items size = 1 ifTrue: [ self items first labelBrick paddingLeft: self themer spotterThemer breadcrumbSeparatorWidth / 2 ].  self items addLast: arg1.  self band addBrickBack: arg1.  self items do: [:arg3 |  arg3 wrappedBounds markWidthDirty ].  self band doLayoutForcetestAddCategories  | tmp1 |  tmp1 := {GTSpotterA1 .   GTSpotterA2 .   GTSpotterA3}.  self addCategories: tmp1.  self assert: (self hasCategories: tmp1)processors  ^processors ifNil: [ processors := OrderedCollection new.        self origin spotterProcessorsFor: self.        processors do: [:arg1 |  self candidates addProcessor: arg1 ].        processors ]defaultExceptionHandler  ^GTSpotterDebuggingExceptionHandler neweventType  ^eventTypetestInstanceCreation  self assert: spotter notNil.  self assertEmpty: spotter steps.  self deny: spotter hasMultipleStepsinspectorIn: arg1  (self textualDiffIn: arg1) title: 'Diff (actual vs. expected)'.  (self inspectorDiffIn: arg1) title: 'Objects (actual vs. expected)'.  super inspectorIn: arg1.  self session supportsDiff ifTrue: [ arg1 last title: 'Inspector' ]browseClassVariables  | tmp1 |  tmp1 := self currentClass.  (tmp1 notNil and: [ tmp1 isTrait not ]) ifTrue: [ self systemNavigation browseClassVariables: tmp1 ]setUpPresentationTitle  ^'SetUp' , (self session setUpMethod methodClass ~= self session testContext methodClass ifTrue: [ ' (' , self session setUpMethod methodClass name , ')' ] ifFalse: [ '' ])onThemerChanged  super onThemerChanged.  self themer spotterThemer headerWidgetStyleFor: self.  self themer spotterThemer closeButtonWidgetStyleFor: self closeButton.  self themer spotterThemer searchFieldWidgetStyleFor: self searchField.  self class environment at: #GTEventRecorderSettings ifPresent: [ self themer spotterThemer settingsButtonWidgetStyleFor: self settingsButton ]on: arg1 category: arg2  self stepModel: arg1.  self category: arg2defaultContinuing  ^falseuncheck  super uncheck.  self hideActionbarremoveAllCandidates  self performSymbol: #removeAllCandidates withArguments: {}.  Processor yieldentities  ^self panes collect: [:arg1 |  (arg1 port: #entity) value ]eventType  ^eventTypenotifyBreadcrumbVisibilityChanged  self announcer announce: GTSpotterBreadcrumbVisibilityChanged newaddObject: arg1 inProcessor: arg2  objects add: arg1privateAddCandidate: arg1 weightedInFull: arg2  key  ^labelconfigurationBlockForProcessorsCreatedBy: arg1  ^[:arg2 |   ]allowProcessorsFrom: arg1 configuredWith: arg2  self allowProcessorsFrom: arg1.  configurationBlocks at: arg1 printString put: arg2itemBrick  ^candidateBricknewTriangleBrick  ^GLMBrick newiconBrick  ^iconBrickchangeFilterRequestFor: arg1  requestRefresh  self updateToolbar.  self refreshPaneselement  ^elementremoveSessionSilently  (self browser pane port: #entity) silentValue: niltitleBrick: arg1  titleBrick := arg1allCandidates: arg1  self items: arg1newDebugger  ^newDebuggerupdatePreviewWithEmpty  self removeAllBricks.  self asyncTask execute: [ | tmp1 |        tmp1 := GLMLabelBrick new           text: self defaultNotAvailableText;           textPosition: #center;           textColor: Color lightGray;           with: [:arg1 |  arg1 label                 customFont;                 fontSize: 14 ] ] withArguments: {} callback: [:arg2 |  self compositeBrick: arg2 ] priority: Processor userBackgroundPriority delay: 50inspectorActionsForNode  ^self hostObject inspectorActionsForNodemockProcessorFor: arg1  < spotterOrder: 1>  arg1 listProcessor     allCandidates: [ nil ];     itemName: [:arg2 |  arg2 asString ];     filter: GTFilterSubstringdropDownBrick  ^dropDownBrickinspectSubInstances  self currentClassOrMetaClass ifNotNil: [:arg1 |  arg1 instanceSide inspectSubInstances ]isVisible  ^self items isEmpty notstepModel: arg1  stepModel := arg1.  stepModel announcer when: GTSpotterSelectedCandidateChanged send: #onSelectedChanged: to: self.  stepModel spotter announcer when: GTSpotterStepPopped send: #onStepPopped to: self.  self actionbarBrick stepModel: arg1.  self     highlightQuery;     checkOrUncheckdefaultLabel  ^'Print it'labelBrick: arg1  labelBrick := arg1.  self themer spotterThemer breadcrumbItemLabelStyleFor: self labelBrick.  self addBrickBack: self labelBrickexecuteAction  newDebugger := self debugger debug: self interruptedContext using: debuggerClasschangeFilterRequestFor: arg1  self openListChooseLabeled: 'All available presentations' forInspector: arg1 with: allMethodSignatures select: selectedMethodSignatures format: [:arg2 |  self printSignature: arg2 ] actionSelector: #replaceSelectedSignaturesWith:in:testInitialText  self flag: 'is this instvar still required ? we have context'.  self assert: spotter getText isEmptyOrNil.  self assert: spotter text isEmptyOrNilisFirst  ^(self previousLink processorLink = self processorLink) notselected  < return: #GTSpotterCandidateLink>  self assert: [ selected isNotNil ] description: [ 'Selected candidate can not be accessed where there is no one' ].  ^selectedshouldDisplayPresentationCreatedBy: arg1  ^selectedMethodSignatures anySatisfy: [:arg2 |  arg2 first = arg1 methodClass and: [ arg2 second = arg1 selector ] ]browseMethodFull  self currentClassOrMetaClass ifNotNil: [ Smalltalk tools browser openOnClass: self currentClassOrMetaClass selector: self currentMessageName ]candidateLink  ^candidateLinkon: arg1  | tmp1 |  tmp1 := GLMBrickListModel new on: arg1 pages.  tmp1 morphAtLogic: [:arg2 |  self newPageRow: (tmp1 origin at: arg2) in: arg1 ].  self model: tmp1notifyStepPopped  self announce: GTSpotterStepPopped newnewRemoveButtonFor: arg1  ^self newActionButton     beError;     hintTitle: 'Remove binding';     hintText: 'will unassign variable';     icon: self themer bindingThemer removeIcon;     action: [:arg2 |  arg2 owner disable.        GLMAnimation swipeLeft           onCompleted: [ self announce: #bindingRemoved event: arg1.              self model origin remove: arg1.              self invalidate ];           animate: arg2 owner ]addObjects: arg1 inProcessor: arg2  self performSymbol: #addAllCandidates:in: withArguments: {arg1 .         arg2}.  Processor yieldget: arg1  | tmp1 |  tmp1 := self httpClient get: arg1.  ^String new: tmp1 size streamContents: [:arg2 |  tmp1 linesDo: [:arg3 |  arg2                 nextPutAll: arg3;                 cr ] ]notifyCandidateAdded: arg1 in: arg2  self announcer announce: (GTSpotterCandidateAdded new           candidateLink: arg1;           category: arg2;           yourself)removeLastPane  | tmp1 |  tmp1 := self panes last.  self browser removeLastPane.  self browser announce: (GLMPaneRemoved pane: tmp1 fromBrowser: self browser)notifyContextChangedFrom: arg1 to: arg2  self announce: (GTSpotterContextChanged new           previous: arg1;           current: arg2;           yourself)emptyTextColor  ^self themer textLightColor< arg1  ^self weight < arg1 weightselectPreviousCategory  self spotterModel hasSelected ifTrue: [ self spotterModel currentStep selectPreviousCategory ]spotterPreviewArrowStyleFor: arg1  arg1     hSpaceFill;     renderer: (GTSpotterTriangleRenderer new orientation: #right);     height: [ (self previewArrowWidth - self previewArrowGapHack) * 2 ]spotterContentsStyleFor: arg1  arg1     useVerticalLinearLayout;     borderWidth: self outerBorderWidth;     padding: self outerBorderWidth;     hSpaceFill;     vSpaceFill.  arg1 layout zIndex: 2spotterPreviewCompositeStyleFor: arg1  arg1     hSpaceFill;     vSpaceFill;     margin: self previewBorderWidth;     paddingLeft: self previewPaddingLefttempIndex: arg1  tempIndex := arg1addItem: arg1  self addBrickBack: arg1reject: arg1  ^self reject: arg1 as: self defaultItemsClassdebugger  ^debuggerinitialize  super initialize.  categories := Dictionary new.  self band hSpaceFill.  self announcer when: GLMBrickScrollPositionChanged send: #onScrolled to: selfspotterForRepositoriesFor: arg1  < spotterOrder: 87>  arg1 listProcessor     title: 'Monticello Repositories';     allCandidates: [ MCRepositoryGroup default repositories ];     itemIcon: #systemIcon;     wantsToDisplayOnEmptyQuery: false;     filter: self defaultFilterClasscontext  ^self currenttestContextNodes  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp2 := 42.  tmp1 := OrderedCollection new.  [:arg1 |  arg1 + 1 + tmp2 ] asContext gtInspectorVariableNodesIn: tmp1.  tmp1 := tmp1 withIndexCollect: [:arg2 :arg3 |  arg3 -> arg2 ].  tmp3 := tmp1 select: [:arg2 |  arg2 value label beginsWith: '[' ].  tmp4 := tmp1 select: [:arg2 |  arg2 value key isInteger ].  tmp5 := tmp1 select: [:arg2 |  arg2 value isKindOf: GTInspectorSlotNode ].  self assert: tmp3 sort last key < tmp4 first key.  self assert: tmp4 sort last key < tmp5 first keyurlProvider: arg1  urlProvider := arg1 asZnUrldefaultBreadcrumbHeight  ^self themer spotterThemer breadcrumbHeight + self themer spotterThemer breadcrumbTriangleHeighttitle: arg1  title := arg1httpClient  ^ZnClient new     systemPolicy;     beOneShot;     accept: ZnMimeType textPlain;     url: self urlProvider;     yourselfonUnhovered  (self stepModel isCategorySelected: self category) ifFalse: [ self hideActionbar ]defaultPlaygroundTitle  ^'Playground'privacyAgreementNotificationStyleFor: arg1  | tmp1 |  tmp1 := arg1 sendUsageData ifTrue: [ self privacyAgreementIsSendingDataColor ] ifFalse: [ self privacyAgreementIsNotSendingDataColor ].  arg1 messageBrick rubricTextFamilyName: StandardFonts defaultFont familyName.  arg1 messageBrick rubricTextColor: Color black.  arg1     color: tmp1;     borderColor: tmp1 darker;     borderWidth: self outerBorderWidth;     marginTop: 0applyFilterWithQuery  [ self doApplyFilterWithQuery ] on: GTLimitArrived do: [ ^self ]shouldEnableProcessorsCreateBy: arg1  self subclassResponsibilitysetUp  super setUp.  debugger := self debuggerToTest newitemDo: arg1  self onDo cull: arg1 cull: self contextspotterForMetacelloConfigurationsFor: arg1  < spotterOrder: 86>  arg1 listProcessor     title: 'Metacello Configurations';     allCandidates: [ Smalltalk allClasses select: [:arg2 |  (arg2 respondsTo: #isMetacelloConfig) and: [ arg2 isMetacelloConfig and: [ arg2 name beginsWith: 'ConfigurationOf' ] ] ] thenCollect: #project ];     itemName: [:arg2 |  arg2 configuration class name ];     itemIcon: [ Smalltalk ui icons iconNamed: #config ];     filter: self defaultFilterClass;     wantsToDisplayOnEmptyQuery: falseonDraw: arg1  super onDraw: arg1.  arg1 fillRectangle: ((self brickBounds withWidth: self themer spotterThemer outerBorderWidth) translateBy: (self themer scrollbarWidth + self themer scrollbarOffset + 1) @ 0) color: (self spotterModel isPreviewVisible ifTrue: [ self themer spotterThemer backgroundColor ] ifFalse: [ Color transparent ])isEmpty  < return: #Boolean>  ^self candidates isEmptydeleteFromFileSystem  | tmp1 |  tmp1 := self fileReference.  (tmp1 notNil and: [ tmp1 fileSystem isWritable ]) ifTrue: [ tmp1 ensureDelete ]inspectorActionsForNode  < return: #Collection of: #GLMAction>  ^#()wantsToDisplayOnEmptyQuery  ^truetestDeploymentExceptionHandlerMock3  self assertResetExceptions.  self shouldntRaise: ZeroDivide process: 'abc' origin: GTSpotterExceptionMock3 new.  self assertException: ZeroDivide.  self assertResetExceptions.  self shouldntRaise: Error process: 'abc' origin: GTSpotterExceptionMock3 new.  self assertException: ZeroDividenewInspectButtonFor: arg1  ^self newActionButton     hintTitle: 'Inspect';     hintText: 'will open inspector window';     icon: self themer bindingThemer inspectIcon;     action: [:arg2 |  self remove.        self announce: #inspect event: arg1 ]installCodeActionsFor: arg1  self installActionsForRootPragmas: self codeActionsPragmas in: arg1browsingActionsForNode  ^{(GLMGenericAction new     action: [ self systemNavigation browseAllAccessesTo: self label from: self hostObject class ];     title: 'List methods using this variable') .   (GLMGenericAction new     action: [ self systemNavigation browseAllStoresInto: self label from: self hostObject class ];     title: 'List methods storing into this variable')}mockProcessorFor: arg1  < spotterOrder: 1>  AssertionFailure signal: self messageTextvariableTag  ^'attribute'onAllCandidatesAdded: arg1  arg1 candidateLinks ifEmpty: [ ^self ].  self addItems: (arg1 candidateLinks collect: [:arg2 |  self buildItemFor: arg2 in: arg1 category ]) to: (self categoryBrickFor: arg1 category)stackDebuggingActionsPragmas  ^#(stackDebuggingAction)notEmpty  ^self isEmpty notgetCandidateLinks: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := arg1 headLink.  tmp3 := arg1 tailLink.  tmp1 := OrderedCollection new.  tmp2 ifNil: [ ^tmp1 ].  tmp2 = tmp3 ifTrue: [ tmp1 add: tmp2.        ^tmp1 ].  tmp4 := tmp2.  [ tmp4 = tmp3 ] whileFalse: [ tmp1 add: tmp4.        tmp4 := tmp4 nextLink ].  tmp1 add: tmp4.  ^tmp1assertSearch: arg1  self deny: (spotter currentStep context matches: arg1).  self basicSearch: arg1.  self deny: previousContext identicalTo: currentContext.  self deny: previousContext identicalTo: spotter currentStep context.  self assert: spotter currentStep context text asString equals: arg1 asStringisTriangleVisible  ^isTriangleVisible ifNil: [ isTriangleVisible := false ]nameBrick  ^nameBrickstream  ^stream ifNil: [ stream := self defaultStream.        stream           onAddedSelector: #addCandidate:in:;           onRemoveSelector: #removeAllCandidatesOf:;           receiver: self candidates.        stream ]gtInspectorProcessorsIn: arg1  < gtInspectorPresentationOrder: 40>  arg1 list     title: 'Processors';     display: [ self processors ];     format: #gtDisplayString;     when: [ self spotter notNil ]initialize  super initialize.  self     emptyBrick: self newEmptyText;     maxHeight: 300;     height: [:arg1 |  arg1 band height ];     width: 300breadcrumbItemStyleFor: arg1  arg1 vSpaceFillnotifySpotterExitFor: arg1  self announce: (GTSpotterExitAnnouncement new eventType: arg1)addAllSignatures  self allPresentationMethods do: [:arg1 |  self addSignatureFor: arg1 ]testNoOverlappingCodeEditorKeyBindings  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self skip.  tmp1 := [ 20 factorial ] asContext.  tmp2 := Process forContext: tmp1 priority: Processor userInterruptPriority.  window := GTGenericStackDebugger openOn: (tmp2 newDebugSessionNamed: 'test debugging' startedAt: tmp1).  tmp3 := self findSatisfying: [:arg1 |  arg1 model isKindOf: GLMRubricSmalltalkTextModel ] in: window.  tmp4 := OrderedCollection new.  tmp3 withAllOwnersDo: [:arg1 |  tmp4 addAll: arg1 kmDispatcher directKeymaps allEntries keymaps ].  tmp5 := (tmp4 groupedBy: [:arg2 |  arg2 shortcut ]) select: [:arg2 |  arg2 value size > 1 ].  self assertEmpty: tmp5newSearchField  ^GLMRubTextFieldBrick newtestCategoryLinkByCandidateLinkThreeA1A2A3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 |  tmp10 := candidates addProcessor: GTSpotterA1.  tmp11 := candidates addProcessor: GTSpotterA2.  tmp12 := candidates addProcessor: GTSpotterA3.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp2 := candidates addCandidate: 12 in: GTSpotterA1.  tmp3 := candidates addCandidate: 13 in: GTSpotterA1.  tmp4 := candidates addCandidate: 21 in: GTSpotterA2.  tmp5 := candidates addCandidate: 22 in: GTSpotterA2.  tmp6 := candidates addCandidate: 23 in: GTSpotterA2.  tmp7 := candidates addCandidate: 31 in: GTSpotterA3.  tmp8 := candidates addCandidate: 32 in: GTSpotterA3.  tmp9 := candidates addCandidate: 33 in: GTSpotterA3.  self assert: tmp10 equals: (candidates getProcessorLinkByCandidateLink: tmp1).  self assert: tmp10 equals: (candidates getProcessorLinkByCandidateLink: tmp2).  self assert: tmp10 equals: (candidates getProcessorLinkByCandidateLink: tmp3).  self assert: tmp11 equals: (candidates getProcessorLinkByCandidateLink: tmp4).  self assert: tmp11 equals: (candidates getProcessorLinkByCandidateLink: tmp5).  self assert: tmp11 equals: (candidates getProcessorLinkByCandidateLink: tmp6).  self assert: tmp12 equals: (candidates getProcessorLinkByCandidateLink: tmp7).  self assert: tmp12 equals: (candidates getProcessorLinkByCandidateLink: tmp8).  self assert: tmp12 equals: (candidates getProcessorLinkByCandidateLink: tmp9)key  ^label ifNil: [ self hostObject key ]categoryTitleNameWidgetStyleFor: arg1  arg1     textColor: self titleTextColor;     color: self titleBackgroundColortimestamp  ^timestamprawValue  ^self hostObject rawValueitemSelectedBackgroundColor  ^self backgroundColor darkericon: arg1  self iconBrick normalImage: arg1initialize  super initialize.  debugActionHolder := nil asValueHolder.  debugActionHolder whenChangedDo: [ self update ]render: arg1  ^GTSpotterItemBrick new     icon: (self itemIconFor: arg1);     text: (self itemNameFor: arg1)id  ^#gtClearEditorDebugActiontestDebuggingExceptionHandlerMock4  self shouldRaise: ArithmeticError process: 'abc' origin: GTSpotterExceptionMock4 new do: [:arg1 |  self assert: arg1 messageText equals: 'Error while filtering' ]initialize  super initialize.  self enable.  self announcer when: #onMouseHover send: #onHovered to: self.  self announcer when: #onMouseUnhover send: #onUnhovered to: selfdebuggerToTest  ^GTSUnitDebuggertaskbarIcon  ^self iconNamed: #glamorousBugspotterCatalogProjectsFor: arg1  < spotterOrder: 90>  CatalogSettings displayCatalogProjectsInSpotter ifFalse: [ ^self ].  arg1 listProcessor     allCandidates: [ CatalogProvider default projects ];     title: 'Catalog Projects';     itemName: [:arg2 |  arg2 name ];     itemIcon: [:arg2 |  CatalogBrowser iconFor: arg2 ];     filter: GTFilterSubstring;     actLogic: [:arg2 |  arg1 exit.        (UIManager default confirm: 'Would you like to install ' , arg2 name , '?') ifTrue: [ arg2 installStableVersion.              UIManager inform: arg2 name , ' installed' ] ];     wantsToDisplayOnEmptyQuery: trueupperThreshold: arg1  upperThreshold := arg1executeAction  self codePresentation evaluateSelectionAndDo: [:arg1 |  self debugger inspect: arg1 ]addStep: arg1 during: arg2  self assert: arg1 isNotNil.  self assert: arg2 isNotNil.  self steps add: arg1.  arg2 ensure: [ self steps remove: arg1 ]addItems: arg1  self stream addObjects: arg1 inProcessor: self processorinitialize  super initialize.  self searchField: self newSearchField.  self class environment at: #GTEventRecorderSettings ifPresent: [ self settingsButton: self newSettingsButton ].  self helpButton: self newHelpButton.  self closeButton: self newCloseButtoninitialize  super initialize.  self     useVerticalLinearLayout;     labelBrick: self newLabelBrick;     triangleBrick: self newTriangleBrick;     enablelayout: arg1 in: arg2  ^super layout: arg1 in: arg2testArrays  self assert: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 51 51 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 81 81 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99) equals: #(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99)compose  | tmp1 |  tmp1 := self tabulator.  tmp1 row: #main.  tmp1 transmit     to: #main;     andShow: [:arg1 |  arg1 tabulator with: [:arg2 |  arg2 title: 'Variables'.              arg2 row: #variables.              arg2 transmit                 to: #variables port: #entity;                 andShow: [:arg3 |  self variablesIn: arg3 ].              arg2 transmit                 from: #variables port: #entity;                 to: #variables port: #selection;                 when: [:arg4 |  self debugger selectedVariableName notNil and: [ arg4 notNil ] ];                 transformed: [:arg4 |  self selectedVariableForContext: arg4 ].              arg2 transmit                 from: #variables;                 toOutsidePort: #selection;                 transformed: [:arg5 |  arg5 value ] ].        arg1 tabulator with: [:arg2 |  arg2 title: 'Evaluator'.              arg2 row: #evaluator.              arg2 transmit                 to: #evaluator;                 andShow: [:arg3 |  self contextEvaluatorIn: arg3 ].              arg2 transmit                 from: #evaluator;                 toOutsidePort: #selection ].        arg1 onChangeOfPort: #activePresentation act: [:arg6 |  (arg6 pane port: #activePresentation) value ifNotNil: [:arg7 |  self debugger cache at: #activePresentationTitle put: arg7 title ] ] ].  tmp1 transmit     from: #main;     toOutsidePort: #selectionlayoutAllowedTop: arg1  self     translate: arg1 by: (self deltaTop: arg1);     increaseZindex: arg1;     cutAllowedBoundsTop: arg1actOnPaneRemoved: arg1  self panes last presentations first updateToolbar.  self notifyPaneRemoved ifTrue: [ self debugger announce: arg1 ]onRemoveSelector: arg1  onRemoveSelector := arg1popUntil: arg1  [ self steps last = arg1 ] whileFalse: [ self popStep ]save: arg1  foundationOrigin  ^foundationOrigin ifNil: [ foundationOrigin := self ]handleFatalException: arg1  GTSpotterExceptionsTest fatals add: arg1privateProcessorLink: arg1  processorLink := arg1settingsButtonStyleFor: arg1  arg1     vSpaceFill;     width: [:arg2 |  arg2 height ];     margin: #(10 0);     marginRight: 2glmAnimateBrickBounds: arg1 duration: arg2 callback: arg3  self animation ifNotNil: #terminate.  animation := GLMAnimation new     linear;     duration: arg2;     from: self band brickBounds left;     to: self band brickBounds left + arg1;     onCompleted: arg3;     animation: [:arg4 :arg5 |  arg4 changedWith: [ arg4                 translateXTo: arg5 asInteger;                 data: arg4 brickBounds left ] ];     animate: self bandtransmitFromStackToCodeIn: arg1  arg1 transmit     from: #stack port: #selection;     to: #code;     andShow: [:arg2 :arg3 |  self methodCodeIn: arg2 forContext: arg3 ]category: arg1  category := arg1makeBasicInspect  shouldBasicInspect := truefileName  self subclassResponsibilitydeltaBottom: arg1  ^arg1 globalOuterBounds corner y - self allowedBounds corner yhostObject: arg1  self assert: [ hostObject isNil ] description: [ 'Host can be assigned only once' ].  hostObject := arg1toggleHints  (self hasSubbrick: self actionbarBrick) ifFalse: [ ^self ].  self stepModel spotter isShiftPressed ifTrue: [ self onRevealHints ] ifFalse: [ self onHideHints ]allFilteredCandidates  ^allFilteredCandidates ifNil: [ allFilteredCandidates := OrderedCollection new ]asArray  ^self items asArrayonAmountChanged: arg1 in: arg2  self assert: arg1 >= 0.  arg1 = 0 ifTrue: [ ^self ].  self announcer announce: (GTSpotterCandidatesAmountChanged new           amount: arg1;           category: arg2;           yourself)persistenceStrategies: arg1  persistenceStrategies := arg1actionbarBrick: arg1  actionbarBrick := arg1.  self actionbarBrick     vSpaceFill;     hShrinkWrapaddCategory: arg1  self assert: arg1 isNotNil.  self assert: arg1 hasOwner not.  self assert: arg1 hasSubbricks.  self band hasSubbricks ifFalse: [ self band addBrickBack: arg1 titleBrick.        self band addBrickBack: arg1 ] ifTrue: [ | tmp1 |        tmp1 := 2.        [ tmp1 <= self band subbricksCount and: [ (self band subbricks at: tmp1) order <= arg1 order ] ] whileTrue: [ tmp1 := tmp1 + 2 ].        tmp1 > self band subbricksCount ifTrue: [ self band addBrickBack: arg1 titleBrick.              self band addBrickBack: arg1 ] ifFalse: [ self band addBrick: arg1 titleBrick after: (self band subbricks at: tmp1).              self band addBrick: arg1 titleBrick after: arg1 titleBrick ] ]onThemerChanged  super onThemerChanged.  self band subbricks withIndexDo: [:arg1 :arg2 |  arg2 even ifTrue: [ self themer spotterThemer breadcrumbSeparatorWidgetStyleFor: arg1 ] ]newEmptyText  ^GLMLabelBrick new     text: 'No saved pages';     hSpaceFill;     textPosition: #center;     padding: self themer bindingThemer emptyTextPadding;     textColor: self themer bindingThemer emptyTextColor;     fontSize: self themer bindingThemer emptyTextFontSize;     yourselfslot: arg1  self assert: [ arg1 isNotNil ] description: [ 'Slot can not be nil' ].  slot := arg1defaultCandidatesLimit  ^self defaultItemsLimitdefaultIcon  ^GLMUIThemeExtraIcons glamorousHelpassertDebuggerInitializationForContext: arg1 andStepBlock: arg2  self initializeSessionForContext: arg1 withStepBlock: arg2.  self assertDebuggerInitializationgtInspectorUsersIn: arg1  < gtInspectorPresentationOrder: 1>  arg1 list     title: 'Users';     display: [ self users sorted: [:arg2 :arg3 |  arg2 selector < arg3 selector ] ];     format: #gtDisplayStringpreviewBrick  ^previewBrickspotterModel  ^spotterModelcompose  self title: 'Tree'.  self tabulator with: [:arg1 |  arg1           row: #tree;           row: #source.        arg1 transmit           to: #tree;           andShow: [:arg2 |  self treeIn: arg2 ].        arg1 transmit           to: #source;           andShow: [:arg2 |  self sourceIn: arg2 ].        arg1 transmit           from: #tree;           to: #source port: #selectionInterval;           transformed: [:arg3 |  arg3 sourceInterval ].        arg1 transmit           toOutsidePort: #selection;           from: #tree port: #selectedNode ]stepModel  ^stepModelshouldFilterInContext: arg1  ^arg1 notEmpty or: [ self wantsToDisplayOnEmptyQuery ]send  self session stepInto: self currentContext.  self updateBrowserborder: arg1  border := arg1initialize  super initialize.  self filteredItems: self defaultFilteredItemsanySatisfy: arg1  self do: [:arg2 |  (arg1 value: arg2) ifTrue: [ ^true ] ].  ^falsespotterModel: arg1  spotterModel := arg1.  spotterModel steps do: [:arg2 |  self pushPane: (self buildPane: arg2) ].  spotterModel announcer when: GTSpotterStepAdded send: #onStepAdded: to: selfspotterDirtyMonticelloPackagesFor: arg1  < spotterOrder: 85>  arg1 listProcessor     allCandidates: [ MCWorkingCopy allManagers select: #modified ];     title: 'Dirty Monticello packages';     itemIcon: [ Smalltalk ui icons iconNamed: #dirtyPackageIcon ];     filter: self defaultFilterClass;     wantsToDisplayOnEmptyQuery: truenotifySelected  self stepModel spotter announce: (GTSpotterCandidateSelected new itemBrick: self).  self stepModel announcer announce: (GTSpotterCandidateSelected new itemBrick: self)candidateLink  ^candidateLinkprivateAddCandidate: arg1 inEmpty: arg2  | tmp1 tmp2 |  tmp2 := arg2.  tmp1 := nil.  [ tmp1 isNil and: [ tmp2 isNotNil ] ] whileTrue: [ tmp2 := tmp2 nextLink.        tmp2 ifNotNil: [ tmp1 := tmp2 headLink ] ifNil: [ nil ] ].  tmp2 ifNil: [ self candidates addLast: arg1 ] ifNotNil: [ self candidates add: arg1 beforeLink: tmp1 ].  arg2     headLink: arg1;     tailLink: arg1.  arg2 incrementSize.  ^arg1isFullyVisible: arg1  ^self allowedBounds containsRect: arg1 globalOuterBoundsstep  self window ifNil: [ ^self ].  self window isActive ifFalse: [ ^self ].  self wantsAutomaticRefresh ifTrue: [ self requestRefresh ]initialize  super initialize.  self enable.  self themer spotterThemer itemNormalStyleFor: self.  self iconBrick: self newIconBrick.  self labelBrick: self newLabelBrick.  self actionbarBrick: self newActionbarBrickonHovered  self showActionbarhandleException: arg1 do: arg2  arg1 pass.  ^super handleException: arg1 do: arg2tagsFrom: arg1  ^(arg1 pragmas select: [:arg2 |  arg2 key == self tagPragmaKey ]) ifEmpty: [ defaultTag ifNil: [ {} ] ifNotNil: [ {defaultTag} ] ] ifNotEmpty: [:arg3 |  arg3 collect: [:arg2 |  arg2 argumentAt: 1 ] ]step: arg1  step := arg1debuggerStructureIn: arg1  arg1     row: #stack;     row: [:arg2 |  arg2           column: #code;           column: #bytecode ] span: 2;     row: #inspectorassertDiveIn: arg1  | tmp1 tmp2 |  tmp1 := spotter steps size.  previousStep := spotter currentStep.  tmp2 := spotter currentStep candidates getCandidateLink: currentCandidate in: currentProcessor.  self assert: tmp2 notNil.  self assert: tmp2 candidate identicalTo: currentCandidate.  self assert: tmp2 processor identicalTo: currentProcessor.  self shouldnt: [ spotter currentStep select: tmp2 ] raise: Error.  self assert: spotter currentStep selected identicalTo: tmp2.  self shouldnt: [ spotter currentStep perform: arg1 ] raise: Error.  currentStep := spotter currentStep.  currentProcessor := currentCandidate := previousContext := currentContext := nil.  self denyEmpty: spotter steps.  self assert: spotter steps size > tmp1.  self assert: spotter steps size equals: tmp1 + 1.  self deny: previousStep equals: currentStep.  self deny: previousStep equals: spotter currentStep.  self assert: currentStep equals: spotter currentStepprocessor: arg1  processor := arg1executeAction  self debugger updateSelectionIntervaldoFilter: arg1 forProcessor: arg2  self processor: arg2.  self filter: arg1.  self streamed: (OrderedCollection new: 100).  (self cache at: #processorsAndFilters) at: arg2 put: arg1.  (self cache at: #processorsAndStreamed) at: arg2 put: streamed.  ^arg1 value: selfitemsLimit  ^self context itemsLimitgetProcessorLink: arg1  ^self processorLinksMap at: arg1 ifAbsentPut: [ self addProcessor: arg1 ]breadcrumbItemTriangleWidgetStyleFor: arg1  arg1 renderer: (GTSpotterTriangleRenderer new orientation: #bottom).  arg1 owner isTriangleVisible ifTrue: [ arg1 color: self breadcrumbItemBackgroundColor ] ifFalse: [ arg1 color: Color transparent ]removeAllCandidates  self processors linksDo: [:arg1 |  arg1 clear ].  self candidates removeAll.  self notifyAllCandidatesRemovedgtPagesIn: arg1  < gtInspectorPresentationOrder: 0>  arg1 list     title: 'Pages';     display: [ self pages ];     format: #gtDisplayString;     filterOn: [:arg2 :arg3 |  arg2 match: arg3 content ]updateBrowser  super updateBrowser.  ((self browser paneNamed: #stack) port: #selection) value: self session interruptedContextprevious: arg1  previous := arg1removePage: arg1  self pages remove: arg1 ifAbsent: [  ]pageActionsIn: arg1  self pageActions do: [:arg2 |  arg1 addAction: arg2 ]element  ^elementonHideHints  (self hasSubbrick: self actionbarBrick) ifFalse: [ ^self ].  self themer spotterThemer hintHideStyleFor: self diveInButtonbuttonPressedColor  ^self backgroundColor darkerhelp  ^'Save the current method.'defaultOrder  ^15isActive  ^self isActive: self testContextsave  persistenceStrategies do: [:arg1 |  arg1 save ]newRow  ^GLMInteractableBrick new     enable;     enableDoubleClick;     selectedColor: self themer bindingThemer selectedColor;     vShrinkWrap;     hSpaceFill;     padding: self themer bindingThemer padding;     paddingRight: 0listProcessor  | tmp1 |  tmp1 := GTSpotterCandidatesListProcessor new.  self addProcessor: tmp1.  ^tmp1pragma: arg1 of: arg2  ^arg2 pragmas detect: [:arg3 |  arg3 selector = arg1 ] ifNone: [ nil ]inspectorIn: arg1 on: arg2  ^arg2 gtConstructDebuggerInspectorIn: arg1 for: selfspotter: arg1  spotter := arg1addAndSelectAllSignatures  self allPresentationMethods do: [:arg1 |  self addAndSelectSignatureFor: arg1 ]newActionButton  | tmp1 tmp2 |  tmp1 := self themer bindingThemer padding + self themer bindingThemer borderWidth.  tmp2 := (tmp1 / 2) rounded.  ^GLMHintableActionButtonBrick new     padding: tmp2;     visible: false;     margin: {0 .         tmp2};     hShrinkWrap;     vAlign: #center;     pressedColor: self themer buttonPressedColorhasCandidates  < return: #Boolean>  ^self candidates isNotEmptyfilterByMethods: arg1  | tmp1 |  tmp1 := GTSpotterMethodListProcessorFilter new.  arg1 do: [:arg2 |  tmp1 allowProcessorsFrom: arg2 ].  self processorsFilter: tmp1processor  ^self processorLink valuegenerateCacheFor: arg1  | tmp1 |  tmp1 := OrderedDictionary new.  (self basicVariableNodesFor: arg1) do: [:arg2 |  tmp1 at: arg2 key put: (self generateHashFor: arg2 value) ].  ^tmp1methodCodeWidgetIn: arg1 forContext: arg2  ^arg1 pharoMethod     title: 'Source';     format: [ arg2 sourceCode ];     smalltalkClass: [ arg2 methodClass ];     doItReceiver: [ arg2 receiver ];     doItContext: [ arg2 ];     with: [:arg3 |  self installBindingsForDoItIn: arg3 from: arg2 ]newActionButton  | tmp1 tmp2 |  tmp1 := self themer bindingThemer padding + self themer bindingThemer borderWidth.  tmp2 := (tmp1 / 2) rounded.  ^GLMHintableActionButtonBrick new     padding: tmp2;     visible: false;     margin: {0 .         tmp2};     marginRight: tmp1;     hShrinkWrap;     vAlign: #center;     pressedColor: self themer buttonPressedColorupdateOuterPaneFrom: arg1 for: arg2  | tmp1 tmp2 |  tmp2 := arg2 methodClass compile: arg1 text notifying: nil.  tmp1 := arg1 pane browser pane.  tmp1 browser panes do: #update.  self flag: 'This is a huge hack because of so many reasons:				- the presentation accesses the state of the outer browser directly				- the presentation depends on the implementation of the browser 				It should be solved through transmissions.								But, it works for now and the browser is reasonably updated'.  ^tmp1 withAllPanesAndPresentationsDo: [:arg3 |  (arg3 isKindOf: self class) ifTrue: [ ((arg3 first paneNamed: #classes) port: #selection) value: arg2 methodClass.              ((arg3 first paneNamed: #methods) port: #selection) value: ((arg3 first paneNamed: #methods) presentations first displayedValue ifNotNil: [:arg4 |  arg4 detect: [:arg5 |  arg5 selector = tmp2 ] ]) ] ]newDropDownMorph  ^GTSpotterDropDownMorph newactionbarBrick  ^actionbarBrickvisible: arg1  super visible: arg1.  self toggleHints> arg1  ^self weight > arg1 weightspotterModel: arg1  spotterModel := arg1.  self spotterModel announcer when: GTSpotterCandidateSelected send: #onCandidateSelected: to: self.  self spotterModel announcer when: GTSpotterCandidateSelectedMoved send: #onCandidateMoved to: self.  self spotterModel announcer when: GTSpotterStepAdded send: #onStepAdded to: self.  self spotterModel announcer when: GTSpotterShowPreview send: #onShowPreview to: self.  self spotterModel announcer when: GTSpotterHidePreview send: #onHidePreview to: self.  self spotterModel announcer when: GTSpotterRevealHints send: #onRevealHints to: self.  self spotterModel announcer when: GTSpotterHideHints send: #onHideHints to: selfinitializeWindow: arg1  arg1     whenClosedDo: [ debugger ifNotNil: #windowIsClosing ];     initialExtent: 700 @ 180settingsButton: arg1  settingsButton ifNotNil: [ self removeBrick: settingsButton ].  settingsButton := arg1.  self themer spotterThemer settingsButtonWidgetStyleFor: settingsButton.  self themer spotterThemer settingsButtonStyleFor: settingsButton.  settingsButton     hintTitle: 'Settings';     hintText: 'Shows the settings UI';     action: [ self openSettingsBrowser ].  self addBrickBack: settingsButtonremoveAllCandidatesOf: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self getProcessorLink: arg1.  tmp1 isEmpty ifTrue: [ ^self ].  tmp2 := tmp1 headLink.  tmp3 := tmp1 tailLink.  tmp2 = tmp3 ifTrue: [ self candidates removeCycledLink: tmp2.        tmp1 clear ].  tmp4 := tmp2.  [ tmp4 = tmp3 ] whileFalse: [ | tmp5 |        tmp5 := tmp4 nextLink.        self candidates removeCycledLink: tmp4.        tmp4 := tmp5 ].  self candidates removeCycledLink: tmp4.  tmp1 clearhasFilteredItems  ^self filteredItems isEmptyOrNil notitemSelectedBackgroundColor  ^self backgroundColor slightlyDarkerclipSubmorphs  ^truecontextMenuActions  ^(Pragma allNamed: self contextMenuPragma from: self class class to: Object class) flatCollect: [:arg1 |  self class perform: arg1 methodSelector with: self ]itemFilterName  ^itemFilterNameBlocknewContext  ^newContexttestResetBindings  | tmp1 |  window := playground openOn: (GTPlayPage new saveContent: 'number+1').  playground setBindings: {(#number -> 2)} asDictionary.  tmp1 := playground currentBindings.  self assert: tmp1 size equals: 1.  playground resetBindings.  tmp1 := playground currentBindings.  self assert: tmp1 size equals: 0triangleBrick  ^triangleBrickquery: arg1  query := arg1context  ^contextmatches: arg1  ^result := self matchContext: arg1previewArrowGapHack  ^self themer scrollbarOffset + self themer scrollbarWidth + self outerBorderWidth + 1testSimpleFailingAssestion  self assert: falsesetUp  super setUp.  spotter := GTMockSpotter new     exceptionHandler: GTSpotterDebuggingExceptionHandler new;     yourselfrunToBytecode: arg1 inContext: arg2  arg1 offset <= arg2 pc ifTrue: [ ^self ].  self stepOver: arg2.  [ arg2 == self interruptedContext and: [ arg2 pc < arg1 offset ] ] whileTrue: [ self stepOver: arg2 ]newArrowBrick  ^GTSpotterPreviewArrowBrick newouterBorderWidth  ^4hasMatched  ^self result ifNil: [ ^false ]result  ^resultplaygroundActions  ^(Pragma allNamed: self playgroundActionPragma from: self class to: Object sortedByArgument: 1) collect: [:arg1 |  self perform: arg1 methodSelector ]testDeploymentExceptionHandlerDuring  | tmp1 |  self exceptionHandler: (tmp1 := GTSpotterDeploymentExceptionHandlerMock new) do: [ self shouldnt: [ GTCurrentSpotterExceptionHandler value ] raise: Error.        self assert: GTCurrentSpotterExceptionHandler value notNil.        self assert: GTCurrentSpotterExceptionHandler value identicalTo: tmp1 ]incrementSize  size := self size + 1setUp  super setUp.  42 messageThatIsNotUnderstoodonLayouted  super onLayouted.  self isChecked ifTrue: [ self stepModel spotter announce: GTSpotterCandidateSelectedMoved new ]categoryStyleFor: arg1  arg1     marginBottom: self categoryMarginBottom;     hSpaceFillpage: arg1  page := arg1computeCandidatesIn: arg1  ^self computeAllItemsIn: arg1itemFilterNameFor: arg1  ^self processor itemFilterNameFor: arg1pragmas: arg1 inPackages: arg2  | tmp1 |  tmp1 := OrderedCollection new.  RPackageOrganizer default packages do: [:arg3 |  arg2 do: [:arg4 |  arg3 packageName = arg4 ifTrue: [ arg3 methods do: [:arg5 |  arg5 methodClass isTrait ifFalse: [ (arg5 pragmas detect: [:arg6 |  arg6 selector = arg1 ] ifNone: [ nil ]) ifNotNil: [:arg6 |  tmp1 add: arg6 ] ] ] ] ] ].  ^tmp1creationTimeForFileName  ^(self creationTime asString copyReplaceAll: ':' with: '-') copyReplaceAll: '.' with: '-'isFullyVisible: arg1 in: arg2  ^arg2 containsRect: arg1 globalOuterBoundsinitializeTestContextFrom: arg1  testContext := arg1 findContextSuchThat: [:arg2 |  arg2 method isTestMethod ].  testContext ifNil: [ testContext := arg1 findContextSuchThat: [:arg2 |  arg2 receiver class isTestCase ] ].  testContext ifNil: [ testContext := arg1 ]itemActionSelectedBackgroundColor  ^self itemSelectedBackgroundColor slightlyDarkertestEmptyTextInput  self assertText: Text new do: [ self assert: spotter text isEmpty ].  self assertText: (Text fromString: '') do: [ self assert: spotter text isEmpty ].  self assertText: '' do: [ self assert: spotter text isEmpty ].  self flag: 'currently: nil is converted to the string "nil"'defaultPages  ^OrderedCollection newmockProcessorFor: arg1  < spotterOrder: 1>  self assert: GTCurrentSpotterExceptionHandler value notNil.  self assert: GTCurrentSpotterExceptionHandler value == arg1 spotter exceptionHandler.  arg1 listProcessor     allCandidates: [ self assert: GTCurrentSpotterExceptionHandler value notNil.        self assert: GTCurrentSpotterExceptionHandler value == arg1 spotter exceptionHandler.        #(1 2 3) ];     itemName: [:arg2 |  self assert: GTCurrentSpotterExceptionHandler value notNil.        self assert: GTCurrentSpotterExceptionHandler value == arg1 spotter exceptionHandler.        arg2 asString ];     filter: GTSpotterExceptionMock5Filterhead  ^self candidates headhasMultipleSteps  ^self steps size > 1searchFieldWidgetStyleFor: arg1  arg1 morph     color: Color transparent;     textColor: self searchFieldTextColor;     borderColor: Color transparent.  arg1 morph textArea backgroundColor: Color transparentdoApplyFilterWithQuery  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := OrderedCollection new.  tmp2 := OrderedCollection new.  tmp3 := OrderedCollection new.  self allItemsDo: [:arg1 |  | tmp5 tmp6 tmp7 |        tmp7 := self itemFilterNameFor: arg1.        tmp6 := self queryForItem: arg1.        tmp5 := self indexForItemName: tmp7 andQuery: tmp6.        tmp5 >= 1 ifTrue: [ tmp5 = 1 ifTrue: [ tmp7 size = tmp6 size ifTrue: [ tmp1 add: arg1.                          self addItem: arg1.                          tmp1 size = self itemsLimit ifTrue: [ self filteredItems: tmp1.                                GTLimitArrived signal ] ] ifFalse: [ tmp2 add: arg1 ] ] ifFalse: [ tmp3 add: arg1 ] ] ].  tmp4 := tmp2 , tmp3.  tmp1 size < self itemsLimit ifTrue: [ | tmp8 |        tmp8 := tmp4 first: (self itemsLimit - tmp1 size min: tmp4 size).        self addItems: tmp8 ].  self filteredItems: tmp1 , tmp4showActionbar  self shouldShowActionbar ifFalse: [ ^self ].  self actionbarBrick visible: trueselectTopContext  ((self browser paneNamed: #stack) port: #selection) value: self interruptedContextnotEmpty  ^self isEmpty notspotterGhostText  ^'Search'tearDown  debugger ifNotNil: [ debugger close ].  window := nil.  debugger := nil.  session := nil.  super tearDowntailLink  ^tailLinkdebugAction  ^debugActionHolder valuebackgroundColor  ^Smalltalk ui theme lightBackgroundColor slightlyLighterpresentationFilter: arg1  self assert: [ arg1 isNotNil ] description: [ 'Presentation filter must not be nil' ].  presentationFilter := arg1bytecodePane  ^self browser paneNamed: #bytecoderefreshPanes  self panes do: [:arg1 |  arg1 updateToolbar.        arg1 presentations presentations first withAllPresentations do: [:arg2 |  arg2 wantsAutomaticRefresh ifTrue: [ arg2 requestRefresh ] ] ]initialize  super initialize.  self needsUpdate: falseasSet  ^self items asSetsubclassesOf: arg1 filterBySubstring: arg2 inPackage: arg3  ^(self subclassesOf: arg1 inPackage: arg3) select: [:arg4 |  arg4 name includesSubstring: arg2 caseSensitive: false ]shrinkTop: arg1 with: arg2  ^arg1 top: arg1 top + arg2 globalOuterBounds heightexecuteAction  self codePresentation evaluateSelectiondetect: arg1 ifFound: arg2 ifNone: arg3  self do: [:arg4 |  arg1 value ifTrue: [ ^arg2 value: arg4 ] ].  ^arg3 valuedefaultPagerModel  ^GLMMockPagerModel newrebuildCacheFor: arg1  cachedHashes := self generateCacheFor: arg1keyBinding  ^keyBindingkey  ^'self'actOn: arg1 for: arg2  actBlock ifNil: [ super actOn: arg1 for: arg2 ] ifNotNil: [ actBlock cull: arg1 cull: arg2 ]categoryTitleShortcutStyleFor: arg1  arg1     vSpaceFill;     textPosition: #leftCenter;     textColor: self titleTextColor.  arg1 label familyName: 'Lucida Grande'defaultCache  ^IdentityDictionary new     at: #processorsAndFilters put: (IdentityDictionary new: 100);     at: #processorsAndStreamed put: (IdentityDictionary new: 100);     yourselfspotterWindowsFor: arg1  < spotterOrder: 5>  arg1 listProcessor     title: 'Windows';     candidatesLimit: 10;     allCandidates: [ (self currentWorld submorphs select: [:arg2 |  arg2 isKindOf: SystemWindow ]) allButFirst ];     itemName: [:arg2 |  '{1} [{2}]' format: {arg2 label .               arg2 className} ];     itemIcon: [:arg2 |  arg2 taskbarIcon ];     sort: [:arg3 :arg4 |  arg3 label < arg4 label ];     filter: GTFilterSubstring;     wantsToDisplayOnEmptyQuery: truetestInspectDoesNotCrash  window := GTInspector openOn: ProtoObject newborderColor  ^borderColorinitializeAssestionContextFrom: arg1  | tmp1 |  tmp1 := {TestCase .   TestCase superclass}.  assertionContext := arg1 findContextSuchThat: [:arg2 |  arg2 = testContext ifTrue: [ ^self ].        arg2 sender notNil and: [ (tmp1 anySatisfy: [:arg3 |  arg3 includesMethod: arg2 sender method ]) not ] ].  assertionContext ifNotNil: [ assertionCallerContext := name = 'Halt' ifTrue: [ assertionContext ] ifFalse: [ assertionContext sender ] ]newSeparator  ^GLMBrick newprocess: arg1  (self context matches: arg1) ifTrue: [ ^self ].  self context: (self newContextForQuery: arg1).  self stream updateTimestamp.  self asyncTask execute: [:arg2 |  self spotter notifyContextChangedFrom: lastSearchContext to: self context.        self processContext: arg2 ] withArguments: {self context} callback: [ lastSearchContext := self context.        self spotter notifySearchFinishedFor: arg1 processors: self processors ] delay: 200spotter  ^self step spotteronRemovedFrom: arg1  super onRemovedFrom: arg1.  self stepModel ifNotNil: [ self stepModel announcer unsubscribe: self.        self stepModel spotter announcer unsubscribe: self ]assortCandidatesSize: arg1  executeAction  self needsUpdate: false.  self codePresentation hasUnacceptedEdits ifTrue: [ self codePresentation compileTextIn: self currentContext from: self session andDo: [ self needsUpdate: true ] ].  self codePresentation flashshouldntRaise: arg1 process: arg2 origin: arg3  self shouldntRaise: arg1 process: arg2 origin: arg3 during: GTSpotterDeploymentExceptionHandlerMock newhelp  ^'Open an help browser for the currently active debugger.'category  self assert: category isNotNil.  ^categoryspotterForGlobalVarsFor: arg1  < spotterOrder: 40>  arg1 listProcessor     allCandidates: [ Smalltalk globals associations select: [:arg2 |  arg2 value isBehavior not and: [ arg2 value isTrait not ] ] ];     title: 'Global variables';     itemName: [:arg3 |  arg3 key ];     filter: self defaultFilterClass;     wantsToDisplayOnEmptyQuery: falsecurrent: arg1  current := arg1keymapToggleDebug  < shortcut>  ^KMKeymap shortcut: Character cr command shift action: [ self class openGlobalSpotterDebug ]initialize  super initialize.  self triangleBrick: self newTriangleBrickbreadcrumbStyleFor: arg1  arg1     margin: {0 .         0};     marginBottom: self breadcrumbTriangleHeight negated;     height: self breadcrumbHeight + self breadcrumbTriangleHeight.  arg1 layout zIndex: 2doContinueFilterForProcessor: arg1  self processor: arg1.  self filter: ((self cache at: #processorsAndFilters) at: arg1).  self streamed: ((self cache at: #processorsAndStreamed) at: arg1).  ^arg1 withItemsLimit: arg1 continueItemsLimit do: [ filter value: self ]step  ^self context stepnewStep  ^self defaultStep spotter: selflabel: arg1  label := arg1updateTimestamp  self timestamp: Time microsecondClockValueprocessorsFilter: arg1  processorsFilter := arg1privacyAgreementIsNotSendingDataColor  ^Color paleRedasSpotterCandidateLink  ^selfdefaultKeymap  ^PharoShortcuts current printItShortcutallowedBounds: arg1  allowedBounds := arg1spotterForPragmasFor: arg1  < spotterOrder: 40>  arg1 listProcessor     allCandidates: [ Pragma allInstances collect: [:arg2 |  arg2 selector ] as: Set ];     title: 'Pragmas';     itemName: [:arg3 |  arg3 ];     filter: self defaultFilterClass;     wantsToDisplayOnEmptyQuery: falseallTags  ^(self allPragmasWithTag collect: [:arg1 |  arg1 argumentAt: 1 ]) asSet sorted: [:arg2 :arg3 |  arg2 < arg3 ]addActActionButton  actOnButton := self newActionButtonBrick     icon: self themer spotterThemer iconAct;     hintTitle: 'Default action';     hintText: '<enter>';     action: [ self owner beSelected.        self stepModel actDueTo: #actionButton ];     yourself.  self addActionButton: actOnButtonnewBindingRow: arg1 in: arg2  ^self newRow     borderWidth: {0 .         0 .         (arg2 last == arg1 ifTrue: [ 0 ] ifFalse: [ self themer bindingThemer borderWidth ]) .         0};     addAllBricks: {(self newBindingLabel           textColor: self themer textLightColor;           text: arg1 key) .         (self newBindingLabel text: arg1 value asString) .         (self newInspectButtonFor: arg1) .         (self newGoButtonFor: arg1) .         (self newRemoveButtonFor: arg1)};     with: [:arg3 |  arg3           when: #onMouseHover do: [ self showActionsOf: arg3 ];           when: #onMouseUnhover do: [ self hideActionsOf: arg3 ] ];     yourselfbreadcrumbBrick  ^breadcrumbBrickonStepAdded  self selectedItemBrick: nil.  self spotterModel steps last candidates announcer when: GTSpotterAllCandidatesRemoved send: #onAllCandidatesRemoved to: selfgtFilter  ^selfid  ^GTSUnitDebuggerJumpToTestAction nametestDevelopmentHandleException  self assertResetExceptions.  self should: [ [ 1 / 0 ] on: ZeroDivide do: [:arg1 |  GTSpotterDebuggingExceptionHandlerMock new handleException: arg1 ] ] raise: ZeroDivide.  self assertException: ZeroDividebrowseSendersOfMessages  self currentMessageName ifNotNil: [ self systemNavigation browseAllSendersOf: self currentMessageName ]spotterModel: arg1  spotterModel := arg1.  arg1 announcer when: GTSpotterSelectedCandidateChanged send: #onCandidateSelected: to: self.  arg1 announcer when: GTSpotterStepPopped send: #onStepPopped to: self.  arg1 announcer when: GTSpotterStepAdded send: #onStepAdded to: self.  arg1 announcer when: GTSpotterSearchFinished send: #onSearchFinished to: selfdefaultCategory  ^'Available Debuggers'defaultLabel  ^'Spotter'assertProcessorIncludesAll: arg1  self assert: arg1 notEmpty.  self assert: currentProcessor notNil.  self assert: currentProcessor allFilteredCandidates notEmpty.  arg1 do: [:arg2 |  self assert: (currentProcessor allFilteredCandidates anySatisfy: [:arg3 |  arg3 = arg2 ]) ]testDeploymentHandleExceptionMock5  self assertResetExceptions.  self shouldnt: [ [ 1 / 0 ] on: ZeroDivide do: [:arg1 |  self assert: (GTSpotterDeploymentExceptionHandlerMock5 new handleException: arg1 do: [ 7 ]) identicalTo: 7 ] ] raise: ZeroDivide.  self assertException: ZeroDividefirstPresentation  ^self panes first presentations firstselect: arg1  ^self select: arg1 as: self defaultItemsClassisEmpty  ^self items isEmptydefaultExceptionHandler  ^GTSpotterDeploymentExceptionHandler newprintOn: arg1  arg1 nextPutAll: self keywordeventType: arg1  eventType := arg1spotterForReferencesFor: arg1  < spotterOrder: 32>  arg1 listProcessor     title: 'References';     filter: GTNullFilter item: [:arg2 :arg3 |  self class environment at: arg3 textTrimmed ifPresent: [:arg4 |  SystemNavigation default allReferencesTo: arg4 binding do: arg2 ] ];     keyBinding: $n shift meta;     itemName: [:arg5 |  arg5 gtDisplayString ]mockProcessorFor: arg1  < spotterOrder: 1>  arg1 listProcessor     allCandidates: [ #(1 2 3) ];     itemName: [:arg2 |  arg2 asString ];     filter: GTSpotterExceptionMock4FilterinstallBindingsForDoItIn: arg1 from: arg2  (arg2 notNil and: [ arg2 method isDoIt and: [ arg2 receiver isNil ] ]) ifTrue: [ arg1 variableBindings: arg2 gtDebuggerDoItBindings ]page  ^pagescrollpaneBackgroundColor  ^self spotterThemer backgroundColorinitializeWidgets  self preDebuggingActions do: [:arg1 |  self presenterAt: arg1 id asSymbol put: (self buttonFor: arg1) ].  self presentersDo: [:arg2 |  self focusOrder add: arg2 ]itemFilterName: arg1  itemFilterNameBlock := arg1goIcon  ^GLMUIThemeExtraIcons glamorousGoexecute: arg1 withArguments: arg2 callback: arg3 priority: arg4 delay: arg5  arg1 valueWithPossibleArgs: arg2.  arg2 valuegatherStacked: arg1  | tmp1 |  tmp1 := DoubleLinkedList new.  arg1 subbricks do: [:arg2 |  arg2 layoutProperties floating = #stack ifTrue: [ tmp1 add: arg2 ] ].  ^tmp1buildVariablesFromContext: arg1  ^arg1 gtDebuggerRetrieveVariableValuePairsexit  self exitDueTo: #unknownprepareProcessorInContext: arg1  allFilteredCandidates := nilisActive: arg1  ^arg1 ifNil: [ false ] ifNotNil: [ arg1 isDead not and: [ arg1 ~= self process suspendedContext or: [ arg1 willReturn not ] ] ]breadcrumbItemLabelWidgetStyleFor: arg1  arg1     color: self breadcrumbItemBackgroundColor;     textColor: self breadcrumbItemTextColorreceiver  ^self debuggerdefaultStep  ^GTMockSpotterStep newsearchFieldMarginLeft  ^20gtIterator  ^selftestInstanceCreationSmokeTest  self shouldnt: [ spotter := GTMockSpotter new ] raise: ErrorresultsPaneWidth  ^100gtDisplaySpotterMorphOn: arg1  < gtInspectorPresentationOrder: 50>  arg1 morph     title: 'Live';     display: [ GLMBrick new           hSpaceFill;           vSpaceFill;           addMorphBack: (GTSpotterMorph new spotterModel: self);           yourself ]itemIcon  ^itemIconBlockkey  ^self slot nameinitialize  super initialize.  cache := self defaultCache.  text := self defaultText.  continuing := self defaultContinuinginitialize  super initialize.  self needsUpdate: falsedoApplyFilterWithQuery  | tmp1 |  tmp1 := OrderedCollection new.  self allItemsDo: [:arg1 |  (self isMatchedItem: arg1) ifTrue: [ tmp1 add: arg1.              self addItem: arg1.              tmp1 size = self itemsLimit ifTrue: [ GTLimitArrived signal ] ] ].  self filteredItems: tmp1titleTextColor  ^self themer textLightColormethodsIn: arg1  ^arg1 list     title: 'Methods';     display: [:arg2 :arg3 |  arg3 methods collect: #asRingDefinition ];     filterOn: [:arg4 :arg5 |  arg4 , '*' match: arg5 selector ];     helpMessage: 'Wildcard filtering (e.g., "*pattern*")';     tags: [:arg6 |  arg6 category ];     sorted: [:arg7 :arg8 |  arg7 selector < arg8 selector ];     format: [:arg6 |  arg6 selector ];     morphicSelectionAct: [:arg9 :arg2 :arg3 |  Smalltalk tools browser openOnClass: arg3 selector: arg9 selection selector ] icon: GLMUIThemeExtraIcons glamorousBrowse on: $b entitled: 'Browse';     dynamicActionsOnSelection: [:arg9 |  self methodActionsFor: arg9 selection ]tearDown  a := nil.  super tearDowndetect: arg1 ifNone: arg2  ^self detect: arg1 ifFound: [:arg3 |  arg3 ] ifNone: arg2pushStep: arg1  self addStep: arg1.  self currentStep: arg1assertNoExceptions  self assertEmpty: self class exceptions.  self assertEmpty: self class fatalsopenSettingsBrowser  GLMPrivacyAgreementBrick openSettingsBrowser.  self spotterModel exitDueTo: #openSettingsBrowserbrowseMessages  self currentMessageName ifNotNil: [ self systemNavigation browseAllImplementorsOf: self currentMessageName ]removeCacheAt: arg1  ^self cache removeKey: arg1 ifAbsent: [ nil ]isEmpty  ^self text isNil or: [ self textTrimmed isEmpty ]diveInDueTo: arg1  self spotterModelDo: [:arg2 |  arg2 hasSelected ifTrue: [ arg2 currentStep diveInDueTo: arg1 ] ]highlightQuery  self labelBrick label highlight: self stepModel context textshiftPressed: arg1  self isShiftPressed = arg1 ifTrue: [ ^self ].  isShiftPressed := arg1.  self isShiftPressed ifTrue: [ self notifyRevealHints ] ifFalse: [ self notifyHideHints ]allPresentationMethods  ^(PragmaCollector allSystemPragmas select: [:arg1 |  arg1 key == self inspectorPragmaKey ]) collect: [:arg2 |  arg2 method ]previousProcessorFrom: arg1  arg1 do: [:arg2 |  arg2 asSpotterCandidateLink processor ifNotNil: [ ^arg2 processor ] ].  ^GTSpotterCandidatesListProcessor new     title: 'Items';     filter: GTFilterSubstring;     yourselfspotterUsersFor: arg1  < spotterOrder: 50>  ^arg1 listProcessor     title: 'Senders';     filter: GTFilterSubstring item: [:arg2 :arg3 |  self senders do: [:arg4 |  arg2 value: arg4 compiledMethod ] ];     keyBinding: $n metastepScrollPageUp  self spotterModel currentStep announcer announce: GTSpotterScrollPageUp newtestDebuggingExceptionHandlerMock5  self assertResetExceptions.  self shouldntRaise: AssertionFailure process: 'abc' origin: GTSpotterExceptionMock5 new during: GTSpotterDebuggingExceptionHandlerMock new.  self assertNoExceptionspreviousText  ^self previous ifNil: [ '' ] ifNotNil: [ self previous text ]asGlamourAction  | tmp1 |  tmp1 := glamourAction action.  ^glamourAction action: [:arg1 :arg2 |  self precondition ifTrue: [ self preAction.              tmp1 cull: arg1 cull: arg2.              self postAction ] ]restoreSettings  | tmp1 tmp2 |  tmp2 := self debugger cache at: #activePresentationTitle ifAbsent: [ ^self ].  tmp1 := self presentations first paneNamed: #main.  tmp1 presentations presentations detect: [:arg1 |  arg1 title = tmp2 ] ifFound: [:arg2 |  tmp1 lastActivePresentation: arg2 ]contextMenuPragma  ^#playgroundContextMenuactOnBrowserClosing: arg1  self entity saveContent: self first panes first presentations first text.  GTPlayBook instance addPageIfInteresting: self entityactLogic  ^actBlockdefaultLabel  ^'Jump to test method'classesIn: arg1  ^arg1 fastList     title: 'Class Hierarchy';     display: [:arg2 |  | tmp1 |        tmp1 := OrderedCollection new.        arg2 class withAllSuperclassesDo: [:arg3 |  tmp1 add: arg3 ].        tmp1 ];     format: [:arg4 |  arg4 name ];     enableFilter;     morphicSelectionAct: [:arg5 |  Smalltalk tools browser openOnClass: arg5 selection ] icon: GLMUIThemeExtraIcons glamorousBrowse on: $b entitled: 'Browse'formatBytecode: arg1  | tmp1 |  tmp1 := {(TextColor new color: self theme textColor)}.  self selectedContext pc = arg1 offset ifTrue: [ tmp1 := {(TextColor new color: self theme textColor) .         TextEmphasis italic} ].  self selectedContext pc > arg1 offset ifTrue: [ tmp1 := {(TextColor new color: Color gray)} ].  ^Text string: arg1 printString attributes: tmp1renderTriangle: arg1 on: arg2 with: arg3  self renderTriangle: arg1 on: arg2 with: arg3 color: (arg1 currentColor ifNil: [ arg1 color ])configurationBlockForProcessorsCreatedBy: arg1  self subclassResponsibilityiconAct  ^self iconNamed: #glamorousAcceptafter: arg1 do: arg2 with: arg3  | tmp1 |  tmp1 := arg3 brickValue: self.  arg1 brickValue: self.  arg2 brickValue: tmp1defaultLabel  ^'Debug it'stepModel: arg1  stepModel := arg1shouldntRaise: arg1 process: arg2 origin: arg3 during: arg4  spotter exceptionHandler: arg4.  self assert: spotter exceptionHandler identicalTo: arg4.  self shouldnt: [ self process: arg2 origin: arg3 ] raise: arg1.  self assert: spotter exceptionHandler identicalTo: arg4doApplyFilterWithQuery  self subclassResponsibilityinitialize  super initialize.  self     hSpaceFill;     with: [:arg1 |  arg1 when: #onAccepted do: [ self announce: #accepted event: arg1 text ] ];     cancelOnEscape;     cancelOnFocusLost;     with: [:arg2 |  arg2 margin: {arg2 themer focusedBorderWidth .               0} ];     with: [:arg2 |  arg2 editBrick           hShrinkWrap;           rubricBackgroundColor: arg2 themer rubricBackgroundColor;           margins: (self defaultPadding @ 0) asMargin ];     with: [:arg2 |  arg2 maxWidth: [ arg2 approximateWidth + arg2 owner hPadding ] ];     with: [:arg2 |  arg2 labelBrick margin: {0 .               (self defaultPadding + 2) .               0 .               self defaultPadding} ];     with: [:arg2 |  arg2 layout widthDependency: [ arg2 owner ] ];     with: [:arg2 |  arg2 editBrick layout widthDependency: [ arg2 ] ];     yourselfdoFilterInContext: arg1  ^arg1 doFilter: filterBlock gtFilter forProcessor: selfcategoryTitleStyleFor: arg1  arg1     useHorizontalLinearLayout;     height: 30;     hSpaceFill;     paddingLeft: self categoryNameMarginLeftcontext: arg1  context := arg1.  self resetrawValue  ^valueisAbove: arg1  ^arg1 globalOuterBounds origin <= self allowedBounds originamountBrick  ^amountBrickkeymapToggle  < shortcut>  ^KMKeymap shortcut: Character cr shift action: [ self class openGlobalSpotter ]spotterForDirectoriesFor: arg1  < spotterOrder: 50>  self flag: #specialFilter.  arg1 listProcessor     title: 'Directories';     itemIcon: [ GLMUIThemeExtraIcons glamorousFolder ];     itemFilterName: [:arg2 |  arg2 basename ];     filter: GTFilterFileReference item: [:arg3 :arg4 |  self fileReferencesBy: #directories inContext: arg4 usingFilter: arg3 ];     wantsToDisplayOnEmptyQuery: falsetitleFamilyName  ^'Open Sans'assertProcessorIncludes: arg1  self assert: arg1 notNil.  self assert: currentProcessor notNil.  self assert: currentProcessor allFilteredCandidates notEmpty.  self assert: (currentProcessor allFilteredCandidates anySatisfy: [:arg2 |  arg2 = arg1 ])select: arg1 dueTo: arg2  self assert: [ arg1 isNotNil ] description: [ 'Candidate link must not be nil' ].  self assert: [ arg1 processor isNotNil ] description: [ 'Candidate must have assigned category (processor)' ].  (self isSelected: arg1) ifTrue: [ ^self ].  self spotter after: [ selected := arg1.        self notifySelectedCandidateChanged: arg1 for: arg2 ] do: [ self spotter notifyCategorySelected: self selected processor ] ifTrue: [ (self isCategorySelected: arg1 processor) not ]selectPreviousCandidateDueTo: arg1  self spotterModel hasSelected ifTrue: [ self spotterModel currentStep selectPreviousDueTo: arg1 ]streamed  ^streamedselectNextDueTo: arg1  self select: self selected next dueTo: arg1gtDisplayOn: arg1  arg1 nextPutAll: self nameactOnInspectorPaneRemoved: arg1  arg1 browser panes size == 1 ifTrue: [ self selectedVariableName: nil ]moveTo: arg1  | tmp1 tmp2 tmp3 |  arg1 ifNil: [ ^self ].  tmp1 := arg1 globalBounds.  tmp3 := self globalBounds.  tmp2 := (tmp1 top - tmp3 top max: 0) min: tmp3 height - self triangleBrick height.  self triangleBrick brickBounds top = tmp2 ifTrue: [ ^self ].  self triangleBrick marginTop: tmp2.  self triangleBrick doLayoutForce.  self owner changedprintString  1 / 0defaultContinueItemsLimit  ^100presenterAt: arg1  ^self basicPresenters at: arg1addSignatureFor: arg1  | tmp1 |  tmp1 := self signatureFor: arg1.  (allMethodSignatures includes: tmp1) ifFalse: [ allMethodSignatures add: tmp1 ]isMatchedItem: arg1  ^falsespotterPragmasFor: arg1  < spotterOrder: 40>  ^arg1 listProcessor     title: 'Pragmas';     allCandidates: [ self pragmas ];     itemName: [:arg2 |  arg2 method printString , ' ' , arg2 asString ];     filter: GTFilterSubstringcontext  ^context ifNil: [ context := self newContextForQuery: nil ]processors: arg1  processors := arg1defaultIcon  ^niltitle  self subclassResponsibilityprintStringOf: arg1  ^[ ((arg1 class == Array ifTrue: [ self printArray: arg1 ] ifFalse: [ arg1 printString ]) contractTo: 200) asComment ] on: Error do: [ '"Error printing. Try self printString to debug"' ]prepareFilterInContext: arg1  super prepareFilterInContext: arg1.  caseSensitive ifNil: [ caseSensitive := self defaultCaseSensitive ].  self query: (caseSensitive ifTrue: [ self context textTrimmed ] ifFalse: [ self context textLowercase ])defaultText  ^''do: arg1  items ifNotNil: [ items do: arg1 ] ifNil: [ items := self defaultItems.        self itemDo: [:arg2 |  items add: arg2.              arg1 value: arg2 ] ]hidePreview  self spotterModel hidePreviewid  ^#gTInspectSelectionDebugActionterminateProcessors  self asyncTask terminateonStepAdded: arg1  | tmp1 tmp2 tmp3 tmp4 |  self spotterModel steps size <= 1 ifTrue: [ ^self push: (GTSpotterStepBreadcrumbItem new                 text: self spotterModel steps first origin gtDisplayString;                 stepModel: self spotterModel steps first) ].  tmp1 := arg1 stepModel.  tmp3 := tmp1 spotter steps at: tmp1 spotter steps size - 1.  tmp4 := tmp3 selected candidate.  tmp2 := tmp1 origin.  self push: (GTSpotterStepBreadcrumbItem new           stepModel: tmp1;           text: (tmp4 = tmp2 ifTrue: [ (tmp3 selected renderingProcessor render: tmp4) labelBrick text ] ifFalse: [ (tmp2 isKindOf: Collection) ifTrue: [ tmp1 processors first title ] ifFalse: [ tmp2 gtDisplayString ] ]))defaultTextLowercase  ^self textTrimmed asLowercaseremoveIcon  ^GLMUIThemeExtraIcons glamorousRemoveconfigureProcessorsStartingAt: arg1 with: arg2  arg1 > self processors size ifTrue: [ ^self ].  arg1 to: self processors size do: [:arg3 |  arg2 value: (self processors at: arg3) ]spotterPreviewArrowContainerStyleFor: arg1  arg1     useVerticalLinearLayout;     vSpaceFill;     width: self previewArrowWidth;     margin: {(self headerHeight + self innerBorderWidth + self previewBorderWidth) .         0 .         self previewBorderWidth .         self previewArrowGapHack negated}.  arg1 layout zIndex: 4beDeployment  self exceptionHandler: GTSpotterDeploymentExceptionHandler newhelp  ^'Select in the stack the context containing the test method.'inspectorIn: arg1  ^arg1 dynamic display: [:arg2 |  self inspectorIn: GLMCompositePresentation new on: arg2 ]equals: arg1  arg1 ifNil: [ ^false ].  ^self matches: arg1 searchcompose  self class enableDebuggerWindowDistinctColor ifTrue: [ self color: (Color r: 1.0 g: 0.3 b: 0.3) ].  self installDebuggingActionsFor: self.  self tabulator with: [:arg1 |  self debuggerStructureIn: arg1.        self debuggerTransmissionsIn: arg1 ].  self registerActionshideActionbar  self shouldShowActionbar ifTrue: [ ^self ].  self actionbarBrick visible: falsevalue: arg1  ^[ [ self applyFilterInContext: arg1 ] on: Error do: [:arg2 |  self exceptionHandler handleException: arg2 do: [ self applyFilterInContext: arg1 error: arg2 ] ] ] ensure: [ context := nil ]stepToFirstInterestingBytecodeIn: arg1  ^arg1 suspendedContextgtListFilter  ^GTFilterSubstring newonRemovedFrom: arg1  super onRemovedFrom: arg1.  self stepModel spotter announcer unsubscribe: self.  self stepModel announcer unsubscribe: self.  self stepModel candidates announcer unsubscribe: selfitemIconFor: arg1  ^nildiveInButton  ^diveInButtonnewAs: arg1  ^items ifNil: [ arg1 new ] ifNotNil: [ arg1 new: self size ]contentsBrick: arg1  contentsBrick ifNotNil: [ self removeBrick: contentsBrick ].  contentsBrick := arg1.  self themer spotterThemer spotterContentsStyleFor: contentsBrick.  self addBrickBack: contentsBrickfilterUsing: arg1  self filter: arg1arrowBrick  ^arrowBrickhistorize: arg1  (arg1 = self or: [ arg1 isNil ]) ifFalse: [ self history removeAllSuchThat: [:arg2 |  arg2 value = arg1 value ].        self history addFirst: arg1 ]testshouldSpotterIgnoreProcessorDefinedInMethod  spotterModel  ^spotterModeltestPreviousA1A2EmptyCategory  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := candidates addProcessor: GTSpotterA1.  tmp5 := candidates addProcessor: GTSpotterA2.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp2 := candidates addCandidate: 12 in: GTSpotterA1.  tmp3 := candidates addCandidate: 13 in: GTSpotterA1.  self assert: tmp4 equals: (candidates previousProcessorLinkOf: tmp4).  self assert: tmp4 equals: (candidates previousProcessorLinkOf: tmp5)testContextChange  self assertSearch: 'a'.  self assert: previousContext text equals: ''.  self denySearch: 'a'.  self assertSearch: 'ab'.  self assert: previousContext text equals: 'a'.  self denySearch: 'ab'.  self assertSearch: 'abc'.  self assert: previousContext text equals: 'ab'.  self denySearch: 'abc'.  self assertSearch: 'ab'.  self assert: previousContext text equals: 'abc'.  self denySearch: 'ab'.  self assertSearch: 'a'.  self assert: previousContext text equals: 'ab'.  self denySearch: 'a'.  self assertSearch: ''.  self assert: previousContext text equals: 'a'.  self flag: 'because the decision for triggering a search is made in multiple places, an empty input will always trigger a search - this should be simplified - one place to make the decision GTSpotter>>#setText:from: <-> #Context>>#matches:'.  self assertSearch: ''.  self assertSearch: ''diveInDueTo: arg1  self canDiveInSelectedCandidate ifTrue: [ self spotter           historize: self selected;           requestNextStepWith: self selected candidate for: #diveIn;           notifyDiveIn: self selected candidate for: arg1 ]asNonTruncatedTextFrom: arg1  ^self class asNonTruncatedTextFrom: arg1testRemoveCandidatesA1A2A3FromA1A2A3  | tmp1 tmp2 tmp3 |  tmp1 := candidates addProcessor: GTSpotterA1.  tmp2 := candidates addProcessor: GTSpotterA2.  tmp3 := candidates addProcessor: GTSpotterA3.  candidates addCandidate: 11 in: GTSpotterA1.  candidates addCandidate: 12 in: GTSpotterA1.  candidates addCandidate: 13 in: GTSpotterA1.  candidates addCandidate: 21 in: GTSpotterA2.  candidates addCandidate: 22 in: GTSpotterA2.  candidates addCandidate: 23 in: GTSpotterA2.  candidates addCandidate: 31 in: GTSpotterA3.  candidates addCandidate: 32 in: GTSpotterA3.  candidates addCandidate: 33 in: GTSpotterA3.  candidates removeAllCandidatesOf: GTSpotterA1.  candidates removeAllCandidatesOf: GTSpotterA3.  candidates removeAllCandidatesOf: GTSpotterA2.  self assert: candidates head equals: nil.  self assert: candidates tail equals: nil.  self assert: tmp1 headLink equals: nil.  self assert: tmp1 tailLink equals: nil.  self assert: tmp2 headLink equals: nil.  self assert: tmp2 tailLink equals: nil.  self assert: tmp3 headLink equals: nil.  self assert: tmp3 tailLink equals: niltext  ^text ifNil: [ text := '' asText ]session  ^self debugger sessiontestDeploymentExceptionHandlerMock4  self assertResetExceptions.  self shouldntRaise: ArithmeticError process: 'abc' origin: GTSpotterExceptionMock4 new.  self assertException: ArithmeticError.  self assertResetExceptions.  self shouldntRaise: Error process: 'abc' origin: GTSpotterExceptionMock4 new.  self assertException: ArithmeticErrorelement: arg1  element := arg1spotterForCachedPlaygroundPagesFor: arg1  < spotterOrder: 100>  arg1 listProcessor     allCandidates: [ GTPlayBook instance pages ];     title: 'Playground cached pages';     itemName: [:arg2 |  arg2 content asString contractTo: 100 ];     filter: self defaultFilterClassonCandidateSelected: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := arg1 itemBrick processor.  tmp2 := self categoryBrickOf: tmp1 ifAbsent: [ ^self ].  tmp3 := arg1 itemBrick.  tmp4 := tmp2 titleBrick.  tmp5 := (tmp3 candidateLink isFirst and: [ tmp4 isFirstInOwner ]) ifTrue: [ tmp4 ] ifFalse: [ tmp3 ].  self scrollTo: tmp5selectPreviousDueTo: arg1  self select: self selected previous dueTo: arg1implementors: arg1 inPackages: arg2  | tmp1 |  tmp1 := OrderedCollection new.  RPackageOrganizer default packages do: [:arg3 |  arg2 do: [:arg4 |  arg3 packageName = arg4 ifTrue: [ arg3 methods do: [:arg5 |  arg5 selector = tmp1 ifTrue: [ tmp1 add: arg5 ] ] ] ] ].  ^tmp1fileOutMessage  self currentMessageName ifNotNil: [ Cursor write showWhile: [ self currentClassOrMetaClass fileOutMethod: self currentMessageName ] ]filteredItems  ^filteredItemsonThemerChanged  super onThemerChanged.  self themer spotterThemer spotterPreviewArrowWidgetStyleFor: self triangleBrickdefaultItemsClass  ^OrderedCollectiondoIt  | tmp1 |  Smalltalk compiler silentlyDo: [ tmp1 := Smalltalk compiler evaluate: text string trimBoth ] exceptionDo: [:arg1 |  ^arg1 ]testPreviousA1A2Category  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp7 := candidates addProcessor: GTSpotterA1.  tmp8 := candidates addProcessor: GTSpotterA2.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp2 := candidates addCandidate: 12 in: GTSpotterA1.  tmp3 := candidates addCandidate: 13 in: GTSpotterA1.  tmp4 := candidates addCandidate: 21 in: GTSpotterA2.  tmp5 := candidates addCandidate: 22 in: GTSpotterA2.  tmp6 := candidates addCandidate: 23 in: GTSpotterA2.  self assert: tmp7 equals: (candidates previousProcessorLinkOf: tmp8).  self assert: tmp8 equals: (candidates previousProcessorLinkOf: tmp7)browseReceiver  self currentContext receiver class ifNotNil: [:arg1 |  Smalltalk tools browser openOnClass: arg1 ]text  ^textcreationTime  ^creationTimeinitialize  super initialize.  allMethodSignatures := OrderedCollection new.  selectedMethodSignatures := OrderedCollection newbuildItemFor: arg1 in: arg2  | tmp1 |  tmp1 := (arg1 renderingProcessor render: arg1 value)     candidateLink: arg1;     stepModel: self stepModel;     yourself.  ^tmp1methodCodeIn: arg1 forContext: arg2  (self methodCodeWidgetIn: arg1 forContext: arg2) with: [:arg3 |  self installCodeActionsFor: arg3 ]showPreview  self isPreviewShown ifTrue: [ ^self ].  self addBrickBack: self previewBrick.  self previewBrick spotterModel ifNotNil: [:arg1 |  arg1 hasSelected ifTrue: [ self previewBrick updatePreviewWith: arg1 currentStep selected candidate ] ].  self contentsBrick hSpaceFill: 100 - self previewBrick layout hPercent.  self changedborderColor  ^Color r: 180 g: 180 b: 180 range: 255addCategories: arg1  arg1 do: [:arg2 |  candidates addProcessor: arg2 ]initialize  super initialize.  self contentsBrick: self newContentsBrick.  self arrowBrick: self newArrowBrick.  self previewBrick: self newPreviewBrickupdateBrowserFrom: arg1  arg1 action needsUpdate ifTrue: [ self updateBrowser ].  self announcer announce: (GTDebuggerBrowserUpdateRequest from: arg1)senders: arg1 inPackages: arg2  | tmp1 |  tmp1 := OrderedCollection new.  RPackageOrganizer default packages do: [:arg3 |  arg2 do: [:arg4 |  arg3 packageName = arg4 ifTrue: [ arg3 methods do: [:arg5 |  (arg5 refersToLiteral: arg1) ifTrue: [ tmp1 add: arg5 ] ] ] ] ].  ^tmp1indexForItemName: arg1 andQuery: arg2  ^arg1 findString: arg2 startingAt: 1 caseSensitive: self caseSensitiveautoHide: arg1  autoHide := arg1executeAction  self debugger inspect: self debugger bytecodePresentation selectionpopStep  self steps size > 1 ifTrue: [ self after: [ self steps removeLast ] do: [:arg1 |  self notifyDiveOut: arg1 ] with: self currentStep origin.        self notifyStepPopped.        self pagerModel scrollToPane: self steps size callback: [ self pagerModel popPane: false ] ]closeSpotter  self autoHide ifTrue: [ self delete ]breadcrumbSeparatorLineWidth  ^2spotterForClassesFor: arg1  < spotterOrder: 10>  arg1 listProcessor     allCandidates: [ Smalltalk allClassesAndTraits ];     title: 'Classes';     filter: self defaultFilterClass;     itemIcon: #systemIcon;     keyBinding: $b meta;     wantsToDisplayOnEmptyQuery: falseusers  ^(self keyword senders collect: [:arg1 |  arg1 compiledMethod ]) \ (self pragmas collect: [:arg1 |  arg1 method ])initialize  super initialize.  self needsUpdate: false.  shouldBasicInspect := falserenderBottomTriangle: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := arg1 brickBounds width.  tmp5 := arg1 brickBounds height.  tmp1 := arg1 brickBounds topLeft + ((tmp4 / 2 - tmp5 max: 0) @ 0).  tmp2 := arg1 brickBounds topLeft + ((tmp4 / 2 + tmp5 min: tmp4) @ 0).  tmp3 := arg1 brickBounds bottomLeft + ((tmp4 / 2) @ 0).  self renderTriangle: arg1 on: arg2 with: {tmp1 asIntegerPoint .         tmp2 asIntegerPoint .         tmp3 asIntegerPoint}showActionsOf: arg1  arg1 subbricks select: [:arg2 |  arg2 isKindOf: GLMHintableActionButtonBrick ] thenDo: [:arg2 |  arg2 visible: true ]shouldEnableProcessorsCreateBy: arg1  ^(GTSpotterExtensionSettings shouldSpotterIgnoreProcessorDefinedInMethod: arg1) notstepModel  ^stepModelassertText: arg1  self assertText: arg1 do: nilhelp  ^'Print the result of a selected piece of code from the code pane of the debugger.'post: arg1  | tmp1 tmp2 tmp3 |  tmp1 := ZnEntity text: arg1 asString.  (tmp2 := self httpClient)     entity: tmp1;     post.  tmp3 := tmp2 response location.  ^tmp3 asZnUrl inContextOf: self urlProvideraddDiveInActionButton  (self stepModel canDiveIn: self candidate) ifTrue: [ diveInButton := self newActionButtonBrick           icon: self themer spotterThemer iconDiveIn;           hintTitle: 'Dive in';           hintText: '<' , OSPlatform current defaultModifier name asLowercase , '+right>';           action: [ self owner beSelected.              self stepModel diveInDueTo: #actionButton ];           yourself.        self addActionButton: diveInButton ]itemIconStyleFor: arg1  self flag: 'figure out why alpha doesn''t work'.  arg1     width: self itemIconMaxWidth;     vSpaceFillnewIconBrick  ^GLMInteractableBrick new normalImage: ((Form extent: 16 @ 16 depth: 32) fillAlpha: 0)origin: arg1  origin := arg1iconDiveInCategory  ^self iconNamed: #glamorousDiveAllRightIcondefaultOrder  ^200basicVariableNodesFor: arg1 in: arg2  self subclassResponsibilityitemActionSelectedBackgroundColor  ^self itemSelectedBackgroundColor darkerexitDueTo: arg1  self notifySpotterExitFor: arg1stepModel: arg1  stepModel := arg1headerStyleFor: arg1  arg1     hSpaceFill;     height: self headerHeightorientation  ^orientation ifNil: [ #bottom ]initialize  super initialize.  border := 0.  borderColor := Color transparentinstallActionsForRootPragmas: arg1 in: arg2  arg2 dynamicActions: [:arg3 |  self actionsForPragmas: (arg1 collect: [:arg4 |  #gt , arg4 capitalized ]) ].  arg2 dynamicActionsOnSelection: [:arg3 |  self actionsForPragmas: (arg1 collect: [:arg4 |  #gtContext , arg4 capitalized ]) ]slot  ^slottestAddThreeCandidateA1A2A3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 |  tmp10 := candidates addProcessor: GTSpotterA1.  tmp11 := candidates addProcessor: GTSpotterA2.  tmp12 := candidates addProcessor: GTSpotterA3.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp2 := candidates addCandidate: 12 in: GTSpotterA1.  tmp3 := candidates addCandidate: 13 in: GTSpotterA1.  tmp4 := candidates addCandidate: 21 in: GTSpotterA2.  tmp5 := candidates addCandidate: 22 in: GTSpotterA2.  tmp6 := candidates addCandidate: 23 in: GTSpotterA2.  tmp7 := candidates addCandidate: 31 in: GTSpotterA3.  tmp8 := candidates addCandidate: 32 in: GTSpotterA3.  tmp9 := candidates addCandidate: 33 in: GTSpotterA3.  self assert: tmp1 nextLink equals: tmp2.  self assert: tmp1 previousLink equals: tmp9.  self assert: tmp2 nextLink equals: tmp3.  self assert: tmp2 previousLink equals: tmp1.  self assert: tmp3 nextLink equals: tmp4.  self assert: tmp3 previousLink equals: tmp2.  self assert: tmp4 nextLink equals: tmp5.  self assert: tmp4 previousLink equals: tmp3.  self assert: tmp5 nextLink equals: tmp6.  self assert: tmp5 previousLink equals: tmp4.  self assert: tmp6 nextLink equals: tmp7.  self assert: tmp6 previousLink equals: tmp5.  self assert: tmp7 nextLink equals: tmp8.  self assert: tmp7 previousLink equals: tmp6.  self assert: tmp8 nextLink equals: tmp9.  self assert: tmp8 previousLink equals: tmp7.  self assert: tmp9 nextLink equals: tmp1.  self assert: tmp9 previousLink equals: tmp8.  self assert: candidates head equals: tmp1.  self assert: candidates tail equals: tmp9.  self assert: tmp10 headLink equals: tmp1.  self assert: tmp10 tailLink equals: tmp3.  self assert: tmp11 headLink equals: tmp4.  self assert: tmp11 tailLink equals: tmp6.  self assert: tmp12 headLink equals: tmp7.  self assert: tmp12 tailLink equals: tmp9previewPaddingLeft  ^self previewArrowWidth * 1.2filterByMethods: arg1  | tmp1 |  tmp1 := GTInspectorMethodListFilter new.  arg1 do: [:arg2 |  tmp1 addAndSelectSignatureFor: arg2 ].  self presentationFilter: tmp1receiver: arg1  receiver := arg1fileReferenceOrNil  self fileDirectory ifNil: [ ^nil ].  ^self fileDirectory / self fileNameweight: arg1  weight := arg1compose  self title: 'Meta'.  self tabulator with: [:arg1 |  arg1           row: [:arg2 |  arg2                 column: #classes;                 column: #methods span: 3 ];           row: #source.        arg1 transmit           to: #classes;           andShow: [:arg3 |  self classesIn: arg3 ].        arg1 transmit           to: #classes port: #selection;           transformed: [:arg4 |  arg4 class ].        arg1 transmit           fromOutsidePort: #entity;           from: #classes;           to: #methods;           andShow: [:arg3 |  self methodsIn: arg3 ].        arg1 transmit           from: #methods;           fromOutsidePort: #entity;           to: #source;           when: [:arg5 |  arg5 notNil ];           andShow: [:arg3 :arg5 :arg6 |  self sourceOf: arg5 for: arg6 in: arg3 ].        arg1 transmit           toOutsidePort: #selection;           from: #methods port: #evaluatedObject.        arg1 transmit           toOutsidePort: #selection;           from: #source port: #evaluatedObject ]printStringOf: arg1  self subclassResponsibilitydiveInCategoryDueTo: arg1  self diveInCategory: self selected processor dueTo: arg1setText: arg1 from: arg2  self steps isEmpty ifTrue: [ self addStep: (self newStep origin: self foundationOrigin) ].  (arg1 asString isEmpty and: [ self text isEmpty not ]) ifTrue: [ self currentStep process: nil ] ifFalse: [ self currentStep process: arg1 asString ].  text := arg1 asString asText.  ^truecandidates  ^candidates ifNil: [ candidates := DoubleLinkedList new ]itemIconAlphaValue  ^0.5stream: arg1  stream := arg1category  ^categorynameBrick: arg1  nameBrick ifNotNil: [ self removeBrick: nameBrick ].  nameBrick := arg1.  self themer spotterThemer categoryTitleNameStyleFor: nameBrick.  self addBrickBack: nameBrickisCategorySelected: arg1  < return: #Boolean>  ^self hasSelected and: [ self selected processor == arg1 ]defaultOrder  ^260increaseZindex: arg1  arg1 layoutProperties zIndex: 2queryForItem: arg1  ^queryhandleException: arg1 do: arg2  ^arg2 valuecategoryNameMarginRight  ^10testFloatPairs  | tmp1 |  tmp1 := 4.2 gtInspectorVariableValuePairs.  self assert: tmp1 size equals: 2.  self assert: tmp1 first equals: '1' -> 1074842828.  self assert: tmp1 second equals: '2' -> 3435973837testContext  ^testContextclear  self     headLink: nil;     tailLink: nil.  size := 0cache  ^cacheeventType  ^eventTypenewSettingsButton  ^GLMHintableActionButtonBrick newnotifyCategorySelected: arg1  self announce: (GTSpotterCategorySelected new category: arg1)rawValue  ^self hostObject readSlot: slotheadLink: arg1  headLink := arg1categoryBrickOf: arg1  < return: #GTSpotterCategoryBrick>  < throws: #Error when: 'Category for aProcessor does not exist'>  ^self categories at: arg1 ifAbsent: [ Error signal: 'Category for ' , arg1 asString , ' does not exist' ]keyword  ^keywordspotterPreviewIn: arg1  < spotterPreview: 10>  arg1 list     title: 'Preview';     display: [:arg2 |  arg2 ];     format: [:arg3 |  GTSpotterItemBrick new           text: arg3 gtDisplayString;           disable;           yourself ];     entity: self implementorscaseSensitive  ^caseSensitiveexecuteAction  self codePresentation profileSelectiontestArrayPairsLong  | tmp1 tmp2 |  tmp1 := 3 * GTInspector indexableDisplayLimit.  tmp2 := (1 to: tmp1) asArray gtInspectorVariableValuePairs.  self assert: tmp2 size equals: 2 * GTInspector indexableDisplayLimit.  (tmp2 collect: #key) allSatisfy: [:arg1 |  (tmp2 at: arg1) = arg1 ].  self assert: (tmp2 collect: #key) equals: ((1 to: GTInspector indexableDisplayLimit) asOrderedCollection           addAll: (tmp1 - GTInspector indexableDisplayLimit + 1 to: tmp1) asOrderedCollection;           yourself)setUp  super setUp.  spotter := GTMockSpotter new.  self shouldnt: [ spotter setText: '' from: self ] raise: Error.  currentStep := currentProcessor := currentCandidate := nilitemsLimit  ^self processor itemsLimitrawValue  ^self hostObject basicAt: indexonThemerChanged  super onThemerChanged.  self themer spotterThemer spotterContentsWidgetStyleFor: selfpaneBrick: arg1  paneBrick ifNotNil: [ self removeBrick: paneBrick ].  paneBrick := arg1.  self themer spotterThemer spotterPaneStyleFor: paneBrick.  self addBrickBack: paneBrickselectNextCandidateDueTo: arg1  self spotterModel hasSelected ifTrue: [ self spotterModel currentStep selectNextDueTo: arg1 ]addTag: arg1  (allTags includes: arg1) ifFalse: [ allTags add: arg1 ]initialize  super initialize.  self needsUpdate: falsedeltaTop: arg1  ^self allowedBounds origin y - arg1 globalOuterBounds origin yitemName  ^itemNameBlocktestDebuggingExceptionHandlerMock2  self shouldRaise: MessageNotUnderstood process: 'abc' origin: GTSpotterExceptionMock2 newspotterClipboardFor: arg1  < spotterOrder: 90>  ^arg1 listProcessor     title: 'Clipboard History';     items: [ Clipboard default recentItems ];     itemName: [:arg2 |  arg2 asString contractTo: 100 ];     itemFilterName: [:arg2 |  arg2 asString ];     filter: self defaultFilterClass;     actLogic: [:arg2 :arg3 |  arg3 exit.        arg2 asString inspect ];     wantsToDisplayOnEmptyQuery: falsecloseButton  ^closeButtondoFilterInContext: arg1  ^arg1 doFilter: GTFilterBlock gtFilter forProcessor: selfbreadcrumbHeight  ^26addItems: arg1  self addAllBricks: arg1resultsPaneStyleFor: arg1  arg1     hSpaceFill: self resultsPaneWidth;     vSpaceFill;     with: [:arg2 |  arg2 band layout: GTSpotterStackedLayout new ]itemIconAlphaValue  ^0.8getProcessorLinkByCandidateLink: arg1  ^arg1 processorLinkisEmpty  self deprecated: 'Use hasSteps instead'.  ^self hasSteps notcontinueFilter  | tmp1 tmp2 |  tmp1 := self cache at: #processorsAndFilters ifAbsent: [ ^self ].  tmp2 := tmp1 associations select: [:arg1 |  arg1 key hasFilteredCandidates ].  tmp2 size = 1 ifFalse: [ ^self ].  self canContinue ifFalse: [ ^self ].  self withContinue: true do: [ tmp2 do: [:arg1 |  arg1 key continueFilterInContext: self ] ]variablesIn: arg1  ^(super variablesIn: arg1) sorted: nilselectedItemBrick: arg1  selectedItemBrick isNil & arg1 isNotNil ifTrue: [ self showTriangle ].  selectedItemBrick isNotNil & arg1 isNil ifTrue: [ self hideTriangle ].  selectedItemBrick := arg1spotterWorldMenuFor: arg1  < spotterOrder: 9>  ^(self currentWorld worldMenu spotterItemsFor: arg1)     candidatesLimit: 15;     allCandidates: [ self currentWorld worldMenu allItems ];     title: 'Menu'spotter  ^spottertestWithErrorInSetup  self assert: a equals: 41assertException: arg1  self denyEmpty: self class exceptions.  self assert: (self class exceptions anySatisfy: [:arg2 |  arg2 class == arg1 ]).  self assertEmpty: self class fatalsorder  < return: #Number>  ^orderbasicPresenters  ^presenters ifNil: [ presenters := OrderedDictionary new ]childrenVariableNodesForNode: arg1  | tmp1 |  tmp1 := OrderedCollection new: arg1 value class allSlots size.  tmp1 add: (GTInspectorWrapperNode hostObject: arg1 label: 'self').  self basicVariableNodesFor: arg1 value in: tmp1.  ^tmp1defaultOrder  ^250inspectorDiffIn: arg1  ^arg1 tabulator with: [:arg2 |  arg2 when: [ self session supportsDiff ].        arg2           column: #actual;           column: #expected.        arg2 transmit           to: #actual;           andShow: [:arg3 |  arg3 dynamic display: [:arg4 |  GTDebuggerInspector new startOn: self session actualResult ] ].        arg2 transmit           to: #expected;           andShow: [:arg3 |  arg3 dynamic display: [:arg4 |  GTDebuggerInspector new startOn: self session expectedResult ] ] ]compositeBrick  ^compositeBrickstackIn: arg1  ^(self stackWidgetIn: arg1) with: [:arg2 |  self installStackDebuggingActionsFor: arg2 ]newActionbarButton  ^GLMHintableActionButtonBrick newnotifySelectedCandidateChanged: arg1  self notifySelectedCandidateChanged: arg1 for: #unknownpreviousProcessorLinkOf: arg1  | tmp1 |  arg1 ifNil: [ ^arg1 ].  tmp1 := arg1 previousLink.  tmp1 ifNil: [ tmp1 := self processors tail ].  [ tmp1 = arg1 ] whileFalse: [ tmp1 isEmpty ifFalse: [ ^tmp1 ].        tmp1 := tmp1 previousLink.        tmp1 ifNil: [ tmp1 := self processors tail ] ].  ^arg1dropDownPaneStyleFor: arg1  arg1     layoutProperties: GLMBrickLayoutProperties new;     marginTop: self innerBorderWidth;     vSpaceFill;     hSpaceFillitemNormalBackgroundColor  ^Color transparentonCurrentStepChanged  self searchField rubric updateTextWith: self spotterModel currentStep context text.  self searchField rubric selectFrom: self searchField rubric text size + 1 to: self searchField rubric text sizeaddDiveInButton  diveInButton := self newActionbarButton.  self diveInButton     icon: self themer spotterThemer iconDiveInCategory;     pressedColor: (self themer spotterThemer itemActionSelectedBackgroundColor alpha: 0.5);     action: [ self stepModel diveInCategory: self category dueTo: #actionButton ];     beHelp;     hintTitle: 'Show all';     hintText: '<' , OSPlatform current defaultModifier name asLowercase , '+shift+right>'.  self pushActionButton: self diveInButtoninstallDebuggingActionsFor: arg1  self subclassResponsibilitydefaultLowerThreshold  ^0.33addAndSelectSignatureFor: arg1  | tmp1 |  tmp1 := self signatureFor: arg1.  (allMethodSignatures includes: tmp1) ifFalse: [ allMethodSignatures add: tmp1 ].  (selectedMethodSignatures includes: tmp1) ifFalse: [ selectedMethodSignatures add: tmp1 ]popPane: arg1  self flag: 'the spotter-model will not pop its step unless the UI allows it by this call - hmmmmm'.  self notifyPagePoped: nilstepModel: arg1  stepModel := arg1.  stepModel candidates announcer when: GTSpotterCandidateAdded send: #onCandidateAdded: to: self.  stepModel candidates announcer when: GTSpotterAllCandidatesRemoved send: #onAllCandidatesRemoved to: self.  stepModel candidates announcer when: GTSpotterAllCandidatesAdded send: #onAllCandidatesAdded: to: self.  stepModel candidates announcer when: GTSpotterCandidatesAmountChanged send: #onCandidatesAmountChanged: to: self.  stepModel announcer when: GTSpotterScrollPageDown send: #scrollPageDown to: self.  stepModel announcer when: GTSpotterScrollPageUp send: #scrollPageUp to: self.  stepModel announcer when: GTSpotterCandidateSelected send: #onCandidateSelected: to: selfkeymapProfileOneCycle  < shortcut>  ^KMKeymap shortcut: $u meta action: [ self class profileOneCycle ]exceptionHandler  self flag: 'Bloc -> overrides doesNotUnderstand discarding the current exception context'.  ^GTCurrentSpotterExceptionHandler value ifNil: [ self context exceptionHandler ]togglePreview  self spotterModel togglePrevieworigin  ^originsetAmountVisible: arg1 all: arg2  self titleBrick setAmountVisible: arg1 all: arg2scrollpaneBackgroundColor  ^self spotterThemer backgroundColorgtInspectorPragmasIn: arg1  < gtInspectorPresentationOrder: 0>  arg1 list     title: 'Pragmas';     display: [ self pragmas ];     format: #gtDisplayStringinspect: arg1  ((self browser paneNamed: #inspector) port: #entity) silentValue: arg1.  (self browser paneNamed: #inspector) updaterubricBackgroundColor  ^self spotterThemer backgroundColorvalue: arg1  | tmp1 |  tmp1 := GTCurrentSpotterExceptionHandler value.  self assert: tmp1 notNil.  self assert: tmp1 == arg1 exceptionHandler.  self assert: tmp1 == arg1 step exceptionHandler.  self assert: tmp1 == arg1 spotter exceptionHandler.  ^#('done')onDo  ^onDo ifNil: [ onDo := [:arg1 :arg2 |   ] ]actualResult  ^actualResulticonDiveIn  ^self iconNamed: #glamorousDiveRightIconprocessors: arg1  processors := arg1close  self browser ifNotNil: [:arg1 |  arg1 close ]check  super check.  self showActionbar.  self notifySelectedcodePresentation  ^self debugger perform: self codePresentationSelectorassertDiveInCategory  self assertDiveIn: #diveInCategoryspotterForSendersFor: arg1  < spotterOrder: 31>  arg1 listProcessor     title: 'Senders';     filter: GTNullFilter item: [:arg2 :arg3 |  SystemNavigation default allSendersToString: arg3 textTrimmed do: arg2 ];     keyBinding: $n meta;     wantsToDisplayOnEmptyQuery: falsebreadcrumbItemBackgroundColor  ^self borderColoronRemoveSelector  ^onRemoveSelectorsetBindings: arg1  self inspectorPresentation firstPresentation     variableBindings: [ arg1 associations ];     updateVariableBindingsweight  ^weightbreadcrumbSeparatorWidgetStyleFor: arg1  arg1     color: self breadcrumbItemBackgroundColor;     borderColor: self breadcrumbSeparatorColor;     renderer: GTSpotterBreadcrumbSeparatorRenderer newtestAddTwoCandidateA1  | tmp1 tmp2 tmp3 |  tmp3 := candidates addProcessor: GTSpotterA1.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp2 := candidates addCandidate: 12 in: GTSpotterA1.  self assert: tmp1 nextLink equals: tmp2.  self assert: tmp1 previousLink equals: tmp2.  self assert: tmp2 nextLink equals: tmp1.  self assert: tmp2 previousLink equals: tmp1.  self assert: candidates head equals: tmp1.  self assert: candidates tail equals: tmp2.  self assert: tmp3 headLink equals: tmp1.  self assert: tmp3 tailLink equals: tmp2onLostFocus: arg1  focusedMorph ifNil: [ focusedMorph := arg1 morph ]spotterModel: arg1  spotterModel := arg1.  spotterModel announcer when: GTSpotterExitAnnouncement send: #closeSpotter to: self.  spotterModel announcer when: GTSpotterShowPreview send: #onShowPreview to: self.  spotterModel announcer when: GTSpotterHidePreview send: #onHidePreview to: self.  self breadcrumbBrick spotterModel: spotterModel.  self paneBrick spotterModel: spotterModel.  spotterModel class isPreviewVisible ifTrue: [ spotterModel showPreview ].  self spotterModelDo: [ self spotterModel setText: '' from: nil.        self spotterModel currentStep process: nil ]withItemsLimit: arg1 do: arg2  ^arg2 valueid  ^#gTSaveDebugActionprocessor: arg1 isRelevantForQuery: arg2  | tmp1 |  tmp1 := arg1 title asLowercase copyReplaceAll: String space with: ''.  ^tmp1 beginsWith: arg2value  ^self itemsassertProcessorNotEmpty  self assert: currentProcessor notNil.  self deny: currentProcessor allFilteredCandidates isEmptycategory  ^categoryselectedColor  ^Color veryVeryDarkGray alpha: 0.1assertResetExceptions  self class reset.  self assertNoExceptionsdoApplyFilterWithQuery  self streamed ifTrue: [ | tmp1 |        self filteredItems: (tmp1 := OrderedCollection new).        self allItems withIndexDo: [:arg1 :arg2 |  tmp1 add: arg1.              self addItem: arg1.              arg2 = self itemsLimit ifTrue: [ GTLimitArrived signal ] ] ] ifFalse: [ self filteredItems: self allItems.        self addItems: (self allItems first: (self itemsLimit min: self allItems size)) ]breadcrumbItemLabelStyleFor: arg1  arg1     textPosition: #center;     padding: {0 .         self outerBorderWidth};     vSpaceFill;     hSpaceFilllabel: arg1  self title: arg1.  self updatetestNextA1Category  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := candidates addProcessor: GTSpotterA1.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp2 := candidates addCandidate: 12 in: GTSpotterA1.  tmp3 := candidates addCandidate: 13 in: GTSpotterA1.  self assert: tmp4 equals: (candidates nextProcessorLinkOf: tmp4)newStepsBand  ^GLMBrick newbasicVariableNodesFor: arg1 in: arg2  ^arg1 gtInspectorVariableNodesIn: arg2stackPresentation  ^(self browser paneNamed: #stack) presentations firstonHideHints  self themer spotterThemer hintHideArrowStyleFor: self triangleBrickprivateAddCandidate: arg1 weightedIn: arg2  ^arg2 isFull ifTrue: [ self privateAddCandidate: arg1 weightedInFull: arg2 ] ifFalse: [ self privateAddCandidate: arg1 weightedInNotFull: arg2 ]spotterModel: arg1  self contentsBrick spotterModel: arg1.  self arrowBrick spotterModel: arg1.  self previewBrick spotterModel: arg1gtInspectorStepsIn: arg1  < gtInspectorPresentationOrder: 40>  arg1 list     title: 'Steps';     display: [ self steps ];     when: [ self steps notEmpty ]isFull  ^self size = self processor itemsLimitallSatisfy: arg1  self do: [:arg2 |  (arg1 value: arg2) ifFalse: [ ^false ] ].  ^truefirst: arg1  ^self items copyFrom: 1 to: (self size min: (arg1 max: 0))assertDiveIn  self assertDiveIn: #diveInhelp  ^'Evaluate the selection in a code pane of a debugger and push the result in the inspector of the debugger.'headerBrick  ^headerBrickmenu  ^nilhasSelected  < return: #Boolean>  ^selected isNotNildebuggerStructureIn: arg1  arg1     row: #stack;     row: #code span: 2;     row: #inspectorinitialize  super initialize.  selectedMethodSignatures := OrderedCollection new.  configurationBlocks := Dictionary newdoContinueFilterInContext: arg1  ^arg1 doContinueFilterForProcessor: selfinitialize  super initialize.  self needsUpdate: falsecontext: arg1  self current: arg1setUp  super setUp.  candidates := GTSpotterCandidatesList newcandidateLink: arg1  candidateLink := arg1.  self actionbarBrick candidateLink: self candidateLinkpaneBrick  ^paneBrickhostObject  ^hostObjecttestAddOneCandidateA1A2  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := candidates addProcessor: GTSpotterA1.  tmp4 := candidates addProcessor: GTSpotterA2.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp2 := candidates addCandidate: 21 in: GTSpotterA2.  self assert: tmp1 nextLink equals: tmp2.  self assert: tmp1 previousLink equals: tmp2.  self assert: tmp2 nextLink equals: tmp1.  self assert: tmp2 previousLink equals: tmp1.  self assert: candidates head equals: tmp1.  self assert: candidates tail equals: tmp2.  self assert: tmp3 headLink equals: tmp1.  self assert: tmp3 tailLink equals: tmp1.  self assert: tmp4 headLink equals: tmp2.  self assert: tmp4 tailLink equals: tmp2rawValue  ^thisContext object: self hostObject instVarAt: indexdiveInCategory: arg1 dueTo: arg2  self spotter     requestNextCategoryStepWith: (self candidates getProcessorLink: arg1) for: #diveInCategory;     notifyDiveInCategory: arg1 for: arg2notifyStepAdded: arg1  self announce: (GTSpotterStepAdded new stepModel: arg1)testAddOneCandidateA1A2A3  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp4 := candidates addProcessor: GTSpotterA1.  tmp5 := candidates addProcessor: GTSpotterA2.  tmp6 := candidates addProcessor: GTSpotterA3.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp2 := candidates addCandidate: 21 in: GTSpotterA2.  tmp3 := candidates addCandidate: 31 in: GTSpotterA3.  self assert: tmp1 nextLink equals: tmp2.  self assert: tmp1 previousLink equals: tmp3.  self assert: tmp2 nextLink equals: tmp3.  self assert: tmp2 previousLink equals: tmp1.  self assert: tmp3 nextLink equals: tmp1.  self assert: tmp3 previousLink equals: tmp2.  self assert: candidates head equals: tmp1.  self assert: candidates tail equals: tmp3.  self assert: tmp4 headLink equals: tmp1.  self assert: tmp4 tailLink equals: tmp1.  self assert: tmp5 headLink equals: tmp2.  self assert: tmp5 tailLink equals: tmp2.  self assert: tmp6 headLink equals: tmp3.  self assert: tmp6 tailLink equals: tmp3index: arg1 slotName: arg2  index := arg1.  slotName := arg2rawValue  ^self hostObject at: self tempIndexshouldShowActionbar  < return: #Boolean>  ^self isHovered or: [ self isChecked or: [ self stepModel ifNil: [ false ] ifNotNil: [:arg1 |  arg1 isSelected: self candidateLink ] ] ]closeActionFor: arg1  ^GLMGenericAction new     action: [ self removeLastPane ];     icon: GLMUIThemeExtraIcons glamorousClose;     condition: [:arg2 |  self panes size > 1 and: [ self panes last presentations = arg2 ] ];     title: 'Close this inspector column'newCloseButton  ^GLMHintableActionButtonBrick newbuttonFor: arg1  ^(self instantiate: arg1 specPresenter)     debugAction: arg1;     yourselftestInspectDoesNotCrash  window := GTInspector openOn: self class neworiginalSession  ^originalSessionsearchFieldFamilyName  ^'Source Sans Pro'printObjectAsAnItem: arg1  | tmp1 tmp2 |  tmp1 := (arg1 class name first isVowel ifTrue: [ 'an ' ] ifFalse: [ 'a ' ]) , arg1 class name.  tmp2 := (GTObjectPrinter asTruncatedTextFrom: arg1) asString.  ^(tmp2 beginsWith: tmp1) ifTrue: [ tmp2 ] ifFalse: [ String streamContents: [:arg2 |  arg2                 << tmp1;                 << ' (';                 << tmp2;                 << ')' ] ]messageText  ^self class nametextAttributesForStackEntry: arg1  (self selectedContext isNil or: self class enableStackColoring not) ifTrue: [ ^{(TextColor color: self theme textColor)} ].  ^self theme styleContext: arg1 from: selfsnippets  ^snippets ifNil: [ snippets := WeakIdentityKeyDictionary new ]spotterConcreteMethodFor: arg1  < spotterOrder: 30>  self flag: #specialFilter.  ^arg1 listProcessor     title: 'Methods';     filter: GTNullFilter item: [:arg2 :arg3 |  self concreteMethodsInContext: arg3 usingFilter: arg2 ];     wantsToDisplayOnEmptyQuery: falseitems: arg1  items := arg1withContinue: arg1 do: arg2  | tmp1 |  tmp1 := continuing.  ^[ continuing := arg1.  arg2 value ] ensure: [ continuing := tmp1 ]previous  ^self previousLinkshowActionsOf: arg1  arg1 subbricks select: [:arg2 |  arg2 isKindOf: GLMHintableActionButtonBrick ] thenDo: [:arg2 |  arg2 visible: true ]key  ^self tempNameapplyFilterWithQuery  | tmp1 |  tmp1 := FuzzyMatcher allSortedByScoreMatching: query in: self allItems by: [:arg1 |  self itemFilterNameFor: arg1 ].  self     addItems: (tmp1 takeFirst: self itemsLimit);     filteredItems: tmp1testAddTwoCandidateA1A2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp5 := candidates addProcessor: GTSpotterA1.  tmp6 := candidates addProcessor: GTSpotterA2.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp2 := candidates addCandidate: 12 in: GTSpotterA1.  tmp3 := candidates addCandidate: 21 in: GTSpotterA2.  tmp4 := candidates addCandidate: 22 in: GTSpotterA2.  self assert: tmp1 nextLink equals: tmp2.  self assert: tmp1 previousLink equals: tmp4.  self assert: tmp2 nextLink equals: tmp3.  self assert: tmp2 previousLink equals: tmp1.  self assert: tmp3 nextLink equals: tmp4.  self assert: tmp3 previousLink equals: tmp2.  self assert: tmp4 nextLink equals: tmp1.  self assert: tmp4 previousLink equals: tmp3.  self assert: candidates head equals: tmp1.  self assert: candidates tail equals: tmp4.  self assert: tmp5 headLink equals: tmp1.  self assert: tmp5 tailLink equals: tmp2.  self assert: tmp6 headLink equals: tmp3.  self assert: tmp6 tailLink equals: tmp4onShowPreview  self triangleBrick renderer border: 0.  self triangleBrick selectedColor: self themer spotterThemer borderColor.  self changedtestAddThreeCandidateA1A2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp7 := candidates addProcessor: GTSpotterA1.  tmp8 := candidates addProcessor: GTSpotterA2.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  tmp2 := candidates addCandidate: 12 in: GTSpotterA1.  tmp3 := candidates addCandidate: 13 in: GTSpotterA1.  tmp4 := candidates addCandidate: 21 in: GTSpotterA2.  tmp5 := candidates addCandidate: 22 in: GTSpotterA2.  tmp6 := candidates addCandidate: 23 in: GTSpotterA2.  self assert: tmp1 nextLink equals: tmp2.  self assert: tmp1 previousLink equals: tmp6.  self assert: tmp2 nextLink equals: tmp3.  self assert: tmp2 previousLink equals: tmp1.  self assert: tmp3 nextLink equals: tmp4.  self assert: tmp3 previousLink equals: tmp2.  self assert: tmp4 nextLink equals: tmp5.  self assert: tmp4 previousLink equals: tmp3.  self assert: tmp5 nextLink equals: tmp6.  self assert: tmp5 previousLink equals: tmp4.  self assert: tmp6 nextLink equals: tmp1.  self assert: tmp6 previousLink equals: tmp5.  self assert: candidates head equals: tmp1.  self assert: candidates tail equals: tmp6.  self assert: tmp7 headLink equals: tmp1.  self assert: tmp7 tailLink equals: tmp3.  self assert: tmp8 headLink equals: tmp4.  self assert: tmp8 tailLink equals: tmp6processor  ^processordebuggerStructureIn: arg1  self subclassResponsibilitynewActionbarBrick  ^GTSpotterItemActionbarBrick newisDropDownPaneVisible  ^self dropDownBrick isNotNilopenWithNotification: arg1  (GTSpecPreDebugPresenter on: self)     message: arg1;     openWithSpec;     setTitle: self titlebreadcrumbSeparatorColor  ^self breadcrumbItemBackgroundColor muchLighter slightlyDarkerconfigurationBlockForProcessorsCreatedBy: arg1  ^[:arg2 |   ]regex: arg1  regex := arg1testDevelopmentHandleExceptionMock5  self assertResetExceptions.  self should: [ [ 1 / 0 ] on: ZeroDivide do: [:arg1 |  GTSpotterDebuggingExceptionHandlerMock new handleException: arg1 do: [ self fail: 'Ups, we shouldnt have reached this statement' ] ] ] raise: ZeroDivide.  self assertException: ZeroDivideassertDebuggerInitialization  self assert: (debugger class handlesContext: session interruptedContext).  window := debugger openOn: session.  self assert: window model equals: debugger.  self assert: debugger session interruptedContext notNil.  self assert: debugger session interruptedProcess notNiladdActionButton: arg1  self themer spotterThemer itemActionButtonStyleFor: arg1.  self themer spotterThemer itemActionButtonWidgetStyleFor: arg1.  self addBrickBack: arg1.  self stepModel spotter isShiftPressed ifTrue: [ self themer spotterThemer hintRevealStyleFor: arg1 ]childrenNodesFor: arg1  < return: #Collection of: #GTInspectorVariableNode>  ^#()rubricBackgroundColor  ^self spotterThemer backgroundColorhideActionbar  (self hasSubbrick: self actionbarBrick) ifTrue: [ self removeBrick: self actionbarBrick ]addObject: arg1 inProcessor: arg2  self performSymbol: self onAddedSelector withArguments: {arg1 .         arg2}.  Processor yielddebuggingActionsPragmas  ^#(debuggingAction)closeButtonStyleFor: arg1  arg1     vSpaceFill;     width: [:arg2 |  arg2 height ];     margin: 10;     marginLeft: 0testDebugger  self assertDebuggerInitializationForContext: [ 20 factorial ] asContext andStepBlock: [:arg1 |   ].  self assertDebuggerClosingregex  ^regexitemBrick  ^candidateBrickaddItems: arg1 to: arg2  | tmp1 |  self assert: arg1 isNotNil.  self assert: arg1 isNotEmpty.  self assert: arg2 isNotNil.  tmp1 := arg2 hasSubbricks not.  arg2 addItems: arg1.  tmp1 ifTrue: [ self addCategory: arg2 ]stepBlockForTestWithHalt  ^[:arg1 |  arg1     completeStep: arg1 suspendedContext;     completeStep: arg1 suspendedContext;     step;     stepToSendOrReturn;     completeStep: arg1 suspendedContext;     stepToSendOrReturn ]gtListFilter  ^GTFilterSubstring newpragmas: arg1  pragmas := arg1selectedVariableName: arg1  self cache at: #selectedVariableName put: arg1allFilesSorted  ^self allFiles sorted: [:arg1 :arg2 |  arg1 modificationTime > arg2 modificationTime ]onThemerChanged  super onThemerChanged.  self doLayoutForceshowActionbar  (self hasSubbrick: self actionbarBrick) ifFalse: [ self addBrickBack: self actionbarBrick.        self toggleHints ]categoryAmountStyleFor: arg1  arg1 textPosition: #leftCenter.  arg1 label familyName: self titleFamilyName.  arg1     vSpaceFill;     width: #approximateWidth;     marginLeft: self categoryNameMarginRightlabel  ^labelspotterPreviewItemsIn: arg1  < spotterPreview: 10>  arg1 list     title: '<' , self gtDisplayString , '>';     display: [:arg2 |  arg2 ];     format: [:arg3 |  GTSpotterItemBrick new           text: arg3 method gtDisplayString;           disable;           yourself ];     entity: self pragmas asArraystringWithoutInitialCommentFrom: arg1  ^(arg1 trimLeft isEmpty not and: [ arg1 trimLeft first = $" ]) ifFalse: [ arg1 trimRight ] ifTrue: [ | tmp1 tmp2 |        tmp1 := arg1 findAnySubstring: '"' startingAt: (arg1 indexOf: $") + 1.        tmp2 := 1.        [ tmp1 <= arg1 size and: [ tmp2 % 2 = 1 or: [ (arg1 at: tmp1) = $" or: [ (arg1 at: tmp1) isSeparator ] ] ] ] whileTrue: [ (arg1 at: tmp1) = $" ifTrue: [ tmp2 := tmp2 + 1 ].              tmp1 := tmp1 + 1 ].        tmp1 >= (arg1 size + 1) ifTrue: [ ^'' ].        (arg1 copyFrom: tmp1 to: arg1 size) trimBoth ]errorMessage  ^'error obtaining field value'scrollbarColor  ^Color lightGray alpha: 0.2text: arg1  self labelBrick text: arg1helpButtonStyleFor: arg1  arg1     vSpaceFill;     width: [:arg2 |  arg2 height ];     margin: 10;     marginLeft: 0updateVariableNode: arg1 basedOn: arg2  | tmp1 |  tmp1 := arg1 hostObject class compiler     source: arg2;     context: nil;     receiver: arg1 hostObject;     failBlock: [ ^self ];     evaluate.  arg1 save: tmp1debuggerToTest  ^GTGenericStackDebuggersignatureFor: arg1  ^{arg1 methodClass .   arg1 selector}senders: arg1  ^self senders: arg1 inPackages: self defaultPackagestestAccessBindings  | tmp1 tmp2 |  tmp2 := Dictionary new.  tmp2 add: (WorkspaceVariable key: #a value: 1).  tmp2 add: (WorkspaceVariable key: #b value: 2).  window := playground openOn: (GTPlayPage new saveContent: 'a:=1. b:=a+1').  playground inspectorPresentation firstPresentation selectLine.  playground inspectorPresentation firstPresentation evaluateSelection.  tmp1 := playground currentBindings.  self assert: tmp1 equals: tmp2implementors  ^methods ifNil: [ methods := (SystemNavigation default allImplementorsOf: self name) collect: [:arg1 |  arg1 compiledMethod ] ]onStepPopped  self stepModel spotter steps last = self stepModel & self isChecked ifTrue: [ self notifySelected ]pagerModel  ^pagerModel ifNil: [ pagerModel := self defaultPagerModel defaultNumberOfVisiblePages: 1.        pagerModel announcer when: GLMPagePoped send: #onPagePopped to: self.        pagerModel ]message: arg1  textPresenter text: arg1testDeploymentExceptionHandlerMock5  self assertResetExceptions.  self shouldntRaise: AssertionFailure process: 'abc' origin: GTSpotterExceptionMock5 new during: GTSpotterDeploymentExceptionHandlerMock new.  self assertNoExceptionscategoryTitleWidgetStyleFor: arg1  arg1 normalColor: self categoryTitleBackgroundColoremptyTextFontSize  ^Smalltalk ui theme textFont pointSizespotterActDefault  | tmp1 |  tmp1 := GTPlayground new openOn: self.  self title notNil ifTrue: [ self ensureStashPersistency ].  ^tmp1codePane  ^self browser paneNamed: #codeonPagePopped  self steps size > 0 ifTrue: [ self currentStep: self steps last ]evaluationAction  ^GLMGenericAction new     action: [:arg1 :arg2 |  | tmp1 |        tmp1 := arg2 perform: arg1 selection selector.        (arg1 pane port: #evaluatedObject) value: tmp1 ];     shortcut: $g;     title: 'Do it and go';     yourselfsettingsLabelSelectedTextColor  ^Color blackinitialize  super initialize.  self needsUpdate: falsenewPageRow: arg1 in: arg2  ^self newRow     addBrickBack: (self newPageLabel           textColor: self themer textColor;           text: (arg1 content asString contractTo: 50));     addBrickBack: (self newAcceptButtonFor: arg1);     when: #onDoubleClicked do: [ self remove.        self announce: #pageAccepted event: arg1 ];     with: [:arg3 |  arg3           when: #onMouseHover do: [ self showActionsOf: arg3 ];           when: #onMouseUnhover do: [ self hideActionsOf: arg3 ] ];     yourselfnewLabelBrick  ^GLMLabelBrick newbreadcrumbSeparatorStyleFor: arg1  arg1     borderWidth: self breadcrumbSeparatorLineWidth;     width: self breadcrumbSeparatorWidth;     height: self breadcrumbHeight + self outerBorderWidthdefaultItemsLimit  ^5candidate  ^self valueisSelected: arg1  < return: #Boolean>  ^self hasSelected and: [ self selected == arg1 ]prepareFilterInContext: arg1  super prepareFilterInContext: arg1.  separators ifNil: [ separators := self defaultSeparators ].  self query: (self query substrings: self separators) asSet asArraystepModel: arg1  stepModel := arg1.  self stepModel announcer when: GTSpotterSelectedCandidateChanged send: #onCandidateSelected to: self.  self stepModel spotter announcer when: GTSpotterRevealHints send: #onRevealHints to: self.  self stepModel spotter announcer when: GTSpotterHideHints send: #onHideHints to: selfregisterActions  self when: GLMBrowserClosing send: #actOnBrowserClosing: to: self.  self when: DebugActionExecuted send: #updateBrowserFrom: to: self.  self when: GLMPaneRemoved send: #actOnInspectorPaneRemoved: to: selfpublish  (self confirm: 'Publish playground content to the cloud?') ifFalse: [ ^self ].  self content ifEmpty: [ self inform: 'Nothing was published because the playground is empty'.        ^self ].  Clipboard clipboardText: (publishedUrl := (GTUrlProvider new post: self contentString) asString).  self inform: publishedUrl , ' was published and the url was copied to clipboard'defaultLabel  ^'Do it'processors  ^processorsdefaultKeymap  ^$g metapreviewBrick: arg1  previewBrick ifNotNil: [ self removeBrick: arg1 ].  previewBrick := arg1.  self themer spotterThemer spotterPreviewStyleFor: previewBrickasyncTask  ^asyncTask ifNil: [ asyncTask := GLMAsyncTask new ]transmitFromStackToCodeIn: arg1  arg1 transmit     from: #stack port: #selection;     to: #code;     andShow: [:arg2 :arg3 |  self methodCodeIn: arg2 forContext: arg3.        self setUpCodeIn: arg2.        self tearDownCodeIn: arg2 ]value: arg1  ArithmeticError signal: 'Error while filtering'sourceCode: arg1  ^((self browser paneNamed: #code) port: #text) value: arg1selectionChanged: arg1  arg1 isNotNil ifTrue: [ self announce: (GTGenericStackDebuggerSelectionChanged forDebugger: self) ].  UIManager default defer: [ self session ifNotNil: [ (self browser paneNamed: #stack) presentations updateToolbar ] ].  self class enableStackColoring ifFalse: [ ^self ].  UIManager default defer: [ (self browser paneNamed: #stack) presentations presentations ifNotEmpty: [:arg2 |  self session interruptedProcess ifNotNil: [ arg2 first update ] ] ]isMatchedItem: arg1  ^self matcher ifNotNil: [ self matcher value: arg1 value: self context ] ifNil: [ (self itemFilterNameFor: arg1) includesSubstring: query caseSensitive: caseSensitive ]candidateLink: arg1  candidateLink := arg1testDebuggingExceptionHandlerDuring  | tmp1 |  self exceptionHandler: (tmp1 := GTSpotterDebuggingExceptionHandlerMock new) do: [ self shouldnt: [ GTCurrentSpotterExceptionHandler value ] raise: Error.        self assert: GTCurrentSpotterExceptionHandler value notNil.        self assert: GTCurrentSpotterExceptionHandler value identicalTo: tmp1 ]updateBrowser  | tmp1 tmp2 |  tmp2 := self session.  tmp2 interruptedContext ifNil: [ self close.        UIManager default inform: 'End of debugged execution' ] ifNotNil: [ tmp1 := self browser pane.        (tmp1 port: #entity) silentValue: nil.        (tmp1 port: #entity) value: tmp2 ]isShiftPressed  ^isShiftPressed ifNil: [ isShiftPressed := false ]triangleBrick  ^triangleBrickprocessor  ^self valuedefaultTextTrimmed  ^self text trimBothshouldDisplayPresentationCreatedBy: arg1  ^(self tagsFrom: arg1) includesAny: selectedTagsonHidePreview  | tmp1 |  self paneBrick isPreviewShown ifFalse: [ ^self ].  tmp1 := ((self width - (self width / 100 * (100 - self themer spotterThemer previewWidthPercent))) @ 0) negated / 2.  self bounds: (self bounds expandBy: tmp1 rounded).  self paneBrick hidePreview.  self doLayoutitemsLimit  ^Float infinityprocess: arg1 origin: arg2  | tmp1 |  ((tmp1 := GTSpotterStep new)     spotter: spotter;     origin: arg2;     yourself) processContext: (tmp1 newContextForQuery: arg1)handleException: arg1 do: arg2  GTSpotterExceptionsTest exceptions add: arg1allowProcessorsFrom: arg1  | tmp1 |  tmp1 := self signatureFor: arg1.  (selectedMethodSignatures includes: tmp1) ifFalse: [ selectedMethodSignatures add: tmp1 ]iconFor: arg1 error: arg2  ^self iconNamed: #smallWarningIconhandleExceptionsDuring: arg1  self exceptionHandler handleExceptionsDuring: arg1onThemerChanged  super onThemerChanged.  self themer spotterThemer itemNormalWidgetStyleFor: selfsession: arg1  (self browser pane port: #entity) value: arg1.  self title: arg1 namedefaultStream  ^GTSpotterUIThreadStream newvalue: arg1  self context: arg1caseSensitive: arg1  caseSensitive := arg1browseVersions  Smalltalk tools versionBrowser browseVersionsForClass: self currentClassOrMetaClass selector: self currentMessageNameactOnButton  ^actOnButtoncull: arg1  self context: arg1renderArrow: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 tmp11 tmp12 tmp13 tmp14 tmp15 |  tmp14 := 2.  tmp15 := 1.  tmp1 := arg1 brickBounds height.  tmp2 := arg1 brickBounds width.  tmp4 := tmp1 / 4.  tmp3 := tmp2 / 2.  tmp5 := ((tmp3 - tmp4 max: 0) min: tmp2) floor - tmp14 - tmp15.  tmp6 := ((tmp3 + tmp4 max: 0) min: tmp2) floor - tmp15.  tmp7 := tmp5.  tmp8 := tmp14 negated.  tmp9 := (tmp4 * 2) floor.  tmp10 := tmp1 + tmp14.  tmp11 := arg1 brickBounds topLeft + (tmp5 @ tmp8).  tmp12 := arg1 brickBounds topLeft + (tmp6 @ tmp9).  tmp13 := arg1 brickBounds topLeft + (tmp7 @ tmp10).  arg2 line: tmp11 to: tmp12 width: arg1 borderWidth first color: arg1 borderColor first.  arg2 line: tmp12 to: tmp13 width: arg1 borderWidth first color: arg1 borderColor firsttearDown  window ifNotNil: [ window delete ].  window := nil.  (RPackageOrganizer default packageNamed: 'GTMockTests' ifAbsent: [  ]) ifNotNil: #removeFromSystem.  playground := nil.  super tearDownhasStepModel  ^stepModel isNotNilevent: arg1  event := arg1categories  < return: #Dictionary>  ^categoriesbuildPane: arg1  | tmp1 |  tmp1 := GTSpotterResultsBrick new stepModel: arg1.  self brickThemer spotterThemer resultsPaneStyleFor: tmp1.  ^tmp1initialize  super initialize.  allTags := OrderedCollection new.  selectedTags := OrderedCollection new.  defaultTag := #customhintHideArrowStyleFor: arg1  arg1 ifNil: [ ^self ].  (arg1 valueOfProperty: #brickSpotterIsReveal ifAbsent: [ false ]) ifFalse: [ ^self ].  arg1 setProperty: #brickSpotterIsReveal toValue: false.  (arg1 hasProperty: #brickSpotterBackupColor) ifTrue: [ arg1 color: (arg1 valueOfProperty: #brickSpotterBackupColor) ].  arg1 changedlayoutProportional: arg1 in: arg2 position: arg3  | tmp1 tmp2 tmp3 |  arg1 isEmpty ifTrue: [ ^self ].  tmp1 := arg2 innerBounds width.  tmp3 := 0.  arg1 inject: arg2 paddingLeft into: [:arg4 :arg5 |  | tmp4 |        self sendEvent: (GLMBrickLayoutStacked new                 index: tmp3 + 1;                 position: arg3;                 yourself) to: arg5.        tmp2 := ((tmp1 - arg4) / (arg1 size - tmp3)) ceiling.        tmp4 := arg5 wrappedBounds.        tmp3 = 0 ifTrue: [ tmp4 width: (((arg5 layout maxWidth brickValue: arg5) max: tmp2) min: tmp1 - arg4) ] ifFalse: [ tmp3 = (arg1 size - 1) ifFalse: [ tmp4 width: (tmp2 min: (arg5 layout maxWidth brickValue: arg5)) ] ifTrue: [ tmp4 width: tmp2 ] ].        tmp4 translateBy: arg4 @ 0.        arg5 brickBounds: tmp4.        tmp3 := tmp3 + 1.        arg4 + tmp4 outerBounds width ]step  ^stepseparators  ^separatorshelpButton  ^helpButtonhelp  ^'Execute a selected piece of code from the code pane of the debugger.'variablesFromContext: arg1  ^cachedVariables ifNil: [ cachedVariables := self buildVariablesFromContext: arg1 ]onThemerChanged  super onThemerChanged.  self themer spotterThemer categoryTitleWidgetStyleFor: self.  self themer spotterThemer categoryAmountWidgetStyleFor: self amountBrick.  self themer spotterThemer categoryTitleNameWidgetStyleFor: self nameBrickexpectedResult  ^expectedResultsettingsButton  ^settingsButtoncontinueFilterInContext: arg1  [ self basicContinueFilterInContext: arg1 ] on: Error do: [:arg2 |  self exceptionHandler handleException: arg2 do: [ ('[Spotter] Exception in continuing processor <' , self title asString , '>: ' , arg2 asString) traceCr ] ]newBreadcrumbBrick  ^GTSpotterStepsBreadcrumb newexceptionHandler: arg1 do: arg2  self assertResetExceptions.  self shouldnt: [ arg1 handleExceptionsDuring: arg2 ] raise: Error.  self assertNoExceptions.  self assertResetExceptions.  self shouldnt: [ spotter exceptionHandler: arg1.        spotter handleExceptionsDuring: arg2 ] raise: Error.  self assertNoExceptionsband: arg1  band := arg1.  band     useHorizontalLinearLayout;     hShrinkWrap;     vSpaceFill.  self band data: 0.  self addBrickBack: banddefaultKeymap  ^PharoShortcuts current doItShortcutonRevealHints  (self hasSubbrick: self actionbarBrick) ifFalse: [ ^self ].  self themer spotterThemer hintRevealStyleFor: self diveInButtonbasicRelevantProcessorsProcess: arg1 do: arg2  arg1 text substrings detect: [:arg3 |  arg3 beginsWith: '#' ] ifFound: [:arg4 |  | tmp1 |        arg1 text: (arg1 text copyReplaceAll: arg4 with: '').        tmp1 := arg4 allButFirst asLowercase.        self processors select: [:arg3 |  self processor: arg3 isRelevantForQuery: tmp1 ] thenDo: arg2 ] ifNone: [ self processors do: arg2 ]currentMessageName  ^self currentContext methodSelectorcandidatesLimit: arg1  self itemsLimit: arg1textLowercase  ^textLowercase ifNil: [ textLowercase := self defaultTextLowercase ]id  ^self class namereceiver  ^receivervariableTag  ^'attribute'open  | tmp1 |  tmp1 := super open.  self class environment at: #GTDebuggerEventCollector ifPresent: [:arg1 |  arg1 new collectDataFrom: self ].  ^tmp1reject: arg1 as: arg2  | tmp1 |  tmp1 := self newAs: arg2.  self do: [:arg3 |  (arg1 value: arg3) ifFalse: [ tmp1 add: arg3 ] ].  ^tmp1session  ^self owner sessiondefaultTask  ^GLMAsyncTask newisNotEmpty  < return: #Boolean>  ^self isEmpty notpersistenceStrategies  ^persistenceStrategiescollect: arg1 as: arg2  | tmp1 |  tmp1 := self newAs: arg2.  self do: [:arg3 |  tmp1 add: (arg1 value: arg3) ].  ^tmp1initialize  super initialize.  self     useVerticalLinearLayout;     vShrinkWrap;     initializeListeners;     enableitemNormalWidgetStyleFor: arg1  arg1     normalColor: self itemNormalBackgroundColor;     selectedColor: self itemHoveredBackgroundColor;     checkedColor: self itemSelectedBackgroundColorprocessorKeyBindingsDo: arg1  processorKeyBindings ifNotNil: [ processorKeyBindings keys do: [:arg2 |  self kmDispatcher removeKeyCombination: arg2 ] ].  processorKeyBindings := Dictionary new.  arg1 valuetreeIn: arg1  ^arg1 tree     rootsExpanded;     display: [:arg2 |  {arg2} ];     children: [:arg3 |  arg3 children ];     selectionPopulate: #selectedNode on: $o entitled: 'Open' with: [:arg4 |  arg4 selection ];     format: [:arg3 |  String streamContents: [:arg5 |  arg5                 nextPutAll: arg3 class name;                 nextPut: $(;                 nextPutAll: ((arg3 formattedCode truncateTo: 50) copyReplaceAll: String cr with: String space);                 nextPut: $) ] ]reject: arg1 thenDo: arg2  self do: [:arg3 |  (arg1 value: arg3) ifFalse: [ arg2 value: arg3 ] ]hintRevealArrowStyleFor: arg1  arg1 ifNil: [ ^self ].  (arg1 valueOfProperty: #brickSpotterIsReveal ifAbsent: [ false ]) ifTrue: [ ^self ].  arg1 setProperty: #brickSpotterBackupColor toValue: arg1 color.  arg1 setProperty: #brickSpotterIsReveal toValue: true.  arg1 color: self themer popupHelpThemer backgroundColor.  arg1 changedcurrent  ^currentheadLink  ^headLinktestBla  < expectedFailure>  self assert: self bla equals: 1announcer  ^announcer ifNil: [ announcer := Announcer new ]stepModel  ^stepModelcontentsBrick  ^contentsBricktestAddOneCandidateA1  | tmp1 tmp2 |  tmp2 := candidates addProcessor: GTSpotterA1.  tmp1 := candidates addCandidate: 11 in: GTSpotterA1.  self assert: tmp1 nextLink equals: tmp1.  self assert: tmp1 previousLink equals: tmp1.  self assert: candidates head equals: tmp1.  self assert: candidates tail equals: tmp1.  self assert: tmp2 headLink equals: tmp1.  self assert: tmp2 tailLink equals: tmp1defaultOrder  ^5sort  ^sortBlockdefaultKeymap  ^PharoShortcuts current inspectItShortcutpreviewArrowColor  ^self itemSelectedBackgroundColorselect  self invalidateWith: [ self labelBrick label           customFont;           beBold ]canDiveInSelectedCandidate  ^self canDiveIn: self selected candidateinspectIt  | tmp1 |  Smalltalk compiler silentlyDo: [ tmp1 := Smalltalk compiler evaluate: text string trimBoth ] exceptionDo: [:arg1 |  ^arg1 ].  tmp1 inspect.  self exitDueTo: #inspectItshouldDisplayPresentationCreatedBy: arg1  ^true