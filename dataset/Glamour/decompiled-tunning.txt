updateRoots  roots := nil.  self changed: #rootNodescolumn: arg1 evaluated: arg2  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2)percent: arg1  percent := arg1outerPortEvent: arg1  self announce: (GLMContextChanged new           presentation: self;           property: arg1 portName;           value: arg1 value;           oldValue: arg1 oldValue;           yourself).  self portChangeActions do: [:arg2 |  arg2 portName = arg1 portName ifTrue: [ arg2 actOn: self ] ]passiveOrigins  ^(self originReferences select: [:arg1 |  arg1 isPassive ]) collect: [:arg1 |  arg1 port ]forceHeight: arg1  customHeight := arg1doOpen: arg1  ^self subclassResponsibilityhintTitle: arg1  hintTitle := arg1shadowOffset  ^0 @ 0markLayoutClean  self layout markCleananimateToEditFocused  self borderAnimation     from: self borderColor first;     to: self themer focusedBorderColor;     animate: selftestToSend  | tmp1 |  tmp1 := GLMListPresentation new.  tmp1 selectionTransformation: [:arg1 |  arg1 + 1 ].  tmp1 entity: (1 to: 100).  tmp1 selection: 41.  self assert: tmp1 selection equals: 42modifiedBlock: arg1  modifiedBlock := arg1brickDoubleLink  ^self valueOfProperty: #brickDoubleLink ifAbsentPut: [ nil ]testSimpleTransmissionsToOuter  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 sendTo: #outer -> #increased from: #outer -> #entity with: [:arg1 |  arg1 + 1 ].  tmp1 transmit     to: #one;     from: #outer port: #increased;     andShow: [:arg2 |  arg2 text ].  tmp1 startOn: 41.  self assert: ((tmp1 paneNamed: #one) port: #entity) value equals: 42subbrickAfter  | tmp1 |  tmp1 := self brickDoubleLink.  tmp1 ifNil: [ ^nil ].  tmp1 nextLink ifNil: [ ^nil ].  ^tmp1 nextLink valuerubric  ^self morphpagerBar  ^pagerBarrenderWithTitle: arg1  | tmp1 |  tmp1 := self renderObject: arg1.  ^self morph: tmp1 withTitleOf: arg1keystroke: arg1 from: arg2  arg1 anyModifierKeyPressed ifTrue: [ ^super keystroke: arg1 from: arg2 ].  self glamourPresentation text: self text.  ^falsecolorTop  ^self color at: ToprenderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderFastTreeWithColumnsPresentation: selftitle  ^titlecheckedFocusedIcon  ^checkedFocusedIconexecuteMenuAction: arg1  self announcer announce: (GLMMenuItemSelected action: arg1)isRunningInUIProcess  ^UIManager default uiProcess == Processor activeProcessactOnContextChanged: arg1  arg1 property = #selectionInterval ifTrue: [ arg1 value notNil ifTrue: [ textMorph setSelection: arg1 value ] ifFalse: [ textMorph setSelection: (1 to: 0) ] ]sortBlock  ^columnToSortBy sortBlock ifNil: [ | tmp1 |        tmp1 := columnToSortBy defaultSortBlockForPresentation: self glamourPresentation.        [:arg1 :arg2 |  tmp1 value: arg1 data value: arg2 data ] ]separatorBefore  ^separatorBefore ifNil: [ false ]sendTo: arg1 from: arg2 with: arg3  self transmissions addLast: (GLMTransmission new           addActiveOrigin: (self resolveOriginPort: arg2);           destination: (self resolveDestinationPort: arg1);           transformation: arg3;           yourself)oldValue: arg1  oldValue := arg1updateWidth: arg1 on: arg2  arg1 outerWidth: (arg2 normalizeWidth: (arg2 widthParentDependency: arg1) of: arg1)textColor  ^self valueOfProperty: #brickTextColor ifAbsent: [ self themer textColor ]state  ^self subclassResponsibilitytestDefaultPortValue  | tmp1 |  tmp1 := GLMPane named: 'test'.  self assert: (tmp1 port: #somePort) value isNiltabs  ^tabsaction: arg1  action := arg1testChildrenBlockTakesEntity  | tmp1 tmp2 |  tmp1 := GLMFinder new.  tmp2 := nil.  tmp1 show: [:arg1 |  arg1 tree children: [:arg2 :arg3 |  tmp2 := arg3.              #() ] ].  window := tmp1 openOn: ($a to: $d).  self waitUntilUIRedrawed.  self assert: tmp2 equals: ($a to: $d)popupThemer  ^self registerModule: GLMBrickPopupThemer newhasTitleIcon  ^self titleIcon notNiladdPresentations: arg1  self transmissionStrategy addPresentations: arg1testShrinkWrapInStaticWithNeighbours  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp7 := 20.  tmp6 := self staticWidth - tmp7.  tmp1 := self newBrickWithStaticExtent useHorizontalLinearLayout.  tmp2 := GLMBrick new     useVerticalLinearLayout;     hSpaceFill;     vShrinkWrap.  tmp3 := GLMBrick new     height: self staticHeight;     hSpaceFill.  tmp4 := GLMBrick new     height: self staticHeight;     hSpaceFill.  tmp5 := GLMBrick new     vSpaceFill;     width: tmp7.  tmp1 addAllBricks: {tmp2 .         tmp5}.  tmp2 addAllBricks: {tmp3 .         tmp4}.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 brickBounds equals: (0 @ 0 extent: self staticExtent).  self assert: tmp5 brickBounds equals: (tmp6 @ 0 extent: tmp7 @ self staticHeight).  self assert: tmp3 brickBounds equals: (0 @ 0 extent: tmp6 @ self staticHeight).  self assert: tmp4 brickBounds equals: (0 @ self staticHeight extent: tmp6 @ self staticHeight).  self assert: tmp2 brickBounds equals: (0 @ 0 extent: tmp6 @ (self staticHeight + self staticHeight))presentation  ^presentationaccept  self text: self editBrick text.  self borderColor: self themer color emerald.  self beNormalpane: arg1  pane := arg1variableBindings  ^variableBindings ifNil: [ variableBindings := Dictionary new ]testImplicitNotNilMultipleValues  | tmp1 |  tmp1 := GLMPresentation new.  tmp1 useImplicitNotNil.  (tmp1 pane port: #entity) value: (GLMMultiValue withAll: #(nil nil)).  self assert: tmp1 matches not.  (tmp1 pane port: #entity) value: (GLMMultiValue withAll: #(1 nil)).  self assert: tmp1 matches not.  (tmp1 pane port: #entity) value: (GLMMultiValue withAll: #(nil 1)).  self assert: tmp1 matches not.  (tmp1 pane port: #entity) value: (GLMMultiValue withAll: #(1 2)).  self assert: tmp1 matchesrubricBorderColor  ^Color transparentscrollPageDown  self     scrollDown: self calculateMaxVelocity;     update;     changedstartTime  ^startTime ifNil: [ startTime := Time millisecondClockValue ]clearUserEdits  self hasUnacceptedEdits: falsesubmit: arg1  arg1 cull: self submitonLayouted  ^self brick onLayoutedprintOn: arg1  super printOn: arg1.  arg1     nextPut: Character space;     nextPutAll: self identityHash printString;     nextPutAll: ' (name=';     nextPutAll: self name printString;     nextPutAll: ' value=';     nextPutAll: self value printString;     nextPut: $)tabs: arg1  tabs := arg1markClean  isDirty := falserowMorphElementsForFirstColumn: arg1 item: arg2 in: arg3  (self iconFor: arg2) ifNotNil: [:arg4 |  arg3 add: arg4 asMorph ]interactionModel  ^selfunsubscribeListeners  self activeHand removeEventListener: selfactOnUpdatedPresentation: arg1  tableModel resetElements.  tableMorph refreshtestConditionalPresentation  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     to: #two;     from: #one;     andShow: [:arg1 |  arg1 text when: [:arg2 |  arg2 = 42 ].        arg1 list when: [:arg2 |  arg2 > 42 ] ].  ((tmp1 paneNamed: #one) port: #selection) value: 42.  self assert: (tmp1 paneNamed: #two) matchingPresentations size equals: 1.  self assert: ((tmp1 paneNamed: #two) matchingPresentations first isKindOf: GLMRubricTextPresentation).  ((tmp1 paneNamed: #one) port: #selection) value: 43.  self assert: (tmp1 paneNamed: #two) matchingPresentations size equals: 1.  self assert: ((tmp1 paneNamed: #two) matchingPresentations first isKindOf: GLMListPresentation)selectedTextBlock: arg1  selectedTextBlock := arg1pharoMethod  ^self custom: GLMPhlowPharoMethodBrick newapproximateHeight  ^self labelBrick approximateHeight + self vMargin + self vPaddingbrickRoot  ^self owner ifNotNil: [ self owner brickRoot ] ifNil: [ ^self ]setWidthAfterResizing  | tmp1 tmp2 |  tmp1 := pagerModel circleButtonSize * (pagerModel firstVisiblePageIndex - 1).  tmp2 := tmp1 + self computeWidth.  self setPosition: tmp1 @ tmp2newButtonBrick  ^GLMButtonBrick newparentNode  ^parentNodedoLayout  self isLayotingAllowed ifTrue: [ GLMBrickLayouter uniqueInstance layoutIn: self brickApi ]shouldExpandToLevel: arg1  ^expandLevel := arg1testUpdateOnTriggered  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMPane named: 'test'.  tmp2 := GLMPresentation new.  tmp3 := Announcer new.  tmp1 addPresentation: tmp2.  tmp4 := 0.  tmp2 when: GLMPresentationUpdated do: [:arg1 |  tmp4 := tmp4 + 1 ].  tmp2 updateOn: GLMTestAnnouncement from: #yourself.  tmp2 entity: tmp3.  tmp2 registerAnnouncements.  tmp3 announce: GLMTestAnnouncement.  self assert: tmp4 equals: 1testAsOriginIdentifier  | tmp1 |  tmp1 := GLMPortIdentifier new.  self assert: tmp1 asGlamourOriginIdentifier equals: tmp1newLabelBrick  ^GLMLabelBrick newisLastInOwner  ^self brickDoubleLink ifNotNil: [:arg1 |  arg1 hasSuccessor not ] ifNil: [ false ]entity: arg1  self transformedEntity: (self displayLogic phlowValue: arg1).  super entity: arg1defaultSelectionActions  ^self executionSelectionActions , self browsingSelectionActions , self codeEditingSelectionActionsinitializeTableModel: arg1  tableModel := (self createDataSourceFrom: arg1)     glamourPresentation: arg1;     yourself.  self specificDataSourceInitializiationhandlesMouseOver: arg1  ^self isEnabled ifTrue: [ true ] ifFalse: [ super handlesMouseDown: arg1 ]defaultFillStyle  ^SolidFillStyle color: Color transparentvShrinkWrap  vResizing := #shrinkWrap.  self height: [ self morph height ]doLayout  self brickRoot doLayoutForceselectionIndex  ^selectionIndexwhen: arg1 do: arg2  self announcer when: arg1 do: arg2act: arg1 entitled: arg2  self addAction: (GLMGenericAction new           action: arg1;           title: arg2;           yourself)testUpdateAction  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list populate: #foo on: $m with: [:arg2 :arg3 |  42 ] ].  tmp1 transmit     to: #two;     from: #one port: #foo;     andShow: [:arg1 |  arg1 text ].  tmp1 startOn: #(1 2 3).  self assert: tmp1 panes first presentations size equals: 1.  self assertEmpty: tmp1 panes last presentations.  tmp1 panes first presentations first actions first actOn: tmp1 panes first presentations first.  self assert: tmp1 panes second presentations size equals: 1.  self assert: tmp1 panes second presentations first entity equals: 42mouseEnter: arg1  super mouseEnter: arg1.  ^self select: arg1callback: arg1  callback := arg1formatSourceCode  self glamourPresentation formatSourceCodeinactiveFillStyle  ^self theme watcherWindowInactiveFillStyleFor: selfaddPane: arg1  arg1 browser: self.  self panes add: arg1.  self hasStatusbar ifTrue: [ self addDefaultStatusbarTransmissionFrom: arg1 ].  ^arg1paneWidthsToFit: arg1  | tmp1 |  tmp1 := Array new: self paneCount.  tmp1 atAllPut: (arg1 / self sizing) floor.  (1 to: arg1 - tmp1 sum) do: [:arg2 |  tmp1 at: arg2 put: (tmp1 at: arg2) + 1 ].  ^tmp1hSpaceFill: arg1  self hPercent: arg1minHeight  ^minHeight ifNil: [ minHeight := 0 ]withAnnotation: arg1  withAnnotation := arg1vSpaceFill: arg1  super vSpaceFill: arg1.  self label vSpaceFillbandTopOffset  ^self band brickBounds topshowScrollBarWhenNeeded  ^showScrollBarWhenNeeded ifNil: [ showScrollBarWhenNeeded := true ]textColor  ^Color r: 0 g: 115 b: 0 range: 255resolveDestinationPort: arg1  self flag: 'this is a temporary hack due to initializeScripting transmitting directly a port'.  (arg1 isKindOf: GLMPort) ifTrue: [ ^arg1 ].  ^self resolvePort: arg1 asGlamourTargetIdentifier defaultPortName: #entitycontextClass: arg1  contextClass := arg1setUp  super setUp.  pane := GLMPane named: 'test'.  presentation := GLMTreePresentation new.  pane addPresentation: presentation.  presentation entity: #(#($a $b $c $d) #($e $f) #($g)).  presentation children: [:arg1 :arg2 |  arg1 asString size > 1 ifTrue: [ arg1 ] ifFalse: [ OrderedCollection new ] ].  presentation shouldValidate: trueactOnContextChanged: arg1  arg1 property = #activePresentation ifTrue: [ tabs announcer suspendAllWhile: [ tabs selectedPageIndex: (arg1 presentation matchingPresentations indexOf: arg1 value) ] ]normalizePaneIndex: arg1  arg1 < 1 ifTrue: [ ^1 ].  arg1 > self size ifTrue: [ ^self size ].  ^arg1render: arg1  | tmp1 |  tmp1 := GLMMorphic containerMorph.  arg1 cell isRow ifTrue: [ self renderCustomRow: arg1 cell ofPane: arg1 pane inUI: tmp1 inBrowser: arg1 ] ifFalse: [ self renderCustomColumn: arg1 cell ofPane: arg1 pane inUI: tmp1 inBrowser: arg1 ].  arg1 when: GLMBrowserClosed send: #actOnBrowserClosed: to: self.  ^tmp1scrollBarMenuButtonPressed: arg1  defaultRenderer  ^GLMBrickAreaRenderer newbuttonBackgroundColor  ^Color veryDarkGray lighterlayoutPolicy: arg1  super layoutPolicy: arg1forceStopStepping  stopStepping := true.  self changeduseCache  self parameters at: 'shouldUseCache' put: trueimplementorsOfIt  self announce: (GLMTextEditorRequest for: #implementorsOfIt)isDependsOnChildren: arg1  ^(self stateOf: arg1) isOnChildrenhighlightSmalltalkContext: arg1  highlightSmalltalkContext := arg1smooth: arg1  smooth := arg1isFoundationBrick  ^falsetestPublishing  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #classes.  tmp1 sendToOutside: #selectedClass from: #classes -> #selection.  tmp1 sendTo: #classes -> #highlight fromOutside: #highlightedClass.  (tmp1 panes first port: #selection) value: 42.  self assert: (tmp1 pane port: #selectedClass) value equals: 42.  self assert: (tmp1 panes first port: #selection) value equals: 42.  (tmp1 pane port: #highlightedClass) value: 43.  self assert: (tmp1 pane port: #highlightedClass) value equals: 43.  self assert: (tmp1 panes first port: #highlight) value equals: 43.  (tmp1 panes first port: #highlight) value: 44.  self assert: (tmp1 pane port: #highlightedClass) value equals: 43.  self assert: (tmp1 panes first port: #highlight) value equals: 44.  (tmp1 pane port: #selectedClass) value: 45.  self assert: (tmp1 pane port: #selectedClass) value equals: 45.  self assert: (tmp1 panes first port: #selection) value equals: 42testCopyRootPrototype  | tmp1 tmp2 tmp3 |  tmp1 := GLMPresentation new.  tmp2 := tmp1 copy.  self assert: tmp2 rootPrototype equals: tmp1.  self assert: tmp2 parentPrototype equals: tmp1.  tmp3 := tmp2 copy.  self assert: tmp3 rootPrototype equals: tmp1.  self assert: tmp3 parentPrototype equals: tmp2pathIn: arg1  self parentNode ifNotNil: [ (arg1 includes: self parentNode) ifFalse: [ self parentNode pathIn: arg1 ] ].  arg1 add: self.  ^arg1formatLogic  ^self valueOfProperty: #phlowFormat ifAbsent: [ #yourself ]testTypeOfMultipleSelection  | tmp1 tmp2 tmp3 |  tmp1 := GLMCompositePresentation new.  tmp1 list beMultiple.  window := tmp1 openOn: {{1} asSet .         {1} asOrderedCollection}.  tmp2 := self find: MorphTreeMorph in: window.  tmp3 := tmp2 scroller submorphs first.  self send: tmp2 mouseUpOnItem: tmp3.  self assert: tmp1 selection asOrderedCollection equals: {{1} asSet} asOrderedCollectionmessageBrick: arg1  messageBrick := arg1.  self messageBrick     hSpaceFill;     vAlign: #center;     margin: 10;     text: self privacyMessage.  self addBrickBack: self messageBrickweightValue: arg1  self label weightValue: arg1.  self dotsBrick weightValue: arg1left  ^GLMSouthDirection uniqueInstancematchingPresentations  ^self presentations select: [:arg1 |  arg1 matches ]formatedDisplayValueOf: arg1  ^self cacheAt: #formatedDisplayValue for: arg1 ifAbsentPut: [ self glamourPresentation formatedDisplayValueOf: arg1 ]showOnlyBrowser  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list           display: [:arg2 |  1 to: arg2 * 3 ];           showOnly: 50 ].  tmp1 transmit     to: #two;     from: #one;     andShow: [:arg1 |  arg1 list           display: [:arg2 |  1 to: arg2 * 3 ];           showOnly: 50 ].  tmp1 transmit     to: #one;     from: #two;     andShow: [:arg1 |  arg1 list           display: [:arg2 |  1 to: arg2 * 3 ];           showOnly: 50 ].  ^tmp1buildLabelFrom: arg1 withAction: arg2  | tmp1 tmp2 |  tmp2 := arg1 isMorph ifTrue: [ arg1 ] ifFalse: [ | tmp3 tmp4 |        tmp3 := GLMBrick new.        tmp4 := GLMLabelBrick new           text: arg1;           textColor: tmp3 themer textSecondaryColor;           hSpaceFill;           vSpaceFill;           marginLeft: 5.        tmp3           addBrickBack: tmp4;           hSpaceFill;           vSpaceFill.        tmp3 maxWidth: [ 5 + tmp4 approximateWidth + (arg2 ifNotNil: [:arg3 |  arg3 normalImage width * 1.5 ] ifNil: [ 0 ]) ].        tmp3 ].  tmp1 := arg2 ifNil: [ tmp2 ] ifNotNil: [ arg2           vSpaceFill;           width: arg2 normalImage width * 1.5.        tmp2 addBrickBack: arg2.        tmp2 ].  ^tmp1column: arg1 evaluated: arg2 tags: arg3  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           tags: arg3)initialize  super initialize.  self band useVerticalLinearLayoutwithColumns  ^withColumns ifNil: [ withColumns := false ]testMinWidthOneStatic  | tmp1 |  tmp1 := self newBrickWithSmallStaticExtent.  tmp1 minWidth: self staticWidth.  tmp1 doLayoutForce.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 brickBounds equals: (0 @ 0 extent: self staticWidth @ self staticSmallHeight)fastList  ^self custom: GLMFastListPresentation newpager  ^self custom: GLMPager newrubricTextColor: arg1  self setProperty: #brickRubricTextColor toValue: arg1.  self updateStylecomputeOriginFor: arg1  | tmp1 tmp2 |  arg1 textArea scrollSelectionIntoView: nil.  tmp1 := (self originMorphFor: arg1) positionInWorld y - 6.  tmp2 := (self originMorphFor: arg1) right + arg1 positionInWorld x + 6.  ^tmp2 @ tmp1actualPageMorph  ^actualPageMorph ifNil: [ actualPageMorph := self lazyPageMorphCreation value           hResizing: #spaceFill;           vResizing: #spaceFill;           yourself ]updateStyle  self borderWidth: self themer buttonBorderWidth.  self borderColor: self themer buttonBorderColor.  self padding: self themer buttonPadding.  self normalColor: self themer buttonBackgroundColor.  self selectedColor: self themer buttonSelectedColor.  self pressedColor: self themer buttonPressedColor.  self minWidth: self themer buttonMinWidth.  self minHeight: self themer buttonMinHeight.  self doLayoutForcesimilar: arg1  ^(self class direction: self direction)     length: arg1;     yourselfisLayotingAllowed  ^self valueOfProperty: #brickLayoutingAllowed ifAbsent: [ true ]useImplicitAllNil  implicitAllNil := truetransformed: arg1  self transformation: arg1doItContext: arg1  doItContext := arg1receive: arg1 in: arg2  self seenTransmissions addLast: arg1.  ^super receive: arg1 in: arg2scrollValue  ^currentScrollDeltacolumn: arg1  ^self addColumn: arg1expand  self contentBrick ifNil: [ ^self ].  self isExpanded ifFalse: [ self addBrickBack: self contentBrick ]leftPosition: arg1  leftPosition := arg1scrollTo: arg1 smooth: arg2  self scrollTo: arg1page: arg1  page := arg1newTabSelectorMorph  ^GLMTabSelectorBrick new     minHeight: self theme buttonMinHeight;     hSpaceFill;     vResizing: #shrinkWrapinitializeListeners  self activeHand addEventListener: selfstrongSelectionValue: arg1  strongSelectionValue := arg1glamourValueWithArgs: arg1  ^arg1 anySatisfy: [:arg2 |  arg2 notNil ]rubricTextFontSize: arg1  self setProperty: #brickRubricTextFontSize toValue: arg1.  self updateStyletheme  ^Smalltalk ui thememodel: arg1  adaptor := arg1.  self initializeItemsupdateOn: arg1 from: arg2  updateActions add: (GLMSingleUpdateAction new           presentation: self;           announcement: arg1;           transformation: arg2;           yourself)hoverIcon  ^self selectedImageaPane: arg1  ^self addNewPaneNamed: arg1onScrollBoundsChanged: arg1  self markButtonsInside: arg1 boundstestExplicitNotNilMultipleValues  | tmp1 |  tmp1 := GLMPresentation new.  tmp1 useExplicitNotNil.  (tmp1 pane port: #entity) value: (GLMMultiValue withAll: #(nil nil)).  self assert: tmp1 matches not.  (tmp1 pane port: #entity) value: (GLMMultiValue withAll: #(1 nil)).  self assert: tmp1 matches.  (tmp1 pane port: #entity) value: (GLMMultiValue withAll: #(nil 1)).  self assert: tmp1 matches.  (tmp1 pane port: #entity) value: (GLMMultiValue withAll: #(1 2)).  self assert: tmp1 matchesallActionsWithShortcuts  ^self allActions , self allSelectionActions select: [:arg1 |  arg1 hasShortcut ]* arg1  < return: #Point>  ^self subclassResponsibilitytestNamed  | tmp1 |  tmp1 := GLMPane named: 1.  self assert: tmp1 name equals: 1.  self assert: tmp1 browser equals: GLMNoBrowser new.  self assertEmpty: tmp1 ports.  self assert: tmp1 presentations isEmptypaneNamed: arg1  ^self panes detect: [:arg2 |  arg2 name = arg1 ]presentations  < debuggingStone: #presentationCreation label: 'Presentation creation'>  | tmp1 |  tmp1 := GLMCompositePresentation new.  self presentationsFactory glamourValue: tmp1 asGlamorousMultiValue , (self transmission origins collect: #value).  ^tmp1shouldUseCache  ^self glamourPresentation shouldUseCachehasProperty: arg1  ^super hasProperty: arg1maxPanes: arg1  maxPanes := arg1onLayoutEvent: arg1  selectionInterval: arg1  (self pane port: #selectionInterval) value: arg1actOnPresentationUpdated: arg1  container removeAllMorphs.  container addMorphBack: (self morphFrom: arg1 presentation)tagsFilterBlock  ^tagsFilterBlocktestTabsWithTitle  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 title: 'title'.        arg1 list.        arg1 text ].  window := tmp1 openOn: 42.  self assert: self compositeTabGroup submorphs size equals: 2.  self assert: self compositeTabGroup submorphs first class equals: GLMPanelMorph.  self assert: self compositeTabGroup submorphs first submorphs size equals: 1.  self assert: self compositeTabGroup submorphs first submorphs first class equals: LazyTabGroupMorph.  self assert: self compositeTabGroup submorphs first submorphs first pages size equals: 2testResetValue  | tmp1 |  tmp1 := GLMTestPane new port: #port1.  tmp1 value: 42.  self assert: tmp1 value equals: 42.  tmp1 resetValue.  self assert: tmp1 value isNilhighlightSmalltalk: arg1  highlightSmalltalk := arg1taskbarIcon  ^self titleIconbuild: arg1 trigger: arg2 content: arg3  arg1 removeAllBricks.  arg1 contentBrick: arg3.  arg1 triggerBrick: arg2scrollByKeyboard: arg1  | tmp1 |  (self isKeyboardScrollEvent: arg1) ifFalse: [ ^self ].  self velocity: (self calculateVelocity: arg1).  arg1 keyValue = 30 ifTrue: [ tmp1 := #up ].  arg1 keyValue = 31 ifTrue: [ tmp1 := #down ].  self scrollBy: velocity direction: tmp1asString  ^'vertical'width  ^self brick widthprivateThemer  ^self valueOfProperty: #brickThemer ifAbsentPut: [ nil ]newPane: arg1  newPane := arg1presentation: arg1  presentation := arg1column: arg1 evaluated: arg2  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2)columns  ^columns ifNil: [ columns := OrderedCollection new ]normalColor  ^normalColorelementColumn  | tmp1 tmp2 |  tmp2 := GLMMorphicPaneWithoutTitleRenderer new render: self containerNode item.  tmp2 borderStyle: (UITheme current buttonSelectedBorderStyleFor: tmp2).  tmp1 := OrderedCollection with: tmp2.  ^UITheme current newRowIn: self currentWorld for: tmp1testUpdate  | tmp1 tmp2 tmp3 |  tmp1 := OrderedCollection with: 1 with: 2.  tmp2 := GLMPane named: 'test'.  tmp3 := GLMListPresentation new.  tmp2 addPresentation: tmp3.  tmp3 entity: tmp1.  tmp3 shouldValidate: true.  tmp3 update.  tmp3 selection: 2.  self assert: tmp3 selection equals: 2.  tmp1 removeLast.  tmp3 update.  self assert: tmp3 selection isNilfromOutsidePort: arg1 transformed: arg2  ^self from: #outer port: arg1 transformed: arg2render: arg1  | tmp1 |  tmp1 := GLMMorphic containerMorph.  self initializeAnnouncementForPresentation: arg1.  self initializeTableModel: arg1.  self initializeTableMorph.  self addFastTableIn: tmp1.  arg1 selection ifNotNil: [ tableModel announcer suspendAll: self suspendedAnnouncements while: [ tableModel explicitSelection: arg1 selection ] ].  ^tmp1update  self panes do: [:arg1 |  arg1 update ].  self announce: (GLMPresentationUpdated new presentation: self)hasTags  ^self columns anySatisfy: [:arg1 |  arg1 hasTags ]shouldRootsExpand  ^rootsExpanded ifNil: [ false ]on: arg1  arg1 layoutProperties ifNil: [ arg1 layoutProperties: GLMBrickLayoutProperties new.        arg1 layoutProperties           hSpaceFill;           vSpaceFill ].  (arg1 layoutProperties isKindOf: GLMBrickLayoutProperties) ifTrue: [ self layoutProperties: arg1 layoutProperties ].  morph := arg1.  morph layoutProperties: GLMBrickLayoutProperties new.  morph layoutProperties     hSpaceFill;     vSpaceFill.  self addBrickBack: morph.  super brickBounds: (0 @ 0 extent: morph width @ morph height)lastActivePresentation: arg1  (self port: #activePresentation) value: arg1.  lastActivePresentation := arg1.  self browser lastActivePresentation: arg1updateSizing  | tmp1 |  tmp1 := sizing.  self basicUpdateSizing.  sizing = tmp1 ifFalse: [ self layoutPanes ].  ^sizingbuttonModel: arg1  buttonModel := arg1widthMyselfDependency: arg1  ^arg1 layout width brickValue: arg1 bricksettingsButtonLabel  ^self sendUsageData ifTrue: [ 'Change preferences' ] ifFalse: [ 'Go to settings' ]morph  | tmp1 |  tmp1 := RubScrolledTextMorph new     getSelectionSelector: #primarySelectionInterval;     model: textModel;     beForSmalltalkScripting;     textFont: StandardFonts codeFont;     color: self theme backgroundColor;     notificationStrategy: GLMPopperNotificationStrategy new;     yourself.  (tmp1 textArea decoratorNamed: #shoutStyler) ifNotNil: [:arg1 |  arg1 refreshStyling ].  ^tmp1clippingBounds  ^self fullBoundsouterBounds  ^self fullBoundsnewHintBrick  ^GLMLabelBrick new     text: self hintText;     padding: #(0 10);     width: [:arg1 |  arg1 approximateWidth ];     height: [:arg1 |  arg1 approximateHeight ]suspendedAnnouncements  ^OrderedCollection with: GLMTreeMorphSelectionChanged with: GLMTreeMorphStrongSelectionChanged with: GLMMenuItemSelected with: GLMKeyStrokeconvertScrollValue: arg1  self pagerModel actualNumberOfVisiblePages = 0 ifTrue: [ ^0 ].  ^(self width - ((self width / self pagerModel actualNumberOfVisiblePages + self paneMargin) * self band subbricksCount)) * arg1themer  ^self privateThemer ifNotNil: [ self privateThemer ] ifNil: [ self hasOwner ifTrue: [ self owner themer ] ifFalse: [ self theme brickThemer ] ]moveBandBottom  self band translateY: self height - self band brickBounds bottombeSelected  self removeAllBricks.  self addBrickBack: self selectedLabel.  self themer tabLabelThemer selectedStyleFor: self.  self changedtestDifferentHeights  window := GLMScrollListBrick exampleDifferentHeights.  self assert: window isSystemWindowprintOn: arg1  arg1     nextPutAll: 'Port (pane=';     nextPutAll: self pane name printString;     nextPutAll: ' name=';     nextPutAll: self name printString;     nextPutAll: ' value=';     nextPutAll: self value printString;     nextPut: $)elementShouldBeDisplayed: arg1  | tmp1 |  self tagsToFilterBy ifEmpty: [ ^true ].  tmp1 := self glamourPresentation tagsFor: arg1 to: #filter.  ^self tagsToFilterBy allSatisfy: [:arg2 |  tmp1 includes: arg2 ]registeredAnnouncers  ^registeredAnnouncers ifNil: [ registeredAnnouncers := OrderedCollection new ]height: arg1  self vSpaceFill.  super height: arg1vAlign: arg1  < brickBuilderProperty: #Layout name: 'Vertical align' as: #asSymbol getter: #vAlign model: #GLMUIBuilderTextFieldProperty>  self layout vAlign: arg1ownerThatIsA: arg1  ^self firstOwnerSuchThat: [:arg2 |  arg2 isKindOf: arg1 ]isHeightDirty  ^self heightState = #dirtymorph: arg1 withTitleOf: arg2  | tmp1 |  tmp1 := LazyTabGroupMorph new.  tmp1     vResizing: #spaceFill;     hResizing: #spaceFill;     cornerStyle: (self theme tabGroupCornerStyleIn: nil);     font: self theme labelFont.  self flag: 'add a regular page instead of a lazy one'.  self flag: 'handle the PresentationChanged announcement to update the label in the morph. 	The problem is that at the moment I do not know how to link to the label in the tabSelectorMorph'.  tmp1 addLazyPage: arg1 label: (self titleOrIconOf: arg2 in: tmp1) toolbar: (self renderToolbarForPresentation: arg2 inMorph: arg1) action: (self labelActionBrickFor: arg2).  tmp1 selectedPageIndex: 1.  ^tmp1testPopOnePage  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel popPane.  self assert: pagerModel size equals: 1.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 1.  self assert: pagerModel numberOfVisiblePages equals: 2assertNoDuplicatedAnnouncementsIn: arg1  | tmp1 |  tmp1 := (arg1 subscriptions subscriptions groupedBy: [:arg2 |  arg2 announcementClass ]) select: [:arg3 |  arg3 value size > 1 ].  self assert: tmp1 isEmpty description: 'The announcement should have only one subscription of a given type.'testHasStatusbar  | tmp1 |  tmp1 := GLMBrowser new.  self deny: tmp1 hasStatusbar.  tmp1 hasStatusbar: true.  self assert: tmp1 panes size equals: 1.  self assert: tmp1 panes first name equals: GLMBrowser defaultStatusbarPane.  self assert: tmp1 statusbarPane identicalTo: tmp1 panes firsttoggleFilteringByTag: arg1  (self shouldFilterByTag: arg1) ifTrue: [ self tagsToFilterBy remove: arg1 ] ifFalse: [ self tagsToFilterBy add: arg1 ].  self resetChildrenContents.  self changed: #rootNodesonPositionChanged: arg1  self scrollToPane: pagerModel firstVisiblePageIndex smooth: arg1 smooth callback: arg1 callbacktabLabelThemer  ^self registerModule: GLMBrickTabLabelThemer newisFirstAdded  ^(self getIndex: self band firstSubbrick) = 1testTwoDependsOnParentInsideStatic  | tmp1 tmp2 tmp3 |  tmp1 := self newBrickWithStaticExtent.  tmp2 := self newBrickFullHeightAndWidthDependsOnParent: 50.  tmp3 := self newBrickFullHeightAndWidthDependsOnParent: 50.  tmp1     addBrickBack: tmp2;     addBrickBack: tmp3.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp2 brickBounds equals: (0 @ 0 extent: (self staticWidth / 2) @ self staticHeight).  self assert: tmp3 brickBounds equals: ((self staticWidth / 2) @ 0 extent: (self staticWidth / 2) @ self staticHeight)renderBackgroundColorOf: arg1 on: arg2  | tmp1 |  tmp1 := arg1 brickBounds expandBy: arg1 shadowWidth negated.  self renderBackgroundColorOf: arg1 on: arg2 in: tmp1actOnPresentationUpdated: arg1  textModel text: arg1 presentation formatedDisplayValue.  textModel changed: #textlayoutProperties  ^super layoutPropertiesrenderTreePresentation: arg1  ^GLMMorphicTreeRenderer render: arg1 from: selfinitialize  super initialize.  self rubricBackgroundColor: Color transparenttestAssociationAsOriginIdentifier  self assert: ((#pane -> #port) asGlamourOriginIdentifier isKindOf: GLMPortIdentifier).  self assert: (#pane -> #port) asGlamourOriginIdentifier paneName equals: #pane.  self assert: (#pane -> #port) asGlamourOriginIdentifier portName equals: #portpanes  ^self band submorphstransmission  ^transmissionrenderToolbarForPresentation: arg1 inMorph: arg2  | tmp1 tmp2 |  tmp1 := arg2 theme newToolDockingBarIn: arg2.  tmp2 := self toolbarButtonsForPresentation: arg1.  tmp1 addAllMorphs: tmp2.  (arg1 allActions select: #isMenu) ifNotEmpty: [ tmp1 addMorphBack: (self dropDownMenuFrom: [ | tmp3 |                    tmp3 := self menuIn: MenuMorph new for: arg1.                    tmp3 popUpEvent: self currentEvent in: arg2 world ] withIcon: GLMUIThemeExtraIcons glamorousMore) ].  ^tmp1destination  ^destinationtestInterdependentPanesShouldUpdateTheFocusTriggerPaneWithText  | tmp1 tmp2 tmp3 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two;     column: #three.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 text display: [:arg2 |  1 to: arg2 ] ].  tmp1 transmit     to: #two;     from: #one;     andShow: [:arg1 |  arg1 text display: [:arg2 |  1 to: arg2 * 2 ] ].  tmp1 transmit     to: #three;     from: #two;     andShow: [:arg1 |  arg1 text display: [:arg2 |  1 to: arg2 * 3 ] ].  tmp1 transmit     toOutsidePort: #focus;     from: #three port: #focus.  tmp1 transmit     to: #one port: #selection;     fromOutsidePort: #focus;     transformed: [:arg2 |  arg2 + 1 ].  tmp1 transmit     to: #two port: #selection;     fromOutsidePort: #focus;     transformed: [:arg2 |  arg2 + 2 ].  window := tmp1 openOn: 5.  ((tmp1 paneNamed: #one) port: #selection) value: 3.  ((tmp1 paneNamed: #two) port: #selection) value: 6.  tmp2 := (window submorphs last submorphs at: 5) submorphs first submorphs first.  ((tmp1 paneNamed: #three) port: #selection) value: 2.  ((tmp1 paneNamed: #three) port: #focus) value: 1.  self assert: ((tmp1 paneNamed: #one) port: #entity) value equals: 5.  self assert: ((tmp1 paneNamed: #one) port: #selection) value equals: 2.  self assert: ((tmp1 paneNamed: #two) port: #entity) value equals: 2.  self assert: ((tmp1 paneNamed: #two) port: #selection) value equals: 3.  self assert: ((tmp1 paneNamed: #three) port: #entity) value equals: 3.  self assert: ((tmp1 paneNamed: #three) port: #selection) value isNil.  tmp3 := (window submorphs last submorphs at: 5) submorphs first submorphs first.  self assert: tmp2 ~= tmp3drawKeyboardFocusOn: arg1  normalStyleFor: arg1  super normalStyleFor: arg1.  arg1 padding: #(0 1)buttonMinWidth  ^70initialize  super initialize.  self rubric: self newRubricMorph.  self withoutBackground.  self     hSpaceFill;     vSpaceFillcopy  | tmp1 |  self flag: 'perhaps this should be replaced with smarter analysys mechanisms'.  tmp1 := super copy.  tmp1 parentPrototype: self.  ^tmp1highlightSmalltalk  ^highlightSmalltalkhandlesMouseDown: arg1  ^self isEnabled ifTrue: [ true ] ifFalse: [ super handlesMouseDown: arg1 ]testCreation  | tmp1 |  tmp1 := GLMPane named: 1 in: 2.  self assert: tmp1 name equals: 1.  self assert: tmp1 browser equals: 2shouldBeDisplayed  ^self shouldBeDisplayedByTags and: [ self shouldBeDisplayedByText ]hasChildren: arg1  self parameters at: 'hasChildrenBlock' put: arg1widthChildrenDependency: arg1  ^self subclassResponsibilitynewStaticItemFrom: arg1  ^FTStaticBasicItem new     data: arg1 data;     depth: arg1 depth;     children: #();     dataSource: self;     yourselfwithGhostText  ^withGhostTextvPercent  ^self vState percentactOnWindowRequest: arg1  arg1 action value: selfsmooth: arg1  smooth := arg1scrollpaneBackgroundColor  ^Color transparentshouldFilterByAmount  ^self amountToFilterBy notNil and: [ self amountToFilterBy isZero not ]updateWidth  self layout isWidthCustom ifFalse: [ ^self ].  [ self bounds: (self brickBounds withWidth: self customWidth) ] on: Exception do: [  ]closer  ^closerprintOn: arg1  arg1     nextPutAll: self class name;     nextPutAll: ' (origins=';     nextPutAll: self origins printString;     nextPutAll: ' destination=';     nextPutAll: self destination printString;     nextPut: $)invalidateLayout  self layoutPolicy layout: self brickApi in: self wrappedBounds innerBoundsglamourPresentation: arg1  glamourPresentation := arg1actOnPaneAdded: arg1  container brickRoot pushPane: (self renderObject: arg1 pane)unregisterFromAllAnnouncements  super unregisterFromAllAnnouncements.  self panes do: [:arg1 |  arg1 unregisterFromAllAnnouncements ]testNestedCompositesPaneReference  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list.        arg1 text.        arg1 composite: [:arg2 |  arg2 text.              arg2 list ] ].  tmp1 startOn: 42.  (tmp1 paneNamed: #one) presentations do: [:arg3 |  self assert: arg3 pane identicalTo: (tmp1 paneNamed: #one) ].  (tmp1 paneNamed: #one) presentations last do: [:arg3 |  self assert: arg3 pane identicalTo: (tmp1 paneNamed: #one) ]iconFor: arg1  ^self icon glamourValue: arg1 asGlamorousMultiValue , self entity asGlamorousMultiValuebuild: arg1 trigger: arg2 content: arg3  self subclassResponsibilitycomputeTagsFilterFor: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self columns collect: [:arg2 |  tmp1 addAll: (arg2 computeTagsFilterFor: arg1) ].  ^tmp1isAllowedToNotePresentationsChanged  ^allowedToNotePresentationsChanged ifNil: [ allowedToNotePresentationsChanged := true ]renderGlamorouslyOn: arg1  ^arg1 renderStacker: selftitleBrick  ^titleBricktestUnregisterAnnouncements  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Announcer new.  tmp3 := GLMBrowser new.  tmp4 := GLMPane new.  tmp2 := GLMPresentation new.  tmp4 addPresentation: tmp2.  tmp3 addPane: tmp4.  tmp2 updateOn: GLMTestAnnouncement from: [ tmp1 ].  tmp2 registerAnnouncements.  self assert: tmp1 numberOfSubscriptions equals: 1.  tmp3 unregisterFromAllAnnouncements.  self assert: tmp1 numberOfSubscriptions equals: 0testValidatePorts  presentation selection: #($e $f).  self assert: presentation selection equals: #($e $f).  presentation selection: $a.  self assert: presentation selection equals: $a.  presentation selection: 'wrongSelection'.  self assert: presentation selection equals: $atestAssociationAsTargetIdentifier  self assert: ((#pane -> #port) asGlamourTargetIdentifier isKindOf: GLMPortIdentifier).  self assert: (#pane -> #port) asGlamourTargetIdentifier paneName equals: #pane.  self assert: (#pane -> #port) asGlamourTargetIdentifier portName equals: #porthasBindingOf: arg1  ^self variableBindings includesKey: arg1marginTop: arg1  < brickBuilderProperty: #Geometry name: 'Margin Top' as: #asInteger getter: #marginTop model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds marginTop: arg1textFontSize  ^self theme labelFont pointSizetestValidateOn  self assert: (presentation validate: #($e $f) on: (pane port: #selection)).  self assert: (presentation validate: $a on: (pane port: #selection)).  self deny: (presentation validate: $h on: (pane port: #selection))renderGlamorouslyOn: arg1  ^arg1 renderAction: selfupdateTextAreaWhenUnplugged  self withoutStyler.  super updateTextAreaWhenUnpluggedheightChildrenDependency: arg1  ^arg1 paddingTop + arg1 paddingBottom + ((self nonFloatSubbricks: arg1) detectSum: [:arg2 |  arg2 outerBounds height ])renderDropDownListPresentation: arg1  ^GLMMorphicDropDownRenderer render: arg1 from: selfopenOn: arg1  self assert: [ arg1 isNotNil ] description: [ 'Can not open below a nil brick!' ].  self anchorBrick: arg1.  self onCreated.  self announce: #onCreated event: self.  ^self popupLayout open: self with: (arg1 boundsInWorld expandBy: self inset)presentation: arg1  presentation := arg1topOffset  ^self band firstSubbrick brickBounds tophasTitle  ^title notNilbeSuccess  self themer: self themer popupSuccessThemer themeraddPresentation: arg1  self addPresentations: (OrderedCollection with: arg1)doItContext  ^self glamourPresentation doItContextcolorTop: arg1  self color at: Top put: arg1addColumn: arg1 size: arg2  ^(self addColumn: arg1)     size: arg2;     span: 0rubricBorderWidth  ^self valueOfProperty: #brickRubricBorderWidth ifAbsent: [ self themer rubricBorderWidth ]textColor  ^self color darkeninset: arg1  inset := arg1 asMargin.  self updateInsetAndSpacinginitialize  super initialize.  self     width: 300;     textBrick: self newTextBrick;     okButton: self newButtonBricktoolbar: arg1  toolbar := arg1updateHeight: arg1  arg1 isHeightClean ifTrue: [ Exception signal: 'Clean height can''t be updated!' ].  arg1 layout vState updateHeight: arg1 on: selftextModelFor: arg1  | tmp1 |  tmp1 := GLMSmalltalkCodeModel new     text: arg1 formatedDisplayValue;     glamourPresentation: arg1;     highlightSmalltalk: true;     highlightSmalltalkContext: arg1 highlightSmalltalkContext.  self addVariableBindingsOn: tmp1 from: arg1.  arg1 isForScripting ifTrue: [ tmp1 bindingsStrategy: self workspaceBindingsStrategy ].  ^tmp1updateToolbar  self announce: (GLMPresentationToolbarUpdated new presentation: self)font: arg1  buttonsBrick  ^buttonsBrickhintText: arg1  hintText := arg1testAllRecursivePresentations  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 text ].  tmp1 startOn: 42.  self assert: tmp1 panes first withAllPresentations size equals: 2.  self assert: tmp1 pane withAllPresentations size equals: 4dropDownMenuFrom: arg1 withIcon: arg2  | tmp1 tmp2 tmp3 |  tmp1 := arg2.  tmp2 := arg2.  tmp3 := MultistateButtonMorph new extent: tmp1 extent.  ^tmp3     extent: tmp1 extent;     activeEnabledOverUpFillStyle: (ImageFillStyle form: tmp1);     passiveEnabledOverUpFillStyle: (ImageFillStyle form: tmp1);     activeEnabledOverDownFillStyle: (ImageFillStyle form: tmp2);     passiveEnabledOverDownFillStyle: (ImageFillStyle form: tmp2);     addUpAction: arg1;     setBalloonText: 'Menu' translated;     yourselfcolumn: arg1 evaluated: arg2 width: arg3 tags: arg4  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           width: arg3;           tags: arg4;           yourself)testAsGlamorousMultiValue  self assert: (GLMMultiValue with: #(1 2 3)) equals: #(1 2 3) asGlamorousMultiValue.  self assert: 1 asGlamorousMultiValue , 2 asGlamorousMultiValue , 3 asGlamorousMultiValue equals: (GLMMultiValue withAll: #(1 2 3))textInputFor: arg1 withHelpMessage: arg2  | tmp1 |  tmp1 := self theme newTextEntryIn: nil for: arg1 get: #inputText set: #inputText: class: String getEnabled: #inputTextEnabled help: arg2.  tmp1 askBeforeDiscardingEdits: false.  tmp1 ghostText: arg2.  tmp1 layoutFrame: (LayoutFrame identity           topFraction: 1;           topOffset: -26;           bottomOffset: -4).  ^tmp1glamourValueWithArgs: arg1  ^arg1 allSatisfy: [:arg2 |  arg2 isNil not ]fastFramingOn  ^self theme settings fastDragging and: [ self isFlexed not ]explicitSelection: arg1  self table selectIndexes: (self searchText: arg1 asString)evaluateSelectionAndDo: arg1  self announce: (GLMEvaluateSelection new action: arg1)selectedIndex  ^selectedIndex ifNil: [ selectedIndex := 0 ]checkedImage: arg1  checkedImage := arg1tagsToFilterBy  ^tagsToFilterBy ifNil: [ tagsToFilterBy := OrderedCollection new ]initializeScriptingDefaults  super initializeScriptingDefaults.  self cell ifNil: [ self addColumn: #pane ].  self transmissions detect: [:arg1 |  arg1 originatesAt: (self pane port: #entity) ] ifNone: [ self transmit           to: (self panes first port: #entity);           from: #outer port: #entity;           andShow: [:arg2 |  arg2 custom: GLMFlexiblePresentation new ] ]borderColor  ^Color r: 225 g: 124 b: 108 range: 255testTreeSelectionCancellation  | tmp1 tmp2 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 tree allowDeselection ].  window := tmp1 openOn: ($a to: $d).  tmp2 := self treeVisibleItems first.  self send: self tree mouseUpOnItem: tmp2.  self send: self tree mouseUpOnItem: tmp2.  self assert: (tmp1 panes first port: #selection) value isNilshouldShowHeader  ^shouldShowHeader ifNil: [ shouldShowHeader := true ]addNewPaneNamed: arg1  ^self addPane: (GLMPane named: arg1 in: self)render: arg1  | tmp1 tmp2 |  treeModel := GLMTreeMorphModel new glamourPresentation: arg1.  tmp1 := GLMMorphic containerMorph.  treeMorph := self treeMorphFor: treeModel and: arg1.  arg1 allowsInput ifTrue: [ tmp2 := self textInputFor: treeModel withHelpMessage: arg1 helpMessage.        treeMorph layoutFrame bottomOffset: -26.        tmp1 addMorphBack: tmp2 ].  tmp1 addMorphBack: treeMorph.  self installActionsOnModel: treeModel fromPresentation: arg1.  self installKeystrokeActionsOnMorph: treeMorph fromPresentation: arg1.  arg1 selection notNil ifTrue: [ treeModel announcer suspendAll: self suspendedAnnouncements while: [ treeMorph model explicitSelection: arg1 selection ] ].  treeModel announcer when: GLMTreeMorphSelectionChanged do: [:arg2 |  arg1 announcer suspendAllWhile: [ arg1 selection: arg2 selectionValue.              arg1 selectionPath: arg2 selectionPathValue ] ].  treeModel announcer when: GLMTreeMorphStrongSelectionChanged do: [:arg2 |  arg1 strongSelection: arg2 strongSelectionValue ].  arg1 when: GLMContextChanged send: #actOnContextChanged: to: self.  arg1 when: GLMPresentationUpdated send: #actOnUpdatedPresentation: to: self.  ^tmp1okButton  ^okButtonhintDelay: arg1  hintDelay := arg1testAllowNil  | tmp1 tmp2 |  tmp1 := GLMTabulator new.  tmp1     column: [:arg1 |  arg1           row: #one;           row: #two ];     column: #details.  tmp1 transmit     to: #one;     andShow: [:arg2 |  arg2 tree display: #(1 2 3) ].  tmp1 transmit     to: #two;     andShow: [:arg2 |  arg2 tree display: #(#a #b #c) ].  tmp1 transmit     to: #details;     from: #one;     from: #two;     andShow: [:arg2 |  arg2 text           display: [:arg3 :arg4 |  arg3 asString , arg4 asString ];           allowNil ].  window := tmp1 openOn: 42.  ((tmp1 paneNamed: #one) port: #selection) value: 2.  tmp2 := window submorphs last submorphs last submorphs first.  self assert: tmp2 text asString equals: '2nil'.  ((tmp1 paneNamed: #two) port: #selection) value: #c.  tmp2 := window submorphs last submorphs last submorphs first.  self assert: tmp2 text asString equals: '2c'.  ((tmp1 paneNamed: #one) port: #selection) value: nil.  tmp2 := window submorphs last submorphs last submorphs first.  self assert: tmp2 text asString equals: 'nilc'toString: arg1  ^self glamourPresentation hasFilterBlock ifTrue: [ arg1 ] ifFalse: [ super toString: arg1 ]dependencyButtonSize  ^self isDependenciesShown ifTrue: [ self circleButtonSize ] ifFalse: [ 0 ]testNestedBrowserWithExplicitTransmission  | tmp1 tmp2 tmp3 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp2 := GLMTabulator new.  tmp2 column: #innerOne.  tmp2 transmit     to: #innerOne;     from: #outer port: #entity;     andShow: [:arg1 |  arg1 text ].  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 custom: tmp2 ].  tmp1 startOn: 42.  tmp3 := (tmp1 paneNamed: #one) presentations first.  self assert: ((tmp1 paneNamed: #one) port: #entity) value equals: 42.  self assert: ((tmp3 paneNamed: #innerOne) port: #entity) value equals: 42testFrom  browser transmit from: #one.  self assert: browser transmissions first origins first pane equals: browser panes first.  self assert: browser transmissions first origins first name equals: GLMPortIdentifier defaultOriginPortNameglobalInnerBounds  ^self owner ifNotNil: [ self innerBounds translateBy: self owner globalBoundsTranslateFactor ] ifNil: [ self innerBounds ]cachedPresentation  ^cachedPresentationhasMinDimensionRestriction: arg1  ^arg1 layout hasMinWidthpopupPrint  textMorph textArea editor highlightEvaluateAndDo: [:arg1 |  textMorph shoutStyler style: textMorph text.        GLMPrintPopper new openFromRubric: textMorph textArea withResult: arg1 ]pagerModel: arg1  pagerModel := arg1.  self pagerModel announcer when: GLMPagePushed send: #onPagePushed: to: self.  self pagerModel announcer when: GLMPagePoped send: #onPagePoped to: self.  self sliderBrick: self newSliderBrick.  self buttonsBrick: self newButtonsBricktaskThumbnailOfSize: arg1  | tmp1 tmp2 tmp3 |  tmp3 := self globalBounds scaledAndCenteredIn: (0 @ 0 extent: arg1).  tmp1 := Form extent: tmp3 extent depth: Display depth.  tmp2 := MatrixTransform2x3 withScale: tmp1 extent / self extent.  tmp1 getCanvas transformBy: tmp2 clippingTo: tmp1 boundingBox during: [:arg2 |  arg2 translateBy: self globalBounds topLeft negated during: [:arg3 |  self fullDrawOn: arg3 ] ] smoothing: 2.  ^ImageMorph new form: tmp1updateFor: arg1  thumbnail := arg1 taskThumbnailOfSize: self maxExtent.  self image: thumbnail form.  self position: position - ((thumbnail width / 2) @ (thumbnail height + self defaultBottomMargin + self defaultBorderWidth))headerColumn: arg1  arg1 id ifNil: [ ^nil ].  ^SimpleButtonMorph new     layoutPolicy: RowLayout new;     listDirection: #leftToRight;     wrapCentering: #center;     cellInset: 5 @ 0;     layoutInset: 5 @ 0;     label: arg1 id;     target: self;     actionSelector: #actionColumn:;     arguments: {arg1};     yourselfshowFirst: arg1  ^self firstTransmission transmissionStrategy presentationsFactory: arg1column: arg1 evaluated: arg2 width: arg3 tags: arg4  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           width: arg3;           tags: arg4;           yourself)paddingLeft: arg1  < brickBuilderProperty: #Geometry name: 'Padding Left' as: #asInteger getter: #paddingLeft model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds paddingLeft: arg1openOn: arg1 with: arg2  self startOn: arg1.  ^self openWith: arg2presentationsFactory  ^presentationsFactorycolumn: arg1 evaluated: arg2 tags: arg3 filtered: arg4  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           tagsBlock: arg3;           tagsFilter: arg4)buttons  ^buttons ifNil: [ buttons := OrderedCollection new ]headerColumn: arg1  arg1 id ifNil: [ ^nil ].  ^SimpleButtonMorph new     layoutPolicy: RowLayout new;     listDirection: #leftToRight;     wrapCentering: #center;     cellInset: 5 @ 0;     layoutInset: 5 @ 0;     label: arg1 id;     target: self;     actionSelector: #actionColumn:;     arguments: {arg1};     yourselftransmissionStrategy: arg1  transmissionStrategy := arg1shouldBeDisplayedByTags  | tmp1 |  self flag: 'it looks like this method does not really get called for children'.  self containerTree tagsToFilterBy isEmpty ifTrue: [ ^true ].  self withContentsDo: [:arg1 |  tmp1 := self containerTree glamourPresentation tagsFor: arg1 item to: #filter.        (self containerTree tagsToFilterBy allSatisfy: [:arg2 |  tmp1 includes: arg2 ]) ifTrue: [ ^true ] ].  ^falseselectedLabel: arg1  selectedLabel := arg1dataCache  ^dataCache ifNil: [ dataCache := self class defaultCache ]isWithElementIndex  ^self parameters at: 'withRowIndex' ifAbsent: [ false ]textModel: arg1  textModel := arg1.  self textEditBrick ifNotNil: [:arg2 |  arg2 text: self textModel ]actualNumberOfVisiblePages  firstVisiblePageIndex = lastVisiblePageIndex & (firstVisiblePageIndex = 0) ifTrue: [ ^0 ].  ^lastVisiblePageIndex - firstVisiblePageIndex + 1hSpaceFill  self hSpaceFill: 100listBrick  ^scrollListhSpaceFill: arg1  super hSpaceFill: arg1.  hResizing := #spaceFilladdPresentation: arg1  evaluateAndOpenFromRubric: arg1  self openFromRubric: arg1 withResult: arg1 textArea editor evaluateSelectiontitle  ^titlemaxExtent  ^300 @ 300theme  ^Smalltalk ui themeicon: arg1  self normalImage: arg1.  self doLayoutForceglamourPresentation: arg1  glamourPresentation := arg1testSimplePort  | tmp1 |  tmp1 := GLMSimplePort new.  tmp1 name: #foo.  tmp1 value: 42.  self assert: tmp1 name equals: #foo.  self assert: tmp1 value equals: 42.  self assert: tmp1 hasPane notmenu: arg1 shifted: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Dictionary new.  tmp4 := self containerTree allMenuActions.  tmp4 do: [:arg3 |  tmp2 := arg3 category notNil ifTrue: [ tmp1 at: arg3 category ifAbsentPut: [ tmp3 := MenuMorph new.                    arg1 add: arg3 category subMenu: tmp3.                    tmp3 ] ] ifFalse: [ arg1 ].        (tmp2 add: arg3 title target: self selector: #executeMenuAction: argument: arg3)           enabled: (arg3 isEnabledOn: self containerTree glamourPresentation);           icon: arg3 icon;           keyText: (arg3 hasShortcut ifTrue: [ arg3 shortcutAsString ] ifFalse: [ nil ]).        (arg3 separatorAfter and: [ tmp4 last ~= arg3 ]) ifTrue: [ tmp2 addLine ] ].  ^arg1newBand  ^GLMScrollPaneBandBrick newshouldRootsExpand: arg1  rootsExpanded := arg1bindingThemer  ^self registerModule: GTPlayBindingThemer newrecomputeState  self recomputeState: trueonThemerChanged  self changedtextBrick  ^textBrickinitialize  super initialize.  condition := truevelocityValue: arg1  | tmp1 |  tmp1 := arg1 <= self class defaultScrollTurboTime ifTrue: [ 2 ] ifFalse: [ 1 ].  ^self velocity + (self class defaultScrollAcceleration * tmp1) min: self calculateMaxVelocitycheck  self box check.  self label check.  super checklabel  ^labelBrickaddDupHandle: arg1  animation: arg1  animationLogic := arg1isTopOverscrolled  ^self bandTopOffset > 0suspendAll: arg1 while: arg2  | tmp1 |  tmp1 := suspendedAnnouncemets.  suspendedAnnouncemets := arg1 copy.  arg2 ensure: [ suspendedAnnouncemets := tmp1 ]maxWidth  ^maxWidth ifNil: [ maxWidth := Float infinity ]children: arg1  self shouldNotImplementisWithElementIndex  ^self parameters at: 'withRowIndex' ifAbsent: [ false ]hShrinkWrap  super hShrinkWrap.  self label hShrinkWrapinitialize  super initialize.  self     vShrinkWrap;     hSpaceFilldisplayLogic  ^self valueOfProperty: #phlowDisplay ifAbsent: [ #yourself ]selectedMethod  ^self doItContext ifNil: [ nil ] ifNotNil: [:arg1 |  arg1 method ]popup: arg1 event: arg2  < return: #Boolean>  ^arg2 type = #mouseMove and: [ (arg1 isInsideOfPopupBrick: arg2) not ]renderer: arg1  renderer := arg1rowHeightBlock  ^self parameters at: 'rowHeight' ifAbsent: [ self class defaultRowHeight ]count  self subclassResponsibilitytestTreeSelection  | tmp1 tmp2 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 tree ].  window := tmp1 openOn: ($a to: $d).  tmp2 := self treeVisibleItems first.  self send: self tree mouseUpOnItem: tmp2.  self assert: (tmp1 panes first port: #selection) value equals: $aupdateScrollbar  self verticalScrollbar ifNotNil: [:arg1 |  arg1 updatePosition ]scrollPageUp  self     scrollUp: self calculateMaxVelocity;     update;     changedwidthState: arg1  widthState := arg1newStringBrick  ^GLMStringBrick newtreeVisibleItems  ^self tree scroller submorphssetUp  | tmp1 tmp2 tmp3 tmp4 |  super setUp.  browser := GLMExplicitBrowser new.  tmp1 := browser addNewPane name: 'pane1'.  tmp2 := browser addNewPane name: 'pane2'.  tmp3 := GLMTransmission new     addActiveOrigin: (tmp2 port: #selection);     destination: (GLMPresentationBoundPort new           name: #selection;           presentation: browser;           yourself);     yourself.  browser addTransmission: tmp3.  tmp4 := GLMTransmission new     ensureReplacePresentationsStrategy;     addActiveOrigin: (tmp1 port: #selection);     destination: (tmp2 port: #entity);     addPresentation: (GLMPresentation new title: 'presentation1');     yourself.  browser addTransmission: tmp4.  copiedBrowser := browser copycolumn: arg1 evaluated: arg2 width: arg3  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           width: arg3;           yourself)hState  ^self layout hStatetestMorphUpdate  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := 42.  tmp1 := GLMTabulator new.  tmp1 row: #morph.  tmp1 transmit     to: #morph;     andShow: [:arg1 |  arg1 morph display: [:arg2 |  tmp2 asString asMorph ] ].  window := tmp1 openOn: 42.  tmp3 := self findLast: StringMorph in: window.  self assert: tmp3 notNil.  self assert: tmp3 contents equals: 42 asString.  tmp2 := 43.  tmp1 update.  tmp4 := self findLast: StringMorph in: window.  self assert: tmp4 ~= tmp3.  self assert: tmp4 notNil.  self assert: tmp4 notNil.  self assert: tmp4 contents equals: 43 asStringhasMaxWidth  ^(self maxWidth isNumber ifTrue: [ self maxWidth isInfinite ] ifFalse: [ false ]) notactionName  ^self parameters at: 'actionName' ifAbsent: 'Validate'renderActionListPresentation: arg1  ^GLMMorphicActionListRenderer render: arg1 from: selfneedActionButton  ^self parameters at: 'actionBlock' ifPresent: [ true ] ifAbsent: [ false ]outerPortEvent: arg1  arg1 port name = #entity ifFalse: [ ^self ].  panes := nil.  self matches ifTrue: [ (self transformation glamourValue: arg1 port value) do: [:arg2 |  self addPaneFrom: (GLMSimplePort new value: arg2) ] ]keyStroke: arg1 from: arg2  | tmp1 |  tmp1 := self allKeystrokeActions detect: [:arg3 |  arg3 shortcut = arg1 keyCharacter ] ifNone: [ nil ].  tmp1 ifNotNil: [ self announce: (GLMKeyStroke action: tmp1) ]selectedPageIndex: arg1  | tmp1 |  tmp1 := self normalizePaneIndex: arg1.  (self isPaneVisible: tmp1) ifFalse: [ self scrollToPane: (tmp1 < self firstVisiblePageIndex ifTrue: [ tmp1 ] ifFalse: [ tmp1 - self numberOfVisiblePages + 1 ]) ].  selectedPageIndex := tmp1.  self focusPaneAt: tmp1.  self notifySelectedPageChanged.  self invariantscrollToRight  scrollBar glmAnimateValue: 1.0 duration: 200removePage: arg1  | tmp1 |  tmp1 := self pages indexOf: arg1.  self announcer suspendAllWhile: [ super removePage: arg1 ].  self announcer announce: (LazyTabPageRemoved new           tabs: self;           page: arg1;           pageIndex: tmp1;           newIndex: self tabSelectorMorph selectedIndex).  self pages isEmpty ifTrue: [ self contentMorph removeAllMorphs ]toggleExpandedState: arg1 event: arg2  super toggleExpandedState: arg1 event: arg2.  self resizeColumnscontext  context ifNil: [ context := OrderedCollection new ].  ^contextmenuColumn: arg1 row: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := UIManager default newMenuIn: self table for: self.  tmp2 := Dictionary new.  self allMenuActions do: [:arg3 |  tmp3 := arg3 category notNil ifTrue: [ tmp2 at: arg3 category ifAbsentPut: [ tmp4 := MenuMorph new.                    tmp1 add: arg3 category subMenu: tmp4.                    tmp4 ] ] ifFalse: [ tmp1 ].        (tmp3 add: arg3 title target: self selector: #executeMenuAction: argument: arg3)           icon: arg3 icon;           balloonText: arg3 help;           enabled: (arg3 isEnabledOn: self glamourPresentation);           keyText: (arg3 hasShortcut ifTrue: [ arg3 shortcutAsString ] ifFalse: [ nil ]) ].  ^tmp1asGlamorousMultiValue  ^selfselectionAct: arg1 entitled: arg2 condition: arg3  self addSelectionAction: (GLMGenericAction new           action: arg1;           title: arg2;           condition: arg3;           yourself)testOneDependsOnParentOneDependsOnChildrenInsideStatic  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp5 := 20.  tmp6 := 50.  tmp1 := self newBrickWithStaticExtent.  tmp2 := self newBrickFullHeightAndWidthDependsOnParent: 100.  tmp3 := self newBrickWithFullDependsOnChildren.  tmp4 := GLMBrick new     width: tmp5;     height: tmp6;     yourself.  tmp1 addBrickBack: tmp2.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp2 brickBounds equals: (0 @ 0 extent: self staticExtent).  tmp1 addBrickBack: tmp3.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp2 brickBounds equals: (0 @ 0 extent: self staticExtent).  self assert: tmp3 brickBounds equals: (self staticWidth @ 0 extent: 0 @ 0).  tmp3 addBrickBack: tmp4.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp2 brickBounds equals: (0 @ 0 extent: (self staticWidth - tmp5) @ self staticHeight).  self assert: tmp3 brickBounds equals: ((self staticWidth - tmp5) @ 0 extent: tmp5 @ tmp6).  self assert: tmp4 brickBounds equals: (0 @ 0 extent: tmp5 @ tmp6)select  super select.  self announcer announce: (GLMPagerButtonSelected new buttonModel: self)transmitIn: arg1  self transmission destination hasPane ifTrue: [ self transmission destination pane notingPresentationChangeDo: [ self transmission destination pane clearIn: arg1.              self transmission destination pane presentations: self presentations copy ] ]pasteRecent  self announce: (GLMTextEditorRequest for: #pasteRecent)portName: arg1  portName := arg1tabs: arg1  tabs := arg1updateOn: arg1 fromAll: arg2  updateActions add: (GLMMultipleUpdateAction new           presentation: self;           announcement: arg1;           transformation: arg2;           yourself)testSpawnFinder  | tmp1 |  tmp1 := GLMFinder new.  window := tmp1 openOn: ($a to: $d).  self waitUntilUIRedrawed.  self assert: window submorphs last class equals: GLMPaneScrollerisUpdating  ^isUpdating ifNil: [ isUpdating := false ]when: arg1 send: arg2 to: arg3  self announcer when: arg1 send: arg2 to: arg3glamourPresentation: arg1  glamourPresentation := arg1