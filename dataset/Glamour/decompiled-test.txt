foundationBrick  ^(self owner isKindOf: GLMFoundationBrick) ifTrue: [ self owner ] ifFalse: [ self ]-======-renderBorder: arg1 on: arg2  arg2 drawPolygon: arg1 area vertices color: Color transparent borderWidth: arg1 border widthTop borderColor: arg1 border colorTop-======-click: arg1  | tmp1 |  tmp1 := super click: arg1.  tmp1 ifTrue: [ self closePopup ].  ^tmp1-======-selectedLabel  ^selectedLabel-======-stepAt: arg1  hasInitialStep ifFalse: [ hasInitialStep := true.        ^self ].  super stepAt: arg1-======-submorphAfter  ^self subbrickAfter-======-value  ^value-======-enableFilterWithAction: arg1  self enableFilter.  self parameters at: 'actionBlock' put: arg1-======-pane  ^pane ifNil: [ pane := (GLMPane named: 'root' in: GLMNoBrowser new)           addPresentationSilently: self;           yourself ]-======-updateWidthPercentage  self subbricks ifEmpty: [ ^self ].  self subbricks do: [:arg1 |  arg1 hSpaceFill: 100 / self subbricksCount ]-======-testEmptyList  window := GLMScrollListBrick exampleEmptyCollection.  self assert: window isSystemWindow-======-defaultWaitDuration  ^500 milliSecond-======-announce: arg1  self logger logAnnouncement: arg1 from: self.  super announce: arg1-======-isFocused  ^focused-======-resetChildrenContent  elements := self calculateElements.  self resetDataCache-======-bar  ^bar-======-firstSubbrick  ^self subbricks first-======-drawingBounds: arg1  | tmp1 tmp2 |  tmp1 := arg1 brickBounds.  tmp2 := arg1 shadowOffset.  ^arg1 shadowWidth isZero ifTrue: [ tmp1 ] ifFalse: [ tmp1 quickMerge: ((tmp1 expandBy: arg1 shadowWidth) translateBy: tmp2) ]-======-shouldValidate  ^shouldValidate ifNil: [ shouldValidate := false ]-======-basicElements  ^self glamourPresentation displayValue-======-cancel  self borderColor: self themer color alizarin.  self beNormal-======-mouseDown: arg1  startDragX := arg1 position x - self globalBounds left.  startResizingWidth := self width.  isRightResizing := self isRightResizingZone: arg1.  isRightResizing ifFalse: [ isLeftResizing := self isLeftResizingZone: arg1 ] ifTrue: [ isLeftResizing := false ].  isResizing := isLeftResizing or: isRightResizing.  super mouseDown: arg1-======-rubricBackgroundColor  ^self valueOfProperty: #brickRubricBackgroundColor ifAbsent: [ self themer rubricBackgroundColor ]-======-renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderRubricTextPresentation: self-======-newBand  ^super newBand height: [:arg1 |  arg1 subbricks isEmpty ifTrue: [ 0 ] ifFalse: [ arg1 lastSubbrick brickBounds bottom ] ]-======-doesNotUnderstand: arg1  ^self rubric perform: arg1 selector withArguments: arg1 arguments-======-compositeMorph  ^window submorphs last submorphs last submorphs last-======-replaceFrom: arg1 to: arg2 with: arg3  self okToStyle ifFalse: [ ^next replaceFrom: arg1 to: arg2 with: arg3 ].  self disableDrawingWhile: [ arg3 addAttribute: self defaultFontChange.        text ifNil: [ text := self text ].        text replaceFrom: arg1 to: arg2 with: (self styler format: arg3).        self style: text.        next text: text.        self recomposeFrom: arg1 to: arg1 + arg3 size - 1 delta: arg3 size - (arg2 - arg1 + 1).        self textArea paragraphWasComposedFrom: arg1 to: arg1 + arg3 size - 1.        self textArea paragraphReplacedTextFrom: arg1 to: arg2 with: arg3 ]-======-installEntity  self textBrick setTextWith: (self displayLogic phlowValue: self entity).  self textBrick selectionInterval: (self selectionInterval phlowValue: self entity)-======-resetInput  self updateRoots-======-render: arg1  ^self subclassResponsibility-======-onDoubleClick  self announcer announce: (GLMTreeMorphStrongSelectionChanged new strongSelectionValue: (self selection ifNotNil: [ self selection selectedItemOrItemsOrNil ]))-======-isButton  ^self hasIcon-======-defaultBrowser  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 * 3 ] ].  tmp1 transmit     to: #two;     from: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 * 3 ] ].  tmp1 transmit     to: #one;     from: #two;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 * 3 ] ].  ^tmp1-======-initialize  super initialize.  isSyncronous := false-======-testLeftFloatingMySelfDependencyWithMargin  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := 10.  tmp2 := #left.  tmp1 := self newBrickWithStaticExtent.  tmp4 := self newBrickWithSmallStaticExtent.  tmp4 marginLeft: tmp3.  tmp4 layout floating: tmp2.  tmp1 addBrickBack: tmp4.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp4 extent equals: self staticSmallExtent.  self assert: tmp4 brickBounds equals: (tmp3 @ 0 extent: self staticSmallExtent)-======-floatingMethodFor: arg1  ^('layoutFloating' , arg1 capitalized , ':in:') asSymbol-======-testPaneCreation  | tmp1 |  tmp1 := GLMFinder new.  tmp1 addPresentation: (GLMPresentation new title: 'presentation1').  self assert: tmp1 panes isEmpty.  (tmp1 pane port: #entity) value: #value1.  self assert: tmp1 panes size equals: 1.  self assert: tmp1 panes first browser identicalTo: tmp1.  self assert: (tmp1 panes first port: #entity) value equals: #value1.  self assert: tmp1 panes first presentations size equals: 1.  self assert: tmp1 panes first presentations first title equals: 'presentation1'.  self assert: tmp1 panes first presentations first ~~ tmp1 transmission transmissionStrategy presentations first.  (tmp1 panes first port: #selection) value: #value2.  self assert: tmp1 panes size equals: 2.  self assert: tmp1 panes last browser identicalTo: tmp1.  self assert: (tmp1 panes last port: #entity) value equals: #value2.  self assert: tmp1 panes last presentations first title equals: 'presentation1'.  self assert: tmp1 panes last presentations first ~~ tmp1 transmission transmissionStrategy presentations first.  self assert: tmp1 panes last presentations first ~~ tmp1 panes first presentations first.  (tmp1 panes last port: #selection) value: #value3.  self assert: tmp1 panes size equals: 3.  self assert: tmp1 panes last browser identicalTo: tmp1.  self assert: (tmp1 panes last port: #entity) value equals: #value3.  (tmp1 panes first port: #selection) value: #value4.  self assert: tmp1 panes size equals: 2.  self assert: tmp1 panes last browser identicalTo: tmp1.  self assert: (tmp1 panes last port: #entity) value equals: #value4.  (tmp1 pane port: #entity) value: #value5.  self assert: tmp1 panes size equals: 1.  self assert: tmp1 panes last browser identicalTo: tmp1.  self assert: (tmp1 panes last port: #entity) value equals: #value5-======-state  ^#vState-======-onThemerChanged  self updateStyle-======-markClean: arg1  ^self subclassResponsibility-======-addAllBricks: arg1  self brickRoot addAllBricks: arg1-======-copyAccordingToPaneMapping: arg1 inNewBrowser: arg2  ^self copy presentation: arg2-======-customDependencies: arg1  ^arg1 layout heightDependencies-======-dimension: arg1  dimension := arg1-======-prioritySortedSubbricks: arg1  | tmp1 |  tmp1 := OrderedCollection newFrom: arg1 subbricks.  tmp1 sort: [:arg2 :arg3 |  (self isDependsOnParent: arg2) ifFalse: [ true ] ifTrue: [ (self isDependsOnParent: arg3) ifFalse: [ false ] ifTrue: [ (self hasDimensionRestrictions: arg2) ifFalse: [ false ] ifTrue: [ (self hasDimensionRestrictions: arg3) ifFalse: [ true ] ifTrue: [ (self hasMinDimensionRestriction: arg2) ifFalse: [ false ] ifTrue: [ true ] ] ] ] ] ].  ^tmp1-======-sorted: arg1  sortBlock := arg1-======-testTrasmissions  self assert: copiedBrowser transmissions size equals: 2.  self assert: copiedBrowser transmissions first ~~ browser transmissions first.  self assert: copiedBrowser transmissions last ~~ browser transmissions last.  self assert: (copiedBrowser transmissions first destination pane browser isKindOf: GLMNoBrowser).  self assert: copiedBrowser transmissions last destination pane browser identicalTo: copiedBrowser.  self assert: copiedBrowser transmissions first origins first pane browser identicalTo: copiedBrowser.  self assert: copiedBrowser transmissions last origins first pane browser identicalTo: copiedBrowser-======-text  ^(self pane port: #text) value ifNil: [ self textBlock value ] ifNotNil: [ (self pane port: #text) value ]-======-scrollToPane: arg1 smooth: arg2  self scrollTo: (pagerModel convertIndexToValue: arg1) smooth: arg2-======-testWithDisplay  < expectedFailure>  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := GLMTabulator new     column: #stacker;     yourself.  tmp1 transmit     to: #stacker;     andShow: [:arg1 |  arg1 dynamic display: [:arg2 |  | tmp6 |              tmp6 := GLMStacker new.              tmp6 aPane: #all.              tmp6 transmit                 to: #all;                 andShow: [:arg3 |  arg3 text display: [ 'All ' , arg2 asString ] ].              tmp6 ] ].  window := tmp1 openOn: 10.  tmp2 := tmp1 panes first presentations first.  tmp3 := tmp2 cachedPresentation first.  self assert: tmp3 panes first presentations size equals: 1.  tmp4 := tmp3 panes first presentations first.  tmp5 := self findWherePresentationIs: tmp4 in: window.  self assert: tmp5 text asString equals: 'All 10'-======-hShrinkWrap  super hShrinkWrap.  self labelBrick hShrinkWrap.  self editBrick hShrinkWrap-======-shouldFilterByTag: arg1  ^self tagsToFilterBy includes: arg1-======-transmission  ^transmission ifNil: [ transmission := GLMTransmission new ensureReplacePresentationsStrategy.        transmission ]-======-isOnMyself  ^true-======-beCentered  isCentered := true.  self isVFilling ifTrue: [ self rubric forceHeight: [ self height - self vPadding ] ]-======-testTo  browser transmit to: #one.  self assert: browser transmissions first destination pane equals: browser panes first.  self assert: browser transmissions first destination name equals: GLMPortIdentifier defaultTargetPortName-======-settingsButtonBrick: arg1  settingsButtonBrick := arg1.  self settingsButtonBrick     text: self settingsButtonLabel;     hShrinkWrap;     vAlign: #center;     margin: 10;     when: #onClicked do: [ self openSettingsBrowser ].  self addBrickBack: self settingsButtonBrick-======-unregisterFromAllAnnouncements  updateActions do: [:arg1 |  arg1 unregisterFromAllAnnouncements ]-======-resetDataCache  dataCache := nil-======-hintText  ^hintText ifNil: [ hintText := 'Need help?' ]-======-actOnPresentationUpdated: arg1  self setLabelOf: window for: arg1 presentation-======-testShortcutFromKeymap  | tmp1 tmp2 |  tmp2 := Smalltalk os defaultModifier.  tmp1 := GLMAction new.  tmp1 keymap: tmp2 + $i asShortcut.  self assert: tmp1 keymap equals: tmp2 + $i asShortcut.  tmp1 keymap: tmp2 + $i shift.  self assert: tmp1 keymap equals: tmp2 + $i shift.  tmp1 keymap: nil.  self assertEmpty: tmp1 shortcutAsString-======-removeProperty: arg1  super removeProperty: arg1-======-testPortsInmmutability  < expectedFailure>  | tmp1 tmp2 |  tmp1 := GLMPane in: 1.  self assertEmpty: tmp1 ports.  tmp2 := tmp1 ports.  tmp2 add: 1.  self assert: tmp2 size equals: 1.  self assertEmpty: tmp1 ports-======-addAllBricks: arg1  | tmp1 |  tmp1 := self privateAddAllBricks: arg1.  tmp1 do: [:arg2 |  self privatePrepareBrickAfterAdding: arg2 ].  self doLayoutForce.  ^arg1-======-minWidth  ^minWidth ifNil: [ minWidth := 0 ]-======-testSelectionAvailableWhenNoSelectionDisabled  | tmp1 |  tmp1 := GLMPresentation new.  tmp1 selection: 1.  self assert: tmp1 selection equals: 1.  self assert: tmp1 rawSelection equals: 1-======-paddingLeft: arg1  self padding at: Left put: arg1.  self updateCache-======-list: arg1  list := arg1-======-addContentsMorph  self contentsMorph: GLMMorphic emptyMorph.  self contentsMorph     layoutFrame: (LayoutFrame identity           leftOffset: 10;           topOffset: 10;           rightOffset: -10;           bottomOffset: -10);     hResizing: #spaceFill;     vResizing: #spaceFill.  self addMorphBack: self contentsMorph-======-updateTabs  | tmp1 |  self removeAllBricks.  self tabs ifEmpty: [ ^self ].  tmp1 := self selectedTab.  self tabs do: [:arg1 |  arg1 selected: arg1 == tmp1.        arg1 hSpaceFill: (100 / self tabs size) asFloat ].  self addAllBricks: self tabs-======-textLightColor  ^Color gray-======-verticallyStackedArrangement  ^self stackedVerticallyArrangement-======-updateState: arg1  self brickBounds width = arg1 width ifFalse: [ self markWidthDirty ].  self brickBounds height = arg1 height ifFalse: [ self markHeightDirty ]-======-testBundleStrategy  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMPane named: 'pane1'.  tmp2 := GLMPane named: 'pane2'.  tmp3 := GLMTransmission new.  tmp3 ensureReplacePresentationsStrategy.  tmp3 addActiveOrigin: (tmp1 port: #port1).  tmp3 destination: (tmp2 port: #port2).  tmp3 addPresentation: GLMPresentation new.  (tmp1 port: #port1) value: 1.  tmp3 transmit.  self assert: tmp2 presentations size equals: 1.  tmp4 := tmp2 presentations first.  (tmp1 port: #port1) value: 2.  tmp3 transmit.  self assert: tmp2 presentations first rootPrototype equals: tmp4 rootPrototype.  self assert: tmp2 presentations first ~~ tmp4-======-dataCache  ^dataCache ifNil: [ dataCache := self class defaultCache ]-======-zIndex  ^self layout zIndex brickValue: self-======-children  ^children ifNil: [ children := OrderedCollection new ]-======-shortcut  ^self keymap ifNotNil: [ self keymap currentCharacter ]-======-cell  ^cell-======-popupEditorShadowThemer  ^self registerModule: [ GLMBrickPopupEditShadowThemer new ] to: self named: #popupThemer-======-textBrick: arg1  textBrick := arg1.  self textBrick wrapped: true.  self textBrick layoutProperties     vSpaceFill;     hSpaceFill.  self addBrickBack: self textBrick-======-leftoverScrollRange  ^(self totalScrollRange - self innerBounds width roundTo: self scrollDeltaWidth) max: 0-======-renderPager: arg1  ^arg1 hasFixedSizePanes ifTrue: [ GLMMorphicPagerRenderer render: arg1 from: self ] ifFalse: [  ]-======-resetContentsRecursively  self resetContents.  self allContents do: [:arg1 |  arg1 resetContentsRecursively ]-======-profileSelection  self announce: GLMProfileSelection-======-renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderRubricHighlightedTextPresentation: self-======-newTextBrick  ^GLMRubEditingAreaBrick new-======-destination: arg1  destination := arg1-======-scrollToBottom  self band hasSubbricks ifFalse: [ ^self ].  self scrollTo: self band lastSubbrick-======-widthLeft: arg1  self width at: Left put: arg1-======-hintBrick: arg1  hintBrick := arg1.  self hintBrick textColor: self themer popupThemer textColor.  self contentBrick addBrickBack: self hintBrick-======-newHeaderMorph  ^(self theme newRowIn: self theme for: {self tabSelectorMorph .         self toolbarMorph})     cellInset: 0;     cellPositioning: #bottomCenter;     borderWidth: 0-======-scrollpane: arg1  scrollpane := arg1-======-actOnPaneRemoved: arg1  container popPane-======-showAt: arg1  self     openInWorld;     align: arg1-======-createSimplePaneMorph  ^Morph new-======-evaluateSelection  self evaluateSelectionAndDo: [:arg1 |  arg1 ]-======-modifiedBlock  ^modifiedBlock-======-when: arg1 send: arg2 to: arg3  self announcer when: arg1 send: arg2 to: arg3-======-resetDataCache  dataCache := nil-======-rowMorphFor: arg1  | tmp1 tmp2 |  tmp1 := arg1 rowMorphForColumn: glamourColumn.  tmp1 ifNotNil: [ tmp1 borderWidth: 0 ] ifNil: [ tmp1 := self defaultRowMorph ].  tmp2 := Morph new     color: Color transparent;     layoutPolicy: RowLayout new;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     layoutInset: container columnInset @ container rowInset;     yourself.  tmp2 addMorph: tmp1.  self isFirstColumn ifTrue: [ | tmp3 |        tmp3 := container iconBlock value: arg1.        tmp3 ifNotNil: [ tmp2 addMorph: tmp3 asMorph ].        tmp2 layoutInset: 0 @ container rowInset ].  ^tmp2-======-paste  self announce: (GLMTextEditorRequest for: #paste)-======-width: arg1  self brickBounds: (self brickBounds withWidth: arg1)-======-calculateScrollbarHeight  | tmp1 tmp2 tmp3 |  tmp1 := self approximateBandHeight.  tmp1 = 0 ifTrue: [ ^0 ].  self scrollPane isFullyVisible ifTrue: [ ^0 ].  tmp2 := self scrollPane getIndex: self scrollPane band firstSubbrick.  tmp3 := self scrollPane getIndex: self scrollPane band lastSubbrick.  ^((tmp3 - tmp2 + 1) / self scrollPane model count * self height) ceiling-======-outOfWorld: arg1  super outOfWorld: arg1.  self brickRoot onRemovedFrom: self-======-hasBindingOf: arg1  ^self variableBindings includesKey: arg1-======-newTreeMorph  ^GLMPaginatedMorphTreeMorph new-======-isForScripting  ^isForScripting ifNil: [ false ]-======-valueFor: arg1 withIndex: arg2 in: arg3  ^self cacheAt: arg3 title for: arg1 ifAbsentPut: [ self glamourPresentation column: arg3 valueFor: (self glamourPresentation isWithElementIndex ifTrue: [ arg1 asGlamorousMultiValue , arg2 asGlamorousMultiValue ] ifFalse: [ arg1 ]) ]-======-render: arg1  | tmp1 |  tmp1 := super render: arg1.  arg1 shouldAllExpand ifTrue: [ treeMorph expandAll ].  arg1 shouldRootsExpand ifTrue: [ treeMorph expandRoots ].  arg1 shouldExpandToLevel ifTrue: [ treeMorph expandAllTo: arg1 expandLevel ].  ^tmp1-======-iconBrick  ^iconBrick-======-onOpened  super onOpened.  self textEditBrick     takeKeyboardFocus;     selectAll-======-custom: arg1  ^self add: arg1-======-actOnTextEditorRequest: arg1  arg1 action value: textMorph textArea editor-======-initialize  super initialize.  self     useHorizontalLinearLayout;     hShrinkWrap-======-hShrinkWrap  self layout hShrinkWrap-======-testFreshBrickIsDirty  self assertBrickDirty: GLMBrick new-======-shadowColor: arg1  < brickBuilderProperty: #'Look&Feel' name: 'Shadow Color' as: #brickBuilderEvaluate getter: #shadowColor model: #GLMUIBuilderTextFieldProperty>  self setProperty: #brickShadowColor toValue: arg1-======-openInBrickWindowLabeled: arg1  ^self class environment at: #GLMSystemWindowBrick ifPresent: [:arg2 |  arg2 new           label: arg1;           color: Color transparent;           addBrickBack: (GLMBrick new vSpaceFill                 hSpaceFill;                 addBrickBack: self;                 yourself);           extent: 400 @ 400 * self currentWorld displayScaleFactor;           openCenteredInWorld ] ifAbsent: [ self asMorph openInWindow ]-======-normalizeWidth: arg1 of: arg2  ^(arg1 max: (arg2 layout minWidth brickValue: arg2)) min: (arg2 layout maxWidth brickValue: arg2)-======-postCopy  port := port copy-======-resolveOriginPort: arg1  ^self resolvePort: arg1 asGlamourOriginIdentifier defaultPortName: #selection-======-testMarkerOneStaticHeight  | tmp1 |  tmp1 := self newBrickWithStaticExtent.  self markFullyClean: tmp1.  tmp1 wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp1 brickApi.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightDirty-======-sendToOutside: arg1 from: arg2  self sendTo: #outer -> arg1 from: arg2-======-calculateScrollbarTopOffset  | tmp1 tmp2 tmp3 |  tmp1 := self approximateBandHeight.  tmp1 = 0 ifTrue: [ ^0 ].  tmp2 := self scrollPane getIndex: self scrollPane band firstSubbrick.  tmp3 := self scrollPane getIndex: self scrollPane band lastSubbrick.  ^((tmp2 - 1) / self scrollPane model count * self height) floor-======-mouseLeave: arg1  super mouseLeave: arg1.  ^self deselect: arg1-======-approximateWidth  ^self label approximateWidth + self hMargin + self hPadding-======-icon  ^nil-======-noActions  actions := nil.  dynamicActionsBlock := nil-======-updateCache  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self brickBounds origin x.  tmp2 := self brickBounds origin y.  tmp3 := self brickBounds corner x.  tmp4 := self brickBounds corner y.  innerBounds := (tmp1 + self paddingLeft) @ (tmp2 + self paddingTop) corner: (tmp3 - self paddingRight) @ (tmp4 - self paddingBottom).  outerBounds := (tmp1 - self marginLeft) @ (tmp2 - self marginTop) corner: (tmp3 + self marginRight) @ (tmp4 + self marginBottom)-======-interval  ^self start to: self end-======-glamourPresentation: arg1  glamourPresentation := arg1-======-color: arg1  color := arg1-======-alizarin  ^Color brickColorRegistry at: #brickAlizarin ifAbsentPut: [ Color r: 231 g: 76 b: 60 range: 255 ]-======-west  direction := West-======-printOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  ports printOn: arg1.  arg1 nextPut: $)-======-portSymbol  ^portSymbol-======-tabLabelThemer  ^self registerModule: GLMBrickTabLabelDarkThemer new-======-testReferences  | tmp1 tmp2 |  tmp1 := GLMExplicitBrowser new.  tmp2 := tmp1 addNewPaneNamed: #pane1.  self assert: (tmp1 resolveOriginPort: #pane1) identicalTo: (tmp2 port: #selection).  self assert: (tmp1 resolveOriginPort: #pane1 -> #foo) identicalTo: (tmp2 port: #foo).  self assert: (tmp1 resolveDestinationPort: #pane1) identicalTo: (tmp2 port: #entity).  self assert: (tmp1 resolveDestinationPort: #pane1 -> #foo) identicalTo: (tmp2 port: #foo).  self assert: ((tmp1 resolveOriginPort: #outer) isKindOf: GLMPresentationBoundPort).  self assert: (tmp1 resolveOriginPort: #outer) presentation identicalTo: tmp1.  self assert: (tmp1 resolveOriginPort: #outer) name equals: #selection.  self assert: ((tmp1 resolveOriginPort: #outer -> #foo) isKindOf: GLMPresentationBoundPort).  self assert: (tmp1 resolveOriginPort: #outer -> #foo) presentation identicalTo: tmp1.  self assert: (tmp1 resolveOriginPort: #outer -> #foo) name equals: #foo.  self assert: ((tmp1 resolveDestinationPort: #outer) isKindOf: GLMPresentationBoundPort).  self assert: (tmp1 resolveDestinationPort: #outer) presentation identicalTo: tmp1.  self assert: (tmp1 resolveDestinationPort: #outer) name equals: #entity.  self assert: ((tmp1 resolveDestinationPort: #outer -> #foo) isKindOf: GLMPresentationBoundPort).  self assert: (tmp1 resolveDestinationPort: #outer -> #foo) presentation identicalTo: tmp1.  self assert: (tmp1 resolveDestinationPort: #outer -> #foo) name equals: #foo-======-first  ^self presentations first-======-testSuspendAllWhile  | tmp1 tmp2 |  announcer when: GLMTestAnnouncement do: [:arg1 |  tmp1 := arg1 ].  tmp1 := nil.  tmp2 := announcer announce: GLMTestAnnouncement.  self assert: tmp1 equals: tmp2.  tmp1 := nil.  announcer suspendAllWhile: [ tmp2 := announcer announce: GLMTestAnnouncement ].  self assert: tmp1 isNil-======-isHSpaceFill  ^self hState isOnParent-======-isLeftResizingZone: arg1  ^(self globalBounds withWidth: resizingZoneWidth) containsPoint: arg1 position-======-toString: arg1  ^self glamourPresentation hasFilterBlock ifTrue: [ arg1 ] ifFalse: [ super toString: arg1 ]-======-testNoSelection  | tmp1 tmp2 tmp3 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 tree noSelection ].  window := tmp1 openOn: ($a to: $d).  tmp2 := window submorphs last submorphs first submorphs first submorphs first submorphs first.  tmp3 := tmp2 scroller submorphs first.  self send: tmp2 mouseUpOnItem: tmp3.  self assert: tmp1 panes size equals: 1-======-scrollingDelay: arg1  scrollingDelay := arg1-======-allowDropOnItem: arg1  allowDropOnItemBlock := arg1-======-useExplicitNotNil  implicitNotNil := false-======-testEquality  self assert: (copiedBrowser = browser) not-======-check  self isChecked ifFalse: [ isChecked := true.        self announce: #onChecked.        self changed ]-======-actOnVariableBindingsUpdated: arg1  textModel variableBindings: nil.  self addVariableBindingsOn: textModel from: arg1 presentation.  textModel changed: #text.  self flag: 'update just the style here'-======-totalPaneWidth  ^self innerBounds width - ((self sizing - 1) * self separatorWidth)-======-dynamicActionsOnSelection  (selectionDynamicActionsBlock isNil or: [ self selectedText isNil ]) ifTrue: [ ^OrderedCollection new ].  ^selectionDynamicActionsBlock glamourValue: self-======-onCompleted: arg1  callback := arg1-======-updateWidth: arg1  arg1 isWidthClean ifTrue: [ Exception signal: 'Clean width can''t be updated!' ].  arg1 layout hState updateWidth: arg1 on: self-======-pane  ^pane-======-testPresentationTransformation  | tmp1 |  tmp1 := GLMDynamicPresentation new.  tmp1 entity: 42.  tmp1 presentationTransformation: [:arg1 :arg2 |  (1 to: arg2) do: [:arg3 |  arg1 text title: arg3 asString ] ].  self assert: tmp1 currentPresentation presentations size equals: 42.  self assert: tmp1 currentPresentation pane identicalTo: tmp1 pane-======-setUp  super setUp.  pagerModel := GLMPagerModel new scrollingDelay: 0.  pagerModel defaultNumberOfVisiblePages: 2-======-testMarkerOneChildrenWidth  | tmp1 |  tmp1 := self newBrickWithFullDependsOnChildren.  self markFullyClean: tmp1.  tmp1 wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp1 brickApi.  self assert: tmp1 wrappedBounds isWidthDirty.  self assert: tmp1 wrappedBounds isHeightClean-======-synchronizeScrollTo: arg1  pagerModel synchronizeScrollTo: arg1-======-privateHeight: arg1  self layout height: arg1-======-testPresentations  | tmp1 |  tmp1 := GLMExpander new.  tmp1 show: [:arg1 |  arg1 text ].  tmp1 startOn: #(#a #b #c).  self assert: tmp1 panes size equals: 3.  self assert: tmp1 panes first presentations entity value equals: #a.  self assert: tmp1 panes first presentations size equals: 1.  self assert: (tmp1 panes first presentations first isKindOf: GLMRubricTextPresentation)-======-defaultScrollButtonStyleFor: arg1  arg1 checkedIcon: GLMUIThemeExtraIcons glamorousGrayCircleEmpty.  arg1 checkedFocusedIcon: GLMUIThemeExtraIcons glamorousGrayCircle.  arg1 normalImage: GLMUIThemeExtraIcons glamorousGrayCircleEmpty.  arg1 selectedImage: GLMUIThemeExtraIcons glamorousGrayCircle.  arg1 checkedImage: arg1 checkedIcon-======-glamourPresentation: arg1  glamourPresentation := arg1-======-renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderFastTreePresentation: self-======-rubricTextFontSize  ^self valueOfProperty: #brickRubricTextFontSize ifAbsent: [ self themer rubricTextFontSize ]-======-doesNotUnderstand: arg1  ^self brickRoot perform: arg1 selector withArguments: arg1 arguments-======-debugSelection  self announce: GLMDebugSelection-======-childrenValueOf: arg1 atLevel: arg2  self flag: 'this is rather hackish, but needed to treat list and tree in the same way.'.  ^OrderedCollection new-======-update  super update-======-padding  ^self wrappedBounds padding-======-sortByColumn: arg1  columnToSortBy := columnToSortBy == arg1 ifTrue: [ nil ] ifFalse: [ arg1 ].  elements := self elementsSorted.  self glamourPresentation changed-======-allowItemDragBlock  ^allowItemDragBlock-======-addBrick: arg1 after: arg2  | tmp1 |  tmp1 := self privateAddBrick: arg1 asBrick after: arg2.  self privatePrepareBrickAfterAdding: tmp1.  self doLayoutForce.  ^arg1-======-testShortcutAsString  | tmp1 tmp2 |  tmp2 := Smalltalk os menuShortcutModifierString.  tmp1 := GLMAction new.  tmp1 shortcut: $i.  self assert: tmp1 shortcutAsString equals: tmp2 , '+i'.  tmp1 shortcut: $I.  self assert: tmp1 shortcutAsString equals: tmp2 , '+shift+i'.  tmp1 shortcut: nil.  self assertEmpty: tmp1 shortcutAsString-======-roots  roots ifNil: [ self roots: self glamourExpander panes ].  ^roots-======-add: arg1 before: arg2  collection add: arg1 before: arg2.  self announce: GLMItemAdded-======-actOnPresentationToolbarUpdated: arg1  | tmp1 |  self setLabelOf: window for: arg1 presentation.  tmp1 := self renderToolbarForPresentation: arg1 presentation inMorph: window.  tmp1 hResizing: #shrinkWrap.  window toolbarBox: tmp1-======-paneCount  ^paneCount-======-fromOutside: arg1  ^self fromOutsidePort: arg1-======-backgroundColor  ^self theme backgroundColor-======-measureOpeningTime  | tmp1 tmp2 tmp3 |  tmp2 := 15.  tmp1 := self defaultBrowser.  tmp3 := Time millisecondsToRun: [ tmp2 timesRepeat: [ (tmp1 openOn: 10) delete ] ].  ^{tmp2 .   tmp3}-======-bounds  ^bounds-======-click: arg1  super click: arg1.  ^true-======-firstVisiblePageIndex  ^firstVisiblePageIndex-======-outerBoundsInParent  ^self owner ifNotNil: [ self wrappedBounds outerBounds translateBy: self owner brickBounds origin ] ifNil: [ self wrappedBounds outerBounds ]-======-newBrickWithStaticExtent  ^GLMBrick new     height: self staticHeight;     width: self staticWidth;     color: Color random;     yourself-======-addItemMorph: arg1 after: arg2  self addBrickBackNoLayout: arg1.  self setBoundsOf: arg1 after: arg2.  (self isPartiallyVisible: arg1) ifFalse: [ self removeBrickNoLayout: arg1.        ^nil ].  ^arg1-======-isDoubleClickEnabled  ^isDoubleClickEnabled ifNil: [ isDoubleClickEnabled := false ]-======-addTransmission: arg1  arg1 browser: self.  ^self transmissions addLast: arg1-======-layoutMorphs: arg1  shouldLayoutMorphs := arg1-======-hasUnacceptedEdits  ^hasUnacceptedEdits ifNil: [ hasUnacceptedEdits := false ]-======-* arg1  < return: #Point>  ^arg1 negated @ 0-======-testMarkerOneParentWidth  | tmp1 |  tmp1 := self newBrickWithFullFill.  self markFullyClean: tmp1.  tmp1 wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp1 brickApi.  self assert: tmp1 wrappedBounds isWidthDirty.  self assert: tmp1 wrappedBounds isHeightClean-======-renderMorphPresentation: arg1  ^GLMMorphicMorphRenderer render: arg1 from: self-======-isCollection  ^true-======-registerEventsForPresentation: arg1  super registerEventsForPresentation: arg1.  arg1 when: GLMVariableBindingsChanged send: #actOnVariableBindingsUpdated: to: self.  arg1 when: GLMEvaluateSelection send: #actOnEvaluateSelection: to: self.  arg1 when: GLMCompileText send: #actOnCompileText: to: self.  arg1 when: GLMDebugSelection send: #debugSelection to: self.  arg1 when: GLMProfileSelection send: #profileSelection to: self.  arg1 when: GLMPrintSelection send: #evaluateAndPrintSelection to: self-======-selectedBorderStyleFor: arg1  ^self theme tabLabelSelectedBorderStyleFor: arg1-======-compileTextIn: arg1 from: arg2 andDo: arg3  self announce: (GLMCompileText new           presentation: self;           context: arg1;           session: arg2;           action: arg3)-======-sortByColumn: arg1  columnToSortBy := columnToSortBy == arg1 ifTrue: [ nil ] ifFalse: [ arg1 ].  columnToSortBy ifNotNil: [ self rootItem children: (self rootItem children sorted: self sortBlock) ] ifNil: [ self rootItem data: self basicRoots ].  self glamourPresentation changed-======-onRemovedFrom: arg1  -======-registerModule: arg1  ^self registerModule: arg1 to: self named: thisContext sender selector-======-acceptDroppingMorph: arg1 event: arg2 inMorph: arg3  | tmp1 |  tmp1 := (arg3 scrollerSubMorphFromPoint: arg2 position) complexContents item.  ^self glamourPresentation accept: arg1 passenger droppedOnItem: tmp1-======-composite: arg1  composite := arg1-======-shouldUseCache  ^self parameters at: 'shouldUseCache' ifAbsent: [ false ]-======-delete  super delete.  isOpen := false-======-testCompositeInTheParentPane  | tmp1 |  tmp1 := GLMBrowser new.  self assert: (tmp1 pane presentations isKindOf: GLMCompositePresentation).  self assert: tmp1 pane presentations size equals: 1.  self assert: tmp1 pane presentations first equals: tmp1-======-isHeightClean  ^self brick wrappedBounds isHeightClean-======-wrapped  ^wrapped ifNil: [ wrapped := true ]-======-percent  ^percent-======-testMultipleSelectionWithChange  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list           beMultiple;           display: [:arg2 |  arg2 - 2 to: arg2 ] ].  window := tmp1 openOn: 4.  tmp2 := window submorphs last submorphs first submorphs first submorphs first.  tmp4 := tmp2 scroller submorphs first.  tmp5 := tmp2 scroller submorphs last.  self send: tmp2 mouseUpOnItem: tmp4.  self send: tmp2 mouseUpWithShift: true onItem: tmp5.  self assert: (tmp2 model selection selectedNodePathList collect: [:arg3 |  arg3 first item ]) asOrderedCollection equals: #(2 3 4) asOrderedCollection.  (tmp1 pane port: #entity) value: 42.  tmp3 := window submorphs last submorphs first submorphs first submorphs first.  tmp4 := tmp3 scroller submorphs first.  tmp5 := tmp3 scroller submorphs second.  self send: tmp3 mouseUpOnItem: tmp4.  self send: tmp3 mouseUpWithShift: true onItem: tmp5.  self assert: (tmp3 model selection selectedNodePathList collect: [:arg3 |  arg3 first item ]) asOrderedCollection equals: #(40 41) asOrderedCollection-======-id: arg1  id := arg1-======-specificTableMorphInitializiation  | tmp1 |  tmp1 := tableModel glamourPresentation.  tableMorph rowHeight: tmp1 rowHeight.  tmp1 isSearchable ifTrue: [ tableMorph enableSearch ].  tmp1 isFilterable ifTrue: [ tmp1 needActionButton ifTrue: [ tableMorph enableFilterWithAction: tmp1 actionBlock named: tmp1 actionName ] ifFalse: [ tmp1 hasFilterBlock ifTrue: [ tableMorph enableFilter: (GLMFilterBlock block: tmp1 filterBlock) ] ifFalse: [ tableMorph enableFilter ] ] ].  (tmp1 isFilterable or: [ tmp1 isSearchable ]) ifFalse: [ tableMorph disableFunction ] ifTrue: [ tableMorph explicitFunction ]-======-spotterThemer  ^self registerModule: GTSpotterWidgetThemer new to: GTSpotterBrickThemer new-======-readyToBeDisplayed  self glamourPresentation announcer announce: (GLMDataSourceUpdated newDataSource: self)-======-invalidateLayout  ^self brick invalidateLayout-======-addLazyPage: arg1 label: arg2 toolbar: arg3  self addLazyPage: arg1 label: arg2 toolbar: arg3 collapsable: false-======-isMenu  ^self hasTitle and: [ self hasIcon not ]-======-render: arg1  paneMorph := GLMMorphic containerMorph.  arg1 when: GLMMatchingPresentationsChanged send: #actOnMatchingPresentationsChanged: to: self.  self renderMorphFor: arg1.  ^paneMorph-======-addRow: arg1  | tmp1 tmp2 |  tmp2 := arg1 isSymbol ifTrue: [ self browser addNewPaneNamed: arg1.        GLMCustomRow new           id: arg1;           browser: self browser ] ifFalse: [ tmp1 := GLMCustomRow new browser: self browser.        arg1 value: tmp1.        tmp1 ].  self children addLast: tmp2.  ^tmp2-======-privateStyle: arg1  | tmp1 |  arg1 makeAllColor: Color red.  tmp1 := self parser parse: arg1 asString onError: [  ].  (tmp1 notNil and: [ tmp1 ~~ arg1 ]) ifTrue: [ self flag: 'change only the runs array of the original text.'.        arg1 setString: arg1 string setRunsChecking: tmp1 runs ]-======-newPane  ^newPane-======-initializeTextMorph  textMorph := RubScrolledTextMorph new.  textMorph     beReadOnly;     beWrapped;     textFont: self theme textFont;     textColor: self theme textColor;     backgroundColor: self theme errorPopperBackgroundColor.  self     vResizing: #spaceFill;     hResizing: #spaceFill;     addMorph: textMorph fullFrame: LayoutFrame identity-======-allowItemDrag: arg1  allowItemDragBlock := arg1-======-privateScrollPosition: arg1  scrollPosition := arg1.  self announcer announce: GLMBrickScrollPositionChanged new-======-relabelTab: arg1 with: arg2  arg1 label: arg2.  self updateTabs-======-newVerticalScrollbar  ^GLMScrollbarBrick new-======-shouldBeDisplayedByText  self containerTree shouldFilterByTextInput ifFalse: [ ^true ].  self withContentsDo: [:arg1 |  self flag: 'this should be delegated to the presentation		and glamourValue should be used to include the entity ports'.        (self containerTree glamourPresentation filterStrategy value: self containerTree inputText asString value: arg1 item) == true ifTrue: [ ^true ] ].  ^false-======-isOnParent  ^false-======-asyncTask  ^asyncTask ifNil: [ asyncTask := GLMAsyncTask new ]-======-isVShrinking  ^vResizing = #shrinkWrap-======-addBrickBackNoLayout: arg1 before: arg2  self band doNotLayoutDuring: [ self band addBrick: arg1 before: arg2 ].  ^arg1-======-renderCustomColumn: arg1 ofPane: arg2 inUI: arg3 inBrowser: arg4  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp2 := arg1 children inject: 0 into: [:arg5 :arg6 |  arg5 + arg6 span ].  tmp3 := arg1 children inject: 0 into: [:arg5 :arg6 |  arg5 + arg6 size ].  tmp4 := 0.  tmp5 := 0.  arg1 children keysAndValuesDo: [:arg7 :arg6 |  arg6 hasId ifTrue: [ tmp1 := self renderObject: (arg4 paneNamed: arg6 id) ] ifFalse: [ tmp1 := GLMMorphic containerMorph.              self renderCustomRow: arg6 ofPane: arg2 inUI: tmp1 inBrowser: arg4.              tmp1 addPaneSplitters ].        tmp1 layoutFrame: (LayoutFrame new                 topFraction: tmp4 / tmp2 offset: tmp5 - (tmp3 * tmp4 / tmp2) rounded + self margin;                 leftFraction: 0 offset: 0;                 bottomFraction: (tmp4 + arg6 span) / tmp2 offset: tmp5 + arg6 size - (tmp3 * (tmp4 + arg6 span) / tmp2) rounded - self margin;                 rightFraction: 1 offset: 0;                 yourself).        arg3 addMorphBack: tmp1.        tmp4 := tmp4 + arg6 span.        tmp5 := tmp5 + arg6 size ].  arg1 children last size > 0 ifTrue: [ (arg3 submorphs atLast: 2) layoutFrame bottomOffset: (arg3 submorphs atLast: 2) layoutFrame bottomOffset - tmp5.        arg3 submorphs last layoutFrame topOffset: arg3 submorphs last layoutFrame topOffset - tmp5.        arg3 submorphs last layoutFrame bottomOffset: arg3 submorphs last layoutFrame bottomOffset - tmp5 ].  arg3 addPaneSplitters-======-testFillBrickInsideStatic  | tmp1 tmp2 |  tmp1 := self newBrickWithStaticExtent.  tmp2 := self newBrickWithFullFill.  tmp2 brickApi layout hState isOnParent.  tmp2 brickApi layout vState isOnParent.  tmp1 addBrickBack: tmp2.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp2 extent equals: tmp1 extent-======-press  super press.  self closePopup-======-modelFor: arg1  | tmp1 |  tmp1 := arg1 highlightSmalltalkContext.  ^GLMRubricSmalltalkTextModel new     glamourPresentation: arg1;     highlightSmalltalk: tmp1 notNil;     highlightSmalltalkContext: tmp1;     yourself-======-complete: arg1 callback: arg2  process ifNil: [ ^self terminate ].  process isTerminated ifFalse: [ ^self ].  callback = arg2 ifFalse: [ ^self terminate ].  callback ifNotNil: [ callback cull: arg1 ].  process := nil-======-glmSubscriptions  ^registry subscriptions-======-updatePanes  self basicUpdateSizing.  self layoutPanes.  self hideOrShowScrollBar.  self setScrollDeltas.  self scrollToRight-======-verticalScrollbar  ^verticalScrollbar-======-rowMorphForItem: arg1  | tmp1 |  tmp1 := OrderedCollection new.  arg1 depth timesRepeat: [ tmp1 add: self class emptyMorph ].  tmp1 add: (self buttonFor: arg1).  (self iconFor: arg1 data) ifNotNil: [:arg2 |  tmp1 add: arg2 asMorph ].  tmp1     add: (self formatedDisplayValueOf: arg1 data) asMorph asReadOnlyMorph;     addAll: (self tagMorphsFrom: self glamourPresentation for: arg1 data).  ^Smalltalk ui theme newRowIn: self currentWorld for: tmp1-======-bindingsStrategy: arg1  bindingsStrategy := arg1-======-postCopy  super postCopy.  presentations ifNotNil: [:arg1 |  presentations := presentations collect: [:arg2 |  arg2 copy ] ].  arrangement ifNotNil: [:arg1 |  arrangement := arrangement copy.        arrangement composite: self ]-======-text: arg1  text := arg1.  self glamourPresentation ifNotNil: [:arg2 |  arg2 text: text ]-======-click: arg1  super click: arg1.  self announcer announce: (GLMPagerButtonClicked new buttonModel: self)-======-measureSelectionTimeForSize: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp2 := 15.  tmp1 := self defaultBrowser.  tmp5 := tmp1 openOn: arg1.  tmp4 := tmp1 panes first ports second.  tmp3 := Time millisecondsToRun: [ arg1 - tmp2 to: arg1 do: [:arg2 |  tmp4 value: arg2 ] ].  tmp5 delete.  ^{arg1 .   tmp3}-======-computeTagsFilterFor: arg1  ^self computeTagsFor: arg1 from: self tagsFilterBlock-======-textColor: arg1  < brickBuilderProperty: #Text name: 'Text color' as: #brickBuilderEvaluate getter: #textColor model: #GLMUIBuilderTextFieldProperty>  self label textColor: arg1.  self dotsBrick textColor: arg1-======-cellColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp1 := self elementAt: arg2.  tmp2 := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForElement: tmp1);     yourself.  ^tmp2-======-sortBlock: arg1  sortBlock := arg1-======-testBrickDependsOnChildrenOneStatic  | tmp1 tmp2 |  tmp1 := self newBrickWithFullDependsOnChildren.  tmp2 := self newBrickWithStaticExtent.  tmp1 addBrickBack: tmp2.  self assert: tmp1 brickApi layout hState isOnChildren.  self assert: tmp1 brickApi layout vState isOnChildren.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: tmp2 extent-======-headerFor: arg1 in: arg2  | tmp1 |  tmp1 := GLMBrick new.  tmp1     hSpaceFill;     vShrinkWrap.  tmp1 addBrickBack: (arg1 isVariableBinding ifTrue: [ arg1 key asBrick ] ifFalse: [ arg1 asBrick ]) hSpaceFill.  (self hasChildren: arg1) ifTrue: [ tmp1 addBrickFirst: (self newToggleButtonFor: arg2) ].  ^tmp1-======-act: arg1 on: arg2  self addAction: (GLMGenericAction new           action: arg1;           shortcut: arg2;           yourself)-======-remove: arg1  collection remove: arg1.  self announce: GLMItemRemoved-======-separatorAfter  ^separatorAfter ifNil: [ false ]-======-paneMargin  self flag: 'fix support of margin'.  ^0-======-property  ^property-======-testUnregisterFromAnnouncementsWhenUpdating  | tmp1 tmp2 tmp3 |  tmp3 := 0.  tmp2 := GLMAnnouncingCollection new.  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text           updateOn: GLMItemAdded from: [ tmp2 ];           display: [ tmp3 := tmp3 + 1 ] ].  window := tmp1 openOn: tmp2.  1 to: 3 do: [:arg2 |  tmp2 add: arg2 ].  self assert: tmp3 equals: 4-======-onLayouted  self doNotUpdateDuring: [ self update ]-======-rowHeight  ^self rowHeightBlock glamourValue: self asGlamorousMultiValue , self entity asGlamorousMultiValue-======-lazyPageMorphCreation: arg1  lazyPageMorphCreation := arg1-======-loremIpsum  ^String loremIpsum: 81233-======-updatePreview: arg1  self announcer announce: (GLMPagerPreviewUpdate new pageIndex: arg1)-======-transformation  ^transformation ifNil: [ transformation := [:arg1 |  arg1 ] ]-======-onMyselfDo: arg1  ^self on: #isOnMyself do: arg1 ifAbsent: [ GLMBrickLayoutMyselfState new ]-======-findSatisfying: arg1 in: arg2  arg2 allMorphsDo: [:arg3 |  (arg1 value: arg3) ifTrue: [ ^arg3 ] ].  self fail-======-paddingLeft  ^self wrappedBounds paddingLeft-======-withIndexDo: arg1  ^collection withIndexDo: arg1-======-asGlamourTargetIdentifier  self portName ifNil: [ self portName: self class defaultTargetPortName ].  ^self-======-arrangement: arg1  arg1 composite: self.  ^arrangement := arg1-======-entity  ^entity-======-minimumPageNumberForScrollbar  ^minimumPageNumberForScrollbar-======-assertHeightDirty: arg1  self assert: arg1 wrappedBounds heightState equals: #dirty.  self assert: arg1 wrappedBounds isHeightDirty.  self assert: arg1 wrappedBounds isHeightClean not-======-isHorizontal: arg1  isHorizontal := arg1-======-registerModule: arg1 to: arg2  ^self registerModule: arg1 to: arg2 named: thisContext sender selector-======-toWatcher  ^self destination: (self browser watcherPane port: #entity)-======-populate: arg1 iconName: arg2 on: arg3 entitled: arg4 with: arg5  self populate: arg1 icon: (self iconNamed: arg2) on: arg3 entitled: arg4 with: arg5-======-presentations: arg1  presentations := arg1-======-menuColumn: arg1 row: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := UIManager default newMenuIn: self table for: self.  tmp2 := Dictionary new.  self allMenuActions do: [:arg3 |  tmp3 := arg3 category notNil ifTrue: [ tmp2 at: arg3 category ifAbsentPut: [ tmp4 := MenuMorph new.                    tmp1 add: arg3 category subMenu: tmp4.                    tmp4 ] ] ifFalse: [ tmp1 ].        (tmp3 add: arg3 title target: self selector: #executeMenuAction: argument: arg3)           icon: arg3 icon;           balloonText: arg3 help;           enabled: (arg3 isEnabledOn: self glamourPresentation);           keyText: (arg3 hasShortcut ifTrue: [ arg3 shortcutAsString ] ifFalse: [ nil ]) ].  ^tmp1-======-cellColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp1 := self elementAt: arg2.  tmp2 := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForColumn: arg1 item: tmp1 withIndex: arg2);     yourself.  ^tmp2-======-testCodeExecutionWithBindings  | tmp1 tmp2 tmp3 |  tmp1 := GLMCompositePresentation new.  tmp1 pharoScript.  window := tmp1 openOn: 'a:=1'.  tmp3 := nil.  tmp2 := self find: RubScrolledTextMorph in: window.  tmp2 textArea editor evaluateSelectionAndDo: [:arg1 |  tmp3 := arg1 ].  self assert: tmp3 equals: 1-======-rightAngle: arg1  ^arg1 = GLMNorthDirection uniqueInstance-======-stylerStyled: arg1  next ifNil: [ ^self ].  text runs: arg1 runs.  (self textArea scrollPane ifNil: [ self textArea ]) changed-======-onDraw: arg1  self renderer render: self on: arg1-======-render: arg1  textModel := self textModelFor: arg1.  textMorph := self textMorphForModel: textModel.  textModel text: textMorph text.  textMorph setSelection: textModel selection.  self installActionsOnModel: textModel fromPresentation: arg1.  self installKeystrokeActionsOnMorph: textMorph textMorph fromPresentation: arg1.  textMorph announcer when: GLMSelectedTextChanged do: [:arg2 |  arg1 announcer suspendAllWhile: [ arg1 selectionInterval: arg2 interval.              arg1 selectedText: arg2 selectedText ] ].  textMorph announcer when: GLMTextChanged do: [:arg2 |  arg1 suspendAllWhile: [ arg1 text: arg2 text ] ].  self registerEventsForPresentation: arg1.  ^textMorph-======-open: arg1 with: arg2  ^arg1 openAbove: arg2-======-isWidthClean  ^self brick wrappedBounds isWidthClean-======-buttonBorderColor  ^Color lightGray-======-presentation  presentation ifNil: [ | tmp1 |        tmp1 := GLMMorphicRenderer new render: self glmPres.        tmp1 hResizing: #spaceFill.        tmp1 vResizing: #spaceFill.        presentation := MorphicGenericAdapter morph: tmp1 ].  ^presentation-======-selectedIndex  ^selectedIndex ifNil: [ selectedIndex := 0 ]-======-selectionIndex: arg1  selectionIndex := arg1-======-onButtonDeselected  GLMPagerPanePreviewMorph uniqueInstance hideFromWorld-======-readyToBeDisplayed  self glamourPresentation announcer announce: (GLMDataSourceUpdated newDataSource: self)-======-onLostFocus  self isCancelOnFocusLost & self isEditMode ifTrue: [ self cancel ].  self isEditMode ifTrue: [ self animateToEditNotFocused ] ifFalse: [ self animateToNormal ]-======-watcherPane  ^watcherPane ifNil: [ watcherPane := GLMPane named: #_watcher ]-======-privateRemoveOutWorld: arg1  arg1 outOfWorld: arg1 world-======-actionSelector  ^#morphicActOn:-======-border  ^self valueOfProperty: #brickBorder ifAbsentPut: [ GLMBrickBorder new ]-======-variableBindings  ^(variableBindingsBlock glamourValue: self entity) ifNil: [ OrderedCollection new ]-======-testAccordion  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 accordionArrangement.        arg1 list title: 'List'.        arg1 text title: 'Text' ].  window := tmp1 openOn: 42.  self assert: self compositePanel submorphs notEmpty.  self assert: self compositePanel submorphs size equals: 2.  self assert: self compositePanel submorphs first class equals: ExpanderMorph.  self assert: self compositePanel submorphs last class equals: ExpanderMorph-======-clear  arrangement := nil.  presentations := nil-======-testPanes  self assert: copiedBrowser panes size equals: 2.  self assert: copiedBrowser panes first ~~ browser panes first.  self assert: copiedBrowser panes last ~~ browser panes last.  self assert: copiedBrowser panes first browser identicalTo: copiedBrowser.  self assert: copiedBrowser panes last browser identicalTo: copiedBrowser.  self assert: copiedBrowser panes first ports size equals: 1.  self assert: copiedBrowser panes first ports first name equals: #selection.  self assert: copiedBrowser panes first ports first pane identicalTo: copiedBrowser panes first.  self assert: copiedBrowser panes last ports size equals: 2.  self assert: copiedBrowser panes last ports first name equals: #selection.  self assert: copiedBrowser panes last ports last name equals: #entity-======-addBrick: arg1 before: arg2  | tmp1 |  tmp1 := self privateAddBrick: arg1 asBrick before: arg2.  self privatePrepareBrickAfterAdding: tmp1.  self doLayoutForce.  ^arg1-======-glmAnimateValue: arg1 duration: arg2  self glmAnimateValue: arg1 duration: arg2 callback: nil-======-layoutSubbricks  self layoutPolicy layout: self brickApi in: self innerBounds-======-actionThemer  ^GLMActionBrickThemer new-======-textEditBrick  ^textEditBrick-======-renderFastTreePresentation: arg1  ^GLMMorphicFastTreeRenderer render: arg1 from: self-======-separatorWidth  ^20-======-columns: arg1  columns := arg1-======-animateToEditNotFocused  self borderAnimation     from: self borderColor first;     to: self themer normalBorderColor;     animate: self-======-column: arg1 evaluated: arg2 modified: arg3  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           modifiedBlock: arg3)-======-defaultSelectionActions  ^self executionSelectionActions-======-leftShadowOf: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := arg1 shadowWidth.  tmp4 := tmp2 negated @ tmp2 / 2.0.  tmp3 := arg1 brickBounds topLeft + tmp4 + arg1 shadowOffset.  tmp1 := (self shadowGradientFor: arg1)     origin: tmp3 - tmp4 + ((tmp2 / 2.0) @ 0);     direction: (tmp2 @ 0) negated;     yourself.  arg2 fillRectangle: (tmp3 extent: tmp2 @ (arg1 height - tmp2)) fillStyle: tmp1-======-changed  self world ifNil: [ ^self ].  ^fullBounds ifNil: [ self invalidRect: self bounds ] ifNotNil: [ self invalidRect: fullBounds ]-======-testMarkerOneChildrenInStaticWidth  | tmp1 tmp2 |  tmp1 := self newBrickWithStaticExtent.  tmp2 := self newBrickWithFullDependsOnChildren.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthDirty.  self assert: tmp2 wrappedBounds isHeightClean.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightClean-======-announcer  ^announcer ifNil: [ announcer := GLMAnnouncer new ]-======-popup: arg1 event: arg2  < return: #Boolean>  ^arg2 type == #keystroke and: [ arg2 keyCharacter = Character escape ]-======-shouldDisplayPresentationCreatedBy: arg1  ^true-======-scrollBarColor  ^self valueOfProperty: #brickScrollbarColor ifAbsent: [ self themer scrollbarColor ]-======-tabWidth  ^tabWidth ifNil: [ TextStyle default rubTabWidth ]-======-actualPageMorph: arg1  actualPageMorph := arg1-======-subbrickBefore  | tmp1 |  tmp1 := self brickDoubleLink.  tmp1 ifNil: [ ^nil ].  tmp1 previousLink ifNil: [ ^nil ].  ^tmp1 previousLink value-======-renderFastListPresentation: arg1  ^GLMMorphicFastListRenderer render: arg1 from: self-======-scrollDown: arg1  self band translateY: arg1 negated.  self isBottomOverscrolled ifTrue: [ self moveBandBottom ]-======-tearDown  window ifNotNil: [ window delete ].  super tearDown-======-variableBindings: arg1  ^variableBindingsBlock := arg1-======-colorRight  ^self color at: Right-======-testUnregisterAnnouncementsWhenRemovingPane  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Announcer new.  tmp3 := GLMBrowser new.  tmp4 := GLMPane new.  tmp2 := GLMPresentation new.  tmp4 addPresentation: tmp2.  tmp3 addPane: tmp4.  tmp2 updateOn: GLMTestAnnouncement from: [ tmp1 ].  tmp2 registerAnnouncements.  self assert: tmp1 numberOfSubscriptions equals: 1.  tmp3 removePane: tmp4.  self assert: tmp1 numberOfSubscriptions equals: 0-======-vMargin  ^self marginTop + self marginBottom-======-addActiveOrigin: arg1  ^self originReferences add: (GLMOriginPortReference new           port: arg1;           beActive;           yourself)-======-glamourPresentation  ^glamourPresentation-======-testFinder  | tmp1 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 title: 'something'.        arg1 stackedArrangement.        arg1 list.        arg1 text ].  self assert: tmp1 transmission transmissionStrategy presentations size equals: 2.  tmp1 startOn: (1 to: 42).  self assert: tmp1 panes first presentations size equals: 2.  self assert: (tmp1 panes first presentations arrangement isKindOf: GLMStackedVerticallyArrangement).  window := tmp1 open.  self find: LazyTabGroupMorph in: window-======-presentations  ^self pane presentations-======-removeTabIndex: arg1  self tabs removeAt: arg1.  self selectedIndex: 0.  self tabs ifNotEmpty: [ self selectedIndex: (self selectedIndex - 1) \\ self tabs size + 1 ]-======-font: arg1  self label font: arg1.  self dotsBrick font: arg1-======-selectToLeft  self selectedPageIndex: self selectedPageIndex - 1-======-glamourPresentation  ^glamourPresentation-======-openInBrickWindow  ^self openInBrickWindowLabeled: self-======-sizeLogic: arg1  countLogic := arg1-======-initialize  super initialize.  self on: #keyStroke send: #handleKeyStroke: to: self.  hasInitialStep := false-======-textModelFor: arg1  ^GLMTextModel new     text: arg1 formatedDisplayValue;     glamourPresentation: arg1-======-testAccordionWithTitle  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 accordionArrangement.        arg1 title: 'title'.        arg1 list.        arg1 text ].  window := tmp1 openOn: 42.  self assert: self compositeTabGroup submorphs notEmpty.  self assert: self compositeTabGroup submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph class equals: GLMPanelMorph.  self assert: self compositeTabGroup contentMorph submorphs first submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph submorphs first submorphs first class equals: ExpanderMorph-======-gtActionsIn: arg1  < gtInspectorPresentationOrder: 50>  arg1 list     title: 'Actions';     display: [ self actions ];     format: [:arg2 |  arg2 gtDisplayString ]-======-column: arg1 evaluated: arg2 width: arg3 tags: arg4 sortedBy: arg5  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           width: arg3;           tags: arg4;           sortBlock: arg5 yourself)-======-origin: arg1 length: arg2 breadth: arg3  ^arg1 extent: arg2 @ arg3-======-from: arg1  fromLogic := arg1-======-hAlign  ^self layout hAlign-======-helpMessage  ^helpMessage ifNil: [ helpMessage := 'Search Input' ]-======-newSliderBrick  ^GLMPagerScrollSlidingBrick new-======-isWidthDirty  ^self widthState = #dirty-======-transformation  ^transformation-======-render: arg1  container := GLMMorphic containerMorph.  container     changeTableLayout;     listDirection: #leftToRight;     vResizing: #spaceFill;     hResizing: #shrinkWrap.  scrollPane := GeneralScrollPane new     changeScrollerTableLayout;     scrollTarget: container;     yourself.  self registerAnnouncementsFor: arg1.  arg1 panes do: [:arg2 |  self addMorphFromObject: arg2 toContainer: container ].  ^scrollPane-======-modules  ^modules ifNil: [ modules := Dictionary new ]-======-glamourAction: arg1  glamourAction := arg1-======-transformation: arg1  transformation := arg1-======-testInnerTransmissions  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMExplicitBrowser new.  tmp2 := GLMExplicitBrowser new.  tmp3 := GLMPresentation new.  tmp1 addNewPane name: 'pane1'.  tmp2 addNewPane name: 'innerpane 1'.  tmp1 addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: tmp1;                 name: #entity;                 yourself);           destination: (tmp1 panes first port: #entity);           addPresentation: tmp2;           yourself).  tmp2 addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: tmp2;                 name: #entity;                 yourself);           destination: (tmp2 panes first port: #entity);           addPresentation: tmp3;           yourself).  (tmp1 pane port: #entity) value: 42.  tmp4 := tmp1 panes first presentations first.  self assert: tmp4 transmissions size equals: 1.  self assert: (tmp4 transmissions first origins first isKindOf: GLMPresentationBoundPort).  self assert: tmp4 transmissions first origins first pane identicalTo: tmp1 panes first-======-hasMinHeight  ^(self minHeight isNumber ifTrue: [ self minHeight <= 0 ] ifFalse: [ false ]) not-======-action  ^action-======-vPadding  ^self paddingTop + self paddingBottom-======-isEntityPort  ^self name = #entity-======-when: arg1 send: arg2 to: arg3  self announcer when: arg1 send: arg2 to: arg3-======-toggleFilteringByTag: arg1  (self shouldFilterByTag: arg1) ifTrue: [ self tagsToFilterBy remove: arg1 ] ifFalse: [ self tagsToFilterBy add: arg1 ].  self resetChildrenContent.  self tableRefresh-======-printSelection  self announce: GLMPrintSelection-======-actOnPaneReplaced: arg1  container brickRoot popAndReplacePane: (self renderObject: arg1 newPane)-======-renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderFastTablePresentation: self-======-selectedClassOrMetaClass  ^self highlightSmalltalkContext-======-addPresentations: arg1  self notingPresentationChangeDo: [ arg1 do: [:arg2 |  self addPresentationSilently: arg2 ] ]-======-category  ^category-======-testFullAlignCenterShrinkWrapInSpaceFill  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := 10.  tmp1 := self newBrickWithStaticExtent.  tmp2 := self newBrickWithFullFill.  tmp3 := self newBrickWithFullDependsOnChildren.  tmp4 := self newBrickWithSmallStaticExtent.  tmp3     vAlign: #center;     hAlign: #center.  tmp1 addBrickBack: tmp2.  tmp2 addBrickBack: tmp3.  tmp3 addBrickBack: tmp4.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp3 brickBounds equals: ((self staticExtent - self staticSmallExtent) / 2 extent: self staticSmallExtent) ceiling.  tmp4     height: tmp4 height + tmp5;     width: tmp4 width + tmp5.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp3 brickBounds equals: ((self staticExtent - self staticSmallExtent) / 2 - (tmp5 / 2) extent: self staticSmallExtent + tmp5) ceiling-======-icon  ^icon ifNil: [ icon := [ nil ] ]-======-acceptsSelection: arg1  acceptsSelection := arg1-======-filterBlock: arg1  filterBlock := arg1-======-color  ^self valueOfProperty: #brickBackgroundColor ifAbsent: [ self themer backgroundColor ]-======-testStartingPreservesItself  | tmp1 tmp2 |  tmp1 := GLMCompositePresentation new.  tmp2 := tmp1 finder.  tmp1 startOn: 42.  self assert: tmp1 pane presentations equals: tmp1.  self assert: tmp1 first identicalTo: tmp2-======-presentation  ^presentation-======-layoutPolicy  ^self brick layoutPolicy-======-addRow: arg1 size: arg2  ^(self addRow: arg1)     size: arg2;     span: 0-======-buttonForTag: arg1 filter: arg2  ^(GLMMorphic togglingButtonLabelled: arg1 pressed: (self shouldFilterByTag: arg2) style: self glamourPresentation tagsStyle)     target: self;     actionSelector: #toggleFilteringByTag:;     arguments: (Array with: arg2);     yourself-======-collapse  self contentBrick ifNil: [ ^self ].  self isExpanded ifTrue: [ self removeBrick: self contentBrick ]-======-bindingsStrategy  ^bindingsStrategy ifNil: [ bindingsStrategy := self defaultBindingsStrategy ]-======-testGlamourValueWithArgs  self assert: ([ #foo ] glamourValueWithArgs: #(1 2)) equals: #foo.  self assert: ([:arg1 |  Array with: arg1 ] glamourValueWithArgs: #(1 2)) equals: #(1).  self assert: ([:arg1 :arg2 |  Array with: arg1 with: arg2 ] glamourValueWithArgs: #(1 2)) equals: #(1 2).  self assert: ([:arg1 :arg2 :arg3 |  Array with: arg1 with: arg2 with: arg3 ] glamourValueWithArgs: #(1 2)) equals: #(1 2 nil).  self assert: (#yourself glamourValueWithArgs: #(1 2)) equals: 1.  self assert: (#yourself glamourValueWithArgs: #()) equals: nil-======-markWidthClean  ^self brick wrappedBounds markWidthClean-======-isVFilling  ^vResizing = #spaceFill-======-browser  browser ifNil: [ ^GLMNoBrowser new ].  ^browser-======-vState  ^GLMBrickLayoutDummState new-======-testCachedPresentation  | tmp1 tmp2 |  tmp1 := GLMDynamicPresentation new.  tmp1 entity: 42.  tmp1 transformation: [:arg1 |  GLMRubricTextPresentation new ].  tmp2 := tmp1 currentPresentation.  self assert: tmp1 cachedPresentation identicalTo: tmp2-======-buttonsBrick: arg1  buttonsBrick := arg1.  self buttonsBrick pagerModel: pagerModel.  self buttonsBrick     hShrinkWrap;     vShrinkWrap.  self addBrickBack: self buttonsBrick-======-act  self subclassResponsibility-======-beEdit  self isEditMode ifTrue: [ ^self ].  self editBrick updateTextWith: self labelBrick text.  self editBrick moveCursorToIndex: self labelBrick text size + 1.  self addBrickFirst: self editBrick.  self removeBrick: self labelBrick.  self borderColor: (self themer focusedBorderColor alpha: 0).  self editBrick rubric takeKeyboardFocus.  self announce: #onEditMode-======-maxWidth: arg1  self layout maxWidth: arg1-======-backgroundColor  ^Color transparent-======-maxHeight: arg1  maxHeight := arg1-======-sendOneOrMultiple  self sendOneOrMultipleAs: Array-======-testJumpstartTransmission  | tmp1 tmp2 |  tmp1 := GLMExplicitBrowser new.  tmp2 := GLMPresentation new.  tmp1 addNewPane.  tmp1 addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           addActiveOrigin: (tmp1 pane port: #entity);           destination: (tmp1 panes first port: #entity);           addPresentation: tmp2;           yourself).  self assert: (tmp1 panes first port: #entity) value isNil.  self assertEmpty: tmp1 panes first presentations.  (tmp1 pane port: #entity) value: #foo.  self assert: (tmp1 panes first port: #entity) value equals: #foo.  self assert: tmp1 panes first presentations size equals: 1.  self assert: tmp1 panes first presentations first rootPrototype equals: tmp2-======-markDirtyCustomDependency: arg1 inContext: arg2  arg1 isBrick not | (arg1 = arg2) ifTrue: [ ^self ].  (self hasCustomDependencies: arg1) ifTrue: [ self markDirty: arg1.        arg1 subbricks do: [:arg3 |  arg3 isBrick ifTrue: [ self markDirty: arg3.                    self markDirtyAround: arg3 inContext: arg1 ] ].        (self customDependencies: arg1) do: [:arg3 |  | tmp1 |              [ tmp1 := (arg3 brickValue: arg1) brickApi ] on: Exception do: [ tmp1 := nil ].              tmp1 ifNotNil: [ (tmp1 = arg2) not & (tmp1 = arg1) not & tmp1 isBrick ifTrue: [ (self isClean: tmp1) ifTrue: [ self markDirty: tmp1.                                self markDirtyAround: tmp1 inContext: arg1 ] ] ] ] ]-======-onChangeOfPort: arg1 act: arg2  self portChangeActions add: (GLMPortChangeAction new           portName: arg1;           action: arg2)-======-setFocused  focused ifFalse: [ self checkedImage: checkedFocusedIcon.        self check.        focused := true ]-======-value: arg1 in: arg2  (self validate: arg1) ifFalse: [ ^self ].  self port value: arg1 in: arg2-======-notingPresentationChangeDo: arg1  arg1 value-======-glamourExpander  ^glamourExpander-======-testIsRendered  self assert: tabs pages first isRendered not.  tabs selectedPageIndex: 1.  self assert: tabs pages first isRendered.  self assert: tabs pages second isRendered not-======-column: arg1  ^self addColumn: arg1-======-dragResizingLeft: arg1  | tmp1 tmp2 |  tmp2 := self brickBounds right.  tmp1 := arg1 position x - self owner globalBounds left - startDragX.  tmp1 := (tmp1 max: 0) min: tmp2 - self pagerModel circleButtonSize.  self setPosition: tmp1 @ tmp2-======-checkBrick: arg1  checkBrick := arg1.  self box     borderColor: self themer checkboxBorderColor;     borderWidth: self themer checkboxBorderWidth;     vAlign: #center;     checkedImage: self themer checkboxCheckedImage;     width: self themer checkboxWidth;     height: self themer checkboxHeight.  self addBrickFirst: self box-======-newDataSource: arg1  newDataSource := arg1-======-shoutAboutToStyle: arg1  self highlightSmalltalk ifFalse: [ ^false ].  self highlightSmalltalkContext ifNotNil: [:arg2 |  arg1 classOrMetaClass: arg2 ].  ^true-======-shouldUseCache  ^self glamourPresentation shouldUseCache-======-step  | tmp1 |  tmp1 := self textLogic value asString.  self text = tmp1 ifTrue: [ ^self ].  self text: tmp1.  self doLayoutForce-======-updateInsetAndSpacing  self triggerBrick margin: {self inset top .         self inset right .         0 .         self inset left}.  self contentBrick margin: {self spacing .         self inset right .         self inset bottom .         self inset left}-======-computeWidth  ^self pagerModel ifNil: [ 0 ] ifNotNil: [:arg1 |  arg1 circleButtonSize * arg1 actualNumberOfVisiblePages ]-======-invalidateMorphBounds: arg1  | tmp1 tmp2 tmp3 |  isLayouting & arg1 not ifTrue: [ ^self ].  tmp1 := self paddingLeft @ self paddingTop.  tmp2 := self paddingRight @ self paddingBottom.  tmp3 := self globalBounds.  tmp3 := tmp3 origin + tmp1 corner: tmp3 corner - tmp2.  self morph bounds: tmp3-======-in: arg1  table := arg1.  self initializeColumns-======-popAndReplacePane: arg1  transform removeMorph: transform lastSubmorph.  transform submorphs isEmpty ifFalse: [ transform removeMorph: transform lastSubmorph ].  paneCount := paneCount - 1.  arg1     borderWidth: 0;     hResizing: #spaceFill;     vResizing: #spaceFill;     layoutInset: 0.  transform hasSubmorphs ifTrue: [ transform addMorphBack: self separator ].  transform addMorphBack: (arg1 adoptPaneColor: self paneColor).  paneCount := paneCount + 1.  self updatePanes-======-morph: arg1  morphBuilder := arg1-======-isHeightCustom  ^self vState isOnMyself-======-addDefaultStatusbarTransmissionFrom: arg1  | tmp1 |  tmp1 := GLMTransmission new     ensureReplacePresentationsStrategy;     addActiveOrigin: (arg1 port: #status);     destination: (self statusbarPane port: #entity);     addPresentation: self statusbarPresentation;     yourself.  self addTransmission: tmp1-======-setProperty: arg1 toValue: arg2  super setProperty: arg1 toValue: arg2-======-scrollToPane: arg1 callback: arg2  self scrollTo: (self convertIndexToValue: arg1) smooth: true callback: arg2-======-