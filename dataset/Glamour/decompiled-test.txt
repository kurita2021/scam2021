foundationBrick  ^(self owner isKindOf: GLMFoundationBrick) ifTrue: [ self owner ] ifFalse: [ self ]-=JUAMPI=-renderBorder: arg1 on: arg2  arg2 drawPolygon: arg1 area vertices color: Color transparent borderWidth: arg1 border widthTop borderColor: arg1 border colorTop-=JUAMPI=-click: arg1  | tmp1 |  tmp1 := super click: arg1.  tmp1 ifTrue: [ self closePopup ].  ^tmp1-=JUAMPI=-selectedLabel  ^selectedLabel-=JUAMPI=-stepAt: arg1  hasInitialStep ifFalse: [ hasInitialStep := true.        ^self ].  super stepAt: arg1-=JUAMPI=-submorphAfter  ^self subbrickAfter-=JUAMPI=-value  ^value-=JUAMPI=-enableFilterWithAction: arg1  self enableFilter.  self parameters at: 'actionBlock' put: arg1-=JUAMPI=-pane  ^pane ifNil: [ pane := (GLMPane named: 'root' in: GLMNoBrowser new)           addPresentationSilently: self;           yourself ]-=JUAMPI=-updateWidthPercentage  self subbricks ifEmpty: [ ^self ].  self subbricks do: [:arg1 |  arg1 hSpaceFill: 100 / self subbricksCount ]-=JUAMPI=-testEmptyList  window := GLMScrollListBrick exampleEmptyCollection.  self assert: window isSystemWindow-=JUAMPI=-defaultWaitDuration  ^500 milliSecond-=JUAMPI=-announce: arg1  self logger logAnnouncement: arg1 from: self.  super announce: arg1-=JUAMPI=-isFocused  ^focused-=JUAMPI=-resetChildrenContent  elements := self calculateElements.  self resetDataCache-=JUAMPI=-bar  ^bar-=JUAMPI=-firstSubbrick  ^self subbricks first-=JUAMPI=-drawingBounds: arg1  | tmp1 tmp2 |  tmp1 := arg1 brickBounds.  tmp2 := arg1 shadowOffset.  ^arg1 shadowWidth isZero ifTrue: [ tmp1 ] ifFalse: [ tmp1 quickMerge: ((tmp1 expandBy: arg1 shadowWidth) translateBy: tmp2) ]-=JUAMPI=-shouldValidate  ^shouldValidate ifNil: [ shouldValidate := false ]-=JUAMPI=-basicElements  ^self glamourPresentation displayValue-=JUAMPI=-cancel  self borderColor: self themer color alizarin.  self beNormal-=JUAMPI=-mouseDown: arg1  startDragX := arg1 position x - self globalBounds left.  startResizingWidth := self width.  isRightResizing := self isRightResizingZone: arg1.  isRightResizing ifFalse: [ isLeftResizing := self isLeftResizingZone: arg1 ] ifTrue: [ isLeftResizing := false ].  isResizing := isLeftResizing or: isRightResizing.  super mouseDown: arg1-=JUAMPI=-rubricBackgroundColor  ^self valueOfProperty: #brickRubricBackgroundColor ifAbsent: [ self themer rubricBackgroundColor ]-=JUAMPI=-renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderRubricTextPresentation: self-=JUAMPI=-newBand  ^super newBand height: [:arg1 |  arg1 subbricks isEmpty ifTrue: [ 0 ] ifFalse: [ arg1 lastSubbrick brickBounds bottom ] ]-=JUAMPI=-doesNotUnderstand: arg1  ^self rubric perform: arg1 selector withArguments: arg1 arguments-=JUAMPI=-compositeMorph  ^window submorphs last submorphs last submorphs last-=JUAMPI=-replaceFrom: arg1 to: arg2 with: arg3  self okToStyle ifFalse: [ ^next replaceFrom: arg1 to: arg2 with: arg3 ].  self disableDrawingWhile: [ arg3 addAttribute: self defaultFontChange.        text ifNil: [ text := self text ].        text replaceFrom: arg1 to: arg2 with: (self styler format: arg3).        self style: text.        next text: text.        self recomposeFrom: arg1 to: arg1 + arg3 size - 1 delta: arg3 size - (arg2 - arg1 + 1).        self textArea paragraphWasComposedFrom: arg1 to: arg1 + arg3 size - 1.        self textArea paragraphReplacedTextFrom: arg1 to: arg2 with: arg3 ]-=JUAMPI=-installEntity  self textBrick setTextWith: (self displayLogic phlowValue: self entity).  self textBrick selectionInterval: (self selectionInterval phlowValue: self entity)-=JUAMPI=-resetInput  self updateRoots-=JUAMPI=-render: arg1  ^self subclassResponsibility-=JUAMPI=-onDoubleClick  self announcer announce: (GLMTreeMorphStrongSelectionChanged new strongSelectionValue: (self selection ifNotNil: [ self selection selectedItemOrItemsOrNil ]))-=JUAMPI=-isButton  ^self hasIcon-=JUAMPI=-defaultBrowser  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 * 3 ] ].  tmp1 transmit     to: #two;     from: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 * 3 ] ].  tmp1 transmit     to: #one;     from: #two;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 * 3 ] ].  ^tmp1-=JUAMPI=-initialize  super initialize.  isSyncronous := false-=JUAMPI=-testLeftFloatingMySelfDependencyWithMargin  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := 10.  tmp2 := #left.  tmp1 := self newBrickWithStaticExtent.  tmp4 := self newBrickWithSmallStaticExtent.  tmp4 marginLeft: tmp3.  tmp4 layout floating: tmp2.  tmp1 addBrickBack: tmp4.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp4 extent equals: self staticSmallExtent.  self assert: tmp4 brickBounds equals: (tmp3 @ 0 extent: self staticSmallExtent)-=JUAMPI=-floatingMethodFor: arg1  ^('layoutFloating' , arg1 capitalized , ':in:') asSymbol-=JUAMPI=-testPaneCreation  | tmp1 |  tmp1 := GLMFinder new.  tmp1 addPresentation: (GLMPresentation new title: 'presentation1').  self assert: tmp1 panes isEmpty.  (tmp1 pane port: #entity) value: #value1.  self assert: tmp1 panes size equals: 1.  self assert: tmp1 panes first browser identicalTo: tmp1.  self assert: (tmp1 panes first port: #entity) value equals: #value1.  self assert: tmp1 panes first presentations size equals: 1.  self assert: tmp1 panes first presentations first title equals: 'presentation1'.  self assert: tmp1 panes first presentations first ~~ tmp1 transmission transmissionStrategy presentations first.  (tmp1 panes first port: #selection) value: #value2.  self assert: tmp1 panes size equals: 2.  self assert: tmp1 panes last browser identicalTo: tmp1.  self assert: (tmp1 panes last port: #entity) value equals: #value2.  self assert: tmp1 panes last presentations first title equals: 'presentation1'.  self assert: tmp1 panes last presentations first ~~ tmp1 transmission transmissionStrategy presentations first.  self assert: tmp1 panes last presentations first ~~ tmp1 panes first presentations first.  (tmp1 panes last port: #selection) value: #value3.  self assert: tmp1 panes size equals: 3.  self assert: tmp1 panes last browser identicalTo: tmp1.  self assert: (tmp1 panes last port: #entity) value equals: #value3.  (tmp1 panes first port: #selection) value: #value4.  self assert: tmp1 panes size equals: 2.  self assert: tmp1 panes last browser identicalTo: tmp1.  self assert: (tmp1 panes last port: #entity) value equals: #value4.  (tmp1 pane port: #entity) value: #value5.  self assert: tmp1 panes size equals: 1.  self assert: tmp1 panes last browser identicalTo: tmp1.  self assert: (tmp1 panes last port: #entity) value equals: #value5-=JUAMPI=-state  ^#vState-=JUAMPI=-onThemerChanged  self updateStyle-=JUAMPI=-markClean: arg1  ^self subclassResponsibility-=JUAMPI=-addAllBricks: arg1  self brickRoot addAllBricks: arg1-=JUAMPI=-copyAccordingToPaneMapping: arg1 inNewBrowser: arg2  ^self copy presentation: arg2-=JUAMPI=-customDependencies: arg1  ^arg1 layout heightDependencies-=JUAMPI=-dimension: arg1  dimension := arg1-=JUAMPI=-prioritySortedSubbricks: arg1  | tmp1 |  tmp1 := OrderedCollection newFrom: arg1 subbricks.  tmp1 sort: [:arg2 :arg3 |  (self isDependsOnParent: arg2) ifFalse: [ true ] ifTrue: [ (self isDependsOnParent: arg3) ifFalse: [ false ] ifTrue: [ (self hasDimensionRestrictions: arg2) ifFalse: [ false ] ifTrue: [ (self hasDimensionRestrictions: arg3) ifFalse: [ true ] ifTrue: [ (self hasMinDimensionRestriction: arg2) ifFalse: [ false ] ifTrue: [ true ] ] ] ] ] ].  ^tmp1-=JUAMPI=-sorted: arg1  sortBlock := arg1-=JUAMPI=-testTrasmissions  self assert: copiedBrowser transmissions size equals: 2.  self assert: copiedBrowser transmissions first ~~ browser transmissions first.  self assert: copiedBrowser transmissions last ~~ browser transmissions last.  self assert: (copiedBrowser transmissions first destination pane browser isKindOf: GLMNoBrowser).  self assert: copiedBrowser transmissions last destination pane browser identicalTo: copiedBrowser.  self assert: copiedBrowser transmissions first origins first pane browser identicalTo: copiedBrowser.  self assert: copiedBrowser transmissions last origins first pane browser identicalTo: copiedBrowser-=JUAMPI=-text  ^(self pane port: #text) value ifNil: [ self textBlock value ] ifNotNil: [ (self pane port: #text) value ]-=JUAMPI=-scrollToPane: arg1 smooth: arg2  self scrollTo: (pagerModel convertIndexToValue: arg1) smooth: arg2-=JUAMPI=-testWithDisplay  < expectedFailure>  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := GLMTabulator new     column: #stacker;     yourself.  tmp1 transmit     to: #stacker;     andShow: [:arg1 |  arg1 dynamic display: [:arg2 |  | tmp6 |              tmp6 := GLMStacker new.              tmp6 aPane: #all.              tmp6 transmit                 to: #all;                 andShow: [:arg3 |  arg3 text display: [ 'All ' , arg2 asString ] ].              tmp6 ] ].  window := tmp1 openOn: 10.  tmp2 := tmp1 panes first presentations first.  tmp3 := tmp2 cachedPresentation first.  self assert: tmp3 panes first presentations size equals: 1.  tmp4 := tmp3 panes first presentations first.  tmp5 := self findWherePresentationIs: tmp4 in: window.  self assert: tmp5 text asString equals: 'All 10'-=JUAMPI=-hShrinkWrap  super hShrinkWrap.  self labelBrick hShrinkWrap.  self editBrick hShrinkWrap-=JUAMPI=-shouldFilterByTag: arg1  ^self tagsToFilterBy includes: arg1-=JUAMPI=-transmission  ^transmission ifNil: [ transmission := GLMTransmission new ensureReplacePresentationsStrategy.        transmission ]-=JUAMPI=-isOnMyself  ^true-=JUAMPI=-beCentered  isCentered := true.  self isVFilling ifTrue: [ self rubric forceHeight: [ self height - self vPadding ] ]-=JUAMPI=-testTo  browser transmit to: #one.  self assert: browser transmissions first destination pane equals: browser panes first.  self assert: browser transmissions first destination name equals: GLMPortIdentifier defaultTargetPortName-=JUAMPI=-settingsButtonBrick: arg1  settingsButtonBrick := arg1.  self settingsButtonBrick     text: self settingsButtonLabel;     hShrinkWrap;     vAlign: #center;     margin: 10;     when: #onClicked do: [ self openSettingsBrowser ].  self addBrickBack: self settingsButtonBrick-=JUAMPI=-unregisterFromAllAnnouncements  updateActions do: [:arg1 |  arg1 unregisterFromAllAnnouncements ]-=JUAMPI=-resetDataCache  dataCache := nil-=JUAMPI=-hintText  ^hintText ifNil: [ hintText := 'Need help?' ]-=JUAMPI=-actOnPresentationUpdated: arg1  self setLabelOf: window for: arg1 presentation-=JUAMPI=-testShortcutFromKeymap  | tmp1 tmp2 |  tmp2 := Smalltalk os defaultModifier.  tmp1 := GLMAction new.  tmp1 keymap: tmp2 + $i asShortcut.  self assert: tmp1 keymap equals: tmp2 + $i asShortcut.  tmp1 keymap: tmp2 + $i shift.  self assert: tmp1 keymap equals: tmp2 + $i shift.  tmp1 keymap: nil.  self assertEmpty: tmp1 shortcutAsString-=JUAMPI=-removeProperty: arg1  super removeProperty: arg1-=JUAMPI=-testPortsInmmutability  < expectedFailure>  | tmp1 tmp2 |  tmp1 := GLMPane in: 1.  self assertEmpty: tmp1 ports.  tmp2 := tmp1 ports.  tmp2 add: 1.  self assert: tmp2 size equals: 1.  self assertEmpty: tmp1 ports-=JUAMPI=-addAllBricks: arg1  | tmp1 |  tmp1 := self privateAddAllBricks: arg1.  tmp1 do: [:arg2 |  self privatePrepareBrickAfterAdding: arg2 ].  self doLayoutForce.  ^arg1-=JUAMPI=-minWidth  ^minWidth ifNil: [ minWidth := 0 ]-=JUAMPI=-testSelectionAvailableWhenNoSelectionDisabled  | tmp1 |  tmp1 := GLMPresentation new.  tmp1 selection: 1.  self assert: tmp1 selection equals: 1.  self assert: tmp1 rawSelection equals: 1-=JUAMPI=-paddingLeft: arg1  self padding at: Left put: arg1.  self updateCache-=JUAMPI=-list: arg1  list := arg1-=JUAMPI=-addContentsMorph  self contentsMorph: GLMMorphic emptyMorph.  self contentsMorph     layoutFrame: (LayoutFrame identity           leftOffset: 10;           topOffset: 10;           rightOffset: -10;           bottomOffset: -10);     hResizing: #spaceFill;     vResizing: #spaceFill.  self addMorphBack: self contentsMorph-=JUAMPI=-updateTabs  | tmp1 |  self removeAllBricks.  self tabs ifEmpty: [ ^self ].  tmp1 := self selectedTab.  self tabs do: [:arg1 |  arg1 selected: arg1 == tmp1.        arg1 hSpaceFill: (100 / self tabs size) asFloat ].  self addAllBricks: self tabs-=JUAMPI=-textLightColor  ^Color gray-=JUAMPI=-verticallyStackedArrangement  ^self stackedVerticallyArrangement-=JUAMPI=-updateState: arg1  self brickBounds width = arg1 width ifFalse: [ self markWidthDirty ].  self brickBounds height = arg1 height ifFalse: [ self markHeightDirty ]-=JUAMPI=-testBundleStrategy  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMPane named: 'pane1'.  tmp2 := GLMPane named: 'pane2'.  tmp3 := GLMTransmission new.  tmp3 ensureReplacePresentationsStrategy.  tmp3 addActiveOrigin: (tmp1 port: #port1).  tmp3 destination: (tmp2 port: #port2).  tmp3 addPresentation: GLMPresentation new.  (tmp1 port: #port1) value: 1.  tmp3 transmit.  self assert: tmp2 presentations size equals: 1.  tmp4 := tmp2 presentations first.  (tmp1 port: #port1) value: 2.  tmp3 transmit.  self assert: tmp2 presentations first rootPrototype equals: tmp4 rootPrototype.  self assert: tmp2 presentations first ~~ tmp4-=JUAMPI=-dataCache  ^dataCache ifNil: [ dataCache := self class defaultCache ]-=JUAMPI=-zIndex  ^self layout zIndex brickValue: self-=JUAMPI=-children  ^children ifNil: [ children := OrderedCollection new ]-=JUAMPI=-shortcut  ^self keymap ifNotNil: [ self keymap currentCharacter ]-=JUAMPI=-cell  ^cell-=JUAMPI=-popupEditorShadowThemer  ^self registerModule: [ GLMBrickPopupEditShadowThemer new ] to: self named: #popupThemer-=JUAMPI=-textBrick: arg1  textBrick := arg1.  self textBrick wrapped: true.  self textBrick layoutProperties     vSpaceFill;     hSpaceFill.  self addBrickBack: self textBrick-=JUAMPI=-leftoverScrollRange  ^(self totalScrollRange - self innerBounds width roundTo: self scrollDeltaWidth) max: 0-=JUAMPI=-renderPager: arg1  ^arg1 hasFixedSizePanes ifTrue: [ GLMMorphicPagerRenderer render: arg1 from: self ] ifFalse: [  ]-=JUAMPI=-resetContentsRecursively  self resetContents.  self allContents do: [:arg1 |  arg1 resetContentsRecursively ]-=JUAMPI=-profileSelection  self announce: GLMProfileSelection-=JUAMPI=-renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderRubricHighlightedTextPresentation: self-=JUAMPI=-newTextBrick  ^GLMRubEditingAreaBrick new-=JUAMPI=-destination: arg1  destination := arg1-=JUAMPI=-scrollToBottom  self band hasSubbricks ifFalse: [ ^self ].  self scrollTo: self band lastSubbrick-=JUAMPI=-widthLeft: arg1  self width at: Left put: arg1-=JUAMPI=-hintBrick: arg1  hintBrick := arg1.  self hintBrick textColor: self themer popupThemer textColor.  self contentBrick addBrickBack: self hintBrick-=JUAMPI=-newHeaderMorph  ^(self theme newRowIn: self theme for: {self tabSelectorMorph .         self toolbarMorph})     cellInset: 0;     cellPositioning: #bottomCenter;     borderWidth: 0-=JUAMPI=-scrollpane: arg1  scrollpane := arg1-=JUAMPI=-actOnPaneRemoved: arg1  container popPane-=JUAMPI=-showAt: arg1  self     openInWorld;     align: arg1-=JUAMPI=-createSimplePaneMorph  ^Morph new-=JUAMPI=-evaluateSelection  self evaluateSelectionAndDo: [:arg1 |  arg1 ]-=JUAMPI=-modifiedBlock  ^modifiedBlock-=JUAMPI=-when: arg1 send: arg2 to: arg3  self announcer when: arg1 send: arg2 to: arg3-=JUAMPI=-resetDataCache  dataCache := nil-=JUAMPI=-rowMorphFor: arg1  | tmp1 tmp2 |  tmp1 := arg1 rowMorphForColumn: glamourColumn.  tmp1 ifNotNil: [ tmp1 borderWidth: 0 ] ifNil: [ tmp1 := self defaultRowMorph ].  tmp2 := Morph new     color: Color transparent;     layoutPolicy: RowLayout new;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     layoutInset: container columnInset @ container rowInset;     yourself.  tmp2 addMorph: tmp1.  self isFirstColumn ifTrue: [ | tmp3 |        tmp3 := container iconBlock value: arg1.        tmp3 ifNotNil: [ tmp2 addMorph: tmp3 asMorph ].        tmp2 layoutInset: 0 @ container rowInset ].  ^tmp2-=JUAMPI=-paste  self announce: (GLMTextEditorRequest for: #paste)-=JUAMPI=-width: arg1  self brickBounds: (self brickBounds withWidth: arg1)-=JUAMPI=-calculateScrollbarHeight  | tmp1 tmp2 tmp3 |  tmp1 := self approximateBandHeight.  tmp1 = 0 ifTrue: [ ^0 ].  self scrollPane isFullyVisible ifTrue: [ ^0 ].  tmp2 := self scrollPane getIndex: self scrollPane band firstSubbrick.  tmp3 := self scrollPane getIndex: self scrollPane band lastSubbrick.  ^((tmp3 - tmp2 + 1) / self scrollPane model count * self height) ceiling-=JUAMPI=-outOfWorld: arg1  super outOfWorld: arg1.  self brickRoot onRemovedFrom: self-=JUAMPI=-hasBindingOf: arg1  ^self variableBindings includesKey: arg1-=JUAMPI=-newTreeMorph  ^GLMPaginatedMorphTreeMorph new-=JUAMPI=-isForScripting  ^isForScripting ifNil: [ false ]-=JUAMPI=-valueFor: arg1 withIndex: arg2 in: arg3  ^self cacheAt: arg3 title for: arg1 ifAbsentPut: [ self glamourPresentation column: arg3 valueFor: (self glamourPresentation isWithElementIndex ifTrue: [ arg1 asGlamorousMultiValue , arg2 asGlamorousMultiValue ] ifFalse: [ arg1 ]) ]-=JUAMPI=-render: arg1  | tmp1 |  tmp1 := super render: arg1.  arg1 shouldAllExpand ifTrue: [ treeMorph expandAll ].  arg1 shouldRootsExpand ifTrue: [ treeMorph expandRoots ].  arg1 shouldExpandToLevel ifTrue: [ treeMorph expandAllTo: arg1 expandLevel ].  ^tmp1-=JUAMPI=-iconBrick  ^iconBrick-=JUAMPI=-onOpened  super onOpened.  self textEditBrick     takeKeyboardFocus;     selectAll-=JUAMPI=-custom: arg1  ^self add: arg1-=JUAMPI=-actOnTextEditorRequest: arg1  arg1 action value: textMorph textArea editor-=JUAMPI=-initialize  super initialize.  self     useHorizontalLinearLayout;     hShrinkWrap-=JUAMPI=-hShrinkWrap  self layout hShrinkWrap-=JUAMPI=-testFreshBrickIsDirty  self assertBrickDirty: GLMBrick new-=JUAMPI=-shadowColor: arg1  < brickBuilderProperty: #'Look&Feel' name: 'Shadow Color' as: #brickBuilderEvaluate getter: #shadowColor model: #GLMUIBuilderTextFieldProperty>  self setProperty: #brickShadowColor toValue: arg1-=JUAMPI=-openInBrickWindowLabeled: arg1  ^self class environment at: #GLMSystemWindowBrick ifPresent: [:arg2 |  arg2 new           label: arg1;           color: Color transparent;           addBrickBack: (GLMBrick new vSpaceFill                 hSpaceFill;                 addBrickBack: self;                 yourself);           extent: 400 @ 400 * self currentWorld displayScaleFactor;           openCenteredInWorld ] ifAbsent: [ self asMorph openInWindow ]-=JUAMPI=-normalizeWidth: arg1 of: arg2  ^(arg1 max: (arg2 layout minWidth brickValue: arg2)) min: (arg2 layout maxWidth brickValue: arg2)-=JUAMPI=-postCopy  port := port copy-=JUAMPI=-resolveOriginPort: arg1  ^self resolvePort: arg1 asGlamourOriginIdentifier defaultPortName: #selection-=JUAMPI=-testMarkerOneStaticHeight  | tmp1 |  tmp1 := self newBrickWithStaticExtent.  self markFullyClean: tmp1.  tmp1 wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp1 brickApi.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightDirty-=JUAMPI=-sendToOutside: arg1 from: arg2  self sendTo: #outer -> arg1 from: arg2-=JUAMPI=-calculateScrollbarTopOffset  | tmp1 tmp2 tmp3 |  tmp1 := self approximateBandHeight.  tmp1 = 0 ifTrue: [ ^0 ].  tmp2 := self scrollPane getIndex: self scrollPane band firstSubbrick.  tmp3 := self scrollPane getIndex: self scrollPane band lastSubbrick.  ^((tmp2 - 1) / self scrollPane model count * self height) floor-=JUAMPI=-mouseLeave: arg1  super mouseLeave: arg1.  ^self deselect: arg1-=JUAMPI=-approximateWidth  ^self label approximateWidth + self hMargin + self hPadding-=JUAMPI=-icon  ^nil-=JUAMPI=-noActions  actions := nil.  dynamicActionsBlock := nil-=JUAMPI=-updateCache  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self brickBounds origin x.  tmp2 := self brickBounds origin y.  tmp3 := self brickBounds corner x.  tmp4 := self brickBounds corner y.  innerBounds := (tmp1 + self paddingLeft) @ (tmp2 + self paddingTop) corner: (tmp3 - self paddingRight) @ (tmp4 - self paddingBottom).  outerBounds := (tmp1 - self marginLeft) @ (tmp2 - self marginTop) corner: (tmp3 + self marginRight) @ (tmp4 + self marginBottom)-=JUAMPI=-interval  ^self start to: self end-=JUAMPI=-glamourPresentation: arg1  glamourPresentation := arg1-=JUAMPI=-color: arg1  color := arg1-=JUAMPI=-alizarin  ^Color brickColorRegistry at: #brickAlizarin ifAbsentPut: [ Color r: 231 g: 76 b: 60 range: 255 ]-=JUAMPI=-west  direction := West-=JUAMPI=-printOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  ports printOn: arg1.  arg1 nextPut: $)-=JUAMPI=-portSymbol  ^portSymbol-=JUAMPI=-tabLabelThemer  ^self registerModule: GLMBrickTabLabelDarkThemer new-=JUAMPI=-testReferences  | tmp1 tmp2 |  tmp1 := GLMExplicitBrowser new.  tmp2 := tmp1 addNewPaneNamed: #pane1.  self assert: (tmp1 resolveOriginPort: #pane1) identicalTo: (tmp2 port: #selection).  self assert: (tmp1 resolveOriginPort: #pane1 -> #foo) identicalTo: (tmp2 port: #foo).  self assert: (tmp1 resolveDestinationPort: #pane1) identicalTo: (tmp2 port: #entity).  self assert: (tmp1 resolveDestinationPort: #pane1 -> #foo) identicalTo: (tmp2 port: #foo).  self assert: ((tmp1 resolveOriginPort: #outer) isKindOf: GLMPresentationBoundPort).  self assert: (tmp1 resolveOriginPort: #outer) presentation identicalTo: tmp1.  self assert: (tmp1 resolveOriginPort: #outer) name equals: #selection.  self assert: ((tmp1 resolveOriginPort: #outer -> #foo) isKindOf: GLMPresentationBoundPort).  self assert: (tmp1 resolveOriginPort: #outer -> #foo) presentation identicalTo: tmp1.  self assert: (tmp1 resolveOriginPort: #outer -> #foo) name equals: #foo.  self assert: ((tmp1 resolveDestinationPort: #outer) isKindOf: GLMPresentationBoundPort).  self assert: (tmp1 resolveDestinationPort: #outer) presentation identicalTo: tmp1.  self assert: (tmp1 resolveDestinationPort: #outer) name equals: #entity.  self assert: ((tmp1 resolveDestinationPort: #outer -> #foo) isKindOf: GLMPresentationBoundPort).  self assert: (tmp1 resolveDestinationPort: #outer -> #foo) presentation identicalTo: tmp1.  self assert: (tmp1 resolveDestinationPort: #outer -> #foo) name equals: #foo-=JUAMPI=-first  ^self presentations first-=JUAMPI=-testSuspendAllWhile  | tmp1 tmp2 |  announcer when: GLMTestAnnouncement do: [:arg1 |  tmp1 := arg1 ].  tmp1 := nil.  tmp2 := announcer announce: GLMTestAnnouncement.  self assert: tmp1 equals: tmp2.  tmp1 := nil.  announcer suspendAllWhile: [ tmp2 := announcer announce: GLMTestAnnouncement ].  self assert: tmp1 isNil-=JUAMPI=-isHSpaceFill  ^self hState isOnParent-=JUAMPI=-isLeftResizingZone: arg1  ^(self globalBounds withWidth: resizingZoneWidth) containsPoint: arg1 position-=JUAMPI=-toString: arg1  ^self glamourPresentation hasFilterBlock ifTrue: [ arg1 ] ifFalse: [ super toString: arg1 ]-=JUAMPI=-testNoSelection  | tmp1 tmp2 tmp3 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 tree noSelection ].  window := tmp1 openOn: ($a to: $d).  tmp2 := window submorphs last submorphs first submorphs first submorphs first submorphs first.  tmp3 := tmp2 scroller submorphs first.  self send: tmp2 mouseUpOnItem: tmp3.  self assert: tmp1 panes size equals: 1-=JUAMPI=-scrollingDelay: arg1  scrollingDelay := arg1-=JUAMPI=-allowDropOnItem: arg1  allowDropOnItemBlock := arg1-=JUAMPI=-useExplicitNotNil  implicitNotNil := false-=JUAMPI=-testEquality  self assert: (copiedBrowser = browser) not-=JUAMPI=-check  self isChecked ifFalse: [ isChecked := true.        self announce: #onChecked.        self changed ]-=JUAMPI=-actOnVariableBindingsUpdated: arg1  textModel variableBindings: nil.  self addVariableBindingsOn: textModel from: arg1 presentation.  textModel changed: #text.  self flag: 'update just the style here'-=JUAMPI=-totalPaneWidth  ^self innerBounds width - ((self sizing - 1) * self separatorWidth)-=JUAMPI=-dynamicActionsOnSelection  (selectionDynamicActionsBlock isNil or: [ self selectedText isNil ]) ifTrue: [ ^OrderedCollection new ].  ^selectionDynamicActionsBlock glamourValue: self-=JUAMPI=-onCompleted: arg1  callback := arg1-=JUAMPI=-updateWidth: arg1  arg1 isWidthClean ifTrue: [ Exception signal: 'Clean width can''t be updated!' ].  arg1 layout hState updateWidth: arg1 on: self-=JUAMPI=-pane  ^pane-=JUAMPI=-testPresentationTransformation  | tmp1 |  tmp1 := GLMDynamicPresentation new.  tmp1 entity: 42.  tmp1 presentationTransformation: [:arg1 :arg2 |  (1 to: arg2) do: [:arg3 |  arg1 text title: arg3 asString ] ].  self assert: tmp1 currentPresentation presentations size equals: 42.  self assert: tmp1 currentPresentation pane identicalTo: tmp1 pane-=JUAMPI=-setUp  super setUp.  pagerModel := GLMPagerModel new scrollingDelay: 0.  pagerModel defaultNumberOfVisiblePages: 2-=JUAMPI=-testMarkerOneChildrenWidth  | tmp1 |  tmp1 := self newBrickWithFullDependsOnChildren.  self markFullyClean: tmp1.  tmp1 wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp1 brickApi.  self assert: tmp1 wrappedBounds isWidthDirty.  self assert: tmp1 wrappedBounds isHeightClean-=JUAMPI=-synchronizeScrollTo: arg1  pagerModel synchronizeScrollTo: arg1-=JUAMPI=-privateHeight: arg1  self layout height: arg1-=JUAMPI=-testPresentations  | tmp1 |  tmp1 := GLMExpander new.  tmp1 show: [:arg1 |  arg1 text ].  tmp1 startOn: #(#a #b #c).  self assert: tmp1 panes size equals: 3.  self assert: tmp1 panes first presentations entity value equals: #a.  self assert: tmp1 panes first presentations size equals: 1.  self assert: (tmp1 panes first presentations first isKindOf: GLMRubricTextPresentation)-=JUAMPI=-defaultScrollButtonStyleFor: arg1  arg1 checkedIcon: GLMUIThemeExtraIcons glamorousGrayCircleEmpty.  arg1 checkedFocusedIcon: GLMUIThemeExtraIcons glamorousGrayCircle.  arg1 normalImage: GLMUIThemeExtraIcons glamorousGrayCircleEmpty.  arg1 selectedImage: GLMUIThemeExtraIcons glamorousGrayCircle.  arg1 checkedImage: arg1 checkedIcon-=JUAMPI=-glamourPresentation: arg1  glamourPresentation := arg1-=JUAMPI=-renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderFastTreePresentation: self-=JUAMPI=-rubricTextFontSize  ^self valueOfProperty: #brickRubricTextFontSize ifAbsent: [ self themer rubricTextFontSize ]-=JUAMPI=-doesNotUnderstand: arg1  ^self brickRoot perform: arg1 selector withArguments: arg1 arguments-=JUAMPI=-debugSelection  self announce: GLMDebugSelection-=JUAMPI=-childrenValueOf: arg1 atLevel: arg2  self flag: 'this is rather hackish, but needed to treat list and tree in the same way.'.  ^OrderedCollection new-=JUAMPI=-update  super update-=JUAMPI=-padding  ^self wrappedBounds padding-=JUAMPI=-sortByColumn: arg1  columnToSortBy := columnToSortBy == arg1 ifTrue: [ nil ] ifFalse: [ arg1 ].  elements := self elementsSorted.  self glamourPresentation changed-=JUAMPI=-allowItemDragBlock  ^allowItemDragBlock-=JUAMPI=-addBrick: arg1 after: arg2  | tmp1 |  tmp1 := self privateAddBrick: arg1 asBrick after: arg2.  self privatePrepareBrickAfterAdding: tmp1.  self doLayoutForce.  ^arg1-=JUAMPI=-testShortcutAsString  | tmp1 tmp2 |  tmp2 := Smalltalk os menuShortcutModifierString.  tmp1 := GLMAction new.  tmp1 shortcut: $i.  self assert: tmp1 shortcutAsString equals: tmp2 , '+i'.  tmp1 shortcut: $I.  self assert: tmp1 shortcutAsString equals: tmp2 , '+shift+i'.  tmp1 shortcut: nil.  self assertEmpty: tmp1 shortcutAsString-=JUAMPI=-roots  roots ifNil: [ self roots: self glamourExpander panes ].  ^roots-=JUAMPI=-add: arg1 before: arg2  collection add: arg1 before: arg2.  self announce: GLMItemAdded-=JUAMPI=-actOnPresentationToolbarUpdated: arg1  | tmp1 |  self setLabelOf: window for: arg1 presentation.  tmp1 := self renderToolbarForPresentation: arg1 presentation inMorph: window.  tmp1 hResizing: #shrinkWrap.  window toolbarBox: tmp1-=JUAMPI=-paneCount  ^paneCount-=JUAMPI=-fromOutside: arg1  ^self fromOutsidePort: arg1-=JUAMPI=-backgroundColor  ^self theme backgroundColor-=JUAMPI=-measureOpeningTime  | tmp1 tmp2 tmp3 |  tmp2 := 15.  tmp1 := self defaultBrowser.  tmp3 := Time millisecondsToRun: [ tmp2 timesRepeat: [ (tmp1 openOn: 10) delete ] ].  ^{tmp2 .   tmp3}-=JUAMPI=-bounds  ^bounds-=JUAMPI=-click: arg1  super click: arg1.  ^true-=JUAMPI=-firstVisiblePageIndex  ^firstVisiblePageIndex-=JUAMPI=-outerBoundsInParent  ^self owner ifNotNil: [ self wrappedBounds outerBounds translateBy: self owner brickBounds origin ] ifNil: [ self wrappedBounds outerBounds ]-=JUAMPI=-newBrickWithStaticExtent  ^GLMBrick new     height: self staticHeight;     width: self staticWidth;     color: Color random;     yourself-=JUAMPI=-addItemMorph: arg1 after: arg2  self addBrickBackNoLayout: arg1.  self setBoundsOf: arg1 after: arg2.  (self isPartiallyVisible: arg1) ifFalse: [ self removeBrickNoLayout: arg1.        ^nil ].  ^arg1-=JUAMPI=-isDoubleClickEnabled  ^isDoubleClickEnabled ifNil: [ isDoubleClickEnabled := false ]-=JUAMPI=-addTransmission: arg1  arg1 browser: self.  ^self transmissions addLast: arg1-=JUAMPI=-layoutMorphs: arg1  shouldLayoutMorphs := arg1-=JUAMPI=-hasUnacceptedEdits  ^hasUnacceptedEdits ifNil: [ hasUnacceptedEdits := false ]-=JUAMPI=-* arg1  < return: #Point>  ^arg1 negated @ 0-=JUAMPI=-testMarkerOneParentWidth  | tmp1 |  tmp1 := self newBrickWithFullFill.  self markFullyClean: tmp1.  tmp1 wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp1 brickApi.  self assert: tmp1 wrappedBounds isWidthDirty.  self assert: tmp1 wrappedBounds isHeightClean-=JUAMPI=-renderMorphPresentation: arg1  ^GLMMorphicMorphRenderer render: arg1 from: self-=JUAMPI=-isCollection  ^true-=JUAMPI=-registerEventsForPresentation: arg1  super registerEventsForPresentation: arg1.  arg1 when: GLMVariableBindingsChanged send: #actOnVariableBindingsUpdated: to: self.  arg1 when: GLMEvaluateSelection send: #actOnEvaluateSelection: to: self.  arg1 when: GLMCompileText send: #actOnCompileText: to: self.  arg1 when: GLMDebugSelection send: #debugSelection to: self.  arg1 when: GLMProfileSelection send: #profileSelection to: self.  arg1 when: GLMPrintSelection send: #evaluateAndPrintSelection to: self-=JUAMPI=-selectedBorderStyleFor: arg1  ^self theme tabLabelSelectedBorderStyleFor: arg1-=JUAMPI=-compileTextIn: arg1 from: arg2 andDo: arg3  self announce: (GLMCompileText new           presentation: self;           context: arg1;           session: arg2;           action: arg3)-=JUAMPI=-sortByColumn: arg1  columnToSortBy := columnToSortBy == arg1 ifTrue: [ nil ] ifFalse: [ arg1 ].  columnToSortBy ifNotNil: [ self rootItem children: (self rootItem children sorted: self sortBlock) ] ifNil: [ self rootItem data: self basicRoots ].  self glamourPresentation changed-=JUAMPI=-onRemovedFrom: arg1  -=JUAMPI=-registerModule: arg1  ^self registerModule: arg1 to: self named: thisContext sender selector-=JUAMPI=-acceptDroppingMorph: arg1 event: arg2 inMorph: arg3  | tmp1 |  tmp1 := (arg3 scrollerSubMorphFromPoint: arg2 position) complexContents item.  ^self glamourPresentation accept: arg1 passenger droppedOnItem: tmp1-=JUAMPI=-composite: arg1  composite := arg1-=JUAMPI=-shouldUseCache  ^self parameters at: 'shouldUseCache' ifAbsent: [ false ]-=JUAMPI=-delete  super delete.  isOpen := false-=JUAMPI=-testCompositeInTheParentPane  | tmp1 |  tmp1 := GLMBrowser new.  self assert: (tmp1 pane presentations isKindOf: GLMCompositePresentation).  self assert: tmp1 pane presentations size equals: 1.  self assert: tmp1 pane presentations first equals: tmp1-=JUAMPI=-isHeightClean  ^self brick wrappedBounds isHeightClean-=JUAMPI=-wrapped  ^wrapped ifNil: [ wrapped := true ]-=JUAMPI=-percent  ^percent-=JUAMPI=-testMultipleSelectionWithChange  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list           beMultiple;           display: [:arg2 |  arg2 - 2 to: arg2 ] ].  window := tmp1 openOn: 4.  tmp2 := window submorphs last submorphs first submorphs first submorphs first.  tmp4 := tmp2 scroller submorphs first.  tmp5 := tmp2 scroller submorphs last.  self send: tmp2 mouseUpOnItem: tmp4.  self send: tmp2 mouseUpWithShift: true onItem: tmp5.  self assert: (tmp2 model selection selectedNodePathList collect: [:arg3 |  arg3 first item ]) asOrderedCollection equals: #(2 3 4) asOrderedCollection.  (tmp1 pane port: #entity) value: 42.  tmp3 := window submorphs last submorphs first submorphs first submorphs first.  tmp4 := tmp3 scroller submorphs first.  tmp5 := tmp3 scroller submorphs second.  self send: tmp3 mouseUpOnItem: tmp4.  self send: tmp3 mouseUpWithShift: true onItem: tmp5.  self assert: (tmp3 model selection selectedNodePathList collect: [:arg3 |  arg3 first item ]) asOrderedCollection equals: #(40 41) asOrderedCollection-=JUAMPI=-id: arg1  id := arg1-=JUAMPI=-specificTableMorphInitializiation  | tmp1 |  tmp1 := tableModel glamourPresentation.  tableMorph rowHeight: tmp1 rowHeight.  tmp1 isSearchable ifTrue: [ tableMorph enableSearch ].  tmp1 isFilterable ifTrue: [ tmp1 needActionButton ifTrue: [ tableMorph enableFilterWithAction: tmp1 actionBlock named: tmp1 actionName ] ifFalse: [ tmp1 hasFilterBlock ifTrue: [ tableMorph enableFilter: (GLMFilterBlock block: tmp1 filterBlock) ] ifFalse: [ tableMorph enableFilter ] ] ].  (tmp1 isFilterable or: [ tmp1 isSearchable ]) ifFalse: [ tableMorph disableFunction ] ifTrue: [ tableMorph explicitFunction ]-=JUAMPI=-spotterThemer  ^self registerModule: GTSpotterWidgetThemer new to: GTSpotterBrickThemer new-=JUAMPI=-readyToBeDisplayed  self glamourPresentation announcer announce: (GLMDataSourceUpdated newDataSource: self)-=JUAMPI=-invalidateLayout  ^self brick invalidateLayout-=JUAMPI=-addLazyPage: arg1 label: arg2 toolbar: arg3  self addLazyPage: arg1 label: arg2 toolbar: arg3 collapsable: false-=JUAMPI=-isMenu  ^self hasTitle and: [ self hasIcon not ]-=JUAMPI=-render: arg1  paneMorph := GLMMorphic containerMorph.  arg1 when: GLMMatchingPresentationsChanged send: #actOnMatchingPresentationsChanged: to: self.  self renderMorphFor: arg1.  ^paneMorph-=JUAMPI=-addRow: arg1  | tmp1 tmp2 |  tmp2 := arg1 isSymbol ifTrue: [ self browser addNewPaneNamed: arg1.        GLMCustomRow new           id: arg1;           browser: self browser ] ifFalse: [ tmp1 := GLMCustomRow new browser: self browser.        arg1 value: tmp1.        tmp1 ].  self children addLast: tmp2.  ^tmp2-=JUAMPI=-privateStyle: arg1  | tmp1 |  arg1 makeAllColor: Color red.  tmp1 := self parser parse: arg1 asString onError: [  ].  (tmp1 notNil and: [ tmp1 ~~ arg1 ]) ifTrue: [ self flag: 'change only the runs array of the original text.'.        arg1 setString: arg1 string setRunsChecking: tmp1 runs ]-=JUAMPI=-newPane  ^newPane-=JUAMPI=-initializeTextMorph  textMorph := RubScrolledTextMorph new.  textMorph     beReadOnly;     beWrapped;     textFont: self theme textFont;     textColor: self theme textColor;     backgroundColor: self theme errorPopperBackgroundColor.  self     vResizing: #spaceFill;     hResizing: #spaceFill;     addMorph: textMorph fullFrame: LayoutFrame identity-=JUAMPI=-allowItemDrag: arg1  allowItemDragBlock := arg1-=JUAMPI=-privateScrollPosition: arg1  scrollPosition := arg1.  self announcer announce: GLMBrickScrollPositionChanged new-=JUAMPI=-relabelTab: arg1 with: arg2  arg1 label: arg2.  self updateTabs-=JUAMPI=-newVerticalScrollbar  ^GLMScrollbarBrick new-=JUAMPI=-shouldBeDisplayedByText  self containerTree shouldFilterByTextInput ifFalse: [ ^true ].  self withContentsDo: [:arg1 |  self flag: 'this should be delegated to the presentation		and glamourValue should be used to include the entity ports'.        (self containerTree glamourPresentation filterStrategy value: self containerTree inputText asString value: arg1 item) == true ifTrue: [ ^true ] ].  ^false-=JUAMPI=-isOnParent  ^false-=JUAMPI=-asyncTask  ^asyncTask ifNil: [ asyncTask := GLMAsyncTask new ]-=JUAMPI=-isVShrinking  ^vResizing = #shrinkWrap-=JUAMPI=-addBrickBackNoLayout: arg1 before: arg2  self band doNotLayoutDuring: [ self band addBrick: arg1 before: arg2 ].  ^arg1-=JUAMPI=-renderCustomColumn: arg1 ofPane: arg2 inUI: arg3 inBrowser: arg4  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp2 := arg1 children inject: 0 into: [:arg5 :arg6 |  arg5 + arg6 span ].  tmp3 := arg1 children inject: 0 into: [:arg5 :arg6 |  arg5 + arg6 size ].  tmp4 := 0.  tmp5 := 0.  arg1 children keysAndValuesDo: [:arg7 :arg6 |  arg6 hasId ifTrue: [ tmp1 := self renderObject: (arg4 paneNamed: arg6 id) ] ifFalse: [ tmp1 := GLMMorphic containerMorph.              self renderCustomRow: arg6 ofPane: arg2 inUI: tmp1 inBrowser: arg4.              tmp1 addPaneSplitters ].        tmp1 layoutFrame: (LayoutFrame new                 topFraction: tmp4 / tmp2 offset: tmp5 - (tmp3 * tmp4 / tmp2) rounded + self margin;                 leftFraction: 0 offset: 0;                 bottomFraction: (tmp4 + arg6 span) / tmp2 offset: tmp5 + arg6 size - (tmp3 * (tmp4 + arg6 span) / tmp2) rounded - self margin;                 rightFraction: 1 offset: 0;                 yourself).        arg3 addMorphBack: tmp1.        tmp4 := tmp4 + arg6 span.        tmp5 := tmp5 + arg6 size ].  arg1 children last size > 0 ifTrue: [ (arg3 submorphs atLast: 2) layoutFrame bottomOffset: (arg3 submorphs atLast: 2) layoutFrame bottomOffset - tmp5.        arg3 submorphs last layoutFrame topOffset: arg3 submorphs last layoutFrame topOffset - tmp5.        arg3 submorphs last layoutFrame bottomOffset: arg3 submorphs last layoutFrame bottomOffset - tmp5 ].  arg3 addPaneSplitters-=JUAMPI=-testFillBrickInsideStatic  | tmp1 tmp2 |  tmp1 := self newBrickWithStaticExtent.  tmp2 := self newBrickWithFullFill.  tmp2 brickApi layout hState isOnParent.  tmp2 brickApi layout vState isOnParent.  tmp1 addBrickBack: tmp2.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp2 extent equals: tmp1 extent-=JUAMPI=-press  super press.  self closePopup-=JUAMPI=-modelFor: arg1  | tmp1 |  tmp1 := arg1 highlightSmalltalkContext.  ^GLMRubricSmalltalkTextModel new     glamourPresentation: arg1;     highlightSmalltalk: tmp1 notNil;     highlightSmalltalkContext: tmp1;     yourself-=JUAMPI=-complete: arg1 callback: arg2  process ifNil: [ ^self terminate ].  process isTerminated ifFalse: [ ^self ].  callback = arg2 ifFalse: [ ^self terminate ].  callback ifNotNil: [ callback cull: arg1 ].  process := nil-=JUAMPI=-glmSubscriptions  ^registry subscriptions-=JUAMPI=-updatePanes  self basicUpdateSizing.  self layoutPanes.  self hideOrShowScrollBar.  self setScrollDeltas.  self scrollToRight-=JUAMPI=-verticalScrollbar  ^verticalScrollbar-=JUAMPI=-rowMorphForItem: arg1  | tmp1 |  tmp1 := OrderedCollection new.  arg1 depth timesRepeat: [ tmp1 add: self class emptyMorph ].  tmp1 add: (self buttonFor: arg1).  (self iconFor: arg1 data) ifNotNil: [:arg2 |  tmp1 add: arg2 asMorph ].  tmp1     add: (self formatedDisplayValueOf: arg1 data) asMorph asReadOnlyMorph;     addAll: (self tagMorphsFrom: self glamourPresentation for: arg1 data).  ^Smalltalk ui theme newRowIn: self currentWorld for: tmp1-=JUAMPI=-bindingsStrategy: arg1  bindingsStrategy := arg1-=JUAMPI=-postCopy  super postCopy.  presentations ifNotNil: [:arg1 |  presentations := presentations collect: [:arg2 |  arg2 copy ] ].  arrangement ifNotNil: [:arg1 |  arrangement := arrangement copy.        arrangement composite: self ]-=JUAMPI=-text: arg1  text := arg1.  self glamourPresentation ifNotNil: [:arg2 |  arg2 text: text ]-=JUAMPI=-click: arg1  super click: arg1.  self announcer announce: (GLMPagerButtonClicked new buttonModel: self)-=JUAMPI=-measureSelectionTimeForSize: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp2 := 15.  tmp1 := self defaultBrowser.  tmp5 := tmp1 openOn: arg1.  tmp4 := tmp1 panes first ports second.  tmp3 := Time millisecondsToRun: [ arg1 - tmp2 to: arg1 do: [:arg2 |  tmp4 value: arg2 ] ].  tmp5 delete.  ^{arg1 .   tmp3}-=JUAMPI=-computeTagsFilterFor: arg1  ^self computeTagsFor: arg1 from: self tagsFilterBlock-=JUAMPI=-textColor: arg1  < brickBuilderProperty: #Text name: 'Text color' as: #brickBuilderEvaluate getter: #textColor model: #GLMUIBuilderTextFieldProperty>  self label textColor: arg1.  self dotsBrick textColor: arg1-=JUAMPI=-cellColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp1 := self elementAt: arg2.  tmp2 := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForElement: tmp1);     yourself.  ^tmp2-=JUAMPI=-sortBlock: arg1  sortBlock := arg1-=JUAMPI=-testBrickDependsOnChildrenOneStatic  | tmp1 tmp2 |  tmp1 := self newBrickWithFullDependsOnChildren.  tmp2 := self newBrickWithStaticExtent.  tmp1 addBrickBack: tmp2.  self assert: tmp1 brickApi layout hState isOnChildren.  self assert: tmp1 brickApi layout vState isOnChildren.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: tmp2 extent-=JUAMPI=-headerFor: arg1 in: arg2  | tmp1 |  tmp1 := GLMBrick new.  tmp1     hSpaceFill;     vShrinkWrap.  tmp1 addBrickBack: (arg1 isVariableBinding ifTrue: [ arg1 key asBrick ] ifFalse: [ arg1 asBrick ]) hSpaceFill.  (self hasChildren: arg1) ifTrue: [ tmp1 addBrickFirst: (self newToggleButtonFor: arg2) ].  ^tmp1-=JUAMPI=-act: arg1 on: arg2  self addAction: (GLMGenericAction new           action: arg1;           shortcut: arg2;           yourself)-=JUAMPI=-remove: arg1  collection remove: arg1.  self announce: GLMItemRemoved-=JUAMPI=-separatorAfter  ^separatorAfter ifNil: [ false ]-=JUAMPI=-paneMargin  self flag: 'fix support of margin'.  ^0-=JUAMPI=-property  ^property-=JUAMPI=-testUnregisterFromAnnouncementsWhenUpdating  | tmp1 tmp2 tmp3 |  tmp3 := 0.  tmp2 := GLMAnnouncingCollection new.  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text           updateOn: GLMItemAdded from: [ tmp2 ];           display: [ tmp3 := tmp3 + 1 ] ].  window := tmp1 openOn: tmp2.  1 to: 3 do: [:arg2 |  tmp2 add: arg2 ].  self assert: tmp3 equals: 4-=JUAMPI=-onLayouted  self doNotUpdateDuring: [ self update ]-=JUAMPI=-rowHeight  ^self rowHeightBlock glamourValue: self asGlamorousMultiValue , self entity asGlamorousMultiValue-=JUAMPI=-lazyPageMorphCreation: arg1  lazyPageMorphCreation := arg1-=JUAMPI=-loremIpsum  ^String loremIpsum: 81233-=JUAMPI=-updatePreview: arg1  self announcer announce: (GLMPagerPreviewUpdate new pageIndex: arg1)-=JUAMPI=-transformation  ^transformation ifNil: [ transformation := [:arg1 |  arg1 ] ]-=JUAMPI=-onMyselfDo: arg1  ^self on: #isOnMyself do: arg1 ifAbsent: [ GLMBrickLayoutMyselfState new ]-=JUAMPI=-findSatisfying: arg1 in: arg2  arg2 allMorphsDo: [:arg3 |  (arg1 value: arg3) ifTrue: [ ^arg3 ] ].  self fail-=JUAMPI=-paddingLeft  ^self wrappedBounds paddingLeft-=JUAMPI=-withIndexDo: arg1  ^collection withIndexDo: arg1-=JUAMPI=-asGlamourTargetIdentifier  self portName ifNil: [ self portName: self class defaultTargetPortName ].  ^self-=JUAMPI=-arrangement: arg1  arg1 composite: self.  ^arrangement := arg1-=JUAMPI=-entity  ^entity-=JUAMPI=-minimumPageNumberForScrollbar  ^minimumPageNumberForScrollbar-=JUAMPI=-assertHeightDirty: arg1  self assert: arg1 wrappedBounds heightState equals: #dirty.  self assert: arg1 wrappedBounds isHeightDirty.  self assert: arg1 wrappedBounds isHeightClean not-=JUAMPI=-isHorizontal: arg1  isHorizontal := arg1-=JUAMPI=-registerModule: arg1 to: arg2  ^self registerModule: arg1 to: arg2 named: thisContext sender selector-=JUAMPI=-toWatcher  ^self destination: (self browser watcherPane port: #entity)-=JUAMPI=-populate: arg1 iconName: arg2 on: arg3 entitled: arg4 with: arg5  self populate: arg1 icon: (self iconNamed: arg2) on: arg3 entitled: arg4 with: arg5-=JUAMPI=-presentations: arg1  presentations := arg1-=JUAMPI=-menuColumn: arg1 row: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := UIManager default newMenuIn: self table for: self.  tmp2 := Dictionary new.  self allMenuActions do: [:arg3 |  tmp3 := arg3 category notNil ifTrue: [ tmp2 at: arg3 category ifAbsentPut: [ tmp4 := MenuMorph new.                    tmp1 add: arg3 category subMenu: tmp4.                    tmp4 ] ] ifFalse: [ tmp1 ].        (tmp3 add: arg3 title target: self selector: #executeMenuAction: argument: arg3)           icon: arg3 icon;           balloonText: arg3 help;           enabled: (arg3 isEnabledOn: self glamourPresentation);           keyText: (arg3 hasShortcut ifTrue: [ arg3 shortcutAsString ] ifFalse: [ nil ]) ].  ^tmp1-=JUAMPI=-cellColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp1 := self elementAt: arg2.  tmp2 := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForColumn: arg1 item: tmp1 withIndex: arg2);     yourself.  ^tmp2-=JUAMPI=-testCodeExecutionWithBindings  | tmp1 tmp2 tmp3 |  tmp1 := GLMCompositePresentation new.  tmp1 pharoScript.  window := tmp1 openOn: 'a:=1'.  tmp3 := nil.  tmp2 := self find: RubScrolledTextMorph in: window.  tmp2 textArea editor evaluateSelectionAndDo: [:arg1 |  tmp3 := arg1 ].  self assert: tmp3 equals: 1-=JUAMPI=-rightAngle: arg1  ^arg1 = GLMNorthDirection uniqueInstance-=JUAMPI=-stylerStyled: arg1  next ifNil: [ ^self ].  text runs: arg1 runs.  (self textArea scrollPane ifNil: [ self textArea ]) changed-=JUAMPI=-onDraw: arg1  self renderer render: self on: arg1-=JUAMPI=-render: arg1  textModel := self textModelFor: arg1.  textMorph := self textMorphForModel: textModel.  textModel text: textMorph text.  textMorph setSelection: textModel selection.  self installActionsOnModel: textModel fromPresentation: arg1.  self installKeystrokeActionsOnMorph: textMorph textMorph fromPresentation: arg1.  textMorph announcer when: GLMSelectedTextChanged do: [:arg2 |  arg1 announcer suspendAllWhile: [ arg1 selectionInterval: arg2 interval.              arg1 selectedText: arg2 selectedText ] ].  textMorph announcer when: GLMTextChanged do: [:arg2 |  arg1 suspendAllWhile: [ arg1 text: arg2 text ] ].  self registerEventsForPresentation: arg1.  ^textMorph-=JUAMPI=-open: arg1 with: arg2  ^arg1 openAbove: arg2-=JUAMPI=-isWidthClean  ^self brick wrappedBounds isWidthClean-=JUAMPI=-buttonBorderColor  ^Color lightGray-=JUAMPI=-presentation  presentation ifNil: [ | tmp1 |        tmp1 := GLMMorphicRenderer new render: self glmPres.        tmp1 hResizing: #spaceFill.        tmp1 vResizing: #spaceFill.        presentation := MorphicGenericAdapter morph: tmp1 ].  ^presentation-=JUAMPI=-selectedIndex  ^selectedIndex ifNil: [ selectedIndex := 0 ]-=JUAMPI=-selectionIndex: arg1  selectionIndex := arg1-=JUAMPI=-onButtonDeselected  GLMPagerPanePreviewMorph uniqueInstance hideFromWorld-=JUAMPI=-readyToBeDisplayed  self glamourPresentation announcer announce: (GLMDataSourceUpdated newDataSource: self)-=JUAMPI=-onLostFocus  self isCancelOnFocusLost & self isEditMode ifTrue: [ self cancel ].  self isEditMode ifTrue: [ self animateToEditNotFocused ] ifFalse: [ self animateToNormal ]-=JUAMPI=-watcherPane  ^watcherPane ifNil: [ watcherPane := GLMPane named: #_watcher ]-=JUAMPI=-privateRemoveOutWorld: arg1  arg1 outOfWorld: arg1 world-=JUAMPI=-actionSelector  ^#morphicActOn:-=JUAMPI=-border  ^self valueOfProperty: #brickBorder ifAbsentPut: [ GLMBrickBorder new ]-=JUAMPI=-variableBindings  ^(variableBindingsBlock glamourValue: self entity) ifNil: [ OrderedCollection new ]-=JUAMPI=-testAccordion  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 accordionArrangement.        arg1 list title: 'List'.        arg1 text title: 'Text' ].  window := tmp1 openOn: 42.  self assert: self compositePanel submorphs notEmpty.  self assert: self compositePanel submorphs size equals: 2.  self assert: self compositePanel submorphs first class equals: ExpanderMorph.  self assert: self compositePanel submorphs last class equals: ExpanderMorph-=JUAMPI=-clear  arrangement := nil.  presentations := nil-=JUAMPI=-testPanes  self assert: copiedBrowser panes size equals: 2.  self assert: copiedBrowser panes first ~~ browser panes first.  self assert: copiedBrowser panes last ~~ browser panes last.  self assert: copiedBrowser panes first browser identicalTo: copiedBrowser.  self assert: copiedBrowser panes last browser identicalTo: copiedBrowser.  self assert: copiedBrowser panes first ports size equals: 1.  self assert: copiedBrowser panes first ports first name equals: #selection.  self assert: copiedBrowser panes first ports first pane identicalTo: copiedBrowser panes first.  self assert: copiedBrowser panes last ports size equals: 2.  self assert: copiedBrowser panes last ports first name equals: #selection.  self assert: copiedBrowser panes last ports last name equals: #entity-=JUAMPI=-addBrick: arg1 before: arg2  | tmp1 |  tmp1 := self privateAddBrick: arg1 asBrick before: arg2.  self privatePrepareBrickAfterAdding: tmp1.  self doLayoutForce.  ^arg1-=JUAMPI=-glmAnimateValue: arg1 duration: arg2  self glmAnimateValue: arg1 duration: arg2 callback: nil-=JUAMPI=-layoutSubbricks  self layoutPolicy layout: self brickApi in: self innerBounds-=JUAMPI=-actionThemer  ^GLMActionBrickThemer new-=JUAMPI=-textEditBrick  ^textEditBrick-=JUAMPI=-renderFastTreePresentation: arg1  ^GLMMorphicFastTreeRenderer render: arg1 from: self-=JUAMPI=-separatorWidth  ^20-=JUAMPI=-columns: arg1  columns := arg1-=JUAMPI=-animateToEditNotFocused  self borderAnimation     from: self borderColor first;     to: self themer normalBorderColor;     animate: self-=JUAMPI=-column: arg1 evaluated: arg2 modified: arg3  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           modifiedBlock: arg3)-=JUAMPI=-defaultSelectionActions  ^self executionSelectionActions-=JUAMPI=-leftShadowOf: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := arg1 shadowWidth.  tmp4 := tmp2 negated @ tmp2 / 2.0.  tmp3 := arg1 brickBounds topLeft + tmp4 + arg1 shadowOffset.  tmp1 := (self shadowGradientFor: arg1)     origin: tmp3 - tmp4 + ((tmp2 / 2.0) @ 0);     direction: (tmp2 @ 0) negated;     yourself.  arg2 fillRectangle: (tmp3 extent: tmp2 @ (arg1 height - tmp2)) fillStyle: tmp1-=JUAMPI=-changed  self world ifNil: [ ^self ].  ^fullBounds ifNil: [ self invalidRect: self bounds ] ifNotNil: [ self invalidRect: fullBounds ]-=JUAMPI=-testMarkerOneChildrenInStaticWidth  | tmp1 tmp2 |  tmp1 := self newBrickWithStaticExtent.  tmp2 := self newBrickWithFullDependsOnChildren.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthDirty.  self assert: tmp2 wrappedBounds isHeightClean.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightClean-=JUAMPI=-announcer  ^announcer ifNil: [ announcer := GLMAnnouncer new ]-=JUAMPI=-popup: arg1 event: arg2  < return: #Boolean>  ^arg2 type == #keystroke and: [ arg2 keyCharacter = Character escape ]-=JUAMPI=-shouldDisplayPresentationCreatedBy: arg1  ^true-=JUAMPI=-scrollBarColor  ^self valueOfProperty: #brickScrollbarColor ifAbsent: [ self themer scrollbarColor ]-=JUAMPI=-tabWidth  ^tabWidth ifNil: [ TextStyle default rubTabWidth ]-=JUAMPI=-actualPageMorph: arg1  actualPageMorph := arg1-=JUAMPI=-subbrickBefore  | tmp1 |  tmp1 := self brickDoubleLink.  tmp1 ifNil: [ ^nil ].  tmp1 previousLink ifNil: [ ^nil ].  ^tmp1 previousLink value-=JUAMPI=-renderFastListPresentation: arg1  ^GLMMorphicFastListRenderer render: arg1 from: self-=JUAMPI=-scrollDown: arg1  self band translateY: arg1 negated.  self isBottomOverscrolled ifTrue: [ self moveBandBottom ]-=JUAMPI=-tearDown  window ifNotNil: [ window delete ].  super tearDown-=JUAMPI=-variableBindings: arg1  ^variableBindingsBlock := arg1-=JUAMPI=-colorRight  ^self color at: Right-=JUAMPI=-testUnregisterAnnouncementsWhenRemovingPane  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Announcer new.  tmp3 := GLMBrowser new.  tmp4 := GLMPane new.  tmp2 := GLMPresentation new.  tmp4 addPresentation: tmp2.  tmp3 addPane: tmp4.  tmp2 updateOn: GLMTestAnnouncement from: [ tmp1 ].  tmp2 registerAnnouncements.  self assert: tmp1 numberOfSubscriptions equals: 1.  tmp3 removePane: tmp4.  self assert: tmp1 numberOfSubscriptions equals: 0-=JUAMPI=-vMargin  ^self marginTop + self marginBottom-=JUAMPI=-addActiveOrigin: arg1  ^self originReferences add: (GLMOriginPortReference new           port: arg1;           beActive;           yourself)-=JUAMPI=-glamourPresentation  ^glamourPresentation-=JUAMPI=-testFinder  | tmp1 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 title: 'something'.        arg1 stackedArrangement.        arg1 list.        arg1 text ].  self assert: tmp1 transmission transmissionStrategy presentations size equals: 2.  tmp1 startOn: (1 to: 42).  self assert: tmp1 panes first presentations size equals: 2.  self assert: (tmp1 panes first presentations arrangement isKindOf: GLMStackedVerticallyArrangement).  window := tmp1 open.  self find: LazyTabGroupMorph in: window-=JUAMPI=-presentations  ^self pane presentations-=JUAMPI=-removeTabIndex: arg1  self tabs removeAt: arg1.  self selectedIndex: 0.  self tabs ifNotEmpty: [ self selectedIndex: (self selectedIndex - 1) \\ self tabs size + 1 ]-=JUAMPI=-font: arg1  self label font: arg1.  self dotsBrick font: arg1-=JUAMPI=-selectToLeft  self selectedPageIndex: self selectedPageIndex - 1-=JUAMPI=-glamourPresentation  ^glamourPresentation-=JUAMPI=-openInBrickWindow  ^self openInBrickWindowLabeled: self-=JUAMPI=-sizeLogic: arg1  countLogic := arg1-=JUAMPI=-initialize  super initialize.  self on: #keyStroke send: #handleKeyStroke: to: self.  hasInitialStep := false-=JUAMPI=-textModelFor: arg1  ^GLMTextModel new     text: arg1 formatedDisplayValue;     glamourPresentation: arg1-=JUAMPI=-testAccordionWithTitle  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 accordionArrangement.        arg1 title: 'title'.        arg1 list.        arg1 text ].  window := tmp1 openOn: 42.  self assert: self compositeTabGroup submorphs notEmpty.  self assert: self compositeTabGroup submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph class equals: GLMPanelMorph.  self assert: self compositeTabGroup contentMorph submorphs first submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph submorphs first submorphs first class equals: ExpanderMorph-=JUAMPI=-gtActionsIn: arg1  < gtInspectorPresentationOrder: 50>  arg1 list     title: 'Actions';     display: [ self actions ];     format: [:arg2 |  arg2 gtDisplayString ]-=JUAMPI=-column: arg1 evaluated: arg2 width: arg3 tags: arg4 sortedBy: arg5  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           width: arg3;           tags: arg4;           sortBlock: arg5 yourself)-=JUAMPI=-origin: arg1 length: arg2 breadth: arg3  ^arg1 extent: arg2 @ arg3-=JUAMPI=-from: arg1  fromLogic := arg1-=JUAMPI=-hAlign  ^self layout hAlign-=JUAMPI=-helpMessage  ^helpMessage ifNil: [ helpMessage := 'Search Input' ]-=JUAMPI=-newSliderBrick  ^GLMPagerScrollSlidingBrick new-=JUAMPI=-isWidthDirty  ^self widthState = #dirty-=JUAMPI=-transformation  ^transformation-=JUAMPI=-render: arg1  container := GLMMorphic containerMorph.  container     changeTableLayout;     listDirection: #leftToRight;     vResizing: #spaceFill;     hResizing: #shrinkWrap.  scrollPane := GeneralScrollPane new     changeScrollerTableLayout;     scrollTarget: container;     yourself.  self registerAnnouncementsFor: arg1.  arg1 panes do: [:arg2 |  self addMorphFromObject: arg2 toContainer: container ].  ^scrollPane-=JUAMPI=-modules  ^modules ifNil: [ modules := Dictionary new ]-=JUAMPI=-glamourAction: arg1  glamourAction := arg1-=JUAMPI=-transformation: arg1  transformation := arg1-=JUAMPI=-testInnerTransmissions  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMExplicitBrowser new.  tmp2 := GLMExplicitBrowser new.  tmp3 := GLMPresentation new.  tmp1 addNewPane name: 'pane1'.  tmp2 addNewPane name: 'innerpane 1'.  tmp1 addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: tmp1;                 name: #entity;                 yourself);           destination: (tmp1 panes first port: #entity);           addPresentation: tmp2;           yourself).  tmp2 addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: tmp2;                 name: #entity;                 yourself);           destination: (tmp2 panes first port: #entity);           addPresentation: tmp3;           yourself).  (tmp1 pane port: #entity) value: 42.  tmp4 := tmp1 panes first presentations first.  self assert: tmp4 transmissions size equals: 1.  self assert: (tmp4 transmissions first origins first isKindOf: GLMPresentationBoundPort).  self assert: tmp4 transmissions first origins first pane identicalTo: tmp1 panes first-=JUAMPI=-hasMinHeight  ^(self minHeight isNumber ifTrue: [ self minHeight <= 0 ] ifFalse: [ false ]) not-=JUAMPI=-action  ^action-=JUAMPI=-vPadding  ^self paddingTop + self paddingBottom-=JUAMPI=-isEntityPort  ^self name = #entity-=JUAMPI=-when: arg1 send: arg2 to: arg3  self announcer when: arg1 send: arg2 to: arg3-=JUAMPI=-toggleFilteringByTag: arg1  (self shouldFilterByTag: arg1) ifTrue: [ self tagsToFilterBy remove: arg1 ] ifFalse: [ self tagsToFilterBy add: arg1 ].  self resetChildrenContent.  self tableRefresh-=JUAMPI=-printSelection  self announce: GLMPrintSelection-=JUAMPI=-actOnPaneReplaced: arg1  container brickRoot popAndReplacePane: (self renderObject: arg1 newPane)-=JUAMPI=-renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderFastTablePresentation: self-=JUAMPI=-selectedClassOrMetaClass  ^self highlightSmalltalkContext-=JUAMPI=-addPresentations: arg1  self notingPresentationChangeDo: [ arg1 do: [:arg2 |  self addPresentationSilently: arg2 ] ]-=JUAMPI=-category  ^category-=JUAMPI=-testFullAlignCenterShrinkWrapInSpaceFill  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := 10.  tmp1 := self newBrickWithStaticExtent.  tmp2 := self newBrickWithFullFill.  tmp3 := self newBrickWithFullDependsOnChildren.  tmp4 := self newBrickWithSmallStaticExtent.  tmp3     vAlign: #center;     hAlign: #center.  tmp1 addBrickBack: tmp2.  tmp2 addBrickBack: tmp3.  tmp3 addBrickBack: tmp4.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp3 brickBounds equals: ((self staticExtent - self staticSmallExtent) / 2 extent: self staticSmallExtent) ceiling.  tmp4     height: tmp4 height + tmp5;     width: tmp4 width + tmp5.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp3 brickBounds equals: ((self staticExtent - self staticSmallExtent) / 2 - (tmp5 / 2) extent: self staticSmallExtent + tmp5) ceiling-=JUAMPI=-icon  ^icon ifNil: [ icon := [ nil ] ]-=JUAMPI=-acceptsSelection: arg1  acceptsSelection := arg1-=JUAMPI=-filterBlock: arg1  filterBlock := arg1-=JUAMPI=-color  ^self valueOfProperty: #brickBackgroundColor ifAbsent: [ self themer backgroundColor ]-=JUAMPI=-testStartingPreservesItself  | tmp1 tmp2 |  tmp1 := GLMCompositePresentation new.  tmp2 := tmp1 finder.  tmp1 startOn: 42.  self assert: tmp1 pane presentations equals: tmp1.  self assert: tmp1 first identicalTo: tmp2-=JUAMPI=-presentation  ^presentation-=JUAMPI=-layoutPolicy  ^self brick layoutPolicy-=JUAMPI=-addRow: arg1 size: arg2  ^(self addRow: arg1)     size: arg2;     span: 0-=JUAMPI=-buttonForTag: arg1 filter: arg2  ^(GLMMorphic togglingButtonLabelled: arg1 pressed: (self shouldFilterByTag: arg2) style: self glamourPresentation tagsStyle)     target: self;     actionSelector: #toggleFilteringByTag:;     arguments: (Array with: arg2);     yourself-=JUAMPI=-collapse  self contentBrick ifNil: [ ^self ].  self isExpanded ifTrue: [ self removeBrick: self contentBrick ]-=JUAMPI=-bindingsStrategy  ^bindingsStrategy ifNil: [ bindingsStrategy := self defaultBindingsStrategy ]-=JUAMPI=-testGlamourValueWithArgs  self assert: ([ #foo ] glamourValueWithArgs: #(1 2)) equals: #foo.  self assert: ([:arg1 |  Array with: arg1 ] glamourValueWithArgs: #(1 2)) equals: #(1).  self assert: ([:arg1 :arg2 |  Array with: arg1 with: arg2 ] glamourValueWithArgs: #(1 2)) equals: #(1 2).  self assert: ([:arg1 :arg2 :arg3 |  Array with: arg1 with: arg2 with: arg3 ] glamourValueWithArgs: #(1 2)) equals: #(1 2 nil).  self assert: (#yourself glamourValueWithArgs: #(1 2)) equals: 1.  self assert: (#yourself glamourValueWithArgs: #()) equals: nil-=JUAMPI=-markWidthClean  ^self brick wrappedBounds markWidthClean-=JUAMPI=-isVFilling  ^vResizing = #spaceFill-=JUAMPI=-browser  browser ifNil: [ ^GLMNoBrowser new ].  ^browser-=JUAMPI=-vState  ^GLMBrickLayoutDummState new-=JUAMPI=-testCachedPresentation  | tmp1 tmp2 |  tmp1 := GLMDynamicPresentation new.  tmp1 entity: 42.  tmp1 transformation: [:arg1 |  GLMRubricTextPresentation new ].  tmp2 := tmp1 currentPresentation.  self assert: tmp1 cachedPresentation identicalTo: tmp2-=JUAMPI=-buttonsBrick: arg1  buttonsBrick := arg1.  self buttonsBrick pagerModel: pagerModel.  self buttonsBrick     hShrinkWrap;     vShrinkWrap.  self addBrickBack: self buttonsBrick-=JUAMPI=-act  self subclassResponsibility-=JUAMPI=-beEdit  self isEditMode ifTrue: [ ^self ].  self editBrick updateTextWith: self labelBrick text.  self editBrick moveCursorToIndex: self labelBrick text size + 1.  self addBrickFirst: self editBrick.  self removeBrick: self labelBrick.  self borderColor: (self themer focusedBorderColor alpha: 0).  self editBrick rubric takeKeyboardFocus.  self announce: #onEditMode-=JUAMPI=-maxWidth: arg1  self layout maxWidth: arg1-=JUAMPI=-backgroundColor  ^Color transparent-=JUAMPI=-maxHeight: arg1  maxHeight := arg1-=JUAMPI=-sendOneOrMultiple  self sendOneOrMultipleAs: Array-=JUAMPI=-testJumpstartTransmission  | tmp1 tmp2 |  tmp1 := GLMExplicitBrowser new.  tmp2 := GLMPresentation new.  tmp1 addNewPane.  tmp1 addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           addActiveOrigin: (tmp1 pane port: #entity);           destination: (tmp1 panes first port: #entity);           addPresentation: tmp2;           yourself).  self assert: (tmp1 panes first port: #entity) value isNil.  self assertEmpty: tmp1 panes first presentations.  (tmp1 pane port: #entity) value: #foo.  self assert: (tmp1 panes first port: #entity) value equals: #foo.  self assert: tmp1 panes first presentations size equals: 1.  self assert: tmp1 panes first presentations first rootPrototype equals: tmp2-=JUAMPI=-markDirtyCustomDependency: arg1 inContext: arg2  arg1 isBrick not | (arg1 = arg2) ifTrue: [ ^self ].  (self hasCustomDependencies: arg1) ifTrue: [ self markDirty: arg1.        arg1 subbricks do: [:arg3 |  arg3 isBrick ifTrue: [ self markDirty: arg3.                    self markDirtyAround: arg3 inContext: arg1 ] ].        (self customDependencies: arg1) do: [:arg3 |  | tmp1 |              [ tmp1 := (arg3 brickValue: arg1) brickApi ] on: Exception do: [ tmp1 := nil ].              tmp1 ifNotNil: [ (tmp1 = arg2) not & (tmp1 = arg1) not & tmp1 isBrick ifTrue: [ (self isClean: tmp1) ifTrue: [ self markDirty: tmp1.                                self markDirtyAround: tmp1 inContext: arg1 ] ] ] ] ]-=JUAMPI=-onChangeOfPort: arg1 act: arg2  self portChangeActions add: (GLMPortChangeAction new           portName: arg1;           action: arg2)-=JUAMPI=-setFocused  focused ifFalse: [ self checkedImage: checkedFocusedIcon.        self check.        focused := true ]-=JUAMPI=-value: arg1 in: arg2  (self validate: arg1) ifFalse: [ ^self ].  self port value: arg1 in: arg2-=JUAMPI=-notingPresentationChangeDo: arg1  arg1 value-=JUAMPI=-glamourExpander  ^glamourExpander-=JUAMPI=-testIsRendered  self assert: tabs pages first isRendered not.  tabs selectedPageIndex: 1.  self assert: tabs pages first isRendered.  self assert: tabs pages second isRendered not-=JUAMPI=-column: arg1  ^self addColumn: arg1-=JUAMPI=-dragResizingLeft: arg1  | tmp1 tmp2 |  tmp2 := self brickBounds right.  tmp1 := arg1 position x - self owner globalBounds left - startDragX.  tmp1 := (tmp1 max: 0) min: tmp2 - self pagerModel circleButtonSize.  self setPosition: tmp1 @ tmp2-=JUAMPI=-checkBrick: arg1  checkBrick := arg1.  self box     borderColor: self themer checkboxBorderColor;     borderWidth: self themer checkboxBorderWidth;     vAlign: #center;     checkedImage: self themer checkboxCheckedImage;     width: self themer checkboxWidth;     height: self themer checkboxHeight.  self addBrickFirst: self box-=JUAMPI=-newDataSource: arg1  newDataSource := arg1-=JUAMPI=-shoutAboutToStyle: arg1  self highlightSmalltalk ifFalse: [ ^false ].  self highlightSmalltalkContext ifNotNil: [:arg2 |  arg1 classOrMetaClass: arg2 ].  ^true-=JUAMPI=-shouldUseCache  ^self glamourPresentation shouldUseCache-=JUAMPI=-step  | tmp1 |  tmp1 := self textLogic value asString.  self text = tmp1 ifTrue: [ ^self ].  self text: tmp1.  self doLayoutForce-=JUAMPI=-updateInsetAndSpacing  self triggerBrick margin: {self inset top .         self inset right .         0 .         self inset left}.  self contentBrick margin: {self spacing .         self inset right .         self inset bottom .         self inset left}-=JUAMPI=-computeWidth  ^self pagerModel ifNil: [ 0 ] ifNotNil: [:arg1 |  arg1 circleButtonSize * arg1 actualNumberOfVisiblePages ]-=JUAMPI=-invalidateMorphBounds: arg1  | tmp1 tmp2 tmp3 |  isLayouting & arg1 not ifTrue: [ ^self ].  tmp1 := self paddingLeft @ self paddingTop.  tmp2 := self paddingRight @ self paddingBottom.  tmp3 := self globalBounds.  tmp3 := tmp3 origin + tmp1 corner: tmp3 corner - tmp2.  self morph bounds: tmp3-=JUAMPI=-in: arg1  table := arg1.  self initializeColumns-=JUAMPI=-popAndReplacePane: arg1  transform removeMorph: transform lastSubmorph.  transform submorphs isEmpty ifFalse: [ transform removeMorph: transform lastSubmorph ].  paneCount := paneCount - 1.  arg1     borderWidth: 0;     hResizing: #spaceFill;     vResizing: #spaceFill;     layoutInset: 0.  transform hasSubmorphs ifTrue: [ transform addMorphBack: self separator ].  transform addMorphBack: (arg1 adoptPaneColor: self paneColor).  paneCount := paneCount + 1.  self updatePanes-=JUAMPI=-morph: arg1  morphBuilder := arg1-=JUAMPI=-isHeightCustom  ^self vState isOnMyself-=JUAMPI=-addDefaultStatusbarTransmissionFrom: arg1  | tmp1 |  tmp1 := GLMTransmission new     ensureReplacePresentationsStrategy;     addActiveOrigin: (arg1 port: #status);     destination: (self statusbarPane port: #entity);     addPresentation: self statusbarPresentation;     yourself.  self addTransmission: tmp1-=JUAMPI=-setProperty: arg1 toValue: arg2  super setProperty: arg1 toValue: arg2-=JUAMPI=-scrollToPane: arg1 callback: arg2  self scrollTo: (self convertIndexToValue: arg1) smooth: true callback: arg2-=JUAMPI=-