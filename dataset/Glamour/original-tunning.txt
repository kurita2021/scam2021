updateRoots  roots := nil.  self changed: #rootNodescolumn: aBlockOrString evaluated: aBlock  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock)percent: anObject  percent := anObjectouterPortEvent: aPortEvent  self announce: (GLMContextChanged new           presentation: self;           property: aPortEvent portName;           value: aPortEvent value;           oldValue: aPortEvent oldValue;           yourself).  self portChangeActions do: [:each |  each portName = aPortEvent portName ifTrue: [ each actOn: self ] ]passiveOrigins  ^(self originReferences select: [:each |  each isPassive ]) collect: [:each |  each port ]forceHeight: anObject  customHeight := anObjectdoOpen: aUI  ^self subclassResponsibilityhintTitle: anObject  hintTitle := anObjectshadowOffset  ^0 @ 0markLayoutClean  self layout markCleananimateToEditFocused  self borderAnimation     from: self borderColor first;     to: self themer focusedBorderColor;     animate: selftestToSend  | list |  list := GLMListPresentation new.  list selectionTransformation: [:x |  x + 1 ].  list entity: (1 to: 100).  list selection: 41.  self assert: list selection equals: 42modifiedBlock: anObject  modifiedBlock := anObjectbrickDoubleLink  ^self valueOfProperty: #brickDoubleLink ifAbsentPut: [ nil ]testSimpleTransmissionsToOuter  | browser |  browser := GLMTabulator new.  browser column: #one.  browser sendTo: #outer -> #increased from: #outer -> #entity with: [:x |  x + 1 ].  browser transmit     to: #one;     from: #outer port: #increased;     andShow: [:a |  a text ].  browser startOn: 41.  self assert: ((browser paneNamed: #one) port: #entity) value equals: 42subbrickAfter  | link |  link := self brickDoubleLink.  link ifNil: [ ^nil ].  link nextLink ifNil: [ ^nil ].  ^link nextLink valuerubric  ^self morphpagerBar  ^pagerBarrenderWithTitle: aPresentation  | morph |  morph := self renderObject: aPresentation.  ^self morph: morph withTitleOf: aPresentationkeystroke: anEvent from: aMorph  anEvent anyModifierKeyPressed ifTrue: [ ^super keystroke: anEvent from: aMorph ].  self glamourPresentation text: self text.  ^falsecolorTop  ^self color at: ToprenderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderFastTreeWithColumnsPresentation: selftitle  ^titlecheckedFocusedIcon  ^checkedFocusedIconexecuteMenuAction: anAction  self announcer announce: (GLMMenuItemSelected action: anAction)isRunningInUIProcess  ^UIManager default uiProcess == Processor activeProcessactOnContextChanged: ann  ann property = #selectionInterval ifTrue: [ ann value notNil ifTrue: [ textMorph setSelection: ann value ] ifFalse: [ textMorph setSelection: (1 to: 0) ] ]sortBlock  ^columnToSortBy sortBlock ifNil: [ | defaultSortBlock |        defaultSortBlock := columnToSortBy defaultSortBlockForPresentation: self glamourPresentation.        [:x :y |  defaultSortBlock value: x data value: y data ] ]separatorBefore  ^separatorBefore ifNil: [ false ]sendTo: aDesinationPortReference from: anOriginPortReference with: aBlock  self transmissions addLast: (GLMTransmission new           addActiveOrigin: (self resolveOriginPort: anOriginPortReference);           destination: (self resolveDestinationPort: aDesinationPortReference);           transformation: aBlock;           yourself)oldValue: anObject  oldValue := anObjectupdateWidth: aBrick on: aLayout  aBrick outerWidth: (aLayout normalizeWidth: (aLayout widthParentDependency: aBrick) of: aBrick)textColor  ^self valueOfProperty: #brickTextColor ifAbsent: [ self themer textColor ]state  ^self subclassResponsibilitytestDefaultPortValue  | pane |  pane := GLMPane named: 'test'.  self assert: (pane port: #somePort) value isNiltabs  ^tabsaction: aBlock  action := aBlocktestChildrenBlockTakesEntity  | browser receivedEntity |  browser := GLMFinder new.  receivedEntity := nil.  browser show: [:a |  a tree children: [:each :entity |  receivedEntity := entity.              #() ] ].  window := browser openOn: ($a to: $d).  self waitUntilUIRedrawed.  self assert: receivedEntity equals: ($a to: $d)popupThemer  ^self registerModule: GLMBrickPopupThemer newhasTitleIcon  ^self titleIcon notNiladdPresentations: aCollection  self transmissionStrategy addPresentations: aCollectiontestShrinkWrapInStaticWithNeighbours  | root band child1 child2 neighbour childWidth width |  width := 20.  childWidth := self staticWidth - width.  root := self newBrickWithStaticExtent useHorizontalLinearLayout.  band := GLMBrick new     useVerticalLinearLayout;     hSpaceFill;     vShrinkWrap.  child1 := GLMBrick new     height: self staticHeight;     hSpaceFill.  child2 := GLMBrick new     height: self staticHeight;     hSpaceFill.  neighbour := GLMBrick new     vSpaceFill;     width: width.  root addAllBricks: {band .         neighbour}.  band addAllBricks: {child1 .         child2}.  self assertAllSubbricksAreClean: root.  self assert: root brickBounds equals: (0 @ 0 extent: self staticExtent).  self assert: neighbour brickBounds equals: (childWidth @ 0 extent: width @ self staticHeight).  self assert: child1 brickBounds equals: (0 @ 0 extent: childWidth @ self staticHeight).  self assert: child2 brickBounds equals: (0 @ self staticHeight extent: childWidth @ self staticHeight).  self assert: band brickBounds equals: (0 @ 0 extent: childWidth @ (self staticHeight + self staticHeight))presentation  ^presentationaccept  self text: self editBrick text.  self borderColor: self themer color emerald.  self beNormalpane: aPane  pane := aPanevariableBindings  ^variableBindings ifNil: [ variableBindings := Dictionary new ]testImplicitNotNilMultipleValues  | presentation |  presentation := GLMPresentation new.  presentation useImplicitNotNil.  (presentation pane port: #entity) value: (GLMMultiValue withAll: #(nil nil)).  self assert: presentation matches not.  (presentation pane port: #entity) value: (GLMMultiValue withAll: #(1 nil)).  self assert: presentation matches not.  (presentation pane port: #entity) value: (GLMMultiValue withAll: #(nil 1)).  self assert: presentation matches not.  (presentation pane port: #entity) value: (GLMMultiValue withAll: #(1 2)).  self assert: presentation matchesrubricBorderColor  ^Color transparentscrollPageDown  self     scrollDown: self calculateMaxVelocity;     update;     changedstartTime  ^startTime ifNil: [ startTime := Time millisecondClockValue ]clearUserEdits  self hasUnacceptedEdits: falsesubmit: aBlock  aBlock cull: self submitonLayouted  ^self brick onLayoutedprintOn: aStream  super printOn: aStream.  aStream     nextPut: Character space;     nextPutAll: self identityHash printString;     nextPutAll: ' (name=';     nextPutAll: self name printString;     nextPutAll: ' value=';     nextPutAll: self value printString;     nextPut: $)tabs: anObject  tabs := anObjectmarkClean  isDirty := falserowMorphElementsForFirstColumn: aColumn item: anItem in: rowElements  (self iconFor: anItem) ifNotNil: [:anIcon |  rowElements add: anIcon asMorph ]interactionModel  ^selfunsubscribeListeners  self activeHand removeEventListener: selfactOnUpdatedPresentation: anAnnouncement  tableModel resetElements.  tableMorph refreshtestConditionalPresentation  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #two;     from: #one;     andShow: [:a |  a text when: [:x |  x = 42 ].        a list when: [:x |  x > 42 ] ].  ((browser paneNamed: #one) port: #selection) value: 42.  self assert: (browser paneNamed: #two) matchingPresentations size equals: 1.  self assert: ((browser paneNamed: #two) matchingPresentations first isKindOf: GLMRubricTextPresentation).  ((browser paneNamed: #one) port: #selection) value: 43.  self assert: (browser paneNamed: #two) matchingPresentations size equals: 1.  self assert: ((browser paneNamed: #two) matchingPresentations first isKindOf: GLMListPresentation)selectedTextBlock: anObject  selectedTextBlock := anObjectpharoMethod  ^self custom: GLMPhlowPharoMethodBrick newapproximateHeight  ^self labelBrick approximateHeight + self vMargin + self vPaddingbrickRoot  ^self owner ifNotNil: [ self owner brickRoot ] ifNil: [ ^self ]setWidthAfterResizing  | left right |  left := pagerModel circleButtonSize * (pagerModel firstVisiblePageIndex - 1).  right := left + self computeWidth.  self setPosition: left @ rightnewButtonBrick  ^GLMButtonBrick newparentNode  ^parentNodedoLayout  self isLayotingAllowed ifTrue: [ GLMBrickLayouter uniqueInstance layoutIn: self brickApi ]shouldExpandToLevel: level  ^expandLevel := leveltestUpdateOnTriggered  | pane presentation announcer timesTriggered |  pane := GLMPane named: 'test'.  presentation := GLMPresentation new.  announcer := Announcer new.  pane addPresentation: presentation.  timesTriggered := 0.  presentation when: GLMPresentationUpdated do: [:announcement |  timesTriggered := timesTriggered + 1 ].  presentation updateOn: GLMTestAnnouncement from: #yourself.  presentation entity: announcer.  presentation registerAnnouncements.  announcer announce: GLMTestAnnouncement.  self assert: timesTriggered equals: 1testAsOriginIdentifier  | id |  id := GLMPortIdentifier new.  self assert: id asGlamourOriginIdentifier equals: idnewLabelBrick  ^GLMLabelBrick newisLastInOwner  ^self brickDoubleLink ifNotNil: [:bdl |  bdl hasSuccessor not ] ifNil: [ false ]entity: anObject  self transformedEntity: (self displayLogic phlowValue: anObject).  super entity: anObjectdefaultSelectionActions  ^self executionSelectionActions , self browsingSelectionActions , self codeEditingSelectionActionsinitializeTableModel: aPresentation  tableModel := (self createDataSourceFrom: aPresentation)     glamourPresentation: aPresentation;     yourself.  self specificDataSourceInitializiationhandlesMouseOver: evt  ^self isEnabled ifTrue: [ true ] ifFalse: [ super handlesMouseDown: evt ]defaultFillStyle  ^SolidFillStyle color: Color transparentvShrinkWrap  vResizing := #shrinkWrap.  self height: [ self morph height ]doLayout  self brickRoot doLayoutForceselectionIndex  ^selectionIndexwhen: aventName do: aBlock  self announcer when: aventName do: aBlockact: aBlock entitled: aString  self addAction: (GLMGenericAction new           action: aBlock;           title: aString;           yourself)testUpdateAction  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #one;     andShow: [:a |  a list populate: #foo on: $m with: [:list :input |  42 ] ].  browser transmit     to: #two;     from: #one port: #foo;     andShow: [:a |  a text ].  browser startOn: #(1 2 3).  self assert: browser panes first presentations size equals: 1.  self assertEmpty: browser panes last presentations.  browser panes first presentations first actions first actOn: browser panes first presentations first.  self assert: browser panes second presentations size equals: 1.  self assert: browser panes second presentations first entity equals: 42mouseEnter: evt  super mouseEnter: evt.  ^self select: evtcallback: anObject  callback := anObjectformatSourceCode  self glamourPresentation formatSourceCodeinactiveFillStyle  ^self theme watcherWindowInactiveFillStyleFor: selfaddPane: aPane  aPane browser: self.  self panes add: aPane.  self hasStatusbar ifTrue: [ self addDefaultStatusbarTransmissionFrom: aPane ].  ^aPanepaneWidthsToFit: limit  | padded |  padded := Array new: self paneCount.  padded atAllPut: (limit / self sizing) floor.  (1 to: limit - padded sum) do: [:i |  padded at: i put: (padded at: i) + 1 ].  ^paddedhSpaceFill: anInteger  self hPercent: anIntegerminHeight  ^minHeight ifNil: [ minHeight := 0 ]withAnnotation: aBoolean  withAnnotation := aBooleanvSpaceFill: anInteger  super vSpaceFill: anInteger.  self label vSpaceFillbandTopOffset  ^self band brickBounds topshowScrollBarWhenNeeded  ^showScrollBarWhenNeeded ifNil: [ showScrollBarWhenNeeded := true ]textColor  ^Color r: 0 g: 115 b: 0 range: 255resolveDestinationPort: aPortReference  self flag: 'this is a temporary hack due to initializeScripting transmitting directly a port'.  (aPortReference isKindOf: GLMPort) ifTrue: [ ^aPortReference ].  ^self resolvePort: aPortReference asGlamourTargetIdentifier defaultPortName: #entitycontextClass: aClassOrBlock  contextClass := aClassOrBlocksetUp  super setUp.  pane := GLMPane named: 'test'.  presentation := GLMTreePresentation new.  pane addPresentation: presentation.  presentation entity: #(#($a $b $c $d) #($e $f) #($g)).  presentation children: [:x :i |  x asString size > 1 ifTrue: [ x ] ifFalse: [ OrderedCollection new ] ].  presentation shouldValidate: trueactOnContextChanged: ann  ann property = #activePresentation ifTrue: [ tabs announcer suspendAllWhile: [ tabs selectedPageIndex: (ann presentation matchingPresentations indexOf: ann value) ] ]normalizePaneIndex: anIndex  anIndex < 1 ifTrue: [ ^1 ].  anIndex > self size ifTrue: [ ^self size ].  ^anIndexrender: aBrowser  | container |  container := GLMMorphic containerMorph.  aBrowser cell isRow ifTrue: [ self renderCustomRow: aBrowser cell ofPane: aBrowser pane inUI: container inBrowser: aBrowser ] ifFalse: [ self renderCustomColumn: aBrowser cell ofPane: aBrowser pane inUI: container inBrowser: aBrowser ].  aBrowser when: GLMBrowserClosed send: #actOnBrowserClosed: to: self.  ^containerscrollBarMenuButtonPressed: anObject  defaultRenderer  ^GLMBrickAreaRenderer newbuttonBackgroundColor  ^Color veryDarkGray lighterlayoutPolicy: aLayout  super layoutPolicy: aLayoutforceStopStepping  stopStepping := true.  self changeduseCache  self parameters at: 'shouldUseCache' put: trueimplementorsOfIt  self announce: (GLMTextEditorRequest for: #implementorsOfIt)isDependsOnChildren: aBrick  ^(self stateOf: aBrick) isOnChildrenhighlightSmalltalkContext: anObject  highlightSmalltalkContext := anObjectsmooth: anObject  smooth := anObjectisFoundationBrick  ^falsetestPublishing  | browser |  browser := GLMTabulator new.  browser column: #classes.  browser sendToOutside: #selectedClass from: #classes -> #selection.  browser sendTo: #classes -> #highlight fromOutside: #highlightedClass.  (browser panes first port: #selection) value: 42.  self assert: (browser pane port: #selectedClass) value equals: 42.  self assert: (browser panes first port: #selection) value equals: 42.  (browser pane port: #highlightedClass) value: 43.  self assert: (browser pane port: #highlightedClass) value equals: 43.  self assert: (browser panes first port: #highlight) value equals: 43.  (browser panes first port: #highlight) value: 44.  self assert: (browser pane port: #highlightedClass) value equals: 43.  self assert: (browser panes first port: #highlight) value equals: 44.  (browser pane port: #selectedClass) value: 45.  self assert: (browser pane port: #selectedClass) value equals: 45.  self assert: (browser panes first port: #selection) value equals: 42testCopyRootPrototype  | presentation newPresentation yetAnotherPresentation |  presentation := GLMPresentation new.  newPresentation := presentation copy.  self assert: newPresentation rootPrototype equals: presentation.  self assert: newPresentation parentPrototype equals: presentation.  yetAnotherPresentation := newPresentation copy.  self assert: yetAnotherPresentation rootPrototype equals: presentation.  self assert: yetAnotherPresentation parentPrototype equals: newPresentationpathIn: aCollection  self parentNode ifNotNil: [ (aCollection includes: self parentNode) ifFalse: [ self parentNode pathIn: aCollection ] ].  aCollection add: self.  ^aCollectionformatLogic  ^self valueOfProperty: #phlowFormat ifAbsent: [ #yourself ]testTypeOfMultipleSelection  | composer firstTreeMorph treeNodeMorph |  composer := GLMCompositePresentation new.  composer list beMultiple.  window := composer openOn: {{1} asSet .         {1} asOrderedCollection}.  firstTreeMorph := self find: MorphTreeMorph in: window.  treeNodeMorph := firstTreeMorph scroller submorphs first.  self send: firstTreeMorph mouseUpOnItem: treeNodeMorph.  self assert: composer selection asOrderedCollection equals: {{1} asSet} asOrderedCollectionmessageBrick: anObject  messageBrick := anObject.  self messageBrick     hSpaceFill;     vAlign: #center;     margin: 10;     text: self privacyMessage.  self addBrickBack: self messageBrickweightValue: anInteger  self label weightValue: anInteger.  self dotsBrick weightValue: anIntegerleft  ^GLMSouthDirection uniqueInstancematchingPresentations  ^self presentations select: [:each |  each matches ]formatedDisplayValueOf: anElement  ^self cacheAt: #formatedDisplayValue for: anElement ifAbsentPut: [ self glamourPresentation formatedDisplayValueOf: anElement ]showOnlyBrowser  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #one;     andShow: [:a |  a list           display: [:x |  1 to: x * 3 ];           showOnly: 50 ].  browser transmit     to: #two;     from: #one;     andShow: [:a |  a list           display: [:x |  1 to: x * 3 ];           showOnly: 50 ].  browser transmit     to: #one;     from: #two;     andShow: [:a |  a list           display: [:x |  1 to: x * 3 ];           showOnly: 50 ].  ^browserbuildLabelFrom: aStringOrMorph withAction: aBrick  | label innerLabel |  innerLabel := aStringOrMorph isMorph ifTrue: [ aStringOrMorph ] ifFalse: [ | container labelMorph |        container := GLMBrick new.        labelMorph := GLMLabelBrick new           text: aStringOrMorph;           textColor: container themer textSecondaryColor;           hSpaceFill;           vSpaceFill;           marginLeft: 5.        container           addBrickBack: labelMorph;           hSpaceFill;           vSpaceFill.        container maxWidth: [ 5 + labelMorph approximateWidth + (aBrick ifNotNil: [:b |  b normalImage width * 1.5 ] ifNil: [ 0 ]) ].        container ].  label := aBrick ifNil: [ innerLabel ] ifNotNil: [ aBrick           vSpaceFill;           width: aBrick normalImage width * 1.5.        innerLabel addBrickBack: aBrick.        innerLabel ].  ^labelcolumn: aBlockOrString evaluated: aBlock tags: anObject  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           tags: anObject)initialize  super initialize.  self band useVerticalLinearLayoutwithColumns  ^withColumns ifNil: [ withColumns := false ]testMinWidthOneStatic  | brick |  brick := self newBrickWithSmallStaticExtent.  brick minWidth: self staticWidth.  brick doLayoutForce.  self assertAllSubbricksAreClean: brick.  self assert: brick brickBounds equals: (0 @ 0 extent: self staticWidth @ self staticSmallHeight)fastList  ^self custom: GLMFastListPresentation newpager  ^self custom: GLMPager newrubricTextColor: aColor  self setProperty: #brickRubricTextColor toValue: aColor.  self updateStylecomputeOriginFor: aMorph  | desiredTop desiredLeft |  aMorph textArea scrollSelectionIntoView: nil.  desiredTop := (self originMorphFor: aMorph) positionInWorld y - 6.  desiredLeft := (self originMorphFor: aMorph) right + aMorph positionInWorld x + 6.  ^desiredLeft @ desiredTopactualPageMorph  ^actualPageMorph ifNil: [ actualPageMorph := self lazyPageMorphCreation value           hResizing: #spaceFill;           vResizing: #spaceFill;           yourself ]updateStyle  self borderWidth: self themer buttonBorderWidth.  self borderColor: self themer buttonBorderColor.  self padding: self themer buttonPadding.  self normalColor: self themer buttonBackgroundColor.  self selectedColor: self themer buttonSelectedColor.  self pressedColor: self themer buttonPressedColor.  self minWidth: self themer buttonMinWidth.  self minHeight: self themer buttonMinHeight.  self doLayoutForcesimilar: aLength  ^(self class direction: self direction)     length: aLength;     yourselfisLayotingAllowed  ^self valueOfProperty: #brickLayoutingAllowed ifAbsent: [ true ]useImplicitAllNil  implicitAllNil := truetransformed: aBlock  self transformation: aBlockdoItContext: aOneArgBlock  doItContext := aOneArgBlockreceive: aTransmission in: aContext  self seenTransmissions addLast: aTransmission.  ^super receive: aTransmission in: aContextscrollValue  ^currentScrollDeltacolumn: aBlockOrSymbol  ^self addColumn: aBlockOrSymbolexpand  self contentBrick ifNil: [ ^self ].  self isExpanded ifFalse: [ self addBrickBack: self contentBrick ]leftPosition: anInteger  leftPosition := anIntegerscrollTo: aValue smooth: aBoolean  self scrollTo: aValuepage: anObject  page := anObjectnewTabSelectorMorph  ^GLMTabSelectorBrick new     minHeight: self theme buttonMinHeight;     hSpaceFill;     vResizing: #shrinkWrapinitializeListeners  self activeHand addEventListener: selfstrongSelectionValue: anObject  strongSelectionValue := anObjectglamourValueWithArgs: anArray  ^anArray anySatisfy: [:each |  each notNil ]rubricTextFontSize: aFloat  self setProperty: #brickRubricTextFontSize toValue: aFloat.  self updateStyletheme  ^Smalltalk ui thememodel: anAdaptor  adaptor := anAdaptor.  self initializeItemsupdateOn: anAnnouncement from: aBlockOrSymbol  updateActions add: (GLMSingleUpdateAction new           presentation: self;           announcement: anAnnouncement;           transformation: aBlockOrSymbol;           yourself)hoverIcon  ^self selectedImageaPane: aBlockOrSymbol  ^self addNewPaneNamed: aBlockOrSymbolonScrollBoundsChanged: boundsChangedAnnouncement  self markButtonsInside: boundsChangedAnnouncement boundstestExplicitNotNilMultipleValues  | presentation |  presentation := GLMPresentation new.  presentation useExplicitNotNil.  (presentation pane port: #entity) value: (GLMMultiValue withAll: #(nil nil)).  self assert: presentation matches not.  (presentation pane port: #entity) value: (GLMMultiValue withAll: #(1 nil)).  self assert: presentation matches.  (presentation pane port: #entity) value: (GLMMultiValue withAll: #(nil 1)).  self assert: presentation matches.  (presentation pane port: #entity) value: (GLMMultiValue withAll: #(1 2)).  self assert: presentation matchesallActionsWithShortcuts  ^self allActions , self allSelectionActions select: [:action |  action hasShortcut ]* aNumber  < return: #Point>  ^self subclassResponsibilitytestNamed  | aPane |  aPane := GLMPane named: 1.  self assert: aPane name equals: 1.  self assert: aPane browser equals: GLMNoBrowser new.  self assertEmpty: aPane ports.  self assert: aPane presentations isEmptypaneNamed: aSymbol  ^self panes detect: [:each |  each name = aSymbol ]presentations  < debuggingStone: #presentationCreation label: 'Presentation creation'>  | presentations |  presentations := GLMCompositePresentation new.  self presentationsFactory glamourValue: presentations asGlamorousMultiValue , (self transmission origins collect: #value).  ^presentationsshouldUseCache  ^self glamourPresentation shouldUseCachehasProperty: aSymbol  ^super hasProperty: aSymbolmaxPanes: anInteger  maxPanes := anIntegeronLayoutEvent: aLayoutEvent  selectionInterval: anInterval  (self pane port: #selectionInterval) value: anIntervalactOnPresentationUpdated: ann  container removeAllMorphs.  container addMorphBack: (self morphFrom: ann presentation)tagsFilterBlock  ^tagsFilterBlocktestTabsWithTitle  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a title: 'title'.        a list.        a text ].  window := browser openOn: 42.  self assert: self compositeTabGroup submorphs size equals: 2.  self assert: self compositeTabGroup submorphs first class equals: GLMPanelMorph.  self assert: self compositeTabGroup submorphs first submorphs size equals: 1.  self assert: self compositeTabGroup submorphs first submorphs first class equals: LazyTabGroupMorph.  self assert: self compositeTabGroup submorphs first submorphs first pages size equals: 2testResetValue  | port |  port := GLMTestPane new port: #port1.  port value: 42.  self assert: port value equals: 42.  port resetValue.  self assert: port value isNilhighlightSmalltalk: aBoolean  highlightSmalltalk := aBooleantaskbarIcon  ^self titleIconbuild: aPopup trigger: aTriggerBrick content: aContentBrick  aPopup removeAllBricks.  aPopup contentBrick: aContentBrick.  aPopup triggerBrick: aTriggerBrickscrollByKeyboard: anEvent  | direction |  (self isKeyboardScrollEvent: anEvent) ifFalse: [ ^self ].  self velocity: (self calculateVelocity: anEvent).  anEvent keyValue = 30 ifTrue: [ direction := #up ].  anEvent keyValue = 31 ifTrue: [ direction := #down ].  self scrollBy: velocity direction: directionasString  ^'vertical'width  ^self brick widthprivateThemer  ^self valueOfProperty: #brickThemer ifAbsentPut: [ nil ]newPane: anObject  newPane := anObjectpresentation: anObject  presentation := anObjectcolumn: aBlockOrString evaluated: aBlock  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock)columns  ^columns ifNil: [ columns := OrderedCollection new ]normalColor  ^normalColorelementColumn  | row morph |  morph := GLMMorphicPaneWithoutTitleRenderer new render: self containerNode item.  morph borderStyle: (UITheme current buttonSelectedBorderStyleFor: morph).  row := OrderedCollection with: morph.  ^UITheme current newRowIn: self currentWorld for: rowtestUpdate  | col pane presentation |  col := OrderedCollection with: 1 with: 2.  pane := GLMPane named: 'test'.  presentation := GLMListPresentation new.  pane addPresentation: presentation.  presentation entity: col.  presentation shouldValidate: true.  presentation update.  presentation selection: 2.  self assert: presentation selection equals: 2.  col removeLast.  presentation update.  self assert: presentation selection isNilfromOutsidePort: aPortSymbol transformed: aBlock  ^self from: #outer port: aPortSymbol transformed: aBlockrender: aPresentation  | container |  container := GLMMorphic containerMorph.  self initializeAnnouncementForPresentation: aPresentation.  self initializeTableModel: aPresentation.  self initializeTableMorph.  self addFastTableIn: container.  aPresentation selection ifNotNil: [ tableModel announcer suspendAll: self suspendedAnnouncements while: [ tableModel explicitSelection: aPresentation selection ] ].  ^containerupdate  self panes do: [:each |  each update ].  self announce: (GLMPresentationUpdated new presentation: self)hasTags  ^self columns anySatisfy: [:aColumn |  aColumn hasTags ]shouldRootsExpand  ^rootsExpanded ifNil: [ false ]on: aMorph  aMorph layoutProperties ifNil: [ aMorph layoutProperties: GLMBrickLayoutProperties new.        aMorph layoutProperties           hSpaceFill;           vSpaceFill ].  (aMorph layoutProperties isKindOf: GLMBrickLayoutProperties) ifTrue: [ self layoutProperties: aMorph layoutProperties ].  morph := aMorph.  morph layoutProperties: GLMBrickLayoutProperties new.  morph layoutProperties     hSpaceFill;     vSpaceFill.  self addBrickBack: morph.  super brickBounds: (0 @ 0 extent: morph width @ morph height)lastActivePresentation: aPresentation  (self port: #activePresentation) value: aPresentation.  lastActivePresentation := aPresentation.  self browser lastActivePresentation: aPresentationupdateSizing  | old |  old := sizing.  self basicUpdateSizing.  sizing = old ifFalse: [ self layoutPanes ].  ^sizingbuttonModel: anObject  buttonModel := anObjectwidthMyselfDependency: aBrick  ^aBrick layout width brickValue: aBrick bricksettingsButtonLabel  ^self sendUsageData ifTrue: [ 'Change preferences' ] ifFalse: [ 'Go to settings' ]morph  | morph |  morph := RubScrolledTextMorph new     getSelectionSelector: #primarySelectionInterval;     model: textModel;     beForSmalltalkScripting;     textFont: StandardFonts codeFont;     color: self theme backgroundColor;     notificationStrategy: GLMPopperNotificationStrategy new;     yourself.  (morph textArea decoratorNamed: #shoutStyler) ifNotNil: [:styler |  styler refreshStyling ].  ^morphclippingBounds  ^self fullBoundsouterBounds  ^self fullBoundsnewHintBrick  ^GLMLabelBrick new     text: self hintText;     padding: #(0 10);     width: [:b |  b approximateWidth ];     height: [:b |  b approximateHeight ]suspendedAnnouncements  ^OrderedCollection with: GLMTreeMorphSelectionChanged with: GLMTreeMorphStrongSelectionChanged with: GLMMenuItemSelected with: GLMKeyStrokeconvertScrollValue: aFloat  self pagerModel actualNumberOfVisiblePages = 0 ifTrue: [ ^0 ].  ^(self width - ((self width / self pagerModel actualNumberOfVisiblePages + self paneMargin) * self band subbricksCount)) * aFloatthemer  ^self privateThemer ifNotNil: [ self privateThemer ] ifNil: [ self hasOwner ifTrue: [ self owner themer ] ifFalse: [ self theme brickThemer ] ]moveBandBottom  self band translateY: self height - self band brickBounds bottombeSelected  self removeAllBricks.  self addBrickBack: self selectedLabel.  self themer tabLabelThemer selectedStyleFor: self.  self changedtestDifferentHeights  window := GLMScrollListBrick exampleDifferentHeights.  self assert: window isSystemWindowprintOn: aStream  aStream     nextPutAll: 'Port (pane=';     nextPutAll: self pane name printString;     nextPutAll: ' name=';     nextPutAll: self name printString;     nextPutAll: ' value=';     nextPutAll: self value printString;     nextPut: $)elementShouldBeDisplayed: anObject  | elementTags |  self tagsToFilterBy ifEmpty: [ ^true ].  elementTags := self glamourPresentation tagsFor: anObject to: #filter.  ^self tagsToFilterBy allSatisfy: [:each |  elementTags includes: each ]registeredAnnouncers  ^registeredAnnouncers ifNil: [ registeredAnnouncers := OrderedCollection new ]height: anObject  self vSpaceFill.  super height: anObjectvAlign: aSymbol  < brickBuilderProperty: #Layout name: 'Vertical align' as: #asSymbol getter: #vAlign model: #GLMUIBuilderTextFieldProperty>  self layout vAlign: aSymbolownerThatIsA: aClass  ^self firstOwnerSuchThat: [:m |  m isKindOf: aClass ]isHeightDirty  ^self heightState = #dirtymorph: aMorph withTitleOf: aPresentation  | tabs |  tabs := LazyTabGroupMorph new.  tabs     vResizing: #spaceFill;     hResizing: #spaceFill;     cornerStyle: (self theme tabGroupCornerStyleIn: nil);     font: self theme labelFont.  self flag: 'add a regular page instead of a lazy one'.  self flag: 'handle the PresentationChanged announcement to update the label in the morph. 	The problem is that at the moment I do not know how to link to the label in the tabSelectorMorph'.  tabs addLazyPage: aMorph label: (self titleOrIconOf: aPresentation in: tabs) toolbar: (self renderToolbarForPresentation: aPresentation inMorph: aMorph) action: (self labelActionBrickFor: aPresentation).  tabs selectedPageIndex: 1.  ^tabstestPopOnePage  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel popPane.  self assert: pagerModel size equals: 1.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 1.  self assert: pagerModel numberOfVisiblePages equals: 2assertNoDuplicatedAnnouncementsIn: anAnnouncement  | duplications |  duplications := (anAnnouncement subscriptions subscriptions groupedBy: [:aSubscription |  aSubscription announcementClass ]) select: [:each |  each value size > 1 ].  self assert: duplications isEmpty description: 'The announcement should have only one subscription of a given type.'testHasStatusbar  | browser |  browser := GLMBrowser new.  self deny: browser hasStatusbar.  browser hasStatusbar: true.  self assert: browser panes size equals: 1.  self assert: browser panes first name equals: GLMBrowser defaultStatusbarPane.  self assert: browser statusbarPane identicalTo: browser panes firsttoggleFilteringByTag: aTag  (self shouldFilterByTag: aTag) ifTrue: [ self tagsToFilterBy remove: aTag ] ifFalse: [ self tagsToFilterBy add: aTag ].  self resetChildrenContents.  self changed: #rootNodesonPositionChanged: announcement  self scrollToPane: pagerModel firstVisiblePageIndex smooth: announcement smooth callback: announcement callbacktabLabelThemer  ^self registerModule: GLMBrickTabLabelThemer newisFirstAdded  ^(self getIndex: self band firstSubbrick) = 1testTwoDependsOnParentInsideStatic  | root brick1 brick2 |  root := self newBrickWithStaticExtent.  brick1 := self newBrickFullHeightAndWidthDependsOnParent: 50.  brick2 := self newBrickFullHeightAndWidthDependsOnParent: 50.  root     addBrickBack: brick1;     addBrickBack: brick2.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick1 brickBounds equals: (0 @ 0 extent: (self staticWidth / 2) @ self staticHeight).  self assert: brick2 brickBounds equals: ((self staticWidth / 2) @ 0 extent: (self staticWidth / 2) @ self staticHeight)renderBackgroundColorOf: aBrick on: aCanvas  | rectangle |  rectangle := aBrick brickBounds expandBy: aBrick shadowWidth negated.  self renderBackgroundColorOf: aBrick on: aCanvas in: rectangleactOnPresentationUpdated: ann  textModel text: ann presentation formatedDisplayValue.  textModel changed: #textlayoutProperties  ^super layoutPropertiesrenderTreePresentation: aPresentation  ^GLMMorphicTreeRenderer render: aPresentation from: selfinitialize  super initialize.  self rubricBackgroundColor: Color transparenttestAssociationAsOriginIdentifier  self assert: ((#pane -> #port) asGlamourOriginIdentifier isKindOf: GLMPortIdentifier).  self assert: (#pane -> #port) asGlamourOriginIdentifier paneName equals: #pane.  self assert: (#pane -> #port) asGlamourOriginIdentifier portName equals: #portpanes  ^self band submorphstransmission  ^transmissionrenderToolbarForPresentation: aPresentation inMorph: aMorph  | dock buttons |  dock := aMorph theme newToolDockingBarIn: aMorph.  buttons := self toolbarButtonsForPresentation: aPresentation.  dock addAllMorphs: buttons.  (aPresentation allActions select: #isMenu) ifNotEmpty: [ dock addMorphBack: (self dropDownMenuFrom: [ | menu |                    menu := self menuIn: MenuMorph new for: aPresentation.                    menu popUpEvent: self currentEvent in: aMorph world ] withIcon: GLMUIThemeExtraIcons glamorousMore) ].  ^dockdestination  ^destinationtestInterdependentPanesShouldUpdateTheFocusTriggerPaneWithText  | browser treeMorphThree treeMorphThree2 |  browser := GLMTabulator new.  browser     column: #one;     column: #two;     column: #three.  browser transmit     to: #one;     andShow: [:a |  a text display: [:x |  1 to: x ] ].  browser transmit     to: #two;     from: #one;     andShow: [:a |  a text display: [:x |  1 to: x * 2 ] ].  browser transmit     to: #three;     from: #two;     andShow: [:a |  a text display: [:x |  1 to: x * 3 ] ].  browser transmit     toOutsidePort: #focus;     from: #three port: #focus.  browser transmit     to: #one port: #selection;     fromOutsidePort: #focus;     transformed: [:x |  x + 1 ].  browser transmit     to: #two port: #selection;     fromOutsidePort: #focus;     transformed: [:x |  x + 2 ].  window := browser openOn: 5.  ((browser paneNamed: #one) port: #selection) value: 3.  ((browser paneNamed: #two) port: #selection) value: 6.  treeMorphThree := (window submorphs last submorphs at: 5) submorphs first submorphs first.  ((browser paneNamed: #three) port: #selection) value: 2.  ((browser paneNamed: #three) port: #focus) value: 1.  self assert: ((browser paneNamed: #one) port: #entity) value equals: 5.  self assert: ((browser paneNamed: #one) port: #selection) value equals: 2.  self assert: ((browser paneNamed: #two) port: #entity) value equals: 2.  self assert: ((browser paneNamed: #two) port: #selection) value equals: 3.  self assert: ((browser paneNamed: #three) port: #entity) value equals: 3.  self assert: ((browser paneNamed: #three) port: #selection) value isNil.  treeMorphThree2 := (window submorphs last submorphs at: 5) submorphs first submorphs first.  self assert: treeMorphThree ~= treeMorphThree2drawKeyboardFocusOn: aCanvas  normalStyleFor: aBrick  super normalStyleFor: aBrick.  aBrick padding: #(0 1)buttonMinWidth  ^70initialize  super initialize.  self rubric: self newRubricMorph.  self withoutBackground.  self     hSpaceFill;     vSpaceFillcopy  | copy |  self flag: 'perhaps this should be replaced with smarter analysys mechanisms'.  copy := super copy.  copy parentPrototype: self.  ^copyhighlightSmalltalk  ^highlightSmalltalkhandlesMouseDown: evt  ^self isEnabled ifTrue: [ true ] ifFalse: [ super handlesMouseDown: evt ]testCreation  | aPane |  aPane := GLMPane named: 1 in: 2.  self assert: aPane name equals: 1.  self assert: aPane browser equals: 2shouldBeDisplayed  ^self shouldBeDisplayedByTags and: [ self shouldBeDisplayedByText ]hasChildren: aBlock  self parameters at: 'hasChildrenBlock' put: aBlockwidthChildrenDependency: aBrick  ^self subclassResponsibilitynewStaticItemFrom: anItem  ^FTStaticBasicItem new     data: anItem data;     depth: anItem depth;     children: #();     dataSource: self;     yourselfwithGhostText  ^withGhostTextvPercent  ^self vState percentactOnWindowRequest: ann  ann action value: selfsmooth: anObject  smooth := anObjectscrollpaneBackgroundColor  ^Color transparentshouldFilterByAmount  ^self amountToFilterBy notNil and: [ self amountToFilterBy isZero not ]updateWidth  self layout isWidthCustom ifFalse: [ ^self ].  [ self bounds: (self brickBounds withWidth: self customWidth) ] on: Exception do: [  ]closer  ^closerprintOn: aStream  aStream     nextPutAll: self class name;     nextPutAll: ' (origins=';     nextPutAll: self origins printString;     nextPutAll: ' destination=';     nextPutAll: self destination printString;     nextPut: $)invalidateLayout  self layoutPolicy layout: self brickApi in: self wrappedBounds innerBoundsglamourPresentation: anObject  glamourPresentation := anObjectactOnPaneAdded: ann  container brickRoot pushPane: (self renderObject: ann pane)unregisterFromAllAnnouncements  super unregisterFromAllAnnouncements.  self panes do: [:each |  each unregisterFromAllAnnouncements ]testNestedCompositesPaneReference  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list.        a text.        a composite: [:another |  another text.              another list ] ].  browser startOn: 42.  (browser paneNamed: #one) presentations do: [:each |  self assert: each pane identicalTo: (browser paneNamed: #one) ].  (browser paneNamed: #one) presentations last do: [:each |  self assert: each pane identicalTo: (browser paneNamed: #one) ]iconFor: anObject  ^self icon glamourValue: anObject asGlamorousMultiValue , self entity asGlamorousMultiValuebuild: aPopup trigger: aTriggerBrick content: aContentBrick  self subclassResponsibilitycomputeTagsFilterFor: aGlamourValue  | tags |  tags := OrderedCollection new.  self columns collect: [:aColumn |  tags addAll: (aColumn computeTagsFilterFor: aGlamourValue) ].  ^tagsisAllowedToNotePresentationsChanged  ^allowedToNotePresentationsChanged ifNil: [ allowedToNotePresentationsChanged := true ]renderGlamorouslyOn: aRenderer  ^aRenderer renderStacker: selftitleBrick  ^titleBricktestUnregisterAnnouncements  | announcer presentation browser pane |  announcer := Announcer new.  browser := GLMBrowser new.  pane := GLMPane new.  presentation := GLMPresentation new.  pane addPresentation: presentation.  browser addPane: pane.  presentation updateOn: GLMTestAnnouncement from: [ announcer ].  presentation registerAnnouncements.  self assert: announcer numberOfSubscriptions equals: 1.  browser unregisterFromAllAnnouncements.  self assert: announcer numberOfSubscriptions equals: 0testValidatePorts  presentation selection: #($e $f).  self assert: presentation selection equals: #($e $f).  presentation selection: $a.  self assert: presentation selection equals: $a.  presentation selection: 'wrongSelection'.  self assert: presentation selection equals: $atestAssociationAsTargetIdentifier  self assert: ((#pane -> #port) asGlamourTargetIdentifier isKindOf: GLMPortIdentifier).  self assert: (#pane -> #port) asGlamourTargetIdentifier paneName equals: #pane.  self assert: (#pane -> #port) asGlamourTargetIdentifier portName equals: #porthasBindingOf: aSymbol  ^self variableBindings includesKey: aSymbolmarginTop: anObject  < brickBuilderProperty: #Geometry name: 'Margin Top' as: #asInteger getter: #marginTop model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds marginTop: anObjecttextFontSize  ^self theme labelFont pointSizetestValidateOn  self assert: (presentation validate: #($e $f) on: (pane port: #selection)).  self assert: (presentation validate: $a on: (pane port: #selection)).  self deny: (presentation validate: $h on: (pane port: #selection))renderGlamorouslyOn: aRenderer  ^aRenderer renderAction: selfupdateTextAreaWhenUnplugged  self withoutStyler.  super updateTextAreaWhenUnpluggedheightChildrenDependency: aBrick  ^aBrick paddingTop + aBrick paddingBottom + ((self nonFloatSubbricks: aBrick) detectSum: [:each |  each outerBounds height ])renderDropDownListPresentation: aDropListPresentation  ^GLMMorphicDropDownRenderer render: aDropListPresentation from: selfopenOn: aBrick  self assert: [ aBrick isNotNil ] description: [ 'Can not open below a nil brick!' ].  self anchorBrick: aBrick.  self onCreated.  self announce: #onCreated event: self.  ^self popupLayout open: self with: (aBrick boundsInWorld expandBy: self inset)presentation: anObject  presentation := anObjecttopOffset  ^self band firstSubbrick brickBounds tophasTitle  ^title notNilbeSuccess  self themer: self themer popupSuccessThemer themeraddPresentation: aPresentation  self addPresentations: (OrderedCollection with: aPresentation)doItContext  ^self glamourPresentation doItContextcolorTop: aColor  self color at: Top put: aColoraddColumn: aBlockOrSymbol size: anInteger  ^(self addColumn: aBlockOrSymbol)     size: anInteger;     span: 0rubricBorderWidth  ^self valueOfProperty: #brickRubricBorderWidth ifAbsent: [ self themer rubricBorderWidth ]textColor  ^self color darkeninset: aMargin  inset := aMargin asMargin.  self updateInsetAndSpacinginitialize  super initialize.  self     width: 300;     textBrick: self newTextBrick;     okButton: self newButtonBricktoolbar: anObject  toolbar := anObjectupdateHeight: aBrick  aBrick isHeightClean ifTrue: [ Exception signal: 'Clean height can''t be updated!' ].  aBrick layout vState updateHeight: aBrick on: selftextModelFor: aPresentation  | tm |  tm := GLMSmalltalkCodeModel new     text: aPresentation formatedDisplayValue;     glamourPresentation: aPresentation;     highlightSmalltalk: true;     highlightSmalltalkContext: aPresentation highlightSmalltalkContext.  self addVariableBindingsOn: tm from: aPresentation.  aPresentation isForScripting ifTrue: [ tm bindingsStrategy: self workspaceBindingsStrategy ].  ^tmupdateToolbar  self announce: (GLMPresentationToolbarUpdated new presentation: self)font: aFont  buttonsBrick  ^buttonsBrickhintText: anObject  hintText := anObjecttestAllRecursivePresentations  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a text ].  browser startOn: 42.  self assert: browser panes first withAllPresentations size equals: 2.  self assert: browser pane withAllPresentations size equals: 4dropDownMenuFrom: aBlock withIcon: anIcon  | activeForm passiveForm menuButton |  activeForm := anIcon.  passiveForm := anIcon.  menuButton := MultistateButtonMorph new extent: activeForm extent.  ^menuButton     extent: activeForm extent;     activeEnabledOverUpFillStyle: (ImageFillStyle form: activeForm);     passiveEnabledOverUpFillStyle: (ImageFillStyle form: activeForm);     activeEnabledOverDownFillStyle: (ImageFillStyle form: passiveForm);     passiveEnabledOverDownFillStyle: (ImageFillStyle form: passiveForm);     addUpAction: aBlock;     setBalloonText: 'Menu' translated;     yourselfcolumn: aBlockOrString evaluated: aBlock width: aNumber tags: anObject  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           width: aNumber;           tags: anObject;           yourself)testAsGlamorousMultiValue  self assert: (GLMMultiValue with: #(1 2 3)) equals: #(1 2 3) asGlamorousMultiValue.  self assert: 1 asGlamorousMultiValue , 2 asGlamorousMultiValue , 3 asGlamorousMultiValue equals: (GLMMultiValue withAll: #(1 2 3))textInputFor: aTreeModel withHelpMessage: helpStringMessage  | textInput |  textInput := self theme newTextEntryIn: nil for: aTreeModel get: #inputText set: #inputText: class: String getEnabled: #inputTextEnabled help: helpStringMessage.  textInput askBeforeDiscardingEdits: false.  textInput ghostText: helpStringMessage.  textInput layoutFrame: (LayoutFrame identity           topFraction: 1;           topOffset: -26;           bottomOffset: -4).  ^textInputglamourValueWithArgs: anArray  ^anArray allSatisfy: [:each |  each isNil not ]fastFramingOn  ^self theme settings fastDragging and: [ self isFlexed not ]explicitSelection: anObject  self table selectIndexes: (self searchText: anObject asString)evaluateSelectionAndDo: aBlock  self announce: (GLMEvaluateSelection new action: aBlock)selectedIndex  ^selectedIndex ifNil: [ selectedIndex := 0 ]checkedImage: anObject  checkedImage := anObjecttagsToFilterBy  ^tagsToFilterBy ifNil: [ tagsToFilterBy := OrderedCollection new ]initializeScriptingDefaults  super initializeScriptingDefaults.  self cell ifNil: [ self addColumn: #pane ].  self transmissions detect: [:each |  each originatesAt: (self pane port: #entity) ] ifNone: [ self transmit           to: (self panes first port: #entity);           from: #outer port: #entity;           andShow: [:a |  a custom: GLMFlexiblePresentation new ] ]borderColor  ^Color r: 225 g: 124 b: 108 range: 255testTreeSelectionCancellation  | browser treeNodeMorph |  browser := GLMFinder new.  browser show: [:a |  a tree allowDeselection ].  window := browser openOn: ($a to: $d).  treeNodeMorph := self treeVisibleItems first.  self send: self tree mouseUpOnItem: treeNodeMorph.  self send: self tree mouseUpOnItem: treeNodeMorph.  self assert: (browser panes first port: #selection) value isNilshouldShowHeader  ^shouldShowHeader ifNil: [ shouldShowHeader := true ]addNewPaneNamed: aString  ^self addPane: (GLMPane named: aString in: self)render: aPresentation  | container textInput |  treeModel := GLMTreeMorphModel new glamourPresentation: aPresentation.  container := GLMMorphic containerMorph.  treeMorph := self treeMorphFor: treeModel and: aPresentation.  aPresentation allowsInput ifTrue: [ textInput := self textInputFor: treeModel withHelpMessage: aPresentation helpMessage.        treeMorph layoutFrame bottomOffset: -26.        container addMorphBack: textInput ].  container addMorphBack: treeMorph.  self installActionsOnModel: treeModel fromPresentation: aPresentation.  self installKeystrokeActionsOnMorph: treeMorph fromPresentation: aPresentation.  aPresentation selection notNil ifTrue: [ treeModel announcer suspendAll: self suspendedAnnouncements while: [ treeMorph model explicitSelection: aPresentation selection ] ].  treeModel announcer when: GLMTreeMorphSelectionChanged do: [:ann |  aPresentation announcer suspendAllWhile: [ aPresentation selection: ann selectionValue.              aPresentation selectionPath: ann selectionPathValue ] ].  treeModel announcer when: GLMTreeMorphStrongSelectionChanged do: [:ann |  aPresentation strongSelection: ann strongSelectionValue ].  aPresentation when: GLMContextChanged send: #actOnContextChanged: to: self.  aPresentation when: GLMPresentationUpdated send: #actOnUpdatedPresentation: to: self.  ^containerokButton  ^okButtonhintDelay: anObject  hintDelay := anObjecttestAllowNil  | browser detailsMorph |  browser := GLMTabulator new.  browser     column: [:c |  c           row: #one;           row: #two ];     column: #details.  browser transmit     to: #one;     andShow: [:a |  a tree display: #(1 2 3) ].  browser transmit     to: #two;     andShow: [:a |  a tree display: #(#a #b #c) ].  browser transmit     to: #details;     from: #one;     from: #two;     andShow: [:a |  a text           display: [:one :two |  one asString , two asString ];           allowNil ].  window := browser openOn: 42.  ((browser paneNamed: #one) port: #selection) value: 2.  detailsMorph := window submorphs last submorphs last submorphs first.  self assert: detailsMorph text asString equals: '2nil'.  ((browser paneNamed: #two) port: #selection) value: #c.  detailsMorph := window submorphs last submorphs last submorphs first.  self assert: detailsMorph text asString equals: '2c'.  ((browser paneNamed: #one) port: #selection) value: nil.  detailsMorph := window submorphs last submorphs last submorphs first.  self assert: detailsMorph text asString equals: 'nilc'toString: anObject  ^self glamourPresentation hasFilterBlock ifTrue: [ anObject ] ifFalse: [ super toString: anObject ]dependencyButtonSize  ^self isDependenciesShown ifTrue: [ self circleButtonSize ] ifFalse: [ 0 ]testNestedBrowserWithExplicitTransmission  | browser innerBrowser realInnerBrowser |  browser := GLMTabulator new.  browser column: #one.  innerBrowser := GLMTabulator new.  innerBrowser column: #innerOne.  innerBrowser transmit     to: #innerOne;     from: #outer port: #entity;     andShow: [:a |  a text ].  browser transmit     to: #one;     andShow: [:a |  a custom: innerBrowser ].  browser startOn: 42.  realInnerBrowser := (browser paneNamed: #one) presentations first.  self assert: ((browser paneNamed: #one) port: #entity) value equals: 42.  self assert: ((realInnerBrowser paneNamed: #innerOne) port: #entity) value equals: 42testFrom  browser transmit from: #one.  self assert: browser transmissions first origins first pane equals: browser panes first.  self assert: browser transmissions first origins first name equals: GLMPortIdentifier defaultOriginPortNameglobalInnerBounds  ^self owner ifNotNil: [ self innerBounds translateBy: self owner globalBoundsTranslateFactor ] ifNil: [ self innerBounds ]cachedPresentation  ^cachedPresentationhasMinDimensionRestriction: aBrick  ^aBrick layout hasMinWidthpopupPrint  textMorph textArea editor highlightEvaluateAndDo: [:result |  textMorph shoutStyler style: textMorph text.        GLMPrintPopper new openFromRubric: textMorph textArea withResult: result ]pagerModel: aModel  pagerModel := aModel.  self pagerModel announcer when: GLMPagePushed send: #onPagePushed: to: self.  self pagerModel announcer when: GLMPagePoped send: #onPagePoped to: self.  self sliderBrick: self newSliderBrick.  self buttonsBrick: self newButtonsBricktaskThumbnailOfSize: thumbExtent  | f t r |  r := self globalBounds scaledAndCenteredIn: (0 @ 0 extent: thumbExtent).  f := Form extent: r extent depth: Display depth.  t := MatrixTransform2x3 withScale: f extent / self extent.  f getCanvas transformBy: t clippingTo: f boundingBox during: [:c |  c translateBy: self globalBounds topLeft negated during: [:ct |  self fullDrawOn: ct ] ] smoothing: 2.  ^ImageMorph new form: fupdateFor: aMorph  thumbnail := aMorph taskThumbnailOfSize: self maxExtent.  self image: thumbnail form.  self position: position - ((thumbnail width / 2) @ (thumbnail height + self defaultBottomMargin + self defaultBorderWidth))headerColumn: column  column id ifNil: [ ^nil ].  ^SimpleButtonMorph new     layoutPolicy: RowLayout new;     listDirection: #leftToRight;     wrapCentering: #center;     cellInset: 5 @ 0;     layoutInset: 5 @ 0;     label: column id;     target: self;     actionSelector: #actionColumn:;     arguments: {column};     yourselfshowFirst: aBlock  ^self firstTransmission transmissionStrategy presentationsFactory: aBlockcolumn: aBlockOrString evaluated: aBlock width: aNumber tags: anObject  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           width: aNumber;           tags: anObject;           yourself)paddingLeft: anObject  < brickBuilderProperty: #Geometry name: 'Padding Left' as: #asInteger getter: #paddingLeft model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds paddingLeft: anObjectopenOn: anObject with: aRenderer  self startOn: anObject.  ^self openWith: aRendererpresentationsFactory  ^presentationsFactorycolumn: aBlockOrString evaluated: aBlock tags: anObject filtered: anotherObject  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           tagsBlock: anObject;           tagsFilter: anotherObject)buttons  ^buttons ifNil: [ buttons := OrderedCollection new ]headerColumn: column  column id ifNil: [ ^nil ].  ^SimpleButtonMorph new     layoutPolicy: RowLayout new;     listDirection: #leftToRight;     wrapCentering: #center;     cellInset: 5 @ 0;     layoutInset: 5 @ 0;     label: column id;     target: self;     actionSelector: #actionColumn:;     arguments: {column};     yourselftransmissionStrategy: anObject  transmissionStrategy := anObjectshouldBeDisplayedByTags  | nodeTags |  self flag: 'it looks like this method does not really get called for children'.  self containerTree tagsToFilterBy isEmpty ifTrue: [ ^true ].  self withContentsDo: [:node |  nodeTags := self containerTree glamourPresentation tagsFor: node item to: #filter.        (self containerTree tagsToFilterBy allSatisfy: [:each |  nodeTags includes: each ]) ifTrue: [ ^true ] ].  ^falseselectedLabel: anObject  selectedLabel := anObjectdataCache  ^dataCache ifNil: [ dataCache := self class defaultCache ]isWithElementIndex  ^self parameters at: 'withRowIndex' ifAbsent: [ false ]textModel: aTextModel  textModel := aTextModel.  self textEditBrick ifNotNil: [:aTextEditBrick |  aTextEditBrick text: self textModel ]actualNumberOfVisiblePages  firstVisiblePageIndex = lastVisiblePageIndex & (firstVisiblePageIndex = 0) ifTrue: [ ^0 ].  ^lastVisiblePageIndex - firstVisiblePageIndex + 1hSpaceFill  self hSpaceFill: 100listBrick  ^scrollListhSpaceFill: anInteger  super hSpaceFill: anInteger.  hResizing := #spaceFilladdPresentation: aPresentation  evaluateAndOpenFromRubric: aMorph  self openFromRubric: aMorph withResult: aMorph textArea editor evaluateSelectiontitle  ^titlemaxExtent  ^300 @ 300theme  ^Smalltalk ui themeicon: anImage  self normalImage: anImage.  self doLayoutForceglamourPresentation: anObject  glamourPresentation := anObjecttestSimplePort  | port |  port := GLMSimplePort new.  port name: #foo.  port value: 42.  self assert: port name equals: #foo.  self assert: port value equals: 42.  self assert: port hasPane notmenu: aMenuMorph shifted: b  | subMenus targetMenuMorph subMenu allActions |  subMenus := Dictionary new.  allActions := self containerTree allMenuActions.  allActions do: [:action |  targetMenuMorph := action category notNil ifTrue: [ subMenus at: action category ifAbsentPut: [ subMenu := MenuMorph new.                    aMenuMorph add: action category subMenu: subMenu.                    subMenu ] ] ifFalse: [ aMenuMorph ].        (targetMenuMorph add: action title target: self selector: #executeMenuAction: argument: action)           enabled: (action isEnabledOn: self containerTree glamourPresentation);           icon: action icon;           keyText: (action hasShortcut ifTrue: [ action shortcutAsString ] ifFalse: [ nil ]).        (action separatorAfter and: [ allActions last ~= action ]) ifTrue: [ targetMenuMorph addLine ] ].  ^aMenuMorphnewBand  ^GLMScrollPaneBandBrick newshouldRootsExpand: anObject  rootsExpanded := anObjectbindingThemer  ^self registerModule: GTPlayBindingThemer newrecomputeState  self recomputeState: trueonThemerChanged  self changedtextBrick  ^textBrickinitialize  super initialize.  condition := truevelocityValue: anInteger  | time |  time := anInteger <= self class defaultScrollTurboTime ifTrue: [ 2 ] ifFalse: [ 1 ].  ^self velocity + (self class defaultScrollAcceleration * time) min: self calculateMaxVelocitycheck  self box check.  self label check.  super checklabel  ^labelBrickaddDupHandle: haloSpec  animation: anObject  animationLogic := anObjectisTopOverscrolled  ^self bandTopOffset > 0suspendAll: aCollection while: aBlock  | previousSuspendedAnnouncemets |  previousSuspendedAnnouncemets := suspendedAnnouncemets.  suspendedAnnouncemets := aCollection copy.  aBlock ensure: [ suspendedAnnouncemets := previousSuspendedAnnouncemets ]maxWidth  ^maxWidth ifNil: [ maxWidth := Float infinity ]children: anObject  self shouldNotImplementisWithElementIndex  ^self parameters at: 'withRowIndex' ifAbsent: [ false ]hShrinkWrap  super hShrinkWrap.  self label hShrinkWrapinitialize  super initialize.  self     vShrinkWrap;     hSpaceFilldisplayLogic  ^self valueOfProperty: #phlowDisplay ifAbsent: [ #yourself ]selectedMethod  ^self doItContext ifNil: [ nil ] ifNotNil: [:aContext |  aContext method ]popup: aPopupBrick event: anEvent  < return: #Boolean>  ^anEvent type = #mouseMove and: [ (aPopupBrick isInsideOfPopupBrick: anEvent) not ]renderer: anObject  renderer := anObjectrowHeightBlock  ^self parameters at: 'rowHeight' ifAbsent: [ self class defaultRowHeight ]count  self subclassResponsibilitytestTreeSelection  | browser treeNodeMorph |  browser := GLMFinder new.  browser show: [:a |  a tree ].  window := browser openOn: ($a to: $d).  treeNodeMorph := self treeVisibleItems first.  self send: self tree mouseUpOnItem: treeNodeMorph.  self assert: (browser panes first port: #selection) value equals: $aupdateScrollbar  self verticalScrollbar ifNotNil: [:b |  b updatePosition ]scrollPageUp  self     scrollUp: self calculateMaxVelocity;     update;     changedwidthState: aSymbol  widthState := aSymbolnewStringBrick  ^GLMStringBrick newtreeVisibleItems  ^self tree scroller submorphssetUp  | pane1 pane2 transmission1 transmission2 |  super setUp.  browser := GLMExplicitBrowser new.  pane1 := browser addNewPane name: 'pane1'.  pane2 := browser addNewPane name: 'pane2'.  transmission1 := GLMTransmission new     addActiveOrigin: (pane2 port: #selection);     destination: (GLMPresentationBoundPort new           name: #selection;           presentation: browser;           yourself);     yourself.  browser addTransmission: transmission1.  transmission2 := GLMTransmission new     ensureReplacePresentationsStrategy;     addActiveOrigin: (pane1 port: #selection);     destination: (pane2 port: #entity);     addPresentation: (GLMPresentation new title: 'presentation1');     yourself.  browser addTransmission: transmission2.  copiedBrowser := browser copycolumn: aBlockOrString evaluated: aBlock width: aNumber  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           width: aNumber;           yourself)hState  ^self layout hStatetestMorphUpdate  | browser number originalMorph newMorph |  number := 42.  browser := GLMTabulator new.  browser row: #morph.  browser transmit     to: #morph;     andShow: [:presenter |  presenter morph display: [:x |  number asString asMorph ] ].  window := browser openOn: 42.  originalMorph := self findLast: StringMorph in: window.  self assert: originalMorph notNil.  self assert: originalMorph contents equals: 42 asString.  number := 43.  browser update.  newMorph := self findLast: StringMorph in: window.  self assert: newMorph ~= originalMorph.  self assert: newMorph notNil.  self assert: newMorph notNil.  self assert: newMorph contents equals: 43 asStringhasMaxWidth  ^(self maxWidth isNumber ifTrue: [ self maxWidth isInfinite ] ifFalse: [ false ]) notactionName  ^self parameters at: 'actionName' ifAbsent: 'Validate'renderActionListPresentation: anActionListPresentation  ^GLMMorphicActionListRenderer render: anActionListPresentation from: selfneedActionButton  ^self parameters at: 'actionBlock' ifPresent: [ true ] ifAbsent: [ false ]outerPortEvent: aPortEvent  aPortEvent port name = #entity ifFalse: [ ^self ].  panes := nil.  self matches ifTrue: [ (self transformation glamourValue: aPortEvent port value) do: [:each |  self addPaneFrom: (GLMSimplePort new value: each) ] ]keyStroke: aKeyboardEvent from: aTreeMorph  | action |  action := self allKeystrokeActions detect: [:a |  a shortcut = aKeyboardEvent keyCharacter ] ifNone: [ nil ].  action ifNotNil: [ self announce: (GLMKeyStroke action: action) ]selectedPageIndex: anIndex  | normalizedIndex |  normalizedIndex := self normalizePaneIndex: anIndex.  (self isPaneVisible: normalizedIndex) ifFalse: [ self scrollToPane: (normalizedIndex < self firstVisiblePageIndex ifTrue: [ normalizedIndex ] ifFalse: [ normalizedIndex - self numberOfVisiblePages + 1 ]) ].  selectedPageIndex := normalizedIndex.  self focusPaneAt: normalizedIndex.  self notifySelectedPageChanged.  self invariantscrollToRight  scrollBar glmAnimateValue: 1.0 duration: 200removePage: aPage  | removedPageIndex |  removedPageIndex := self pages indexOf: aPage.  self announcer suspendAllWhile: [ super removePage: aPage ].  self announcer announce: (LazyTabPageRemoved new           tabs: self;           page: aPage;           pageIndex: removedPageIndex;           newIndex: self tabSelectorMorph selectedIndex).  self pages isEmpty ifTrue: [ self contentMorph removeAllMorphs ]toggleExpandedState: aMorph event: event  super toggleExpandedState: aMorph event: event.  self resizeColumnscontext  context ifNil: [ context := OrderedCollection new ].  ^contextmenuColumn: column row: rowIndex  | menu subMenus targetMenuMorph subMenu |  menu := UIManager default newMenuIn: self table for: self.  subMenus := Dictionary new.  self allMenuActions do: [:action |  targetMenuMorph := action category notNil ifTrue: [ subMenus at: action category ifAbsentPut: [ subMenu := MenuMorph new.                    menu add: action category subMenu: subMenu.                    subMenu ] ] ifFalse: [ menu ].        (targetMenuMorph add: action title target: self selector: #executeMenuAction: argument: action)           icon: action icon;           balloonText: action help;           enabled: (action isEnabledOn: self glamourPresentation);           keyText: (action hasShortcut ifTrue: [ action shortcutAsString ] ifFalse: [ nil ]) ].  ^menuasGlamorousMultiValue  ^selfselectionAct: aBlock entitled: aString condition: conditionBlock  self addSelectionAction: (GLMGenericAction new           action: aBlock;           title: aString;           condition: conditionBlock;           yourself)testOneDependsOnParentOneDependsOnChildrenInsideStatic  | root brick1 brick2 brick3 staticWidth staticHeight |  staticWidth := 20.  staticHeight := 50.  root := self newBrickWithStaticExtent.  brick1 := self newBrickFullHeightAndWidthDependsOnParent: 100.  brick2 := self newBrickWithFullDependsOnChildren.  brick3 := GLMBrick new     width: staticWidth;     height: staticHeight;     yourself.  root addBrickBack: brick1.  self assert: root extent equals: self staticExtent.  self assert: brick1 brickBounds equals: (0 @ 0 extent: self staticExtent).  root addBrickBack: brick2.  self assert: root extent equals: self staticExtent.  self assert: brick1 brickBounds equals: (0 @ 0 extent: self staticExtent).  self assert: brick2 brickBounds equals: (self staticWidth @ 0 extent: 0 @ 0).  brick2 addBrickBack: brick3.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick1 brickBounds equals: (0 @ 0 extent: (self staticWidth - staticWidth) @ self staticHeight).  self assert: brick2 brickBounds equals: ((self staticWidth - staticWidth) @ 0 extent: staticWidth @ staticHeight).  self assert: brick3 brickBounds equals: (0 @ 0 extent: staticWidth @ staticHeight)select  super select.  self announcer announce: (GLMPagerButtonSelected new buttonModel: self)transmitIn: aContext  self transmission destination hasPane ifTrue: [ self transmission destination pane notingPresentationChangeDo: [ self transmission destination pane clearIn: aContext.              self transmission destination pane presentations: self presentations copy ] ]pasteRecent  self announce: (GLMTextEditorRequest for: #pasteRecent)portName: anObject  portName := anObjecttabs: anObject  tabs := anObjectupdateOn: anAnnouncement fromAll: aBlockOrSymbol  updateActions add: (GLMMultipleUpdateAction new           presentation: self;           announcement: anAnnouncement;           transformation: aBlockOrSymbol;           yourself)testSpawnFinder  | browser |  browser := GLMFinder new.  window := browser openOn: ($a to: $d).  self waitUntilUIRedrawed.  self assert: window submorphs last class equals: GLMPaneScrollerisUpdating  ^isUpdating ifNil: [ isUpdating := false ]when: aventName send: aSymbol to: aReceiver  self announcer when: aventName send: aSymbol to: aReceiverglamourPresentation: anObject  glamourPresentation := anObject