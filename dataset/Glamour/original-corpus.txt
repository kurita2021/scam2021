shadowGradientReverseFor: aBrick  ^GradientFillStyle ramp: {(0.0 -> (aBrick shadowColor alpha: 0)) .         (1.0 -> aBrick shadowColor)}onTabClicked: anEvent with: aBrick  self selectedIndex: (self tabs indexOf: aBrick)initialize  super initialize.  self enablevirtualFirstVisiblePageIndex: anIndex  virtualFirstVisiblePageIndex := self normalizePaneIndex: anIndexhasActions  ^self allActions notEmptypressedImage: anObject  pressedImage := anObjecttextColor: aColor  self setProperty: #brickTextColor toValue: aColor.  self updateFontisSearchable  ^self parameters at: 'isSearchable' ifAbsent: [ false ]rowHeight: aNumber  self parameters at: 'rowHeight' put: aNumberheightChildrenDependency: aBrick  ^aBrick paddingTop + aBrick paddingBottom + (((self nonFloatSubbricks: aBrick) detectMax: [:each |  each outerBounds height ]) ifNil: [ 0 ] ifNotNil: [:m |  m outerBounds height ])send: treeMorph doubleClickWithShift: aBoolean onItem: treeNodeMorph  | event |  event := MouseButtonEvent basicNew setType: #mouseDown position: treeNodeMorph bounds origin + (1 @ 1) which: 4 buttons: (aBoolean ifTrue: [ 8 ] ifFalse: [ 0 ]) hand: (HandMorph new           mouseFocus: treeNodeMorph;           yourself) stamp: nil.  treeMorph doubleClick: eventaddPresentation: aPresentation  | currentPresentations |  currentPresentations := self presentations.  self presentationsFactory: [:composite |  currentPresentations do: [:each |  composite add: each ].        composite add: aPresentation copy ]staticHeight  ^100 * self currentWorld displayScaleFactorfastTable  ^self custom: GLMFastTablePresentation newshowTitle  shouldShowTitle := truemargin: margins  margins ifNil: [ ^self margin: #(0) ].  margins isCollection ifTrue: [ margins isEmpty ifTrue: [ ^self margin: #(0) ].        self           marginTop: (margins at: 1);           marginRight: (margins at: 1);           marginBottom: (margins at: 1);           marginLeft: (margins at: 1).        margins size > 1 ifTrue: [ self                 marginRight: (margins at: 2);                 marginLeft: (margins at: 2) ].        margins size > 2 ifTrue: [ self marginBottom: (margins at: 3) ].        margins size > 3 ifTrue: [ self marginLeft: (margins at: 4) ] ] ifFalse: [ ^self margin: {margins} ].  self updateCachestartOn: anObject  self initializeScriptingDefaults.  self entity: anObjecttestGlamourValue  self assert: ([:a |  a + 2 ] glamourValue: 40) equals: 42.  self assert: ([:a |  a + 2 ] glamourValue: 40 asGlamorousMultiValue) equals: 42.  self assert: ([ 42 ] glamourValue: 40 asGlamorousMultiValue) equals: 42.  self assert: ([:a |  a first + a last ] glamourValue: #(40 2)) equals: 42.  self assert: ([:a :b |  a + b ] glamourValue: (GLMMultiValue withAll: #(40 2))) equals: 42.  self assert: ([:a |  a + 2 ] glamourValue: (GLMMultiValue withAll: #(40 2))) equals: 42.  self assert: ([ 42 ] glamourValue: (GLMMultiValue withAll: #(40 2))) equals: 42createDataSourceFrom: aPresentation  ^aPresentation allowSeparators ifTrue: [ GLMFastListOutlineDataSource new ] ifFalse: [ GLMFastListDataSource new ]bindingOf: aSymbol  ^self bindingsStrategy cull: self variableBindings cull: aSymbol cull: selfrenderToolbarForPresentation: aPresentation inMorph: aMorph  | dock buttons |  dock := aMorph theme newToolDockingBarIn: aMorph.  buttons := self toolbarButtonsForPresentation: aPresentation.  dock addAllMorphs: buttons.  dock addMorphBack: (self dropDownMenuFrom: [ | menu defaultMenu |              defaultMenu := aMorph buildWindowMenu.              (aPresentation allActions select: #isMenu) ifNotEmpty: [ defaultMenu addLine ].              menu := self menuIn: defaultMenu for: aPresentation.              menu popUpEvent: self currentEvent in: aMorph world ] withIcon: aMorph theme windowMenuForm).  ^dockwhen: anAnnouncement do: aBlock  self announcer when: anAnnouncement do: aBlockbasicUpdateSizing  sizing := (self paneCount min: self maxPanes) max: 1testRemovingVariableSizePanes  | finder |  finder := GLMFinder new variableSizePanes.  window := finder openOn: 40.  self assert: window submorphs last scrollTarget submorphs size equals: 2.  (finder panes first port: #selection) value: 41.  self assert: window submorphs last scrollTarget submorphs size equals: 4.  (finder panes first port: #selection) value: 42.  self assert: window submorphs last scrollTarget submorphs size equals: 4.  (finder panes second port: #selection) value: 43.  self assert: window submorphs last scrollTarget submorphs size equals: 6.  (finder panes first port: #selection) value: 44.  self assert: window submorphs last scrollTarget submorphs size equals: 4defaultDotsText  ^'...'bottomShadowOf: aBrick on: aCanvas  | gradient width origin offset |  width := aBrick shadowWidth.  offset := width @ width negated / 2.0.  origin := aBrick brickBounds bottomLeft + offset + aBrick shadowOffset.  gradient := (self shadowGradientFor: aBrick)     origin: origin - offset - (0 @ (width / 2.0));     direction: 0 @ width;     yourself.  aCanvas fillRectangle: (origin extent: (aBrick width - width) @ width) fillStyle: gradientindex: anObject  index := anObjectmarginLeft  ^self brick marginLeftnewToolbarMorph  ^GLMPanelMorph new     fillStyle: (SolidFillStyle color: Color transparent);     borderStyle: (BorderStyle width: 0);     vResizing: #spaceFill;     hResizing: #shrinkWrap;     cellPositioning: #center;     changeTableLayout;     cellInset: 0;     yourselfremoveBrick: aBrick  | result |  aBrick ifNil: [ ^aBrick ].  result := self privateRemoveBrick: aBrick.  self privatePrepareBrickAfterRemoving: aBrick.  self doLayoutForce.  ^resultpagerBar: aBrick  pagerBar := aBrick.  self pagerBar     vShrinkWrap;     hShrinkWrap.  self pagerBar layout hAlign: #center.  self pagerBar pagerModel: pagerModel.  self addBrickBack: self pagerBarportName  ^self port nameinstallKeystrokeActionsOnMorph: aMorph fromPresentation: aPresentation  aPresentation allActionsWithShortcuts do: [:each |  each installKeyCombinationForPresentation: aPresentation onMorph: aMorph ]onChildrenDo: aBlock  ^self on: #isOnChildren do: aBlock ifAbsent: [ GLMBrickLayoutChildrenState new ]tabs  ^tabs ifNil: [ tabs := OrderedCollection new ]isCancelOnFocusLost  ^cancelOnFocusLost ifNil: [ cancelOnFocusLost := false ]testOneTabWithActions  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list act: #inspect entitled: 'Inspect' ].  window := browser openOn: 42.  self assert: self compositeMorph class equals: GLMPanelMorph.  self assert: self compositeMorph submorphs size equals: 2listBrick: aBrick  scrollList := aBrick.  self listBrick     vSpaceFill;     hSpaceFill.  self addBrickBack: self listBrickaddMorphFromObject: anObject toContainer: aContainerMorph  | renderedMorph |  renderedMorph := (self renderObject: anObject)     vResizing: #spaceFill;     hResizing: #rigid;     minimumExtent: 200 @ 10;     extent: 200 @ 10;     yourself.  aContainerMorph addMorphBack: renderedMorph.  aContainerMorph addMorphBack: (EdgeGripMorph new           width: ProportionalSplitterMorph splitterWidth;           hResizing: #rigid;           target: renderedMorph)removePane: aPane  aPane unregisterFromAllAnnouncements.  self panes remove: aPaneinitialize  super initialize.  fontSize := self themer textFontSize.  familyName := self themer textFamilyName.  text := ''.  textPosition := #leftCenter.  self     hShrinkWrap;     vShrinkWrap.  self updateFontlayout: aBrick in: newBounds  self layout: aBrick in: newBounds inject: aBrick paddingLeft @ aBrick paddingTop into: [:origin :each |  each outerOrigin: origin.        each outerBounds width @ 0 ]taskbarTask  ^nilcalculateScrollbarTopOffset  ^(self height / self scrollPane band height * self scrollPane band brickBounds top abs) floorstepCondition  ^stepCondition ifNil: [ [ false ] ]scrollPositionBottom  ^self scrollPositionTop + self innerBounds heightisLayotingAllowed: aBoolean  self setProperty: #brickLayoutingAllowed toValue: aBooleanpresentations: aCompositePresentation  self transmissionStrategy presentations: aCompositePresentationsuspendedAnnouncemets  ^suspendedAnnouncemets ifNil: [ suspendedAnnouncemets := OrderedCollection new ]newButton  ^GLMPagerScrollButtonBrick newactOnVariableBindingsAccessRequest: ann  ann action ifNotNil: [:aBlock |  aBlock cull: textModel variableBindings ]testTitle  | presentation |  presentation := GLMPresentation new.  presentation entity: #foo.  self assert: presentation titleValue isNil.  presentation title: '41'.  self assert: presentation titleValue equals: '41'.  presentation entity: '4'.  presentation title: [:x |  x , '2' ].  self assert: presentation titleValue equals: '42'.  presentation entity: (GLMMultiValue withAll: #('4' '3')).  presentation title: [:first :second |  first , second ].  self assert: presentation titleValue equals: '43'isHovered  ^self isSelectedthemer: anObject  themer := anObjecttestToSendAs  | presentation |  presentation := GLMPresentation new.  presentation selection: #foo.  self assert: presentation selection equals: #foo.  self assert: (presentation pane port: #newport) value equals: nil.  presentation send: [:num |  num + 1 ] as: #newport.  presentation selection: 1.  self assert: (presentation pane port: #newport) value equals: 2.  self assert: presentation selection equals: 1selectionAct: aBlock entitled: aString enabledWhen: conditionBlock  self addSelectionAction: (GLMGenericAction new           action: aBlock;           title: aString;           enabledCondition: conditionBlock;           yourself)translateX: anInteger  self translateBy: anInteger @ 0shouldValidate: aBoolean  shouldValidate := aBooleanactionColumn: column  column execute.  self tableRefreshactOnContextChanged: ann  ann property = #selection ifTrue: [ listModel announcer suspendAllWhile: [ dropDownMorph listSelectionIndex: (listModel glamourPresentation displayValue indexOf: ann value) ] ]isHeightDirty  ^self brick wrappedBounds isHeightDirtyvAlign: aSymbol  vAlign := aSymbolselectionAct: aBlock entitled: aString categorized: anotherString  self addSelectionAction: (GLMGenericAction new           action: aBlock;           title: aString;           category: anotherString;           yourself)explicitSelection: anObject  self glamourPresentation isMultiple ifTrue: [ self explicitlySelectMultipleItems: anObject ] ifFalse: [ self explicitlySelectItem: anObject ]textColor  ^Color r: 16 g: 172 b: 221 range: 255testSimplePropagation  < expectedFailure>  | browser |  browser := GLMTabulator new.  browser column: #pane1.  browser transmit     to: #pane1;     andShow: [:a |  a text ].  browser startOn: 42.  self assert: GLMLogger instance announcements copy size equals: 8triggerBrick: aBrick  self assert: [ aBrick isNotNil ] description: [ 'Trigger brick must not be nil' ].  triggerBrick ifNotNil: [ self removeBrick: triggerBrick ].  triggerBrick := aBrick.  self addBrickBack: self triggerBrickmenu: aMenuMorph  | subMenus targetMenuMorph subMenu allActions |  subMenus := Dictionary new.  allActions := self allMenuActions.  allActions do: [:action |  targetMenuMorph := action category notNil ifTrue: [ subMenus at: action category ifAbsentPut: [ subMenu := MenuMorph new.                    aMenuMorph add: action category subMenu: subMenu.                    subMenu ] ] ifFalse: [ aMenuMorph ].        (action separatorBefore and: [ allActions first ~= action ]) ifTrue: [ targetMenuMorph addLine ].        (targetMenuMorph add: action title target: self selector: #executeMenuAction: argument: action)           enabled: (action isEnabledOn: self glamourPresentation);           icon: action icon;           keyText: (action hasShortcut ifTrue: [ action shortcutAsString ] ifFalse: [ nil ]).        (action separatorAfter and: [ allActions last ~= action ]) ifTrue: [ targetMenuMorph addLine ] ].  ^aMenuMorphvShrinkWrap  self height: [ self vPadding + (self icon isNil & self hoverIcon isNil ifTrue: [ 0 ] ifFalse: [ self icon ifNil: [ self hoverIcon height ] ifNotNil: [ self hoverIcon ifNil: [ self icon height ] ifNotNil: [ self icon height max: self hoverIcon height ] ] ]) ]worksWithMorphic  ^truedisplayValue  ^sortBlock ifNil: [ super displayValue ] ifNotNil: [ super displayValue sorted: sortBlock ]renderPresentation: aPresentation  ^nilnewBrickWithSmallStaticExtent  ^GLMBrick new     height: self staticSmallHeight;     width: self staticSmallWidth;     color: Color random;     yourselfselectedBorderStyleFor: aBrick  ^self normalBorderStyleFor: aBrickpresentation  ^presentationwaitUntilUIRedrawed  self isRunningInUIProcess ifTrue: [ self currentWorld doOneCycle.        ^self ].  self currentWorld defer: [ uiWaitingSemaphore ifNotNil: #signal ].  uiWaitingSemaphore wait: self defaultWaitDurationmodel  ^adaptorhPercent  ^self hState percentaction  ^actionBlockscrollToPane: anIndex smooth: isSmooth  self scrollToPane: anIndex smooth: isSmooth callback: nilcustomFont  font := LogicalFont new     familyName: self familyName;     fallbackFamilyNames: nil;     pointSize: self fontSize;     weightValue: 400;     stretchValue: 5;     slantValue: 0;     yourselfclearUserEdits  self flag: 'Should remove the need for using #defer:. Currently it used as	the rendered suspends all announcements for a presentation when it handles a text changed request.'.  UIManager default defer: [ self announce: (GLMTextEditorRequest new action: [:anEditor |  anEditor model clearUserEdits ]) ]position  ^positiondefaultScrollButtonIconRenderBlock  ^[:object |  {Form new .   Form new} ]tagMorphsFrom: aTagProvider for: element  | tagMorphs tags tagsFilter |  tagMorphs := OrderedCollection new.  tags := self glamourPresentation tagsFor: element fromProvider: aTagProvider to: #show.  tagsFilter := self glamourPresentation tagsFor: element fromProvider: aTagProvider to: #filter.  tags withIndexDo: [:each :index |  tagMorphs addLast: (self buttonForTag: each filter: (tagsFilter at: index ifAbsentPut: [ each ])) ].  ^tagMorphsnormalizeHeight: anInteger of: aBrick  ^(anInteger max: (aBrick layout minHeight brickValue: aBrick)) min: (aBrick layout maxHeight brickValue: aBrick)rubricCursorColor: aColor  self setProperty: #brickRubricCursorColor toValue: aColor.  self updateStyletestColumnBlockTakesEntity  | browser receivedEntity |  browser := GLMFinder new.  receivedEntity := nil.  browser show: [:a |  a table column: 'Even' evaluated: [:each :entity |  receivedEntity := entity.              'x' ] ].  window := browser openOn: (1 to: 5).  self waitUntilUIRedrawed.  self assert: receivedEntity equals: (1 to: 5)containerTree: anObject  containerTree := anObjectcontext: aContext  context := aContextborderAnimation  ^borderAnimation ifNil: [ borderAnimation := GLMAnimation borderColor duration: 200 ]vShrinkWrap  super vShrinkWrap.  self label vShrinkWrap.  self dotsBrick vShrinkWraptestSelectionValidation  | browser |  browser := GLMTabulator new.  browser     column: [:c |  c           row: #one;           row: #two ];     column: #three.  browser transmit     to: #one;     andShow: [:a |  a list display: [:x |  1 to: x ] ].  browser transmit     to: #two;     from: #one;     andShow: [:a |  a list           beMultiple;           display: [:x |  1 to: x ] ].  browser transmit     to: #three;     from: #two;     andShow: [:a |  a text ].  browser startOn: 42.  ((browser paneNamed: #one) port: #selection) value: 40.  self assert: ((browser paneNamed: #two) port: #entity) value equals: 40.  ((browser paneNamed: #two) port: #selection) value: #(10 30 40).  self assert: ((browser paneNamed: #two) port: #selection) value equals: #(10 30 40).  self assert: ((browser paneNamed: #three) port: #entity) value equals: #(10 30 40).  ((browser paneNamed: #two) port: #selection) value: #(10 30).  self assert: ((browser paneNamed: #two) port: #selection) value equals: #(10 30).  self assert: ((browser paneNamed: #three) port: #entity) value equals: #(10 30).  ((browser paneNamed: #one) port: #selection) value: 5.  self assert: ((browser paneNamed: #two) port: #entity) value equals: 5.  ((browser paneNamed: #two) port: #selection) value: #(1 3).  self assert: ((browser paneNamed: #two) port: #selection) value equals: #(1 3).  self assert: ((browser paneNamed: #three) port: #entity) value equals: #(1 3)haloClass  ^#GLMHaloBricktransformation: aBlock  transformation := aBlockonStepped: aBlock  steppedLogic := aBlockonChildrenLayouted  ^self brick onChildrenLayouteddefaultValidate: anObject on: aPort  aPort name == #selection ifFalse: [ ^true ].  self entity ifNil: [ ^false ].  self allDisplayedDo: [:each |  each = anObject ifTrue: [ ^true ] ].  ^falseaddNewPane  ^self addNewPaneNamed: 'undefined'boundsInWorld  ^self globalBoundsrender: aPresentation  container := GLMMorphic containerMorph.  container     changeTableLayout;     listDirection: #leftToRight;     vResizing: #spaceFill;     hResizing: #spaceFill.  container addMorphBack: aPresentation displayValue widget widget.  aPresentation when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  ^containerthemer  ^themerpane: aPane  pane := aPaneoldPresentations: aCollection  oldPresentations := aCollectionisFloating: aBrick  aBrick layout floating = #none ifTrue: [ ^false ].  ^self respondsTo: (self floatingMethodFor: aBrick layout floating)title: anObject  title := anObjectlist  ^self custom: GLMListPresentation newcursorPosition  ^cursorPositiontestToWatcher  browser transmit toWatcher.  self assert: browser transmissions first destination pane equals: browser watcherPaneallowsRecursiveSearch: aBoolean  allowsRecursiveSearch := aBooleantextSize  ^textSize ifNil: [ textSize := self sizeOf: self text ]isDotsAdded  ^self hasSubbrick: self dotsBrickmarginBottom  ^self brick marginBottomtestAllActions  | listing |  listing := GLMPresentation new.  self assert: listing hasActions not.  listing addAction: GLMAction new.  listing addAction: GLMAction new.  listing dynamicActions: [:p |  OrderedCollection with: GLMAction new with: GLMAction new with: GLMAction new ].  self assert: listing allActions size equals: 5.  self assert: listing hasActionstearDown  window ifNotNil: [ window delete ].  super tearDowncustomValidation: aBlock  customValidation := aBlock.  shouldValidate := trueenabledCondition: anObject  enabledCondition := anObjecttoggleFilteringByTag: aTag  (self shouldFilterByTag: aTag) ifTrue: [ self tagsToFilterBy remove: aTag ] ifFalse: [ self tagsToFilterBy add: aTag ].  self resetChildrenContent.  self tableRefreshdisplay: aBlock  self transformation: aBlockenableElementIndex  self parameters at: 'withRowIndex' put: truefilterOn: aBlock  self error: 'This presentation does not allow filtering with a block for now. In the futur we should have a new filter with FastTable to do that. If you want to give it a try look FTFunction and his subclasses.'editRowMorphForColumn: glamourColumn node: aNode withIndex: aRowIndex  | rowMorph |  rowMorph := self viewRowMorphForColumn: glamourColumn node: aNode withIndex: aRowIndex.  rowMorph hResizing: #spaceFill.  rowMorph on: #mouseDown send: #value: to: [:event |  event shiftPressed ifTrue: [ GLMEditorPopupBrick new                 in: [:aPopup |  aPopup themer: aPopup themer popupEditorBorderThemer themer ];                 closer: (GLMPopupBrickCloser new                       predicate: GLMPopupBrickOutisideClickPredicate new;                       predicate: GLMPopupBrickEscPredicate new;                       yourself);                 textModel: (self valueFor: aNode withIndex: aRowIndex in: glamourColumn);                 when: #textAccepted do: [:anEvent |  glamourColumn modifiedBlock cull: anEvent morph text cull: aNode cull: self glamourPresentation ];                 openOn: rowMorph ] ifFalse: [ event wasHandled: false ] ].  ^rowMorphpaneAt: anIndex  ^self panes at: anIndexpredicates  ^predicatestransformation  ^transformationnext  < return: #GLMVector>  ^nextactOnUpdatedPresentation: anAnnouncement  treeMorph model updateRoots.  self flag: 'Calling update list explicitly here is a hack. This should be solvable by the model through a notification mechanism'.  treeMorph updateListrender: aDropListPresentation  listModel := GLMDropListModel new glamourPresentation: aDropListPresentation.  listModel announcer when: GLMDropDownListMorphSelectionChanged do: [:ann |  aDropListPresentation selectedIndex: ann selectionIndex.        aDropListPresentation selection: ann selectionValue ].  listModel selectionIndex: aDropListPresentation selectedIndex.  dropDownMorph := (MorphDropListMorph on: listModel list: #list selected: #selectionIndex changeSelected: #selectionIndex: useIndex: true)     hResizing: #spaceFill;     vResizing: #shrinkWrap.  aDropListPresentation when: GLMContextChanged send: #actOnContextChanged: to: self.  aDropListPresentation when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  ^dropDownMorphcomputeTagsFor: aGlamourValue  ^self computeTagsFor: aGlamourValue from: self tagsBlockvisibleIndex  ^visibleIndex ifNil: [ visibleIndex := 1 ]extent: aPoint  | newTop patch offset |  super extent: aPoint.  offset := (self height - self textArea height) / 2.0.  patch := offset fractionPart rounded - offset sign.  newTop := (offset + patch) truncated abs.  self textArea top: newTopintercellSpacing  ^self parameters at: 'intercellSpacing' ifAbsent: [ self class defaultIntercellSpacing ]markDirty: aBrick  self markLayoutDirty: aBrick owner.  aBrick markHeightDirtystyle: aText  self styler ifNotNil: [:aStyler |  aStyler styleInBackgroundProcess: aText ]updateButtons  self buttons select: #isFocused thenDo: #uncheck.  self pagerModel size > 0 ifTrue: [ self buttons from: self pagerModel firstVisiblePageIndex to: self pagerModel lastVisiblePageIndex do: #check ]open  self presentation openOn: self loremIpsumselectionIndex: anObject  selectionIndex := anObject.  self announcer announce: (GLMDropDownListMorphSelectionChanged new           selectionValue: self selectedItem;           selectionIndex: selectionIndex;           yourself)searchStrategy  ^searchBlockupdateFont  font := LogicalFont familyName: self familyName pointSize: self fontSizeinitialize  super initialize.  parameters := Dictionary newanimate: anObject  self asyncTask terminate.  animatedObject := anObject.  self reset.  stamp := Time millisecondClockValue.  self asyncTask     doInBackground: [ [ self shouldStop ] whileFalse: [ self needsStep ifTrue: [ self animationStep ] ] ];     onCompleted: [ isCompleted := true.        [ callback brickValue: self animatedObject ] ensure: [ ensureLogic brickValue: self animatedObject ] ];     priority: Processor userSchedulingPriority;     executetestDefaultStrategy  self assert: GLMTransmission new transmissionStrategy class equals: GLMNoStrategymarginRight  ^self brick marginRightshouldStop  ^shouldStop ifNil: [ shouldStop := false ]smooth: anObject  smooth := anObjectisCancelOnEscape  ^cancelOnEscape ifNil: [ cancelOnEscape := false ]closePopup  self stopSteppingSelector: #openHintPopup:.  hintBrick ifNotNil: [ hintBrick close.        hintBrick := nil ]contentsMorph  ^contentsMorphnumberOfVisiblePages  ^numberOfVisiblePagespopPane: isSmooth  self invariant.  pagesCount >= 1 ifTrue: [ | scrollTo smooth |        smooth := isSmooth.        focusedViews removeKey: pagesCount ifAbsent: [ true ].        pagesCount := pagesCount - 1.        firstVisiblePageIndex = 1 ifTrue: [ smooth := false ].        lastVisiblePageIndex > pagesCount ifTrue: [ firstVisiblePageIndex := firstVisiblePageIndex - 1.              lastVisiblePageIndex := lastVisiblePageIndex - 1 ].        firstVisiblePageIndex := firstVisiblePageIndex max: 1.        pagesCount = 0 ifTrue: [ selectedPageIndex := 0.              firstVisiblePageIndex := 0 ].        self selectedPageIndex > pagesCount ifTrue: [ self selectedPageIndex: pagesCount ].        scrollTo := pagesCount = firstVisiblePageIndex & (pagesCount > self numberOfVisiblePages).        self notifyPagePoped: smooth ].  self invariantto: aPort  ^self destination: (self browser resolveDestinationPort: aPort)color: colors  colors ifNil: [ ^self color: #(0) ].  colors isCollection ifTrue: [ colors isEmpty ifTrue: [ ^self color: #(0) ].        self           colorTop: (colors at: 1);           colorRight: (colors at: 1);           colorBottom: (colors at: 1);           colorLeft: (colors at: 1).        colors size > 1 ifTrue: [ self                 colorRight: (colors at: 2);                 colorLeft: (colors at: 2) ].        colors size > 2 ifTrue: [ self colorBottom: (colors at: 3) ].        colors size > 3 ifTrue: [ self colorLeft: (colors at: 4) ] ] ifFalse: [ ^self color: {colors} ]testStartTransmissionFromInitializationBlock  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #one;     andShow: [:a |  a list initialize: [:pres |  pres selection: 4 ] ].  browser transmit     from: #one port: #selection;     to: #two port: #entity;     andShow: [:a |  a text ].  self assertEmpty: (browser paneNamed: #one) presentations.  self assertEmpty: (browser paneNamed: #two) presentations.  browser startOn: 42.  self assert: (browser paneNamed: #one) presentations size equals: 1.  self assert: (browser paneNamed: #one) presentations first selection equals: 4.  self assert: (browser paneNamed: #two) presentations size equals: 1calculateItems  ^self basicItems collect: [:coll |  coll select: [:each |  self elementShouldBeDisplayed: each ] ]themer  ^self privateThemer ifNotNil: [ self privateThemer ] ifNil: [ self owner isNotNil ifTrue: [ self owner isBrick ifTrue: [ self owner themer ] ifFalse: [ super brickThemer ] ] ifFalse: [ self theme brickThemer ] ]calculateElements  ^self tagsToFilterBy ifEmpty: [ self basicElements ] ifNotEmpty: [ self basicElements select: [:each |  self elementShouldBeDisplayed: each ] ]condition: anObject  condition := anObjectnewLabel  ^GLMLabelBrick new margin: #(3 0)smooth  ^smoothtestUpdateFromModel  | browser treeMorphOne1 treeMorphTwo1 treeMorphOne2 treeMorphTwo2 |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #one;     andShow: [:a |  a list display: [:x |  x - 3 to: x ] ].  browser transmit     to: #two;     from: #one;     andShow: [:a |  a list display: [:x |  x * 10 to: x * 10 + 2 ] ].  window := browser openOn: 4.  treeMorphOne1 := self find: MorphTreeMorph in: window.  self assert: (treeMorphOne1 model roots collect: #item) equals: #(1 2 3 4) asOrderedCollection.  ((browser paneNamed: #one) port: #selection) value: 2.  treeMorphTwo1 := self findLast: MorphTreeMorph in: window.  self assert: (treeMorphTwo1 model roots collect: #item) equals: #(20 21 22) asOrderedCollection.  browser entity: 8.  treeMorphOne2 := self find: MorphTreeMorph in: window.  self assert: (treeMorphOne2 model roots collect: #item) equals: #(5 6 7 8) asOrderedCollection.  self assert: treeMorphOne1 ~= treeMorphOne2.  self assertEmpty: window submorphs last submorphs last submorphs first submorphs.  ((browser paneNamed: #one) port: #selection) value: 5.  treeMorphTwo2 := self findLast: MorphTreeMorph in: window.  self assert: (treeMorphTwo2 model roots collect: #item) equals: #(50 51 52) asOrderedCollection.  self assert: treeMorphTwo1 ~= treeMorphTwo2flash  self announce: (GLMTextEditorRequest new action: [:anEditor |  anEditor flash ])buttonCenterByIndex: aNumber  | width |  width := self pagerModel circleButtonSize.  ^(aNumber - 1) * width + (width / 2)popupSuccessThemer  ^self registerModule: GLMBrickPopupSuccessThemer new to: self named: #popupThemergetText  ^self glamourPresentation formatedDisplayValuehShrinkWrap  hResizing := #shrinkWrap.  self width: [ self morph width ]containerTree: anObject  containerTree := anObjectsetLabelOf: aWindow for: aRenderable  aWindow setLabel: (self titleFor: aRenderable)marginBottom  ^self wrappedBounds marginBottompane: anObject  pane := anObjectdefaultBorderStyle  ^FillStyleBorder color: (Color white darker alpha: 0.5) width: 10testCopyNotTheSameRegistry  | presentation newPresentation |  presentation := GLMPresentation new.  newPresentation := presentation copy.  self assert: presentation glmSubscriptions ~~ newPresentation glmSubscriptionsdarken  ^Color brickColorRegistry at: #brickDarken ifAbsentPut: [ Color r: 29 g: 29 b: 29 range: 255 ]testListDoubleClickWithMultipleSelection  | browser treeMorph treeNodeMorph lastTreeNodeMorph |  browser := GLMFinder new.  browser show: [:a |  a tree beMultiple ].  window := browser openOn: ($a to: $d).  treeMorph := window submorphs last submorphs first submorphs first submorphs first submorphs first.  treeNodeMorph := treeMorph scroller submorphs first.  lastTreeNodeMorph := treeMorph scroller submorphs last.  self send: treeMorph mouseUpWithShift: false onItem: treeNodeMorph.  self send: treeMorph mouseUpWithShift: true onItem: lastTreeNodeMorph.  self send: treeMorph doubleClickWithShift: false onItem: treeNodeMorph.  self assert: (browser panes first port: #strongSelection) value asSet equals: ($a to: $d) asSettestSimpleTransmission  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser sendTo: #two -> #port2 from: #one -> #port1.  self assert: browser transmissions size equals: 1.  self assert: (browser transmissions first transmissionStrategy isKindOf: GLMNoStrategy).  self assert: browser transmissions first origins first equals: ((browser paneNamed: #one) port: #port1).  self assert: browser transmissions first destination equals: ((browser paneNamed: #two) port: #port2)isLastAdded  ^(self getIndex: self band lastSubbrick) = self model countisHeightClean  ^self heightState = #cleanentity: anObject  entity := anObject.  self setTitle: (self titleLogic phlowValue: self entity)announcer  ^announcer ifNil: [ announcer := GLMAnnouncer new ]isSyncronous  ^isSyncronouscopyAccordingToPaneMapping: newPanesMapping inNewBrowser: anotherBrowser  ^self subclassResponsibilityborderWidth: anObject  < brickBuilderProperty: #'Look&Feel' name: 'Border width' as: #brickBuilderEvaluate getter: #borderWidth model: #GLMUIBuilderTextFieldProperty>  self border width: anObjectbindingThemer  ^self registerModule: GTPlayBindingDarkThemer newpopulate: aPortSymbol icon: anIcon entitled: aString with: aBlock  self addAction: (GLMGenericAction new           action: (GLMPortUpdater new                 portSymbol: aPortSymbol;                 valueBlock: aBlock;                 yourself);           icon: anIcon;           title: aString;           yourself)markLayoutDirty  self layout markDirtywithSmalltalkSearch  self     searchOn: [:text :each |  Smalltalk compiler           receiver: each;           evaluate: ' | entity each | each := self. entity := each.' , text ];     helpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'styler  ^styler ifNil: [ styler := self defaultStyler ]testMultipleInitialSelection  | browser firstTreeMorph |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a tree           beMultiple;           display: [:x |  1 to: x * 3 ] ].  window := browser openOn: 5.  (browser panes first port: #selection) value: #(2 5 3).  firstTreeMorph := self find: MorphTreeMorph in: window.  self assert: firstTreeMorph model selection notNil.  self assert: firstTreeMorph model selection selectedItemOrItemsOrNil size equals: 3isSelected  ^isSelectedupdateToolbar  super updateToolbar.  cachedPresentation ifNotNil: [ cachedPresentation updateToolbar.        cachedPresentation presentations do: #updateToolbar ]testValidSubscriptionsInComplexBrowser  | browser navigator tabulator1 tabulator2 pane1 pane2 content1 content2 details1 details2 |  navigator := GLMTabulator new.  navigator     row: #content;     row: #details.  navigator transmit     to: #content;     andShow: [:a |  a list display: #allSuperclasses ].  navigator transmit     from: #content;     to: #details;     andShow: [:a |  a text ].  navigator transmit     from: #content;     toOutsidePort: #selection.  browser := GLMFinder new.  browser show: [:a |  a custom: navigator ].  self assertEmpty: browser panes.  (browser pane port: #entity) value: String.  self assert: browser panes size equals: 1.  pane1 := browser panes first.  tabulator1 := pane1 presentations first.  content1 := tabulator1 panes first.  self assert: content1 presentations first displayValue size equals: 5.  (content1 port: #selection) value: Collection.  self assert: browser panes size equals: 2.  pane2 := browser panes second.  tabulator2 := pane2 presentations first.  content2 := tabulator2 panes first.  self assert: content1 presentations first displayValue size equals: 5.  self assert: content2 presentations first displayValue size equals: 2.  details1 := tabulator1 panes second.  self assert: details1 presentations first displayValue equals: Collection.  (content2 port: #selection) value: Object.  self assert: details1 presentations first displayValue equals: Collection.  details2 := tabulator2 panes second.  self assert: details2 presentations first displayValue equals: Object.  self assert: content1 presentations first displayValue size equals: 5.  self assert: content2 presentations first displayValue size equals: 2testPorts  | transmission |  transmission := GLMTransmission new.  transmission addActiveOrigin: (GLMSimplePort new           name: #port1;           value: 1).  transmission addPassiveOrigin: (GLMSimplePort new           name: #port2;           value: 2).  transmission addActiveOrigin: (GLMSimplePort new           name: #port3;           value: 3).  transmission addPassiveOrigin: (GLMSimplePort new           name: #port4;           value: 4).  transmission destination: (GLMSimplePort new name: #port5).  self assert: transmission originReferences size equals: 4.  transmission originReferences do: [:each |  self assert: (each isKindOf: GLMOriginPortReference) ].  self assert: (transmission originReferences at: 1) port name equals: #port1.  self assert: (transmission originReferences at: 2) port name equals: #port2.  self assert: (transmission originReferences at: 3) port name equals: #port3.  self assert: (transmission originReferences at: 4) port name equals: #port4.  self assert: transmission origins size equals: 4.  transmission origins do: [:each |  self assert: (each isKindOf: GLMSimplePort) ].  self assert: (transmission origins at: 1) name equals: #port1.  self assert: (transmission origins at: 2) name equals: #port2.  self assert: (transmission origins at: 3) name equals: #port3.  self assert: (transmission origins at: 4) name equals: #port4.  self assert: transmission activeOrigins size equals: 2.  transmission activeOrigins do: [:each |  self assert: (each isKindOf: GLMSimplePort) ].  self assert: (transmission activeOrigins at: 1) name equals: #port1.  self assert: (transmission activeOrigins at: 2) name equals: #port3.  self assert: transmission passiveOrigins size equals: 2.  transmission passiveOrigins do: [:each |  self assert: (each isKindOf: GLMSimplePort) ].  self assert: (transmission passiveOrigins at: 1) name equals: #port2.  self assert: (transmission passiveOrigins at: 2) name equals: #port4.  self assert: (transmission destination isKindOf: GLMSimplePort).  self assert: transmission destination name equals: #port5action: anObject  clickAction := anObjectlayoutFloatingRight: aBrick in: newBounds  | left top |  left := aBrick owner width - aBrick width - aBrick marginRight - aBrick owner paddingRight.  top := aBrick marginTop + aBrick owner paddingTop.  aBrick brickBounds: (left @ top extent: aBrick extent).  ^0icon  ^self normalImagetransmitIn: aContext  initialExtent: aPoint  initialExtent := aPointtestInterdependentPanesShouldUpdateTheFocusTriggerPane  | treeMorphThree treeMorphThree2 browser treeMorphTwo treeMorphOne |  browser := GLMTabulator new.  browser     column: #one;     column: #two;     column: #three.  browser transmit     to: #one;     andShow: [:a |  a list display: [:x |  1 to: x ] ].  browser transmit     to: #two;     from: #one;     andShow: [:a |  a list display: [:x |  1 to: x * 2 ] ].  browser transmit     to: #three;     from: #two;     andShow: [:a |  a list display: [:x |  1 to: x * 3 ] ].  browser transmit     toOutsidePort: #focus;     from: #three port: #focus.  browser transmit     to: #one port: #selection;     fromOutsidePort: #focus;     transformed: [:x |  x + 1 ].  browser transmit     to: #two port: #selection;     fromOutsidePort: #focus;     transformed: [:x |  x + 2 ].  window := browser openOn: 5.  ((browser paneNamed: #one) port: #selection) value: 3.  ((browser paneNamed: #two) port: #selection) value: 6.  treeMorphThree := self findWherePresentationIs: (browser paneNamed: #three) presentations first in: window.  ((browser paneNamed: #three) port: #selection) value: 2.  ((browser paneNamed: #three) port: #focus) value: 1.  self assert: ((browser paneNamed: #one) port: #entity) value equals: 5.  self assert: ((browser paneNamed: #one) port: #selection) value equals: 2.  self assert: ((browser paneNamed: #two) port: #entity) value equals: 2.  self assert: ((browser paneNamed: #two) port: #selection) value equals: 3.  self assert: ((browser paneNamed: #three) port: #entity) value equals: 3.  self assert: ((browser paneNamed: #three) port: #selection) value isNil.  treeMorphThree2 := self findWherePresentationIs: (browser paneNamed: #three) presentations first in: window.  self assert: treeMorphThree ~= treeMorphThree2.  self assert: treeMorphThree2 selectedMorph isNil.  treeMorphOne := self findWherePresentationIs: (browser paneNamed: #one) presentations first in: window.  self assert: treeMorphOne selectedMorph notNil.  treeMorphTwo := self findWherePresentationIs: (browser paneNamed: #two) presentations first in: window.  self assert: treeMorphTwo selectedMorph notNillabel  ^self isSelected ifTrue: [ self selectedLabel userString ifNil: [ self firstSubmorph ] ] ifFalse: [ self normalLabel userString ifNil: [ self firstSubmorph ] ]columns  ^columns ifNil: [ columns := OrderedCollection new ]testPresentations  | pane presentation announcement |  pane := GLMPane named: 'test'.  presentation := GLMPresentation new.  self assertEmpty: pane presentations.  announcement := nil.  pane when: GLMPresentationsChanged do: [:ann |  announcement := ann ].  pane addPresentation: presentation.  self assert: pane presentations size equals: 1.  self assert: pane presentations first identicalTo: presentation.  self assert: presentation pane identicalTo: pane.  self assert: announcement notNilinnerPortEvent: aPortEvent  aPortEvent portName = #entity ifFalse: [ (self pane port: aPortEvent portName) value: aPortEvent value ]hPercent: anInteger  hState := self hState onParentDo: [:s |  s percent: anInteger ]renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderDiffPresentation: selftestCustomInstance  | memoryLogger |  self assert: GLMLogger instance identicalTo: GLMLogger nullInstance.  memoryLogger := GLMMemoryLogger new.  GLMLogger instance: memoryLogger.  self assert: GLMLogger instance identicalTo: memoryLogger.  GLMLogger reset.  self assert: GLMLogger instance identicalTo: GLMLogger nullInstanceaddColumn: aBlockOrSymbol span: anInteger  ^(self addColumn: aBlockOrSymbol) span: anIntegertestForbiddenAnnouncements  | context pane |  context := GLMTransmissionContext new.  pane := GLMPane new.  self assert: (context canAnnounceMatchingPresentationsChanged: pane).  context forbidToAnnounceMatchingPresentationsChanged: pane.  self assert: (context canAnnounceMatchingPresentationsChanged: pane) notinitialize  super initialize.  self     removeMorph: self contentMorph;     removeMorph: self tabSelectorMorph;     toolbarMorph: self newToolbarMorph;     headerMorph: self newHeaderMorph;     addMorph: self headerMorph;     addMorph: self contentMorphdebugSelection  textMorph debugItactOnMatchingPresentationChanged: anAnnouncement  container removeAllMorphs.  self renderContainerFor: anAnnouncement pane.  self renderer window ifNotNil: [ self flag: 'this check is fishy'.        self renderer window fullBounds ]synchronizeScrollTo: aValue  self notifySynchronizeScrollTo: aValueresetLayout  self vResizing: #rigid.  self hResizing: #rigid.  self height: nil.  self width: nilnewText  ^GLMRubTextAreaBrick new     width: 200;     margin: #(3 0);     vShrinkWrap;     rubricTextFamilyName: StandardFonts defaultFont familyNamedelay  ^delay ifNil: [ delay := 0 ]asBrick  ^selfact: aBlock icon: anIcon entitled: aString  self addAction: (GLMGenericAction new           action: aBlock;           icon: anIcon;           title: aString;           yourself)addBrickBack: aBrick  | result |  result := self privateAddBrickBack: aBrick asBrick.  self privatePrepareBrickAfterAdding: result.  self doLayoutForce.  ^aBrickhighlightSmalltalk  ^highlightSmalltalkinitializeAnnouncementForPresentation: aPresentation  aPresentation when: GLMDataSourceUpdated send: #dataSourceUpdated: to: self.  aPresentation when: GLMContextChanged send: #actOnContextChanged: to: self.  aPresentation when: GLMPresentationUpdated send: #actOnUpdatedPresentation: to: self.  aPresentation when: GLMPresentationRefreshRequest send: #actOnPresentationRefreshRequest: to: selftransmitIn: aContext  self subclassResponsibilitydefaultValidate: anObject on: aPort  aPort name == #selection ifFalse: [ ^true ].  self entity ifNil: [ ^false ].  ^self isMultiple ifTrue: [ anObject isCollection and: [ anObject allSatisfy: [:each |  self displayValue includes: each ] ] ] ifFalse: [ self displayValue includes: anObject ]peterRiver  ^Color brickColorRegistry at: #brickPeterRiver ifAbsentPut: [ Color r: 52 g: 152 b: 219 range: 255 ]beNormal  self isReadMode ifTrue: [ ^self ].  self animateToNormal.  self removeBrick: self editBrick.  self activeHand releaseKeyboardFocus.  self addBrickBack: self labelBrick.  self announce: #onReadModehighlightSmalltalkContext  ^highlightSmalltalkContext ifNil: [ nil ] ifNotNil: [ highlightSmalltalkContext glamourValue: self entity ]watcherPane  ^nilscrollUp: anInteger  self scrollBy: (self isFirstAdded ifTrue: [ anInteger min: self topOffset - self bandTopOffset ] ifFalse: [ anInteger ])spacing  ^6actOnEvaluateSelection: ann  UIManager default defer: [ textMorph evaluateSelectionAndDo: ann action ]show: aBlock  self transmission transmissionStrategy presentationsFactory: aBlockscrollbarWidth  ^self valueOfProperty: #brickScrollbarWidth ifAbsent: [ self themer scrollbarWidth ]menu: menu shifted: b  self selectedNode ifNotNil: [:current |  current menu: menu shifted: b ].  ^menuroots: anObjectOrCollection  roots := anObjectOrCollection isCollection ifTrue: [ anObjectOrCollection collect: [:each |  self nodeModelFor: each ] ] ifFalse: [ OrderedCollection with: (self nodeModelFor: anObjectOrCollection) ]tagsBlock  ^tagsBlocktestNestedSuspendParticularAnnouncementWhile  | announcement instance2 announcement2 |  announcer when: GLMTestAnnouncement , GLMTestAnnouncement2 do: [:ann |  announcement := ann ].  announcement2 := nil.  announcer suspendAll: {GLMTestAnnouncement} while: [ announcer suspendAll: {GLMTestAnnouncement2} while: [ instance2 := announcer announce: GLMTestAnnouncement.              announcement2 := announcement.              announcement := nil ].        announcer announce: GLMTestAnnouncement ].  self assert: announcement isNil.  self assert: announcement2 equals: instance2sizing  ^sizing ifNil: [ self updateSizing ]beForScripting  isForScripting := truedefaultValidate: anObject on: aPort  aPort name == #selection ifFalse: [ ^true ].  self entity ifNil: [ ^false ].  ^self displayValue includes: anObjectfromOutsideEntityPortTransformed: aBlock  ^self fromOutsidePort: #entity transformed: aBlockopenOn: anObject with: aRenderer  self startOn: anObject.  ^self openWith: aRenderercomputeTagsFor: aGlamourValue from: aBlock  | value |  aBlock ifNil: [ ^OrderedCollection new ].  value := aBlock glamourValue: aGlamourValue.  ^value isString ifTrue: [ OrderedCollection with: value ] ifFalse: [ value asOrderedCollection ]data  ^datavalueFor: aGlamourColumn  ^self containerTree glamourPresentation column: aGlamourColumn valueFor: self itemactionBlock  ^self parameters at: 'actionBlock'allowsFilter  ^filterBlock notNilpresentation: anObject  presentation := anObjectprivacyMessage  ^self sendUsageData ifTrue: [ 'You are sending diagnostic and usage data to help us improve Pharo. Thanks!' ] ifFalse: [ 'No diagnostic and usage data is being sent. Would you like to send diagnostic and usage data to help us improve Pharo?' ]onLayoutEvent: aLayoutEvent  ^self brick onLayoutEvent: aLayoutEventtestUpdatingTextPortUpdatesTheMorph  < expectedFailure>  | composite textMorph |  composite := GLMCompositePresentation new with: [:a |  a text ].  window := composite openOn: 'fourtytwo'.  composite first text: '42'.  self assert: (composite pane port: #text) value asString equals: '42'.  textMorph := self find: RubScrolledTextMorph in: window.  self assert: textMorph text asString equals: '42'column: aBlockOrString evaluated: aBlock sortedBy: aSortingBlock  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           sortBlock: aSortingBlock)childrenValueOf: anObject  ^self children glamourValue: anObject asGlamorousMultiValue , self entity asGlamorousMultiValuetestAllowNil  | browser presentationsChanged matchingPresentationsChanged |  browser := GLMTabulator new.  browser     column: [:c |  c           row: #one;           row: #two ];     column: #details.  browser transmit     to: #one;     andShow: [:a |  a tree display: #(1 2 3) ].  browser transmit     to: #two;     andShow: [:a |  a tree display: #(#a #b #c) ].  browser transmit     to: #details;     from: #one;     from: #two;     andShow: [:a |  a text           display: [:one :two |  one asString , two asString ];           allowNil ].  browser startOn: 42.  (browser paneNamed: #details) when: GLMPresentationsChanged do: [:a |  presentationsChanged := true ].  (browser paneNamed: #details) when: GLMMatchingPresentationsChanged do: [:a |  matchingPresentationsChanged := true ].  presentationsChanged := false.  matchingPresentationsChanged := false.  ((browser paneNamed: #one) port: #selection) value: 2.  self assert: presentationsChanged.  self assert: matchingPresentationsChanged.  self assert: (browser paneNamed: #details) presentations first displayValue equals: '2nil'.  presentationsChanged := false.  ((browser paneNamed: #two) port: #selection) value: #c.  self assert: presentationsChanged.  self assert: matchingPresentationsChanged.  self assert: (browser paneNamed: #details) presentations first displayValue equals: '2c'.  presentationsChanged := false.  ((browser paneNamed: #one) port: #selection) value: nil.  self assert: presentationsChanged.  self assert: matchingPresentationsChanged.  self assert: (browser paneNamed: #details) presentations first displayValue equals: 'nilc'testTransmitting  | transmission |  transmission := GLMTransmission new.  transmission addActiveOrigin: (GLMSimplePort new           name: #port1;           value: 1).  transmission destination: (GLMSimplePort new name: #port5).  self assert: transmission value equals: 1.  self assert: transmission destination value isNil.  transmission transmit.  self assert: transmission destination value equals: 1.  transmission addPassiveOrigin: (GLMSimplePort new           name: #port2;           value: 2).  transmission addActiveOrigin: (GLMSimplePort new           name: #port3;           value: 3).  transmission addPassiveOrigin: (GLMSimplePort new           name: #port4;           value: 4).  self assert: transmission value equals: (GLMMultiValue withAll: #(1 2 3 4)).  transmission transmit.  self assert: transmission destination value equals: (GLMMultiValue withAll: #(1 2 3 4))oldValue  ^oldValueopenInWorld  super openInWorld.  isOpen := trueprofileSelection  self announce: GLMProfileSelectionscrollToPane: anIndex smooth: isSmooth callback: aBlock  self scrollTo: (pagerModel convertIndexToValue: anIndex) smooth: isSmooth callback: aBlockselectedBackgroundStyleFor: aBrick  ^self theme tabLabelSelectedFillStyleFor: aBricktabSelector  ^tabSelectoronPositionChanged: announcement  self scrollToPane: pagerModel firstVisiblePageIndex smooth: announcement smoothtearDown  window ifNotNil: [ window delete ].  super tearDownamountToFilterBy: aNumber  amountToFilterBy := aNumbercustomWidth  ^self layout width brickValue: selfacceptContents: anAnnouncement  self announce: #textAccepted event: anAnnouncement.  self closechildrenBlock  ^childrenBlock ifNil: [ childrenBlock := self glamourPresentation children isNil ifFalse: [ self glamourPresentation children ] ifTrue: [ OrderedCollection new ] ]testAddSetsCorrectPane  | composite presentation |  composite := GLMCompositePresentation new.  presentation := GLMPresentation new.  composite add: presentation.  self assert: composite pane equals: presentation panescrollBarIsVisible  ^submorphs includes: scrollBarouterHeight: anInteger  ^self brick wrappedBounds outerHeight: anIntegerglamourColumn: aColumn  glamourColumn := aColumnaction: anObject  action := anObjectlist  ^list ifNil: [ list := self glamourPresentation displayValue collect: [:each |  (self glamourPresentation formatedDisplayValueOf: each) asMorph ] ]addColumn: aColumn  | brick |  brick := (aColumn computation phlowValue: self entity) asBrick.  brick := aColumn style phlowValue: brick.  ^self addBrickBack: brickmarginTop: anInteger  self translateY: anInteger - self marginTop.  self margin at: Top put: anInteger.  self updateCachetitleOrIconOrNilOf: aPresentation in: container  ^aPresentation hasTitleIcon ifTrue: [ | image |        image := self theme newImageIn: container form: aPresentation titleIconValue.        aPresentation titleValue ifNotNil: [ image setBalloonText: aPresentation titleValue maxLineLength: 10 ] ] ifFalse: [ aPresentation hasTitle ifTrue: [ aPresentation titleValue ] ifFalse: [ nil ] ]testTreeWithTags  | browser model oddNode lineWithNumber3 someNode secondSome |  model := Dictionary new.  model at: #even put: #(2 6 8).  model at: #odd put: #(3 7 9).  model at: #some put: #(1 2 3 4).  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a tree           display: [ model keys ];           sortBlock: [:x :y |  x <= y ];           children: [:key |  key isNumber ifFalse: [ model at: key ] ];           tags: [:item |  item isNumber ifTrue: [ item even ifTrue: [ #('even') ] ifFalse: [ #('odd') ] ] ifFalse: [ #() ] ] ].  window := browser openOn: model.  self waitUntilUIRedrawed.  oddNode := self treeVisibleItems second.  oddNode toggleExpandedState.  self waitUntilUIRedrawed.  lineWithNumber3 := self treeVisibleItems third.  (self find: SimpleButtonMorph in: lineWithNumber3) doButtonAction.  self waitUntilUIRedrawed.  someNode := self treeVisibleItems fifth.  someNode toggleExpandedState.  self waitUntilUIRedrawed.  secondSome := self find: TextMorph in: self treeVisibleItems seventh.  self assert: secondSome text asString equals: '3'height: anObject  vState := self vState onMyselfDo: [:s |  s dimension: anObject ]borderWidth  ^self border widthenabled  ^truefontSize  ^self label fontSizetransformedEntity  ^transformedEntityupdateFoundationBounds  self owner ifNotNil: [:o |  o isFoundationBrick ifTrue: [ self doNotLayoutDuring: [ o isVShrinking | o isHShrinking ifTrue: [ o privateExtent: self outerBounds extent ] ] ] ]send: treeMorph mouseUpWithShift: aBoolean onItem: treeNodeMorph  | mouseUp |  mouseUp := MouseButtonEvent basicNew setType: #mouseUp position: treeNodeMorph bounds origin + (1 @ 1) which: 4 buttons: (aBoolean ifTrue: [ 8 ] ifFalse: [ 0 ]) hand: (HandMorph new           mouseFocus: treeNodeMorph;           yourself) stamp: nil.  treeMorph listManager mouseUp: mouseUp on: treeNodeMorphtestRemovePage  tabs removePage: tabs pages first.  self assert: tabs pages size equals: 1normalBackgroundStyleFor: aBrick  ^self theme tabLabelNormalFillStyleFor: aBrickgtInspectorPortsIn: composite  < gtInspectorPresentationOrder: 30>  ^composite table     title: 'Ports';     display: [ self ports ];     column: 'Port' evaluated: [:each |  each name ];     column: 'Value' evaluated: [:each |  each value asString ]cachedMatchingPresentations  ^cachedMatchingPresentations ifNil: [ cachedMatchingPresentations := self matchingPresentations ]render: aBrick on: aCanvas  self     renderShadowOf: aBrick on: aCanvas;     renderBackgroundColorOf: aBrick on: aCanvas;     renderBorderOf: aBrick on: aCanvastestWithPresentation  | browser dynamic text textMorph |  browser := GLMTabulator new     column: #stacker;     yourself.  browser transmit     to: #stacker;     andShow: [:c |  c dynamic presentation: [:presentation :number |  presentation text display: [ 'All ' , number asString ] ] ].  window := browser openOn: 10.  dynamic := browser panes first presentations first.  text := dynamic cachedPresentation first.  textMorph := self findWherePresentationIs: text in: window.  self assert: textMorph text asString equals: 'All 10'= anObject  ^self species = anObject species and: [ self item = anObject item ]contextClass  ^contextClasscheckedIcon: aForm  checkedIcon := aFormresetChildrenContents  self roots do: [:each |  each resetContentsRecursively ]buttonBackgroundColor  ^Color veryVeryLightGray lighternoTestAcceptKeyCanBeOverriden  | composite textMorph overriden shortcut |  overriden := false.  composite := GLMCompositePresentation new with: [:a |  a text act: [:text |  overriden := true ] on: $s entitled: 'Override' ].  window := composite openOn: '4'.  textMorph := self find: RubScrolledTextMorph in: window.  self simulateOnlyOneClickOn: textMorph.  (Delay forMilliseconds: HandMorph doubleClickTime + 1) wait.  self assert: ActiveHand keyboardFocus equals: textMorph textArea.  shortcut := $s meta asKeyCombination.  textMorph textArea handleKeystroke: (KeyboardEvent new setType: #keystroke buttons: shortcut modifier eventCode position: textMorph textArea center keyValue: shortcut key asciiValue charCode: shortcut key asciiValue hand: nil stamp: DateAndTime now).  self assert: overridenrenderShadowOf: aBrick on: aCanvas  | anArea aCurrentVector aFirstVector anOrigin |  aBrick shadowWidth = 0 ifTrue: [ ^self ].  anArea := aBrick area.  aFirstVector := aBrick area vector.  aCurrentVector := aFirstVector.  anOrigin := aBrick area origin.  [ aCurrentVector next ~= aFirstVector ] whileTrue: [ self renderShadow: aBrick vector: aCurrentVector origin: anOrigin on: aCanvas.        self renderCornerShadow: aBrick vector: aCurrentVector origin: anOrigin on: aCanvas.        anOrigin := aCurrentVector + anOrigin.        aCurrentVector := aCurrentVector next ].  self renderShadow: aBrick vector: aCurrentVector origin: anOrigin on: aCanvas.  self renderCornerShadow: aBrick vector: aCurrentVector origin: anOrigin on: aCanvas.  aCanvas drawPolygon: (anArea vertices collect: [:each |  each + aBrick shadowOffset ]) color: aBrick shadowColor borderWidth: 0 borderColor: Color transparentannouncer  ^super announcerselectPreviousTab  self selectedIndex: (self selectedIndex < 2 ifTrue: [ self tabs size ] ifFalse: [ self selectedIndex - 1 ])vSpaceFill: anInteger  < brickBuilderProperty: #Layout name: 'Vertical percent' as: #asInteger getter: #vPercent model: #GLMUIBuilderTextFieldProperty>  self layout vSpaceFill: anIntegerisWithElementIndex  ^self parameters at: 'withRowIndex' ifAbsent: [ false ]printString  ^collection printStringaddTab: aStringOrMorph  self tabs add: (self newLabelBrick: aStringOrMorph).  self updateTabspresentation: anObject  presentation := anObjectinitialize  super initialize.  lastScrollTimeStamp := 0.  self useVerticalLinearLayout.  self band: self newBand.  self verticalScrollbar: self newVerticalScrollbar.  self initializeListenerstabbedArrangement  ^self arrangement: GLMTabbedArrangement newsend: treeMorph mouseDownWithShift: aBoolean onItem: treeNodeMorph  | mouseUp |  mouseUp := MouseButtonEvent basicNew setType: #mouseDown position: treeNodeMorph bounds origin + (1 @ 1) which: 4 buttons: (aBoolean ifTrue: [ 8 ] ifFalse: [ 0 ]) hand: (HandMorph new           mouseFocus: treeNodeMorph;           yourself) stamp: nil.  treeMorph mouseUp: mouseUp onMorph: treeNodeMorphvariableSizePanes  self hasFixedSizePanes: falseinitialize  super initialize.  morphBuilder := [:thisPresentation :theDisplayValue |  theDisplayValue asMorph ]outOfWorld: aWorld  super outOfWorld: aWorld.  self unsubscribeListenersstyle  ^stylelayout  ^self brick layoutPropertiesprivateSetText: aString  text := aString asString.  textSize := nilpassivelyFrom: anOriginPortReference  self lastTransmission addPassiveOrigin: (self resolveOriginPort: anOriginPortReference)testUnregisterAnnouncements  | announcer presentation |  announcer := Announcer new.  presentation := GLMPresentation new.  presentation updateOn: GLMTestAnnouncement from: [ announcer ].  presentation registerAnnouncements.  self assert: announcer numberOfSubscriptions equals: 1.  presentation unregisterFromAllAnnouncements.  self assert: announcer numberOfSubscriptions equals: 0diff  ^self custom: GLMDiffPresentation newtestEmptyPopPane  | count |  count := 0.  pagerModel announcer when: GLMPagePoped do: [:ann |  count := count + 1 ].  pagerModel popPane.  self assert: count equals: 0.  self assert: pagerModel size equals: 0.  self assert: pagerModel firstVisiblePageIndex equals: 0.  self assert: pagerModel lastVisiblePageIndex equals: 0.  self assert: pagerModel numberOfVisiblePages equals: 2.  pagerModel popPane.  pagerModel popPane.  self assert: count equals: 0paddingLeft  ^self brick paddingLeftstepTime  ^stepTime ifNil: [ super stepTime ]testLastActivePresentation  | browser |  browser := GLMFinder new.  browser show: [:a |  a list title: 'a'.        a text title: 'b'.        a table title: 'c' ].  browser startOn: 1.  self assert: browser lastActivePresentation isNil.  (browser panes first port: #selection) value: 2.  self assert: browser lastActivePresentation isNil.  browser panes last lastActivePresentation: browser panes last presentations last.  self assert: browser lastActivePresentation equals: browser panes last presentations last.  (browser panes first port: #selection) value: 3.  self assert: browser panes last lastActivePresentation title equals: 'c'testOnChangeOfPortAct  | pane presentation timesTriggered |  pane := GLMPane named: 'test'.  presentation := GLMPresentation new.  pane addPresentation: presentation.  timesTriggered := 0.  presentation onChangeOfPort: #test act: [ timesTriggered := timesTriggered + 1 ].  (pane port: #test) value: 42.  self assert: timesTriggered equals: 1staticWidth  ^100 * self currentWorld displayScaleFactorpopupThemer  ^self registerModule: GLMActionBrickPopupThemer newwidthBottom: anInteger  self width at: Bottom put: anIntegericonBrick: anObject  iconBrick := anObjectchildrenBlock: aBlock  childrenBlock := aBlockiconFor: anElement  ^self cacheAt: #icon for: anElement ifAbsentPut: [ self glamourPresentation icon cull: anElement ]testSurroundingPanel  | browser dynamicContainerMorph |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a dynamic presentation: [:some :object |  some text ] ].  window := browser openOn: 4.  dynamicContainerMorph := window submorphs last submorphs first submorphs first.  self assert: (dynamicContainerMorph isKindOf: PanelMorph).  self assert: (dynamicContainerMorph submorphs first isKindOf: RubScrolledTextMorph)isWidthCustom  ^self hState isOnMyselftestFixedSize  | browser |  browser := GLMFinder new.  self assert: browser hasFixedSizePanes.  browser hasFixedSizePanes: false.  self assert: browser hasFixedSizePanes nottestAdd  entity add: 4.  announcer announce: GLMTestAnnouncement.  self assert: listMorph roots size equals: 4.  self assert: listMorph model roots size equals: 4.  self assert: treeMorph roots size equals: 4.  self assert: treeMorph model roots size equals: 4.  self assert: tableMorph roots size equals: 4.  self assert: tableMorph model roots size equals: 4.  self assert: labelMorph contents equals: '4'scrollBrick: aBrick  scrollBrick := aBrick.  self scrollBrick pagerModel: pagerModel.  self scrollBrick     vSpaceFill;     hSpaceFill.  self addBrickBack: self scrollBricksetUp  super setUp.  tabs := LazyTabGroupMorph new.  tabs addLazyPage: (PanelMorph new fillStyle: (SolidFillStyle color: Color red)) label: 'one'.  tabs addLazyPage: (PanelMorph new fillStyle: (SolidFillStyle color: Color yellow)) label: (GLMLabelBrick new text: 'two').  window := tabs openInWindowmargin: aCollection  < brickBuilderProperty: #Geometry name: 'Margin' as: #brickBuilderEvaluate getter: #margin model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds margin: aCollectionchildrenValueOf: anObject atLevel: anInteger  ^self children glamourValue: anObject asGlamorousMultiValue , self entity asGlamorousMultiValue , anInteger asGlamorousMultiValue , self asGlamorousMultiValueaddRow: aBlockOrSymbol  ^self cellOrColumn addRow: aBlockOrSymboltextPosition  ^self label textPositiontestOneReplacePane  pagerModel popAndReplacePane: self createSimplePaneMorph.  self assert: pagerModel size equals: 1.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 1.  self assert: pagerModel numberOfVisiblePages equals: 2pagerModel  ^pagerModeltestBottomMarginParentDependency  | root margin brick |  margin := 10.  root := self newBrickWithStaticExtent.  brick := self newBrickFullHeightAndWidthDependsOnParent: 100.  brick marginBottom: margin.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticExtent - (0 @ margin).  self assert: brick brickBounds equals: (0 @ 0 corner: self staticExtent - (0 @ margin))testTabsWithActions  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list act: #inspect entitled: 'Inspect'.        a text ].  window := browser openOn: 42.  self denyEmpty: self compositeTabGroup toolbarMorph submorphs.  self compositeTabGroup selectedPageIndex: 2.  self assertEmpty: self compositeTabGroup toolbarMorph submorphs.  self compositeTabGroup selectedPageIndex: 1.  self denyEmpty: self compositeTabGroup toolbarMorph submorphslogger: anObject  logger := anObjectcellColumn: column row: rowIndex  | element cell |  element := self elementAt: rowIndex.  cell := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForElement: element);     yourself.  (self needSeparatorBefore: rowIndex) ifTrue: [ cell withTopSeparator ].  ^cellcolor  ^self registerModule: GLMBrickColorThemer newlayout: aLayout  < brickBuilderProperty: #Layout name: 'Orientation' as: #brickBuilderLayout getter: #layoutPolicy model: #GLMUIBuilderTextFieldProperty>  self layoutPolicy: aLayoutbounds: aRectangle  self updateState: aRectangle.  self brickBounds: aRectanglewidthParentDependency: aBrick  ^self subclassResponsibilitycomputeTagsFilterFor: aGlamourValue  ^self computeTagsFor: aGlamourValue from: self tagsFilterBlockassertWidthClean: aBrick  self assert: aBrick wrappedBounds widthState equals: #clean.  self assert: aBrick wrappedBounds isWidthDirty not.  self assert: aBrick wrappedBounds isWidthCleaninitialize  super initialize.  logger := GLMLogger instancetagsToFilterBy  ^tagsToFilterBy ifNil: [ tagsToFilterBy := OrderedCollection new ]hideFromWorld  self deleteheaderBrick: aBrick  headerBrick := aBrick.  self headerBrick hSpaceFill.  self addBrickFirst: self headerBrickoldPage  ^oldPageborderDo: aBlock  aBlock cull: self border.  ^selfvelocity: anInteger  velocity := anIntegercontentPadding  ^0testEntityPortInitialization  | pane presentation |  pane := GLMPane named: 'test'.  presentation := GLMPresentation new initialize: [:pres |  pres entity: 2 ].  pane addPresentation: presentation.  self assert: presentation entity equals: nil.  presentation initializePresentation.  self assert: (pane port: #entity) value equals: 2.  self assert: presentation entity equals: 2width: widths  widths ifNil: [ ^self width: #(0) ].  widths isCollection ifTrue: [ widths isEmpty ifTrue: [ ^self width: #(0) ].        self           widthTop: (widths at: 1);           widthRight: (widths at: 1);           widthBottom: (widths at: 1);           widthLeft: (widths at: 1).        widths size > 1 ifTrue: [ self                 widthRight: (widths at: 2);                 widthLeft: (widths at: 2) ].        widths size > 2 ifTrue: [ self widthBottom: (widths at: 3) ].        widths size > 3 ifTrue: [ self widthLeft: (widths at: 4) ] ] ifFalse: [ ^self width: {widths} ]isRow  ^trueonCreated: aBlock  onCreatedBlock := aBlockpopulate: aPortSymbol iconName: aSymbol entitled: aString with: aBlock  self populate: aPortSymbol icon: (self iconNamed: aSymbol) entitled: aString with: aBlockhasChanged  ^self value ~~ self oldValueoriginatesAt: aPort  ^(self activeOrigins includes: aPort) and: [ self meetsCondition ]sendersOfIt  self announce: (GLMTextEditorRequest for: #sendersOfIt)isMorphBrick  ^falsesetLabelOf: aWindow for: aRenderable  textPosition: aSymbol  textPosition := aSymbolnoTestEnteringTextInPort  | composite textMorph |  composite := GLMCompositePresentation new with: [:a |  a text display: '' ].  window := composite openOn: 4.  textMorph := self find: RubScrolledTextMorph in: window.  self simulateOnlyOneClickOn: textMorph.  self simulateKeyStrokes: 'hello'.  self assert: (composite pane port: #text) value asString equals: 'hello'width  ^self brickBounds widthhasTagsFilter  ^self tagsFilterBlock notNiluseExplicitAllNil  implicitAllNil := trueactOnPresentationUpdated: ann  self setLabelOf: window for: ann presentationbuttonLabel  ^self glamourAction titlelabelBrick: anObject  labelBrick := anObject.  self label     vShrinkWrap;     hShrinkWrap;     text: 'button';     textPosition: #center;     vAlign: #center;     hAlign: #center.  self addBrickBack: self labeltestCreation  | anEvent portOne portTwo |  portOne := GLMSimplePort new     name: #portOne;     value: 1.  portTwo := GLMSimplePort new     name: #portTwo;     value: 2.  anEvent := GLMPortEvent on: portOne previouslyValued: portTwo.  self assert: anEvent port equals: portOne.  self assert: anEvent oldValue equals: portTwo.  self assertEmpty: anEvent transmissionContextisBrick  ^self brick isBrickdrawKeyboardFocusOnAthensCanvas: anAthensCanvas  layoutChanged  normalBorderColor  ^self color silveropenWith: aRenderer  ^aRenderer open: selfgtInspectorTransmissionsIn: composite  < gtInspectorPresentationOrder: 35>  ^composite list     title: 'Transmissions';     display: [ self transmissions ]printOn: aStream  aStream nextPutAll: 'a NodeModel with '.  aStream nextPutAll: self item printStringcolumn: aGlamourColumn valueFor: anObject  ^aGlamourColumn computation glamourValue: anObject asGlamorousMultiValue , self entity asGlamorousMultiValue , self asGlamorousMultiValuerenderRubricTextPresentation: aPresentation  ^GLMMorphicRubricTextRenderer render: aPresentation from: selfcolumn: aGlamourColumn valueFor: anObject  ^aGlamourColumn computation glamourValue: anObject asGlamorousMultiValue , self entity asGlamorousMultiValue , self asGlamorousMultiValueheaderMorph  ^headerMorphpresentation: aBlock  self presentationTransformation: aBlockpresentationsFactory: anObject  presentationsFactory := anObjectlayoutPolicy  ^super layoutPolicywasTransmited  ^wasTransmitedheightParentDependency: aBrick  ^self subclassResponsibilityactOnPaneRemoved: ann  container removeMorph: container submorphs last.  container removeMorph: container submorphs lasttestDiminishToRight  | counter right |  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  counter := pagerModel defaultNumberOfVisiblePages.  right := pagerModel lastVisiblePageIndex.  self assert: pagerModel numberOfVisiblePages equals: counter.  self assert: pagerModel numberOfVisiblePages equals: right - pagerModel firstVisiblePageIndex + 1.  self assert: pagerModel lastVisiblePageIndex equals: right.  [ counter > 1 ] whileTrue: [ pagerModel diminishToRight.        counter := counter - 1.        self assert: pagerModel numberOfVisiblePages equals: counter.        self assert: pagerModel numberOfVisiblePages equals: right - pagerModel firstVisiblePageIndex + 1.        self assert: pagerModel lastVisiblePageIndex equals: right ].  (1 to: 3) do: [:i |  pagerModel diminishToRight.        self assert: pagerModel numberOfVisiblePages equals: 1.        self assert: pagerModel numberOfVisiblePages equals: right - pagerModel firstVisiblePageIndex + 1.        self assert: pagerModel lastVisiblePageIndex equals: right ]testPresentationConditions  | pane presentation1 presentation2 presentation3 |  pane := GLMPane named: 'test'.  presentation1 := GLMPresentation new condition: [:first :second |  first = 1 and: [ second = 2 ] ].  presentation2 := GLMPresentation new condition: [:first |  first = #foo ].  presentation3 := GLMPresentation new useExplicitNotNil.  pane addPresentation: presentation1.  pane addPresentation: presentation2.  pane addPresentation: presentation3.  (pane port: #entity) value: (GLMMultiValue withAll: #(1 2)).  self assert: pane matchingPresentations size equals: 2.  self assert: pane matchingPresentations first identicalTo: presentation1.  self assert: pane matchingPresentations last identicalTo: presentation3.  (pane port: #entity) value: (GLMMultiValue withAll: #(#foo 2)).  self assert: pane matchingPresentations size equals: 2.  self assert: pane matchingPresentations first identicalTo: presentation2.  self assert: pane matchingPresentations last identicalTo: presentation3.  (pane port: #entity) value: (GLMMultiValue withAll: #(nil 2)).  self assert: pane matchingPresentations size equals: 1testDefaultValidate  | pane |  pane := GLMPane named: 'test'.  self assert: ((pane port: #selection) validate: 5)step  self window ifNil: [ ^self ].  self window isActive ifFalse: [ ^self ].  (self wantsSteps and: [ self model shouldDoStep ]) ifFalse: [ ^self ].  (self window boundsInWorld containsRect: self boundsInWorld) ifFalse: [ ^self ].  self model updateRoots.  self updateListexecute: anArguments  ^self execute: self task withArguments: anArguments callback: self callback priority: self priority delay: self delayaddContent: aBlockWhoseValueReturnsAMorph  | newMorph |  process ifNotNil: [ process terminate ].  process := nil.  process := [ newMorph := aBlockWhoseValueReturnsAMorph value.  WorldState addDeferredUIMessage: [ self contentsMorph           removeAllMorphs;           addMorph: newMorph fullFrame: LayoutFrame identity ] ] newProcess.  process priority: Processor userBackgroundPriority.  process resumehasBindingThatBeginsWith: aString  ^self variableBindings keys anySatisfy: [:each |  each beginsWith: aString ]notingPresentationChangeDo: aBlock  | oldPresentations oldMatchingPresentations |  self isAllowedToNotePresentationsChanged ifFalse: [ aBlock value.        ^self ].  allowedToNotePresentationsChanged := false.  oldPresentations := presentations presentations copy.  oldMatchingPresentations := self cachedMatchingPresentations.  aBlock value.  presentations presentations ~= oldPresentations ifTrue: [ self announce: (GLMPresentationsChanged new                 pane: self;                 oldPresentations: oldPresentations;                 yourself) ].  self matchingPresentations ~= oldMatchingPresentations ifTrue: [ self announce: (GLMMatchingPresentationsChanged new                 pane: self;                 oldMatchingPresentations: oldMatchingPresentations;                 yourself) ].  allowedToNotePresentationsChanged := trueupdateWidth: aBrick on: aLayout  aBrick withWidth: (aLayout normalizeWidth: (aLayout widthMyselfDependency: aBrick) of: aBrick)cellOrColumn  ^cell ifNil: [ cell := GLMCustomColumn new browser: self ]compositeTabGroup  | composite |  composite := self compositeMorph.  self assert: (composite isKindOf: LazyTabGroupMorph).  ^compositelabelBrick: aBrick  labelBrick := aBrick.  self labelBrick textPosition: #leftCenter.  self addBrickBack: labelBricktranslateBy: aPoint  self wrappedBounds translateBy: aPointmorph  ^morphassertAllSubbricksAreClean: aBrick  aBrick withAllSubbricks do: [:each |  self assertBrickClean: each ]acceptAction: anAction  self flag: #TODO.  self model ifNotNil: [:aModel |  aModel acceptAction: anAction ]updateMorphBounds  self withAllSubbricks select: #isMorphBrick thenDo: #onLayoutedallowNil  ^self useExplicitNotNilcollect: aBlock  ^collection collect: aBlockforbidToAnnounceMatchingPresentationsChanged: aPane  self forbid: aPane toAnnounce: GLMMatchingPresentationsChangedtheme  ^UITheme currenttestFinderWithPreviousPort  < expectedFailure>  | browser |  browser := GLMFinder new.  browser show: [:a |  a list           title: 'Presentation1';           display: [:each |  1 to: each ] ].  browser     fromPrevious: #selection;     passivelyFromPrevious: #highlight;     andShow: [:a |  a list           title: 'Presentation2';           display: [:selection :highlight |  1 to: selection + highlight ] ].  browser startOn: 42.  self assert: browser panes first presentations size equals: 1.  self assert: browser presentations first title equals: 'Presentation1'.  self assert: browser transmissions size equals: 1.  self assert: browser transmissions last origins size equals: 2.  self assert: browser transmissions last transmissionStrategy presentations size equals: 1.  self assert: browser transmissions last transmissionStrategy presentations first title equals: 'Presentation2'.  self assert: (browser panes first port: #entity) value equals: 42.  (browser panes first port: #highlight) value: 43.  (browser panes first port: #selection) value: 41.  self assert: browser panes size equals: 2.  self assert: browser panes last presentations size equals: 2.  self assert: browser panes last presentations last displayValue size equals: 84.  self assert: browser panes last presentations size equals: 2shoutAboutToStyle: aPluggableShoutMorph  self highlightSmalltalk ifFalse: [ ^false ].  self highlightSmalltalkContext notNil ifTrue: [ aPluggableShoutMorph classOrMetaClass: self highlightSmalltalkContext ].  ^truedata: anObject  ^self setProperty: #brickDataObject toValue: anObjectselection: aSelection  self selection = aSelection ifTrue: [ ^self ].  super selection: aSelection.  self announcer announce: (GLMTreeMorphSelectionChanged new           selectionValue: (aSelection ifNotNil: [ aSelection selectedItemOrItemsOrNil ]);           selectionPathValue: self selectionPathItems;           yourself)markHeightDirty  self heightState: #dirtywhen: anAnnouncementClass do: aBlock  self announcer when: anAnnouncementClass do: aBlockhasSubbrick: aBrick  ^aBrick owner = selfmarkButtonsInside: aBounds  | index boundsLeft boundsRight firstFound lastFound |  self flag: 'refactor me'.  firstFound := false.  lastFound := false.  index := 0.  pagerModel size = 0 ifTrue: [ ^self ].  boundsLeft := aBounds x.  boundsRight := aBounds y.  self buttons do: [:indicator |  index := index + 1.        (self isScrollMustBeChecked: index withLeft: boundsLeft andRight: boundsRight) ifTrue: [ indicator check.              firstFound ifFalse: [ pagerModel virtualFirstVisiblePageIndex: index.                    firstFound := true ] ] ifFalse: [ indicator isFocused ifFalse: [ indicator uncheck ].              firstFound & (lastFound = false) ifTrue: [ pagerModel virtualLastVisiblePageIndex: index - 1.                    lastFound := true ] ] ].  lastFound ifFalse: [ pagerModel virtualLastVisiblePageIndex: index.        lastFound := true ]titleValueOfColumn: aColumn  ^aColumn title glamourValue: self entitydynamicActions: aBlock  dynamicActionsBlock := aBlocktagMorphsFrom: aTagProvider for: element  | tagMorphs tags tagsFilter |  tagMorphs := OrderedCollection new.  tags := self glamourPresentation tagsFor: element fromProvider: aTagProvider to: #show.  tagsFilter := self glamourPresentation tagsFor: element fromProvider: aTagProvider to: #filter.  tags withIndexDo: [:each :index |  tagMorphs addLast: (self buttonForTag: each filter: (tagsFilter at: index ifAbsentPut: [ each ])) ].  ^tagMorphstestWithBlockPassesTheParentPresentation  | p presentationInWithBlock |  p := GLMPresentation new.  p with: [:thePresentation |  presentationInWithBlock := thePresentation ].  self assert: presentationInWithBlock identicalTo: psmalltalkClassLogic  ^self valueOfProperty: #phlowSmalltalkClass ifAbsent: [ #yourself ]showScrollBarWhenNeeded: aBoolean  showScrollBarWhenNeeded := aBooleanuseCache  self parameters at: 'shouldUseCache' put: trueallMenuActions  ^self glamourPresentation allSelectionActions select: [:action |  action hasTitle ]passivelyFromPrevious: aPortSymbol  self flag: 'needs revisiting. it does not work anymore'.  self scriptTransmission addPassiveOrigin: (GLMPort new name: aPortSymbol)isInsideOfPopupBrick: anEvent  ^(self isInsideOfTriggerBrick: anEvent) | (self isInsideOfContentBrick: anEvent)column: aBlockOrString evaluated: aBlock width: aNumber  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           width: aNumber;           yourself)isRightResizingZone: evt  | resizingRectangle top left globalBounds |  globalBounds := self globalBounds.  top := globalBounds top.  left := globalBounds right - resizingZoneWidth.  resizingRectangle := left @ top corner: globalBounds corner.  ^resizingRectangle containsPoint: evt positionexpandParentPath  self containerTree expandNodePath: self pathdefaultBottomMargin  ^11registerAnnouncements  self flag: 'The announcements should potentially be interested in any ports, not just in entity'.  updateActions do: [:each |  each registerInPresentation ]setTitle: aString  self titleBrick text: aString.  titleBrick height: (aString isEmpty | aString isNil ifFalse: [ 30 ] ifTrue: [ 0 ])entity  ^entitycopyAccordingToPaneMapping: newPanesMapping inNewBrowser: anotherBrowser  ^(newPanesMapping at: self pane) port: self nametestDefaultPresentation  | dynamic |  dynamic := GLMDynamicPresentation new.  dynamic entity: 42.  dynamic transformation: [:entity |  GLMRubricTextPresentation new ].  self assert: dynamic currentPresentation presentations size equals: 1.  self assert: (dynamic currentPresentation presentations first isKindOf: GLMRubricTextPresentation).  self assert: dynamic currentPresentation pane identicalTo: dynamic panecontentBackgroundColor  ^self theme backgroundColoradoptPaneColor: paneColor  self assureExtension.  extension fillStyle ifNil: [ self color: paneColor ].  self borderStyle baseColor: paneColor darker.  self submorphsDo: [:m |  m adoptPaneColor: paneColor ]testMinHeightTwoParentDependencies  | root brick1 brick2 height |  height := 80.  root := self newBrickWithStaticExtent.  root useVerticalLinearLayout.  brick1 := self newBrickWithFullFill.  brick1 vSpaceFill: 50.  brick1 minHeight: height.  brick2 := self newBrickWithFullFill.  root addAllBricks: {brick1 .         brick2}.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick1 extent equals: self staticWidth @ height.  self assert: brick2 extent equals: self staticWidth @ (self staticHeight - height)testDisplay  | presentation |  presentation := GLMPresentation new.  presentation entity: #foo.  self assert: presentation displayValue equals: #foo.  presentation entity: #(#foo #bar).  self assert: presentation displayValue equals: #(#foo #bar).  presentation entity: (GLMMultiValue withAll: #(#foo #bar)).  self assert: presentation displayValue equals: #foo.  presentation transformation: [:first :second |  (first , second) asSymbol ].  self assert: presentation displayValue equals: #foobaractOnPaneAdded: ann  self subclassResponsibilityexplicitlySelectMultipleItems: aCollection  | newSelection collection |  aCollection ifNil: [ ^self ].  collection := aCollection isCollection ifTrue: [ aCollection ] ifFalse: [ aCollection asOrderedCollection ].  (self selection notNil and: [ self selection selectedItemOrItemsOrNil = collection asOrderedCollection ]) ifTrue: [ ^self ].  newSelection := OrderedCollection new.  self roots do: [:eachRoot |  eachRoot withContentsDo: [:each |  (collection includes: each item) ifTrue: [ newSelection add: each path ] ] ].  self selectAllNodePaths: newSelectionmarginLeft  ^self wrappedBounds marginLeftcollapsableFor: anObject  | collapsable |  collapsable := GLMCollapsableBrick new.  collapsable     vShrinkWrap;     hSpaceFill.  collapsable headerBrick: (self headerFor: anObject in: collapsable).  (self hasChildren: anObject) ifTrue: [ collapsable contentBrick: (self class new on: anObject value).        collapsable contentBrick           vShrinkWrap;           hSpaceFill;           marginLeft: 19 ].  collapsable expand.  ^collapsableisHShrinkWrap  ^self hState isOnChildrenrightAngle: aDirection  ^aDirection = GLMSouthDirection uniqueInstanceexportToCSV  FileSystem workingDirectory / 'table-export.csv' writeStreamDo: [:stream |  self columns do: [:column |  stream                 nextPut: $";                 nextPutAll: (self titleValueOfColumn: column);                 nextPut: $" ] separatedBy: [ stream nextPut: $, ].        stream cr.        self displayValue do: [:each |  self columns do: [:column |  stream                       nextPut: $";                       nextPutAll: (self column: column valueFor: each) asString;                       nextPut: $" ] separatedBy: [ stream nextPut: $, ].              stream cr ] displayingProgress: 'Exporting' ]pushPane: aMorph  aMorph     borderWidth: 0;     hResizing: #spaceFill;     vResizing: #spaceFill;     layoutInset: 0.  transform hasSubmorphs ifTrue: [ transform addMorphBack: self separator ].  transform addMorphBack: (aMorph adoptPaneColor: self paneColor).  paneCount := paneCount + 1.  self updatePanesgtDisplayOn: stream  self hasTitle ifTrue: [ stream           nextPutAll: self title;           space ].  self hasShortcut ifTrue: [ self keymap gtDisplayOn: stream.        stream space ].  self action gtDisplayOn: streampaddingRight: anObject  < brickBuilderProperty: #Geometry name: 'Padding Right' as: #asInteger getter: #paddingRight model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds paddingRight: anObjectopen: aRenderable  window := GLMMorphicWindowRenderer render: aRenderable from: self.  ^window openInWorldpopupErrorThemer  ^self registerModule: GLMBrickPopupErrorThemer new to: self named: #popupThemeractOnPresentationRefreshRequest: anAnnouncement  tableMorph window ifNil: [ ^self ].  tableMorph window isActive ifFalse: [ ^self ].  (tableMorph window boundsInWorld containsRect: tableMorph boundsInWorld) ifFalse: [ ^self ].  tableModel resetDataCache.  tableMorph refreshwidthTraverser  ^GLMBrickWidthTraverser uniqueInstanceopenOn: anObject inExternalWindowWith: aRenderer  self startOn: anObject.  ^aRenderer openInExternalWindow: selfcolumn: aBlockOrString evaluated: aBlock sortedBy: aSortingBlock  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           sortBlock: aSortingBlock)dataCacheFor: anElement  ^self dataCache at: anElement ifAbsentPut: [ Dictionary new ]hAlign: aSymbol  hAlign := aSymbolclose  self announce: GLMBrowserClosed new* aNumber  < return: #Point>  ^aNumber @ 0widthState  ^widthState ifNil: [ widthState := #dirty ]pane  ^panetext  ^self custom: GLMRubricTextPresentation newexecute  self glamourAction actOn: self glamourPresentationallowsRecursiveSearch  ^allowsRecursiveSearch ifNil: [ allowsRecursiveSearch := true ]selectedIndex: index  selectedIndex := indexshadowWidth: anInteger  < brickBuilderProperty: #'Look&Feel' name: 'Shadow Width' as: #asInteger getter: #shadowWidth model: #GLMUIBuilderTextFieldProperty>  self setProperty: #brickShadowWidth toValue: anIntegervalueOfProperty: aSymbol  ^super valueOfProperty: aSymbollayoutPolicy: aBrick on: aTraverser  ^(aBrick owner ifNil: [ aBrick ] ifNotNil: [:owner |  owner isBrick ifTrue: [ owner ] ifFalse: [ aBrick ] ]) layoutPolicyscrollTo: aValue smooth: isSmooth  self scrollTo: aValue smooth: isSmooth callback: nilisFoundationBrick  ^trueaction: anObject  action := anObjecttestMaxHeightOneStatic  | brick |  brick := self newBrickWithStaticExtent.  brick maxHeight: self staticSmallHeight.  brick doLayoutForce.  self assertAllSubbricksAreClean: brick.  self assert: brick brickBounds equals: (0 @ 0 extent: self staticWidth @ self staticSmallHeight)pageIndex  ^pageIndextestToRawSelection  | presentation |  presentation := GLMPresentation new.  presentation selection: 1.  self assert: presentation selection equals: 1.  self assert: presentation rawSelection equals: 1.  presentation selectionTransformation: [:num |  num + 1 ].  presentation selection: 1.  self assert: presentation selection equals: 2.  self assert: presentation rawSelection equals: 1translateY: anObject  ^self brick translateY: anObjectbeNormal  self removeAllBricks.  self addBrickBack: self normalLabel.  self themer tabLabelThemer normalStyleFor: self.  self changedicon  ^self containerTree glamourPresentation iconFor: self itemaction: aBlockClosure  self     when: #onChecked do: [:anAnnouncement :anAnnouncer |  aBlockClosure cull: true cull: self cull: anAnnouncement cull: anAnnouncer ];     when: #onUnchecked do: [:anAnnouncement :anAnnouncer |  aBlockClosure cull: false cull: self cull: anAnnouncement cull: anAnnouncer ]indexOf: anElement  ^collection indexOf: anElementglamourExpander: anObject  glamourExpander := anObjectfullBounds  ^self globalBoundswhenKindOf: aClass  self when: [:each |  each isKindOf: aClass ]filterBlock  ^filterBlockcancelOnFocusLost  cancelOnFocusLost := truedrawingBounds  ^self renderer drawingBounds: selfprintOn: aStream  super printOn: aStream.  aStream     nextPutAll: ' (presentation = ';     nextPutAll: self presentation printString;     nextPutAll: ', property = #';     nextPutAll: self property;     nextPutAll: ', oldValue = ';     nextPutAll: self oldValue gtDisplayString;     nextPutAll: ', value = ';     nextPutAll: self value gtDisplayString;     nextPutAll: ')'shouldFilterByTag: aTag  ^self tagsToFilterBy includes: aTagtestOnlyOneMorphPerRowInList  | browser listMorph nodeMorphs |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list display: [:x |  x ] ].  window := browser openOn: (1 to: 100).  self waitUntilUIRedrawed.  listMorph := self find: MorphTreeMorph in: window.  nodeMorphs := (self find: MorphTreeTransformMorph in: listMorph) submorphs.  self assert: nodeMorphs size equals: 100.  nodeMorphs do: [:node |  self assert: node submorphs size equals: 1 ]beHelp  self themer: self themer popupHelpThemer themerpaddingLeft  ^self padding at: LeftaddBrickBack: aBrick  | link |  link := aBrick asDoubleLink.  aBrick brickDoubleLink: link.  self hasSubbricks ifTrue: [ self lastSubbrick brickDoubleLink nextLink: link.        link previousLink: self lastSubbrick brickDoubleLink ].  self privateSubbricks: (self subbricks copyWith: aBrick).  aBrick privateOwner: selfnewButtonsBrick  ^GLMPagerButtonsPaneBrick newsuspendedAnnouncements  ^OrderedCollection with: GLMTreeMorphSelectionChanged with: GLMTreeMorphStrongSelectionChanged with: GLMMenuItemSelected with: GLMKeyStrokeresetValue  | context |  context := GLMTransmissionContext new.  context addPort: self.  self changeValueTo: nil in: contextcomputation: anObject  computation := anObjecttabSelector: anObject  tabSelector := anObjectfindWherePresentationIs: aPresentation in: aMorph  ^self findSatisfying: [:morph |  morph model notNil and: [ (morph model respondsTo: #glamourPresentation) and: [ morph model glamourPresentation == aPresentation ] ] ] in: aMorphglamourPresentation  ^glamourPresentationoldPresentations  ^oldPresentationsinitializeOn: aPort previouslyValued: anObject in: aTransmissionContext  port := aPort.  oldValue := anObject.  transmissionContext := aTransmissionContextisPaneVisible: aNumber  ^aNumber >= self firstVisiblePageIndex & (aNumber <= self lastVisiblePageIndex)handlePotentialStatusbarFor: aRenderable  | statusbarMorph bottomOffset |  bottomOffset := 0.  aRenderable hasStatusbar ifTrue: [ statusbarMorph := GLMMorphicPaneWithoutTitleRenderer render: aRenderable statusbarPane from: self renderer.        bottomOffset := (0 - (LabelMorph contents: 'XXX') minHeight) * 1.2.        window addMorph: statusbarMorph fullFrame: (LayoutFrame identity                 topFraction: 1;                 leftOffset: 2;                 topOffset: bottomOffset;                 rightOffset: -2) ].  ^bottomOffsetrawSelectionTransmissionFor: aPortSymbol ifNone: ifNoneBlock  ^rawSelectionTransmissions detect: [:transmission |  transmission destination port name = aPortSymbol ] ifNone: ifNoneBlockdoLayoutForce  self wrappedBounds     markHeightDirty;     markWidthDirty.  self doLayouthash  ^self port hashgtDisplayOn: stream  self origins asArray gtDisplayOn: stream.  stream nextPutAll: '->'.  self destination gtDisplayOn: streamrubricBorderWidth: aColor  self setProperty: #brickRubricBorderWidth toValue: aColor.  self updateStyleisHShrinking  ^hResizing = #shrinkWrapcolumns  ^columns ifNil: [ columns := OrderedCollection new ]testAllowNilConditionWhenEmbedded  | expander tabulator |  expander := GLMExpander new.  expander allowNil.  expander display: [:x :y |  x + y ].  expander show: [:a |  a text display: [:x :y |  x asString , y asString ] ].  tabulator := GLMTabulator new.  tabulator     column: #one;     column: #two.  tabulator transmit     to: #two;     fromOutsidePort: #entity;     from: #one port: #nilPort;     andShow: [:a |  a custom: expander ].  self should: [ tabulator startOn: 1 ] raise: ErrorsetBoundsOf: aMorph after: afterMorph  aMorph     withWidth: self band width;     brickBounds: (afterMorph brickBounds bottomLeft extent: aMorph extent)testUnregisterAnnouncementsWhenEntityChanges  | announcer1 presentation |  announcer1 := Announcer new.  presentation := GLMPresentation new.  presentation updateOn: GLMTestAnnouncement from: [ announcer1 ].  presentation entity: 1.  presentation registerAnnouncements.  self assert: announcer1 numberOfSubscriptions equals: 1.  presentation entity: 2.  self assert: announcer1 numberOfSubscriptions equals: 0.  presentation registerAnnouncements.  self assert: announcer1 numberOfSubscriptions equals: 1.  presentation entity: nil.  self assert: announcer1 numberOfSubscriptions equals: 0testMarkerOneStaticInStaticHeight  | root brick |  root := self newBrickWithStaticExtent.  brick := self newBrickWithStaticExtent.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthClean.  self assert: brick wrappedBounds isHeightDirty.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightCleanaddColumn: aColumn  self columns add: aColumndisplayLogic  ^self valueOfProperty: #phlowDisplay ifAbsent: [ #yourself ]hideScrollBar  self removeMorph: scrollBar.  self adjustPaneHeightstylerDecorator  ^stylerDecoratorcomputeMorphWidths  | paneWidths widths |  paneWidths := self paneWidthsToFit: self totalPaneWidth.  widths := OrderedCollection new.  paneWidths do: [:w |  widths add: w ] separatedBy: [ widths add: self separatorWidth ].  ^widths asArrayextent: aPoint  super extent: aPoint.  self fullBoundstranslateBy: aPoint  self brickBounds: (self brickBounds translateBy: aPoint)defaultDimension  ^50isFocused  ^falseheightTraverser  ^GLMBrickHeightTraverser uniqueInstancepresentationClass: aGLMCompositePresentation startOn: anObject  glmPres := aGLMCompositePresentation new startOn: anObjectaction  ^actionscrollTo: aBrick  self shouldBeImplementedannouncements: anObject  announcements := anObjectaction  ^actionhighlightSmalltalkContext  ^highlightSmalltalkContextwidthRight  ^self width at: RighttestChangeChildrenInParent  | parent brick |  parent := self newBrickWithFullDependsOnChildren.  brick := self newBrickWithStaticExtent.  parent addBrickBack: brick.  self assertAllSubbricksAreClean: parent.  self assert: parent extent equals: brick extent.  brick height: self staticHeight * 2.  brick width: self staticWidth * 2.  self assertAllSubbricksAreClean: parent.  self assert: brick extent equals: self staticExtent * 2.  self assert: parent extent equals: brick extenttestNestedBrowserOther  | browser innerBrowser realInnerBrowser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  innerBrowser := GLMTabulator new.  innerBrowser column: #innerOne.  innerBrowser transmit     to: #innerOne;     andShow: [:a |  a text ].  innerBrowser transmit     toOutsidePort: #selection;     from: #innerOne.  browser transmit     to: #one;     andShow: [:a |  (a custom: innerBrowser) display: [:x |  x + 2 ] ].  browser transmit     to: #two;     from: #one;     andShow: [:a |  a text ].  browser startOn: 40.  realInnerBrowser := (browser paneNamed: #one) presentations first.  self assert: ((browser paneNamed: #one) port: #entity) value equals: 40.  self assert: (realInnerBrowser pane port: #entity) value equals: 40.  self assert: ((realInnerBrowser paneNamed: #innerOne) port: #entity) value equals: 42.  (realInnerBrowser panes first port: #selection) value: 7.  self assert: (realInnerBrowser pane port: #selection) value equals: 7.  self assert: (browser panes last port: #entity) value equals: 7column: aBlockOrString evaluated: aBlock tags: anObject sortedBy: aSortingBlock  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           tags: anObject;           sortBlock: aSortingBlock)updateDimension: aBrick  aBrick isHeightClean ifTrue: [ ^self ].  (self dimensionPolicy: aBrick) updateHeight: aBrickresetAnnouncer  super resetAnnouncer.  self panes do: [:each |  each resetAnnouncer ]testCondition  | browser1 browser2 transmission1 |  browser1 := GLMExplicitBrowser new.  browser2 := GLMExplicitBrowser new.  browser1 title: 'browser1'.  browser2 title: 'browser2'.  browser2     transformation: [:x |  x = 42 ifFalse: [ self fail.              42 ] ifTrue: [ 84 ] ];     condition: [:x |  x = 42 ].  browser1 addNewPane name: 'pane1'.  transmission1 := GLMTransmission new ensureReplacePresentationsStrategy.  transmission1 transmissionStrategy addPresentation: browser2.  browser1 addTransmission: (transmission1           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: browser1;                 name: #entity;                 yourself);           destination: (browser1 panes first port: #entity);           yourself).  self assert: (browser1 pane port: #entity) value isNil.  self assert: (browser1 panes first port: #entity) value isNil.  self assertEmpty: browser1 panes first presentations.  (browser1 pane port: #entity) value: 41.  self assert: (browser1 pane port: #entity) value equals: 41.  self assert: (browser1 panes first port: #entity) value equals: 41.  self assert: browser1 panes first presentations size equals: 1.  self assertEmpty: browser1 panes first matchingPresentations.  (browser1 pane port: #entity) value: 42.  self assert: (browser1 pane port: #entity) value equals: 42.  self assert: browser1 panes first presentations size equals: 1.  self assert: browser1 panes first matchingPresentations size equals: 1span: anObject  span := anObjectpushPane: aMorph  self band addBrickBack: (self configurePane: aMorph)* aNumber  < return: #Point>  ^0 @ aNumber negatedwantsSteps  ^self shouldStopStepping not and: [ self glamourPresentation wantsSteps ]items  ^items ifNil: [ items := self calculateItems ]transmissions  ^transmissionsborderWidth  ^1click: evt  self toggle.  ^truetoggleAmountToFilterBy  self amountToFilterBy notNil ifTrue: [ self amountToFilterBy isZero ifTrue: [ amountToFilterBy := self glamourPresentation amountToShow ] ifFalse: [ amountToFilterBy := 0 ].        self changed: #rootNodes ]isChecked  ^isCheckedrow: aBlockOrSymbol span: anInteger  ^self addRow: aBlockOrSymbol span: anIntegerupdateTextAreaWhenPlugged  self withStyler.  super updateTextAreaWhenPluggedorigin  ^originscrollTo: aFloat  self moveLeft: (owner width - self width) * aFloatchanged  ^self brick changedrubricCursorColor  ^self valueOfProperty: #brickRubricCursorColor ifAbsent: [ self themer rubricCursorColor ]addPresentation: aPresentation  self transmission transmissionStrategy addPresentation: aPresentationsliderBrick  ^sliderBricktestTopMarginMyselfDependency  | root margin brick |  margin := 10.  root := self newBrickWithStaticExtent.  brick := self newBrickWithSmallStaticExtent.  brick marginTop: margin.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticSmallExtent.  self assert: brick brickBounds equals: (0 @ margin extent: self staticSmallExtent)newLabelBrick: aStringOrBrick selected: selectedStringOrBrick  ^GLMTabLabelBrick new     label: aStringOrBrick selected: selectedStringOrBrick;     when: #onClicked send: #onTabClicked:with: to: self;     tabSelector: self;     vSpaceFilliconName: aSymbol  self icon: (Smalltalk ui icons iconNamed: aSymbol)renderPopupAction: anAction  ^GLMMorphicPopupActionRenderer render: anAction from: selfmorphicLayerNumber  ^10actOnPaneRemoved: ann  container brickRoot popPaneonPagePoped  self showOrHideScrollBarprintOn: aStream  super printOn: aStream.  aStream     nextPut: $(;     nextPutAll: self identityHash printString;     space;     nextPutAll: self name;     nextPut: $)assertWidthDirty: aBrick  self assert: aBrick wrappedBounds widthState equals: #dirty.  self assert: aBrick wrappedBounds isWidthDirty.  self assert: aBrick wrappedBounds isWidthClean notaddColumn: aBlockOrSymbol  ^self cellOrRow addColumn: aBlockOrSymbolband: aBrick  band := aBrick.  self band scrollpane: self.  self band hSpaceFill.  super addBrickBack: self bandrenderMorphFor: aPane  paneMorph     addMorph: (self renderObject: aPane presentations) fullFrame: LayoutFrame identity;     yourselfscrollButtonIconRenderBlock: aBlock  scrollButtonIconRenderBlock := aBlockupdatePosition  | height top width |  self scrollPane ifNil: [ ^self ].  self scrollPane band height = 0 ifTrue: [ self bar brickBounds: (0 @ 0 extent: 0 @ 0).        ^self changed ].  height := self calculateScrollbarHeight.  top := self calculateScrollbarTopOffset.  width := height >= self height ifTrue: [ 0 ] ifFalse: [ self width ].  self bar brickBounds: (0 @ top extent: width @ height).  self changedremoveCloserListener  self assert: [ self closer isNotNil ] description: [ 'Closer must not be nil' ].  self activeHand removeEventListener: self closer.  self closer popup: nilhandlesMouseDown: evt  ^truetitleAction: aBlock  labelActionBlock := aBlockonLayouted  super onLayouted.  self invalidateMorphBoundsportName  ^portNamenoTestExplicitAcceptDoesNotAffectTextPort  | composite textMorph |  composite := GLMCompositePresentation new with: [:a |  a text display: '123' ].  window := composite openOn: 4.  textMorph := self find: RubScrolledTextMorph in: window.  self simulateOnlyOneClickOn: textMorph.  self simulateKeyStrokes: '4'.  self assert: (composite pane port: #text) value asString equals: '1234'.  self simulateKeyStroke: $s meta.  self simulateKeyStrokes: '56'.  self assert: (composite pane port: #text) value asString equals: '123456'width  ^width ifNil: [ width := Array braceWith: 0 with: 0 with: 0 with: 0 ]scrollbarWidth  ^2newScrollList  ^GLMFallbackScrollListBrick newouterOrigin: aPoint  self brickBounds: (aPoint + (self marginLeft @ self marginTop) extent: self extent)spec  ^self custom: GLMSpecPresentation newmoreToolbarActions: noIconActions on: aBrowser  | menuMorph |  menuMorph := MenuMorph new.  noIconActions do: [:each |  (menuMorph add: each title target: each selector: #actOn: argument: aBrowser)           enabled: (each isEnabledOn: aBrowser);           yourself ].  ^menuMorphtestRemove  entity removeLast.  announcer announce: GLMTestAnnouncement.  self assert: listMorph model roots size equals: 2.  self assert: treeMorph model roots size equals: 2.  self assert: tableMorph model roots size equals: 2.  self assert: labelMorph contents equals: '2'hasMaxDimensionRestriction: aBrick  ^self subclassResponsibilitymarginRight  ^self wrappedBounds marginRightmouseUp: evt  super mouseUp: evt.  (self bounds containsPoint: evt position) & self isPressed ifTrue: [ self depress.        ^self click: evt ] ifFalse: [ self deselect: evt.        ^self depress ]testIn  | aPane |  aPane := GLMPane in: 1.  self assert: aPane name equals: aPane defaultName.  self assert: aPane browser equals: 1.  self assertEmpty: aPane ports.  self assertEmpty: aPane presentationsvShrinkWrap  super vShrinkWrap.  self labelBrick vShrinkWrap.  self editBrick vShrinkWrapannounce: anAnnouncement  (self isAnnouncementSuspended: anAnnouncement) ifTrue: [ ^anAnnouncement asAnnouncement ].  ^super announce: anAnnouncementaddButton: aBrick  self buttons add: aBrick.  aBrick enable.  aBrick index: self buttons size.  aBrick announcer when: GLMPagerButtonClicked send: #onButtonClicked: to: self.  aBrick announcer when: GLMPagerButtonSelected send: #onButtonSelected: to: self.  aBrick announcer when: GLMPagerButtonDeselected send: #onButtonDeselected to: self.  self theme pagerWidgetThemer defaultScrollButtonStyleFor: aBrick.  aBrick height: self pagerModel circleButtonSize.  aBrick width: self pagerModel circleButtonSize.  self addBrickBack: aBrick.  self buttons size = 1 ifTrue: [ self updateButtonsFocus ].  self updateButtonsprimarySelectionInterval: anInterval  primarySelectionInterval := anIntervalinnerBounds  ^self brick innerBoundsbeDownward  self popupLayout: GLMPopupBrickDownwardLayout newrowHeightBlock  ^self parameters at: 'rowHeight' ifAbsent: [ self class defaultRowHeight ]activeOrigins  ^(self originReferences select: [:each |  each isActive ]) collect: [:each |  each port ]pane  self subclassResponsibilitytestCopyNotTheSameRegistry  | pane newPane |  pane := GLMPane new.  newPane := pane copy.  self assert: pane glmSubscriptions ~~ newPane glmSubscriptionsisEmpty  ^collection isEmptytestPresentationInitializationBlockIsCalled  | pane presentation count |  count := 0.  pane := GLMPane named: 'test'.  presentation := GLMPresentation new initialize: [:pres |  count := count + 1 ].  pane addPresentation: presentation.  self assert: count equals: 0.  presentation initializePresentation.  self assert: count equals: 1.  presentation initializePresentation.  self assert: count equals: 2data: anObject  data := anObjectinitialize  super initialize.  next := self.  previous := selftestModelInitialization  self assert: pagerModel size equals: 0.  self assert: pagerModel firstVisiblePageIndex equals: 0.  self assert: pagerModel lastVisiblePageIndex equals: 0.  self assert: pagerModel actualNumberOfVisiblePages equals: 0.  self assert: pagerModel numberOfVisiblePages equals: 2themer: aThemer  self setProperty: #brickThemer toValue: aThemer.  self brickRoot themerChangedbrick  ^brickasGlamorousPane  ^selfallDisplayedDo: aBlock  self displayValue do: [:eachRoot |  self withChildrenOf: eachRoot do: aBlock ]resetDataCache  dataCache := nilupdateVisibleBottom: invisibleBricks  | after |  after := self band lastSubbrick.  [ after isNotNil and: [ (self isPartiallyVisible: after) and: [ (self getIndex: after) < self model count ] ] ] whileTrue: [ after := self addItemMorph: (self getMorphAt: (self getIndex: after) + 1 recycled: (self getAndRemoveInvisibleMorph: invisibleBricks)) after: after ]outOfWorld: aWorld  Morph announcer unsubscribe: self.  ^super outOfWorld: aWorldmaxDepth: anInteger  self parameters at: 'maxDepth' put: anIntegerrenderAction: anAction  ^GLMMorphicActionRenderer render: anAction from: selfallSubbricks  | all |  all := OrderedCollection new.  self allSubbricksDo: [:each |  all add: each ].  ^alldragSliding: evt  | newLeft value |  newLeft := evt position x - self owner globalBounds left - startDragX.  value := self computeScrollValue: newLeft.  self scrollTo: value.  self synchronizeScrollTo: valuesimulateOnlyOneClickOn: aMorph  aMorph simulateClickcontentBackgroundColor  ^Color whitetestExplicitTransmissionComplex  | finder browser |  finder := GLMFinder new.  finder transmit     fromOutsidePort: #entity;     toOutsidePort: #something.  browser := GLMTabulator new.  browser     row: #explorer;     row: #details.  browser transmit     to: #explorer;     andShow: [:a |  a custom: finder ].  browser transmit     from: #explorer port: #something;     to: #details;     andShow: [:a |  a text ].  browser startOn: 42.  self assert: (browser panes first port: #something) value equals: 42submorphBefore  ^self subbrickBeforeshadowColor  ^Color black alpha: 0.5delete  self model notNil ifTrue: [ self model unregisterFromAllAnnouncements ].  super deleteenlargeToLeft  self virtualFirstVisiblePageIndex: self firstVisiblePageIndex - 1.  self recomputeStatetitleValueOfColumn: aColumn  ^aColumn title glamourValue: self entityappendVariableBinding: anAssociationList  anAssociationList ifNotNil: [ anAssociationList do: [:anAssociation |  self variableBindings add: (anAssociation class = WorkspaceVariable ifTrue: [ anAssociation ] ifFalse: [ WorkspaceVariable key: anAssociation key value: anAssociation value ]) ] ]pharoScript  ^self custom: GLMPharoScriptPresentation newrenderGlamorouslyOn: aRenderer  self deprecated: 'Use GLMRubricTextPresentation instead.'.  self registerAnnouncements.  ^aRenderer renderTextPresentation: selftestSimpleEmptyPane  | pane |  pane := GLMPane new.  pane browser: GLMBrowser new.  (pane port: #entity) value: 42.  self assert: GLMLogger instance announcements size equals: 1.  self assert: (GLMLogger instance announcements first isKindOf: GLMContextChanged)actOnMatchingPresentationsChanged: anAnnouncement  paneMorph removeAllMorphs.  self renderMorphFor: anAnnouncement pane.  self renderer window fullBoundsonCreated  self textEditBrick: self newTextEditFieldactOnCompileText: ann  (ann session recompileMethodTo: ann presentation text inContext: ann context notifying: textMorph) ifTrue: [ ann action ifNotNil: [:action |  action value ] ]testSetup  | browser pane1 pane2 transmission |  browser := GLMExplicitBrowser new.  pane1 := browser addNewPane.  pane2 := browser addNewPane.  transmission := GLMTransmission new     addActiveOrigin: (pane1 port: #selection);     destination: (pane2 port: #entity);     yourself.  browser addTransmission: transmission.  self assert: browser panes size equals: 2.  self assert: browser transmissions size equals: 1.  self assert: browser panes first identicalTo: pane1.  self assert: browser panes last identicalTo: pane2.  self assert: pane1 browser identicalTo: browser.  self assert: pane2 browser identicalTo: browser.  self assert: browser transmissions first identicalTo: transmissiontestAddRaisesAnnouncement  | composite announcementCount pane |  composite := GLMCompositePresentation new.  pane := composite pane.  announcementCount := 0.  composite entity: 42.  pane when: GLMMatchingPresentationsChanged do: [:ann |  announcementCount := announcementCount + 1 ].  composite add: GLMPresentation new.  self assert: announcementCount equals: 1openInExternalWindow  ^self defaultRenderer openInExternalWindow: selfchildrenItems  ^OrderedCollection with: ((GLMExpanderContentsNodeModel with: self -> self item) containerNode: self)computeTagsFor: aGlamourValue  ^self computeTagsFor: aGlamourValue from: self tagsBlockreadyToBeDisplayed  self glamourPresentation announcer announce: (GLMDataSourceUpdated newDataSource: self)enableFilter  self parameters at: 'isFilterable' put: truedoItReceiver  ^self glamourPresentation doItReceiverisPartiallyVisible: aBrick  | myBounds testingBounds |  myBounds := (self allowedBounds withWidth: 1) translateBy: self allowedBounds origin negated x @ 0.  testingBounds := (aBrick globalBounds withWidth: 1) translateBy: aBrick globalBounds origin negated x @ 0.  ^myBounds intersects: testingBoundsupdateWidth: aBrick on: aLayout  aBrick withWidth: (aLayout normalizeWidth: (aLayout widthChildrenDependency: aBrick) of: aBrick)showOnlyFinderBrowser  | finder |  finder := GLMFinder new.  finder list     title: 'title';     display: [:each |  1 to: each ];     showOnly: 50.  ^finderpane  ^panecollect: aBlock  ^self copy     presentations: (self presentations collect: aBlock);     yourselfouterBounds  ^outerBounds ifNil: [ self updateCache.        outerBounds ]paddingTop  ^self brick paddingTopopenAt: aPoint  < return: #GLMFoundationBrick>  | aFoundationBrick |  aFoundationBrick := self asBrickedMorph     vShrinkWrap;     hShrinkWrap;     position: aPoint;     openInWorld.  self onOpened.  ^aFoundationBrickonParentDo: aBlock  ^self on: #isOnParent do: aBlock ifAbsent: [ GLMBrickLayoutParentState new ]titleOrIconOf: aPresentation in: container  ^aPresentation hasTitleIcon ifTrue: [ | image |        image := GLMInteractableBrick new normalImage: aPresentation titleIconValue.        image maxWidth: [ aPresentation titleIconValue width * 2 ].        image hSpaceFill.        image vSpaceFill.        aPresentation titleValue ifNotNil: [ image setBalloonText: aPresentation titleValue maxLineLength: 100 ].        image ] ifFalse: [ aPresentation titleValue ifNil: [ '' ] ]renderFinder: aBrowser  ^aBrowser hasFixedSizePanes ifTrue: [ GLMMorphicFixedPanesFinderRenderer render: aBrowser from: self ] ifFalse: [ GLMMorphicVariablePanesFinderRenderer render: aBrowser from: self ]lastPane  self subbricksCount = 0 ifTrue: [ ^nil ].  ^self panes lastrenderBorderOf: aBrick on: aCanvas  | markColor markWidth |  aBrick border renderBorderOf: aBrick on: aCanvas.  markColor := aBrick valueOfProperty: #brickMarkBorderColor ifAbsent: nil.  markWidth := aBrick valueOfProperty: #brickMarkBorderWidth ifAbsent: nil.  markColor isNotNil & markWidth isNotNil ifTrue: [ aCanvas frameRectangle: aBrick brickBounds width: markWidth color: markColor ]testSimpleRows  | layout |  layout := GLMTabulator new.  layout addRow: #first.  layout addRow: #second.  self assert: layout cell children size equals: 2.  self assert: layout cell isColumn.  self assert: layout cell children first isRowtestMinAndMaxHeightTwoParentDependenciesReverse  | root brick1 brick2 minHeight maxHeight |  minHeight := 20.  maxHeight := 60.  root := self newBrickWithStaticExtent.  root useVerticalLinearLayout.  brick1 := self newBrickWithFullFill.  brick1 vSpaceFill: 0.  brick1 minHeight: minHeight.  brick2 := self newBrickWithFullFill.  brick2 maxHeight: maxHeight.  root addAllBricks: {brick1 .         brick2}.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick1 extent equals: self staticWidth @ minHeight.  self assert: brick2 extent equals: self staticWidth @ maxHeightcomputeVertices  vector ifNil: [ ^self ].  vertices := Array streamContents: [:aStream |  | currentVector vertex |        currentVector := vector.        vertex := origin.        aStream nextPut: vertex.        [ currentVector next ~= vector ] whileTrue: [ vertex := currentVector + vertex.              aStream nextPut: vertex.              currentVector := currentVector next ] ]virtualLastVisiblePageIndex: anIndex  virtualLastVisiblePageIndex := self normalizePaneIndex: anIndexanimatedObject  ^animatedObjectbeVertical  self isHorizontal: falsepressedColor: anObject  pressedColor := anObjectfromValue  ^fromValue ifNil: [ fromValue := fromLogic brickValue: self animatedObject ]actionSelector  ^#popupActOn:from:variableBindings: anObject  variableBindings := anObjectunregisterFromAllAnnouncements  self announcerObjects do: [:each |  [ each unsubscribe: self ] on: Error do: [:e |  e resume ] ]entity: anObject  (self pane port: #entity) value: anObjectisDependsOnParent: aBrick  ^(self stateOf: aBrick) isOnParentopen: aPopupBrick with: aRectangle  < return: #GLMFoundationBrick>  ^self subclassResponsibilitymarkDependent: aBrick  aBrick isWidthDirty | aBrick isHeightDirty ifTrue: [ aBrick layout markDirty.        aBrick owner ifNotNil: [:o |  o isBrick ifTrue: [ o layout markDirty ] ] ].  aBrick isWidthDirty ifTrue: [ self widthTraverser markDirtyAround: aBrick inContext: nil ].  aBrick isHeightDirty ifTrue: [ self heightTraverser markDirtyAround: aBrick inContext: nil ]testResettingTheSelection  | composite textPresentation |  composite := GLMCompositePresentation new with: [:a |  a text display: '123456789' ].  window := composite openOn: 4.  textPresentation := composite presentations first.  textPresentation selectionInterval: (2 to: 5).  textPresentation selectionInterval: nilroots: anObjectOrCollection  roots := anObjectOrCollection asOrderedCollection collect: [:each |  self nodeModelFor: each ]receive: aTransmission in: aContext  self subclassResponsibilityactOnContextChanged: anAnnouncement  anAnnouncement property = #selection ifTrue: [ treeModel announcer suspendAll: self suspendedAnnouncements while: [ treeMorph model explicitSelection: anAnnouncement value ] ]text: aBlock  aBlock cull: self texttitleBrick  ^titleBrickpaddingRight  ^self padding at: Righttitle: aStringOrBlock  title := aStringOrBlockcontentBrick: aBrick  contentBrick := aBrick.  self contentBrick     hSpaceFill;     vShrinkWrapselectionValue: anObject  selectionValue := anObjectscrollTo: aBrick  | delta |  (self isVisible: aBrick) ifTrue: [ ^self ].  delta := self allowedBounds top - band globalBounds top - (aBrick globalBounds top - band globalBounds top).  delta < 0 ifTrue: [ delta := delta + self allowedBounds height - aBrick height ].  self band translateY: delta.  self isBottomOverscrolled ifTrue: [ self moveBandBottom ].  self isTopOverscrolled ifTrue: [ self moveBandTop ].  self update.  self changedshouldUseCache: aBoolean  ^self parameters at: 'shouldUseCache' put: aBooleanonButtonSelected: ann  GLMPagerPanePreviewMorph uniqueInstance showAt: (self buttons at: ann buttonModel index) globalBounds topCenter.  self pagerModel updatePreview: ann buttonModel indextestTreeAllowDeseletion  | browser treeNodeMorph |  browser := GLMFinder new.  browser show: [:a |  a list allowDeselection ].  window := browser openOn: ($a to: $d).  treeNodeMorph := self treeVisibleItems first.  self send: self tree mouseUpOnItem: treeNodeMorph.  self send: self tree mouseUpOnItem: treeNodeMorph.  self assert: (browser panes first port: #selection) value isNilexecuteSearch  | newSelection check |  newSelection := OrderedCollection new.  roots do: [:each |  check := self glamourPresentation searchStrategy value: self inputText value: each item.        check ifTrue: [ newSelection add: each path ] ].  newSelection isEmpty ifFalse: [ self selection: (MorphTreeMorphMultipleSelection new selectedNodePathList: newSelection) ] ifTrue: [ self selection: nil ]renderer  ^rendererpopupLayout: aPopupLayout  popupLayout := aPopupLayout.  self popupLayout build: self trigger: self triggerBrick content: self contentBrickcontentsMorph: anObject  contentsMorph := anObjectspacing  ^spacingselectedPageIndex  ^selectedPageIndexshadowOffset  ^self valueOfProperty: #brickShadowOffset ifAbsentPut: [ 0 @ 0 ]action: anAction  action := anActionviewRowMorphForColumn: aGlamourColumn node: aNode withIndex: anInteger  ^(self valueFor: aNode withIndex: anInteger in: aGlamourColumn) asMorph asReadOnlyMorphselectedBehavior  ^self highlightSmalltalkContextrenderGlamorouslyOn: aRenderer  ^aRenderer renderTabbedCompositePresentation: self compositetestScriptingDefaults  | browser |  browser := GLMTabulator new.  browser startOn: 42.  self assert: browser panes size equals: 1.  self assert: browser transmissions size equals: 1.  self assert: browser transmissions first origins first equals: (browser pane port: #entity).  self assert: browser transmissions first destination equals: (browser panes first port: #entity)testListDoubleClick  | browser treeMorph treeNodeMorph |  browser := GLMFinder new.  browser show: [:a |  a list ].  window := browser openOn: ($a to: $d).  treeMorph := window submorphs last submorphs first submorphs first submorphs first submorphs first.  treeNodeMorph := treeMorph scroller submorphs first.  self send: treeMorph mouseUpWithShift: false onItem: treeNodeMorph.  self send: treeMorph doubleClickWithShift: false onItem: treeNodeMorph.  self assert: (browser panes first port: #strongSelection) value equals: $agatherInvisibleItems  ^self band subbricks select: [:each |  (self isPartiallyVisible: each) not ]titleIcon  ^titleIcondisplay: anObject  self setProperty: #phlowDisplay toValue: anObjectnewTitleBrick  ^GLMLabelBrick new     text: self titleText;     padding: #(0 10);     width: [:b |  b approximateWidth ];     height: [:b |  b approximateHeight ]getIndex: aBrick  ^aBrick valueOfProperty: #brickScrollListIndex ifAbsent: [  ]selectedText: anObject  (self pane port: #selectedText) value: anObject copywithHeight: anInteger  ^self brick withHeight: anIntegerselectNextTab  self selectedIndex: self selectedIndex \\ self tabs size + 1dynamicActionsOnSelection: aBlock  selectionDynamicActionsBlock := aBlockrender: aBrick on: aCanvas  self renderShadowOf: aBrick on: aCanvas.  self renderBackground: aBrick on: aCanvas.  self renderBorder: aBrick on: aCanvasnewEditBrick  ^GLMRubTextFieldBrick newfocusedMorphChanged: aMorph at: pageIndex  self assignFocusableMorph: aMorph withPaneAt: pageIndex.  focusedPageIndex = pageIndex ifFalse: [ focusedPageIndex := pageIndex.        self notifyFocusedPageChanged ]allKeystrokeActions  ^self glamourPresentation allActions , self glamourPresentation allSelectionActions select: [:action |  action hasShortcut ]action  ^actiontestCopyAnnouncementsDoNotRaise  | presentation newPresentation |  presentation := GLMPresentation new.  presentation when: GLMContextChanged do: [:ann |  self fail ].  self assert: presentation numberOfSubscriptions equals: 1.  newPresentation := presentation copy.  newPresentation announce: GLMContextChanged.  self assert: newPresentation numberOfSubscriptions equals: 0port: aSymbol  ^ports detect: [:each |  each name = aSymbol ] ifNone: [ ports addLast: (self class portClass new                 pane: self;                 name: aSymbol;                 yourself) ]onThemerChanged  super onThemerChanged.  self updateStylebottomRightCornerShadowOf: aBrick on: aCanvas  | gradient width origin offset |  width := aBrick shadowWidth.  offset := (width @ width) negated / 2.0.  origin := aBrick brickBounds bottomRight + offset + aBrick shadowOffset.  gradient := (self shadowGradientFor: aBrick)     origin: origin;     direction: width @ width / 1.4;     radial: true;     yourself.  aCanvas fillRectangle: (origin extent: width @ width) fillStyle: gradientnormalLabel  ^normalLabelshouldUseCache: aBoolean  ^self parameters at: 'shouldUseCache' put: aBooleanwindow  ^self class environment at: #GLMWindowBrick ifPresent: [:glmWindowBrick |  (self ownerThatIsA: glmWindowBrick) ifNil: [ self ownerThatIsA: SystemWindow ] ] ifAbsent: [ self ownerThatIsA: SystemWindow ]testDefault  | browser |  browser := GLMTabulator new.  browser startOn: #(1 2 3).  self assert: (browser panes first presentations first isKindOf: GLMFlexiblePresentation).  browser startOn: 1.  self assert: (browser panes first presentations first isKindOf: GLMFlexiblePresentation)text: aText  self rubric updateTextWith: aTextbasicElements  ^self glamourPresentation displayValuebuild: aPopup trigger: aTriggerBrick content: aContentBrick  aPopup removeAllBricks.  aPopup triggerBrick: aTriggerBrick.  aPopup contentBrick: aContentBrickisScrollMustBeChecked: anIndex withLeft: leftBound andRight: rightBound  | buttonCenter |  buttonCenter := self buttonCenterByIndex: anIndex.  ^leftBound <= buttonCenter & (rightBound > buttonCenter)popPane: isSmooth  (isSmooth not or: [ self lastPane isNil ]) ifTrue: [ ^self popPane ].  self band doNotLayoutDuring: [:b |  b removeBrick: b lastSubbrick ].  self scrollTo: (pagerModel convertIndexToValue: pagerModel firstVisiblePageIndex with: self band subbricksCount) smooth: isSmooth callback: [ self doLayoutForce ]silver  ^Color brickColorRegistry at: #brickSilver ifAbsentPut: [ Color r: 189 g: 195 b: 199 range: 255 ]mouseDown: evt  | selectors |  self isDoubleClickEnabled ifFalse: [ super mouseDown: evt.        ^self press ].  selectors := Array with: #click: with: #doubleClick: with: #singleClick: with: nil.  evt hand waitForClicksOrDrag: self event: evt selectors: selectors threshold: 10hasFilterBlock  ^self parameters at: 'filterBlock' ifPresent: [ true ] ifAbsent: [ false ]spotterThemer  ^self registerModule: GTSpotterWidgetDarkThemer new to: GTSpotterBrickDarkThemer newassertBrickClean: aBrick  self assertWidthClean: aBrick.  self assertHeightClean: aBrickrender: aPane  aPane when: GLMMatchingPresentationsChanged send: #actOnMatchingPresentationsChanged: to: selfcacheAt: aKey for: anElement ifAbsentPut: aBlock  | elementCache |  self shouldUseCache ifFalse: [ ^aBlock value ].  elementCache := self dataCacheFor: anElement.  (elementCache includesKey: aKey) ifTrue: [ ^elementCache at: aKey ].  ^aBlock value ifNotNil: [:anObject |  elementCache at: aKey ifAbsentPut: [ anObject ] ]initialize  super initialize.  self     vShrinkWrap;     hShrinkWraptestValidatePorts  | pane presentation |  pane := GLMPane named: 'test'.  presentation := GLMListPresentation new.  pane addPresentation: presentation.  presentation shouldValidate: true.  presentation entity: #(1 2).  presentation selection: 2.  self assert: presentation selection equals: 2.  presentation selection: 3.  self assert: presentation selection equals: 2updateHeight: aBrick on: aLayout  aBrick outerHeight: (aLayout normalizeHeight: (aLayout heightParentDependency: aBrick) of: aBrick)scrollTo: anInteger  | brick index |  self band doNotLayoutDuring: [ self band removeAllBricks ].  self moveBandTop.  visibleIndex := nil.  self model count > 0 ifTrue: [ index := (anInteger max: 1) min: self model count.        brick := self getMorphAt: index recycled: nil.        brick withWidth: self band width.        brick doLayout.        brick brickBounds: (0 @ (0 max: (self height - brick height) / 2) extent: brick extent).        self addBrickBackNoLayout: brick ].  self update.  self changedworkspaceBindingsStrategy  ^[:currentBindings :aString :aTextModel |  (aTextModel doItReceiver class allInstVarNames includes: aString) ifTrue: [ nil ] ifFalse: [ (currentBindings includesKey: aString) ifFalse: [ currentBindings add: (WorkspaceVariable key: aString asSymbol) ].        currentBindings associationAt: aString ] ]pressedImage  ^pressedImagerowHeightBlock  ^self parameters at: 'rowHeight' ifAbsent: [ self class defaultRowHeight ]select: anEvent  super select: anEvent.  self box select: anEvent.  self label select: anEventrightAngle: aVector  ^self direction rightAngle: aVector directionshadowWidth  ^self valueOfProperty: #brickShadowWidth ifAbsentPut: [ 0 ]postCopy  super postCopy.  registry := registry copyfocusedViewAt: pageIndex  ^focusedViews at: pageIndex ifAbsent: [ nil ]transmit  ^self addTransmission: (GLMTransmission new           browser: self;           yourself)setCursorToNormal: evt  evt hand showTemporaryCursor: nilcontext  ^contextonOpened  testStatusbarTransmissionsTriggered  | browser pane |  browser := GLMTabulator new.  browser addStatusbar.  self assert: browser statusbarPane notNil.  self assert: browser statusbarPane ~= browser.  pane := (GLMPane in: browser) name: #one.  browser addPane: pane.  self assert: browser transmissions size equals: 1.  (pane port: #status) value: #test.  self assert: browser statusbarPane ~= browser.  self assert: (browser statusbarPane port: #entity) value equals: #test.  self assert: browser statusbarPane presentations size equals: 1.  self assert: (browser statusbarPane presentations first isKindOf: GLMLabelPresentation)isFullyVisible  self band hasSubbricks ifFalse: [ ^true ].  ^self isLastAdded & self isFirstAdded & super isFullyVisibleonChildrenLayouted  super onChildrenLayouted.  self translateXTo: self leftPositionprivateExtent: aPoint  super extent: aPointshouldLayoutMorphs  ^shouldLayoutMorphs ifNil: [ shouldLayoutMorphs := false ]helpMessage: aString  helpMessage := aStringupdateStyle  self color: self scrollpaneBackgroundColorlabel: aBrick  self label: aBrick selected: aBrickposition: aPoint  self translateBy: aPoint asNonFractionalPoint - self brickBounds topLeftscrollbarOffset  ^self valueOfProperty: #brickScrollbarOffset ifAbsent: [ self themer scrollbarOffset ]buttonMorph: aModel  ^UITheme current newButtonIn: nil for: aModel getState: nil action: #execute arguments: nil getEnabled: nil label: aModel buttonLabel help: nilenableFilterWithAction: aBlock named: aString  self enableFilter.  self parameters     at: 'actionBlock' put: aBlock;     at: 'actionName' put: aStringtestInitializeBlockSetsTextSelectionForTextPresentation  self checkInitializeBlockSetsTextSelectionForPresentation: #textrenderGlamorouslyOn: aRenderer  ^aRenderer renderPager: selftestRightMarginParentDependency  | root margin brick |  margin := 10.  root := self newBrickWithStaticExtent.  brick := self newBrickFullHeightAndWidthDependsOnParent: 100.  brick marginRight: margin.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticExtent - (margin @ 0).  self assert: brick brickBounds equals: (0 @ 0 corner: self staticExtent - (margin @ 0))newButton  ^GLMButtonBrick new margin: #(3 0)testStartTransmission  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #one;     andShow: [:a |  a list ].  self assert: browser transmissions size equals: 1.  self assertEmpty: (browser paneNamed: #one) presentations.  self assertEmpty: (browser paneNamed: #two) presentations.  browser startOn: 15.  self assert: (browser paneNamed: #one) presentations size equals: 1.  self assertEmpty: (browser paneNamed: #two) presentationscolumn: anObject evaluated: otherObject  self column: anObject evaluated: otherObject styled: nildrawSubmorphsOnAthensCanvas: anAthensCanvas  | area zIndexedBricks |  self submorphs isEmpty ifTrue: [ ^self ].  area := anAthensCanvas clipRect intersect: self globalInnerBounds ifNone: (0 @ 0 extent: 0 @ 0).  area width = 0 | (area height = 0) ifTrue: [ ^self ].  zIndexedBricks := OrderedCollection new.  self subbricks do: [:each |  | intersection globalBounds |        each ifNotNil: [ self flag: 'fix nil case'.              globalBounds := each isBrick ifTrue: [ each globalBounds ] ifFalse: [ each fullBounds ].              (area intersects: globalBounds) ifTrue: [ | zIndex |                    zIndex := each layoutProperties zIndex brickValue: each.                    zIndex = 1 ifTrue: [ intersection := area intersect: globalBounds ifNone: (0 @ 0 extent: 0 @ 0).                          anAthensCanvas clipBy: intersection during: [ each fullDrawOnAthensCanvas: anAthensCanvas ] ] ifFalse: [ zIndexedBricks add: each ] ] ] ].  zIndexedBricks sort: [:first :second |  (first layoutProperties zIndex brickValue: first) < (second layoutProperties zIndex brickValue: second) ].  zIndexedBricks do: [:each |  | intersection globalBounds |        each ifNotNil: [ self flag: 'fix nil case'.              globalBounds := each isBrick ifTrue: [ each globalBounds ] ifFalse: [ each fullBounds ].              intersection := area intersect: globalBounds ifNone: (0 @ 0 extent: 0 @ 0).              anAthensCanvas clipBy: intersection during: [ each fullDrawOnAthensCanvas: anAthensCanvas ] ] ]renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderListPresentation: selftestAddTransmissionReturn  | transmission |  transmission := GLMTransmission new.  self assert: (GLMExplicitBrowser new addTransmission: transmission) identicalTo: transmissionpredicate: anObject  predicates add: anObjectinitialize  super initialize.  self     enable;     labelBrick: self newLabelBrick;     hShrinkWrap;     vShrinkWraporiginMorphFor: aMorph  (aMorph textArea hasSelection not and: [ aMorph textArea hasHighlightSegment ]) ifTrue: [ ^aMorph textArea getHighlightSegment ].  ^aMorph textArea cursorprivateInvalidateMorph: aMorph  selectItem  self containerTree explicitlySelectItem: self itemkeyboardFocusChange: aBoolean  super keyboardFocusChange: aBoolean.  self focusChangedtextEditBrick: aBrick  textEditBrick := aBrick.  self contentBrick addBrickBack: self textEditBrick.  self textEditBrick rubric announcer when: RubTextAcceptRequest send: #acceptContents: to: selfvalue  ^valuedropOnItem: aBlock  dropOnItemBlock := aBlockrow: aBlockOrSymbol  ^self addRow: aBlockOrSymbolallKeystrokeActions  ^self glamourPresentation allActions , self glamourPresentation allSelectionActions select: [:action |  action hasShortcut ]vSpaceFill: anInteger  super vSpaceFill: anInteger.  vResizing := #spaceFillactOnPresentationUpdated: ann  container removeAllMorphs.  container addMorphBack: (self morphFrom: ann presentation)animationStep  | delta stepValue currentTime stop stepStamp |  self needsStep: false.  currentTime := Time millisecondClockValue.  stop := currentTime >= self finishTime.  delta := self duration = 0 ifTrue: [ 1 ] ifFalse: [ (currentTime - startTime min: self duration) / self duration ].  delta = 1 ifTrue: [ stop := true ].  stepValue := stepLogic brickValue: self animatedObject withEnoughArguments: {self fromValue .         self toValue .         delta}.  delta = 1 | (stepValue = self toValue) ifTrue: [ stop := true ].  stepStamp := stamp.  UIManager default defer: [ self asyncTask isTerminated not & (stepStamp = stamp) ifTrue: [ steppedLogic brickValue: self animatedObject withEnoughArguments: {delta}.              animationLogic brickValue: self animatedObject withEnoughArguments: {stepValue}.              stop ifFalse: [ self needsStep: true.                    self asyncTask resume ] ifTrue: [ self shouldStop: true.                    self asyncTask resume ] ] ].  self asyncTask pauseactionArguments  ^nilcut  self announce: (GLMTextEditorRequest for: #cut)containerNode: anObject  containerNode := anObjectvalue: anObject  value := anObjectisRow  ^falsehasBindingThatBeginsWith: aString  ^self variableBindings keys anySatisfy: [:each |  each beginsWith: aString ]normalLabel: anObject  normalLabel := anObjectopenSettingsBrowser  self class openSettingsBrowsertestSelectionActions  | listing |  listing := GLMPresentation new.  listing selectionActions isEmpty.  listing addSelectionAction: GLMAction new.  self assert: listing selectionActions size equals: 1end: anObject  end := anObjecttext: aString  < brickBuilderProperty: #Text name: 'Text' as: #asString getter: #text model: #GLMUIBuilderTextFieldProperty>  self label text: aString.  self wrappedBounds markWidthDirty.  self doLayouttestTransmissionBundle  | browser pane1 pane2 pane3 presentation1 presentation2 transmission |  browser := GLMExplicitBrowser new.  presentation1 := GLMPresentation new.  presentation2 := GLMPresentation new.  pane1 := GLMTestPane new.  pane2 := GLMTestPane new.  pane3 := GLMTestPane new.  pane1 addPresentation: GLMPresentation new.  pane2 addPresentation: GLMPresentation new.  pane3 addPresentation: presentation1.  transmission := GLMTransmission new     ensureReplacePresentationsStrategy;     addActiveOrigin: (pane1 port: #selection);     addPassiveOrigin: (pane2 port: #selection);     destination: (pane3 port: #entity);     addPresentation: presentation2;     yourself.  browser addPane: pane1.  browser addPane: pane2.  browser addPane: pane3.  browser addTransmission: transmission.  self assert: pane3 presentations size equals: 1.  self assert: pane3 presentations first identicalTo: presentation1.  pane2 presentations first selection: #foo.  self assert: (pane2 port: #selection) seenTransmissions size equals: 1.  self assert: (pane3 port: #entity) seenTransmissions size equals: 0.  pane1 presentations first selection: #bar.  self assert: (pane1 port: #selection) seenTransmissions size equals: 1.  self assert: (pane3 port: #entity) seenTransmissions size equals: 1.  self assert: (pane3 port: #entity) seenTransmissions last identicalTo: transmission.  self assert: (pane3 port: #entity) value equals: (GLMMultiValue withAll: #(#bar #foo)).  self assert: pane3 presentations size equals: 1.  self assert: pane3 presentations first rootPrototype equals: presentation2strongSelectionValue  ^strongSelectionValuerowMorphForColumn: aGlamourColumn  | rowElements contentMorph tagMorphs |  aGlamourColumn modifiedBlock ifNil: [ contentMorph := (self containerTree glamourPresentation column: aGlamourColumn valueFor: self item) asMorph asReadOnlyMorph ] ifNotNil: [ contentMorph := GLMEditableLabelBrick new           cancelOnEscape;           cancelOnFocusLost;           text: (self valueFor: aGlamourColumn);           hSpaceFill;           with: [:b |  b editBrick rubricBackgroundColor: b themer rubricBackgroundColor ];           when: #onEditMode do: [ self containerTree forceStopStepping ];           when: #onReadMode do: [ self containerTree resetStopStepping ];           when: #onSingleClicked do: [:evt :brick |  brick isReadMode ifTrue: [ (brick ownerThatIsA: GLMPaginatedResizableMorphTreeMorph) listManager mouseUp: evt on: brick owner owner owner ] ];           when: #onAccepted do: [ self modified: aGlamourColumn with: contentMorph text ];           yourself.        contentMorph := contentMorph asMorph           hSpaceFill;           vShrinkWrap ].  tagMorphs := self tagMorphsFrom: aGlamourColumn.  tagMorphs ifEmpty: [ ^contentMorph ].  rowElements := OrderedCollection new     add: contentMorph;     addAll: tagMorphs;     yourself.  ^UITheme current newRowIn: self currentWorld for: rowElementsinputText  ^inputText ifNil: [ inputText := '' ]fromOutsidePort: aPortName  ^self from: #outer -> aPortNameinitialExtent  ^initialExtent ifNil: [ initialExtent := RealEstateAgent standardWindowExtent ]dropDownList  ^self custom: GLMDropDownListPresentation newcomputeBounds  duration: anInteger  duration := anIntegertotalScrollRange  | submorphBounds |  submorphBounds := transform localSubmorphBounds ifNil: [ ^0 ].  ^submorphBounds widthmarkLayoutDirty: aBrick  aBrick ifNotNil: [:b |  b isBrick ifTrue: [ b markLayoutDirty ] ]titleFor: aRenderable  ^aRenderable titleValue ifNil: [ 'Glamorous Browser' ]smalltalkClass: aBlock  highlightSmalltalkContext := aBlockmargin  ^margin ifNil: [ margin := Array braceWith: 0 with: 0 with: 0 with: 0 ]wantsSteps: aBoolean  wantsSteps := aBooleanhSpaceFill: anInteger  super hSpaceFill: anInteger.  self label hSpaceFillpaddingRight: anInteger  self padding at: Right put: anInteger.  self updateCacheinstallEntity  self textBrick model: self.  self textBrick classOrMetaClass: (self smalltalkClassLogic phlowValue: self entity).  self textBrick setTextWith: (self displayLogic phlowValue: self entity).  self textBrick selectionInterval: (self selectionInterval phlowValue: self entity)openCenteredInBrickWindowLabeled: aLabel  self     vAlign: #center;     hAlign: #center;     openInBrickWindowLabeled: aLabeltestUpdateYourselfOn  | announcer entity browser presentation |  announcer := Announcer new.  entity := OrderedCollection with: 1 with: 2 with: 3.  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  presentation := a list           updateOn: GLMTestAnnouncement from: [ announcer ];           shouldValidate: true ].  browser startOn: entity.  presentation registerAnnouncements.  presentation selection: 3.  entity removeLast.  announcer announce: GLMTestAnnouncement.  self assert: presentation selection isNilreceive: aTransmission in: aContext  self value: aTransmission value in: aContextchildren: anObject  children := anObjectbrick: aBrick  brick := aBrickshowOrHideScrollBar  self pagerModel size > self pagerModel minimumPageNumberForScrollbar & self showScrollBarWhenNeeded ifTrue: [ (self hasSubbrick: self pagerBar) ifFalse: [ self addBrickBack: self pagerBar ] ] ifFalse: [ self removeBrick: self pagerBar ]custom: aBrick  self flag: 'for now we only allow one subbrick in the composite.	We have to revisit this implementation after the composite will allow for multiple subbricks'.  self hasSubbricks ifFalse: [ self addBrickBack: aBrick ].  ^aBrickwithAllPresentations  | result |  result := OrderedCollection new.  self withAllPanesAndPresentationsDo: [:each |  (each isKindOf: GLMPresentation) ifTrue: [ result add: each ] ].  ^resultmarkHeightDirty  ^self brick wrappedBounds markHeightDirtyvSpaceFill: anInteger  super vSpaceFill: anInteger.  self isCentered ifTrue: [ self beCentered ]intercellSpacing  ^self parameters at: 'intercellSpacing' ifAbsent: [ self class defaultIntercellSpacing ]initialize  super initialize.  self     useVerticalLinearLayout;     vShrinkWrapopenBelow: aRectangle  ^self openAt: aRectangle originhasMaxDimensionRestriction: aBrick  ^aBrick layout hasMaxWidthselectionAct: aBlock iconName: aSymbol entitled: aString  self selectionAct: aBlock icon: (self iconNamed: aSymbol) entitled: aStringpaddingTop  ^self padding at: TopisHShrinking  ^hResizing = #shrinkWrapdynamic  ^self custom: GLMDynamicPresentation newdeselect: anEvent  super deselect: anEvent.  unhoverAction ifNotNil: [:a |  a brickValue: self withEnoughArguments: {anEvent} ]testAccordionExpanded  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a accordionArrangement.        a list title: 'List'.        a text title: 'Text' ].  window := browser openOn: 42.  self assert: self compositePanel submorphs first expanded.  self assert: self compositePanel submorphs last expanded notvalue  < debuggingStone: #transmissionTransformation label: 'Transmission transformation'>  | originalValue |  originalValue := self originReferences size = 1 ifTrue: [ self originReferences first value ] ifFalse: [ GLMMultiValue withAll: (self originReferences collect: [:each |  each value ]) ].  ^self transformation ifNil: [ originalValue ] ifNotNil: [ self transformation glamourValue: originalValue asGlamorousMultiValue , self origins asGlamorousMultiValue ]morphFrom: anActionListPresentation  | buttonsContainer buttonModel button |  buttonsContainer := self rectangleMorphFrom: anActionListPresentation.  anActionListPresentation allActions do: [:each |  buttonModel := GLMButtonModel new.        buttonModel glamourPresentation: anActionListPresentation.        buttonModel glamourAction: each.        button := self buttonMorph: buttonModel.        buttonsContainer addMorphBack: button.        button width: self class defaultWidth ].  ^buttonsContainerlayoutBounds: aRectangle  seenTransmissions  ^seenTransmissions ifNil: [ seenTransmissions := OrderedCollection new ]shadowWidth  ^0entity: anObject  entity := anObject.  self initializeColumnsdisplay: anObject  self setProperty: #phlowDisplay toValue: anObjectupdatePageAtIndex: anInteger withLabel: aStringOrMorph toolbar: aToolbar action: anActionMorph  (self pages at: anInteger) toolbar: aToolbar.  self relabelPage: (self pages at: anInteger) with: (self buildLabelFrom: aStringOrMorph withAction: anActionMorph).  self tabSelectorMorph selectedIndex = anInteger ifTrue: [ self updatePageIndex: anInteger ]enable  isEnabled := trueacceptContents: aString  self flag: #TODO.  self model ifNotNil: [:aModel |  aModel acceptContents: aString ]postCopy  ports := ports copyresetContents  contents := nilact: aBlock iconName: aSymbol on: aCharacter entitled: aString  self act: aBlock icon: (self iconNamed: aSymbol) on: aCharacter entitled: aStringelementsSorted  elements ifNil: [ ^nil ].  ^columnToSortBy ifNotNil: [ elements sorted: self sortBlock ] ifNil: [ self calculateElements ]defaultStyler  ^nilbrickBounds: aRectangle  bounds := aRectangle ceiling.  self updateCachehelp  ^helprubricBorderColor: aColor  self setProperty: #brickRubricBorderColor toValue: aColor.  self updateStyledefaultNumberOfVisiblePages: anInteger  self size = 0 ifFalse: [ GLMPagerException signal: 'You can change default number of visible pages only when there is no pages' ].  numberOfVisiblePages := anIntegerupdateWithString: string from: aMorph  textMorph textArea     updateTextWith: string;     takeKeyboardFocus;     on: Character escape do: [ self delete.        aMorph textArea removeHighlightSegment.        aMorph takeKeyboardFocus ];     on: PharoShortcuts current cancelShortcut do: [ self delete.        aMorph textArea editor cancel.        aMorph takeKeyboardFocus ];     on: Character backspace do: [ self delete.        aMorph textArea removeHighlightSegment.        aMorph takeKeyboardFocus ];     onAnnouncement: MorphLostFocus do: [:ann |  self delete.        aMorph textArea removeHighlightSegment ]receive: aTransmission  self receive: aTransmission in: GLMTransmissionContext newinitialize  super initialize.  self     useVerticalLinearLayout;     bar: self newBarhState  ^hStateouterPortEvent: aPortEvent  | toReplace |  super outerPortEvent: aPortEvent.  aPortEvent port name = #entity ifFalse: [ ^self ].  self panes isEmpty ifFalse: [ toReplace := self panes first.        panes := nil.        self addPaneFromOuter: aPortEvent port.        self announce: (GLMPaneReplaced oldPane: toReplace newPane: self panes first fromBrowser: self) ] ifTrue: [ self addPaneFromOuter: aPortEvent port.        self announce: (GLMPaneAdded pane: self panes last atPosition: self panes size inBrowser: self) ]shouldDoStep  ^self glamourPresentation stepCondition cull: selfinitialize  super initialize.  parameters := Dictionary newisFitsInParent  ^self owner ifNil: [ self brickBounds containsRect: (self outerBounds origin extent: self textSize) ] ifNotNil: [ self owner brickBounds width >= self textSize x ]isDependenciesShown: aBoolean  isDependenciesShown := aBooleanlabelMorph: anObject  labelMorph := anObjectopen  ^self openWith: self defaultRendereraddFastTableIn: container  container addMorphBack: tableMorphupdateHeight: aBrick on: aLayout  aBrick withHeight: (aLayout normalizeHeight: (aLayout heightChildrenDependency: aBrick) of: aBrick)checkboxCheckedImage  ^GLMUIThemeExtraIcons glamorousAccepthasFixedSizePanes  ^hasFixedSizePanes ifNil: [ hasFixedSizePanes := true ]isSingle  ^self isMultiple notinstallDefaultSelectionActions  self defaultSelectionActions do: [:anAction |  self addSelectionAction: anAction ]testCachedMatchingPresentations  | aPane cachedMatchingPresentations |  aPane := GLMPane in: nil.  cachedMatchingPresentations := aPane cachedMatchingPresentations.  self assert: cachedMatchingPresentations identicalTo: aPane cachedMatchingPresentations.  aPane matchingPresentations.  self assert: cachedMatchingPresentations ~~ aPane cachedMatchingPresentationssettingsButtonBrick  ^settingsButtonBrickaddVariableBindingsOn: aTextModel from: aPresentation  aPresentation variableBindings do: [:each |  aTextModel addVariableBinding: each ]initialize  super initialize.  self     hShrinkWrap;     vShrinkWrap;     enableevaluateAndPrintSelection  UIManager default defer: [ textMorph printIt ]height: anObject  < brickBuilderProperty: #Geometry name: 'Height' as: #asInteger getter: #height model: #GLMUIBuilderTextFieldProperty>  self privateHeight: anObject.  self updateHeightisWidthClean  ^self widthState = #cleanwidthRight: anInteger  self width at: Right put: anIntegerperform: aBlock delay: anInteger priority: aPriority  self execute: [  ] withArguments: {} callback: aBlock priority: aPriority delay: anIntegertestCompositeWithinCompositePanePropagation  | composite0 composite1 composite21 composite22 pane |  composite0 := GLMCompositePresentation new.  composite1 := GLMCompositePresentation new.  composite21 := GLMCompositePresentation new.  composite22 := GLMCompositePresentation new.  composite21 add: GLMPresentation new.  composite1 add: composite21.  composite22 add: GLMPresentation new.  composite1 add: composite22.  composite0 add: composite1.  pane := GLMPane new.  pane presentations: composite0.  self assert: composite0 first first first pane equals: pane.  self assert: (composite0 first at: 2) pane equals: pane.  self assert: composite0 first first first pane equals: pane.  self assert: (composite0 first at: 2) first pane equals: panerowHeight: aNumber  self parameters at: 'rowHeight' put: aNumberpresentation: anObject  presentation := anObjectmodel: anObject  model := anObjecttestResettingTheSelection  | composite textPresentation |  composite := GLMCompositePresentation new with: [:a |  a text display: '123456789' ].  window := composite openOn: 4.  textPresentation := composite presentations first.  textPresentation selectionInterval: (2 to: 5).  self shouldnt: [ textPresentation selectionInterval: nil ] raise: ErrortestDefault  | browser textMorph |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a pharoScript display: '123456789' ].  window := browser openOn: 4.  textMorph := window submorphs last submorphs first submorphs first.  self assert: (textMorph isKindOf: RubScrolledTextMorph)showScrollBar  self scrollBarIsVisible ifTrue: [ ^self ].  self resizeScrollBar.  self addMorphFront: scrollBar.  self adjustPaneHeightmorphicAct: aBlock on: aCharacter icon: anIcon entitled: aString  self addAction: (GLMMorphicAction new           action: aBlock;           shortcut: aCharacter;           icon: anIcon;           title: aString;           yourself)selection: anObject  (self pane port: #rawSelection) value: anObject.  self acceptsSelection ifFalse: [ ^self ].  rawSelectionTransmissions do: #transmitnewCheckbox  ^GLMCheckboxBrick new margin: #(3 0)addPresentations: aCollection  textModel  ^textModel ifNil: [ textModel := '' ]onResized  self setWidthAfterResizingshouldShowTitle  ^shouldShowTitle ifNil: [ shouldShowTitle := false ]displayValue  ^columnToSortBy ifNil: [ self glamourPresentation displayValue ] ifNotNil: [ self glamourPresentation displayValue sorted: self sortBlock ]evaluateSelectionAndDo: aBlock  self announce: (GLMEvaluateSelection new action: aBlock)hideHeader  shouldShowHeader := falsedeselect  super deselect.  self announcer announce: (GLMPagerButtonDeselected new buttonModel: self)fullDrawOn: aCanvas  super fullDrawOn: (aCanvas copyClipRect: self fullBounds)renderTextPresentation: aTextPresentation  ^GLMMorphicTextRenderer render: aTextPresentation from: selftestMarkerOneParentInParentHeight  | root brick |  root := self newBrickWithFullFill.  brick := self newBrickWithFullFill.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthClean.  self assert: brick wrappedBounds isHeightDirty.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightCleanannounce: anAnnouncement  self announcer announce: anAnnouncementscrollpaneBackgroundColor  ^self valueOfProperty: #brickScrollpaneBackgroundColor ifAbsent: [ self themer scrollpaneBackgroundColor ]hintBrick  ^hintBricknotifyPagePoppedAndReplaced: aBrick  self notifyAll: (GLMPagePopedAndReplaced new brick: aBrick)onChildrenLayouted  super onChildrenLayouted.  self band translateY: self scrollPositionTopdefaultRenderer  ^GLMRenderer subclasses first newsubmit  ^self addBrickBack: (self newButton           text: 'Submit';           when: #onClicked do: [ self submitForm ])smalltalkCode  self deprecated: 'Use #pharoMethod (if you need to display a method) 	or #pharoScript (if you need to display snippets of code that do not belong to a method)'.  ^self custom: GLMSmalltalkCodePresentation newdisplayText  ^UITheme current newTextIn: self currentWorld text: (self item presentations titleValue ifNil: [ 'noname' ])hoverIcon: anImage  self selectedImage: anImage.  self doLayoutForceinitialize  super initialize.  self initializeTextMorphaccordionArrangement  ^self arrangement: GLMAccordionArrangement newglobalBoundsTranslateFactor  ^self owner ifNotNil: [ self owner globalBoundsTranslateFactor + self brickBounds origin ] ifNil: [ 0 @ 0 ]dragPassengerFor: item inMorph: listMorph  ^self glamourPresentation transformedDraggedItem: item complexContents itemsmooth  ^smoothto: aPaneSymbol port: aPortSymbol  ^self to: (GLMPortIdentifier pane: aPaneSymbol port: aPortSymbol)brickBounds: aRectangle  ^self brick brickBounds: aRectangleinitialize  announcements := OrderedCollection newnotifyAll: anAnnouncement  self isNotificationsAllowed ifTrue: [ self announcer announce: anAnnouncement ]textPosition  ^textPositionnotifyPagePoped: isSmooth  self notifyAll: (GLMPagePoped new smooth: isSmooth)normalBorderStyleFor: aBrick  ^BorderStyle simple     width: 1;     baseColor: Color transparentrenderListPresentation: aListPresentation  ^GLMMorphicListRenderer render: aListPresentation from: selfgetText  ^self displayLogic phlowValue: self entityhasShortcut  ^self keymap notNilprivateAddBrick: aBrick after: otherBrick  | brick link otherLink otherLinkSuccessor index |  brick := aBrick asBrick.  otherLink := otherBrick brickDoubleLink.  otherLink = self lastSubbrick brickDoubleLink ifTrue: [ ^self privateAddBrickBack: aBrick ].  link := brick asDoubleLink.  brick brickDoubleLink: link.  otherLinkSuccessor := otherLink nextLink.  otherLink nextLink: link.  link previousLink: otherLink.  link nextLink: otherLinkSuccessor.  otherLinkSuccessor previousLink: link.  index := (self subbricks indexOf: otherBrick) + 1.  self privateSubbricks: (self subbricks copyReplaceFrom: index to: index - 1 with: (Array with: brick)).  brick owner: self.  ^aBricktestFromPort  browser transmit from: #one port: #port.  self assert: browser transmissions first origins first pane equals: browser panes first.  self assert: browser transmissions first origins first name equals: #portinitialize  super initialize.  self themer: self themer actionThemer.  onCreatedBlock := [  ]last  ^self presentations lastupdateToolbar  self announce: (GLMPresentationToolbarUpdated new presentation: self presentations)vShrinkWrap  self vResizing: #rigid.  self height: #approximateHeightresetData  list := nil.  selectionIndex := niltestUpdateOnFromAllPortsUpdate  | pane presentation announcers col updated |  col := (1 to: 4) asOrderedCollection.  pane := GLMPane named: 'test'.  presentation := GLMListPresentation new.  announcers := col collect: [:each |  Announcer new ].  pane addPresentation: presentation.  presentation updateOn: GLMTestAnnouncement fromAll: [ announcers ].  presentation when: GLMPresentationUpdated do: [:a |  updated := true ].  presentation entity: col.  presentation shouldValidate: true.  presentation registerAnnouncements.  updated := false.  announcers last announce: GLMTestAnnouncement.  self assert: updated.  updated := false.  announcers last announce: GLMTestAnnouncement.  self assert: updatedenableFilter: aBlock  self enableFilter.  self parameters at: 'filterBlock' put: aBlockinitializeShortcuts  self bindKeyCombination: Character arrowLeft alt command toAction: [ self pagerModel selectToLeft ].  self bindKeyCombination: Character arrowRight alt command toAction: [ self pagerModel selectToRight ].  self bindKeyCombination: Character arrowLeft alt shift command toAction: [ self pressedScrollerSizeCombination: #left ].  self bindKeyCombination: Character arrowRight alt shift command toAction: [ self pressedScrollerSizeCombination: #right ]defaultPageSize  ^defaultPageSizetagsFilter: aBlock  tagsFilterBlock := aBlockupdate  self notingPresentationChangeDo: [  ].  self presentations do: [:each |  each update ]hintModifier  ^hintModifier ifNil: [ hintModifier := #shift ]testExplicitTransmission  | finder |  finder := GLMFinder new.  finder transmit     fromOutsidePort: #entity;     toOutsidePort: #selection.  finder startOn: 42.  self assert: (finder pane port: #selection) value equals: 42stepTime  ^self glamourPresentation stepTimetitle: anObject  self setProperty: #phlowTitle toValue: anObjectglobalBounds  ^self owner ifNotNil: [ self brickBounds translateBy: self owner globalBoundsTranslateFactor ] ifNil: [ self brickBounds ]heightParentDependency: aBrick  aBrick owner ifNil: [ Exception signal: 'My height depends on parent, but it is nil' ].  ^(aBrick owner innerBounds height * aBrick layout vPercent / 100) ceilingcolumn: aBlockOrString evaluated: aBlock tags: anObject sortedBy: aSortingBlock  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           tags: anObject;           sortBlock: aSortingBlock)onCreated  | theContentBricks |  theContentBricks := onCreatedBlock brickValue: self withEnoughArguments: {self triggerBrick}.  theContentBricks := theContentBricks asOrderedCollection select: #isNotNil.  self contentBrick addAllBricks: theContentBricksbuttonSelectedColor  ^Color veryDarkGray lighter slightlyDarkerstep: anObject  stepLogic := anObjectpopupError: aString  (GLMErrorPopper new withString: aString from: self editor textArea owner owner owner) openInWorldregisterModule: aModule to: aThemer named: aString  ^self modules at: aString ifAbsent: [ aThemer addModule: aModule value named: aString ]scrollValue: value  currentScrollDelta := value.  self band doNotLayoutDuring: [:b |  b translateXTo: self scrollValue ].  self changedlayoutAfter: aBlock  self doNotLayoutDuring: aBlock.  self doLayoutonPagePreviewUpdate: updateAnnouncement  GLMPagerPanePreviewMorph uniqueInstance updateFor: (self paneAt: updateAnnouncement pageIndex)updateStyle  self color: self rubricBackgroundColor.  self rubric borderColor: self rubricBorderColor.  self rubric borderWidth: self rubricBorderWidth.  self rubric textColor: self rubricTextColor.  self rubric font: (LogicalFont familyName: self rubricTextFamilyName pointSize: self rubricTextFontSize).  self rubric cursor visibleCursorColor: self rubricCursorColormorph  ^morphBuilder glamourValue: self asGlamorousMultiValue , self displayValue asGlamorousMultiValuemorphicAct: aBlock on: aCharacter entitled: aString  self addAction: (GLMMorphicAction new           action: aBlock;           shortcut: aCharacter;           title: aString;           yourself)update  self hasItems ifFalse: [ ^self ].  isUpdating := true.  self updateVisible.  self doNotLayoutDuring: [ | delta |        delta := self bandTopOffset + self topOffset.        self band doLayoutForce.        self band translateY: delta ].  self preventOverscrolling.  self verticalScrollbar updatePosition.  isUpdating := falseinitialize  super initialize.  self color: Color transparent.  self theme pagerWidgetThemer previewPaneStyleFor: self.  self borderWidth: self defaultBorderWidthprivateAddIntoWorld: aBrick  self world == aBrick world ifFalse: [ self privateRemoveOutWorld: aBrick ].  aBrick intoWorld: self worldtestCopy  | transmission newTransmission |  transmission := GLMTransmission new.  transmission addActiveOrigin: (GLMSimplePort new           name: #port1;           value: 1).  transmission addPassiveOrigin: (GLMSimplePort new           name: #port2;           value: 2).  transmission addActiveOrigin: (GLMSimplePort new           name: #port3;           value: 3).  transmission addPassiveOrigin: (GLMSimplePort new           name: #port4;           value: 4).  transmission destination: (GLMSimplePort new name: #port5).  newTransmission := transmission copy.  self assert: transmission originReferences first ~= newTransmission originReferences firstbeError  self themer: self themer popupErrorThemer themervalue: anObject in: aContext  aContext addPort: self.  self silentValue: anObjecttextSecondaryColor  ^Color r: 25 g: 35 b: 45 range: 255privateAddBrickFirst: aBrick  | link head tail brick |  brick := aBrick asBrick.  head := nil.  tail := nil.  self hasSubbricks ifTrue: [ head := self firstSubbrick brickDoubleLink.        tail := self lastSubbrick brickDoubleLink ].  link := brick asDoubleLink.  brick brickDoubleLink: link.  link nextLink: head.  head ifNotNil: [ head previousLink: link ].  self privateSubbricks: (self subbricks copyWithFirst: brick).  brick owner: self.  ^aBrickmaxPanes  ^maxPanestestPane  | pane composite presentation |  pane := GLMPane new.  composite := GLMCompositePresentation new.  presentation := GLMPresentation new.  composite add: presentation.  composite pane: pane.  self assert: composite pane identicalTo: pane.  self assert: composite first pane identicalTo: panescrollbarCornerRadius: anInteger  self setProperty: #brickScrollbarCornerRadius toValue: anInteger.  self updateStylesubbricks  ^self submorphstestSimpleTransmissionWithTransformation  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     from: #one port: #port1;     fromOutsidePort: #entity;     to: #two port: #port2;     when: [:one :outer |  one notNil and: [ outer notNil ] ];     transformed: [:one :outer |  one + outer ].  browser startOn: 2.  self assert: ((browser paneNamed: #two) port: #port2) value isNil.  ((browser paneNamed: #one) port: #port1) value: 40.  self assert: ((browser paneNamed: #two) port: #port2) value equals: 42getAndRemoveInvisibleMorph: aCollection  | brick |  brick := self retrieveLast: aCollection.  ^brick ifNotNil: [ self removeBrickNoLayout: brick.        brick morph ]callback  ^callbackrenderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderPresentation: selfprevious: aVector  previous := aVectorlayoutFloating: aBrick in: newBounds  | float symbol |  float := aBrick layout floating.  symbol := self floatingMethodFor: float.  ^(self respondsTo: symbol) ifTrue: [ self perform: symbol with: aBrick with: newBounds ] ifFalse: [ 0 ]testToSend  | presentation |  presentation := GLMPresentation new.  presentation selection: #foo.  self assert: presentation selection equals: #foo.  presentation selection: #(#foo #bar).  self assert: presentation selection equals: #(#foo #bar).  presentation selectionTransformation: [:first :second |  (first , second) asSymbol ].  presentation selection: (GLMMultiValue withAll: #(#foo #bar)).  self assert: presentation selection equals: #foobarselectionTransformation: anObject  self selectionTransmission transformation: anObjectcalculateElements  ^self tagsToFilterBy ifEmpty: [ self basicElements ] ifNotEmpty: [ self basicElements select: [:each |  self elementShouldBeDisplayed: each ] ]glamourPresentation  ^glamourPresentationpagerModel: anAdapter  pagerModel := anAdapter.  pagerModel announcer when: GLMNumberOfVisiblePagesChanged send: #onResized to: self.  pagerModel announcer when: GLMPagerScrollPositionChanged send: #onPositionChanged: to: self.  self width: self computeWidthalign: aBrick in: parentBrick anchorPoint: aPoint inContext: aContext  | align |  self = aContext ifTrue: [ ^self ].  parentBrick subbricks size = 1 & aContext isNil ifTrue: [ GLMHorizontalLinearLayout uniqueInstance align: aBrick in: parentBrick anchorPoint: aPoint inContext: self ].  align := aBrick layout hAlign.  align = #none ifTrue: [ ^self ].  align = #left ifTrue: [ ^self ].  align = #center ifTrue: [ ^aBrick translateX: ((parentBrick innerBounds width - aBrick outerBounds width) / 2) asInteger ].  align = #right ifTrue: [ ^aBrick translateX: (parentBrick innerBounds width - aBrick outerBounds width) asInteger ]selectedText  ^selectedTexttestConditionWhenEmbedded  | expander tabulator |  expander := GLMExpander new.  expander display: [:x :y |  x + y ].  expander show: [:a |  a text display: [:x :y |  x asString , y asString ] ].  tabulator := GLMTabulator new.  tabulator     column: #one;     column: #two.  tabulator transmit     to: #two;     fromOutsidePort: #entity;     from: #one port: #nilPort;     andShow: [:a |  a custom: expander ].  self shouldnt: [ tabulator startOn: 1 ] raise: ErroractiveTitleFillStyle  ^SolidFillStyle color: Color transparentstepTime  ^self model stepTimeassertBrickDirty: aBrick  self assertWidthDirty: aBrick.  self assertHeightDirty: aBrickdoubleClick: anEvent  self announce: #onDoubleClicked event: anEvent.  ^falsevPercent: anInteger  vState := self vState onParentDo: [:s |  s percent: anInteger ]action: aBlock  action := aBlockopenOn: anObject  ^self openOn: anObject with: self defaultRendererbrowser  ^browseroldPane  ^oldPanecacheAt: aKey for: anElement ifAbsentPut: aBlock  | elementCache |  self shouldUseCache ifFalse: [ ^aBlock value ].  elementCache := self dataCacheFor: anElement.  (elementCache includesKey: aKey) ifTrue: [ ^elementCache at: aKey ].  ^aBlock value ifNotNil: [:anObject |  elementCache at: aKey ifAbsentPut: [ anObject ] ]valueBlock: anObject  valueBlock := anObjectdrawOn: aCanvas  aCanvas translateBy: self globalBounds origin - self brickBounds origin during: [:canvas |  self onDraw: canvas ]render: aBrick on: aCanvas  self     renderShadowOf: aBrick on: aCanvas;     renderBackgroundColorOf: aBrick on: aCanvas;     renderColorOf: aBrick on: aCanvas;     renderImageOf: aBrick on: aCanvas;     renderBorderOf: aBrick on: aCanvasannouncer  iconProvider  ^(Smalltalk respondsTo: #ui) ifTrue: [ (Smalltalk perform: #ui) icons ] ifFalse: [ UITheme current ]contents  ^self childrenItemshasHeightRestrictions: aBrick  ^aBrick layout hasMinHeight | aBrick layout hasMaxHeightshadowOffset  ^0.5 @ 0.5testEnlargeToRight  | counter left |  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel scrollTo: 0.0 smooth: false.  counter := pagerModel numberOfVisiblePages.  left := pagerModel firstVisiblePageIndex.  self assert: pagerModel numberOfVisiblePages equals: counter.  self assert: pagerModel numberOfVisiblePages equals: pagerModel lastVisiblePageIndex - left + 1.  self assert: pagerModel firstVisiblePageIndex equals: left.  [ counter < 6 ] whileTrue: [ counter := counter + 1.        pagerModel enlargeToRight.        self assert: pagerModel numberOfVisiblePages equals: counter.        self assert: pagerModel numberOfVisiblePages equals: pagerModel lastVisiblePageIndex - left + 1.        self assert: pagerModel firstVisiblePageIndex equals: left ].  (1 to: 3) do: [:i |  pagerModel enlargeToRight.        self assert: pagerModel numberOfVisiblePages equals: 6.        self assert: pagerModel numberOfVisiblePages equals: pagerModel lastVisiblePageIndex - left + 1.        self assert: pagerModel firstVisiblePageIndex equals: left.        self assert: pagerModel lastVisiblePageIndex equals: 6 ]testPanesHaveDifferentRegistries  | browser |  browser := GLMFinder new.  browser addPresentation: (GLMPresentation new title: 'presentation1').  self assertEmpty: browser panes.  (browser pane port: #entity) value: #value1.  self assert: browser panes size equals: 1.  (browser panes first port: #selection) value: #value2.  self assert: browser panes size equals: 2.  self deny: (browser panes first instVarNamed: 'registry') identicalTo: (browser panes second instVarNamed: 'registry')nodeModelFor: anObject  ^GLMExpanderLabelNodeModel with: anObject in: selftestCompositeWithinCompositeOuterPortEvents  | childComposite finder parentComposite count |  count := 0.  childComposite := GLMCompositePresentation new.  finder := childComposite finder.  finder show: [:a |  a list display: [:x |  1 to: x ] ].  finder when: GLMPaneAdded do: [:a |  count := count + 1 ].  parentComposite := GLMCompositePresentation new.  parentComposite custom: childComposite.  parentComposite startOn: 10.  self assert: count equals: 1widthTop: anInteger  self width at: Top put: anIntegerupdateContextWith: aPane  vSpaceFill: anInteger  self vPercent: anIntegermenu  ^self menu: MenuMorph newrootNodes  ^self rootsexecute: aBlock withArguments: aCollection callback: callbackBlock  ^self execute: aBlock withArguments: aCollection callback: callbackBlock priority: Processor userSchedulingPriorityactionThemer  ^GLMActionBrickDarkThemer newtestUpdateConditionallyTriggered  | pane presentation announcer timesTriggered |  pane := GLMPane named: 'test'.  (pane port: #entity) value: 40.  presentation := GLMPresentation new.  announcer := Announcer new.  pane addPresentation: presentation.  timesTriggered := 0.  presentation when: GLMPresentationUpdated do: [:announcement |  timesTriggered := timesTriggered + 1 ].  presentation updateOn: GLMTestAnnouncement from: [:x |  announcer ] when: [:ann :entity |  ann parameter + entity = 42 ].  presentation registerAnnouncements.  announcer announce: (GLMTestAnnouncement new parameter: 0).  self assert: timesTriggered equals: 0.  announcer announce: (GLMTestAnnouncement new parameter: 2).  self assert: timesTriggered equals: 1newTransmission  ^self transmission copyisExpanded  ^self hasSubbrick: self contentBrickenableSearch  self parameters at: 'isSearchable' put: truevalue: anObject in: aContext  self subclassResponsibilityend  ^endbeBold  self font forceBoldhPadding  ^self paddingLeft + self paddingRightcompileTextIn: aContext from: aSession andDo: aBlock  self announce: (GLMCompileText new           presentation: self;           context: aContext;           session: aSession;           action: aBlock)nodeModelFor: anObject  ^(GLMTreeMorphNodeModel with: anObject)     containerTree: self;     yourselfpopupEditorBorderThemer  ^self registerModule: GLMBrickPopupEditBorderThemer new to: self named: #popupThemerselectedPaneStyleFor: aMorph  aMorph borderColor: Color transparentmaxPanes: anInteger  maxPanes := anIntegersearchOn: aBlock  self error: 'This presentation does not allow searching with a block for now. In the futur we should have a new filter with FastTable to do that. If you want to give it a try look FTFunction and his subclasses.'notifyScrollerBoundsChanged: aBounds  self notifyAll: (GLMPagerBoundsChanged new bounds: aBounds)testGlamourValue  self assert: ([ #foo ] glamourValue: #(1 2)) equals: #foo.  self assert: ([:first |  Array with: first ] glamourValue: #(1 2)) equals: #(#(1 2)).  self assert: ([:first :second |  Array with: first with: second ] glamourValue: #(1 2)) equals: #(#(1 2) nil).  self assert: ([:first :second |  Array with: first with: second ] glamourValue: (GLMMultiValue with: 1 with: 2)) equals: #(1 2).  self assert: (#yourself glamourValueWithArgs: #(1 2)) equals: 1.  self assert: (#yourself glamourValueWithArgs: #()) equals: nilindex: anObject  index := anObjecttable  ^self custom: GLMPhlowTableBrick newat: aNumber  ^self presentations at: aNumberwithColumns: aBoolean  withColumns := aBooleanresizeScrollBar  | inner outer |  outer := super innerBounds.  inner := outer withHeight: outer height - self scrollBarHeight.  scrollBar bounds: (inner left @ inner bottom corner: outer bottomRight)createDataSourceFrom: aPresentation  ^GLMFastTreeDataSource newisDropTarget  ^self dropOnItemBlock notNilmaxPanes  ^maxPanesdeselect: anEvent  self deselectrenderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderPharoScriptPresentation: selftree  ^self find: MorphTreeMorph in: windowrenderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderPharoMethodPresentation: selfpopup  ^popupmorphicActOn: aPresentation  ^self actOn: aPresentationstylerStyledInBackground: styledCopyOfText  next ifNil: [ ^self ].  text string = styledCopyOfText string ifTrue: [ self stylerStyled: styledCopyOfText ]isClean: aBrick  ^self subclassResponsibilityinitializeTransform  transform := TransformMorph new.  transform     color: Color transparent;     borderWidth: 0;     vResizing: #spaceFill;     hResizing: #spaceFill;     disableTableLayout;     bounds: super innerBounds.  self addMorphBack: transformvirtualFirstVisiblePageIndex  ^virtualFirstVisiblePageIndexdelay: anInteger  delay := anIntegerinitializeLayout  self popupLayout build: self trigger: self newTriggerBrick content: self newContentBricktestStackedVertically  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a stackedVerticallyArrangement.        a list title: 'list'.        a text title: 'text' ].  window := browser openOn: 42.  self assert: self compositeMorph class equals: GLMPanelMorph.  self assert: self compositeMorph submorphs size equals: 2.  self assert: self compositeMorph submorphs size equals: 2.  self assert: self compositeMorph submorphs first class equals: LazyTabGroupMorphnewTriggerBrick  ^GLMActionButtonBrick new     hShrinkWrap;     vShrinkWrap;     yourselfnewBand  ^GLMHorizontalBandBrick newwantsAutomaticRefresh  ^wantsAutomaticRefresh ifNil: [ false ]updateHeight  self layout isHeightCustom ifFalse: [ ^self ].  [ self bounds: (self brickBounds withHeight: self customHeight) ] on: Exception do: [  ]icon: anObject  icon := anObjectupdate  self pane ports do: [:each |  (self validate: each value on: each) ifFalse: [ each resetValue ] ].  self presentations do: [:each |  each update ].  self announce: (GLMPresentationUpdated new presentation: self)selectTable: aTable element: anObject  aTable selectIndex: (self elements indexOf: anObject)newTextBrick  ^GLMRubScrolledTextBrick newdragTransferType  ^#Glamourtext  ^next textfrom: aPort  ^self addActiveOrigin: (self browser resolveOriginPort: aPort)isFirstInOwner  ^self brickDoubleLink ifNotNil: [:bdl |  bdl hasPredecessor not ] ifNil: [ false ]themeChanged  self isSelected ifTrue: [ self themer tabLabelThemer selectedStyleFor: self ] ifFalse: [ self themer tabLabelThemer normalStyleFor: self ].  super themeChangedtestDefaultCompositePresentation  | pane |  pane := GLMPane named: 'test'.  self assert: (pane presentations isKindOf: GLMCompositePresentation)defaultRenderer  ^GLMRenderer subclasses first newtagsToFilterBy  ^tagsToFilterBy ifNil: [ tagsToFilterBy := OrderedCollection new ]privateThemer  ^self valueOfProperty: #brickThemer ifAbsentPut: [ nil ]withBindingsDo: aBlock  self announce: (GLMVariableBindingsAccessRequest new action: aBlock)onThemerChanged  super onThemerChanged.  self updateStyletestValidate  | pane presentation |  pane := GLMPane named: 'test'.  presentation := GLMListPresentation new.  pane addPresentation: presentation.  presentation entity: (OrderedCollection with: 1 with: 2).  presentation shouldValidate: true.  self assert: ((pane port: #selection) validate: 1).  self assert: ((pane port: #selection) validate: 2).  self deny: ((pane port: #selection) validate: 5)allSatisfy: aBlock  ^self presentations allSatisfy: aBlockrender: anAction  | b |  b := GLMPluggableButtonMorph on: anAction getState: nil action: self actionSelector.  b     theme: UITheme current;     arguments: (self actionArguments ifNil: [ {b} ]);     cornerStyle: (UITheme current buttonCornerStyleIn: nil);     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     getEnabledSelector: nil;     setBalloonText: ((anAction help ifNil: [ anAction title ]) , Character tab asString , anAction shortcutAsString) trimBoth;     extent: b minExtent;     removeProperty: #theme.  anAction shouldShowTitle ifTrue: [ b           icon: anAction icon;           label: anAction title font: UITheme current buttonFont ] ifFalse: [ b label: (AlphaImageMorph new image: anAction icon) ].  b     valueOfProperty: #noBorder ifAbsentPut: [ true ];     valueOfProperty: #noFill ifAbsentPut: [ true ];     setProperty: #wantsKeyboardFocusNavigation toValue: false;     borderWidth: 0.  ^bentity: anObject  super entity: anObject.  self installEntityresetBindings  self withBindingsDo: [:bindings |  bindings removeAll ]selectionPopulate: aPortSymbol entitled: aString with: aBlock  self addSelectionAction: (GLMGenericAction new           action: (GLMPortUpdater new                 portSymbol: aPortSymbol;                 valueBlock: aBlock;                 yourself);           title: aString;           yourself)highlightSmalltalkContext  ^highlightSmalltalkContext ifNil: [ nil ] ifNotNil: [ highlightSmalltalkContext glamourValue: self entity ]treeMorphFor: tmpTreeModel and: aPresentation  | tmpTreeMorph columns |  tmpTreeMorph := self newTreeMorph.  tmpTreeMorph     makeLastColumnUnbounded;     doubleClickSelector: #onDoubleClick;     getMenuSelector: #menu:shifted:;     keystrokeActionSelector: #keyStroke:from:;     columnInset: 3;     rowInset: 1;     cornerStyle: tmpTreeMorph preferredCornerStyle;     borderStyle: (BorderStyle inset width: 1);     autoDeselection: aPresentation allowsDeselection;     dragEnabled: tmpTreeModel dragEnabled;     dropEnabled: tmpTreeModel dropEnabled;     hResizing: #spaceFill;     vResizing: #spaceFill;     layoutFrame: LayoutFrame identity.  columns := aPresentation columns isEmpty ifTrue: [ OrderedCollection with: (MorphTreeColumn new rowMorphGetSelector: #elementColumn) ] ifFalse: [ aPresentation columns collect: [:each |  GLMMorphTreeColumn new                 startWidth: each width;                 glamourColumn: each;                 headerButtonLabel: (aPresentation titleValueOfColumn: each) font: StandardFonts menuFont target: tmpTreeModel actionSelector: #sortByColumn: arguments: {each};                 yourself ] ].  tmpTreeMorph     preferedPaneColor: Smalltalk ui theme backgroundColor;     model: tmpTreeModel;     columns: columns.  aPresentation isMultiple ifTrue: [ tmpTreeMorph beMultiple ] ifFalse: [ tmpTreeMorph beSingle ].  tmpTreeMorph chunkSize: aPresentation amountToShow.  tmpTreeMorph pageSize: aPresentation amountToShow.  tmpTreeMorph vShowScrollBar.  tmpTreeMorph hShowScrollBar.  ^tmpTreeMorph buildContentscursorPosition: anObject  cursorPosition := anObjecttransformation  ^transformationadd: newObject beforeOrLast: oldObject  (collection includes: oldObject) ifTrue: [ collection add: newObject before: oldObject ] ifFalse: [ collection add: newObject ].  self announce: GLMItemAddeddepress  self isPressed ifTrue: [ isPressed := false.        self changed.        ^true ].  ^falseisModifierPressed: anEvent  self hintModifier ifNil: [ ^false ].  self hintModifier = #shift ifTrue: [ ^anEvent shiftPressed ].  self hintModifier = #option ifTrue: [ ^anEvent optionKeyPressed ].  self hintModifier = #alt ifTrue: [ ^anEvent altKeyPressed ].  self hintModifier = #command ifTrue: [ ^anEvent commandKeyPressed ].  self hintModifier = #control ifTrue: [ ^anEvent controlKeyPressed ].  ^falseactOnPresentationUpdated: anAnnouncement  container removeAllMorphs.  container addMorph: (self renderObject: anAnnouncement presentation currentPresentation) fullFrame: LayoutFrame identityrenderFastTreeWithColumnsPresentation: aPresentation  ^GLMMorphicFastTreeWithColumnsRenderer render: aPresentation from: selftextBackgroundColor  ^self containerTree glamourPresentation textBackgroundColorFor: self itemenableDoubleClick  isDoubleClickEnabled := trueborderWidth  ^self theme borderWidthtabWidth: anInteger  tabWidth := anIntegeractOn: aPresentation  ^self action glamourValueWithArgs: (Array with: aPresentation withAll: aPresentation entity asGlamorousArray)innerPortEvent: aPortEvent  testPushPanesBeforeOpen  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self openInWindow.  self assert: pagerModel size equals: 3.  self assert: self panesMorphs size equals: 3.  self assert: self buttonsMorphs size equals: 3shouldShowTitle: anObject  shouldShowTitle := anObjecttestPaneRemovedAnnouncement  | browser count |  count := 0.  browser := GLMFinder new.  browser when: GLMPaneRemoved do: [:ann |  count := count + 1 ].  browser startOn: #a.  self assert: count equals: 0.  (browser panes first port: #selection) value: #b.  self assert: count equals: 0.  (browser panes second port: #selection) value: #c.  self assert: count equals: 0.  (browser panes first port: #selection) value: #d.  self assert: count equals: 1pagerModel  ^pagerModelnormalImage  ^normalImagetransmitIn: aContext  self flag: 'The transmitIt: and receive:in: both end up calling notingPresentationChangeDo:. So they should be handled by a surrounding notingPresentationChangeDo:. However, by doing that it seems that we break the morphic updating. No idea why'.  self destination notingPresentationChangeDo: [ self transmissionStrategy transmitIn: aContext.        self destination receive: self in: aContext ].  self browser notNil ifTrue: [ self browser announce: GLMTransmissionTriggered new ]vAlign  ^vAlign ifNil: [ vAlign := #none ]list  ^self custom: GLMPhlowListBrick newwithChildrenOf: anObject do: aBlock  aBlock value: anObject.  (self childrenValueOf: anObject) do: [:each |  self withChildrenOf: each do: aBlock ]smooth  ^smoothcomputeAnnouncerObjects  self subclassResponsibilityaddColumn: aBlockOrSymbol size: anInteger  ^(self addColumn: aBlockOrSymbol)     size: anInteger;     span: 0morph  ^selfaddPaneFromOuter: aPort  | newPane |  newPane := self panes addLast: (GLMPane named: (self panes size + 1) asString in: self).  self newFirstTransmission     addActiveOrigin: aPort;     destination: (newPane port: #entity);     transmitdragTransferTypeForMorph: listMorph  ^self dragTransferTyperenderAccordionCompositePresentation: aCompositePresentation  ^GLMMorphicAccordionRenderer render: aCompositePresentation from: selfinitialize  super initialize.  dimension := self defaultDimensioninputText: anObject  inputText := anObject.  self doSearchOrFiltertestMarkerOneStaticWidth  | brick |  brick := self newBrickWithStaticExtent.  self markFullyClean: brick.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightCleantestValidateOn  | pane presentation |  pane := GLMPane named: 'test'.  presentation := GLMListPresentation new.  pane addPresentation: presentation.  presentation shouldValidate: true.  presentation entity: ($a to: $d).  self deny: (presentation validate: (Array with: $a) on: (pane port: #selection)).  self deny: (presentation validate: (Array with: $a with: $b) on: (pane port: #selection)).  self assert: (presentation validate: $a on: (pane port: #selection)).  self assert: (presentation validate: $b on: (pane port: #selection)).  self deny: (presentation validate: $z on: (pane port: #selection))sendTo: aDesinationPortReference fromOutside: anOriginPortName  self sendTo: aDesinationPortReference from: #outer -> anOriginPortNametestMarkerOneParentInStaticWidth  | root brick |  root := self newBrickWithStaticExtent.  brick := self newBrickWithFullFill.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightCleanselectedText: anObject  selectedText := anObjectnewVerticalScrollbar  ^GLMApproximateScrollbarBrick newvalue: anObject in: aContext  (self validate: anObject) ifFalse: [ ^self ].  aContext addPort: self.  self changeValueTo: anObject in: aContexttoValue  ^toValue ifNil: [ toValue := toLogic brickValue: self animatedObject ]onPagePushed: addedAnnouncement  self buttonsBrick onPagePushed: addedAnnouncement.  self recomputeScrollBarpanesMorphs  ^pagerMorph subbricks first subbricks first subbricksisDependsOnMyself: aBrick  ^(self stateOf: aBrick) isOnMyselftestCreation  | browser |  browser := GLMExpander new.  browser show: [:a |  a text ].  window := browser openOn: #(#a #b #c).  self assert: window submorphs last class equals: GeneralScrollPane.  self assert: window submorphs last scrollTarget submorphs size equals: 3.  self assert: window submorphs last scrollTarget submorphs first complexContents class equals: ExpanderMorphvalue  ^valueisDebug  ^trueisOppositeClean: aBrick  ^aBrick isHeightCleanname  ^namescrollbarColor  ^Color black alpha: 0.5cacheAt: aKey for: anElement ifAbsentPut: aBlock  | elementCache |  self shouldUseCache ifFalse: [ ^aBlock value ].  elementCache := self dataCacheFor: anElement.  (elementCache includesKey: aKey) ifTrue: [ ^elementCache at: aKey ].  ^aBlock value ifNotNil: [:anObject |  elementCache at: aKey ifAbsentPut: [ anObject ] ]border: aBorder  self setProperty: #brickBorder toValue: aBorderdefaultName  ^'undefined'hAlign: aSymbol  < brickBuilderProperty: #Layout name: 'Horizontal align' as: #asSymbol getter: #hAlign model: #GLMUIBuilderTextFieldProperty>  self layout hAlign: aSymbolsuspendAll  ^suspendAll ifNil: [ suspendAll := false ]vShrinkWrap  vState := self vState onChildrenDo: #yourselfpresentation  ^presentationnormalImage: anObject  normalImage := anObjecthasTagsFilter  ^self tagsFilterBlock notNiltestAllSelectionActionsWithSelection  | listing |  listing := GLMPresentation new.  listing addSelectionAction: GLMAction new.  listing addSelectionAction: GLMAction new.  listing selection: Object new.  listing dynamicActionsOnSelection: [:p |  OrderedCollection with: GLMAction new with: GLMAction new with: GLMAction new ].  self assert: listing allSelectionActions size equals: 5pagerModel: aModel  pagerModel := aModel.  maxPanes := aModel numberOfVisiblePages.  pagerModel announcer when: GLMPagePushed send: #onPagePushed: to: self.  pagerModel announcer when: GLMPagePoped send: #onPagePoped: to: self.  pagerModel announcer when: GLMPagePopedAndReplaced send: #onPagePopedAndReplaced: to: self.  pagerModel announcer when: GLMPagerSynchronizeScrollAnnouncement send: #onSynchronizeScroll: to: self.  pagerModel announcer when: GLMPagerScrollPositionChanged send: #onPositionChanged: to: self.  pagerModel announcer when: GLMNumberOfVisiblePagesChanged send: #onPagesNumberChanged to: self.  pagerModel announcer when: GLMSelectedPageChanged send: #onSelectedPageChanged to: self.  pagerModel announcer when: GLMPagerPreviewUpdate send: #onPagePreviewUpdate: to: selfsetScrollDeltas  | range interval value |  transform hasSubmorphs ifFalse: [ scrollBar interval: 1.0.        ^self ].  range := self leftoverScrollRange.  range = 0 ifTrue: [ ^scrollBar           interval: 1.0;           setValue: 0 ].  interval := (self innerBounds width / self totalScrollRange) asFloat.  value := (transform offset x / range min: 1.0) asFloat.  scrollBar interval: interval.  scrollBar setValue: valueuseVerticalLinearLayout  self layout: GLMVerticalLinearLayout uniqueInstancevalue  self flag: 'checking for #entity is rather not elegant, but it is a solution to not affect the other custom ports that will probably be desired to be populated in other ways.'.  ^self name == #entity ifTrue: [ self presentation transformation glamourValue: self port value asGlamorousMultiValue ] ifFalse: [ self port value ]sortBlock  ^sortBlockpressedColor  ^pressedColorcheckedColor: anObject  checkedColor := anObjecttestTriggerConditionsWithParentPort  | transmission presentation |  transmission := GLMTransmission new.  presentation := GLMPresentation new.  transmission addActiveOrigin: (GLMPresentationBoundPort new           presentation: presentation;           name: #port1;           yourself).  self assert: (transmission originatesAt: (GLMPresentationBoundPort new                 presentation: presentation;                 name: #port1;                 yourself)).  self assert: (transmission originatesAt: (presentation pane port: #port1))scrollToRightTask  ^scrollToRightTask ifNil: [ scrollToRightTask := GLMAsyncTask new.        scrollToRightTask           doInBackground: [:isSmooth |  isSmooth ];           onCompleted: [:isSmooth |  self scrollToRight: isSmooth ];           delay: self scrollingDelay ]testMorphUpdateOnAnnounce  | browser number originalMorph newMorph announcer |  announcer := GLMAnnouncer new.  number := 42.  browser := GLMTabulator new.  browser row: #morph.  browser transmit     to: #morph;     andShow: [:presenter |  presenter morph           updateOn: Announcement from: [ announcer ];           display: [:x |  number asString asMorph ] ].  window := browser openOn: 42.  originalMorph := self findLast: StringMorph in: window.  self assert: originalMorph notNil.  self assert: originalMorph contents equals: 42 asString.  number := 43.  announcer announce: Announcement.  newMorph := self findLast: StringMorph in: window.  self assert: newMorph ~= originalMorph.  self assert: newMorph notNil.  self assert: newMorph notNil.  self assert: newMorph contents equals: 43 asStringselectedImage: anObject  selectedImage := anObjectcondition  ^condition ifNil: [ condition := [ true ] ]textLogic  ^textLogicbottomLeftCornerShadowOf: aBrick on: aCanvas  | gradient width origin offset |  width := aBrick shadowWidth.  offset := (width @ width) negated / 2.0.  origin := aBrick brickBounds bottomLeft + offset + aBrick shadowOffset.  gradient := (self shadowGradientFor: aBrick)     origin: origin + (width @ 0);     direction: width negated @ width / 1.4;     radial: true;     yourself.  aCanvas fillRectangle: (origin extent: width @ width) fillStyle: gradienttestWithReturnsTheOriginalPresentation  | p result |  p := GLMPresentation new.  result := p with: [:thePresentation |  GLMPresentation new ].  self assert: result identicalTo: pconvertIndexToValue: anIndex with: numberOfPagers  numberOfPagers = self actualNumberOfVisiblePages ifTrue: [ ^0 ] ifFalse: [ ^(anIndex - 1) / (numberOfPagers - self actualNumberOfVisiblePages) ]gtInspectorBrowserIn: composite  < gtInspectorPresentationOrder: 40>  ^composite tabulator with: [:t |  t title: 'Live'.        t column: #default.        t transmit           to: #default;           transformed: [:x |  self entity ];           andShow: [:a |  a custom: self copy ].        t transmit           from: #default port: #selection;           toOutsidePort: #selection ]morph  ^self custom: GLMMorphPresentation newsetUp  super setUp.  announcer := Announcer new.  entity := OrderedCollection with: 1 with: 2 with: 3.  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #one;     andShow: [:a |  a verticallyStackedArrangement.        a list           title: [:x |  x printString ];           updateOn: GLMTestAnnouncement from: [ announcer ];           shouldValidate: true.        a tree           title: [:x |  x printString ];           children: #();           updateOn: GLMTestAnnouncement from: [ announcer ];           shouldValidate: true.        a table           title: [:x |  x printString ];           updateOn: GLMTestAnnouncement from: [ announcer ];           shouldValidate: true.        a text updateOn: GLMTestAnnouncement from: [ announcer ].        a list           title: 'Not updated automatically';           shouldValidate: true.        a label           display: [:x |  x isEmpty ifTrue: [ '#()' ] ifFalse: [ x last ] ];           updateOn: GLMTestAnnouncement from: [ announcer ] ].  browser transmit     to: #two;     from: #one;     andShow: [:a |  a text ].  window := browser openOn: entity.  listLabelMorph := window submorphs last submorphs second submorphs first submorphs first tabSelectorMorph submorphs first submorphs first.  listMorph := window submorphs last submorphs second submorphs first submorphs first submorphs first submorphs first submorphs first.  treeMorph := window submorphs last submorphs second submorphs first submorphs second submorphs first submorphs first submorphs first.  tableMorph := window submorphs last submorphs second submorphs first submorphs third submorphs first submorphs first submorphs first.  unupdatedListMorph := window submorphs last submorphs second submorphs first submorphs fifth submorphs first submorphs first submorphs first.  labelMorph := window submorphs last submorphs second submorphs first submorphs last submorphs first submorphs firstsubbricks  ^self brick subbricks collect: #brickApitestExample  window := GLMScrollListBrick example.  self assert: window isSystemWindowbeSingle  allowsMultipleSelection := falserenderSmalltalkCodePresentation: aSmalltalkCodePresentation  ^GLMMorphicSmalltalkCodeRenderer render: aSmalltalkCodePresentation from: selfdoInBackground: aBlock  task := aBlockmarginRight  ^self margin at: RighttestTwoInterdependentPanesShouldUpdateTheRenderedSelectionOnTheTriggerPane  | browser morphTwo morphOne |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #one;     andShow: [:a |  a list display: [:x |  1 to: x ] ].  browser transmit     from: #one;     to: #two;     andShow: [:a |  a list display: [:x |  1 to: x ] ].  browser transmit     from: #two port: #toSelect;     toOutsidePort: #toSelect.  browser transmit     fromOutsidePort: #toSelect;     to: #one port: #selection.  browser transmit     fromOutsidePort: #toSelect;     to: #two port: #selection.  window := browser openOn: 100.  ((browser paneNamed: #one) port: #selection) value: 10.  ((browser paneNamed: #two) port: #toSelect) value: 5.  self assert: ((browser paneNamed: #one) port: #selection) value equals: 5.  self assert: ((browser paneNamed: #two) port: #selection) value equals: 5.  self waitUntilUIRedrawed.  morphOne := self findWherePresentationIs: (browser paneNamed: #one) presentations first in: window.  self assert: morphOne notNil.  self assert: morphOne selectedMorph notNil.  morphTwo := self findWherePresentationIs: (browser paneNamed: #two) presentations first in: window.  self assert: morphTwo notNil.  self assert: morphTwo selectedMorph notNilextent: aPoint  self changed.  self width: aPoint x.  self height: aPoint y.  self wrappedBounds bounds: (self brickBounds origin extent: aPoint).  self flag: 'do I need to layout morphs inside?'.  self doLayout.  self changedminHeight: anObject  minHeight := anObjectrenderCustomRow: aCell ofPane: aPane inUI: aMorph inBrowser: aBrowser  | pane totalSpans totalSizes currentSpanPosition currentOffset |  totalSpans := aCell children inject: 0 into: [:sum :each |  sum + each span ].  totalSizes := aCell children inject: 0 into: [:sum :each |  sum + each size ].  currentSpanPosition := 0.  currentOffset := 0.  aCell children keysAndValuesDo: [:index :each |  each hasId ifTrue: [ pane := self renderObject: (aBrowser paneNamed: each id) ] ifFalse: [ pane := GLMMorphic containerMorph.              self renderCustomColumn: each ofPane: aPane inUI: pane inBrowser: aBrowser.              pane addPaneSplitters ].        pane layoutFrame: (LayoutFrame new                 topFraction: 0 offset: 0;                 leftFraction: currentSpanPosition / totalSpans offset: currentOffset - (totalSizes * currentSpanPosition / totalSpans) rounded + self margin;                 bottomFraction: 1 offset: 0;                 rightFraction: (currentSpanPosition + each span) / totalSpans offset: currentOffset + each size - (totalSizes * (currentSpanPosition + each span) / totalSpans) rounded - self margin;                 yourself).        aMorph addMorphBack: pane.        currentSpanPosition := currentSpanPosition + each span.        currentOffset := currentOffset + each size ].  aCell children last size > 0 ifTrue: [ (aMorph submorphs atLast: 2) layoutFrame rightOffset: (aMorph submorphs atLast: 2) layoutFrame rightOffset - currentOffset.        aMorph submorphs last layoutFrame leftOffset: aMorph submorphs last layoutFrame leftOffset - currentOffset.        aMorph submorphs last layoutFrame rightOffset: aMorph submorphs last layoutFrame rightOffset - currentOffset ].  aMorph addPaneSplitterstestStartTabulator  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list.        a text ].  browser startOn: 42.  self assert: ((browser paneNamed: #one) presentations isKindOf: GLMCompositePresentation).  self assert: (browser paneNamed: #one) presentations size equals: 2result: anObject  result := anObjectprintOn: aStream  super printOn: aStream.  aStream nextPutAll: '(port='.  self port printOn: aStream.  aStream     nextPutAll: ' oldValue=';     nextPutAll: self oldValue printString;     nextPut: $)padding: paddings  paddings ifNil: [ ^self padding: #(0) ].  paddings isCollection ifTrue: [ paddings isEmpty ifTrue: [ ^self padding: #(0) ].        self           paddingTop: (paddings at: Top);           paddingRight: (paddings at: Top);           paddingBottom: (paddings at: Top);           paddingLeft: (paddings at: Top).        paddings size > Top ifTrue: [ self                 paddingRight: (paddings at: Right);                 paddingLeft: (paddings at: Right) ].        paddings size > Right ifTrue: [ self paddingBottom: (paddings at: Bottom) ].        paddings size > Bottom ifTrue: [ self paddingLeft: (paddings at: Left) ] ] ifFalse: [ ^self padding: {paddings} ].  self updateCachescrollbarPosition  ^#rightchildrenValueOf: anObject  ^self children glamourValue: anObject asGlamorousMultiValue , self entity asGlamorousMultiValuecreateRootItem  | fullRoot |  fullRoot := FTRootItem data: self basicRoots from: self.  ^self tagsToFilterBy ifEmpty: [ fullRoot ] ifNotEmpty: [ | children |        children := OrderedCollection new.        fullRoot children do: [:item |  (self matchingTag: item) ifNotNil: [:itemNew |  children add: itemNew ] ] displayingProgress: [:each |  'Looking inside ' , each printString ].        FTRootItem new           dataSource: self;           children: children asArray;           yourself ]withSeparatorAfter  self separatorAfter: trueallSelectionActions  ^self selectionActions , self dynamicActionsOnSelection select: [:each |  each isAvailableOn: self ]modelFor: aPresentation  ^(super modelFor: aPresentation)     highlightSmalltalk: true;     bindingsStrategy: self workspaceBindingsStrategy;     appendVariableBinding: aPresentation variableBindings;     yourselfpresentation: anObject  presentation := anObjectresolvePort: aPortReference defaultPortName: aSymbol  ^aPortReference paneName = #outer ifTrue: [ GLMPresentationBoundPort new           presentation: self;           name: aPortReference portName;           yourself ] ifFalse: [ (self paneNamed: aPortReference paneName) port: aPortReference portName ]searchOn: aBlock  self error: 'This presentation does not allow searching with a block for now. In the futur we should have a new filter with FastTable to do that. If you want to give it a try look FTFunction and his subclasses.'testTriggerConditionsWithParentPort  | transmission presentation |  transmission := GLMTransmission new.  presentation := GLMPresentation new.  transmission addActiveOrigin: (GLMPresentationBoundPort new           presentation: presentation;           name: #port1;           yourself).  self assert: (transmission originatesAt: (GLMPresentationBoundPort new                 presentation: presentation;                 name: #port1;                 yourself)).  self assert: (transmission originatesAt: (presentation pane port: #port1))pageIndex: anObject  pageIndex := anObjectmarkFullyClean: aBrick  aBrick withAllSubbricks do: [:each |  each wrappedBounds           markWidthClean;           markHeightClean ].  ^aBrickhasMaxHeight  ^(self maxHeight isNumber ifTrue: [ self maxHeight isInfinite ] ifFalse: [ false ]) notemptyBrick  ^emptyBrickasString  ^'horizontal'buttonForTag: each filter: filter  ^(GLMMorphic togglingButtonLabelled: each pressed: (self shouldFilterByTag: filter) style: self glamourPresentation tagsStyle)     target: self;     actionSelector: #toggleFilteringByTag:;     arguments: (Array with: filter);     yourselfnotifyNumberOfVisiblePagesChanged  self notifyAll: GLMNumberOfVisiblePagesChanged newhShrinkWrap  hState := self hState onChildrenDo: #yourselfenableSearch  self parameters at: 'isSearchable' put: truedefaultPageSize: anInteger  defaultPageSize := anIntegerselectionPath: anObject  (self pane port: #selectionPath) value: anObjecttestTabsWithTitleIconWithoutTitle  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a titleIcon: GLMUIThemeExtraIcons glamorousBrowse.        a list.        a text ].  window := browser openOn: 42.  self assert: self compositeTabGroup submorphs size equals: 2.  self assert: self compositeTabGroup submorphs first class equals: GLMPanelMorph.  self assert: self compositeTabGroup submorphs first submorphs size equals: 1.  self assert: self compositeTabGroup submorphs first submorphs first class equals: LazyTabGroupMorph.  self assert: self compositeTabGroup submorphs first submorphs first pages size equals: 2browser: anObject  browser := anObjectrender: aPresentation  | presentations container expander |  presentations := aPresentation matchingPresentations.  presentations isEmpty ifTrue: [ ^GLMMorphic emptyMorph ].  presentations size = 1 ifTrue: [ ^self renderWithToolbar: presentations first ].  container := GLMMorphic containerMorph.  container changeTableLayout.  presentations do: [:each |  expander := self theme newExpanderIn: container label: (self titleOrIconOf: each in: container) forAll: {(self renderWithToolbar: each)}.        container addMorphBack: expander.        (aPresentation pane lastActivePresentation notNil and: [ each title = aPresentation pane lastActivePresentation title ]) ifTrue: [ expander expanded: true ] ].  (aPresentation pane lastActivePresentation isNil and: [ container submorphs notEmpty ]) ifTrue: [ container submorphs first expanded: true ].  ^containerinitialize  super initialize.  self changeProportionalLayout.  self     onAnnouncement: MorphLostFocus do: [:ann |  ann morph delete ];     color: Color transparenttestOneDependsOnParentOneStaticInsideStatic  | root brick1 brick2 staticWidth |  staticWidth := 20.  root := self newBrickWithStaticExtent.  brick1 := self newBrickFullHeightAndWidthDependsOnParent: 100.  brick2 := GLMBrick new     width: staticWidth;     vSpaceFill;     yourself.  root     addBrickBack: brick1;     addBrickBack: brick2.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick1 brickBounds equals: (0 @ 0 extent: (self staticWidth - staticWidth) @ self staticHeight).  self assert: brick2 brickBounds equals: ((self staticWidth - staticWidth) @ 0 extent: staticWidth @ self staticHeight)testBuildingNestedComposites  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list.        a text.        a composite: [:another |  another text.              another list ] ].  browser startOn: 42.  self assert: ((browser paneNamed: #one) presentations isKindOf: GLMCompositePresentation).  self assert: (browser paneNamed: #one) presentations size equals: 3.  self assert: ((browser paneNamed: #one) presentations last isKindOf: GLMCompositePresentation).  self assert: (browser paneNamed: #one) presentations last size equals: 2initializeAnnouncementForDataSource  tableModel announcer when: GLMTreeMorphSelectionChanged do: [:ann |  tableModel glamourPresentation announcer suspendAllWhile: [ tableModel glamourPresentation selection: ann selectionValue.              tableModel glamourPresentation selectionPath: ann selectionPathValue ] ].  tableModel announcer when: GLMTreeMorphStrongSelectionChanged do: [:ann |  tableModel glamourPresentation strongSelection: ann strongSelectionValue ].  tableMorph     onAnnouncement: FTStrongSelectionChanged send: #strongSelection: to: tableModel;     onAnnouncement: FTSelectionChanged send: #selection: to: tableModel.  self installActionsOnModel: tableModel fromPresentation: tableModel glamourPresentation.  self installKeystrokeActionsOnMorph: tableMorph fromPresentation: tableModel glamourPresentationdefaultAmountToShow  ^500containerNode  ^containerNodecondition  ^conditionwidthDependency: anObject  self widthDependencies add: anObjectisClean: aBrick  ^aBrick isWidthCleanopenInExternalWindowOn: anObject  ^self openOn: anObject inExternalWindowWith: self defaultRendereraddStatusbar  self hasStatusbar: trueaddTextSegment: aTextSegmentMorph  self textSegments add: aTextSegmentMorphlayoutOwnerOf: aBrick  aBrick owner ifNotNil: [ self layoutAround: aBrick owner inContext: aBrick ]testRawSelectionAvailableWhenNoSelectionActive  | presentation |  presentation := GLMPresentation new.  presentation acceptsSelection: false.  presentation selection: 1.  self assert: presentation selection equals: nil.  self assert: presentation rawSelection equals: 1defaultValidate: anObject on: aPort  aPort name == #selection ifFalse: [ ^true ].  self entity ifNil: [ ^false ].  self allDisplayedDo: [:each |  each = anObject ifTrue: [ ^true ] ].  ^falsepostCopy  super postCopy.  announcerObjects := nilpushPane: aMorph smooth: aBoolean  self invariant.  pagesCount := pagesCount + 1.  self size = 1 ifTrue: [ firstVisiblePageIndex := 1.        lastVisiblePageIndex := 1.        selectedPageIndex := 1 ] ifFalse: [ self actualNumberOfVisiblePages < self numberOfVisiblePages ifTrue: [ lastVisiblePageIndex := lastVisiblePageIndex + 1 ] ].  self notifyPagePushed: aMorph scrollTo: true smooth: aBoolean.  self size = 1 ifTrue: [ self notifySelectedPageChanged ].  self invariantbindingsStrategy  ^bindingsStrategytext  ^self label textcontentBrick  ^contentBrickbeTransparent  self rubricBackgroundColor: Color transparentrenderGlamorouslyOn: aRenderer  ^aRenderer renderAccordionCompositePresentation: self compositeheightParentDependency: aBrick  | allowedHeight |  aBrick owner ifNil: [ Exception signal: 'My height depends on parent, but it is nil' ].  allowedHeight := aBrick owner subbricks inject: aBrick owner innerBounds height into: [:height :each |  each isHeightClean ifTrue: [ each layout vState isOnParent not | (self hasHeightRestrictions: each) ifTrue: [ height - each outerBounds height ] ifFalse: [ height ] ] ifFalse: [ height ] ].  ^(allowedHeight * aBrick layout vPercent / 100) ceilingglamourValueWithArgs: anArray  (anArray first pane port: self portSymbol) value: (self valueBlock glamourValueWithArgs: anArray)borderColor  ^Color r: 48 g: 194 b: 240 range: 255title  ^titlevState  ^self layout vStatepane  ^self port panedataSourceUpdated: announcement  tableModel ifNotNil: [ self unsubscribeDataSource: tableModel ].  tableModel := announcement newDataSource.  self initializeAnnouncementForDataSourcetestInclues  | context port |  port := GLMSimplePort new.  context := GLMTransmissionContext new.  context addPort: port.  self assert: (context includesPort: port)setConstrainedPosition: aPoint hangOut: partiallyOutside  | trialRect delta boundingRectangle |  self owner ifNil: [ ^self ].  trialRect := 0 @ 0 extent: self outerBounds extent.  boundingRectangle := self owner paddingLeft @ self owner paddingTop extent: self owner innerBounds extent.  delta := (aPoint + trialRect corner min: boundingRectangle corner) - trialRect corner max: boundingRectangle origin.  self position: delta.  self changedwhen: anAnnouncementClass do: aBlock  self announcer when: anAnnouncementClass do: aBlocktitleText: aText  titleText := aText.  self titleBrick ifNotNil: [ self titleBrick text: self titleText ]testDirectEventsPropagationTransformation  | dynamic textPresentation counter portOne portTwo |  counter := 0.  dynamic := GLMDynamicPresentation new.  dynamic entity: '42'.  dynamic display: [:entity |  textPresentation := GLMRubricTextPresentation new ].  dynamic currentPresentation.  textPresentation announcer when: GLMContextChanged do: [:ann |  counter := counter + 1 ].  portOne := GLMSimplePort new     name: #portOne;     value: 1.  portTwo := GLMSimplePort new     name: #portTwo;     value: 2.  dynamic outerPortEvent: (GLMPortEvent on: portOne previouslyValued: portTwo).  self assert: counter equals: 1adjustLayoutBounds  testDefault  (GLMLoggedObject withAllSubclasses reject: [:each |  each allMethods anySatisfy: [:cm |  cm sendsSelector: #subclassResponsibility ] ]) do: [:each |  self assert: each new logger identicalTo: GLMLogger nullInstance ]render: anActionListPresentation  container := GLMMorphic containerMorph.  container     changeTableLayout;     listDirection: #leftToRight;     vResizing: #spaceFill;     hResizing: #spaceFill.  container addMorphBack: (self morphFrom: anActionListPresentation).  anActionListPresentation when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  ^containernewDataSource  ^newDataSourcesubmitForm  self announce: (GLMFormSubmitted new result: self asFormValue)postCopy  super postCopy.  pane := nil.  self flag: 'self unregisterFromAllAnnouncements.'.  updateActions := updateActions collect: [:each |  each copy           presentation: self;           yourself ].  rawSelectionTransmissions := rawSelectionTransmissions collect: [:each |  each copy ].  rawSelectionTransmissions do: [:transmission |  transmission originReferences do: [:portRef |  portRef port presentation: self ] ].  rawSelectionTransmissions do: [:transmission |  transmission destination presentation: self ]execute: aBlock withArguments: aCollection callback: callbackBlock priority: aPriority  ^self execute: aBlock withArguments: aCollection callback: callbackBlock priority: aPriority delay: 0initializeColumns  self removeAllBricks.  self entity isNil | self table isNil ifTrue: [ ^self ].  self table columns do: [:each |  self addColumn: each ].  self updateWidthPercentagecircleButtonSize  ^22populate: aPortSymbol on: aCharacter entitled: aString with: aBlock  self addAction: (GLMGenericAction new           action: (GLMPortUpdater new                 portSymbol: aPortSymbol;                 valueBlock: aBlock;                 yourself);           shortcut: aCharacter;           title: aString;           yourself)outerPortEvent: aPortEvent  super outerPortEvent: aPortEvent.  aPortEvent hasChanged ifTrue: [ (self transmissions select: [:each |  (each originatesAt: aPortEvent port) and: [ (aPortEvent transmissionContext includesPort: each destination) not ] ]) do: [:each |  each transmitIn: aPortEvent transmissionContext copy ] ]isFocusedMorphVisibleAt: paneIndex  | morph |  morph := self focusedViewAt: paneIndex.  morph ifNil: [ ^false ].  ^morph isInWorldpagerModel: aModel  pagerModel := aModel.  self pagerModel announcer when: GLMPagePushed send: #onPagePushed to: self.  self pagerModel announcer when: GLMPagePoped send: #onPagePoped to: self.  self initializeShortcuts.  self scrollBrick: self newScrollBrick.  self pagerBar: self newPagerBarportName  ^portNameseparatorAfter: aBoolean  separatorAfter := aBooleanstackedVerticallyArrangement  ^self arrangement: (GLMStackedVerticallyArrangement of: self)styled: anObject  self setProperty: #phlowStyled toValue: anObjectinitialize  super initialize.  self themer: self themer popupEditorBorderThemer themerreceive: aTransmission in: aContext  self value: aTransmission value in: aContextspecificTableMorphInitializiation  self specificTableMorphColumnsInitialization.  super specificTableMorphInitializiationtestDiminishToLeft  | counter left |  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  counter := pagerModel numberOfVisiblePages.  left := pagerModel firstVisiblePageIndex.  self assert: pagerModel numberOfVisiblePages equals: counter.  self assert: pagerModel numberOfVisiblePages equals: pagerModel lastVisiblePageIndex - left + 1.  self assert: pagerModel firstVisiblePageIndex equals: left.  [ counter > 1 ] whileTrue: [ pagerModel diminishToLeft.        counter := counter - 1.        self assert: pagerModel numberOfVisiblePages equals: counter.        self assert: pagerModel numberOfVisiblePages equals: pagerModel lastVisiblePageIndex - left + 1.        self assert: pagerModel firstVisiblePageIndex equals: left ].  (1 to: 3) do: [:i |  pagerModel diminishToLeft.        self assert: pagerModel numberOfVisiblePages equals: 1.        self assert: pagerModel numberOfVisiblePages equals: pagerModel lastVisiblePageIndex - left + 1.        self assert: pagerModel firstVisiblePageIndex equals: left ]showOnly: aBlock  amountToShowBlock := aBlocksetPosition: aPoint  self changedWith: [:b |  b           translateXTo: aPoint x;           leftPosition: aPoint x;           doNotLayoutDuring: [ b width: aPoint y - aPoint x.              b wrappedBounds markWidthClean ] ].  self pagerModel notifyScrollerBoundsChanged: aPointcheckbox: aBlock  aBlock cull: self checkboxchanged  self brickRoot changedinvalidate  pageAt: index  ^(self pages at: index) actualPageMorphpresentation  ^presentationacceptsSelection  ^acceptsSelection ifNil: [ acceptsSelection := true ]notifyScrollPositionChanged: isSmooth  self notifyScrollPositionChanged: isSmooth callback: nilchangedText: aTextOrString  text := aTextOrString.  self changed: #texthShrinkWrap  self width: [ self vPadding + (self icon isNil & self hoverIcon isNil ifTrue: [ 0 ] ifFalse: [ self icon ifNil: [ self hoverIcon width ] ifNotNil: [ self hoverIcon ifNil: [ self icon width ] ifNotNil: [ self icon width max: self hoverIcon width ] ] ]) ]meetsCondition  < debuggingStone: #transmissionCondition label: 'Transmission condition'>  | originValues |  originValues := self originReferences size = 1 ifTrue: [ self originReferences first value ] ifFalse: [ GLMMultiValue withAll: (self originReferences collect: [:each |  each value ]) ].  ^self condition glamourValue: originValuesisReadMode  ^self isEditMode notpresentation  ^presentationdisplayedValue  ^cachedDisplayedValuebuttonFor: item  ^((self canDisplayChildrenOf: item) and: [ self hasChildren: item ]) ifTrue: [ item generateButton ] ifFalse: [ self class emptyMorph ]testUpdatePresentationTitle  < expectedFailure>  browser panes first presentations first title: 'something'.  browser panes first presentations first update.  self assert: listLabelMorph contents equals: 'something'selectedColor  ^selectedColorband  ^bandalign: aBrick in: parentBrick anchorPoint: aPoint inContext: aContext  | align |  self = aContext ifTrue: [ ^self ].  parentBrick subbricks size = 1 & aContext isNil ifTrue: [ GLMVerticalLinearLayout uniqueInstance align: aBrick in: parentBrick anchorPoint: aPoint inContext: self ].  align := aBrick layout vAlign.  align = #none ifTrue: [ ^self ].  align = #center ifTrue: [ ^aBrick translateY: ((parentBrick innerBounds height - aBrick outerBounds height) / 2) asInteger ].  align = #bottom ifTrue: [ ^aBrick translateY: (parentBrick innerBounds height - aBrick outerBounds height) asInteger ]actOnPresentationToolbarUpdated: anAnnouncement  | presentation |  presentation := anAnnouncement presentation.  contentMorph updatePageAtIndex: 1 withLabel: (self titleOrIconOf: presentation in: contentMorph) toolbar: (self renderToolbarForPresentation: presentation inMorph: contentMorph) action: (self labelActionBrickFor: presentation)addItemMorph: aMorph before: anotherMorph  self addBrickBackNoLayout: aMorph before: anotherMorph.  self setBoundsOf: aMorph before: anotherMorph.  (self isPartiallyVisible: aMorph) ifFalse: [ self removeBrickNoLayout: aMorph.        ^nil ].  aMorph brickBounds top < 0 ifTrue: [ self moveAllSubbricksBy: aMorph brickBounds top negated ] ifFalse: [ (self getIndex: aMorph) = 1 ifTrue: [ self moveAllSubbricksBy: aMorph brickBounds top negated ] ].  ^aMorphselectionPath  ^(self pane port: #selectionPath) valueuseHorizontalLinearLayout  self layout: GLMHorizontalLinearLayout uniqueInstanceaction: anObject  action := anObjecttestPastingUpdatesTextPort  | composite textMorph |  composite := GLMCompositePresentation new with: [:a |  a text display: '' ].  window := composite openOn: 42.  textMorph := self find: RubScrolledTextMorph in: window.  Clipboard clipboardText: '42'.  textMorph textArea editor paste.  self assert: (composite pane port: #text) value equals: '42'when: aBlock  self condition: aBlocknormalBorderStyleFor: aBrick  ^self theme tabLabelNormalBorderStyleFor: aBrickcolumn: aBlockOrSymbol size: anInteger  ^self addColumn: aBlockOrSymbol size: anIntegerchangePortsAccordingToPaneMapping: newPanesMapping fromOldBrowser: aBrowser toNewBrowser: anotherBrowser  | newPort |  self destination: (self destination copyAccordingToPaneMapping: newPanesMapping inNewBrowser: anotherBrowser).  self originReferences do: [:each |  newPort := each port copyAccordingToPaneMapping: newPanesMapping inNewBrowser: anotherBrowser.        each port: newPort ]statusbarPane  ^statusPaneselectionTransmission  ^self rawSelectionTransmissionFor: #selection ifNone: [ nil ]setUp  super setUp.  announcer := GLMAnnouncer newdisplayFormat: aBlock  displayFormat := aBlocktestSelectedText  | presentation |  presentation := GLMRubricTextPresentation new.  self assert: presentation selectedText equals: ''.  presentation selectedTextBlock: [ 'selection' ].  self assert: presentation selectedText equals: 'selection'stepCondition: aBlock  stepCondition := aBlocktestTopMarginParentDependency  | root margin brick |  margin := 10.  root := self newBrickWithStaticExtent.  brick := self newBrickFullHeightAndWidthDependsOnParent: 100.  brick marginTop: margin.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticExtent - (0 @ margin).  self assert: brick brickBounds equals: (0 @ margin corner: self staticExtent)heightState  ^heightState ifNil: [ heightState := #dirty ]isWidthDirty  ^self brick wrappedBounds isWidthDirtyshouldUseCache  ^self parameters at: 'shouldUseCache' ifAbsent: [ false ]east  direction := EastscrollButtonIconRenderBlock  ^scrollButtonIconRenderBlockhasId  ^id notNilfont: aFont  font := aFont.  aFont ifNil: [ self updateFont ].  familyName := font familyName.  fontSize := font pointSizeensureReplacePresentationsStrategy  self transmissionStrategy class = GLMReplacePresentationsStrategy ifFalse: [ self transmissionStrategy: (GLMReplacePresentationsStrategy of: self) ]browser: anObject  browser := anObjecttestRightFloatingMySelfDependencyWithMargin  | root margin floating brick |  margin := 10.  floating := #right.  root := self newBrickWithStaticExtent.  brick := self newBrickWithSmallStaticExtent.  brick layout floating: floating.  brick marginRight: margin.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticSmallExtent.  self assert: brick brickBounds equals: ((self staticWidth - margin - self staticSmallWidth) @ 0 extent: self staticSmallExtent)resume  process ifNotNil: [ process resume ]displayLogic  ^self valueOfProperty: #phlowDisplay ifAbsent: [ #yourself ]titleAction  ^self titleActionBlock ifNil: [ nil ] ifNotNil: [:aBlock |  aBlock glamourValue: self ]renderGlamorouslyOn: aRenderer  self deprecated: 'Use GLMPharoMethodPresentation GLMPharoScriptPresentation instead.'.  self registerAnnouncements.  ^aRenderer renderSmalltalkCodePresentation: selfaddContentBricks  self onCreated.  self announce: #onCreated event: self triggerBricktestTransientValue  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     fromOutsidePort: #entity;     to: #one port: #entity.  browser transmit     from: #one port: #entity;     to: #two;     andShow: [:a |  a text ].  browser startOn: 42.  self assert: (browser panes first port: #entity) value equals: 42.  self assert: (browser panes last port: #entity) value equals: 42.  (browser panes first port: #entity) transientValue: 43.  self assert: (browser pane port: #entity) value equals: 42.  self assert: (browser panes first port: #entity) value equals: 42.  self assert: (browser panes last port: #entity) value equals: 43.  (browser pane port: #entity) transientValue: 44.  self assert: (browser pane port: #entity) value equals: 42.  self assert: (browser panes first port: #entity) value equals: 44.  self assert: (browser panes last port: #entity) value equals: 44column: aBlockOrString evaluated: aBlock width: aNumber tags: anObject sortedBy: aSortingBlock  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           width: aNumber;           tags: anObject;           sortBlock: aSortingBlock yourself)composite  ^compositebeMode: aMode  self hoverAction: [:aBrick :evt |  | delay |        delay := (self isModifierPressed: evt) ifTrue: [ 0 ] ifFalse: [ self hintDelay ].        self startStepping: #openHintPopup: at: Time millisecondClockValue + delay arguments: {aMode} stepTime: 3000 ]containerTree  ^containerTreefocusedBorderColor  ^self color peterRiverremoveBrick: aBrick  self band removeBrick: aBrickisVShrinkWrap  ^self vState isOnChildrenenableFilter  self parameters at: 'isFilterable' put: truepresentation: anObject  presentation := anObjectpassivelyFrom: aPaneSymbol port: aPortSymbol  ^self passivelyFrom: (GLMPortIdentifier pane: aPaneSymbol port: aPortSymbol)selectionInterval  ^self valueOfProperty: #phlowSelectionInterval ifAbsent: [ 1 to: 0 ]spawn: aBlock iconName: aSymbol entitled: aString  self spawn: aBlock icon: (self iconNamed: aSymbol) entitled: aStringinnerPortEvent: aPortEvent  createFastTable  ^FTTableMorph newleft  ^self subclassResponsibilityrenderStacker: aBrowser  ^GLMMorphicStackerRenderer render: aBrowser from: selfinvalidateLayout  brick  ^selfbox  ^checkBrickisHFilling  ^hResizing = #spaceFillannouncer  ^selftextMorphForModel: aTextModel  ^(RubPluggableTextMorph on: aTextModel text: #text accept: #accept:notifying: readSelection: #selection menu: #menu:shifted:)     changedAction: [:aText |  aText asString trimBoth ifNotEmpty: [ aTextModel text: aText ] ];     onKeyStrokeSend: #keystroke:from: to: aTextModel;     layoutFrame: LayoutFrame identity;     vResizing: #spaceFill;     hResizing: #spaceFill;     color: self theme backgroundColor;     detachAllKeymapCategories;     yourselfcollectionToDragPassenger: aCollection  ^aCollection size = 1 ifTrue: [ aCollection anyOne ] ifFalse: [ aCollection ]toolbarMorph: anObject  toolbarMorph := anObjectscrollPane: anObject  scrollPane := anObject.  self updatePositiondefaultSortBlockForPresentation: aGlamourPresentation  ^[:x :y |  (aGlamourPresentation column: self valueFor: x) asString < (aGlamourPresentation column: self valueFor: y) asString ]renderPharoScriptPresentation: aPharoScriptPresentation  ^GLMMorphicPharoScriptRenderer render: aPharoScriptPresentation from: selfisBrick  ^falsemodelFor: aPresentation  ^GLMRubricTextModel new     glamourPresentation: aPresentation;     yourselfbeSuccess  self beMode: #beSuccessnewIndex  ^newIndexrender: aRenderable  | dock offset bottomOffset |  window := GLMOSWindowWorldMorph new model: aRenderable.  self installActionsOnModel: window fromPresentation: aRenderable.  self installKeystrokeActionsOnMorph: window fromPresentation: aRenderable.  self setLabelOf: window for: aRenderable.  offset := 4.  bottomOffset := 0.  dock := self renderToolbarForPresentation: aRenderable inMorph: window.  dock hResizing: #shrinkWrap.  window toolbarBox: dock.  bottomOffset := self handlePotentialStatusbarFor: aRenderable.  window addMorph: (self renderObject: aRenderable) fullFrame: ((0 @ 0 corner: 1 @ 1) asLayoutFrame           topLeftOffset: 0 @ offset;           bottomRightOffset: 0 @ bottomOffset).  self setPotentialBackgroundColorFor: aRenderable.  aRenderable when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  aRenderable when: GLMWindowRequest send: #actOnWindowRequest: to: window.  aRenderable watcherPane notNil ifTrue: [ GLMMorphicWatcherRenderer render: aRenderable watcherPane from: self renderer ].  ^windowhasItems  ^self model notNil and: [ self model count > 0 ]defaultBorderWidth  ^5currentBindings  self withBindingsDo: [:bingings |  ^bingings copy ]scrollBarHeight  ^self theme scrollbarThicknessbrickRoot: aBrick  self brickRoot ifNotNil: [ self removeMorph: self brickRoot.        brickRoot := nil ].  brickRoot := aBrick.  self addMorphBack: brickRoot.  brickRoot onThemerChangedexecute: aBlock withArguments: aCollection callback: callbackBlock priority: aPriority delay: anIntegerMilliseconds  self terminate.  callback := callbackBlock.  process := [ | result |  anIntegerMilliseconds > 0 ifTrue: [ anIntegerMilliseconds milliSeconds wait ].  result := aBlock valueWithEnoughArguments: aCollection.  UIManager default defer: [ self complete: result callback: callbackBlock ] ] newProcess.  process priority: aPriority.  process resume.  ^selfshortcutAsString  self shortcut ifNil: [ ^'' ].  ^self keymap printOsRepresentationwidthChildrenDependency: aBrick  ^aBrick paddingLeft + aBrick paddingRight + (((self nonFloatSubbricks: aBrick) detectMax: [:each |  each outerBounds width ]) ifNil: [ 0 ] ifNotNil: [:m |  m outerBounds width ])dropElements: aCollection index: rowIndex  self glamourPresentation accept: (self collectionToDragPassenger: aCollection) droppedOnItem: (self elementOrZeroAt: rowIndex)themer: aThemer  self setProperty: #brickThemer toValue: aThemer.  self themerChangedstylerDecorator: anObject  stylerDecorator := anObjectselectionValue  ^selectionValueselect  self owner ifNil: [ ^self ].  self minWidth: [ self owner width min: (self hasSubbricks ifTrue: [ self label layout maxWidth brickValue: self label ] ifFalse: [ 0 ]) ].  self owner doLayoutForcetestEntity  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list ].  browser startOn: ($a to: $d).  self assert: ((browser paneNamed: #one) port: #entity) value equals: ($a to: $d)vSpaceFill: anInteger  super vSpaceFill: anInteger.  self label vSpaceFillupdateStyle  self bar color: self scrollBarColor.  self layout floating: self scrollbarPosition.  self width: self scrollbarWidth.  self layout floating = #right ifTrue: [ self marginRight: self scrollbarOffset ].  self layout floating = #bottom ifTrue: [ self marginBottom: self scrollbarOffset ].  self layout floating = #left ifTrue: [ self marginLeft: self scrollbarOffset ].  self layout floating = #top ifTrue: [ self marginTop: self scrollbarOffset ]calculateMaxVelocity  ^(self height * 0.9) asIntegertestTwoTransmissionsWithOnlyOneEvent  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two;     column: #three.  browser transmit     to: #two;     from: #one;     andShow: [:a |  a list ].  browser transmit     to: #three;     from: #two;     andShow: [:a |  a text ].  self assert: browser transmissions size equals: 2.  self assertEmpty: (browser paneNamed: #one) presentations.  self assertEmpty: (browser paneNamed: #two) presentations.  self assertEmpty: (browser paneNamed: #three) presentations.  ((browser paneNamed: #one) port: #selection) value: 42.  self assert: ((browser paneNamed: #two) port: #entity) value equals: 42.  self assertEmpty: (browser paneNamed: #one) presentations.  self assert: (browser paneNamed: #two) presentations size equals: 1.  self assert: (browser paneNamed: #two) matchingPresentations size equals: 1.  self assertEmpty: (browser paneNamed: #three) presentations.  self assertEmpty: (browser paneNamed: #three) matchingPresentationsshowOn: aDestinationPane  self addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           destination: (self resolveDestinationPort: aDestinationPane);           yourself)andShow: aBlock  self ensureReplacePresentationsStrategy.  self transmissionStrategy presentationsFactory: aBlock.  self origins isEmpty ifTrue: [ self from: #outer port: #entity ]newTextEditField  ^GLMRubEditingAreaBrick new     wrapped: false;     hShrinkWrap;     vShrinkWrap;     withoutBorder;     withoutMargins;     beForSmalltalkCode;     text: self textModel;     yourselftestBundleTransmission  | browser transmission |  browser := GLMTabulator new.  browser     column: #one;     column: #two;     column: #three.  browser transmit     from: #one port: #port1;     from: #two port: #port2;     to: #three -> #port3;     andShow: [:a |  a list.        a table ].  transmission := browser transmissions first.  self assert: browser transmissions size equals: 1.  self assert: transmission browser identicalTo: browser.  self assert: (transmission transmissionStrategy isKindOf: GLMReplacePresentationsStrategy).  self assert: transmission origins size equals: 2.  self assert: transmission origins first equals: ((browser paneNamed: #one) port: #port1).  self assert: transmission origins last equals: ((browser paneNamed: #two) port: #port2).  self assert: transmission destination equals: ((browser paneNamed: #three) port: #port3).  self assert: (transmission transmissionStrategy presentations isKindOf: GLMCompositePresentation).  self assert: transmission transmissionStrategy presentations size equals: 2testMatching  | presentation |  presentation := GLMPresentation new.  self assert: presentation usesImplicitNotNil.  (presentation pane port: #entity) value: (GLMMultiValue withAll: #(nil 1)).  self assert: presentation matches not.  (presentation pane port: #entity) value: 1.  self assert: presentation matches.  presentation useExplicitNotNil.  self assert: presentation usesImplicitNotNil not.  (presentation pane port: #entity) value: (GLMMultiValue withAll: #(nil 1)).  self assert: presentation matches.  (presentation pane port: #entity) value: 1.  self assert: presentation matches.  presentation condition: [:x |  x > 1 ].  presentation useImplicitNotNil.  self assert: presentation usesImplicitNotNil.  (presentation pane port: #entity) value: nil.  self assert: presentation matches not.  (presentation pane port: #entity) value: 1.  self assert: presentation matches not.  (presentation pane port: #entity) value: 2.  self assert: presentation matches.  presentation useExplicitNotNil.  (presentation pane port: #entity) value: 1.  self assert: presentation matches not.  (presentation pane port: #entity) value: 2.  self assert: presentation matches.  self assert: presentation usesImplicitNotNil not.  [ (presentation pane port: #entity) value: (GLMMultiValue withAll: #(nil 1)).  presentation matches.  self signalFailure: 'Should have raised error' ] on: MessageNotUnderstood do: [:err |  self assert: err message selector equals: #>.        self assert: err message arguments equals: (Array with: 1) ]widthChildrenDependency: aBrick  ^aBrick paddingLeft + aBrick paddingRight + ((self nonFloatSubbricks: aBrick) detectSum: [:each |  each outerBounds width ])focusedPageIndex  ^focusedPageIndexisSearchable  ^self parameters at: 'isSearchable' ifAbsent: [ false ]openInWindow  window := pagerMorph asBrickedMorph openInWindowselectedStyleFor: aBrick  aBrick fillStyle: (self selectedBackgroundStyleFor: aBrick).  aBrick borderStyle: (self selectedBorderStyleFor: aBrick)scrollbarCornerRadius  ^0name  ^nameextent  ^self brick extenttitleFor: aRenderable  ^aRenderable titleValue ifNil: [ 'Glamorous Browser' ]staticSmallExtent  ^self staticSmallWidth @ self staticSmallHeightfilterOn: aBlock  filterBlock := aBlockoutOfWorld: aWorld  GLMPagerPanePreviewMorph remove.  ^super outOfWorld: aWorldtopLeftCornerShadowOf: aBrick on: aCanvas  | gradient width origin offset extent |  width := aBrick shadowWidth.  extent := width @ width.  offset := extent negated / 2.0.  origin := aBrick brickBounds origin + offset + aBrick shadowOffset.  gradient := (self shadowGradientFor: aBrick)     origin: origin + (offset * 2 negated);     direction: extent / 1.4 negated;     radial: true;     yourself.  aCanvas fillRectangle: (origin extent: extent) fillStyle: gradientpresentation  ^presentationscrollButtonIconRenderBlock  ^scrollButtonIconRenderBlockdrawingBounds: aBrick  | aRectangle anOffset |  anOffset := aBrick shadowOffset.  aRectangle := aBrick brickBounds expandBy: aBrick border widthTop + aBrick shadowWidth.  anOffset isZero ifFalse: [ aRectangle := aRectangle quickMerge: (aRectangle translateBy: anOffset) ].  ^aRectanglesize  ^size ifNil: [ 0 ]parentPrototype: aPresentation  parentPrototype := aPresentationhAlign  ^hAlign ifNil: [ hAlign := #none ]gtInspectorPanePortsIn: composite  < gtInspectorPresentationOrder: 50>  (self pane gtInspectorPortsIn: composite) title: 'Pane ports'paddingBottom: anInteger  self padding at: Bottom put: anInteger.  self updateCacheglobalClippingBounds  ^self owner ifNotNil: [:brick |  self drawingBounds translateBy: brick globalBoundsTranslateFactor ] ifNil: [ self drawingBounds ]custom: aPresentation  self lastTransmission addPresentation: aPresentation.  ^aPresentationenable: aBoolean  isEnabled := aBooleanmarginLeft  ^self margin at: LeftaddRow: aBlockOrSymbol size: anInteger  ^(self addRow: aBlockOrSymbol)     size: anInteger;     span: 0unhoverAction: anObject  unhoverAction := anObjectwithString: string from: aMorph  | top width left stringMorph height desiredOrigin |  desiredOrigin := self computeOriginFor: aMorph.  stringMorph := RubEditingArea new     font: self theme textFont;     updateTextWith: string.  width := stringMorph width + 12 min: self currentWorld width / 3.  left := desiredOrigin x + width > self currentWorld width ifTrue: [ self currentWorld width - width ] ifFalse: [ desiredOrigin x ].  height := (stringMorph     beWrapped;     width: width;     yourself) height + 2 min: self currentWorld height / 3.  top := desiredOrigin y + height > self currentWorld height ifTrue: [ self currentWorld height - height ] ifFalse: [ desiredOrigin y ].  self updateWithString: string from: aMorph.  self     top: top;     left: left;     width: width;     height: heightrenderObject: anObject  ^self renderer render: anObjectrubric: aMorph  self morph ifNotNil: [ self removeMorph: self morph ].  self on: aMorphbrowseFullClass  self announce: (GLMTextEditorRequest for: #browseFullClass)renderGlamorouslyOn: aRenderer  ^aRenderer renderStackedVerticallyCompositePresentation: self compositeheightDependency: anObject  self heightDependencies add: anObjectdoesNotUnderstand: aMessage  ^self modules at: aMessage selector ifAbsent: [ super doesNotUnderstand: aMessage ]transmitIn: aContext  wasTransmited := true.  super transmitIn: aContextrenderGlamorouslyOn: aRenderer  ^aRenderer renderPane: selflabelActionMorphFor: aPresentation  ^aPresentation titleAction ifNil: [ nil ] ifNotNil: [:labelAction |  ((labelAction isAvailableOn: aPresentation) and: [ labelAction hasIcon ]) ifTrue: [ MultistateButtonMorph new                 extent: labelAction icon extent;                 activeEnabledOverUpFillStyle: (ImageFillStyle form: labelAction icon);                 setBalloonText: labelAction title;                 addUpAction: [ labelAction actOn: aPresentation ] ] ifFalse: [ nil ] ]moveAllSubbricksBy: anInteger  self band subbricks do: [:each |  each translateY: anInteger ].  self band translateY: anInteger negatedlayout: aBrick  aBrick isWidthDirty ifTrue: [ self widthTraverser layoutAround: aBrick inContext: nil ].  aBrick isHeightDirty ifTrue: [ self heightTraverser layoutAround: aBrick inContext: nil ]testNoDuplicateRegistrationsInFastTableRenderer  | table |  window := GLMCompositePresentation new     with: [:c |  c fastList ];     openOn: (1 to: 42).  table := self find: FTTableMorph in: window.  self assertNoDuplicatedAnnouncementsIn: table announcer.  self assertNoDuplicatedAnnouncementsIn: table dataSource announcerisActive  ^active ifNil: [ active := true ]testMultipleSelectionWithChangeFromModel  | browser firstTreeMorph secondTreeMorph |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list           beMultiple;           display: [:x |  x - 2 to: x ] ].  window := browser openOn: 4.  firstTreeMorph := window submorphs last submorphs first submorphs first submorphs first.  self assert: (firstTreeMorph model roots collect: #item) equals: #(2 3 4) asOrderedCollection.  ((browser paneNamed: #one) port: #selection) value: #(2 3).  self assert: ((browser paneNamed: #one) port: #selection) value asOrderedCollection equals: #(2 3) asOrderedCollection.  (browser pane port: #entity) value: 42.  secondTreeMorph := window submorphs last submorphs first submorphs first submorphs first.  self assert: (secondTreeMorph model roots collect: #item) equals: #(40 41 42) asOrderedCollection.  ((browser paneNamed: #one) port: #selection) value: #(40 41).  self assert: ((browser paneNamed: #one) port: #selection) value asOrderedCollection equals: #(40 41) asOrderedCollection.  self assert: firstTreeMorph ~= secondTreeMorphhintDelay  ^hintDelay ifNil: [ hintDelay := 700 ]context: anObject  context := anObjectrender: aPresentation  | presentations index |  presentations := aPresentation matchingPresentations.  presentations isEmpty ifTrue: [ ^GLMMorphic emptyMorph ].  (presentations size = 1 and: [ presentations first hasTitle not ]) ifTrue: [ ^self renderWithTitleOrNil: presentations first ].  tabs := LazyTabGroupMorph new.  tabs     vResizing: #spaceFill;     hResizing: #spaceFill;     cornerStyle: (self theme tabGroupCornerStyleIn: nil);     font: self theme buttonFont.  tabs announcer when: LazyTabPageChanged do: [:ann |  aPresentation announcer suspendAllWhile: [ aPresentation pane lastActivePresentation: (aPresentation matchingPresentations at: ann pageIndex) ] ].  presentations do: [:each |  tabs addLazyPage: [ self renderObject: each ] label: (self titleOrIconOf: each in: tabs) toolbar: (self renderToolbarForPresentation: each inMorph: tabs) action: (self labelActionBrickFor: each) ].  index := 1.  presentations withIndexDo: [:each :i |  (aPresentation pane isLastActivePresentation: each) ifTrue: [ index := i ] ].  tabs announcer suspendAllWhile: [ tabs selectedPageIndex: index ].  aPresentation when: GLMContextChanged send: #actOnContextChanged: to: self.  aPresentation when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  aPresentation when: GLMPresentationToolbarUpdated send: #actOnPresentationToolbarUpdated: to: self.  ^tabsclose  self foundationBrick delete.  self onClosedbrickDoubleLink: aDoubleLink  self setProperty: #brickDoubleLink toValue: aDoubleLinkwithAllSubbricks  ^self allSubbricks     add: self;     yourselfprevious  ^previousasOrderedCollection  ^selfremoveBrickNoLayout: aBrick  self band doNotLayoutDuring: [ self band removeBrick: aBrick ]explicitSelection: anObject  self table selectIndex: (self elements indexOf: anObject)worksWithMorphic  ^truefrom: aPort transformed: aBlock  ^(self addActiveOrigin: (self browser resolveOriginPort: aPort)) transformation: aBlockmouseUp: evt  super mouseUp: evt.  pagerModel recomputeState: isResizing not.  isResizing ifTrue: [ self setWidthAfterResizing ].  isResizing := false.  (self globalBounds containsPoint: evt position) ifFalse: [ self setCursorToNormal: evt ] ifTrue: [ self setCursorToResizing: evt ]sendTo: aDesinationPortReference from: anOriginPortReference  self transmissions addLast: (GLMTransmission new           addActiveOrigin: (self resolveOriginPort: anOriginPortReference);           destination: (self resolveDestinationPort: aDesinationPortReference);           yourself)on: anObject  self removeAllBricks.  anObject isCollection & anObject isString not ifFalse: [ self addBrickBack: (self collapsableFor: anObject) ] ifTrue: [ anObject do: [:each |  self addBrickBack: (self collapsableFor: each) ] ]shrinkingWidth  self rubric width: self rubric textArea width.  self onLayouted.  ^self rubric textArea widthrender: aPane  container := GLMMorphic containerMorph.  self renderContainerFor: aPane.  aPane when: GLMMatchingPresentationsChanged send: #actOnMatchingPresentationChanged: to: self.  (aPane presentations hasTitle or: [ aPane presentations hasTitleIcon ]) ifTrue: [ aPane when: GLMPresentationToolbarUpdated send: #actOnPresentationToolbarUpdated: to: self ].  ^containerhasFilterBlock  ^self parameters at: 'filterBlock' ifPresent: [ true ] ifAbsent: [ false ]do: aBlock  ^self presentations do: aBlockselectedClassOrMetaClass  ^self selectedBehaviorparentPrototype  ^parentPrototypestaticSmallWidth  ^50 * self currentWorld displayScaleFactorouterWidth: anInteger  self brickBounds: (self brickBounds withWidth: anInteger - self marginLeft - self marginRight)scrollUp: anInteger  self band translateY: anInteger.  self isTopOverscrolled ifTrue: [ self moveBandTop ]hShrinkWrap  super hShrinkWrap.  self label hShrinkWrap.  self dotsBrick hShrinkWrapnewTitleBrick  ^GLMLabelBrick newrowMorphForColumn: aColumn item: anItem withIndex: aRowIndex  | rowElements |  rowElements := OrderedCollection new.  self table columns first == aColumn ifTrue: [ self rowMorphElementsForFirstColumn: aColumn item: anItem in: rowElements ].  rowElements addAll: (self rowMorphElementsForColumn: aColumn glamourColumn node: (self dataFromPresentationItem: anItem) withIndex: aRowIndex).  ^Smalltalk ui theme newRowIn: self currentWorld for: rowElementsleft  ^GLMNorthDirection uniqueInstanceelementColumn  | row |  row := OrderedCollection with: self displayText.  ^(UITheme current newRowIn: self currentWorld for: row) fillStyle: Color veryLightGraytestSelectionTriggeredOnSelectedIndex  | browser dropdown text dropdownMorph textMorph |  browser := GLMTabulator new.  browser     row: #one;     row: #two.  browser transmit     to: #one;     andShow: [:a |  a dropDownList           display: [:x |  (1 to: x) + 10 ];           selectedIndex: 2 ].  browser transmit     from: #one;     to: #two;     andShow: [:a |  a text ].  window := browser openOn: 5.  dropdown := browser panes first presentations first.  self assert: browser panes second presentations size equals: 1.  text := browser panes second presentations first.  dropdownMorph := self findWherePresentationIs: dropdown in: window.  textMorph := self findWherePresentationIs: text in: window.  self assert: dropdownMorph selectedItem contents equals: '12'.  self assert: textMorph text asString equals: '12'glamourColumn: anObject  glamourColumn := anObjectasMorph  ^self asBrickedMorphselectionAct: aBlock icon: anIcon entitled: aString  self addSelectionAction: (GLMGenericAction new           action: aBlock;           icon: anIcon;           title: aString;           yourself)presentation  ^GLMCompositePresentation new with: [:a |  | t seg |        t := a text.        seg := RubPlainSegmentMorph from: 400 to: 746.        seg color: (Color green alpha: 0.3).        seg setBalloonText: 'This sentence should be removed. Click on it to remove it'.        seg when: #mouseDown send: #value to: [ seg textArea selectFrom: seg firstIndex to: seg lastIndex.              seg textArea replaceSelectionWith: ''.              seg delete ].        t addTextSegment: seg ]anchorBrick  ^anchorBrickouterBounds  ^self wrappedBounds outerBoundsvariableBindings: aDictionary  variableBindings := aDictionarycolumn: anObject evaluated: otherObject styled: anotherObject  self addColumn: (GLMPhlowTableColumn new           title: anObject;           computation: otherObject;           style: anotherObject)textFieldHeight  ^customHeight ifNil: [ self textArea height ] ifNotNil: [ customHeight brickValue: self ]resetTagsToFilterBy  tagsToFilterBy := OrderedCollection new.  self changed: #rootNodesselected: aBoolean  self isSelected ifTrue: [ self beSelected ] ifFalse: [ self beNormal ]onClosed  tagsFor: anObject to: operation  ^self tagsFor: anObject fromProvider: self to: operationforbidToAnnouncePresentationsChanged: aPane  self forbid: aPane toAnnounce: GLMPresentationsChangedextent  ^self brickBounds extenthasUnacceptedEdits: aBoolean  hasUnacceptedEdits := aBoolean.  self announce: RubEditsStateChangedInModel newtestEmbeddedBrowserRefreshesRendering  | tabulator finder tabulator1 textMorph1 textMorph2 content1 details1 |  tabulator := GLMTabulator new.  tabulator     row: #content;     row: #details.  tabulator transmit     to: #content;     andShow: [:a |  a list display: [:x |  1 to: x ] ].  tabulator transmit     from: #content;     to: #details;     andShow: [:a |  a text ].  tabulator transmit     from: #content;     toOutsidePort: #selection.  finder := GLMFinder new.  finder show: [:a |  a custom: tabulator ].  window := finder openOn: 42.  tabulator1 := finder panes first presentations first.  content1 := tabulator1 panes first.  details1 := tabulator1 panes second.  (content1 port: #selection) value: 41.  textMorph1 := self findWherePresentationIs: details1 presentations first in: window.  self assert: textMorph1 model getText equals: '41'.  (content1 port: #selection) value: 42.  self assert: tabulator1 identicalTo: finder panes first presentations first.  self assert: details1 identicalTo: tabulator1 panes second.  self assert: details1 presentations first text asString equals: '42'.  textMorph2 := self findWherePresentationIs: details1 presentations first in: window.  self assert: textMorph2 model getText asString equals: '42'isVShrinking  ^vResizing = #shrinkWrapsession  ^sessionsendEvent: aLayoutEvent to: aBrick  aBrick onLayoutEvent: aLayoutEventwithWidth: anInteger  self wrappedBounds width: anIntegernewScrollBrick  ^GLMPagerScrollBrick newtestMorphicActionDefinition  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a text morphicAct: [  ] entitled: ''.        a list morphicAct: [  ] entitled: ''.        a tree morphicAct: [  ] entitled: '' ].  browser startOn: #(42).  browser panes first presentations do: [:each |  self assert: each actions size equals: 1 ]outerWidth: anInteger  ^self brick wrappedBounds outerWidth: anIntegershadowOffset: aPoint  self setProperty: #brickShadowOffset toValue: aPointtextPosition: aSymbol  < brickBuilderProperty: #Text name: 'Text position' as: #asSymbol getter: #textPosition model: #GLMUIBuilderTextFieldProperty>  self label textPosition: aSymbol.  self dotsBrick textPosition: aSymbolportSymbol: anObject  portSymbol := anObjectpagerModel  ^pagerModelprivateMoveBy: delta  bounds := bounds translateBy: delta.  fullBounds ifNotNil: [ fullBounds := fullBounds translateBy: delta ]hScrollbarInterval  self scrollTarget width = 0 ifTrue: [ ^0 ].  ^self scrollBounds width asFloat / self scrollTarget width min: 1.0defaultSelectionActions  ^{(GLMGenericAction new     title: 'Print it';     action: [:aPresentation |  aPresentation printSelection ];     shortcut: $p;     yourself) .   (GLMGenericAction new     title: 'Do it';     action: [:aPresentation |  aPresentation evaluateSelection ];     shortcut: $d;     icon: GLMUIThemeExtraIcons glamorousSpawn;     yourself) .   (GLMGenericAction new     title: 'Inspect it';     action: [:aPresentation |  aPresentation evaluateSelectionAndDo: [:result |  result inspect ] ];     shortcut: $i;     icon: GLMUIThemeExtraIcons glamorousInspect;     yourself) .   (GLMGenericAction new     title: 'Debug it';     action: [:aPresentation |  aPresentation debugSelection ];     yourself) .   (GLMGenericAction new     title: 'Profile it';     action: [:aPresentation |  aPresentation profileSelection ];     yourself)}hasTags  ^self tagsBlock notNilseparatorBefore: aBoolean  separatorBefore := aBooleandoItReceiver  ^self glamourPresentation doItReceivernotifySynchronizeScrollTo: aValue  self notifyAll: (GLMPagerSynchronizeScrollAnnouncement new value: aValue)themerChanged  self onThemerChanged.  self subbricks do: #themerChangednewPagerBar  ^GLMPagerBarBrick newproperty: aSymbol  property := aSymbolrecomputeScrollBar  self sliderBrick ifNotNil: #setWidthAfterResizingnewTitleBrick  ^GLMRubTextAreaBrick newfromOutsidePort: aPortSymbol  ^self from: #outer port: aPortSymboltestLeftMarginChangeMyselfDependency  | root margin newMargin brick |  margin := 10.  newMargin := 20.  root := self newBrickWithStaticExtent.  brick := self newBrickWithSmallStaticExtent.  brick marginLeft: margin.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticSmallExtent.  self assert: brick brickBounds equals: (margin @ 0 extent: self staticSmallExtent).  brick marginLeft: newMargin.  brick doLayoutForce.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticSmallExtent.  self assert: brick brickBounds equals: (newMargin @ 0 extent: self staticSmallExtent)borderColor  ^self border colorhideOrShowScrollBar  self isScrollable ifTrue: [ self showScrollBar ] ifFalse: [ self hideScrollBar ]initializeItems  self band layoutAfter: [ 1 to: self model count do: [:index |  self band addBrickBack: ((self model morphAt: index convert: nil) asBrick with: [:b |  b brickApi layout vState isOnParent ifTrue: [ b height: 30 ] ]) ] ].  self band hasSubbricks ifFalse: [ self emptyBrick ifNotNil: [:b |  self band addBrickBack: b ] ]direction  ^directionallowAllNil  ^self useExplicitAllNilselectionPathValue  ^selectionPathValuestrongSelection: ann  self announcer announce: (GLMTreeMorphStrongSelectionChanged new           strongSelectionValue: (self elementAt: ann selectedIndex);           yourself)position: anObject  position := anObjecttestPropagationDuringCircularDependencies  | browser announcements |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #one;     andShow: [:a |  a list display: [:x |  1 to: x ] ].  browser transmit     from: #one;     to: #two;     andShow: [:a |  a list display: [:x |  1 to: x ] ].  browser transmit     from: #two port: #toSelect;     toOutsidePort: #toSelect.  browser transmit     fromOutsidePort: #toSelect;     to: #one port: #selection.  browser transmit     fromOutsidePort: #toSelect;     to: #two port: #selection.  browser startOn: 100.  ((browser paneNamed: #one) port: #selection) value: 50.  ((browser paneNamed: #two) port: #toSelect) value: 42.  self assert: ((browser paneNamed: #one) port: #selection) value equals: 42.  self assert: ((browser paneNamed: #two) port: #selection) value equals: 42.  announcements := GLMLogger instance announcements reverse reject: [:each |  each isKindOf: GLMTransmissionTriggered ].  self assert: (announcements first isKindOf: GLMMatchingPresentationsChanged).  self assert: (announcements second isKindOf: GLMPresentationsChanged).  self assert: (announcements third isKindOf: GLMContextChanged).  self assert: announcements third property equals: #toSelect.  self assert: (announcements fourth isKindOf: GLMContextChanged).  self assert: announcements fourth property equals: #toSelect.  self assert: (announcements fourth isKindOf: GLMContextChanged).  self assert: announcements fifth property equals: #selection.  self assert: announcements fifth value equals: 42.  self assert: (announcements fifth presentation isKindOf: GLMListPresentation).  self assert: announcements fifth presentation pane name equals: #two.  self assert: announcements sixth property equals: #selection.  self assert: announcements sixth value equals: 42.  self assert: (announcements sixth presentation isKindOf: GLMCompositePresentation).  self assert: announcements sixth presentation pane name equals: #tworightAngle: aDirection  ^self subclassResponsibilitylayoutPanes  | widths rect |  widths := self computeMorphWidths.  rect := 0 @ 0 extent: 0 @ self paneHeight.  transform submorphs with: widths do: [:m :w |  rect := rect withWidth: w.        m bounds: rect.        rect := rect translateBy: w @ 0 ]height  ^self brickBounds heightonPagePushed: addedAnnouncement  self addButton: self newButtonmorphAt: anInteger convert: aMorph  self subclassResponsibilityisLastActivePresentation: aPresentation  ^self lastActivePresentation notNil and: [ aPresentation title = self lastActivePresentation title ]withSeparatorBefore  self separatorBefore: truemarkWidthDirty  self widthState: #dirtycontentBackgroundColor  ^Color darkGray darkershowBoundsInHalo  ^truesetUp  super setUp.  pagerModel := GLMPagerModel new.  pagerMorph := GLMPagerBrick new pagerModel: pagerModel yourselfallExpanded  self shouldAllExpand: truetext: aString  self label text: aString.  self label text isEmpty ifTrue: [ self removeBrick: self label ] ifFalse: [ (self hasSubbrick: self label) ifFalse: [ self addBrickBack: self label ] ].  self doLayoutForceaddVariableBinding: anAssociation  self variableBindings at: anAssociation key put: anAssociation valueannouncer  ^announcer ifNil: [ announcer := GLMAnnouncer new ]allowedBounds  ^allowedBounds ifNil: [ allowedBounds := self globalBounds ]okButton: anObject  okButton := anObject.  self okButton     marginBottom: 3;     text: 'OK';     hAlign: #center;     when: #onClicked do: [ self window ifNotNil: [:w |  w close ] ].  self addBrickBack: self okButtonpopulate: aPortSymbol on: aCharacter with: aBlock  self addAction: (GLMGenericAction new           action: (GLMPortUpdater new                 portSymbol: aPortSymbol;                 valueBlock: aBlock;                 yourself);           shortcut: aCharacter;           yourself)strategy  ^self parameters at: 'strategy' ifAbsent: [ #default ]layoutAround: aBrick inContext: aContextBrick  aBrick isBrick ifFalse: [ ^self ].  (self isClean: aBrick) ifTrue: [ ^self ].  aBrick changed.  (self customDependencies: aBrick) do: [:each |  | b |        [ b := (each brickValue: aBrick) brickApi ] on: Exception do: [ b := nil ].        b ifNotNil: [ self layoutAround: b inContext: aBrick ] ].  (self stateOf: aBrick) layout: aBrick on: self.  self layoutSubbricks: aBrick.  self layoutSubbricks: aBrick owner.  aBrick changedannouncesNewSelection  ^self property = #selection and: [ self presentation selection ~~ self value ]vState  ^vStateinitialize  super initialize.  self     checkBrick: self newCheckboxBrick;     labelBrick: self newLabelBrick;     useHorizontalLinearLayout;     vShrinkWrap;     hShrinkWrap;     enableisBrick  ^trueactOnCompileText: ann  (ann session recompileMethodTo: ann presentation text inContext: ann context notifying: textMorph) ifTrue: [ ann action ifNotNil: [:action |  action value ] ]scrollPositionTop  ^scrollPosition ifNil: [ scrollPosition := 0 ]layout: aBrick on: aTraverser  aBrick owner ifNil: [ ^aTraverser markClean: aBrick ].  (aTraverser isDependsOnChildren: aBrick owner) ifTrue: [ Error signal: 'Circle dependency detected!' ].  aTraverser layoutOwnerOf: aBrick.  aTraverser updateDimension: aBrick.  aTraverser markClean: aBrick.  aTraverser layoutChildrenOf: aBrickupdate  self scrollDown: 0.  self scrollUp: 0.  self privateScrollPosition: self band brickBounds top.  self band onChildrenLayoutedpostCopy  super postCopy.  self resetAnnouncerresetAnnouncer  super resetAnnouncer.  self presentations do: [:each |  each resetAnnouncer ]shouldStop: aBoolean  shouldStop := aBooleanhandleKeyStroke: anEvent  self allKeystrokeActions detect: [:a |  anEvent commandKeyPressed and: [ a shortcut = anEvent keyCharacter ] ] ifFound: [:action |  self announcer announce: (GLMKeyStroke action: action) ]renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderActionListPresentation: selfinstallExportToCSV  self act: [ self exportToCSV ] entitled: 'Export to CSV'text: aString  (self pane port: #text) value: aString copyrender: aBrowser  | tabs |  aBrowser panes isEmpty ifTrue: [ ^GLMMorphic emptyMorph ].  tabs := LazyTabGroupMorph new.  tabs     vResizing: #spaceFill;     hResizing: #spaceFill;     cornerStyle: (self theme tabGroupCornerStyleIn: nil);     font: self theme labelFont.  aBrowser panes do: [:each |  self flag: 'add toolbar'.        tabs addLazyPage: [ GLMMorphicPaneWithoutTitleRenderer new                 renderer: self renderer;                 render: each ] label: (self titleOrIconOf: each presentations in: tabs) toolbar: (self renderToolbarForPresentation: each presentations inMorph: tabs) ].  tabs selectedPageIndex: 1.  aBrowser when: GLMBrowserClosed send: #actOnBrowserClosed: to: self.  ^tabsshouldExpandToLevel  ^expandLevel isNil notdiminishToLeft  self actualNumberOfVisiblePages = 1 ifTrue: [ ^self ].  self virtualLastVisiblePageIndex: self lastVisiblePageIndex - 1.  self recomputeStatemarkDirty  isDirty := truemarginLeft: anInteger  self translateX: anInteger - self marginLeft.  self margin at: Left put: anInteger.  self updateCachename: aString  name := aStringneedsStep: aBoolean  doStep := aBooleanmarginBottom: anInteger  self translateY: self marginBottom - anInteger.  self margin at: Bottom put: anInteger.  self updateCachemouseLeave: evt  self setCursorToNormal: evt.  super mouseLeave: evtshortcut: aCharacter  aCharacter ifNil: [ keymap := nil.        ^self ].  keymap := KMModifier meta + aCharacter asKeyCombinationtestHasTitleIcon  | presentation |  presentation := GLMPresentation new.  self assert: presentation hasTitleIcon not.  presentation titleIcon: 'something'.  self assert: presentation hasTitleIconselectedTab  ^self selectedIndex = 0 ifFalse: [ self tabs at: self selectedIndex ifAbsent: [ nil ] ]select: anEvent  self selectinvalidate  self scrollTo: self visibleIndexlayoutFloatingLeft: aBrick in: newBounds  | left top |  left := aBrick marginLeft.  top := aBrick marginTop.  aBrick brickBounds: (left @ top extent: aBrick extent).  ^0explicitlySelectItem: anObject  (self selectedItem notNil and: [ self selectedItem = anObject ]) ifTrue: [ ^self ].  (self selectedItem isNil and: [ anObject isNil ]) ifTrue: [ ^self ].  anObject ifNil: [ self selectNodePath: nil.        self selection: nil ].  self roots do: [:eachRoot |  eachRoot withContentsDo: [:each |  each item = anObject ifTrue: [ each expandParentPath.                    self selectNodePath: each path.                    ^self ] ] ]hasFixedSizePanes: aBoolean  hasFixedSizePanes := aBooleanshadowGradientFor: aBrick  ^GradientFillStyle ramp: {(0.0 -> aBrick shadowColor) .         (1.0 -> (aBrick shadowColor alpha: 0))}testPresentationsInmmutability  < expectedFailure>  | aPane presentations |  aPane := GLMPane in: 1.  self assertEmpty: aPane presentations.  presentations := aPane presentations.  presentations add: 1.  self assert: presentations size equals: 1.  self assertEmpty: aPane presentationsallContents  ^self childrenItems collect: [:d |  (self class with: d)           parentNode: self;           containerTree: self containerTree;           yourself ]helpText  ^niltestToSendMultipleValue  < expectedFailure>  | presentation |  presentation := GLMPresentation new.  presentation selection: (GLMMultiValue withAll: #(#foo #bar)).  self assert: presentation selection equals: #foo.  presentation selectionTransformation: [:first :second |  (first , second) asSymbol ]inset  ^6scrollerSizeShortcutAction: first second: second  first = #left & (second = #left) ifTrue: [ pagerModel enlargeToLeft ].  first = #left & (second = #right) ifTrue: [ pagerModel diminishToRight ].  first = #right & (second = #left) ifTrue: [ pagerModel diminishToLeft ].  first = #right & (second = #right) ifTrue: [ pagerModel enlargeToRight ]scrollBrick  ^scrollBrickwhiteRectangledTags  tagsStyle := #whiteRectangledButtonwithAnnotation  ^withAnnotation ifNil: [ withAnnotation := false ]lastVisiblePageIndex  | lastIndex |  lastIndex := self firstVisiblePageIndex + self numberOfVisiblePages - 1.  ^lastIndex > self size ifTrue: [ self size ] ifFalse: [ lastIndex ]pagerModel  ^pagerModeltestRemovingVariableSizePanesWhenChangingEntity  | finder |  finder := GLMFinder new variableSizePanes.  window := finder openOn: #a.  self assert: window submorphs last scrollTarget submorphs size equals: 2.  finder entity: #b.  self assert: window submorphs last scrollTarget submorphs size equals: 2testMarkerOneChildrenHeight  | brick |  brick := self newBrickWithFullDependsOnChildren.  self markFullyClean: brick.  brick wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthClean.  self assert: brick wrappedBounds isHeightDirtytestChildrenBlock  | browser check |  browser := GLMFinder new.  check := false.  browser show: [:a |  a tree children: [:each |  check := true.              #() ] ].  window := browser openOn: ($a to: $d).  self waitUntilUIRedrawed.  self assert: check equals: trueouterBounds  ^self brick outerBoundsactionList  ^self custom: GLMActionListPresentation newrubricCursorColor  ^self rubricTextColorintercellSpacing: aNumber  self parameters at: 'intercellSpacing' put: aNumberfirstOwnerSuchThat: conditionBlock  self allOwnersDo: [:m |  (conditionBlock cull: m) ifTrue: [ ^m ] ].  ^niltestPanePortTransmissionCallingReceiveIn  | originPort destinationPort transmission |  originPort := GLMTestPane new port: #originPort.  destinationPort := GLMTestPane new port: #destinationPort.  self assertEmpty: destinationPort seenTransmissions.  transmission := GLMTransmission new     addActiveOrigin: originPort;     destination: destinationPort;     transformation: [:x |  x + 1 ].  originPort value: 41.  transmission transmit.  self assert: destinationPort seenTransmissions size equals: 1.  self assert: destinationPort seenTransmissions first origins first value equals: 41.  self assert: destinationPort seenTransmissions first destination identicalTo: destinationPort.  self assert: destinationPort value equals: 42doItContext  ^self glamourPresentation doItContextowner: aBrick  | oldOwner |  oldOwner := self owner.  self privateOwner: aBrick.  aBrick ifNotNil: [ self themerChanged ] ifNil: [ self onRemovedFrom: oldOwner ]newContentMorph  | p |  p := GLMPanelMorph new     roundedCorners: #(2 3 4);     changeTableLayout;     layoutInset: 4;     cellInset: 8;     vResizing: #spaceFill;     hResizing: #spaceFill.  p borderStyle: (self theme tabPanelBorderStyleFor: self).  ^pdeselect  self owner ifNil: [ ^self ].  self layoutProperties minWidth: 0.  self owner doLayoutForcetestChangeChildrenInParentAndSubchildren  | parent brick child |  parent := self newBrickWithFullDependsOnChildren.  brick := self newBrickWithStaticExtent.  child := self newBrickFullHeightAndWidthDependsOnParent: 100.  parent addBrickBack: brick.  brick addBrickBack: child.  self assertAllSubbricksAreClean: parent.  self assert: parent extent equals: brick extent.  self assert: child extent equals: brick extent.  brick height: self staticHeight * 2.  brick width: self staticWidth * 2.  self assertAllSubbricksAreClean: parent.  self assert: brick extent equals: self staticExtent * 2.  self assert: parent extent equals: brick extent.  self assert: child extent equals: brick extentdisplay: anObject  self setProperty: #phlowDisplay toValue: anObjectallActions  ^self actions , self dynamicActions select: [:each |  each isAvailableOn: self ]sortByColumn: aGlamourColumn  columnToSortBy := columnToSortBy == aGlamourColumn ifTrue: [ nil ] ifFalse: [ aGlamourColumn ].  self updateRootshasSubbricks  ^self subbricks isEmpty notcolorBottom: aColor  self color at: Bottom put: aColorshouldShowHeader  ^self parameters at: 'shouldShowHeader' ifAbsent: [ true ]markClean: aBrick  aBrick markWidthCleantestPortInitializationFromTransmission  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     fromOutsidePort: #entity;     to: #one port: #entity;     andShow: [:a :entity |  a text initialize: [:pres |  pres                 text: 'foo' , entity asString;                 selectionInterval: (2 to: 3) ] ].  self assert: (browser panes first port: #text) value equals: nil.  self assert: (browser panes first port: #selectionInterval) value equals: nil.  browser startOn: 42.  self assert: (browser panes first port: #text) value equals: 'foo42'.  self assert: (browser panes first port: #selectionInterval) value equals: (2 to: 3).  (browser pane port: #entity) transientValue: 43.  self assert: (browser panes first port: #text) value equals: 'foo43'.  self assert: (browser panes first port: #selectionInterval) value equals: (2 to: 3).  (browser pane port: #entity) value: 44.  self assert: (browser panes first port: #text) value equals: 'foo44'.  self assert: (browser panes first port: #selectionInterval) value equals: (2 to: 3)morph  | morph |  morph := super morph.  morph editingMode: textModel glamourPresentation editingMode.  morph textFont: textModel glamourPresentation morphicFont.  morph hasUnacceptedEdits: false.  ^morphupdateHeight: aBrick on: aLayout  aBrick withHeight: (aLayout normalizeHeight: (aLayout heightMyselfDependency: aBrick) of: aBrick)amountToFilterBy  ^nildisplayFormat  ^displayFormat ifNil: [ displayFormat := self glamourPresentation format ]selection  ^(self pane port: #selection) valuerenderBackground: aBrick on: aCanvas  aCanvas drawPolygon: aBrick area vertices color: aBrick color borderWidth: 0 borderColor: Color transparenttext  ^self addBrickBack: self newTextassertHeightClean: aBrick  self assert: aBrick wrappedBounds heightState equals: #clean.  self assert: aBrick wrappedBounds isHeightDirty not.  self assert: aBrick wrappedBounds isHeightCleannormalColor: anObject  normalColor := anObjectaddGrabHandle: haloSpec  initialize  super initialize.  collection := OrderedCollection newevaluateAndPrintSelection  UIManager default defer: [ textMorph textArea editor printIt ]widthLeft  ^self width at: LeftisNotificationsAllowed  ^isNotificationsAllowed ifNil: [ isNotificationsAllowed := true ]testUpdateRecomputesMatchingPresentations  | browser collection matchingPresentationsChangedAnnounced |  collection := GLMAnnouncingCollection new.  collection add: 1.  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list when: [:col |  col isEmpty not ] ].  browser startOn: collection.  matchingPresentationsChangedAnnounced := false.  browser panes first when: GLMMatchingPresentationsChanged do: [:ann |  matchingPresentationsChangedAnnounced := true ].  collection removeLast.  browser update.  self assert: matchingPresentationsChangedAnnouncedpresentation  ^presentationmarkDirty: aBrick  self markLayoutDirty: aBrick owner.  aBrick markWidthDirtytestOnePanesShouldUpdateTheRenderedSelectionOnTheTriggerPane  | browser morphOne |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list display: [:x |  1 to: x ] ].  browser transmit     from: #one port: #strongSelection;     toOutsidePort: #toSelect.  browser transmit     fromOutsidePort: #toSelect;     to: #one port: #selection;     transformed: [:x |  x + 1 ].  window := browser openOn: 100.  (browser panes first port: #strongSelection) value: 41.  self assert: ((browser paneNamed: #one) port: #selection) value equals: 42.  morphOne := self findWherePresentationIs: (browser paneNamed: #one) presentations first in: window.  self assert: morphOne notNil.  self assert: morphOne selectedMorph notNilpopup: aPopupBrick event: anEvent  < return: #Boolean>  ^anEvent type = #mouseDown and: [ (aPopupBrick isInsideOfPopupBrick: anEvent) not ]asFormValue  | result |  result := OrderedCollection new.  self subbricks do: [:each |  each asFormValue ifNotNil: [:v |  result addAll: v asOrderedCollection ] ].  ^resultvalueBlock  ^valueBlockonSynchronizeScroll: announcement  self scrollTo: announcement value smooth: falsebounds  ^self globalBoundssortBlock  ^columnToSortBy sortBlock ifNil: [ columnToSortBy defaultSortBlockForPresentation: self glamourPresentation ]row: aBlockOrSymbol  ^self addRow: aBlockOrSymbolport  ^portrightAngle: aDirection  ^aDirection = GLMEastDirection uniqueInstanceisSelected  ^self tabSelector ifNil: [ false ] ifNotNil: [:selector |  selector selectedTab == self ]perform: aBlock delay: anInteger  self execute: [  ] withArguments: {} callback: aBlock delay: anIntegerdefaultInsetBeforeDots  ^1actOnMatchingPresentationsChanged: anAnnouncement  GLMWatcherWindow uniqueInstance addContent: [ self renderObject: anAnnouncement pane presentations ]window  ^windowaddBrickFirst: aBrick  | result |  result := self privateAddBrickFirst: aBrick asBrick.  self privatePrepareBrickAfterAdding: result.  self doLayoutForce.  ^aBrickbeError  self beMode: #beErrorfamilyName  ^familyNamebasicRoots  ^self glamourPresentation displayValueisDirty  ^isDirty ifNil: [ isDirty := true ]addTab: aStringOrMorph selected: selectedStringOrMorph  self tabs add: (self newLabelBrick: aStringOrMorph selected: selectedStringOrMorph).  self updateTabspresentations  ^OrderedCollection newstrongSelection: anObject  (self pane port: #strongSelection) value: (self selectionTransformation glamourValue: anObject)port  ^portformat: anObject  format := anObjecttestTabsLastActivePresentation  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list.        a text ].  window := browser openOn: 42.  self compositeTabGroup selectedPageIndex: 2.  self assert: browser panes first lastActivePresentation notNil.  self assert: (browser panes first lastActivePresentation isKindOf: GLMRubricTextPresentation)lastActivePresentation  ^lastActivePresentationscrollAtIndex: anIndex  self primarySelectionInterval: (anIndex to: anIndex - 1)collectionToDragPassenger: aCollection  ^aCollection size = 1 ifTrue: [ aCollection anyOne ] ifFalse: [ aCollection ]assignFocusableMorph: aMorph withPaneAt: paneIndex  focusedViews at: paneIndex put: aMorphpostCopy  | newPort |  super postCopy.  self flag: 'self unregisterFromAllAnnouncements ?'.  presentations := presentations copy.  ports := ports collect: [:each |  newPort := each copy.        newPort pane: self.        self flag: 'what about value?'.        newPort ]popPane  self popPane: falsedeselect  self isSelected ifTrue: [ isSelected := false.        self announce: #onMouseUnhover.        self changed ]titleValue  ^self title glamourValue: self entitysortBlock: anObject  sortBlock := anObjectactions: aBlock  self deprecated: 'use dynamicActionsOnSelection: for contextual actions, and dynamicActions for presentation-wide actions'.  ^self dynamicActionsOnSelection: aBlockpresentation  ^presentationscrollUp: anInteger  band brickBounds origin x >= 0 ifTrue: [ ^self ].  band brickBounds: (band brickBounds translateBy: anInteger @ 0).  band brickBounds origin x > 0 ifTrue: [ band brickBounds: (band brickBounds translateBy: (band brickBounds origin x @ 0) negated) ]addPaneFrom: aPort  self panes addLast: (GLMPane in: self).  self newTransmission     addActiveOrigin: aPort;     destination: (self panes last port: #entity);     transmit.  self announce: (GLMPaneAdded pane: self panes last atPosition: self panes size inBrowser: self)rubricTextFontSize  ^StandardFonts codeFont pointSizetransformation: anObject  transformation := anObjecttestUpdatingScriptPresentationPreservesSelection  | composite textPresentation textMorph |  composite := GLMCompositePresentation new with: [:c |  c pharoScript           title: 'Code';           act: [:aPresentation |  aPresentation update ] icon: GLMUIThemeExtraIcons glamorousRefresh entitled: 'Update presentation' ].  window := composite openOn: '1 + 2 + 3'.  textPresentation := composite presentations first.  textPresentation selectionInterval: (1 to: 5).  textMorph := self find: RubScrolledTextMorph in: window.  self assert: textPresentation selectionInterval equals: (1 to: 5).  self assert: textMorph selectionInterval equals: (1 to: 5).  self assert: textMorph getSelectionFromModel equals: (1 to: 0).  textPresentation update.  self assert: textPresentation selectionInterval equals: (1 to: 5).  self assert: textMorph selectionInterval equals: (1 to: 5).  self assert: textMorph getSelectionFromModel equals: (1 to: 0)paddingTop  ^self wrappedBounds paddingToptestTabsWithUpdate  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list.        a text ].  window := browser openOn: 42.  self assert: self compositeTabGroup pages size equals: 2.  self shouldnt: [ browser panes first presentations update ] raise: Errorto: anObject  toLogic := anObjectinvalidate  self band removeAllBricks.  self initializeItems.  self doLayoutForce.  self updaterenderStackedVerticallyCompositePresentation: aCompositePresentation  ^GLMMorphicVerticallyStackedRenderer render: aCompositePresentation from: selfmarginRight: anInteger  self translateX: self marginRight - anInteger.  self margin at: Right put: anInteger.  self updateCacheclouds  ^Color brickColorRegistry at: #brickClouds ifAbsentPut: [ Color r: 236 g: 240 b: 241 range: 255 ]resetStopStepping  stopStepping := false.  self changedtextPositionVerticalCenter  ^0 @ (self brickBounds height / 2.0) - (0 @ (self font height / 2.0)) truncatedmenu: aMorphMenu shifted: b  ^self menu: aMorphMenushouldFilterByTextInput  ^self glamourPresentation allowsFilter and: [ self inputText notEmpty ]transmit  self transmitIn: GLMTransmissionContext newopposite  ^GLMBrickHeightTraverser uniqueInstanceisOppositeClean: aBrick  ^aBrick isWidthCleanvector  ^vectorglobalOuterBounds  ^self owner ifNotNil: [ self outerBounds translateBy: self owner globalBoundsTranslateFactor ] ifNil: [ self outerBounds ]isOnMyself  ^falseisFullyVisible  ^self isFirstVisible & self isLastVisibletestOneSimpleRowAndOneNested  | layout |  layout := GLMTabulator new.  layout addRow: #first.  layout addRow: [:row |  row addColumn: #second.        row addColumn: #third.        row addColumn: #fourth ].  self assert: layout cell children size equals: 2.  self assert: layout cell children last children size equals: 3rowMorphElementsForFirstColumn: aColumn item: anItem in: rowElements  anItem depth timesRepeat: [ rowElements add: self class emptyMorph ].  rowElements add: (self buttonFor: anItem).  (self iconFor: anItem data) ifNotNil: [:icon |  rowElements add: icon asMorph ]wrappedBounds: aBounds  brickBounds := aBoundsallSubbricksDo: aBlock  self subbricks do: [:each |  each isBrick ifTrue: [ aBlock value: each.              each allSubbricksDo: aBlock ] ]hasTransformation  ^transformation isNotNil and: [ transformation ~= #yourself ]marginBottom  ^self margin at: BottomlogAnnouncement: anAnnouncement from: aGLMObject  testPublishingToOutsideAndInsideFinder  | innerBrowser finder realInnerBrowser |  finder := GLMFinder new.  innerBrowser := GLMTabulator new.  innerBrowser     column: #one;     column: #two.  innerBrowser transmit     to: #one;     andShow: [:a |  a list display: [:x |  1 to: 43 ] ].  innerBrowser transmit     to: #two;     from: #one;     andShow: [:a |  a text ].  innerBrowser transmit     toOutsidePort: #selection;     from: #one port: #selection.  finder show: [:a |  a custom: innerBrowser ].  self assert: innerBrowser transmissions size equals: 3.  self assert: innerBrowser transmissions second origins first pane identicalTo: innerBrowser panes first.  self assert: innerBrowser transmissions second destination pane identicalTo: innerBrowser panes last.  finder startOn: 43.  realInnerBrowser := innerBrowser.  self assert: realInnerBrowser transmissions size equals: 3.  self assert: realInnerBrowser transmissions second origins first pane identicalTo: realInnerBrowser panes first.  self assert: realInnerBrowser transmissions second destination pane identicalTo: realInnerBrowser panes laststrategy: aSymbole  self parameters at: 'strategy' put: aSymbolerenderShadowOf: aBrick on: aCanvas  aBrick shadowWidth = 0 ifTrue: [ ^self ].  self     topLeftCornerShadowOf: aBrick on: aCanvas;     topRightCornerShadowOf: aBrick on: aCanvas;     bottomRightCornerShadowOf: aBrick on: aCanvas;     bottomLeftCornerShadowOf: aBrick on: aCanvas;     leftShadowOf: aBrick on: aCanvas;     topShadowOf: aBrick on: aCanvas;     rightShadowOf: aBrick on: aCanvas;     bottomShadowOf: aBrick on: aCanvas.  aCanvas fillRectangle: ((aBrick brickBounds insetBy: aBrick shadowWidth / 2.0) translateBy: aBrick shadowOffset) color: aBrick shadowColortestTypeOfMultipleSelection  | composer firstTreeMorph treeNodeMorph |  composer := GLMCompositePresentation new.  composer fastList beMultiple.  window := composer openOn: {{1} asSet .         {1} asOrderedCollection}.  firstTreeMorph := self find: FTTableMorph in: window.  treeNodeMorph := firstTreeMorph selectionStrategy toggleIndex: 1.  self assert: composer selection asOrderedCollection equals: {{1} asSet} asOrderedCollectioncomputation  ^computationtags: aBlock  self tagsBlock: aBlock.  self hasTagsFilter ifFalse: [ self tagsFilter: aBlock ]canAnnounceMatchingPresentationsChanged: aPane  ^self can: aPane announce: GLMMatchingPresentationsChangedrubricText  self deprecated: 'Use #text instead'.  ^self custom: GLMRubricTextPresentation newfilteredRoots  | filtered |  roots ifNil: [ self roots: self displayValue ].  filtered := roots select: [:each |  each shouldBeDisplayed ].  ^filteredinstallKeyCombinationForPresentation: aPresentation onMorph: aMorph  aMorph bindKeyCombination: self keymap toAction: [ self actOn: aPresentation ]cellColumn: aColumnIndex row: aRowIndex  | item cell |  item := self elementAt: aRowIndex.  cell := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForItem: item);     yourself.  ^cellinitialize  super initialize.  color := Color transparent.  self fillStyle: nil.  submorphs := OrderedCollection new.  self     layoutProperties: GLMBrickLayoutProperties new;     useHorizontalLinearLayout;     renderer: self defaultRendererrenderShadow: aBrick vector: aVector origin: anOrigin on: aCanvas  | anInset anOffset aShadowWidth aShadowOrigin aShadowVector aShadowLength aGradient aRectangle |  anInset := aBrick shadowInset.  anOffset := aBrick shadowOffset.  aShadowWidth := aBrick shadowWidth.  aShadowVector := aVector left length: aShadowWidth.  aShadowLength := aVector length + (anInset * 2.0).  ((aVector rightAngle: aVector next) or: [ aVector previous rightAngle: aVector ]) ifTrue: [ aShadowLength := aShadowLength - aShadowWidth + (anInset negated * 2) ].  aShadowOrigin := anOrigin + anOffset + (aShadowVector * anInset) - (aVector * anInset).  (aVector previous rightAngle: aVector) ifTrue: [ aShadowOrigin := aShadowOrigin + (aVector * aShadowWidth) + (aVector * anInset * 2) ].  aGradient := (self shadowGradientFor: aBrick)     origin: aShadowOrigin;     direction: aShadowVector * aShadowWidth;     yourself.  aRectangle := aShadowVector origin: aShadowOrigin breadth: aShadowLength.  aCanvas fillRectangle: aRectangle fillStyle: aGradientchanged  ^fullBounds ifNil: [ self invalidRect: self privateFullBounds ] ifNotNil: [ self invalidRect: fullBounds ]testMarkerOneChildrenInParentWidth  | root brick |  root := self newBrickWithFullFill.  brick := self newBrickWithFullDependsOnChildren.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightCleanokToStyle  ^truesetUp  super setUp.  browser := GLMExplicitBrowser new.  browser addPane: (GLMPane new name: #one).  browser addPane: (GLMPane new name: #two).  browser addPane: (GLMPane new name: #three)testSimplePresentations  | pane presentation announcement |  pane := GLMPane named: 'test'.  presentation := GLMPresentation new.  self assertEmpty: pane presentations.  announcement := nil.  pane when: GLMPresentationsChanged do: [:ann |  announcement := ann ].  pane addPresentation: presentation.  self assert: pane presentations size equals: 1.  self assert: pane presentations first identicalTo: presentation.  self assert: presentation pane identicalTo: pane.  self assert: announcement notNilwatcherPane: anObject  watcherPane := anObjectremoveAllBricks  | copy |  copy := self subbricks copy.  self privateRemoveAllBricks.  copy do: [:b |  self privatePrepareBrickAfterRemoving: b ].  self doLayoutForcerenderDiffPresentation: aPresentation  ^GLMMorphicDiffRenderer render: aPresentation from: selftestAllSelectionActionsWithNoSelection  | listing |  listing := GLMPresentation new.  listing addSelectionAction: GLMAction new.  listing addSelectionAction: GLMAction new.  listing dynamicActionsOnSelection: [:p |  OrderedCollection with: GLMAction new with: GLMAction new with: GLMAction new ].  self assert: listing allSelectionActions size equals: 2testEquality  | presentation |  presentation := GLMPresentation new.  self assert: (presentation = presentation copy) notnonFloatSubbricks: aBrick  ^aBrick subbricks select: [:each |  each layout floating = #none ]renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderDynamicPresentation: selfregisterEventsForPresentation: aPresentation  aPresentation when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  aPresentation when: GLMContextChanged send: #actOnContextChanged: to: self.  aPresentation when: GLMSelectCurrentLine send: #selectLine to: selfspecificTableMorphInitializiation  | presentation |  super specificTableMorphInitializiation.  presentation := tableModel glamourPresentation.  presentation shouldAllExpand ifTrue: [ tableModel expandAll ].  presentation shouldRootsExpand ifTrue: [ tableModel expandRoots ].  presentation shouldExpandToLevel ifTrue: [ tableModel expandAllTo: presentation expandLevel ]beMultiple  allowsMultipleSelection := trueisKeyboardScrollEvent: anEvent  anEvent controlKeyPressed | anEvent commandKeyPressed ifFalse: [ ^false ].  anEvent keyValue = 30 ifTrue: [ ^true ].  anEvent keyValue = 31 ifTrue: [ ^true ].  ^falserenderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderTreePresentation: selfopen  ^self openWith: self defaultRenderertitle: anObject  title := anObjectonCreated  self subclassResponsibilityact  self popup closenotifySelectedPageChanged  self notifyAll: GLMSelectedPageChanged newtestPorts  | pane port |  pane := GLMPane named: 'test'.  self assertEmpty: pane ports.  port := pane port: #foo.  self assert: pane ports size equals: 1.  self assert: pane ports first identicalTo: port.  self assert: (pane port: #foo) identicalTo: portdebugHighlightedText  UIManager default defer: [ textMorph textArea editor debugHighlight.        textMorph shoutStyler style: textMorph text ]defaultRenderer  ^GLMInteractableBrickRenderer newenableFilterWithAction: aBlock named: aString  self enableFilter.  self parameters     at: 'actionBlock' put: aBlock;     at: 'actionName' put: aStringtestInterdependentPanesProperPorts  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two;     column: #three.  browser transmit     to: #one;     andShow: [:a |  a list display: [:x |  1 to: x ] ].  browser transmit     to: #two;     from: #one;     andShow: [:a |  a list display: [:x |  1 to: x * 2 ] ].  browser transmit     to: #three;     from: #two;     andShow: [:a |  a list           display: [:x |  1 to: x * 3 ];           populate: #focus on: $f entitled: 'Focus' with: [:list |  list selection ] ].  browser transmit     toOutsidePort: #focus;     from: #three port: #focus.  browser transmit     to: #one port: #selection;     fromOutsidePort: #focus;     transformed: [:x |  x + 1 ].  browser transmit     to: #two port: #selection;     fromOutsidePort: #focus;     transformed: [:x |  x + 2 ].  browser startOn: 5.  ((browser paneNamed: #one) port: #selection) value: 3.  ((browser paneNamed: #two) port: #selection) value: 6.  ((browser paneNamed: #three) port: #selection) value: 12.  ((browser paneNamed: #three) port: #focus) value: 12.  self assert: (browser pane port: #focus) value equals: 12.  self assert: ((browser paneNamed: #one) port: #entity) value equals: 5.  self assert: ((browser paneNamed: #one) port: #selection) value equals: 13.  self assert: ((browser paneNamed: #two) port: #entity) value equals: 13.  self assert: ((browser paneNamed: #two) port: #selection) value equals: 14.  self assert: ((browser paneNamed: #three) port: #entity) value equals: 14.  self assert: ((browser paneNamed: #three) port: #selection) value equals: nilhighlightingLogic: aBlockWithTwoParameters  self setProperty: #brickHighlightingLogic toValue: aBlockWithTwoParameterstestSimple  | pane1 pane2 transmission |  pane1 := GLMPane named: 'test1'.  pane2 := GLMPane named: 'test2'.  transmission := GLMTransmission new     addActiveOrigin: (pane1 port: #output);     destination: (pane2 port: #input);     yourself.  (pane1 port: #output) value: 42.  self assert: (pane1 port: #output) value equals: 42.  self assert: (pane2 port: #input) value equals: nil.  transmission transmit.  self assert: (pane1 port: #output) value equals: 42.  self assert: (pane2 port: #input) value equals: 42press  self isPressed ifFalse: [ isPressed := true.        self changed ].  ^falsestrongSelection: ann  self announcer announce: (GLMTreeMorphStrongSelectionChanged new           strongSelectionValue: (self elementAt: ann selectedIndex);           yourself)validate: anObject  self pane presentations isEmpty ifTrue: [ ^true ].  ^self pane presentations allSatisfy: [:each |  each validate: anObject on: self ]padding: aCollection  < brickBuilderProperty: #Geometry name: 'Padding' as: #brickBuilderEvaluate getter: #padding model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds padding: aCollectioninnerPortEvent: aPortEvent  aPortEvent isEntityPort ifFalse: [ (self pane port: aPortEvent portName) value: aPortEvent value ].  aPortEvent isSelectionPort ifTrue: [ | index toReplace |        index := self panes reversed indexOf: aPortEvent pane.        (self panes reversed first: index - 2) do: [:each |  self removeLastPane.              self announce: (GLMPaneRemoved pane: each fromBrowser: self) ].        index <= 1 ifTrue: [ self addPaneFromInner: aPortEvent port.              self announce: (GLMPaneAdded pane: self panes last atPosition: self panes size inBrowser: self) ] ifFalse: [ toReplace := self removeLastPane.              self lastActivePresentation: toReplace lastActivePresentation.              self addPaneFromInner: aPortEvent port.              self announce: (GLMPaneReplaced oldPane: toReplace newPane: self panes last fromBrowser: self) ] ]needActionButton  ^self parameters at: 'actionBlock' ifPresent: [ true ] ifAbsent: [ false ]selectionAct: aBlock on: aCharacter entitled: aString  self addSelectionAction: (GLMGenericAction new           action: aBlock;           shortcut: aCharacter;           title: aString;           yourself)text: aString  self label text: aStringpopPane  self band doNotLayoutDuring: [:b |  b removeBrick: b lastSubbrick ].  self doLayoutForcecustom: aPresentation  self subclassResponsibilitytestNestedBrowserEntity  | browser innerBrowser realInnerBrowser |  browser := GLMTabulator new.  browser column: #one.  innerBrowser := GLMTabulator new.  innerBrowser column: #innerOne.  innerBrowser transmit     to: #innerOne;     from: #outer port: #entity;     andShow: [:a |  a text ].  browser transmit     to: #one;     andShow: [:a |  (a custom: innerBrowser) display: [:x |  x + 2 ] ].  browser startOn: 40.  realInnerBrowser := (browser paneNamed: #one) presentations first.  self assert: ((browser paneNamed: #one) port: #entity) value equals: 40.  self assert: (realInnerBrowser pane port: #entity) value equals: 40.  self assert: ((realInnerBrowser paneNamed: #innerOne) port: #entity) value equals: 42find: aClass in: aMorph  ^self findSatisfying: [:morph |  morph isKindOf: aClass ] in: aMorphselect: anEvent  super select: anEvent.  hoverAction ifNotNil: [:a |  a brickValue: self withEnoughArguments: {anEvent} ]formatedDisplayValueOf: anObject  ^self format glamourValue: anObject asGlamorousMultiValue , self entity asGlamorousMultiValueinputTextEnabled  ^truebounds: anObject  bounds := anObjectaddRow: aBlockOrSymbol span: anInteger  ^(self addRow: aBlockOrSymbol)     span: anInteger;     size: 0tagsStyle  ^tagsStyle ifNil: [ self grayRoundedTags.        tagsStyle ]usesExplicitNotNil  ^self usesImplicitNotNil notrubricTextFamilyName  ^StandardFonts codeFont familyNamedrawKeyboardFocusOn: aCanvas  initialize  super initialize.  ports := OrderedCollection new.  presentations := GLMCompositePresentation new     pane: self;     yourselfinitialize  super initialize.  origin := 0 @ 0shouldUseCache  ^self glamourPresentation shouldUseCachelayoutMorphs: aBoolean  self band layoutMorphs: aBooleanparameter: anObject  parameter := anObjectrequestRefresh  self pane ports do: [:each |  (self validate: each value on: each) ifFalse: [ each resetValue ] ].  self announce: (GLMPresentationRefreshRequest new presentation: self)testContext  | pane presentation |  pane := GLMPane named: 'test'.  presentation := GLMPresentation new.  pane addPresentation: presentation.  presentation selection: 42.  self assert: (pane port: #selection) value equals: 42.  (pane port: #entity) value: 'foo'.  self assert: presentation entity equals: 'foo'focusPaneAt: pageIndex  (self isFocusedMorphVisibleAt: pageIndex) ifTrue: [ focusedPageIndex := pageIndex.        (self focusedViewAt: pageIndex) activeHand newKeyboardFocus: (self focusedViewAt: pageIndex).        self notifyFocusedPageChanged ]alertOn: anObject  self textBrick text: anObject asStringtestSetup  | presentation |  presentation := GLMPresentation new.  self assert: presentation pane notNil.  self assert: (presentation pane presentations includes: presentation)privateRemoveBrick: aBrick  | predecessor successor link head tail index |  aBrick ifNil: [ ^aBrick ].  (self hasSubbrick: aBrick) ifFalse: [ ^aBrick ].  link := aBrick brickDoubleLink.  head := self firstSubbrick brickDoubleLink.  tail := self lastSubbrick brickDoubleLink.  predecessor := link previousLink.  successor := link nextLink.  predecessor ifNotNil: [ predecessor nextLink: successor ].  successor ifNotNil: [ successor previousLink: predecessor ].  link clearLinks.  aBrick brickDoubleLink: nil.  index := self subbricks find: aBrick.  self privateSubbricks: (self subbricks copyWithoutIndex: index).  aBrick owner: nil.  ^aBrickportEvent: aPortEvent  aPortEvent portName = #entity ifTrue: [ self unregisterFromAllAnnouncements ].  self browser innerPortEvent: aPortEvent.  self presentations outerPortEvent: aPortEventhasStatusbar: aBoolean  aBoolean ifTrue: [ statusPane := self addPane: (GLMPane new name: self class defaultStatusbarPane) ]withChildrenOf: anObject do: aBlock  aBlock value: anObject.  (self childrenValueOf: anObject) do: [:each |  self withChildrenOf: each do: aBlock ]defaultPopupLayout  ^GLMPopupBrickDownwardLayout newtestValidateWithMultipleSelection  | pane presentation |  pane := GLMPane named: 'test'.  presentation := GLMListPresentation new.  presentation beMultiple.  presentation shouldValidate: true.  pane addPresentation: presentation.  presentation entity: ($a to: $d).  self assert: (presentation validate: (Array with: $a) on: (pane port: #selection)).  self assert: (presentation validate: (Array with: $a with: $b) on: (pane port: #selection)).  self deny: (presentation validate: $a on: (pane port: #selection)).  self deny: (presentation validate: (Array with: $z) on: (pane port: #selection))isColumn  ^trueaddRawSelectionTransmissionTo: aPortSymbol  ^rawSelectionTransmissions add: (GLMTransmission new           addActiveOrigin: (GLMPresentationBoundPort new                 name: #rawSelection;                 presentation: self;                 yourself);           destination: (GLMPresentationBoundPort new                 name: aPortSymbol;                 presentation: self;                 yourself))ensure: aBlock  ensureLogic := aBlockbounds: aRectangle  self layoutAfter: [:b |  b wrappedBounds bounds: aRectangle ]isVFilling  ^vResizing = #spaceFillsortBlock  ^sortBlockwithoutMargins  self margins: 0 asMarginshouldRootsExpand  ^rootsExpanded ifNil: [ false ]uncheck  self box uncheck.  self label uncheck.  super uncheckvalue  self subclassResponsibilitywidthTop  ^self width at: ToptestSimple  | expander |  expander := GLMExpander new.  expander startOn: #(#a #b #c).  self assert: expander panes size equals: 3.  self assert: (expander panes first port: #entity) value equals: #atestPresentationBoundPort  | browser outerPort1 outerPort2 transmission1 transmission2 |  browser := GLMExplicitBrowser new.  browser addNewPane.  GLMTestPane new addPresentation: browser.  outerPort1 := GLMPresentationBoundPort new     presentation: browser;     name: #outerPort1;     yourself.  outerPort2 := GLMPresentationBoundPort new     presentation: browser;     name: #outerPort2;     yourself.  browser addTransmission: (transmission1 := GLMMockSimpleTransmission new           addActiveOrigin: outerPort1;           destination: (browser panes first port: #innerPort1);           yourself).  browser addTransmission: ((transmission2 := GLMMockSimpleTransmission new)           addActiveOrigin: (browser panes first port: #innerPort2);           destination: outerPort2;           yourself).  (browser pane port: #outerPort1) value: 42.  self assert: (browser panes first port: #innerPort1) value equals: 42.  self assert: transmission1 wasTransmited.  self deny: transmission2 wasTransmited.  (browser panes first port: #innerPort2) value: 43.  self assert: (browser pane port: #outerPort2) value equals: 43actOnContextChanged: ann  ann property = #selectionInterval ifTrue: [ ann value notNil ifTrue: [ textMorph setSelection: ann value ] ifFalse: [ textMorph setSelection: (1 to: 0) ] ]includes: anObject  ^collection includes: anObjectuseCache  self parameters at: 'shouldUseCache' put: truerenderListingPresentation: aPresentation  ^GLMMorphicListingRenderer render: aPresentation from: selfelementOrZeroAt: rowIndex  ^rowIndex = 0 ifTrue: [ 0 ] ifFalse: [ self elementAt: rowIndex ]initializeAction: anAction on: aMenuMorph  self action: anAction.  menuMorph := aMenuMorphisOnParent  ^trueinitialize  super initialize.  children := [ #() ]markHeightClean  self heightState: #cleanrubricTextFamilyName  ^self valueOfProperty: #brickRubricTextFamilyName ifAbsent: [ self themer rubricTextFamilyName ]withAllPanesAndPresentationsDo: aBlock  super withAllPanesAndPresentationsDo: aBlock.  self cachedPresentation ifNotNil: [:presentation |  presentation withAllPanesAndPresentationsDo: aBlock ]allowsDeselection: anObject  allowsDeselection := anObjectpaddingBottom: anObject  < brickBuilderProperty: #Geometry name: 'Padding Bottom' as: #asInteger getter: #paddingBottom model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds paddingBottom: anObjecttestSymbolAsTargetIdentifier  self assert: (#pane asGlamourTargetIdentifier isKindOf: GLMPortIdentifier).  self assert: #pane asGlamourTargetIdentifier paneName equals: #pane.  self assert: #pane asGlamourTargetIdentifier portName equals: #entityscrollDeltaWidth  ^1editingMode  ^editingMode ifNil: [ nil ] ifNotNil: [ editingMode glamourValue: self ]renderWithToolbar: aPresentation  | presentationMorph |  presentationMorph := self renderObject: aPresentation.  ^self morph: presentationMorph withToolbarOf: aPresentationinstallActionsOnModel: aMorphicModel fromPresentation: aPresentation  aMorphicModel when: GLMMenuItemSelected do: [:ann |  ann action morphicActOn: aPresentation ].  aMorphicModel when: GLMKeyStroke do: [:ann |  ann action actOn: aPresentation ]testColumnLabel  | browser tableMorph |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a table           display: [:x |  x - 3 to: x ];           column: 'Column' evaluated: [:x |  x asString ];           column: [:x |  'Number ' , x asString ] evaluated: #asString ].  window := browser openOn: 4.  tableMorph := self find: MorphTreeMorph in: window.  self assert: (tableMorph model roots collect: #item) equals: #(1 2 3 4) asOrderedCollection.  self assert: tableMorph columns first header label equals: 'Column'.  self assert: tableMorph columns last header label equals: 'Number 4'action  ^actiontestFormat  | presentation |  presentation := GLMFormatedPresentation new.  presentation format: [:c |  c ].  self assert: (presentation formatedDisplayValueOf: 1) equals: 1.  presentation entity: 41.  presentation format: [:a :c |  a + c ].  self assert: (presentation formatedDisplayValueOf: 1) equals: 42.  presentation entity: (GLMMultiValue with: 20 with: 21).  presentation format: [:a :b :c |  a + b + c ].  self assert: (presentation formatedDisplayValueOf: 1) equals: 42onButtonClicked: ann  self pagerModel switchPaneTo: ann buttonModel indextestSelectionIntervalInitialization  | presentation |  presentation := GLMRubricTextPresentation new initialize: [:pres |  pres selectionInterval: (3 to: 9) ].  self assert: presentation selectionInterval equals: nil.  presentation initializePresentation.  self assert: presentation selectionInterval equals: (3 to: 9)handleListenEvent: anEvent  self predicates detect: [:aPredicate |  aPredicate popup: self popup event: anEvent ] ifFound: [:aPredicate |  self act ]scrollingDelay  ^scrollingDelay ifNil: [ scrollingDelay := 100 ]value: anObject  self value: anObject in: GLMTransmissionContext newdrawOnAthensCanvas: anAthensCanvas  anAthensCanvas pathTransform restoreAfter: [ anAthensCanvas pathTransform translateBy: self globalBounds origin - self brickBounds origin.        self onDrawAthensCanvas: anAthensCanvas ]anySatisfy: aBlock  ^self presentations anySatisfy: aBlockpane: aPane  super pane: aPane.  self presentations do: [:each |  each pane: aPane ]selectionValue  ^selectionValuepane  ^pane ifNil: [ pane := (GLMPane named: 'root' in: GLMNoBrowser new)           presentations: self;           yourself ]setCursorToResizing: evt  evt hand showTemporaryCursor: self resizeCursorwidth  ^width ifNil: [ 200 ]spacing  ^0brickBounds: aRectangle  self wrappedBounds brickBounds: aRectangleopenWith: aRenderer  ^aRenderer open: selfcolorLeft  ^self color at: Leftport: aPort  port := aPortusesImplicitAllNil  ^implicitAllNil ifNil: [ implicitAllNil := false ]priority  ^priority ifNil: [ priority := Processor userSchedulingPriority ]newButtonBrick  ^GLMButtonBrick newrawSelection  ^(self pane port: #rawSelection) valueisInsideOfContentBrick: anEvent  self contentBrick ifNil: [ ^false ] ifNotNil: [:aBrick |  anEvent withHandPositionDo: [:position |  ^aBrick boundsInWorld containsPoint: position ] ]keymap  ^keymaptestUnregisterAnnouncementsWhenRemovingPane  | announcer browser presentation actualFirstPresentation actualLastPresentation |  announcer := GLMAnnouncer new.  browser := GLMFinder new.  presentation := GLMPresentation new.  presentation title: [:entity |  entity ].  browser addPresentation: presentation.  presentation updateOn: GLMTestAnnouncement from: [ announcer ].  browser entity: #value1.  actualFirstPresentation := browser panes first presentations first.  actualFirstPresentation registerAnnouncements.  self assert: announcer numberOfSubscriptions equals: 1.  self assert: announcer glmSubscriptions anyOne announcementClass equals: GLMTestAnnouncement.  self assert: announcer glmSubscriptions anyOne subscriber presentation equals: actualFirstPresentation.  self assert: announcer glmSubscriptions anyOne subscriber presentation identicalTo: actualFirstPresentation.  (browser panes first port: #selection) value: #value2.  browser panes last presentations first registerAnnouncements.  actualLastPresentation := browser panes last presentations first.  self assert: announcer numberOfSubscriptions equals: 2.  self assert: (announcer glmSubscriptions allSatisfy: [:each |  each announcementClass = GLMTestAnnouncement ]).  self assert: (announcer glmSubscriptions anySatisfy: [:each |  each subscriber presentation = actualFirstPresentation ]).  self assert: (announcer glmSubscriptions anySatisfy: [:each |  each subscriber presentation == actualFirstPresentation ]).  (browser panes first port: #selection) value: #value3.  actualLastPresentation := browser panes last presentations first.  self assert: announcer numberOfSubscriptions equals: 1.  self assert: announcer glmSubscriptions anyOne announcementClass equals: GLMTestAnnouncement.  self assert: announcer glmSubscriptions anyOne subscriber presentation equals: actualFirstPresentation.  self assert: announcer glmSubscriptions anyOne subscriber presentation identicalTo: actualFirstPresentationallMenuActions  ^self glamourPresentation allSelectionActions select: [:action |  action hasTitle ]specificDataSourceInitializiation  addLazyPage: aBlock label: aStringOrMorph  self addLazyPage: aBlock label: aStringOrMorph toolbar: nilscrollbarWidth  ^3privatePrepareBrickAfterAdding: aBrick  aBrick wrappedBounds     markWidthDirty;     markHeightDirty.  self privateAddIntoWorld: aBrickwithString: string from: aMorph  aMorph textArea removeHighlightSegment.  super withString: string from: aMorphprintOn: aStream  super printOn: aStream.  aStream     nextPutAll: '(id=';     print: self identityHash;     nextPutAll: ' title=';     print: self titleValue;     nextPutAll: ' pane=';     print: self pane;     nextPutAll: ')'column: aBlockOrSymbol span: anInteger  ^self addColumn: aBlockOrSymbol span: anIntegerconfigurePane: aBrick  | brick |  brick := aBrick asBrick.  brick     layoutProperties: GLMBrickLayoutProperties new;     width: [ self band width / self band subbricksCount ];     vSpaceFill;     marginLeft: self paneMargin;     marginRight: self paneMargin.  brick layout widthDependency: self band.  ^brickpageIndex  ^pageIndexactOnPaneReplaced: ann  self subclassResponsibilitytransformation: anObject  transformation := anObjectonPageSwitched  self updateButtonsdrawKeyboardFocusOnAthensCanvas: aCanvas  value  ^self port valuedoNotUpdateDuring: aBlock  self isUpdating ifTrue: [ ^self ].  isUpdating := true.  aBlock cull: self.  isUpdating := falsecalculateMaxVelocity  ^self band height / 15 max: self class defaultMaxVelocityopposite  ^GLMBrickWidthTraverser uniqueInstancescrollToTop  self scrollTo: 1finishTime  ^self startTime + self durationonChildrenLayouted  super onChildrenLayouted.  self scrollpane ifNotNil: [:s |  s updateScrollbar ].  self shouldLayoutMorphs ifFalse: [ ^self ].  self asyncTask perform: [ self updateMorphBounds ] delay: 400 priority: Processor userBackgroundPriority + 1computeAnnouncerObjects  self flag: 'We catch the error because if there is a problem in the computation of the announcer object, we still want to be able to continue the execution'.  ^OrderedCollection with: ([ self transformation glamourValue: self presentation entity ] on: Error do: [:e |  self presentation entity.              e resume ])vSpaceFill  self vSpaceFill: 100testCopyTheTransformation  | presentation newPresentation |  presentation := GLMPresentation new.  presentation selectionTransformation: [:each |  each + 1 ].  newPresentation := presentation copy.  self assert: (presentation selectionTransformation value: 1) equals: 2.  self assert: (newPresentation selectionTransformation value: 1) equals: 2hasMinDimensionRestriction: aBrick  ^self subclassResponsibilitymorphicSelectionAct: aBlock entitled: aString  self addSelectionAction: (GLMMorphicAction new           action: aBlock;           title: aString;           yourself)contentBrick: aBrick  contentBrick := aBrick.  self addBrickBack: contentBrickselectionAct: aBlock entitled: aString  self addSelectionAction: (GLMGenericAction new           action: aBlock;           title: aString;           yourself)testOriginTransformedValue  | port reference |  port := GLMSimplePort new value: 41.  reference := GLMOriginPortReference new     port: port;     transformation: [:x |  x + 1 ].  self assert: reference value equals: 42enableFilterWithAction: aBlock  self enableFilter.  self parameters at: 'actionBlock' put: aBlockandShowIfNone: aBlock  self ensurePresentIfNoneStrategy.  self transmissionStrategy presentationsFactory: aBlock.  self origins isEmpty ifTrue: [ self from: #outer port: #entity ]isVisible: aBrick  | myBounds testingBounds |  myBounds := (self allowedBounds withWidth: 0) translateBy: self allowedBounds origin negated x @ 0.  testingBounds := (aBrick globalBounds withWidth: 0) translateBy: aBrick globalBounds origin negated x @ 0.  ^myBounds containsRect: testingBoundsmoveBandTop  self band translateY: self bandTopOffset negatedtestDefaultPresentations  | pane |  pane := GLMPane named: 'test'.  self assert: (pane presentations isKindOf: GLMCompositePresentation)morphFrom: aMorphPresentation  | morph |  morph := aMorphPresentation morph     vResizing: #spaceFill;     hResizing: #spaceFill;     yourself.  (self allKeyboardActionsFor: aMorphPresentation) ifNotEmpty: [ morph on: #keyStroke send: #actOnKeyStroke:event:from: to: self withValue: aMorphPresentation ].  ^morphinitialize  super initialize.  updateActions := OrderedCollection new.  portChangeActions := OrderedCollection new.  rawSelectionTransmissions := IdentitySet new.  self addRawSelectionTransmissionTo: #selectiontestPopLastPageOf5  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel popPane.  self assert: pagerModel size equals: 4.  self assert: pagerModel firstVisiblePageIndex equals: 3.  self assert: pagerModel lastVisiblePageIndex equals: 4.  self assert: pagerModel numberOfVisiblePages equals: 2smalltalkClass: anObject  self setProperty: #phlowSmalltalkClass toValue: anObjecthShrinkWrap  hResizing := #shrinkWrapwantsDroppedMorph: transferMorph event: evt inMorph: listMorph  | targetItem targetItemMorph |  (transferMorph isKindOf: TransferMorph) ifFalse: [ ^false ].  transferMorph dragTransferType = self dragTransferType ifFalse: [ ^false ].  targetItemMorph := listMorph scrollerSubMorphFromPoint: evt position.  targetItemMorph ifNotNil: [ targetItem := targetItemMorph complexContents item.        ^self glamourPresentation allow: transferMorph passenger droppedOnItem: targetItem ].  self flag: 'we should ask the whole presentation if it wants to receive a dropped object'.  ^falseinitializePresentation  initializationBlock ifNotNil: [ initializationBlock value: self ]portChangeActions  ^portChangeActionslayout: aBrick in: newBounds  self layout: aBrick in: newBounds inject: aBrick paddingLeft @ aBrick paddingTop into: [:origin :each |  each outerOrigin: origin.        0 @ each outerBounds height ]fixedSizePanes: anInteger  self hasFixedSizePanes: true.  fixedSizePanes := anIntegersubbricks  ^self brick submorphsenableElementIndex  self parameters at: 'withRowIndex' put: trueresetAnnouncer  super resetAnnouncer.  self presentations do: [:each |  each resetAnnouncer ]initialize  super initialize.  self useHorizontalLinearLayout.  self hSpaceFill.  self vShrinkWrap.  self messageBrick: self newTitleBrick.  self settingsButtonBrick: self newButtonBrickports  ^portsselectionInterval: anObject  self setProperty: #phlowSelectionInterval toValue: anObjectmaxHeight: anObject  self layout maxHeight: anObjectdeselect: anEvent  super deselect: anEvent.  self box deselect: anEvent.  self label deselect: anEventposition: anInteger  position := anIntegerupdateButtonsFocus  self buttons do: #setNotFocused.  self pagerModel focusedPageIndex ifNotNil: [ (self buttons at: self pagerModel focusedPageIndex) setFocused ]testIndirectEventsPropagationTransformation  | dynamic textPresentation counter |  counter := 0.  dynamic := GLMDynamicPresentation new.  dynamic entity: '42'.  dynamic display: [:entity |  textPresentation := GLMRubricTextPresentation new ].  dynamic currentPresentation.  textPresentation announcer when: GLMContextChanged do: [:ann |  ann property = #selectionInterval ifTrue: [ counter := counter + 1 ] ].  textPresentation selectionInterval: (1 to: 2).  self assert: counter equals: 1setIndex: anInteger in: aBrick  aBrick setProperty: #brickScrollListIndex toValue: anIntegermarkBorderColor: aColor width: anInteger  self setProperty: #brickMarkBorderColor toValue: aColor.  self setProperty: #brickMarkBorderWidth toValue: anIntegerverticalScrollbar: aBrick  verticalScrollbar := aBrick.  verticalScrollbar scrollPane: self.  verticalScrollbar height: [ self height ].  verticalScrollbar layout heightDependency: self.  super addBrickBack: verticalScrollbarscrollbarOffset: anInteger  self setProperty: #brickScrollbarOffset toValue: anInteger.  self updateStyledotsBrick  ^dotsBrickbuttonMinHeight  ^26 * self currentWorld displayScaleFactorpressedScrollerSizeCombination: aSymbol  firstCombination ifNil: [ firstCombination := aSymbol.        ^self ].  self scrollerSizeShortcutAction: firstCombination second: aSymbol.  firstCombination := nilnewBrickWithFullDependsOnChildren  ^GLMBrick new     hShrinkWrap;     vShrinkWrap;     color: Color random;     yourselfnotifyPagePushed: aMorph scrollTo: isScroll smooth: isSmooth  self notifyAll: (GLMPagePushed new morph: aMorph).  isScroll ifTrue: [ self scrollingDelay > 0 ifTrue: [ self scrollToRightTask execute: {isSmooth} ] ifFalse: [ self scrollToRight: isSmooth ] ]actOnPaneReplaced: ann  container removeMorph: container submorphs last.  container removeMorph: container submorphs last.  self addMorphFromObject: ann newPane toContainer: container.  scrollPane hScrollbar glmAnimateValue: 1.0 duration: 200dataFromPresentationItem: anItem  ^anItem dataopenInExternalWindow: aRenderable  window := GLMOSWindowMorphWorldRenderer render: aRenderable from: self.  ^window openselectionAct: aBlock on: aCharacter  self addSelectionAction: (GLMGenericAction new           action: aBlock;           shortcut: aCharacter;           yourself)activeFillStyle  ^self theme watcherWindowActiveFillStyleFor: selfscrollTo: aValue smooth: isSmooth callback: aBlock  isSmooth ifTrue: [ self glmAnimateValue: aValue duration: 300 callback: aBlock ] ifFalse: [ self scrollValue: (self convertScrollValue: aValue).        self updatePaneBounds.        aBlock value ]searchOn: aBlock  self error: 'This presentation does not allow searching with a block for now. In the futur we should have a new filter with FastTable to do that. If you want to give it a try look FTFunction and his subclasses.'testWatcherCopy  | browser pane transmission browserCopy |  browser := GLMBrowser new.  pane := GLMPane named: 'one'.  browser addPane: pane.  transmission := GLMTransmission new.  browser addTransmission: transmission.  transmission addActiveOrigin: (browser panes first port: #origin).  transmission toWatcher.  browserCopy := browser copy.  self assert: browserCopy transmissions size equals: 1.  self assert: (browserCopy panes first port: #origin) value equals: nil.  self assert: (browserCopy watcherPane port: #entity) value equals: nil.  (browserCopy panes first port: #origin) value: 42.  browserCopy transmissions first transmit.  self assert: (browserCopy watcherPane port: #entity) value equals: 42preventOverscrolling  self band hasSubbricks ifFalse: [ ^self ].  self isFirstAdded & self isFirstVisible ifTrue: [ self bandTopOffset > 0 ifTrue: [ self moveAllSubbricksBy: self topOffset negated.              self moveBandTop.              self update ].        ^self ].  self isTopOverscrolled ifTrue: [ self moveBandTop.        ^self update ].  self isBottomOverscrolled & self isFullyVisible not ifTrue: [ self moveBandBottom.        ^self update ]renderWithTitleOrNil: aPresentation  | morph |  morph := self renderObject: aPresentation.  ^self morph: morph withTitleOrNilOf: aPresentationcurrentColor  ^self state pressedColor: self isPressed selectedColor: self isSelected checkedColor: self isChecked of: selfresizeCursor  ^Cursor resizeForEdge: #lefttestSorted  | presentation |  presentation := GLMListPresentation new.  presentation entity: #(#foo #bar #blurp).  self assert: presentation displayValue equals: #(#foo #bar #blurp).  presentation sorted.  self assert: presentation displayValue equals: #(#bar #blurp #foo).  presentation sorted: [:a :b |  a size < b size ].  self assert: presentation displayValue equals: #(#bar #foo #blurp)popup: anObject  popup := anObjectoldValue  ^oldValuetestTabs  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list.        a text ].  window := browser openOn: 42.  self assert: self compositeTabGroup pages size equals: 2iconFor: anElement  ^self cacheAt: #icon for: anElement ifAbsentPut: [ self glamourPresentation icon cull: anElement ]initialize  super initialize.  self listBrick: self newScrollListshouldUseCache  ^self parameters at: 'shouldUseCache' ifAbsent: [ false ]unsubscribeListeners  self removeCloserListeneronThemerChanged  super onThemerChanged.  self titleBrick textColor: self themer textLightColorinitialize  super initialize.  self textBrick: self newTextBrickhasMaxDimensionRestriction: aBrick  ^aBrick layout hasMaxHeightrenderGlamorouslyOn: aRenderer  ^aRenderer renderFinder: selftearDown  window ifNotNil: [:aWindow |  aWindow delete ].  super tearDowntoolbarButtonsForPresentation: aPresentation  ^(aPresentation allActions select: [:each |  each isButton ]) collect: [:each |  | actionMorph |        actionMorph := each renderGlamorouslyOn: self renderer.        actionMorph arguments ifNil: [ actionMorph arguments: {aPresentation} ] ifNotNil: [ actionMorph arguments: {aPresentation} , actionMorph arguments ].        actionMorph ]selectLine  textMorph textArea editor lineSelectAndEmptyCheck: [ ^nil ]renderLabelPresentation: aLabelPresentation  ^GLMMorphicLabelRenderer render: aLabelPresentation from: selfscrollToTop  self scrollBy: self scrollPositionTop negated direction: #upaddSelectionAction: anAction  self selectionActions add: anActiongrayRoundedTags  tagsStyle := #grayRoundedButtonhintTitle  ^hintTitle ifNil: [ hintTitle := 'Hi,' ]isFilterable  ^self parameters at: 'isFilterable' ifAbsent: [ false ]enableFilterWithAction: aBlock named: aString  self enableFilter.  self parameters     at: 'actionBlock' put: aBlock;     at: 'actionName' put: aStringvShrinkWrap  vResizing := #shrinkWrapselectLine  textMorph selectLineresetChildrenContent  self rootItem: self createRootItem.  self resetDataCachehasTitle  ^self title notNilformat  ^format ifNil: [ format := #asString ]textFamilyName  ^self theme labelFont familyNamesingleClick: anEvent  self announce: #onSingleClicked event: anEventrenderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderSpecPresentation: selfopen: aPopupBrick with: aRectangle  ^aPopupBrick openBelow: aRectanglefloating: aSymbol  self layout floating: aSymbolstyle: anObject  style := anObjectformatedDisplayValue  ^self formatedDisplayValueOf: self displayValueshouldAllExpand  ^allExpanded ifNil: [ false ]toggleOpen  isOpen ifFalse: [ ^self openInWorld ].  self visible ifTrue: [ self hide ] ifFalse: [ self show ]textColor  ^self label textColorforSmalltalk  highlightSmalltalk := truetestTriggeringConditions  | browser pane1 pane2 transmission |  browser := GLMExplicitBrowser new.  browser pane: GLMTestPane new.  pane1 := GLMTestPane new.  pane2 := GLMTestPane new.  transmission := GLMTransmission new     addActiveOrigin: (pane1 port: #selection);     destination: (pane2 port: #entity);     yourself.  browser addPane: pane1.  browser addPane: pane2.  browser addTransmission: transmission.  self assertEmpty: (pane1 port: #selection) seenTransmissions.  self assertEmpty: (pane2 port: #entity) seenTransmissions.  (pane1 port: #selection) value: 12.  self assertEmpty: (pane1 port: #selection) seenTransmissions.  self assert: (pane2 port: #entity) seenTransmissions size equals: 1.  self assert: (pane2 port: #entity) seenTransmissions first identicalTo: transmission.  (pane1 port: #selection) value: 12.  self assertEmpty: (pane1 port: #selection) seenTransmissions.  self assert: (pane2 port: #entity) seenTransmissions size equals: 1.  self assert: (pane2 port: #entity) seenTransmissions first identicalTo: transmissionelementColumn  | rowElements |  rowElements := OrderedCollection new     add: self displayText;     addAll: (self tagMorphsFrom: self containerTree glamourPresentation);     yourself.  ^UITheme current newRowIn: self currentWorld for: rowElementstextBlock: anObject  textBlock := anObjectshouldFilterByTag: aTag  ^self tagsToFilterBy includes: aTagcompose  vectors: theVectors  | currentVector |  self assert: [ theVectors size >= 4 ] description: [ 'There must be at least four vectors (rectangular area)!' ].  vector := theVectors first.  currentVector := vector.  2 to: theVectors size do: [:anIndex |  | aVector |        aVector := theVectors at: anIndex.        currentVector next: aVector.        aVector previous: currentVector.        currentVector := aVector ].  currentVector next: vector.  vector previous: currentVector.  self computeVerticesannounce: aSymbol event: anEvent  self announcer subscriptions subscriptions do: [:each |  each announcementClass = aSymbol ifTrue: [ (each handlesAnnouncement: aSymbol) ifTrue: [ [ each action cull: anEvent cull: self ] on: UnhandledError fork: [:ex |  ex pass ] ] ] ]formatedDisplayValueOf: anElement  ^self cacheAt: #formatedDisplayValue for: anElement ifAbsentPut: [ self glamourPresentation formatedDisplayValueOf: anElement ]hasTagsFilter  ^self tagsFilterBlock notNilactOnPresentationUpdated: anAnnouncement  labelMorph contents: anAnnouncement presentation formatedDisplayValueprivateWidth: anObject  self layout width: anObjectselectionPathItems  ^self selectedNodePath ifNil: [ nil ] ifNotNil: [ self selectedNodePath collect: [:each |  each item ] ]fullBounds  super fullBounds.  ^self brickRoot globalClippingBoundsenableFilter: aBlock  self enableFilter.  self parameters at: 'filterBlock' put: aBlocktestDefaultFixedSizePanes  | finder container |  finder := GLMFinder new.  window := finder openOn: 40.  window width: 522.  container := self find: TransformMorph in: window.  self assert: container submorphs first width equals: window submorphs last width.  (finder panes first port: #selection) value: 42.  self assert: container submorphs size equals: 3.  self assert: container submorphs first extent equals: container submorphs last extent.  self assert: container submorphs first width <= (window submorphs last width / 2)setPotentialBackgroundColorFor: aRenderable  aRenderable colorValue ifNotNil: [ window borderColor: aRenderable colorValue ]browser: aBrowser  browser := aBrowsertestCondition  self assert: (GLMAction new isAvailableOn: GLMPresentation new).  self deny: (GLMAction new           condition: [ false ];           isAvailableOn: GLMPresentation new).  self deny: (GLMAction new           condition: [:presentation :entity |  false ];           isAvailableOn: GLMPresentation new)announcement: anObject  announcement := anObjecttagsToFilterBy  ^tagsToFilterBy ifNil: [ tagsToFilterBy := OrderedCollection new ]hasCustomDependencies: aBrick  ^(self customDependencies: aBrick) isEmpty notchangeValueTo: anObject in: aTransmissionContext  | oldValue |  oldValue := self value.  self pane notingPresentationChangeDo: [ self silentValue: anObject.        self pane portEvent: (GLMPortEvent on: self previouslyValued: oldValue in: aTransmissionContext) ]testPortPublishing  | browser |  browser := GLMFinder new.  (browser pane port: #entity) value: #value1.  self assert: browser panes size equals: 1.  self assert: browser pane ports size equals: 1.  self assert: (browser pane port: #entity) value equals: #value1.  (browser panes first port: #selection) value: #value2.  self assert: browser panes size equals: 2.  self assert: browser pane ports size equals: 3.  self assert: (browser pane port: #entity) value equals: #value1.  self assert: (browser pane port: #selection) value equals: #value2.  (browser panes last port: #selection) value: #value3.  self assert: browser panes size equals: 3.  self assert: browser pane ports size equals: 3.  self assert: (browser pane port: #entity) value equals: #value1.  self assert: (browser pane port: #selection) value equals: #value3.  (browser panes first port: #hover) value: #value4.  self assert: browser panes size equals: 3.  self assert: browser pane ports size equals: 4.  self assert: (browser pane port: #entity) value equals: #value1.  self assert: (browser pane port: #selection) value equals: #value3.  self assert: (browser pane port: #hover) value equals: #value4pharoPlayground  self deprecated: 'Use #pharoScript instead'.  ^self custom: GLMPharoScriptPresentation newstate  ^self classtestLeftMarginParentDependency  | root margin brick |  margin := 10.  root := self newBrickWithStaticExtent.  brick := self newBrickFullHeightAndWidthDependsOnParent: 100.  brick marginLeft: margin.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticExtent - (margin @ 0).  self assert: brick brickBounds equals: (margin @ 0 corner: self staticExtent)panes  ^panes ifNil: [ panes := OrderedCollection new ]enlargeToRight  self virtualLastVisiblePageIndex: self lastVisiblePageIndex + 1.  self recomputeStatesilentValue: anObject  self subclassResponsibilitypopAndReplacePane: aMorph  self doNotNotifyDuring: [:m |  m           popPane;           pushPane: aMorph smooth: false ].  self notifyPagePoppedAndReplaced: aMorphaddPort: aPort  self ports add: aPortwantsSteps  ^truerenderContainerFor: aPane  contentMorph := self morph: (self renderObject: aPane presentations) withTitleOrNilOf: aPane presentations.  container     addMorph: contentMorph fullFrame: LayoutFrame identity;     yourselfmorph  | morph |  morph := RubScrolledTextMorph new     beForSmalltalkCode;     getSelectionSelector: #primarySelectionInterval;     model: textModel;     color: self theme backgroundColor;     textFont: StandardFonts codeFont;     yourself.  (morph textArea decoratorNamed: #shoutStyler) ifNotNil: [:styler |  textModel glamourPresentation variableBindings ifNotEmpty: [ styler styler                 workspace: textModel;                 isForWorkspace: false.              styler refreshStyling ] ].  ^morphbounds  ^self brickBoundssimulateOnlyOneClickOn: aMorph  (Delay forMilliseconds: HandMorph doubleClickTime + 1) wait.  aMorph simulateClickscrollBy: anInteger direction: aSymbol  self isFullyVisible ifTrue: [ ^self ].  aSymbol = #up ifTrue: [ self scrollUp: anInteger ].  aSymbol = #down ifTrue: [ self scrollDown: anInteger ].  self update.  self changedbasicValue: anObject  value := anObjectrenderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^self currentPresentation renderGlamorouslyOn: aRendereranimation  ^animationactOnBrowserClosed: ann  self renderer window deletetestMarkerOneChildrenInParentHeight  | root brick |  root := self newBrickWithFullFill.  brick := self newBrickWithFullDependsOnChildren.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthClean.  self assert: brick wrappedBounds isHeightDirty.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightCleanband  ^bandtestForSmalltalkWorkspace  | browser textMorph |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a pharoScript variableBindings: [:x |  {(#theNumber -> x)} ] ].  window := browser openOn: 42.  textMorph := self find: RubScrolledTextMorph in: window.  self assert: (textMorph model hasBindingOf: #theNumber)approximateHeight  ^self font height + self vMargin + self vPaddingisSplitIntoColumns  ^self children allSatisfy: [:each |  each isColumn ]selection: ann  | selection |  selection := ann newSelectedIndexes select: [:each |  each ~= 0 ] thenCollect: [:each |  self elementAt: each ].  selection ifNotEmpty: [ self announcer announce: (GLMTreeMorphSelectionChanged new                 selectionValue: ((selection size = 1 and: [ self glamourPresentation isSingle ]) ifTrue: [ selection first ] ifFalse: [ selection ]);                 selectionPathValue: selection;                 yourself) ]rubricTextBackgroundColor  ^Color transparentstep  shadowWidth  ^3computeAnnouncerObjects  ^self transformation glamourValue: self presentation entitylabelActionBrickFor: aPresentation  ^aPresentation titleAction ifNil: [ nil ] ifNotNil: [:labelAction |  ((labelAction isAvailableOn: aPresentation) and: [ labelAction hasIcon ]) ifTrue: [ GLMActionButtonBrick new                 icon: labelAction icon;                 setBalloonText: labelAction title;                 action: [ labelAction actOn: aPresentation ] ] ifFalse: [ nil ] ]left  ^GLMEastDirection uniqueInstancechildrenCount  ^self children inject: 0 into: [:sum :each |  sum + each span ]scrollBy: anInteger  self privateScrollPosition: anInteger.  self band translateY: anIntegerupdateVariableBindings  self announce: (GLMVariableBindingsChanged new presentation: self)glamourAction  ^glamourActioninitialize  super initialize.  focus := Dictionary new.  currentScrollDelta := 0.  maxPanes := 2.  self band: self newBand.  Morph announcer weak when: MorphGotFocus send: #focusChanged: to: selftestTextPortPopulatedByDefault  | composite |  composite := GLMCompositePresentation new with: [:a |  a text ].  window := composite openOn: '42'.  self assert: (composite pane port: #text) value asString equals: '42'textColor  ^Color r: 206 g: 38 b: 11 range: 255calculateVelocity: event  | delta |  delta := event timeStamp - lastScrollTimeStamp.  self velocity: (delta > self class defaultScrollTimeReset ifTrue: [ self class defaultScrollVelocity ] ifFalse: [ self velocityValue: delta ]).  lastScrollTimeStamp := event timeStamp.  ^self velocity ceilingtransientValue: anObject  | previousValue |  previousValue := self value.  self value: anObject.  self silentValue: previousValuedefaultPercent  ^100resetElements  self resetDataCache.  self updateDatahSpaceFill: anInteger  super hSpaceFill: anInteger.  self label hSpaceFill.  self dotsBrick hShrinkWraptarget: aTarget actionSelector: aSelector arguments: aCollection  target := aTarget.  selector := aSelector.  arguments := aCollectionglmAnimateValue: aValue duration: anInteger callback: aBlock  self animation ifNotNil: #terminate.  animation := GLMAnimation new     linear;     duration: 200;     from: self scrollValue;     to: (self convertScrollValue: aValue);     ensure: [:b |  b updatePaneBounds.        aBlock brickValue: b ];     animation: [:b :v |  b scrollValue: v ];     animate: selfaddAllBricks: aCollection  self band addAllBricks: aCollectionselectedItem  ^self selectionIndex = 0 ifTrue: [ nil ] ifFalse: [ self glamourPresentation displayValue at: self selectionIndex ]opposite  ^self subclassResponsibilitysubbricksReverseDo: aBlock  self subbricks reverseDo: aBlockdebugSelection  self announce: GLMDebugSelectiontestMultipleSelectionWithChange  | composite textMorph textPresentation |  composite := GLMCompositePresentation new with: [:a |  a text display: '123456789' ].  window := composite openOn: 4.  textMorph := self find: RubScrolledTextMorph in: window.  self assertEmpty: textMorph selectionInterval.  textPresentation := composite presentations first.  textPresentation selectionInterval: (2 to: 5).  self assert: textMorph textArea editor selection asString equals: '2345'.  self assert: textPresentation selectedText asString equals: '2345'checkboxWidth  ^18noTitle  title := nil.  titleIcon := nilsize  ^collection sizeworksWithSeaside  ^truebrowser  ^browserid: anObejct  id := anObejcttabulator  ^self custom: GLMTabulator newtestInterdependentPanesCycleBreak  | browser outerCount oneCount |  outerCount := 0.  oneCount := 0.  browser := GLMTabulator new.  browser     column: #one;     column: #two;     column: #three.  browser transmit     to: #one;     andShow: [:a |  a list display: [:x |  1 to: x ] ].  browser transmit     to: #two;     from: #one;     andShow: [:a |  a list display: [:x |  1 to: x * 2 ] ].  browser transmit     to: #three;     from: #two;     andShow: [:a |  a list           display: [:x |  1 to: x * 3 ];           populate: #focus on: $f entitled: 'Focus' with: [:list |  list selection ] ].  browser transmit     toOutsidePort: #focus;     from: #three port: #focus;     transformed: [:x |  outerCount := outerCount + 1 ].  browser transmit     to: #one port: #selection;     fromOutsidePort: #focus;     transformed: [:x |  oneCount := oneCount + 1 ].  browser startOn: 5.  ((browser paneNamed: #one) port: #selection) value: 3.  ((browser paneNamed: #two) port: #selection) value: 6.  ((browser paneNamed: #three) port: #selection) value: 12.  ((browser paneNamed: #three) port: #focus) value: 12.  self assert: oneCount equals: 1.  self assert: outerCount equals: 1actOnPresentationUpdated: ann  | index presentations |  presentations := ann presentation matchingPresentations.  tabs pages size to: 1 by: -1 do: [:i |  tabs removePageIndex: i ].  presentations do: [:each |  tabs addLazyPage: [ self renderObject: each ] label: (self titleOrIconOf: each in: tabs) toolbar: (self renderToolbarForPresentation: each inMorph: tabs) action: (self labelActionBrickFor: each) ].  index := 1.  presentations withIndexDo: [:each :i |  ann presentation pane lastActivePresentation notNil and: [ each title = ann presentation pane lastActivePresentation title ifTrue: [ index := i ] ] ].  tabs selectedPageIndex: indexmarkWidthDirty  ^self brick wrappedBounds markWidthDirtyscrollDown: anInteger  self scrollBy: (self isLastAdded ifTrue: [ anInteger min: self band brickBounds bottom - self height ] ifFalse: [ anInteger ]) negatedrenderer  ^renderer ifNil: [ renderer := GLMMorphicRenderer new ]scrollBarColor: aColor  self setProperty: #brickScrollbarColor toValue: aColor.  self updateStyleborderColor  ^self theme borderColorbindingOf: aSymbol  ^self bindingsStrategy cull: self variableBindings cull: aSymbolbuttonSelectedColor  ^Color veryVeryLightGray lighter slightlyDarkeronTextAccepted: ann  | isChanged |  isChanged := (self text asString = ann morph text asString) not.  ann morph text isEmpty ifFalse: [ self accept ] ifTrue: [ self cancel ].  isChanged ifTrue: [ self announce: #onAccepted ]customHeight  ^self layout height brickValue: selfaddBrick: aBrick before: anotherBrick  self band addBrick: aBrick before: anotherBrickisAnnouncementSuspended: anAnnouncement  ^self suspendAll or: [ | announcementType |        announcementType := anAnnouncement isClass ifTrue: [ anAnnouncement ] ifFalse: [ anAnnouncement class ].        self suspendedAnnouncemets anySatisfy: [:anAnnouncementType |  announcementType = anAnnouncementType or: [ announcementType inheritsFrom: anAnnouncementType ] ] ]silentValue: anObject  value := anObjectmorph: aMorph  morph := aMorphiconFor: anElement  ^self cacheAt: #icon for: anElement ifAbsentPut: [ self glamourPresentation icon cull: anElement ]rootsExpanded  self shouldRootsExpand: truehSpaceFill: anInteger  super hSpaceFill: anInteger.  self label hSpaceFillwithAllPanes  | result |  result := OrderedCollection new.  self withAllPanesAndPresentationsDo: [:each |  (each isKindOf: GLMPane) ifTrue: [ result add: each ] ].  ^resultspacing: aNumber  spacing := aNumber.  self updateInsetAndSpacingshrinkingWidth  self rubric width: self rubric textArea width.  self onLayouted.  ^self rubric textArea widthonPagePushed  self showOrHideScrollBarscrollBarValue: value  transform hasSubmorphs ifFalse: [ ^self ].  transform offset: (self leftoverScrollRange * value) rounded @ 0testCopyAnnouncementsDoNotRaise  | pane newPane |  pane := GLMPane new.  pane when: GLMPresentationsChanged do: [:ann |  self fail ].  self assert: pane numberOfSubscriptions equals: 1.  newPane := pane copy.  newPane announce: GLMPresentationsChanged.  self assert: newPane numberOfSubscriptions equals: 0toolbarMorph  ^toolbarMorphrenderGlamorouslyOn: aRenderer  ^aRenderer renderPopupAction: selfdragEnabled  ^self glamourPresentation allowsItemDragbounds: aRectangle  super bounds: aRectangle.  self layoutWidgets.  self layoutPanes.  self setScrollDeltasaddModule: aThemerModule named: aSymbol  self modules at: aSymbol put: aThemerModule.  aThemerModule themer: self.  ^aThemerModuletestInitializeBlockSetsTextSelectionForMethodPresentation  self checkInitializeBlockSetsTextSelectionForPresentation: #pharoMethodeditBrick  ^editBrickannouncerObjects  ^announcerObjects := self computeAnnouncerObjects ifNil: [ OrderedCollection new ]execute  target ifNil: [ ^self ].  selector ifNil: [ ^self ].  target perform: selector withArguments: argumentshighlightEvaluateAndDo: aBlock  self announce: (GLMHighlightAndEvaluate new action: aBlock)sliderBrick: aBrick  sliderBrick := aBrick.  self sliderBrick     pagerModel: self pagerModel;     height: self pagerModel circleButtonSize;     width: [ self pagerModel circleButtonSize * self pagerModel actualNumberOfVisiblePages ].  self sliderBrick layout floating: #left.  self addBrickBack: self sliderBrickpresentations: anObject  oldMatchingPresentations: aCollection  oldMatchingPresentations := aCollectionisSplitIntoRows  ^self children allSatisfy: [:each |  each isRow ]dataCacheFor: anElement  ^self dataCache at: anElement ifAbsentPut: [ Dictionary new ]maxHeight  ^maxHeight ifNil: [ maxHeight := Float infinity ]textBlock  ^textBlocktestSelectToLeft  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel switchPaneTo: 6.  self assert: pagerModel numberOfVisiblePages equals: 2.  self assert: pagerModel selectedPageIndex equals: 6.  self assert: pagerModel firstVisiblePageIndex equals: 5.  self assert: pagerModel lastVisiblePageIndex equals: 6.  pagerModel selectToLeft.  self assert: pagerModel selectedPageIndex equals: 5.  self assert: pagerModel firstVisiblePageIndex equals: 5.  self assert: pagerModel lastVisiblePageIndex equals: 6.  pagerModel selectToLeft.  self assert: pagerModel selectedPageIndex equals: 4.  self assert: pagerModel firstVisiblePageIndex equals: 4.  self assert: pagerModel lastVisiblePageIndex equals: 5.  pagerModel selectToLeft.  self assert: pagerModel selectedPageIndex equals: 3.  self assert: pagerModel firstVisiblePageIndex equals: 3.  self assert: pagerModel lastVisiblePageIndex equals: 4.  pagerModel selectToLeft.  self assert: pagerModel selectedPageIndex equals: 2.  self assert: pagerModel firstVisiblePageIndex equals: 2.  self assert: pagerModel lastVisiblePageIndex equals: 3.  pagerModel selectToLeft.  self assert: pagerModel selectedPageIndex equals: 1.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 2lazyPageMorphCreation  ^lazyPageMorphCreationclick: anEvent  self announce: #onClicked event: anEvent.  ^falseonPagesNumberChanged  self maxPanes: pagerModel numberOfVisiblePages.  self doLayoutForce.  self scrollToPane: pagerModel firstVisiblePageIndex smooth: falseinnerBounds  ^innerBounds ifNil: [ self updateCache.        innerBounds ]layout: aBrick in: newBounds  ^self subclassResponsibilitytranslateY: anInteger  self wrappedBounds translateY: anIntegerexecuteMenuAction: anAction  self announce: (GLMMenuItemSelected action: anAction)testClose  | finder |  finder := GLMFinder new.  window := finder openOn: 123.  self assert: window owner notNil.  finder close.  self assert: window owner isNilmoveLeft: left  | right |  right := left + self width.  self changedWith: [:b |  b translateXTo: left.        b leftPosition: left ].  pagerModel notifyScrollerBoundsChanged: left @ rightmarginTop  ^self brick marginTopglamourPresentation  ^glamourPresentationstart  ^startpresentation  ^GLMCompositePresentation new with: [:a |  | t seg |        t := a text.        seg := RubUnderlinedSegmentMorph from: 1 to: 29.        seg icon: (self iconNamed: #smallErrorIcon).        seg label: 'Please review'.        seg iconBlock: [:segment :event |  segment delete ].        t addTextSegment: seg.        seg := RubPlainSegmentMorph from: 535 to: 659.        seg color: (Color green alpha: 0.3).        seg icon: (self iconNamed: #smallErrorIcon).        seg label: 'Remove'.        seg iconBlock: [:segment :event |  segment textArea selectFrom: segment firstIndex to: segment lastIndex.              segment textArea replaceSelectionWith: ''.              segment delete ].        t addTextSegment: seg.        seg := RubUnderlinedSegmentMorph from: 1000 to: 1030.        seg icon: (self iconNamed: #smallHelpIcon).        seg label: 'Print it'.        seg iconBlock: [:segment :event |  self trace: segment getText ].        t addTextSegment: seg ]margin  ^1spawn: aBlock entitled: aString  self addAction: (GLMSpawnBrowserAction new           action: aBlock;           title: aString;           yourself)act: aBlock icon: anIcon on: aCharacter entitled: aString  self addAction: (GLMGenericAction new           action: aBlock;           shortcut: aCharacter;           icon: anIcon;           title: aString;           yourself)pageIndex  ^pageIndextestPaneReplacedAnnouncement  | browser count |  count := 0.  browser := GLMFinder new.  browser when: GLMPaneReplaced do: [:ann |  count := count + 1 ].  browser startOn: #a.  self assert: count equals: 0.  (browser panes first port: #selection) value: #b.  self assert: count equals: 0.  (browser panes second port: #selection) value: #c.  self assert: count equals: 0.  (browser panes first port: #selection) value: #d.  self assert: count equals: 1.  browser entity: #e.  self assert: count equals: 2filterBlock  ^self parameters at: 'filterBlock'morphicSelectionAct: aBlock icon: anIcon entitled: aString  self addSelectionAction: (GLMMorphicAction new           action: aBlock;           icon: anIcon;           title: aString;           yourself)parameters  ^parameterscreateDataSourceFrom: aPresentation  self subclassResponsibilityorigin: aPoint  origin := aPoint.  self computeVerticescontainerTree  ^containerTreeactOnPresentationUpdated: ann  | anInterval |  anInterval := ann presentation selectionInterval.  textMorph setText: ann presentation formatedDisplayValue.  textMorph setSelection: anIntervalrubricBorderWidth  ^0testSimpleColumns  | layout |  layout := GLMTabulator new.  layout addColumn: #first.  layout addColumn: #second.  self assert: layout cell children size equals: 2newBrickWithFullFill  ^GLMBrick new     hSpaceFill;     vSpaceFill;     color: Color random;     yourselfthemerChanged  self onThemerChanged.  self morph brickThemerChangedactionBlock  ^self parameters at: 'actionBlock'selectToRight  self selectedPageIndex: self selectedPageIndex + 1isVertical  ^self isHorizontal nottestPublishingToOutsideFinder  | innerBrowser finder |  finder := GLMFinder new.  innerBrowser := GLMTabulator new.  innerBrowser column: #any.  innerBrowser transmit     to: #any;     andShow: [:a |  a list display: [:x |  1 to: 43 ] ].  innerBrowser transmit     toOutsidePort: #selection;     from: #any port: #selection.  finder show: [:a |  a custom: innerBrowser ].  finder startOn: 43.  self assert: (finder panes first port: #entity) value equals: 43.  self assert: (finder panes first port: #selection) value isNil.  ((finder panes first presentations first paneNamed: #any) port: #selection) value: 42.  self assert: (finder panes first port: #selection) value equals: 42.  self assert: (finder panes first port: #entity) value equals: 43.  self assert: finder panes size equals: 2.  self assert: (finder panes last port: #entity) value equals: 42.  self assert: (finder panes first presentations first isKindOf: GLMTabulator).  self assert: (finder panes last presentations first isKindOf: GLMTabulator).  self assert: (finder panes first presentations first isKindOf: GLMTabulator)inset  ^insetcreateDataSourceFrom: aPresentation  ^GLMFastTreeTableDataSource newupdatePaneBounds  self band updateMorphBoundsbackgroundColor  ^self borderColor muchLighter darkertestAdd  | composite |  composite := GLMCompositePresentation new.  composite add: GLMPresentation new.  self deny: composite isEmpty.  self assert: composite presentations size equals: 1fastTreeTable  ^self custom: GLMFastTreeTablePresentation newscrollToPane: pageIndex  self scrollToPane: pageIndex callback: nilcurrentPresentation  | composite |  composite := GLMCompositePresentation new.  self presentationTransformation glamourValue: composite asGlamorousMultiValue , self displayValue asGlamorousMultiValue.  composite pane: self pane.  composite initializePresentation.  cachedPresentation := composite.  ^compositedisplayValue  ^cachedDisplayedValue := self transformation glamourValue: self entitytakeKeyboardFocus  self rubric takeKeyboardFocusmarkHeightClean  ^self brick wrappedBounds markHeightCleansetLabelWidgetAllowance  ^labelWidgetAllowance := super setLabelWidgetAllowance + (toolbarBox ifNil: [ 0 ] ifNotNil: [:toolbar |  toolbarBox width ])testInvalidateSelection  (browser panes first port: #selection) value: 3.  entity removeLast.  announcer announce: GLMTestAnnouncement.  self assert: (browser panes first port: #selection) value isNil.  self assert: listMorph model selection isNiltestValidate  | pane presentation |  pane := GLMPane named: 'test'.  presentation := GLMPresentation new.  pane addPresentation: presentation.  presentation entity: (OrderedCollection with: 1 with: 2).  self assert: (presentation validate: 1 on: (pane port: #foo)).  self assert: (presentation validate: 2 on: (pane port: #foo)).  self assert: (presentation validate: 5 on: (pane port: #foo))openAbove: aRectangle  | anOrigin |  anOrigin := aRectangle origin - (0 @ self contentBrick height) - (0 @ self inset top).  ^self openAt: anOrigintestCreation  self assertEmpty: GLMCompositePresentation newsize: anObject  size := anObjectrowHeight: aNumber  self parameters at: 'rowHeight' put: aNumbersilentValue: anObject  self port silentValue: anObjectselectionIndex  ^selectionIndex ifNil: [ selectionIndex := self glamourPresentation selectedIndex ]finder  ^self custom: GLMFinder newfixedSizePanes  ^fixedSizePanes ifNil: [ fixedSizePanes := 2 ]open: aRenderable  ^self doOpen: (self render: aRenderable)selectionActions: anObject  selectionActions := anObjectzIndex: anObject  zIndex := anObjectonPagePoped  | button |  button := self buttons removeLast.  button announcer unsubscribe: self.  self owner changed.  self removeBrick: button.  self updateButtonstestTriggerConditions  | transmission port1 port2 |  transmission := GLMTransmission new.  port1 := GLMSimplePort new name: #port1.  port2 := GLMSimplePort new name: #port2.  transmission addActiveOrigin: port1.  transmission addPassiveOrigin: port2.  transmission destination: (GLMPort new name: #port3).  self assert: (transmission originatesAt: port1).  self assert: (transmission originatesAt: port2) notcalculateScrollbarHeight  ^((self scrollPane height min: (self scrollPane layout maxHeight brickValue: self scrollPane)) / self scrollPane band height * (self height min: (self scrollPane layout maxHeight brickValue: self scrollPane))) ceilingmarginBottom: anObject  < brickBuilderProperty: #Geometry name: 'Margin Bottom' as: #asInteger getter: #marginBottom model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds marginBottom: anObjectmarkClean: aBrick  aBrick markHeightCleanspecificTableMorphInitializiation  self specificTableMorphColumnsInitialization.  super specificTableMorphInitializiationreceive: aTransmission in: aContext  self port receive: aTransmission in: aContextwithAllPanes  | result |  result := OrderedCollection new.  self withAllPanesAndPresentationsDo: [:each |  (each isKindOf: GLMPane) ifTrue: [ result add: each ] ].  ^resulttoggle  self isExpanded ifTrue: [ self collapse ] ifFalse: [ self expand ]isColumn  ^falseisSelectionPort  ^self name = #selectionselection  ^self glamourPresentation selectionInterval ifNil: [ 1 to: 0 ]withWidth: anInteger  ^self brick withWidth: anIntegertriggerBrick  < return: #GLMInteractableBrick>  self assert: [ triggerBrick isNotNil ] description: [ 'Trigger brick can not be nil' ].  ^triggerBrickonDrawAthensCanvas: aCanvas  self renderer render: self onAthensCanvas: aCanvaswithAllPanesAndPresentationsDo: aBlock  ^aBlock value: selfinitialize  super initialize.  isChecked := false.  isPressed := false.  isSelected := false.  self disablecomputeTagsFor: aGlamourValue  ^self computeTagsFor: aGlamourValue from: self tagsBlockinactiveTitleFillStyle  ^SolidFillStyle color: Color transparentpaddingBottom  ^self padding at: BottomtranslateY: anInteger  self translateBy: 0 @ anIntegeraction: anObject  action := anObjecttest100DependsOnChildrenBricksInsideOneStatic  | root current |  root := self newBrickWithFullDependsOnChildren.  current := root.  1 to: 99 do: [:index |  current := current addBrickBack: self newBrickWithFullDependsOnChildren ].  current := current addBrickBack: self newBrickWithStaticExtent.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: current extenteditingMode: aBlock  editingMode := aBlockviewRowMorphForColumn: aGlamourColumn node: aNode withIndex: anInteger  ^(self valueFor: aNode withIndex: anInteger in: aGlamourColumn) asMorph asReadOnlyMorphcolumn: aBlockOrSymbol span: anInteger  ^self addColumn: aBlockOrSymbol span: anIntegermarkLayoutClean: aBrick  aBrick ifNotNil: [:b |  b markLayoutClean ]textBackgroundColorFor: anObject  ^self textBackgroundColor glamourValue: anObject asGlamorousMultiValue , self entity asGlamorousMultiValueprofileSelection  textMorph tallyItextent  ^self brickBounds extentformatSourceCode  self announce: GLMFormatCodehighlight: aString  highlightedString := aString.  self changedinitialize  super initialize.  pagesCount := 0.  selectedPageIndex := 0.  focusedViews := Dictionary new.  isDependenciesShown := false.  numberOfVisiblePages := self defaultNumberOfVisiblePages.  firstVisiblePageIndex := 0.  lastVisiblePageIndex := 0.  self invariantpopPane  self pagerModel popPane: trueasyncTask  ^asyncTask ifNil: [ asyncTask := GLMAsyncTask new ]when: anAnnouncement do: aBlock  ^self announcer when: anAnnouncement do: aBlockrow: aBlockOrSymbol size: anInteger  ^self addRow: aBlockOrSymbol size: anIntegerchildrenValueOf: anObject atLevel: anInteger  ^self children glamourValue: anObject asGlamorousMultiValue , self entity asGlamorousMultiValue , anInteger asGlamorousMultiValue , self asGlamorousMultiValueparser  ^parsersetText: aText from: aRubScrolledTextMorph  self glamourPresentation text: aText.  ^truesendOneOrMultipleAs: aCollectionClass updatedBy: oneArgBlock  self send: [:linkedListOrNil |  linkedListOrNil ifNotNil: [ linkedListOrNil size = 1 ifTrue: [ (linkedListOrNil first isCollection and: [ linkedListOrNil first size = 1 ]) ifTrue: [ linkedListOrNil first first ] ifFalse: [ linkedListOrNil first ] ] ifFalse: [ oneArgBlock cull: (linkedListOrNil as: aCollectionClass) ] ] ]withGhostText: aText  withGhostText := aTextremoveAllPanes  self panes do: [:each |  each unregisterFromAllAnnouncements ].  ^self panes removeAlleditRowMorphForColumn: glamourColumn node: aNode withIndex: aRowIndex  | rowMorph |  rowMorph := self viewRowMorphForColumn: glamourColumn node: aNode withIndex: aRowIndex.  rowMorph hResizing: #spaceFill.  rowMorph on: #mouseDown send: #value: to: [:event |  event shiftPressed ifTrue: [ GLMEditorPopupBrick new                 in: [:aPopup |  aPopup themer: aPopup themer popupEditorBorderThemer themer ];                 closer: (GLMPopupBrickCloser new                       predicate: GLMPopupBrickOutisideClickPredicate new;                       predicate: GLMPopupBrickEscPredicate new;                       yourself);                 textModel: (self valueFor: aNode withIndex: aRowIndex in: glamourColumn);                 when: #textAccepted do: [:anEvent |  glamourColumn modifiedBlock cull: anEvent morph text cull: aNode cull: self glamourPresentation ];                 openOn: rowMorph ] ifFalse: [ event wasHandled: false ] ].  ^rowMorphorigin: aPoint length: aLength breadth: aBreadth  ^aPoint - (0 @ aLength) extent: aBreadth @ aLengthtransformedEntity: anObject  transformedEntity := anObjectremoveAllBricks  self band removeAllBricks.  self scrollToTopcolorValue  ^self color notNil ifTrue: [ self color glamourValue: self entity ] ifFalse: [ self color ]testSimple  GLMPresentation new announce: GLMContextChanged new.  self assert: GLMLogger instance announcements size equals: 1isMultiple  ^allowsMultipleSelection ifNil: [ allowsMultipleSelection := false ]workspaceBindingsStrategy  ^[:currentBindings :aString |  (currentBindings includesKey: aString) ifFalse: [ currentBindings add: (WorkspaceVariable key: aString asSymbol) ].  currentBindings associationAt: aString ]parameters  ^parametersscrollbarWidth  ^2resetElements  self resetDataCache.  elements := nilstyler: aStylerObject  styler := aStylerObject.  styler view: selfborderColor: anObject  < brickBuilderProperty: #'Look&Feel' name: 'Border color' as: #brickBuilderEvaluate getter: #borderColor model: #GLMUIBuilderTextFieldProperty>  self border color: anObjectscrollbarWidth: anInteger  self setProperty: #brickScrollbarWidth toValue: anInteger.  self updateStyleanimateToNormal  self borderAnimation     from: self borderColor first;     to: (self borderColor first alpha: 0);     animate: selftestPaneAddedAnnouncement  | browser count |  count := 0.  browser := GLMFinder new.  browser when: GLMPaneAdded do: [:ann |  count := count + 1 ].  browser startOn: #a.  self assert: count equals: 1.  (browser panes first port: #selection) value: #b.  self assert: count equals: 2globalBoundsTranslateFactor  ^self globalBounds originannouncer  ^announcer ifNil: [ announcer := Announcer new ]buttonsMorphs  ^pagerMorph subbricks second subbricks second subbricksexecuteMenuAction: anAction  self containerTree announce: (GLMMenuItemSelected action: anAction)onSelectedPageChanged  self panes do: [:each |  each borderColor: Color transparent ].  self theme pagerWidgetThemer selectedPaneStyleFor: (self panes at: pagerModel selectedPageIndex)initialize  super initialize.  self useVerticalLinearLayoutrenderer: aRenderer  self setProperty: #brickRenderer toValue: aRenderermorphAtLogic: aBlockWithTwoParameters  morphLogic := aBlockWithTwoParameterstestDefaultPane  | composite |  composite := GLMCompositePresentation new.  self assert: composite pane presentations equals: compositetestTextPortPopulatedByDefault  | composite |  composite := GLMCompositePresentation new with: [:a |  a text ].  window := composite openOn: '42'.  self assert: (composite pane port: #text) value asString equals: '42'vShrinkWrap  self layout vShrinkWraptitleLogic  ^self valueOfProperty: #phlowTitle ifAbsent: [ '' ]testMarkerOneStaticInChildrenHeight  | root brick |  root := self newBrickWithFullDependsOnChildren.  brick := self newBrickWithStaticExtent.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthClean.  self assert: brick wrappedBounds isHeightDirty.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightDirtyrenderPharoMethodPresentation: aSmalltalkMethodPresentation  ^GLMMorphicPharoMethodRenderer render: aSmalltalkMethodPresentation from: selftestUnregisterFromAnnouncementsWhenUpdating  | composite announcingCollection numberOfExecutions |  numberOfExecutions := 0.  announcingCollection := GLMAnnouncingCollection new.  composite := GLMCompositePresentation new with: [:a |  a text           updateOn: GLMItemAdded from: [ announcingCollection ];           display: [ numberOfExecutions := numberOfExecutions + 1.              numberOfExecutions asString ] ].  window := composite openOn: announcingCollection.  1 to: 3 do: [:each |  announcingCollection add: each ].  self assert: numberOfExecutions equals: 4drawSubmorphsOn: aCanvas  aCanvas translateBy: self bounds origin - self morph bounds origin + (self paddingLeft @ self paddingTop) during: [:canvas |  self morph fullDrawOn: canvas ]rowMorphForElement: element  | rowElements |  rowElements := OrderedCollection new.  (self iconFor: element) ifNotNil: [:icon |  rowElements add: icon asMorph ].  rowElements     add: (self formatedDisplayValueOf: element) asMorph asReadOnlyMorph;     addAll: (self tagMorphsFrom: self glamourPresentation for: element).  ^self theme newRowIn: self currentWorld for: rowElementsinitialize  super initializewantsExpandBox  ^falsecontentBrick  ^contentBrickrubricTextColor  ^self textColorlabel  ^self custom: GLMLabelPresentation newinitialize  super initialize.  smooth := falseaddCloserListener  self assert: [ self closer isNotNil ] description: [ 'Closer must not be nil' ].  self closer popup: self.  self activeHand addEventListener: self closerswitchPaneTo: anIndex  | normalizedIndex |  self invariant.  normalizedIndex := self normalizePaneIndex: anIndex.  self scrollToPane: normalizedIndex.  self focusPaneAt: normalizedIndex.  selectedPageIndex := normalizedIndex.  self notifySelectedPageChanged.  self invariantpadding  ^padding ifNil: [ padding := Array braceWith: 0 with: 0 with: 0 with: 0 ]onChildrenLayouted  super onChildrenLayouted.  self band translateXTo: (self convertScrollValue: (self pagerModel convertIndexToValue: self pagerModel firstVisiblePageIndex))withTextSegments: aCollection  self textSegments addAll: aCollectiontestNamedIn  | aPane |  aPane := GLMPane named: 1 in: 2.  self assert: aPane name equals: 1.  self assert: aPane browser equals: 2.  self assertEmpty: aPane ports.  self assert: aPane presentations isEmptytestPastingUpdatesTextPort  | composite textMorph |  composite := GLMCompositePresentation new with: [:a |  a text display: '' ].  window := composite openOn: 42.  textMorph := self find: RubEditingArea in: window.  Clipboard clipboardText: '42'.  textMorph editor paste.  self assert: (composite pane port: #text) value asString equals: '42'isSearchable  ^self parameters at: 'isSearchable' ifAbsent: [ false ]pageOf: aSubMorph  | parent page |  aSubMorph ifNil: [ ^0 ].  parent := aSubMorph.  [ parent isNotNil & (parent == self band) not ] whileTrue: [ page := parent.        parent := parent owner ].  ^parent ifNil: [ 0 ] ifNotNil: [ self panes indexOf: page ]onPagePoped: popedAnnouncement  self popPane: popedAnnouncement smoothsetUp  super setUp.  uiWaitingSemaphore := Semaphore newexpandedUntil: anInteger  self shouldExpandToLevel: anIntegerminWidth: anObject  self layout minWidth: anObjectmatches  < debuggingStone: #presentationCondition label: 'Presentation condition'>  ^(self usesImplicitAllNil ifTrue: [ GLMAllNilCondition new glamourValue: self entity ] ifFalse: [ self usesImplicitNotNil ifTrue: [ GLMAllNotNilCondition new glamourValue: self entity ] ifFalse: [ GLMSomeNotNilCondition new glamourValue: self entity ] ]) and: [ (self condition glamourValue: self entity) = true ]testPushPanesAfterOpen  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self openInWindow.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self assert: pagerModel size equals: 3.  self assert: self panesMorphs size equals: 3.  self assert: self buttonsMorphs size equals: 3asBrickedMorph  ^GLMFoundationBrick new brickRoot: selfcalculateHighlightingBounds  | textBounds highlightBounds last |  highlightBounds := OrderedCollection new.  textBounds := (self calculateTextPosition extent: self textSize) translateBy: (0 @ 0) negated.  last := self text asLowercase findString: self highlightedText asLowercase startingAt: 1.  last = 0 ifTrue: [ ^highlightBounds ].  [ last > 0 ] whileTrue: [ | beforeHighlightTextSize highlightSize matchingString |        matchingString := self text copyFrom: last to: last + self highlightedText size - 1.        highlightSize := self sizeOf: matchingString.        beforeHighlightTextSize := self sizeOf: (self text first: last - 1).        highlightBounds add: ((textBounds translateBy: beforeHighlightTextSize x @ 0) withWidth: highlightSize x).        last := self text asLowercase findString: self highlightedText asLowercase startingAt: last + 1 ].  ^highlightBoundscomputeFullBounds  isPassive  ^self isActive notparser: anObject  parser := anObjectenableFilterWithAction: aBlock  self enableFilter.  self parameters at: 'actionBlock' put: aBlockwhenKindOf: aClass  self when: [:each |  each isKindOf: aClass ]setFastTableLayoutFrame: newTableMorph  newTableMorph layoutFrame: LayoutFrame identitytagsBlock: aBlock  tagsBlock := aBlockscrollToBottom  self scrollTo: self model countbrowser  ^browsertestCopyAnnouncements  | pane newPane |  pane := GLMPane new.  pane when: GLMPresentationsChanged do: [:ann |  self fail ].  self assert: pane numberOfSubscriptions equals: 1.  newPane := pane copy.  newPane announce: GLMPresentationsChanged.  self assert: newPane numberOfSubscriptions equals: 0table  ^self custom: GLMTablePresentation newfromOutsideEntityPort  ^self fromOutsidePort: #entitydisplay: aBlockOrSymbol  self subclassResponsibilitytestExplicitAcceptDoesNotAffectTextPort  | composite textMorph |  composite := GLMCompositePresentation new with: [:a |  a pharoScript display: '123' ].  window := composite openOn: 4.  window position: 0 @ 0.  window extent > Display extent ifTrue: [ ^self ].  textMorph := self find: RubScrolledTextMorph in: window.  textMorph simulateClick.  self simulateKeyStrokes: '4'.  self assert: (composite pane port: #text) value equals: '1234'.  self simulateKeyStroke: $s meta.  self simulateKeyStrokes: '56'.  self assert: (composite pane port: #text) value equals: '123456'data  ^self valueOfProperty: #brickDataObject ifAbsentPut: [ nil ]onLayouted  super onLayouted.  self label isFitsInParent ifTrue: [ self isDotsAdded ifTrue: [ self privateRemoveBrick: self dotsBrick.              self doLayoutForce.              self changed ] ] ifFalse: [ self isDotsAdded ifFalse: [ self privateAddBrickBack: self dotsBrick.              self dotsBrick wrappedBounds height: self outerBounds height.              self layoutPolicy layoutFloating: self dotsBrick in: self brickBounds.              self doLayoutForce.              self changed ] ]logAnnouncement: anAnnouncement from: aGLMObject  announcements add: anAnnouncementcontentPadding  ^5renderTabulator: aBrowser  ^GLMMorphicTabulatorRenderer render: aBrowser from: selfisTerminated  process ifNil: [ ^true ].  ^process isTerminatedwidthParentDependency: aBrick  aBrick owner ifNil: [ Exception signal: 'My width depends on parent, but it is nil' ].  ^(aBrick owner innerBounds width * aBrick layout hPercent / 100) ceilingcompositePanel  | composite |  composite := self compositeMorph.  self assert: (composite isKindOf: PanelMorph).  self assert: (composite submorphs allSatisfy: [:morph |  morph isKindOf: ExpanderMorph ]).  ^compositeapproximateHeight  ^self label approximateHeight + self vMargin + self vPaddinginitialize  super initialize.  stringBrick := self newStringBrick.  dotsBrick := self newStringBrick.  self     hShrinkWrap;     vShrinkWrap.  stringBrick marginRight: self defaultInsetBeforeDots.  self privateAddBrickBack: stringBrick.  dotsBrick     text: self defaultDotsText;     width: #approximateWidth;     floating: #right;     zIndex: 2;     marginTop: 1paddingBottom  ^self wrappedBounds paddingBottomisEnabled  ^isEnabledtranslateXTo: anInteger  self translateX: self brickBounds left negated + anIntegertagsFilter: aBlock  tagsFilterBlock := aBlocktest100StaticBricksInsideEachOtherIndideStatic  | root current |  root := self newBrickWithStaticExtent.  current := root.  1 to: 100 do: [:index |  current := current addBrickBack: self newBrickWithStaticExtent ].  self assertAllSubbricksAreClean: root.  self assert: current extent equals: root extentupdateOn: anAnnouncement from: aBlockOrSymbol when: aConditionBlock  updateActions add: (GLMSingleUpdateAction new           presentation: self;           announcement: anAnnouncement;           transformation: aBlockOrSymbol;           condition: aConditionBlock;           yourself)updateVariableBindings  self announce: (GLMVariableBindingsChanged new presentation: self)layout: aBrick on: aTraverser  aTraverser layoutChildrenOf: aBrick.  aTraverser updateDimension: aBrick.  aTraverser markClean: aBrick.  aTraverser layoutOwnerOf: aBrickactionArguments  ^{}heightDependencies  ^heightDependencies ifNil: [ heightDependencies := OrderedCollection new ]existsUIProcess  ^UIManager default uiProcess isNotNiltestActions  | listing |  listing := GLMPresentation new.  listing actions isEmpty.  listing addAction: GLMAction new.  listing actions size = 1on: aSymbol do: aBlock ifAbsent: absentBlock  | state |  state := (aSymbol cull: self) ifTrue: [ self ] ifFalse: absentBlock.  aBlock cull: state.  ^statemorph: aMorph withToolbarOf: aPresentation  | container offset dock |  aPresentation hasActions ifFalse: [ ^aMorph ].  container := GLMMorphic containerMorph.  offset := 0.  dock := self renderToolbarForPresentation: aPresentation inMorph: container.  offset := dock minExtent y.  container addMorph: dock fullFrame: (LayoutFrame identity           bottomFraction: 0;           bottomOffset: offset).  container addMorph: aMorph fullFrame: (LayoutFrame identity topOffset: offset).  ^containercolumn: aBlockOrString evaluated: aBlock modified: aModifiedBlock  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           modifiedBlock: aModifiedBlock)updateColumnMorphs  super updateColumnMorphs.  self resizeColumnslabel: aBrick selected: aSelectedBrick  aBrick vSpaceFill.  aSelectedBrick vSpaceFill.  self maxWidth: aBrick layout maxWidth.  self     normalLabel: aBrick;     selectedLabel: aSelectedBrick;     selected: self isSelected.  self doLayoutForcetestSuspendParticularAnnouncementWhile  | announcement instance |  announcer when: GLMTestAnnouncement do: [:ann |  announcement := ann ].  announcer when: GLMTestAnnouncement2 do: [:ann |  announcement := ann ].  announcement := nil.  instance := announcer announce: GLMTestAnnouncement.  self assert: announcement equals: instance.  announcement := nil.  announcer suspendAll: {GLMTestAnnouncement} while: [ instance := announcer announce: GLMTestAnnouncement ].  self assert: announcement isNil.  announcement := nil.  announcer suspendAll: {GLMTestAnnouncement} while: [ instance := announcer announce: Announcement ].  self assert: announcement isNil.  announcement := nil.  announcer suspendAll: {GLMTestAnnouncement} while: [ instance := announcer announce: GLMTestAnnouncement2 ].  self assert: announcement equals: instanceindex  ^indexspecificDataSourceInitializiation  | presentation |  super specificDataSourceInitializiation.  presentation := tableModel glamourPresentation.  tableModel     childrenBlock: presentation children;     maxDepth: presentation maxDepth;     searchStrategy: presentation strategyonLayouted  super onLayouted.  self translateXTo: self leftPositionmarginRight: anObject  < brickBuilderProperty: #Geometry name: 'Margin Right' as: #asInteger getter: #marginRight model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds marginRight: anObjectfloating: aSymbol  floating := aSymbolarea  | firstBounds secondBounds |  firstBounds := self subbricks first outerBounds.  secondBounds := self subbricks second outerBounds.  ^GLMArea origin: firstBounds origin vectors: {(GLMVector east: firstBounds width) .         (GLMVector south: firstBounds height) .         (GLMVector horizontal: secondBounds corner x - firstBounds corner x) .         (GLMVector south: secondBounds height) .         (GLMVector west: secondBounds width) .         (GLMVector north: secondBounds height) .         (GLMVector horizontal: firstBounds origin x - secondBounds origin x) .         (GLMVector north: firstBounds height)}elementOrZeroAt: rowIndex  ^rowIndex = 0 ifTrue: [ 0 ] ifFalse: [ self elementAt: rowIndex ]addColumn: aColumn  self columns add: aColumnpriority: anInteger  priority := anIntegerwithAllPanesAndPresentationsDo: aBlock  super withAllPanesAndPresentationsDo: aBlock.  self do: [:each |  each withAllPanesAndPresentationsDo: aBlock ]on: anObject  origin := anObjectconvertValueToIndex: aValue  ^(self size - self actualNumberOfVisiblePages) * aValue + 1titleIcon: anObject  titleIcon := anObjectlastActivePresentation: aPresentation  textColor  ^self theme textColortestMarkerOneParentInParentWidth  | root brick |  root := self newBrickWithFullFill.  brick := self newBrickWithFullFill.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightCleantestMarkerOneChildrenInStaticHeight  | root brick |  root := self newBrickWithStaticExtent.  brick := self newBrickWithFullDependsOnChildren.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthClean.  self assert: brick wrappedBounds isHeightDirty.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightCleanstepTime  ^self model stepTimerender: aPresentation  | presentations container |  presentations := aPresentation matchingPresentations.  presentations isEmpty ifTrue: [ ^GLMMorphic emptyMorph ].  container := GLMMorphic containerMorph.  container changeTableLayout.  presentations do: [:each |  container addMorphBack: (self renderWithTitle: each) ].  ^containerstackedArrangement  ^self stackedVerticallyArrangementisClean: aBrick  ^aBrick isHeightCleanfindLast: aClass in: aMorph  ^self findLastSatisfying: [:morph |  morph isKindOf: aClass ] in: aMorphscrollbarColor  ^Color lightGray alpha: 0.5forbiddenAnnouncements: anObject  forbiddenAnnouncements := anObjectstatusbarPresentation  ^GLMLabelPresentation newonEscapePressed  self isCancelOnEscape ifTrue: [ self cancel ]testRemoveAllPages  tabs removePage: tabs pages first.  tabs removePage: tabs pages first.  self assertEmpty: tabs pages.  self assertEmpty: tabs contentMorph submorphsminHeight: anObject  self layout minHeight: anObjectcategory: aString  category := aStringcontents  ^contents ifNil: [ contents := self allContents select: [:each |  each shouldBeDisplayed ] ]updateDimension: aBrick  aBrick isWidthClean ifTrue: [ ^self ].  (self dimensionPolicy: aBrick) updateWidth: aBrickouterPortEvent: aPortEvent  super outerPortEvent: aPortEvent.  self cachedPresentation ifNotNil: [ self cachedPresentation outerPortEvent: aPortEvent ]announcer  ^announcer ifNil: [ announcer := GLMAnnouncer new ]tagsBlock: anObject  tagsBlock := anObjectcondition: anObject  condition := anObjectmakeSyncronous  isSyncronous := truelabel  ^self addBrickBack: self newLabelselectedText  ^(self pane port: #selectedText) value ifNil: [ self selectedTextBlock value ] ifNotNil: [ (self pane port: #selectedText) value ]closer: aPopupCloser  self removeCloserListener.  closer := aPopupCloser.  self addCloserListenerannouncements  ^announcementsrenderTabbedCompositePresentation: aCompositePresentation  ^GLMMorphicTabbedRenderer render: aCompositePresentation from: selfprintSelection  self announce: GLMPrintSelectionnewRubricMorph  ^GLMRubEditingArea new beWrappedcreateSimplePaneMorph  ^Morph newonCreated  self contentBrick padding: #(5 0).  self titleBrick: self newTitleBrick.  self hintBrick: self newHintBrickenabledCondition  ^enabledCondition ifNil: [ true ]testOuterEntity  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #one;     andShow: [:a |  a text ].  browser transmit     to: #two;     fromOutsidePort: #entity;     andShow: [:a |  a text ].  browser startOn: 42.  self assert: browser transmissions first origins anyOne name equals: #entity.  self assert: browser transmissions last origins anyOne name equals: #entity.  self assert: browser transmissions size equals: 2next: aVector  next := aVectortestWhenCondition  | transmission port1 port2 |  transmission := GLMTransmission new.  port1 := GLMSimplePort new     name: #port1;     value: #value1.  port2 := GLMSimplePort new name: #port2.  transmission addActiveOrigin: port1.  transmission destination: port2.  transmission condition: [:entity |  entity = #value1 ].  self assert: transmission meetsCondition.  transmission transmit.  self assert: port2 value equals: #value1renderSpecPresentation: aPresentation  ^GLMMorphicSpecRenderer render: aPresentation from: selfmeasureSelectionTimeInFinderForSize: size  | browser time window |  browser := self defaultFinderBrowser.  window := browser openOn: size.  time := Time millisecondsToRun: [ size timesRepeat: [ (window model panes last port: #selection) value: size ] ].  window delete.  ^{size .   time}hasMinWidth  ^(self minWidth isNumber ifTrue: [ self minWidth <= 0 ] ifFalse: [ false ]) notupdateTriggerBrick  | aTriggerImage |  aTriggerImage := self anchorBrick brickImageForm: self themer popupThemer backgroundColor.  self triggerBrick icon: aTriggerImagewindow: anObject  window := anObjectfilterOn: aBlock  self error: 'This presentation does not allow filtering with a block for now. In the futur we should have a new filter with FastTable to do that. If you want to give it a try look FTFunction and his subclasses.'removeAllMorphs  | oldMorphs myWorld |  myWorld := self world.  submorphs do: [:m |  myWorld ifNotNil: [ m outOfWorld: myWorld ].        m privateOwner: nil ].  oldMorphs := submorphs.  submorphs := EmptyArray.  oldMorphs do: [:m |  self removedMorph: m ]privateAddBrickBack: aBrick  | brick |  brick := aBrick asBrick.  self privateAddBrickLinkBack: brick.  self privateSubbricks: (self subbricks copyWith: brick).  ^aBrickneedActionButton  ^self parameters at: 'actionBlock' ifPresent: [ true ] ifAbsent: [ false ]presentation: anObject  presentation := anObjectresetAnnouncer  registry resetmatches: anObject  self filterBlock ifNil: [ ^true ].  ^self filterBlock valueWithEnoughArguments: {anObject .         pattern}selection: ann  | selection |  selection := ann newSelectedIndexes select: [:each |  each ~= 0 ] thenCollect: [:each |  (self elementAt: each) data ].  selection ifNotEmpty: [ self announcer announce: (GLMTreeMorphSelectionChanged new                 selectionValue: ((selection size = 1 and: [ self glamourPresentation isSingle ]) ifTrue: [ selection first ] ifFalse: [ selection ]);                 selectionPathValue: selection;                 yourself) ]allOwnersDo: aBlock  self owner ifNotNil: [ ^self owner withAllOwnersDo: aBlock ]computeTagsFilterFor: aGlamourValue  ^self computeTagsFor: aGlamourValue from: self tagsFilterBlockwantsSteps  ^wantsSteps ifNil: [ false ]renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderMorphPresentation: selfchildren: anObject  children := anObjectactOnPresentationUpdated: ann  listModel resetData.  dropDownMorph     updateList;     updateListSelectionIndexisLastVisible  self band hasSubbricks ifFalse: [ ^true ].  ^self isVisible: self band lastSubbrickscrollPageDown  self     scrollDown: self height;     update;     changeddoItReceiver  ^doItReceiver glamourValue: self entityremove: anObject ifAbsent: aBlock  collection remove: anObject ifAbsent: aBlock.  self announce: GLMItemRemoveddropEnabled  ^self glamourPresentation isDropTargetroots  | filtered |  roots ifNil: [ self roots: self displayValue ].  filtered := roots select: [:each |  each shouldBeDisplayed ].  ((self shouldFilterByAmount and: [ self amountToFilterBy < filtered size ]) and: [ filtered notEmpty ]) ifTrue: [ filtered := filtered first: self amountToFilterBy ].  ^filteredrightAngle: aDirection  ^aDirection = GLMWestDirection uniqueInstancecomputeTagsFor: anObject  | tags |  tags := OrderedCollection new.  self columns collect: [:aColumn |  tags addAll: (aColumn computeTagsFor: anObject) ].  ^tagsisRendered  ^actualPageMorph notNilshrinkingWidth  ^self morph widthinitialize  super initialize.  self     hShrinkWrap;     color: Color veryVeryLightGray muchLighter;     borderWidth: 1;     borderColor: Color veryVeryLightGray;     padding: #(4 7)testPaneName  | browser |  browser := GLMFinder new.  browser addPresentation: (GLMPresentation new title: 'presentation1').  (browser pane port: #entity) value: #value1.  self assert: browser panes first name equals: '1'.  (browser panes first port: #selection) value: #value2.  self assert: browser panes last name equals: '2'variableBindings: aBlock  ^variableBindingsBlock := aBlockrenderRubricHighlightedTextPresentation: aPresentation  ^GLMMorphicRubricHighlightedTextRenderer render: aPresentation from: selfsetAdaptor  | adaptor |  adaptor := (GLMBrickListModel on: self entity) morphAtLogic: [:index :morph |  self styledLogic phlowValue: (self formatLogic phlowValue: (self displayLogic phlowValue: (self entity at: index))) asBrick ].  self listBrick model: adaptorvirtualLastVisiblePageIndex  ^virtualLastVisiblePageIndexwithAllPresentations  | result |  result := OrderedCollection new.  self withAllPanesAndPresentationsDo: [:each |  (each isKindOf: GLMPresentation) ifTrue: [ result add: each ] ].  ^resultlayout: aBrick on: aTraverser  beRightToLeftWithOffset: anOffset  self invalidateWith: [ self triggerBrick hAlign: #right.        self triggerBrick marginRight: anOffset.        self foundationBrick bounds: (self foundationBrick bounds translateBy: ((self width - self triggerBrick width - anOffset - inset left) @ 0) negated) ]action  ^actioncolumn: aBlockOrSymbol size: anInteger  ^self addColumn: aBlockOrSymbol size: anIntegertestPortEquality  | presentation port |  presentation := GLMPresentation new.  port := GLMPresentationBoundPort new     name: #port;     presentation: presentation.  self assert: port equals: (presentation pane port: #port).  self assert: (presentation pane port: #port) equals: port.  self assert: port hash equals: (presentation pane port: #port) hash.  self assert: (presentation pane port: #port) hash equals: port hashborderColor  ^Color r: 127 g: 191 b: 127 range: 255testPortName  | anEvent portTwo |  portTwo := GLMSimplePort new     name: #portTwo;     value: 2.  anEvent := GLMPortEvent on: (GLMPort new           name: '1';           yourself) previouslyValued: portTwo.  self assert: anEvent portName equals: '1'withAllOwnersDo: aBlock  aBlock cull: self.  self owner ifNotNil: [ ^self owner withAllOwnersDo: aBlock ]allowsSearch  ^searchBlock notNilnewBar  ^GLMBrick newclearIn: aContext  self notingPresentationChangeDo: [ self presentations clear.        self ports do: [:each |  each value: nil in: aContext copy ] ]newRubricMorph  ^GLMRubTextFieldMorph newexecuteMenuAction: anAction  self announcer announce: (GLMMenuItemSelected action: anAction)layoutChildrenOf: aBrick  (self prioritySortedSubbricks: aBrick) do: [:each |  self layoutAround: each inContext: aBrick ]hideHeader  ^self parameters at: 'shouldShowHeader' put: [ false ]heightState: aSymbol  heightState := aSymbolspecificTableMorphColumnsInitialization  | presentation |  presentation := tableModel glamourPresentation.  tableMorph intercellSpacing: tableModel glamourPresentation intercellSpacing.  tableMorph beResizable.  presentation shouldShowHeader ifFalse: [ tableMorph hideColumnHeaders ] ifTrue: [ tableMorph showColumnHeaders ].  tableMorph columns: (presentation columns collect: [:each |  GLMFastTableColumn new                 id: (presentation titleValueOfColumn: each);                 width: each width;                 glamourColumn: each;                 target: tableModel actionSelector: #sortByColumn: arguments: {each};                 yourself ])updateVisible  | invisible |  self hasItems ifFalse: [ ^self ].  invisible := self gatherInvisibleItems.  invisible = self band subbricks & invisible isEmpty not ifTrue: [ ^self ].  self updateVisibleTop: invisible.  self updateVisibleBottom: invisible.  invisible do: [:each |  self removeBrickNoLayout: each ].  visibleIndex := self getIndex: self band firstSubbricklayoutPolicy: aBrick on: aTraverser  ^aBrick layoutPolicytestAddTransmissions  | browser transmission |  browser := GLMBrowser new.  self assertEmpty: browser transmissions.  transmission := GLMTransmission new.  browser addTransmission: transmission.  self assert: transmission browser equals: browserid  ^id ifNil: [ self ]browsingSelectionActions  ^{(GLMGenericAction new     title: 'Browse Full Class';     action: [:aPresentation |  aPresentation browseFullClass ];     shortcut: $b;     category: 'Code search...';     yourself) .   (GLMGenericAction new     title: 'Senders';     action: [:aPresentation |  aPresentation sendersOfIt ];     shortcut: $n;     category: 'Code search...';     yourself) .   (GLMGenericAction new     title: 'Implementors';     action: [:aPresentation |  aPresentation implementorsOfIt ];     shortcut: $m;     category: 'Code search...';     yourself) .   (GLMGenericAction new     title: 'References';     action: [:aPresentation |  aPresentation referencesToIt ];     category: 'Code search...';     withSeparatorAfter;     yourself) .   (GLMGenericAction new     title: 'Extended string search';     action: [:aPresentation |  aPresentation selectLine.        self systemNavigation browseMethodsWithString: aPresentation selectedText matchCase: false ];     shortcut: $E;     category: 'Code search...';     yourself) .   (GLMGenericAction new     title: 'Method source containing selection';     action: [:aPresentation |  aPresentation selectLine.        self systemNavigation browseMethodsWithSourceString: aPresentation selectedText matchCase: false ];     category: 'Code search...';     withSeparatorAfter;     yourself)}font  ^fontnewBrickFullHeightAndWidthDependsOnParent: anInteger  ^GLMBrick new     vSpaceFill;     hSpaceFill: anInteger;     color: Color random;     yourselfisScrollable  ^self leftoverScrollRange > 0computation: anObject  computation := anObjectvShrinkWrap  super vShrinkWrap.  self label vShrinkWraponThemerChanged  renderPane: aPane  ^nilonRemovedFrom: aBrick  self subbricks do: [:each |  each onRemovedFrom: aBrick ]updateWidth: aBrick on: aLayout  setAdaptor  | adaptor |  adaptor := (GLMBrickListModel on: self transformedEntity) morphAtLogic: [:index |  GLMPhlowTableRowBrick new           in: self;           entity: (self transformedEntity at: index) ].  self listBrick model: adaptortestTreeDefaultAllowDeseletion  | browser treeNodeMorph |  browser := GLMFinder new.  browser show: [:a |  a tree ].  window := browser openOn: ($a to: $d).  treeNodeMorph := self treeVisibleItems first.  self send: self tree mouseUpOnItem: treeNodeMorph.  self send: self tree mouseUpOnItem: treeNodeMorph.  self assert: (browser panes first port: #selection) value equals: $anewDataSourceMatching: aFTFilter  ^(super newDataSourceMatching: aFTFilter)     glamourPresentation: self glamourPresentation;     yourselfhasActions  ^falseactOnPaneAdded: ann  container pushPane: (self renderObject: ann pane)render: aRenderable  | dock offset bottomOffset |  window := GLMSystemWindow new model: aRenderable.  self installActionsOnModel: window fromPresentation: aRenderable.  self installKeystrokeActionsOnMorph: window fromPresentation: aRenderable.  self setLabelOf: window for: aRenderable.  offset := 4.  bottomOffset := 0.  dock := self renderToolbarForPresentation: aRenderable inMorph: window.  dock hResizing: #shrinkWrap.  window toolbarBox: dock.  bottomOffset := self handlePotentialStatusbarFor: aRenderable.  window addMorph: (self renderObject: aRenderable) fullFrame: ((0 @ 0 corner: 1 @ 1) asLayoutFrame           topLeftOffset: 0 @ offset;           bottomRightOffset: 0 @ bottomOffset).  self setPotentialBackgroundColorFor: aRenderable.  aRenderable when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  aRenderable when: GLMPresentationToolbarUpdated send: #actOnPresentationToolbarUpdated: to: self.  aRenderable when: GLMWindowRequest send: #actOnWindowRequest: to: window.  aRenderable watcherPane notNil ifTrue: [ GLMMorphicWatcherRenderer render: aRenderable watcherPane from: self renderer ].  ^windowwindowIsClosing  | event |  event := GLMBrowserClosing new presentation: self.  self withAllPresentations do: [:each |  each announce: event ]testEmptyBrickDependsOnChildren  | brick |  brick := self newBrickWithFullDependsOnChildren.  self assert: brick brickApi layout hState isOnChildren.  self assert: brick brickApi layout vState isOnChildren.  self assertAllSubbricksAreDirty: brick.  brick doLayout.  self assertAllSubbricksAreClean: brick.  self assert: brick extent equals: 0 @ 0pharoMethod  ^self custom: GLMPharoMethodPresentation newhSpaceFill  self hSpaceFill: 100messageBrick  ^messageBricktestStartWithOnlyJumpStart  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #one;     andShow: [:a |  a list ].  browser transmit     to: #two;     from: #one;     andShow: [:a |  a text ].  self assert: browser transmissions size equals: 2.  self assertEmpty: (browser paneNamed: #one) presentations.  self assertEmpty: (browser paneNamed: #two) presentations.  browser startOn: #(15 25 35).  self assert: (browser paneNamed: #one) presentations size equals: 1.  self assert: (browser paneNamed: #one) matchingPresentations size equals: 1.  self assertEmpty: (browser paneNamed: #two) presentations.  self assertEmpty: (browser paneNamed: #two) matchingPresentationstestMarkerOneParentInStaticHeight  | root brick |  root := self newBrickWithStaticExtent.  brick := self newBrickWithFullFill.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthClean.  self assert: brick wrappedBounds isHeightDirty.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightCleanrenderer  ^self valueOfProperty: #brickRenderer ifAbsentPut: [ nil ]testAddPane  | browser pane |  browser := GLMBrowser new.  self assertEmpty: browser panes.  pane := GLMPane new.  browser addPane: pane.  self assert: pane browser equals: browserlayout: aBrick on: aTraverser  aTraverser updateDimension: aBrick.  aTraverser markClean: aBrick.  aTraverser layoutChildrenOf: aBrick.  aTraverser layoutOwnerOf: aBrickchildrenItems  ^(self containerTree glamourPresentation childrenValueOf: self item atLevel: self path size) ifNil: [ OrderedCollection new ]action: aBlock  actionBlock := aBlocktoggleFilteringByTag: aTag  (self shouldFilterByTag: aTag) ifTrue: [ self tagsToFilterBy remove: aTag ] ifFalse: [ self tagsToFilterBy add: aTag ].  self resetChildrenContent.  self tableRefreshtoolbar  ^toolbarcachedMatchingPresentations: anObject  ^cachedMatchingPresentations := anObjectenableFilter  self parameters at: 'isFilterable' put: truetestOneStaticBrick  | brick |  brick := self newBrickWithStaticExtent.  self assert: brick brickApi layout hState isOnMyself.  self assert: brick brickApi layout vState isOnMyself.  self assertBrickClean: brick.  self assert: brick extent equals: self staticExtentcontext  ^OrderedCollection newcustomDependencies: aBrick  ^aBrick layout widthDependenciesrender: aBrowser  | pagerModel |  pagerModel := GLMPagerModel new     isDependenciesShown: false;     defaultNumberOfVisiblePages: aBrowser fixedSizePanes;     minimumPageNumberForScrollbar: aBrowser minimumPageNumberForScrollbar.  aBrowser scrollButtonIconRenderBlock ifNotNil: [ pagerModel scrollButtonIconRenderBlock: [:index |  aBrowser scrollButtonIconRenderBlock cull: ((aBrowser panes at: index) port: #entity) value ] ].  container := (GLMPagerBrick new     pagerModel: pagerModel;     yourself) asBrickedMorph.  self registerAnnouncementsFor: aBrowser.  aBrowser panes do: [:each |  container brickRoot pushPane: (self renderObject: each) ].  ^containerinnerBounds  ^self wrappedBounds innerBoundsdefaultValidate: anObject on: aPort  ^truemorphicAct: aBlock entitled: aString  self addAction: (GLMMorphicAction new           action: aBlock;           title: aString;           yourself)with: aBlock  aBlock value: selfextent: aPoint  | newExtent |  newExtent := aPoint rounded.  (bounds extent closeTo: newExtent) ifTrue: [ ^self ].  self invalidRect: bounds.  bounds := bounds topLeft extent: newExtent.  self layoutChanged.  self invalidRect: boundspresentationTransformation: anObject  presentationTransformation := anObjectcomputeTagsFilterFor: aGlamourValue  self subclassResponsibilityselectionValue: anObject  selectionValue := anObjectdirection: aDirection  direction := aDirectionselect  self isSelected ifFalse: [ isSelected := true.        self announce: #onMouseHover.        self changed ]+ aPoint  ^aPoint + self offsetrender: aPresentation  textModel := self modelFor: aPresentation.  textModel primarySelectionInterval: (aPresentation primarySelectionInterval ifNil: [ aPresentation selectionInterval ifNil: [ 1 to: 0 ] ]).  textMorph := self morph.  aPresentation text: textMorph text.  aPresentation withLineNumbers ifTrue: [ textMorph withLineNumbers ] ifFalse: [ textMorph withoutLineNumbers ].  aPresentation withAnnotation ifTrue: [ textMorph withAnnotation ] ifFalse: [ textMorph withoutAnnotation ].  aPresentation withColumns ifTrue: [ textMorph withColumns ] ifFalse: [ textMorph withoutColumns ].  textMorph wrapped: aPresentation wrapped.  textMorph tabWidth: aPresentation tabWidth.  aPresentation withGhostText ifNotNil: [ textMorph withGhostText: aPresentation withGhostText asStringOrText ].  aPresentation textSegments do: [:each |  textMorph addSegment: each ].  (aPresentation textSegments anySatisfy: [:ts |  ts icon notNil ]) ifTrue: [ textMorph withTextSegmentIcons ] ifFalse: [ textMorph withoutTextSegmentIcons ].  textMorph textArea announcer when: RubTextChanged do: [:ann |  aPresentation announcer suspendAllWhile: [ aPresentation text: textMorph text ] ].  textMorph textArea announcer when: RubSelectionChanged do: [:ann |  aPresentation announcer suspendAllWhile: [ aPresentation selectionInterval: textMorph selectionInterval.              aPresentation selectedText: textMorph textArea selection ] ].  textMorph textArea announcer when: RubTextAccepted do: [:ann |  aPresentation suspendAllWhile: [ aPresentation text: ann text ] ].  self installActionsOnModel: textModel fromPresentation: aPresentation.  self installKeystrokeActionsOnMorph: textMorph textArea fromPresentation: aPresentation.  self registerEventsForPresentation: aPresentation.  ^textMorphorigin  ^originhandleListenEvent: anEvent  anEvent type = #keystroke ifTrue: [ (self boundsInWorld containsPoint: anEvent position) ifTrue: [ self scrollByKeyboard: anEvent ] ]bar: aBrick  bar := aBrick.  self addBrickBack: aBrickrenderBorderOf: aBrick on: aCanvas  | canvas widthLeft widthRight widthTop widthBottom colorLeft colorRight colorTop colorBottom |  canvas := aCanvas.  widthLeft := self widthLeft brickValue: aBrick.  widthRight := self widthRight brickValue: aBrick.  widthTop := self widthTop brickValue: aBrick.  widthBottom := self widthBottom brickValue: aBrick.  colorLeft := self colorLeft brickValue: aBrick.  colorRight := self colorRight brickValue: aBrick.  colorTop := self colorTop brickValue: aBrick.  colorBottom := self colorBottom brickValue: aBrick.  canvas fillRectangle: (aBrick brickBounds origin extent: (aBrick brickBounds width - widthRight) @ widthTop) color: colorTop.  canvas fillRectangle: ((aBrick brickBounds right - widthRight) @ aBrick brickBounds top corner: aBrick brickBounds corner - (0 @ widthBottom)) color: colorRight.  canvas fillRectangle: (aBrick brickBounds bottomLeft - (widthLeft negated @ widthBottom) corner: aBrick brickBounds corner) color: colorBottom.  canvas fillRectangle: (aBrick brickBounds origin + (0 @ widthTop) corner: aBrick brickBounds bottomLeft + (widthLeft @ 0)) color: colorLefttoggleFilteringByTag: aTag  self containerTree toggleFilteringByTag: aTagisLayoutClean: aBrick  ^aBrick ifNotNil: [:b |  b layout isClean ] ifNil: [ true ]rectangleMorphFrom: anActionListPresentation  ^BorderedMorph new     borderWidth: 0;     color: Color transparent;     layoutPolicy: TableLayout new;     cellPositioning: #topLeft;     hResizing: #spaceFill;     vResizing: #spaceFill;     listDirection: (anActionListPresentation isHorizontal ifTrue: [ #leftToRight ] ifFalse: [ #topToBottom ]);     listCentering: #topLeft;     wrapCentering: #topLeft;     cellInset: 5;     yourselftransmission: anObject  transmission := anObjectexecute: aBlock withArguments: aCollection callback: callbackBlock delay: anIntegerMilliseconds  ^self execute: aBlock withArguments: aCollection callback: callbackBlock priority: Processor userSchedulingPriority delay: anIntegerMillisecondsheightMyselfDependency: aBrick  ^aBrick layout height brickValue: aBrick brickpresentation: anObject  presentation := anObjectaddBrickBack: aBrick  self band addBrickBack: aBricknewLabelBrick  ^GLMLabelBrick newremoveAllBricks  self brickRoot removeAllBrickscalculateMaxVelocity  ^self band width / 15 max: self class defaultMaxVelocityhShrinkWrap  super hShrinkWrap.  self label hShrinkWraptextSegments  ^textSegments ifNil: [ textSegments := OrderedCollection new ]newIndex: anObject  newIndex := anObjecttransmissionContext  ^transmissionContextpostCopy  origins := self originReferences collect: [:each |  each copy ].  destination := destination copy.  transmissionStrategy := transmissionStrategy copy.  transmissionStrategy transmission: selfpageIndex: anObject  pageIndex := anObjecttestPresentationAndBrowserConditions  | pane presentation1 presentation2 presentation3 |  pane := GLMPane named: 'test'.  presentation1 := GLMExplicitBrowser new condition: [:first :second |  first = 1 and: [ second = 2 ] ].  presentation2 := GLMTabulator new condition: [:first |  first = #foo ].  presentation3 := GLMExplicitBrowser new useExplicitNotNil.  pane addPresentation: presentation1.  pane addPresentation: presentation2.  pane addPresentation: presentation3.  (pane port: #entity) value: (GLMMultiValue withAll: #(1 2)).  self assert: pane matchingPresentations size equals: 2.  self assert: pane matchingPresentations first identicalTo: presentation1.  self assert: pane matchingPresentations last identicalTo: presentation3.  (pane port: #entity) value: (GLMMultiValue withAll: #(#foo 2)).  self assert: pane matchingPresentations size equals: 2.  self assert: pane matchingPresentations first identicalTo: presentation2.  self assert: pane matchingPresentations last identicalTo: presentation3.  (pane port: #entity) value: (GLMMultiValue withAll: #(nil 2)).  self assert: pane matchingPresentations size equals: 1addBrickBackNoLayout: aBrick  self band doNotLayoutDuring: [ self band addBrickBack: aBrick ].  ^aBricksize  ^pagesCountonPagePopedAndReplaced: ann  self popAndReplace: ann brickpopAndReplace: aBrick  | brick |  brick := self configurePane: aBrick.  brick wrappedBounds: self band lastSubbrick wrappedBounds.  brick updateMorphBounds.  self band doNotLayoutDuring: [:b |  b           removeBrick: b lastSubbrick;           addBrickBack: brick ].  self changedhasPane  ^falseallowedBounds: aRectangle  allowedBounds := aRectangleonChildrenLayouted  self updateFoundationBoundstestUpdate  | browser dynamicContainerMorph presentationObject |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a dynamic presentation: [:some :object |  some custom: presentationObject ] ].  presentationObject := GLMRubricTextPresentation new.  window := browser openOn: 42.  dynamicContainerMorph := window submorphs last submorphs first submorphs first.  self assert: (dynamicContainerMorph isKindOf: PanelMorph).  self assert: (dynamicContainerMorph submorphs first isKindOf: RubScrolledTextMorph).  presentationObject := GLMListPresentation new.  browser update.  dynamicContainerMorph := window submorphs last submorphs first submorphs first.  self assert: (dynamicContainerMorph isKindOf: PanelMorph).  self assert: (dynamicContainerMorph submorphs first submorphs first isKindOf: MorphTreeMorph)font  ^fontallDisplayedDo: aBlock  self displayValue do: [:eachRoot |  self withChildrenOf: eachRoot do: aBlock ]isLayoutDirty: aBrick  ^aBrick ifNotNil: [:b |  b layout isDirty ] ifNil: [ true ]testActionDefinition  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a text act: [  ] entitled: ''.        a list act: [  ] entitled: ''.        a tree act: [  ] entitled: '' ].  browser startOn: #(42).  browser panes first presentations do: [:each |  self assert: each actions size equals: 1 ]icon: anObject  icon := anObjectbrickBounds  ^bounds ifNil: [ bounds := 0 @ 0 corner: 50 @ 50 ]state  ^#hStateact: aBlock on: aCharacter entitled: aString  self addAction: (GLMGenericAction new           action: aBlock;           shortcut: aCharacter;           title: aString;           yourself)allow: passengerObject droppedOnItem: anItem  ^self allowDropOnItemBlock glamourValue: (GLMMultiValue with: passengerObject with: anItem with: self)popup: aPopupBrick event: anEvent  < return: #Boolean>  self subclassResponsibilityfamilyName: aString  familyName := aString.  self updateFontprofileHighlightedText  textMorph textArea editor tallyHighlight.  textMorph shoutStyler style: textMorph textpresentations  ^presentationsvShrinkWrap  super vShrinkWrap.  self label vShrinkWraptitleIconValue  ^self titleIcon notNil ifTrue: [ self titleIcon glamourValue: self entity ] ifFalse: [ self titleIcon ]withAllPanesAndPresentationsDo: aBlock  aBlock value: self.  self presentations withAllPanesAndPresentationsDo: aBlockpaneName  ^paneNamecondition  ^condition ifNil: [ true ]privatePrepareBrickAfterRemoving: aBrick  self privateRemoveOutWorld: aBricktestPresentationInitializationBlock  | dynamic count |  count := 0.  dynamic := GLMDynamicPresentation new.  dynamic transformation: [:entity |  GLMListPresentation new initialize: [:pres |  count := count + 1.              pres selection: 5 ] ].  dynamic entity: (1 to: 42).  self assert: count equals: 0.  self assert: dynamic currentPresentation presentations first selection equals: 5.  self assert: count equals: 1innerPortEvent: aPortEvent  | wantedTransmissions |  aPortEvent hasChanged ifFalse: [ ^self ].  wantedTransmissions := self transmissions select: [:each |  (each originatesAt: aPortEvent port) and: [ (aPortEvent transmissionContext includesPort: each destination) not ] ].  wantedTransmissions do: [:each |  each transmitIn: aPortEvent transmissionContext copy ]browser: aBrowser  browser := aBrowseractOnPaneAdded: ann  self addMorphFromObject: ann pane toContainer: container.  scrollPane hScrollbar glmAnimateValue: 1.0 duration: 2000emptyBrick: aBrick  emptyBrick := aBrickinitialize  super initialize.  resizingZoneWidth := 7.  isRightResizing := false.  isLeftResizing := false.  isResizing := false.  self     normalColor: (Color veryLightGray alpha: 0.4);     selectedColor: (Color veryLightGray alpha: 0.55);     enablemorphicActOn: aPresentation  ^(self actOn: aPresentation) openpopPane  transform removeMorph: transform lastSubmorph.  transform submorphs isEmpty ifFalse: [ transform removeMorph: transform lastSubmorph ].  paneCount := paneCount - 1.  self updatePanesannouncer  ^glmAnnouncer ifNil: [ glmAnnouncer := GLMAnnouncer new ]testBottomMarginMyselfDependency  | root margin brick |  margin := 10.  root := self newBrickWithStaticExtent.  brick := self newBrickWithSmallStaticExtent.  brick marginBottom: margin.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticSmallExtent.  self assert: brick brickBounds equals: (0 @ 0 extent: self staticSmallExtent)title  ^titlecheckboxBorderWidth  ^2initialize: aBlock  initializationBlock := aBlockscrollbarOffset  ^1= anObject  ^((anObject isKindOf: GLMBoundPort) and: [ self pane = anObject pane ]) and: [ self name = anObject name ]model: anAdaptor  adaptor := anAdaptor.  self band hasSubbricks ifFalse: [ self updateVisible ].  self updatereferencesToIt  self announce: (GLMTextEditorRequest for: #referencesToIt)isOnChildren  ^falseformat: anObject  self setProperty: #phlowFormat toValue: anObjecttoolbarBox: anObject  | previousToolbar |  previousToolbar := toolbarBox ifNil: [ menuBox ].  toolbarBox := anObject.  self setLabelWidgetAllowance.  self replacePane: previousToolbar with: toolbarBoxenableSearch  self parameters at: 'isSearchable' put: truetestWith  | p presentationInWithBlock |  p := GLMPresentation new.  p with: [:thePresentation |  presentationInWithBlock := thePresentation ].  self assert: presentationInWithBlock identicalTo: ponGotFocus: ann  self animateToEditFocusedsubbricksCount  ^self subbricks sizetestMarkerOneChildrenInChildrenWidth  | root brick |  root := self newBrickWithFullDependsOnChildren.  brick := self newBrickWithFullDependsOnChildren.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean.  self assert: root wrappedBounds isWidthDirty.  self assert: root wrappedBounds isHeightCleancontextClassValue  ^self contextClass glamourValue: self entitytitleActionBlock  ^labelActionBlockcallback  ^callback ifNil: [ callback := [  ] ]color: aColor  < brickBuilderProperty: #'Look&Feel' name: 'Color' as: #brickBuilderEvaluate getter: #color model: #GLMUIBuilderTextFieldProperty>  self setProperty: #brickBackgroundColor toValue: aColordataCache  ^dataCache ifNil: [ dataCache := self class defaultCache ]actOnPresentationToolbarUpdated: ann  | presentations |  presentations := ann presentation matchingPresentations.  tabs pages size to: 1 by: -1 do: [:i |  (tabs pages at: i) toolbar: GLMMorphic emptyMorph ].  presentations withIndexDo: [:each :i |  tabs updatePageAtIndex: i withLabel: (self titleOrIconOf: each in: tabs) toolbar: (self renderToolbarForPresentation: each inMorph: tabs) action: (self labelActionMorphFor: each) ]onTextChanged: ann  self onTextAccepted: annwithoutBackground  self rubric color: Color transparent.  self rubric textArea color: Color transparentlastActivePresentation  ^lastActivePresentation ifNil: [ self panes last lastActivePresentation ]testUpdatingTextPortUpdatesTheMorph  < expectedFailure>  | composite textMorph |  composite := GLMCompositePresentation new with: [:a |  a text ].  window := composite openOn: 'fourtytwo'.  composite first text: '42'.  self assert: (composite pane port: #text) value asString equals: '42'.  textMorph := self find: RubPluggableTextMorph in: window.  self assert: textMorph text asString equals: '42'buttons: anObject  buttons := anObjectentity: anObject  super entity: anObject.  self setAdaptortagsFilterBlock  ^tagsFilterBlocktext: aString  self privateSetText: aString.  self wrappedBounds markWidthDirtyactionColumn: column  column execute.  self tableRefreshunregisterFromAllAnnouncements  self presentations unregisterFromAllAnnouncementstestOneStackedVerticallyWithTitle  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a stackedVerticallyArrangement.        a title: 'title'.        a list ].  window := browser openOn: 42.  self assert: self compositeTabGroup submorphs notEmpty.  self assert: self compositeTabGroup submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph class equals: GLMPanelMorph.  self assert: self compositeTabGroup contentMorph submorphs size equals: 1.  self assert: self compositeTabGroup contentMorph submorphs first class equals: GLMPanelMorph.  self assert: self compositeTabGroup contentMorph submorphs first submorphs size equals: 1.  self assert: self compositeTabGroup contentMorph submorphs first submorphs first class equals: LazyTabGroupMorphisOppositeClean: aBrick  ^self subclassResponsibilityselectionSpawn: aBlock entitled: aString  self addSelectionAction: (GLMSpawnBrowserAction new           action: aBlock;           title: aString;           yourself)allMenuActions  ^self glamourPresentation allSelectionActions select: #hasTitlegoAction  ^GLMGenericAction new     title: 'Do it and go';     action: [:t :entity |  t highlightEvaluateAndDo: [:result |  t selection: result ] ];     shortcut: $g;     yourselfinitialize  super initialize.  wasTransmited := falsetestTextBackgroundColor  | browser firstTreeMorph treeNodeMorph txtMorph |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list           display: [:x |  1 to: x ];           textBackgroundColor: [:aNumber |  (aNumber isDivisibleBy: 2) ifTrue: [ Color green ] ifFalse: [ Color red ] ] ].  window := browser openOn: 4.  firstTreeMorph := window submorphs last submorphs first submorphs first submorphs first.  treeNodeMorph := firstTreeMorph scroller submorphs first.  txtMorph := treeNodeMorph submorphs first submorphs first submorphs first.  self assert: (txtMorph isKindOf: TextMorph).  self assert: txtMorph backgroundColor equals: Color red.  treeNodeMorph := firstTreeMorph scroller submorphs second.  txtMorph := treeNodeMorph submorphs first submorphs first submorphs first.  self assert: (txtMorph isKindOf: TextMorph).  self assert: txtMorph backgroundColor equals: Color green.  treeNodeMorph := firstTreeMorph scroller submorphs third.  txtMorph := treeNodeMorph submorphs first submorphs first submorphs first.  self assert: (txtMorph isKindOf: TextMorph).  self assert: txtMorph backgroundColor equals: Color red.  treeNodeMorph := firstTreeMorph scroller submorphs fourth.  txtMorph := treeNodeMorph submorphs first submorphs first submorphs first.  self assert: (txtMorph isKindOf: TextMorph).  self assert: txtMorph backgroundColor equals: Color greenchanged  self world ifNil: [ ^self ].  self invalidRect: self globalClippingBoundsport  ^self pane port: self nametestMarkerOneStaticInParentHeight  | root brick |  root := self newBrickWithFullFill.  brick := self newBrickWithStaticExtent.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthClean.  self assert: brick wrappedBounds isHeightDirty.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightCleanopenOn: anObject  ^self openOn: anObject with: self defaultRenderercan: aPane announce: anAnnouncement  ^((self forbiddenAnnouncements at: aPane ifAbsent: [ Set new ]) includes: anAnnouncement) notalert: anObject  | window |  self alertOn: anObject.  window := self openInBrickWindowLabeled: 'Alert'.  self class environment at: #GLMSystemWindowBrick ifPresent: [ window           noMenu;           innerExtent: self extent ]shouldFilterByTag: aTag  ^self tagsToFilterBy includes: aTagtestLeftFloatingMySelfDependency  | root floating brick |  floating := #left.  root := self newBrickWithStaticExtent.  brick := self newBrickWithSmallStaticExtent.  brick layout floating: floating.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticSmallExtent.  self assert: brick brickBounds equals: (0 @ 0 extent: self staticSmallExtent)minimumPageNumberForScrollbar: aNumber  minimumPageNumberForScrollbar := aNumberbuttonForTag: each filter: filter  | button |  button := GLMMorphic togglingButtonLabelled: each pressed: (self containerTree shouldFilterByTag: filter) style: self containerTree glamourPresentation tagsStyle.  button     target: self;     actionSelector: #toggleFilteringByTag:;     arguments: (Array with: filter).  ^buttontextBackgroundColor  ^textBackgroundColor ifNil: [ textBackgroundColor := Color transparent ]isClean  ^self isDirty notsilentValue: anObject  value := anObjectdefaultNumberOfVisiblePages  ^2scrollpaneBackgroundColor: aColor  self setProperty: #brickScrollpaneBackgroundColor toValue: aColor.  self updateStylelabelBrick  ^labelBricktopShadowOf: aBrick on: aCanvas  | gradient width origin offset |  width := aBrick shadowWidth.  offset := width @ width negated / 2.0.  origin := aBrick brickBounds topLeft + offset + aBrick shadowOffset.  gradient := (self shadowGradientFor: aBrick)     origin: origin - offset + (0 @ (width / 2.0));     direction: (0 @ width) negated;     yourself.  aCanvas fillRectangle: (origin extent: (aBrick width - width) @ width) fillStyle: gradientprivateRecomputeIndexesAfterScrollAt: aFloat  | left right |  self invariant.  left := self convertValueToIndex: aFloat.  right := left + self actualNumberOfVisiblePages - 1.  firstVisiblePageIndex := left rounded.  lastVisiblePageIndex := right rounded.  lastVisiblePageIndex > self size ifTrue: [ | delta |        delta := lastVisiblePageIndex - self size.        firstVisiblePageIndex := firstVisiblePageIndex - delta.        lastVisiblePageIndex := lastVisiblePageIndex - delta ].  self invariantcomputeTagsFor: aGlamourValue from: aBlock  | value |  aBlock ifNil: [ ^OrderedCollection new ].  value := aBlock glamourValue: aGlamourValue.  ^value isString ifTrue: [ OrderedCollection with: value ] ifFalse: [ value asOrderedCollection ]wrappedBounds  ^brickBounds ifNil: [ brickBounds := GLMBrickBounds new ]renderColorOf: aBrick on: aCanvas  | color |  color := aBrick currentColor.  color ifNotNil: [ aCanvas fillRectangle: (aBrick brickBounds expandBy: aBrick shadowWidth negated) color: color ]formatSourceCode  textMorph formatSourceCodekeyStroke: event  (self navigationKey: event) ifTrue: [ ^self ].  event keyCharacter = Character arrowLeft ifTrue: [ self selectPreviousTab ].  event keyCharacter = Character arrowRight ifTrue: [ self selectNextTab ]rubricTextColor  ^self valueOfProperty: #brickRubricTextColor ifAbsent: [ self themer rubricTextColor ]allowedBounds  ^self globalBoundsrender: aLabelPresentation  labelMorph := (LabelMorph contents: aLabelPresentation formatedDisplayValue)     layoutFrame: LayoutFrame identity;     vResizing: #spaceFill;     hResizing: #spaceFill;     font: StandardFonts haloFont;     yourself.  aLabelPresentation when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  ^labelMorphmarkWidthClean  self widthState: #cleanbackgroundColor  ^Color r: 204 g: 229 b: 204 range: 255render: aRenderable  ^aRenderable renderGlamorouslyOn: selfcellColumn: aColumn row: aRowIndex  | item cell |  item := self elementAt: aRowIndex.  cell := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForColumn: aColumn item: item withIndex: aRowIndex);     yourself.  ^cellwithoutStyler  self textArea withoutDecorator: self stylerDecoratortestAsTargetIdentifier  | id |  id := GLMPortIdentifier new.  self assert: id asGlamourTargetIdentifier equals: idscrollButtonIconRenderBlock: anObject  scrollButtonIconRenderBlock := anObjecttestCreationVariableSize  window := GLMFinder new     variableSizePanes;     openOn: 123.  self assert: window submorphs last class equals: GeneralScrollPaneheight  ^self vState dimensionouterPortEvent: aPortEvent  super outerPortEvent: aPortEvent.  self do: [:each |  each outerPortEvent: aPortEvent ]actionName  ^self parameters at: 'actionName' ifAbsent: 'Validate'testSimpleTransmission  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     from: #one port: #port1;     fromOutsidePort: #outerPort;     to: #two port: #port2.  browser transmit     from: #one port: #port3;     toOutsidePort: #anotherOuterPort.  self assert: browser transmissions size equals: 2.  self assert: browser transmissions first browser identicalTo: browser.  self assert: (browser transmissions first transmissionStrategy isKindOf: GLMNoStrategy).  self assert: browser transmissions first origins first equals: ((browser paneNamed: #one) port: #port1).  self assert: browser transmissions first origins last equals: (browser pane port: #outerPort).  self assert: browser transmissions first destination equals: ((browser paneNamed: #two) port: #port2).  self assert: browser transmissions last browser identicalTo: browser.  self assert: (browser transmissions last transmissionStrategy isKindOf: GLMNoStrategy).  self assert: browser transmissions last origins first equals: ((browser paneNamed: #one) port: #port3).  self assert: browser transmissions last destination equals: (browser pane port: #anotherOuterPort)sortBlock  ^columnToSortBy sortBlock ifNotNil: [:aBlock |  aBlock ] ifNil: [ columnToSortBy defaultSortBlockForPresentation: self glamourPresentation ]filterBlock  ^self parameters at: 'filterBlock'doesNotUnderstand: aMessage  ^self labelBrick perform: aMessage selector withArguments: aMessage argumentssecond  ^self presentations secondtestExplicitSelectionDoesNotUpdate  | composite |  composite := GLMCompositePresentation new with: [:c |  c tree           allowsRecursiveSearch: false;           children: [:each |  each to: each + 10 ] ].  window := composite openOn: {1}.  composite selection: Object new.  self assert: self tree selectedMorph equals: niltransmit  wasTransmited := true.  super transmitcheckedImage  ^checkedImagehighlightSmalltalkContext  ^highlightSmalltalkContext ifNil: [ nil ] ifNotNil: [ highlightSmalltalkContext glamourValue: self entity ]title: anObject  title := anObjectselectionPathValue: anObject  selectionPathValue := anObjecttitleBrick: aBrick  titleBrick := aBrick     textPosition: #center;     height: 0;     hSpaceFill.  self addBrickBack: titleBrickcomputeTagsFor: aGlamourValue  self subclassResponsibilitynewCheckboxBrick  ^GLMInteractableBrick newtestDynamicActions  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list           display: [:x |  1 to: x ];           dynamicActions: [:list |  (1 to: list selection) collect: [:index |  GLMGenericAction new                       action: [ index ];                       title: 'Action' , index printString;                       yourself ] ] ].  browser startOn: 42.  (browser panes first port: #selection) value: 3.  self assert: browser panes first presentations first dynamicActions size equals: 3.  (browser panes first port: #selection) value: 5.  self assert: browser panes first presentations first dynamicActions size equals: 5selectionPopulate: aPortSymbol on: aCharacter entitled: aString with: aBlock  self addSelectionAction: (GLMGenericAction new           action: (GLMPortUpdater new                 portSymbol: aPortSymbol;                 valueBlock: aBlock;                 yourself);           shortcut: aCharacter;           title: aString;           yourself)paddingRight  ^self brick paddingRightpane: aPane  pane := aPanetestSimpleNestedSuspendParticularAnnouncementWhile  | announcement |  announcer when: GLMTestAnnouncement do: [:ann |  announcement := ann ].  announcement := nil.  announcer suspendAll: {GLMTestAnnouncement} while: [ announcer suspendAll: {} while: [  ].        announcer announce: GLMTestAnnouncement ].  self assert: announcement isNiltestInitializeBlockSetsTextSelectionForScriptPresentation  self checkInitializeBlockSetsTextSelectionForPresentation: #pharoScriptcustomValidation  ^customValidationtestSimpleCreation  self assert: tabs pages size equals: 2from: aPaneSymbol port: aPortSymbol  ^self from: (GLMPortIdentifier pane: aPaneSymbol port: aPortSymbol)privateAddBrick: aBrick before: otherBrick  | brick link otherLink otherLinkPredeccessor index |  brick := aBrick asBrick.  otherLink := otherBrick brickDoubleLink.  otherLink = self firstSubbrick brickDoubleLink ifTrue: [ ^self privateAddBrickFirst: aBrick ].  link := brick asDoubleLink.  brick brickDoubleLink: link.  otherLinkPredeccessor := otherLink previousLink.  otherLink previousLink: link.  link nextLink: otherLink.  link previousLink: otherLinkPredeccessor.  otherLinkPredeccessor nextLink: link.  index := (self subbricks indexOf: otherBrick) max: 1.  self privateSubbricks: (self subbricks copyReplaceFrom: index to: index - 1 with: (Array with: brick)).  brick owner: self.  ^aBrickbuttonForTag: each filter: filter  ^(GLMMorphic togglingButtonLabelled: each pressed: (self shouldFilterByTag: filter) style: self glamourPresentation tagsStyle)     target: self;     actionSelector: #toggleFilteringByTag:;     arguments: (Array with: filter);     yourselftestOnePanePush  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self assert: pagerModel size equals: 1.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 1.  self assert: pagerModel numberOfVisiblePages equals: 2render: aMorphPresentation  aMorphPresentation when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  ^scrollPane := self scrollMorphFor: (self morphFrom: aMorphPresentation)searchOn: aBlock  searchBlock := aBlockbeActive  active := truedataFromPresentationItem: anItem  ^anItemactOnVariableBindingsUpdated: ann  textModel variableBindings: nil.  textModel appendVariableBinding: ann presentation variableBindings.  textMorph shoutStyler style: textMorph textpause  process ifNotNil: [ process suspend ]hoverAction: anObject  hoverAction := anObjectrubricBackgroundColor: aColor  self setProperty: #brickRubricBackgroundColor toValue: aColor.  self updateStyleheight: anInteger  self brickBounds: (self brickBounds withHeight: anInteger)addPaneFromInner: aPort  | newPane lastActive |  lastActive := self panes isEmpty ifTrue: [ nil ] ifFalse: [ self lastActivePresentation ].  newPane := GLMPane named: (self panes size + 1) asString in: self.  newPane lastActivePresentation: lastActive.  self panes addLast: newPane.  self newTransmission     addActiveOrigin: aPort;     destination: (newPane port: #entity);     transmitnewLabelBrick: aStringOrBrick  ^GLMTabLabelBrick new     label: aStringOrBrick;     when: #onClicked send: #onTabClicked:with: to: self;     tabSelector: self;     vSpaceFillactOnPaneRemoved: ann  self subclassResponsibilityisHorizontal  ^isHorizontal ifNil: [ isHorizontal := true ]elementShouldBeDisplayed: anObject  | elementTags |  self tagsToFilterBy ifEmpty: [ ^true ].  elementTags := self glamourPresentation tagsFor: anObject to: #filter.  ^self tagsToFilterBy allSatisfy: [:each |  elementTags includes: each ]testRightFloatingMySelfDependency  | root floating brick |  floating := #right.  root := self newBrickWithStaticExtent.  brick := self newBrickWithSmallStaticExtent.  brick layout floating: floating.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticSmallExtent.  self assert: brick brickBounds equals: ((self staticWidth - self staticSmallWidth) @ 0 extent: self staticSmallExtent)addRow: aBlockOrSymbol span: anInteger  ^(self addRow: aBlockOrSymbol) span: anIntegerdynamicActionsOnSelection  (selectionDynamicActionsBlock isNil or: [ self selection isNil ]) ifTrue: [ ^OrderedCollection new ].  ^selectionDynamicActionsBlock glamourValue: selfpreviewPaneStyleFor: aMorph  aMorph borderColor: Color lightGraytestShrinkInShrinkChange  | root brick1 brick2 |  root := self newBrickWithFullDependsOnChildren.  brick1 := self newBrickWithFullDependsOnChildren.  brick2 := self newBrickWithSmallStaticExtent.  root addBrickBack: brick1.  brick1 addBrickBack: brick2.  self assertAllSubbricksAreClean: root.  self assert: root brickBounds equals: (0 @ 0 extent: self staticSmallExtent).  brick2     width: self staticWidth;     height: self staticHeight.  self assert: root brickBounds equals: (0 @ 0 extent: self staticExtent)elements  ^elements ifNil: [ elements := self calculateElements ]pagerModel  ^pagerModelports: anObject  ports := anObjectapproximateBandHeight  | visible averageItemHeight |  visible := self scrollPane band submorphs select: [:each |  self scrollPane isPartiallyVisible: each ].  visible isEmpty ifTrue: [ ^0 ].  averageItemHeight := (visible inject: 0 into: [:visibleHeight :each |  visibleHeight + each height ]) / visible size.  ^self scrollPane model count * averageItemHeightisFilterable  ^self parameters at: 'isFilterable' ifAbsent: [ false ]styledLogic  ^self valueOfProperty: #phlowStyled ifAbsent: [ #yourself ]adjustPaneHeight  transform bounds: self innerBounds.  transform submorphsDo: [:m |  m bounds: (m bounds withHeight: self paneHeight) ]elementShouldBeDisplayed: anObject  | elementTags |  self tagsToFilterBy ifEmpty: [ ^true ].  elementTags := self glamourPresentation tagsFor: anObject to: #filter.  ^self tagsToFilterBy allSatisfy: [:each |  elementTags includes: each ]notifyFocusedPageChanged  self notifyAll: GLMFocusedPageChanged newinitialize  super initialize.  percent := self defaultPercenttext  ^textneedsStep  ^doStep ifNil: [ doStep := true ]stepTime: anInteger  stepTime := anIntegerscrollToRight: isSmooth  self scrollTo: 1.0 smooth: isSmoothtext  ^textpage  ^pagestartOn: anObject  self entity: anObjecttestMaxWidthOneStatic  | brick |  brick := self newBrickWithStaticExtent.  brick maxWidth: self staticSmallWidth.  brick doLayoutForce.  self assertAllSubbricksAreClean: brick.  self assert: brick brickBounds equals: (0 @ 0 extent: self staticSmallWidth @ self staticHeight)width: anObject  self hSpaceFill.  super width: anObjectnewDataSourceMatching: aFTFilter  ^(super newDataSourceMatching: aFTFilter)     glamourPresentation: self glamourPresentation;     yourselfnewRubricMorph  ^super newRubricMorph     beReadOnly;     withoutAnyDecoratorvSpaceFill: anInteger  super vSpaceFill: anInteger.  self label vSpaceFill.  self dotsBrick vSpaceFillallMenuActions  ^self glamourPresentation allSelectionActions select: #hasTitleinvalidateMorphBounds  self invalidateMorphBounds: falsetestTypeOfSingleSelection  | composer firstTreeMorph treeNodeMorph |  composer := GLMCompositePresentation new.  composer list.  window := composer openOn: {{1} asSet}.  firstTreeMorph := self find: MorphTreeMorph in: window.  treeNodeMorph := firstTreeMorph scroller submorphs first.  self send: firstTreeMorph mouseUpOnItem: treeNodeMorph.  self assert: composer selection equals: {1} asSetrenderGlamorouslyOn: aRenderer  ^aRenderer renderExpander: selfselectSilently: anIndex  self changed: #selectionasFormValue  ^self id -> self isCheckedtestNoDuplicateRegistrationOfAnnouncementsOnDataSource  | table amountOfMenuItemSelectedSubscriptions |  window := GLMCompositePresentation new     with: [:c |  c fastList selectionAct: [ 42 inspect ] entitled: 'Answer' ];     openOn: (1 to: 42).  table := self find: FTTableMorph in: window.  amountOfMenuItemSelectedSubscriptions := table dataSource announcer subscriptions subscriptions count: [:each |  each announcementClass = GLMMenuItemSelected ].  self assert: amountOfMenuItemSelectedSubscriptions equals: 1updatePageIndex: index  | p oldPage |  index = 0 ifTrue: [ ^self ].  oldPage := self tabSelectorMorph selectedTab.  p := self pageMorph.  p ifNil: [ self contentMorph addMorph: (self pageAt: index) ] ifNotNil: [ | pageBounds |        pageBounds := self pageMorph bounds.        self contentMorph replaceSubmorph: p by: (self pageAt: index).        self flag: 'Without setting here the bounds the pange moves a few pizels when refreshing the inspector'.        self pageMorph bounds: pageBounds.        self pageMorph layoutChanged ].  ((self pages at: index) toolbar notNil and: [ (self pages at: index) toolbar hasSubmorphs ]) ifTrue: [ self toolbarMorph hasSubmorphs ifFalse: [ self toolbarMorph addMorph: (self pages at: index) toolbar ] ifTrue: [ self toolbarMorph replaceSubmorph: self toolbarMorph submorphs first by: (self pages at: index) toolbar ] ] ifFalse: [ self toolbarMorph removeAllMorphs ].  self headerMorph layoutChanged.  self pageMorph layoutChanged.  self adoptPaneColor: (self owner ifNil: [ self ]) paneColor.  (self tabSelectorMorph tabs at: index) font: self tabSelectorMorph font.  self announcer announce: (LazyTabPageChanged new           tabs: self;           page: (self pages at: index);           oldPage: oldPage;           pageIndex: index)allMenuActions  ^self glamourPresentation allSelectionActions select: #hasTitletextBackgroundColor: aBlockOrAColor  textBackgroundColor := aBlockOrAColorpagerModel: aModel  pagerModel := aModel.  self pagerModel announcer when: GLMPageSwitched send: #onPageSwitched to: self.  self pagerModel announcer when: GLMPagerBoundsChanged send: #onScrollBoundsChanged: to: self.  self pagerModel announcer when: GLMFocusedPageChanged send: #onFocusedPageChanged to: self.  self updateButtonsadd: aPresentation  self pane notingPresentationChangeDo: [ self presentations add: aPresentation.        aPresentation pane: self pane ].  ^aPresentationparameters  ^parametersmarkDirtyChildrenAround: aBrick inContext: aContextBrick  aBrick subbricks do: [:each |  each = aContextBrick ifFalse: [ each isBrick ifTrue: [ (self isClean: each) ifTrue: [ self markDirty: each.                          self markDirtyAround: each inContext: aBrick ] ] ] ]initialize  super initialize.  presentationTransformation := [:aComposite :each |  aComposite custom: each ]initialize  super initialize.  focused := falserecomputeState: isSmooth  | tmpNumberOfVisiblePages notifyNumberOfVisiblePagesChanged |  notifyNumberOfVisiblePagesChanged := false.  self invariant.  virtualFirstVisiblePageIndex isNil & virtualLastVisiblePageIndex isNil ifTrue: [ ^self ].  virtualFirstVisiblePageIndex ifNil: [ virtualFirstVisiblePageIndex := self firstVisiblePageIndex ].  virtualLastVisiblePageIndex ifNil: [ virtualLastVisiblePageIndex := self lastVisiblePageIndex ].  tmpNumberOfVisiblePages := virtualLastVisiblePageIndex - virtualFirstVisiblePageIndex + 1.  tmpNumberOfVisiblePages = numberOfVisiblePages ifFalse: [ notifyNumberOfVisiblePagesChanged := true ].  numberOfVisiblePages := tmpNumberOfVisiblePages.  firstVisiblePageIndex := virtualFirstVisiblePageIndex.  lastVisiblePageIndex := virtualLastVisiblePageIndex.  self invariant.  virtualFirstVisiblePageIndex = nil.  virtualLastVisiblePageIndex = nil.  notifyNumberOfVisiblePagesChanged ifTrue: [ self notifyNumberOfVisiblePagesChanged ].  self notifyScrollPositionChanged: isSmoothfromOutside: aPortSymbol  self deprecated: 'Use fromOutsidePort: instead'.  ^self fromOutsidePort: aPortSymboltest100FillBricksInsideEachOtherIndideStatic  | root current |  root := self newBrickWithStaticExtent.  current := root.  1 to: 100 do: [:index |  current := current addBrickBack: self newBrickWithFullFill ].  self assertAllSubbricksAreClean: root.  self assert: current extent equals: root extentmorphicPopulate: aPortSymbol icon: anIcon on: aCharacter entitled: aString with: aBlock  self addAction: (GLMMorphicAction new           action: (GLMPortUpdater new                 portSymbol: aPortSymbol;                 valueBlock: aBlock;                 yourself);           shortcut: aCharacter;           icon: anIcon;           title: aString;           yourself)innerBounds  | rect |  rect := super innerBounds.  ^self scrollBarIsVisible ifTrue: [ rect withHeight: rect height - self scrollBarHeight - 1 ] ifFalse: [ rect ]vertices  ^verticesvalue  ^self transformation ifNil: [ self port value ] ifNotNil: [ self transformation value: self port value ]marginTop  ^self margin at: TopfilterOn: aBlock  self error: 'This presentation does not allow filtering with a block for now. In the futur we should have a new filter with FastTable to do that. If you want to give it a try look FTFunction and his subclasses.'outerOrigin: aPoint  ^self brick wrappedBounds outerOrigin: aPointcollectionToDragPassenger: aCollection  ^aCollection size = 1 ifTrue: [ aCollection anyOne ] ifFalse: [ aCollection ]addBrickBack: aBrick  self brickRoot addBrickBack: aBrickfocusedBorderWidth  ^1variableBindings  ^variableBindings ifNil: [ variableBindings := Dictionary new ]setUp  super setUp.  layouter := GLMBrickLayouter newcalculateElements  ^self tagsToFilterBy ifEmpty: [ self basicElements ] ifNotEmpty: [ self basicElements select: [:each |  self elementShouldBeDisplayed: each ] ]initialize  super initialize.  predicates := OrderedCollection newtheme  ^Smalltalk ui themeband: aBrick  band := aBrick.  band     useHorizontalLinearLayout;     layoutMorphs: true;     width: [ self band subbricksCount * self width / ((self maxPanes min: self band subbricksCount) max: 1) ];     vSpaceFill.  band layout widthDependency: self.  self addBrickBack: banddo: aBlock  ^collection do: aBlocktestSimpleOpen  | p |  p := GLMCompositePresentation new.  p tabulator with: [:b |  b row: #one.        b transmit           to: #one;           andShow: [:a |  a text ] ].  window := p openOn: 42.  self assert: (window isKindOf: GLMSystemWindow)isCentered  ^isCentered ifNil: [ isCentered := false ]linear  self step: [:b :from :to :delta |  (to - from) * delta + from ]testEntityInUpdateAction  | browser inputFromActionBlock |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a text populate: #foo on: $m with: [:list :input |  inputFromActionBlock := input ] ].  browser startOn: 42.  browser panes first presentations first actions first actOn: browser panes first presentations first.  self assert: inputFromActionBlock equals: 42accept: passengerObject droppedOnItem: anItem  self dropOnItemBlock glamourValue: (GLMMultiValue with: passengerObject with: anItem with: self).  ^truecopySelection  self announce: (GLMTextEditorRequest for: #copySelection)length  ^length valuelabel: aBlock  aBlock cull: self labelcondition: anObject  condition := anObjectlastActivePresentation: aPresentation  selectionActions  ^selectionActions ifNil: [ selectionActions := OrderedCollection new ]markDirty: aBrick  ^self subclassResponsibilityhSpaceFill  hResizing := #spaceFill.  self hResizing: #spaceFilltestWatcherCreation  | browser |  browser := GLMBrowser new.  self assert: browser watcherPane name equals: #_watcher.  (browser watcherPane port: #entity) value: 42.  self assert: (browser watcherPane port: #entity) value equals: 42openFromRubric: aMorph withResult: anObject  | string |  string := anObject printString.  self withString: string from: aMorph.  self width: self width + inspectButton width.  textMorph textArea on: $i meta do: [ anObject inspect ].  textMorph textArea on: Character cr asKeyCombination do: [ self delete.        aMorph textArea removeHighlightSegment.        aMorph editor atEndOfLineInsertAndSelect: string asComment.        aMorph takeKeyboardFocus ].  textMorph textArea on: $p meta do: [ self delete.        aMorph textArea removeHighlightSegment.        aMorph editor atEndOfLineInsertAndSelect: string.        aMorph takeKeyboardFocus ].  inspectButton addUpAction: [ anObject inspect ].  self openInWorldtitleBrick: aBrick  titleBrick := aBrick.  self titleBrick textColor: self themer popupThemer textColor.  self contentBrick addBrickFirst: self titleBricktestStatusbar  | browser |  browser := GLMTabulator withStatusbar.  browser row: #one.  browser transmit     to: #one;     andShow: [:a |  a list display: #(1 2 3) ].  self assert: browser transmissions size equals: 2.  browser startOn: 42childrenValueOf: anObject  self flag: 'this is rather hackish, but needed to treat list and tree in the same way.'.  ^OrderedCollection newlabel  ^stringBrickinstallDefaultSelectionActions  self defaultSelectionActions do: [:anAction |  self addSelectionAction: anAction ]path  ^self pathIn: OrderedCollection newopen: aBlock on: aCharacter entitled: aString  self addAction: (GLMGenericAction new           action: aBlock;           shortcut: aCharacter;           title: aString;           yourself)testUnregisterAnnouncementsWhenUpdatingPaneWithTwoAnnouncers  | announcer browser announcer2 |  announcer := Announcer new.  announcer2 := Announcer new.  browser := GLMTabulator new.  browser row: #one.  browser transmit     to: #one;     andShow: [:presenter |  presenter list           updateOn: GLMTestAnnouncement fromAll: [ {announcer .               nil .               announcer2} ];           display: [:start |  start to: 10 ] ].  browser startOn: 1.  browser panes first presentations first registerAnnouncements.  browser unregisterFromAllAnnouncements.  self assert: announcer numberOfSubscriptions equals: 0.  self assert: announcer2 numberOfSubscriptions equals: 0label  ^labelBrickpresentation: aPresentation  presentation := aPresentationreplaceBoxes  labelArea removeAllMorphs.  self setLabelWidgetAllowance.  self theme configureWatcherWindowLabelAreaFor: self.  self setFramesForLabelArea.  self isActive ifFalse: [ labelArea passivate ]send: aBlock  self selectionTransformation: aBlockicon  ^nilcomputeScrollValue: aNumber  | newValue delta |  delta := self owner width - self width.  newValue := (aNumber max: 0) min: delta.  ^delta = 0 ifTrue: [ 0 ] ifFalse: [ newValue / delta ]initializeNamed: aString in: aBrowser  self initialize.  name := aString ifNil: [ self defaultName ].  browser := aBrowserhasWidthRestrictions: aBrick  ^aBrick layout hasMinWidth or: [ aBrick layout hasMaxWidth ]vSpaceFill: anInteger  super vSpaceFill: anInteger.  self labelBrick vSpaceFill.  self editBrick vSpaceFilltestPageRemovedAnnouncement  | announcement |  announcement := 0.  tabs announcer when: LazyTabPageRemoved do: [:ann |  announcement := announcement + 1 ].  tabs announcer when: LazyTabPageChanged do: [:ann |  announcement := announcement + 1 ].  tabs removePage: tabs pages first.  self assert: announcement equals: 1mouseMove: evt  isRightResizing ifTrue: [ self dragResizingRight: evt ] ifFalse: [ isLeftResizing ifTrue: [ self dragResizingLeft: evt ] ifFalse: [ self dragSliding: evt ] ]row: aBlockOrSymbol size: anInteger  ^self addRow: aBlockOrSymbol size: anIntegerinitializeWidgets  scrollPageUp  self     scrollUp: self height;     update;     changedcolumns  self flag: 'this is rather hackish, but needed to treat list and tree in the same way.'.  ^OrderedCollection newextent: aPoint  | left top right bottom |  super extent: aPoint.  left := self brickRoot marginLeft.  top := self brickRoot marginTop.  right := self extent x - self brickRoot marginRight.  bottom := self extent y - self brickRoot marginBottom.  self isHFilling ifTrue: [ self brickRoot width: right - left ].  self isVFilling ifTrue: [ self brickRoot height: bottom - top ].  self brickRoot wrappedBounds bounds: (left @ top corner: right @ bottom).  self brickRoot doLayoutForceupdateHeight: aBrick on: aLayout  width: anObject  hState := self hState onMyselfDo: [:s |  s dimension: anObject ]actionBlock  ^self parameters at: 'actionBlock'rubricTextFamilyName: aString  self setProperty: #brickRubricTextFamilyName toValue: aString.  self updateStyleinitializeScriptingDefaults  ^selfmarginTop  ^self wrappedBounds marginTophasIcon  ^self icon notNilhasFilterBlock  ^self parameters at: 'filterBlock' ifPresent: [ true ] ifAbsent: [ false ]forbid: aPane toAnnounce: anAnnouncement  (self forbiddenAnnouncements at: aPane ifAbsentPut: [ Set new ]) add: anAnnouncementemerald  ^Color brickColorRegistry at: #brickEmerald ifAbsentPut: [ Color r: 46 g: 204 b: 113 range: 255 ]hSpaceFill: anInteger  < brickBuilderProperty: #Layout name: 'Horizontal percent' as: #asInteger getter: #hPercent model: #GLMUIBuilderTextFieldProperty>  self layout hSpaceFill: anIntegerid  ^id ifNil: [ #anonymous ]selectLine  self announce: GLMSelectCurrentLineparameter  ^parametermorphAt: anInteger convert: aMorph  ^morphLogic ifNil: [ (origin at: anInteger) asMorph ] ifNotNil: [ morphLogic isSymbol ifTrue: [ origin perform: morphLogic withEnoughArguments: {anInteger .                     aMorph} ] ifFalse: [ morphLogic cull: anInteger cull: aMorph ] ]privateFullBounds  ^self fullBoundsvSpaceFill  vResizing := #spaceFillbeNormal  self beMode: #beNormalcancelOnEscape  cancelOnEscape := truemorphicSelectionAct: aBlock icon: anIcon on: aCharacter entitled: aString  self addSelectionAction: (GLMMorphicAction new           action: aBlock;           shortcut: aCharacter;           icon: anIcon;           title: aString;           yourself)privateAddAllBricks: aCollection  | bricks |  bricks := aCollection collect: #asBrick.  bricks do: [:each |  self privateAddBrickLinkBack: each ].  self privateSubbricks: self subbricks , bricks.  ^bricksexplicitSelection: anObject  self table selectIndex: (self elements indexOf: anObject)renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderLabelPresentation: selftestTransmissionTriggeredAnnounced  | browser announcements pane1 pane2 transmission |  announcements := OrderedCollection new.  browser := GLMBrowser new.  pane1 := GLMPane new.  pane2 := GLMPane new.  browser addPane: pane1.  browser addPane: pane2.  transmission := GLMTransmission new.  transmission addActiveOrigin: (pane1 port: #origin).  transmission destination: (pane2 port: #destination).  browser addTransmission: transmission.  browser when: GLMTransmissionTriggered do: [:ann |  announcements add: ann ].  self assertEmpty: announcements.  transmission transmit.  self assert: announcements size equals: 1withoutBackground  self rubric color: Color transparentspan  ^span ifNil: [ span := 1 ]removeBrick: aBrick  self brickRoot removeBrick: aBricklayout: aBrick in: aRectangle inject: anInteger into: aBlock  aBrick subbricks inject: anInteger into: [:origin :each |  | result |        result := origin + ((self isFloating: each) ifFalse: [ aBlock cull: origin cull: each ] ifTrue: [ self layoutFloating: each in: aRectangle ]).        self align: each in: aBrick anchorPoint: origin inContext: nil.        each onLayouted.        result ]withLineNumbers: aBoolean  withLineNumbers := aBooleanwithStyler  self textArea withDecorator: self stylerDecoratorlength: aNumber  self assert: [ aNumber >= 0 ] description: [ 'Length must be non-negative' ].  length := aNumbertransmissionStrategy  ^transmissionStrategyonThemerChanged  | aThemer |  super onThemerChanged.  aThemer := self themer popupThemer.  self color: aThemer backgroundColor.  self borderWidth: aThemer borderWidth.  self borderColor: aThemer borderColor.  self inset: aThemer inset.  self spacing: aThemer spacing.  self shadowWidth: aThemer shadowWidth.  self shadowColor: aThemer shadowColor.  self shadowOffset: aThemer shadowOffset.  self shadowInset: aThemer shadowInset.  self contentBrick padding: aThemer contentPadding.  self contentBrick color: aThemer contentBackgroundColor.  self updateTriggerBrickorigin: aPoint length: aLength breadth: aBreadth  ^self subclassResponsibilityinitialize  super initialize.  textLogic := [:x |  x ]announce: anAnnouncement  self announcer announce: anAnnouncementdoLayoutIn: layoutBounds  initializeScrollbar  scrollBar := ScrollBar new     model: self;     setValueSelector: #scrollBarValue:;     yourself.  scrollBar     borderWidth: 0;     borderColor: #inset;     height: self scrollBarHeight.  self resizeScrollBarasyncTask: anObject  asyncTask := anObjecthelp: aString  help := aStringremoveLast  collection removeLast.  self announce: GLMItemRemovedtopRightCornerShadowOf: aBrick on: aCanvas  | gradient width origin offset |  width := aBrick shadowWidth.  offset := (width @ width) negated / 2.0.  origin := aBrick brickBounds topRight + offset + aBrick shadowOffset.  gradient := (self shadowGradientFor: aBrick)     origin: origin + (0 @ width);     direction: width @ width negated / 1.4;     radial: true;     yourself.  aCanvas fillRectangle: (origin extent: width @ width) fillStyle: gradientposition  ^positionisEditMode  ^self hasSubbrick: self editBrickmenuColumn: column row: rowIndex  | menu subMenus targetMenuMorph subMenu |  menu := UIManager default newMenuIn: self table for: self.  subMenus := Dictionary new.  self allMenuActions do: [:action |  targetMenuMorph := action category notNil ifTrue: [ subMenus at: action category ifAbsentPut: [ subMenu := MenuMorph new.                    menu add: action category subMenu: subMenu.                    subMenu ] ] ifFalse: [ menu ].        (targetMenuMorph add: action title target: self selector: #executeMenuAction: argument: action)           icon: action icon;           balloonText: action help;           enabled: (action isEnabledOn: self glamourPresentation);           keyText: (action hasShortcut ifTrue: [ action shortcutAsString ] ifFalse: [ nil ]) ].  ^menuisDragSource  ^self dropOnItemBlock notNilallowsInput  ^self allowsFilter or: [ self allowsSearch ]newFirstTransmission  ^firstTransmission ifNil: [ self newTransmission ] ifNotNil: [ self firstTransmission copy ]minimumPageNumberForScrollbar  ^minimumPageNumberForScrollbar ifNil: [ 1 ]addPresentationSilently: each  ^presentations add: (each           pane: self;           yourself)doItContext  ^doItContext glamourValue: self entitymarginLeft: anObject  < brickBuilderProperty: #Geometry name: 'Margin Left' as: #asInteger getter: #marginLeft model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds marginLeft: anObjectbrowser  ^browserrenderGlamorouslyOn: aRenderer  self subclassResponsibilitypaneHeight  ^transform bounds heightwhen: anAnnouncementClass do: aBlock  self announcer when: anAnnouncementClass do: aBlockpopupActOn: aPresentation from: aButton  GLMPopupActionBrick new     closer: (GLMPopupBrickCloser predicate: GLMPopupBrickOutisideClickPredicate new);     onCreated: [:popup |  self action glamourValueWithArgs: (Array with: aPresentation withAll: {aPresentation entity .                     popup}) ];     openOn: aButton;     beRightToLeftWithOffset: 0registerEventsForPresentation: aPresentation  aPresentation when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  aPresentation when: GLMContextChanged send: #actOnContextChanged: to: self.  aPresentation when: GLMTextEditorRequest send: #actOnTextEditorRequest: to: selfinitialize  super initialize.  parameters := Dictionary newbuttonBorderWidth  ^1markDirtyAround: aBrick inContext: aContextBrick  aBrick isBrick ifFalse: [ ^self ].  aBrick = aContextBrick ifTrue: [ ^self ].  aBrick owner ifNotNil: [ (aBrick owner = aContextBrick) not & aBrick owner isBrick ifTrue: [ (self isClean: aBrick owner) ifTrue: [ (self isDependsOnChildren: aBrick owner) ifTrue: [ self markDirty: aBrick owner.                          self markDirtyAround: aBrick owner inContext: aBrick ].                    (self isDependsOnMyself: aBrick) | (self isDependsOnChildren: aBrick) ifTrue: [ (aBrick owner subbricks anySatisfy: [:each |  self isDependsOnParent: each ]) ifTrue: [ self markDirty: aBrick owner.                                self markDirtyChildrenAround: aBrick owner inContext: aBrick ] ].                    (self isClean: aBrick owner) ifTrue: [ (aBrick layout floating = #none) not | (aBrick layout vAlign = #none) not | (aBrick layout hAlign = #none) not ifTrue: [ self markLayoutDirty: aBrick owner ] ] ] ] ].  aBrick subbricks do: [:each |  each = aContextBrick ifFalse: [ each isBrick ifTrue: [ (self isDependsOnParent: each) & (self isClean: each) | (each layout floating = #none) not | (each layout vAlign = #none) not | (each layout hAlign = #none) not ifTrue: [ self markDirty: each.                          self markDirtyAround: each inContext: aBrick ] ] ] ].  self markDirtyCustomDependency: aBrick inContext: aContextBrick.  aBrick subbricks do: [:each |  self markDirtyCustomDependency: each inContext: aBrick ]hash  ^super hashpresentationTransformation  ^presentationTransformationdynamicActions  dynamicActionsBlock ifNil: [ ^OrderedCollection new ].  ^dynamicActionsBlock glamourValue: selfpopupHelpThemer  ^self registerModule: GLMBrickPopupHelpThemer new to: self named: #popupThemeraddLazyPage: aBlock label: aStringOrMorph toolbar: aToolbar action: anActionMorphOrNil  | newPage label |  newPage := LazyTabPage new.  newPage     lazyPageMorphCreation: aBlock;     labelMorph: aStringOrMorph;     toolbar: aToolbar.  label := self buildLabelFrom: aStringOrMorph withAction: anActionMorphOrNil.  self addPage: newPage label: labelstrongSelection: ann  self announcer announce: (GLMTreeMorphStrongSelectionChanged new           strongSelectionValue: (self elementAt: ann selectedIndex) data;           yourself)paddingTop: anObject  < brickBuilderProperty: #Geometry name: 'Padding Top' as: #asInteger getter: #paddingTop model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds paddingTop: anObjecthasUnacceptedEdits  self announce: (GLMTextEditorRequest new action: [:anEditor |  ^anEditor model hasUnacceptedEdits ])selection: ann  | selection |  selection := ann newSelectedIndexes select: [:each |  each ~= 0 ] thenCollect: [:each |  self elementAt: each ].  selection ifNotEmpty: [ self announcer announce: (GLMTreeMorphSelectionChanged new                 selectionValue: ((selection size = 1 and: [ self glamourPresentation isSingle ]) ifTrue: [ selection first ] ifFalse: [ selection ]);                 selectionPathValue: selection;                 yourself) ]allKeystrokeActions  ^self model notNil ifTrue: [ self model allActions , self model allSelectionActions select: [:action |  action hasShortcut ] ] ifFalse: [ #() ]act: aBlock iconName: aSymbol entitled: aString  self act: aBlock icon: (self iconNamed: aSymbol) entitled: aStringtestPageChangedAnnouncement  | announcement page |  announcement := 0.  tabs announcer when: LazyTabPageChanged do: [:ann |  announcement := announcement + 1.        page := ann page ].  tabs selectedPageIndex: 1.  self assert: announcement equals: 1.  self assert: (page isKindOf: LazyTabPage)initialize  super initialize.  self beHelp.  self unhoverAction: [:aBrick :anEvent |  (aBrick globalBounds containsPoint: anEvent position) ifFalse: [ self closePopup ] ]tagsFilterBlock  ^tagsFilterBlocktransformDraggedItemBlock  ^transformDraggedItemBlocktestRightMarginMyselfDependency  | root margin brick |  margin := 10.  root := self newBrickWithStaticExtent.  brick := self newBrickWithSmallStaticExtent.  brick marginRight: margin.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticSmallExtent.  self assert: brick brickBounds equals: (0 @ 0 extent: self staticSmallExtent)paddingTop: anInteger  self padding at: Top put: anInteger.  self updateCachetestAnnouncement  | pane presentation announcement |  pane := GLMPane named: 'test'.  presentation := GLMPresentation new.  pane addPresentation: presentation.  announcement := nil.  presentation when: GLMContextChanged do: [:ann |  announcement := ann ].  (pane port: #entity) value: 42.  self assert: announcement notNil.  self assert: announcement property equals: #entity.  self assert: announcement value equals: 42scrollMorphFor: aMorph  ^GeneralScrollPane new     changeScrollerTableLayout;     scrollTarget: aMorph;     layoutFrame: (LayoutFrame identity topOffset: 25);     yourselfinitialize  super initialize.  isLayouting := falselabelBrick: anObject  labelBrick := anObject.  labelBrick     vAlign: #center;     marginLeft: 5;     textPosition: #leftCentertoString: anObject  ^self glamourPresentation hasFilterBlock ifTrue: [ anObject ] ifFalse: [ super toString: anObject ]shadowInset  ^self valueOfProperty: #brickShadowInset ifAbsentPut: [ 0 ]entity  ^(self pane port: #entity) valueisEnabledOn: aPresentation  ^self enabledCondition glamourValueWithArgs: (Array with: aPresentation withAll: aPresentation entity asGlamorousArray)zIndex  ^zIndex ifNil: [ zIndex := 1 ]handlesMouseOverDragging: evt  ^trueanchorBrick: aBrick  anchorBrick := aBrick.  self updateTriggerBricksetNotFocused  focused ifTrue: [ self checkedImage: checkedIcon.        self uncheck.        focused := false ]doValidate: anObject on: aPort  ^self customValidation isNil ifFalse: [ self customValidation glamourValue: anObject asGlamorousMultiValue , aPort name asGlamorousMultiValue , self entity asGlamorousMultiValue ] ifTrue: [ self defaultValidate: anObject on: aPort ]toOutside: aPortSymbol  self deprecated: 'Use toOutsidePort: instead'.  ^self toOutsidePort: aPortSymbollastSubbrick  ^self subbricks lastdragResizingRight: anEvent  | left right |  left := self brickBounds left.  right := anEvent position x - self owner globalBounds left - (startDragX - self computeWidth).  right := (right max: left + self pagerModel circleButtonSize) min: self owner width.  self setPosition: left @ rightheightChildrenDependency: aBrick  ^self subclassResponsibilityassertAllSubbricksAreDirty: aBrick  aBrick withAllSubbricks do: [:each |  self assertBrickDirty: each ]tagMorphsFrom: aTagProvider for: element  | tagMorphs tags tagsFilter |  tagMorphs := OrderedCollection new.  tags := self glamourPresentation tagsFor: element fromProvider: aTagProvider to: #show.  tagsFilter := self glamourPresentation tagsFor: element fromProvider: aTagProvider to: #filter.  tags withIndexDo: [:each :index |  tagMorphs addLast: (self buttonForTag: each filter: (tagsFilter at: index ifAbsentPut: [ each ])) ].  ^tagMorphsinitializeInspectButton  inspectButton := MultistateButtonMorph new     extent: GLMUIThemeExtraIcons glamorousInspect extent;     activeEnabledOverUpFillStyle: (ImageFillStyle form: GLMUIThemeExtraIcons glamorousInspect);     setBalloonText: 'Inspect' translated.  self addMorph: inspectButton fullFrame: (LayoutFrame identity           leftFraction: 1;           bottomFraction: 0;           leftOffset: inspectButton width;           bottomOffset: 2 * inspectButton width)portName: anObject  portName := anObjectactOnPaneReplaced: ann  container popAndReplacePane: (self renderObject: ann newPane)paddingBottom  ^self brick paddingBottomtranslateYTo: anInteger  self translateY: self brickBounds top negated + anIntegertestCustomValidation  | pane presentation |  pane := GLMPane named: 'test'.  presentation := GLMPresentation new.  pane addPresentation: presentation.  presentation customValidation: [:object :aport :entity |  aport ~= #selection or: [ object = (entity last + 40) ] ].  presentation entity: (OrderedCollection with: 1 with: 2).  self assert: presentation entity last equals: 2.  self assert: (presentation validate: 42 on: (pane port: #selection))brick  ^brickbuttonPressedColor  ^Color veryVeryLightGray lighter slightlyDarker slightlyDarkerorigin: aPoint length: aLength breadth: aBreadth  ^aPoint - (aLength @ aBreadth) extent: aLength @ aBreadthmouseDown: evt  (anchorBrick containsPoint: evt cursorPoint) ifTrue: [ anchorBrick mouseDown: evt ] ifFalse: [ super mouseDown: evt ]render: aPresentation  container := GLMMorphic containerMorph.  container addMorph: (self renderObject: aPresentation currentPresentation) fullFrame: LayoutFrame identity.  aPresentation when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  ^containeractOn: anAnnouncement  | allowedToTrigger |  allowedToTrigger := self condition glamourValue: anAnnouncement asGlamorousMultiValue , self presentation entity asGlamorousMultiValue.  allowedToTrigger ifTrue: [ self presentation update ]valueOfProperty: aSymbol ifAbsent: aBlock  ^super valueOfProperty: aSymbol ifAbsent: aBlockbrickBounds: aRectangle  super brickBounds: aRectangle.  self invalidateMorphBoundsstateOf: aBrick  ^self state cull: aBrickrender: aBrick onAthensCanvas: aCanvas  self render: aBrick on: (AthensCanvasWrapper on: aCanvas)outerHeight: anInteger  self brickBounds: (self brickBounds withHeight: anInteger - self marginTop - self marginBottom)pane  ^self presentation panetestEntityPropogationAnnouncements  < expectedFailure>  | browser1 browser2 |  browser1 := GLMTabulator new     title: '1';     yourself.  browser2 := GLMTabulator new     title: '2';     yourself.  browser1 pane name: 'b1 parent pane'.  browser1 column: #'b1-pane'.  browser2 column: #'b2-pane'.  self assert: browser1 pane presentations size equals: 1.  self assert: browser1 pane presentations first identicalTo: browser1.  browser1 transmit     to: #'b1-pane';     andShow: [:a |  a custom: browser2 ].  browser2 transmit     to: #'b2-pane';     andShow: [:a |  a text ].  self assertEmpty: GLMLogger instance announcements copy.  browser1 startOn: 42.  self assert: GLMLogger instance announcements copy size equals: 12.  self assert: ((GLMLogger instance announcements copy at: 1) isKindOf: GLMContextChanged).  self assert: (GLMLogger instance announcements copy at: 1) presentation identicalTo: browser1.  self assert: (GLMLogger instance announcements copy at: 1) property equals: #entity.  self assert: (GLMLogger instance announcements copy at: 1) value equals: 42.  self assert: ((GLMLogger instance announcements copy at: 2) isKindOf: GLMPresentationsChanged).  self assert: (GLMLogger instance announcements copy at: 2) pane identicalTo: browser1 panes first.  self assertEmpty: (GLMLogger instance announcements copy at: 2) oldPresentations.  self assert: (GLMLogger instance announcements copy at: 2) presentations size equals: 1.  self assert: (GLMLogger instance announcements copy at: 2) presentations first equals: browser2.  self assert: ((GLMLogger instance announcements copy at: 3) isKindOf: GLMContextChanged).  self assert: (GLMLogger instance announcements at: 3) presentation equals: browser2.  self assert: (GLMLogger instance announcements at: 3) property equals: #entity.  self assert: (GLMLogger instance announcements at: 3) value equals: 42.  self assert: ((GLMLogger instance announcements at: 4) isKindOf: GLMPresentationsChanged).  self assert: (GLMLogger instance announcements at: 4) pane identicalTo: browser2 panes first.  self assertEmpty: (GLMLogger instance announcements at: 4) oldPresentations.  self assert: (GLMLogger instance announcements at: 4) presentations size equals: 1.  self assert: (GLMLogger instance announcements at: 4) presentations first isNil.  self assert: ((GLMLogger instance announcements at: 5) isKindOf: GLMContextChanged).  self assert: (GLMLogger instance announcements at: 5) presentation isNil.  self assert: (GLMLogger instance announcements at: 5) property equals: #entity.  self assert: (GLMLogger instance announcements at: 5) value equals: 42.  self assert: ((GLMLogger instance announcements at: 6) isKindOf: GLMMatchingPresentationsChanged).  self assert: (GLMLogger instance announcements at: 6) pane identicalTo: browser2 panes first.  self assertEmpty: (GLMLogger instance announcements at: 6) oldMatchingPresentations.  self assert: (GLMLogger instance announcements at: 6) matchingPresentations size equals: 1.  self assert: (GLMLogger instance announcements at: 6) matchingPresentations first isNil.  self assert: ((GLMLogger instance announcements at: 7) isKindOf: GLMMatchingPresentationsChanged).  self assert: (GLMLogger instance announcements at: 7) pane identicalTo: browser1 panes first.  self assertEmpty: (GLMLogger instance announcements at: 7) oldMatchingPresentations.  self assert: (GLMLogger instance announcements at: 7) matchingPresentations size equals: 1.  self assert: (GLMLogger instance announcements at: 7) matchingPresentations first identicalTo: browser2.  self assert: ((GLMLogger instance announcements at: 8) isKindOf: GLMMatchingPresentationsChanged).  self assert: (GLMLogger instance announcements at: 8) pane identicalTo: browser1 pane.  self assertEmpty: (GLMLogger instance announcements at: 8) oldMatchingPresentations.  self assert: (GLMLogger instance announcements at: 8) matchingPresentations size equals: 1.  self assert: (GLMLogger instance announcements at: 8) matchingPresentations first identicalTo: browser1theme  ^Smalltalk ui themewantsSteps  ^self model wantsStepswidth: anObject  width := anObjectcontents: aStringOrText  self text: aStringOrText asStringlastTransmission  ^self transmissions lastfullDrawOn: aCanvas  aCanvas clipRect hasPositiveExtent ifFalse: [ ^self ].  super fullDrawOn: aCanvasuncheck  self isChecked ifTrue: [ isChecked := false.        self announce: #onUnchecked.        self changed ]hasChildren: anObject  anObject ifNil: [ ^false ].  anObject isVariableBinding ifFalse: [ ^false ].  anObject value ifNil: [ ^false ].  anObject value isCollection ifTrue: [ ^anObject value isEmpty not ].  ^truetagMorphsFrom: aTagProvider  | tagMorphs tags tagsFilter |  tagMorphs := OrderedCollection new.  tags := self containerTree glamourPresentation tagsFor: self item fromProvider: aTagProvider to: #show.  tagsFilter := self containerTree glamourPresentation tagsFor: self item fromProvider: aTagProvider to: #filter.  tags withIndexDo: [:each :index |  tagMorphs addLast: (self buttonForTag: each filter: (tagsFilter at: index ifAbsentPut: [ each ])) ].  ^tagMorphsforSmalltalk: aBlock  highlightSmalltalk := true.  highlightSmalltalkContext := aBlockrootPrototype  ^self parentPrototype ifNil: [ self ] ifNotNil: [ self parentPrototype rootPrototype ]execute  ^self execute: self argumentstestPresentationBoundPort  | presentation port |  presentation := GLMPresentation new.  port := GLMPresentationBoundPort new     name: #port;     presentation: presentation.  port value: 42.  self assert: (presentation pane port: #port) value equals: 42.  (presentation pane port: #port) value: 43.  self assert: port value equals: 43focusChanged: anEvent  | pageIndex newFocus |  newFocus := anEvent morph.  currentFocus = newFocus ifFalse: [ currentFocus := newFocus.        pageIndex := self pageOf: newFocus.        pageIndex > 0 ifTrue: [ pagerModel focusedMorphChanged: newFocus at: pageIndex ] ]dataCacheFor: anElement  ^self dataCache at: anElement ifAbsentPut: [ Dictionary new ]model: anObject  model := anObjectresult  ^resultisFitsInParent  ^self owner ifNotNil: [ self owner globalBounds containsRect: self globalBounds ] ifNil: [ self owner ifNotNil: [ self owner bounds containsRect: self globalBounds ] ifNil: [ ^true ] ]renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderTablePresentation: selfactOnContextChanged: anAnnouncement  anAnnouncement property = #selection ifTrue: [ tableModel announcer suspendAll: self suspendedAnnouncements while: [ tableModel explicitSelection: anAnnouncement value ] ]paneName: anObject  paneName := anObjectcreateDataSourceFrom: aPresentation  ^GLMFastTableDataSource newshadowInset  ^0resizeColumns  | rowMorphsWidths |  self columns size > 1 ifFalse: [ ^self ].  rowMorphsWidths := self rowMorphsWidths.  self allNodeMorphs do: [:node |  node submorphs doWithIndex: [:each :index |  each                 hResizing: #rigid;                 width: (rowMorphsWidths at: index) ] ].  self hHideScrollBarshrinkingHeight  ^self morph heighttestNestedSuspendAllWhile  | announcement |  announcer when: GLMTestAnnouncement do: [:ann |  announcement := ann ].  announcement := nil.  announcer suspendAllWhile: [ announcer suspendAllWhile: [  ].        announcer announce: GLMTestAnnouncement ].  self assert: announcement isNilrenderWithExpanders: aBrowser  | morph scroll panel expander |  panel := GLMPanelMorph new.  panel     fillStyle: Color transparent;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     changeTableLayout;     layoutInset: 2;     cellInset: 2.  scroll := GeneralScrollPane new.  scroll     changeScrollerTableLayout;     scrollTarget: panel.  aBrowser panes do: [:each |  expander := ExpanderMorph titleText: (each presentations titleValue ifNil: [ 'noname' ]).        morph := GLMMorphicPaneWithoutTitleRenderer new render: each.        morph borderStyle: (UITheme current buttonSelectedBorderStyleFor: morph).        expander addMorphBack: morph.        panel addMorph: expander ].  ^scrollinvalidateWith: aBlock  aBlock cull: self.  self doLayoutForceoutOfWorld: aWorld  super outOfWorld: aWorld.  self unsubscribeListenersportChangeActions: anObject  portChangeActions := anObjectmodel  ^adaptorwantsDropElements: aCollection type: type index: rowIndex  ^(aCollection isEmptyOrNil or: [ type ~= self dragTransferType ]) ifFalse: [ self glamourPresentation allow: (self collectionToDragPassenger: aCollection) droppedOnItem: (self elementOrZeroAt: rowIndex) ] ifTrue: [ false ]allowDeselection  self allowsDeselection: truefromPrevious: aPortSymbol  self flag: 'needs revisiting. it does not work anymore'.  self scriptTransmission addActiveOrigin: (GLMPort new name: aPortSymbol)changedWith: aBlock  self changed.  aBlock cull: self.  self changedtestLeftMarginMyselfDependency  | root margin brick |  margin := 10.  root := self newBrickWithStaticExtent.  brick := self newBrickWithSmallStaticExtent.  brick marginLeft: margin.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticSmallExtent.  self assert: brick brickBounds equals: (margin @ 0 extent: self staticSmallExtent)methodBindingsStrategy  ^[:currentBindings :aSymbol |  currentBindings associationAt: aSymbol ifAbsent: [ nil ] ]children  ^childrenmouseWheel: event  self scrollBy: (self calculateVelocity: event) direction: (event isUp ifTrue: [ #up ] ifFalse: [ #down ])keymap: aKeymap  keymap := aKeymaptestMaxHeightTwoParentDependencies  | root brick1 brick2 |  root := self newBrickWithStaticExtent.  root useVerticalLinearLayout.  brick1 := self newBrickWithFullFill.  brick1 maxHeight: self staticSmallHeight.  brick2 := self newBrickWithFullFill.  root addAllBricks: {brick1 .         brick2}.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick1 extent equals: self staticWidth @ self staticSmallHeight.  self assert: brick2 extent equals: self staticWidth @ (self staticHeight - self staticSmallHeight)font: anObject  font := anObjecttestTreeWithDisplay  | browser treeCollection |  treeCollection := {(#root1 -> {(#child1 -> {}) .         (#child2 -> {})}) .   (#root2 -> {})}.  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a tree           display: [:each |  each value ];           children: [:x |  x value ] ].  window := browser openOn: #something -> treeCollection.  self assert: browser panes first presentations first displayValue identicalTo: treeCollectiondoNotLayoutDuring: aBlock  | wasAllowed |  wasAllowed := self isLayotingAllowed.  self isLayotingAllowed: false.  [ aBlock cull: self ] ensure: [ wasAllowed ifTrue: [ self isLayotingAllowed: true ] ]reset  isCompleted := false.  shouldStop := false.  doStep := true.  fromValue := nil.  toValue := nil.  currentValue := nil.  startTime := niltags: aBlock  self tagsBlock: aBlock.  self hasTagsFilter ifFalse: [ self tagsFilter: aBlock ]title  ^self addBrickBack: (self newLabel hAlign: #center)registerInPresentation  self announcerObjects do: [:announcerObject |  announcerObject notNil ifTrue: [ (announcerObject when: self announcement send: #actOn: to: self) makeWeak.              self presentation registeredAnnouncers add: announcerObject ] ]initialize  super initialize.  self band useVerticalLinearLayoutonLayouted  self updateFoundationBoundsaccept: aText notifying: anObject  aText asString trimBoth ifEmpty: [ ^self ].  self text: aText.  self changed: #textheaderBrick  ^headerBricktestCopy  | transmission port1 port2 newTransmission |  transmission := GLMTransmission new.  port1 := GLMSimplePort new.  port2 := GLMSimplePort new.  transmission destination: port2.  transmission addActiveOrigin: port1.  newTransmission := transmission copy.  self assert: newTransmission destination ~~ transmission destination.  self assert: newTransmission origins first ~~ transmission origins firstname: aSymbol  name := aSymbolapproximateWidth  ^self hMargin + self hPadding + (self isReadMode ifTrue: [ self labelBrick approximateWidth ] ifFalse: [ self editBrick width + self editBrick hPadding + self editBrick hMargin ])isPressed  ^isPressedupdate  self pane ports do: [:each |  (self validate: each value on: each) ifFalse: [ each resetValue ] ].  self announce: (GLMPresentationUpdated new presentation: self)testTriggerConditions  | transmission port1 port2 |  transmission := GLMTransmission new.  port1 := GLMSimplePort new name: #port1.  port2 := GLMSimplePort new name: #port2.  transmission addActiveOrigin: port1.  transmission destination: port2.  self assert: (transmission originatesAt: port1).  self assert: (transmission originatesAt: port2) not.  self assert: (transmission originatesAt: GLMPort new) nottransformDraggedItem: aBlock  transformDraggedItemBlock := aBlockhighlightSmalltalkContext  ^highlightSmalltalkContextrootItem  ^rootItem ifNil: [ rootItem := self createRootItem ]wantsAutomaticRefresh: aBoolean  wantsAutomaticRefresh := aBooleantextPositionHorizontalCenter  ^((self brickBounds width - self textSize x max: 0) / 2) @ 0width  ^self hState dimensionhandlesMouseDown: evt  ^clickAction notNiltranslateX: anObject  ^self brick translateX: anObjectpresentations  ^self transmissionStrategy presentationslayoutWidgets  | inner outer |  outer := super innerBounds.  inner := self innerBounds.  transform bounds: inner.  scrollBar bounds: (inner left @ inner bottom corner: outer bottomRight)morph  ^RubScrolledTextMorph new     getSelectionSelector: #primarySelectionInterval;     color: self theme backgroundColor;     textColor: self theme textColor;     textFont: StandardFonts defaultFont;     model: textModel;     yourselftags: aBlock  self tagsBlock: aBlock.  self hasTagsFilter ifFalse: [ self tagsFilter: aBlock ]morph  ^morphtestTransmissionWithTwoOrigins  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two;     column: #three.  browser transmit     to: #three;     from: #one;     from: #two;     andShow: [:a |  a text ].  ((browser paneNamed: #one) port: #selection) value: 42.  self assert: ((browser paneNamed: #three) port: #entity) value first equals: 42.  self assert: ((browser paneNamed: #three) port: #entity) value last equals: nil.  self assert: (browser paneNamed: #three) presentations size equals: 1.  self assert: (browser paneNamed: #three) matchingPresentations size equals: 0.  ((browser paneNamed: #two) port: #selection) value: 43.  self assert: ((browser paneNamed: #three) port: #entity) value first equals: 42.  self assert: ((browser paneNamed: #three) port: #entity) value last equals: 43.  self assert: (browser paneNamed: #three) matchingPresentations size equals: 1buttonPadding  ^#(3 7)actOnPresentationUpdated: ann  scrollPane scrollTarget: (self morphFrom: ann presentation)testCreation  self assertEmpty: GLMExpander new panesnoSelection  self acceptsSelection: falsetestFinderWithEmbeddedBrowser  | navigator finder tree1 tree2 |  navigator := GLMTabulator new.  navigator     row: #content;     row: #details.  navigator transmit     to: #content;     andShow: [:a |  a list display: #allSuperclasses ].  navigator transmit     from: #content;     to: #details;     andShow: [:a |  a text ].  navigator transmit     from: #content;     toOutsidePort: #selection.  finder := GLMFinder new.  finder show: [:a |  a custom: navigator ].  window := finder openOn: String.  (finder panes first port: #selection) value: Collection.  self assert: finder panes first presentations first ~= finder panes last presentations first.  tree1 := self find: MorphTreeMorph in: window submorphs last submorphs last submorphs first.  tree2 := self findLast: MorphTreeMorph in: window submorphs last submorphs last submorphs last.  self assert: tree1 notNil.  self assert: tree2 notNil.  self assert: tree1 ~= tree2.  self assert: tree1 model glamourPresentation pane ~= tree2 model glamourPresentation pane.  self assert: tree1 model glamourPresentation ~= tree2 model glamourPresentation* aNumber  < return: #Point>  ^0 @ aNumberselect: aBlock  ^self presentations select: aBlocktestMarkerOneStaticInChildrenWidth  | root brick |  root := self newBrickWithFullDependsOnChildren.  brick := self newBrickWithStaticExtent.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean.  self assert: root wrappedBounds isWidthDirty.  self assert: root wrappedBounds isHeightCleanisSelectionPort  ^self port isSelectionPortretrieveLast: aCollection  ^aCollection isEmpty ifTrue: [ nil ] ifFalse: [ aCollection removeLast ]testAnnouncerUnregistration  self assert: announcer numberOfSubscriptions equals: 5.  browser entity: #($a $b).  self assert: announcer numberOfSubscriptions equals: 5.  browser entity: #($d).  self assert: announcer numberOfSubscriptions equals: 5.  browser entity: #().  self assert: announcer numberOfSubscriptions equals: 5.  browser unregisterFromAllAnnouncements.  self assert: announcer numberOfSubscriptions equals: 0initialize  super initialize.  self labelBrick: self newLabelBrick.  self editBrick: self newEditBrick.  self     padding: self themer focusedBorderWidth;     borderWidth: self themer focusedBorderWidth;     hShrinkWrap;     vShrinkWrap;     enable;     enableDoubleClick;     when: #onDoubleClicked do: [ (self hasSubbrick: self editBrick) ifFalse: [ self beEdit ] ];     bindKeyCombination: Character escape toAction: [ self onEscapePressed ]width: anObject  < brickBuilderProperty: #Geometry name: 'Width' as: #asInteger getter: #width model: #GLMUIBuilderTextFieldProperty>  self privateWidth: anObject.  self updateWidthisFilterable  ^self parameters at: 'isFilterable' ifAbsent: [ false ]initializePresentation  super initializePresentation.  self do: [:each |  each initializePresentation ]add: anObject  collection add: anObject.  self announce: GLMItemAddedactions  actions ifNil: [ actions := OrderedCollection new ].  ^actionslayoutProperties: aLayoutProperties  super layoutProperties: aLayoutPropertiespushPane: aMorph  | isSmooth |  isSmooth := self pagerModel size >= self pagerModel numberOfVisiblePages.  self pagerModel pushPane: aMorph smooth: isSmoothrenderImageOf: aBrick on: aCanvas  | image |  image := aBrick currentImage.  image ifNotNil: [ aCanvas translucentImage: (GLMBrick resizeImage: image scale: (aBrick brickBounds expandBy: aBrick shadowWidth negated) extent / image extent) at: (aBrick brickBounds expandBy: aBrick shadowWidth negated) origin + ((aBrick paddingLeft - aBrick paddingRight) @ (aBrick paddingTop - aBrick paddingBottom) / 2.0) ]testEnlargeToLeft  | counter right |  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  counter := pagerModel numberOfVisiblePages.  right := pagerModel lastVisiblePageIndex.  self assert: pagerModel numberOfVisiblePages equals: counter.  self assert: pagerModel numberOfVisiblePages equals: right - pagerModel firstVisiblePageIndex + 1.  self assert: pagerModel lastVisiblePageIndex equals: right.  [ counter < 6 ] whileTrue: [ counter := counter + 1.        pagerModel enlargeToLeft.        self assert: pagerModel numberOfVisiblePages equals: counter.        self assert: pagerModel numberOfVisiblePages equals: right - pagerModel firstVisiblePageIndex + 1.        self assert: pagerModel lastVisiblePageIndex equals: right ].  (1 to: 3) do: [:i |  pagerModel enlargeToLeft.        self assert: pagerModel numberOfVisiblePages equals: 6.        self assert: pagerModel numberOfVisiblePages equals: right - pagerModel firstVisiblePageIndex + 1.        self assert: pagerModel lastVisiblePageIndex equals: right.        self assert: pagerModel firstVisiblePageIndex equals: 1 ]checkboxBorderColor  ^Color lightGrayinitializeListeners  self addCloserListenerstaticSmallHeight  ^50 * self currentWorld displayScaleFactorfont  ^fontsuspendAllWhile: aBlock  | previousSuspensionState |  previousSuspensionState := suspendAll.  suspendAll := true.  aBlock ensure: [ suspendAll := previousSuspensionState ]presentations  ^presentations ifNil: [ presentations := OrderedCollection new ]parentNode: aNode  parentNode := aNodeprivateOwner: aBrick  owner := aBrickhandlesKeyboard: evt  ^trueuseImplicitNotNil  implicitNotNil := trueinitialize  super initialize.  self     color: Color transparent;     borderWidth: 0;     vResizing: #spaceFill;     hResizing: #spaceFill.  self     initializeTransform;     initializeScrollbar.  paneCount := 0.  maxPanes := 2allowsItemDrag  ^self allowItemDragBlock notNilicon  ^iconheaderMorph: anObject  headerMorph := anObject.  headerMorph clipSubmorphs: trueensurePresentIfNoneStrategy  self transmissionStrategy class = GLMPresentIfNoneStrategy ifFalse: [ self transmissionStrategy: (GLMPresentIfNoneStrategy of: self) ]notifyScrollPositionChanged: isSmooth callback: aBlock  self notifyAll: (GLMPagerScrollPositionChanged new           smooth: isSmooth;           callback: aBlock;           yourself)sourceContext: aContext  sourceLink := aContextat: anObject  ^collection at: anObjectscrollTo: aFloat smooth: isSmooth  self scrollTo: aFloat smooth: isSmooth callback: nilbackgroundColor  ^Color r: 220 g: 246 b: 255 range: 255widthBottom  ^self width at: BottomaddColumn: aColumn  self columns add: aColumnhighlightSmalltalkContext: aClassOrMetaclass  highlightSmalltalkContext := aClassOrMetaclasstagsFor: anObject fromProvider: aTagProvider to: operation  | glamourValue |  glamourValue := anObject asGlamorousMultiValue , self entity asGlamorousMultiValue.  ^operation == #show ifTrue: [ aTagProvider computeTagsFor: glamourValue ] ifFalse: [ aTagProvider computeTagsFilterFor: glamourValue ]initializeNamed: aString  self initializeNamed: aString in: GLMNoBrowser newfloating  ^self layout floatingtextLogic: aBlock  textLogic := aBlocknewBand  ^GLMScrollPaneBandBrick newdefaultRenderer  ^GLMBrickRenderer newcolorRight: aColor  self color at: Right put: aColorfont: aFont  font := aFontsession: anObject  session := anObjectzIndex: anInteger  self layout zIndex: anIntegerinitialize  super initialize.  self fillStyle: self defaultFillStyle.  isOpen := false.  self setLabel: 'Glamorous Watcher'.  self addCornerGrips.  self addEdgeGrips.  self addContentsMorph.  self on: Character escape do: [ self hide ]onPagePushed: pushedAnnouncement  self pushPane: pushedAnnouncement morphisShrinking  ^self isHShrinking | self isVShrinkinghintModifier: anObject  hintModifier := anObjectvalue: anObject  value := anObjectexecutionSelectionActions  ^{(GLMGenericAction new     title: 'Do it';     action: [:aPresentation |  aPresentation highlightEvaluateAndDo: [:result |   ] ];     keymap: PharoShortcuts current doItShortcut;     icon: GLMUIThemeExtraIcons glamorousSpawn;     yourself) .   (GLMGenericAction new     title: 'Print it';     action: [:aPresentation |  aPresentation printSelection ];     keymap: PharoShortcuts current printItShortcut;     yourself) .   (GLMGenericAction new     title: 'Inspect it';     action: [:aPresentation |  aPresentation highlightEvaluateAndDo: [:result |  result inspect ] ];     keymap: PharoShortcuts current inspectItShortcut;     icon: GLMUIThemeExtraIcons glamorousInspect;     yourself) .   (GLMGenericAction new     title: 'Basic Inspect it';     action: [:aPresentation |  aPresentation highlightEvaluateAndDo: [:result |  result basicInspect ] ];     shortcut: $I;     icon: GLMUIThemeExtraIcons glamorousInspect;     yourself) .   (GLMGenericAction new     title: 'Debug it';     action: [:aPresentation |  aPresentation debugSelection ];     shortcut: $D;     yourself) .   (GLMGenericAction new     title: 'Profile it';     action: [:aPresentation |  aPresentation profileSelection ];     withSeparatorAfter;     yourself)}scrollbarCornerRadius  ^self valueOfProperty: #brickScrollbarCornerRadius ifAbsent: [ self themer scrollbarCornerRadius ]presentation  ^presentationwrapped: aBoolean  wrapped := aBooleanisFocused  ^falseleft  ^(GLMVector direction: self direction left) length: self lengthnoTestOKeyWithCtrlCannotBeOverriden  | composite textMorph overriden shortcut |  overriden := false.  composite := GLMCompositePresentation new with: [:a |  a text act: [:text |  overriden := true ] on: $o entitled: 'Override' ].  window := composite openOn: '4'.  textMorph := self find: RubScrolledTextMorph in: window.  shortcut := $o meta asKeyCombination.  textMorph textArea handleKeystroke: (KeyboardEvent new setType: #keystroke buttons: shortcut modifier eventCode position: textMorph textArea center keyValue: shortcut key asciiValue charCode: shortcut key asciiValue hand: nil stamp: DateAndTime now).  self assert: overriden notstatus: anObject  self flag: 'what kind of transformation should we want here?'.  (self pane port: #status) value: (self selectionTransformation glamourValue: anObject)invariant  self isDebug ifFalse: [ ^self ].  pagesCount >= 0 ifFalse: [ GLMPagerException signal: 'The number of page must be non negative' ].  pagesCount > 1 ifTrue: [ firstVisiblePageIndex >= 1 ifFalse: [ GLMPagerException signal: 'First visible page index must be > 1 if number of pages > 0' ].        lastVisiblePageIndex >= 1 ifFalse: [ GLMPagerException signal: 'Last visible page index must be > 1 if number of pages > 0' ].        lastVisiblePageIndex <= pagesCount ifFalse: [ GLMPagerException signal: 'Last visible page index must be less or equals to the number of pages' ].        self actualNumberOfVisiblePages <= numberOfVisiblePages ifFalse: [ GLMPagerException signal: 'Actual number of visible pages must be less or equals to current number of visible pages' ].        selectedPageIndex >= 1 ifFalse: [ GLMPagerException signal: 'Selected page index must be greater or equals then 1 if number of pages is more than 1' ] ].  pagesCount = 1 ifTrue: [ firstVisiblePageIndex = 1 ifFalse: [ GLMPagerException signal: 'First visible page index must be 1 if number of pages is 1' ].        lastVisiblePageIndex = 1 ifFalse: [ GLMPagerException signal: 'Last visible page index must be 1 if number of pages is 1' ].        lastVisiblePageIndex = firstVisiblePageIndex ifFalse: [ GLMPagerException signal: 'First and Last visible page indexes must be equal if number of pages is 1' ].        self actualNumberOfVisiblePages = 1 ifFalse: [ GLMPagerException signal: 'Actual number of visible pages must be 1 if number of pages is 1' ].        selectedPageIndex = 1 ifFalse: [ GLMPagerException signal: 'Selected page index must be 1 if number of pages is 1' ] ].  pagesCount = 0 ifTrue: [ firstVisiblePageIndex = 0 ifFalse: [ GLMPagerException signal: 'First visible page index must be 0 if number of pages is 0' ].        lastVisiblePageIndex = 0 ifFalse: [ GLMPagerException signal: 'Last visible page index must be 0 if number of pages is 0' ].        self actualNumberOfVisiblePages = 0 ifFalse: [ GLMPagerException signal: 'Actual number of visible pages must be 0 if there is no pages' ].        selectedPageIndex = 0 ifFalse: [ GLMPagerException signal: 'Selected page index must be 0 if number of pages is 0' ] ]condition: anObject  condition := anObjectmorph: aMorph withTitleOrNilOf: aPresentation  (aPresentation hasTitle or: [ aPresentation hasTitleIcon ]) ifFalse: [ ^self morph: aMorph withToolbarOf: aPresentation ].  ^self morph: aMorph withTitleOf: aPresentationtestPresentationInitializationBlock  | pane presentation count |  count := 0.  pane := GLMPane named: 'test'.  presentation := GLMPresentation new initialize: [:pres |  (pres pane port: #test) value: count ].  pane addPresentation: presentation.  self assert: (pane port: #test) value equals: nil.  presentation initializePresentation.  self assert: (pane port: #test) value equals: 0.  self assert: (presentation pane port: #test) value equals: 0.  count := 1.  presentation initializePresentation.  self assert: (pane port: #test) value equals: 1.  self assert: (presentation pane port: #test) value equals: 1rowMorphElementsForColumn: glamourColumn node: aNode withIndex: aRowIndex  | rowElements contentMorph tagMorphs |  contentMorph := glamourColumn modifiedBlock ifNotNil: [ self editRowMorphForColumn: glamourColumn node: aNode withIndex: aRowIndex ] ifNil: [ self viewRowMorphForColumn: glamourColumn node: aNode withIndex: aRowIndex ].  rowElements := OrderedCollection new     add: contentMorph;     yourself.  tagMorphs := self tagMorphsFrom: glamourColumn for: aNode.  tagMorphs ifNotEmpty: [ rowElements addAll: tagMorphs ].  ^rowElementsnorth  direction := NorthborderWidth  ^0printOn: aStream  super printOn: aStream.  aStream nextPutAll: ' (pane = ' , self pane printString , ')'table  ^tabledefaultSelectionActions  ^{self goAction} , super defaultSelectionActionsconvertIndexToValue: anIndex  ^self convertIndexToValue: anIndex with: self sizetextBrick  ^textBrickhSpaceFill: anInteger  super hSpaceFill: anInteger.  self labelBrick hSpaceFill.  self editBrick hSpaceFilllogger  ^loggerenableFilter: aBlock  self enableFilter.  self parameters at: 'filterBlock' put: aBlockhasDimensionRestrictions: aBrick  ^(self hasMinDimensionRestriction: aBrick) | (self hasMaxDimensionRestriction: aBrick)onDraw: aCanvas  super onDraw: aCanvas.  self highlightedText isEmpty ifFalse: [ self calculateHighlightingBounds do: [:each |  self highlightingLogic ifNil: [ aCanvas line: each bottomLeft to: each bottomRight width: 1 color: self textColor ] ifNotNil: [ self highlightingLogic cull: aCanvas cull: each ] ] ].  aCanvas drawString: self text at: self calculateTextPosition font: self font color: self textColorhandlePotentialStatusbarFor: aRenderable  | statusbarMorph bottomOffset |  bottomOffset := 0.  aRenderable hasStatusbar ifTrue: [ statusbarMorph := GLMMorphicPaneWithoutTitleRenderer render: aRenderable statusbarPane from: self renderer.        bottomOffset := (0 - (LabelMorph contents: 'XXX') minHeight) * 1.2.        window addMorph: statusbarMorph fullFrame: (LayoutFrame identity                 topFraction: 1;                 leftOffset: 2;                 topOffset: bottomOffset;                 rightOffset: -2) ].  ^bottomOffsettestEmptyPanes  | browser |  browser := GLMFinder new.  self assertEmpty: browser panes.  self assertEmpty: browser transmissionsonCompleted: aBlock  callback := aBlocktext  ^self label textwithContentsDo: aBlock  aBlock value: self.  self containerTree glamourPresentation allowsRecursiveSearch ifTrue: [ self contents do: [:each |  each withContentsDo: aBlock ] ]titleText  ^titleText ifNil: [ titleText := 'Hi,' ]drawSubmorphsOn: aCanvas  | area zIndexedBricks |  self submorphs isEmpty ifTrue: [ ^self ].  area := aCanvas clipRect intersect: self globalInnerBounds ifNone: (0 @ 0 extent: 0 @ 0).  area width = 0 | (area height = 0) ifTrue: [ ^self ].  zIndexedBricks := OrderedCollection new.  self subbricks do: [:each |  | intersection canvas globalBounds |        each ifNotNil: [ globalBounds := each globalClippingBounds.              (area intersects: globalBounds) ifTrue: [ | zIndex |                    zIndex := each layoutProperties zIndex brickValue: each.                    zIndex = 1 ifTrue: [ intersection := area intersect: globalBounds ifNone: (0 @ 0 extent: 0 @ 0).                          canvas := aCanvas copyClipRect: intersection.                          each fullDrawOn: canvas ] ifFalse: [ zIndexedBricks add: each ] ] ] ].  zIndexedBricks sort: [:first :second |  (first layoutProperties zIndex brickValue: first) < (second layoutProperties zIndex brickValue: second) ].  zIndexedBricks do: [:each |  | intersection canvas globalBounds |        each ifNotNil: [ globalBounds := each globalClippingBounds.              intersection := area intersect: globalBounds ifNone: (0 @ 0 extent: 0 @ 0).              canvas := aCanvas copyClipRect: intersection.              each fullDrawOn: canvas ] ]defaultFinderBrowser  | finder |  finder := GLMFinder new.  finder show: [:a |  a list           title: 'title';           display: [:each |  1 to: each ];           showOnly: 50 ].  ^finderprimarySelectionInterval: anInterval  primarySelectionInterval := anIntervalwhen: anAnnouncementClass send: selector to: target  self announcer when: anAnnouncementClass send: selector to: targetwindow  self announce: (GLMWindowRequest new action: [:aWindow |  ^aWindow ]).  ^nilcheckboxBorderColor  ^Color lightGraytestSimpleTransmissionWithCondition  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     from: #one port: #port1;     fromOutsidePort: #entity;     to: #two port: #port2;     when: [:one :outer |  one notNil and: [ outer notNil and: [ one + outer = 42 ] ] ].  browser startOn: 2.  self assert: ((browser paneNamed: #two) port: #port2) value isNil.  ((browser paneNamed: #one) port: #port1) value: 39.  self assert: ((browser paneNamed: #two) port: #port2) value isNil.  ((browser paneNamed: #one) port: #port1) value: 40.  self assert: ((browser paneNamed: #two) port: #port2) value notNilcomputation  ^computationtestDefaultPane  | presentation pane |  presentation := GLMPresentation new.  pane := presentation pane.  self assert: pane presentations first pane identicalTo: pane.  self assert: pane presentations pane identicalTo: pane.  self assert: pane presentations first identicalTo: presentationglamourPresentation  ^glamourPresentationhighlightingLogic  ^self valueOfProperty: #brickHighlightingLogic ifAbsentPut: [ [:aCanvas :aRectangle |  | rectangle |        rectangle := aRectangle translateBy: (3 @ 1) negated + self brickBounds origin.        aCanvas line: rectangle bottomLeft to: rectangle bottomRight width: 1 color: self textColor ] ]origin: aPoint breadth: aNumber  < return: #Rectangle>  ^self direction origin: aPoint length: length breadth: aNumberscrollpaneBackgroundColor  ^Color transparentusesImplicitNotNil  ^implicitNotNil ifNil: [ implicitNotNil := true ]glamourColumn  ^glamourColumnchildren: anObject  children := anObjectwithLineNumbers  ^withLineNumbers ifNil: [ withLineNumbers := false ]column: aBlockOrString evaluated: aBlock tags: anObject  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           tags: anObject)position: anObject  position := anObjectevaluateSelection  self announce: (GLMEvaluateSelection new           action: [:result |  result ];           makeSyncronous)familyName: aString  self label familyName: aString.  self dotsBrick familyName: aStringrubricBorderColor  ^self valueOfProperty: #brickRubricBorderColor ifAbsent: [ self themer rubricBorderColor ]keyStroke: aCharacter from: aTreeMorph  ^falseterminate  self asyncTask terminate.  self isCompleted not & self animatedObject isNotNil ifTrue: [ ensureLogic brickValue: self animatedObject ]registerEventsForPresentation: aPresentation  super registerEventsForPresentation: aPresentation.  aPresentation when: GLMVariableBindingsChanged send: #actOnVariableBindingsUpdated: to: self.  aPresentation when: GLMVariableBindingsAccessRequest send: #actOnVariableBindingsAccessRequest: to: selfshadowInset: aNumber  self setProperty: #brickShadowInset toValue: aNumbereditBrick: aBrick  editBrick := aBrick.  self editBrick     hShrinkWrap;     vShrinkWrap;     withoutMargins;     withoutAdornment;     withoutBorder;     beTransparent;     autoAccept: true;     rubricTextFamilyName: self themer textFamilyName;     rubricTextFontSize: self themer textFontSize.  self editBrick rubric forceHeight: [ self labelBrick height ].  self editBrick rubric announcer when: RubReturnEntered send: #onTextAccepted: to: self.  self editBrick rubric announcer when: MorphLostFocus send: #onLostFocus to: self.  self editBrick rubric announcer when: MorphGotFocus send: #onGotFocus: to: self.  self editBrick rubric announcer when: RubTextAcceptRequest send: #onTextChanged: to: selfonPagePoped  buttonsBrick onPagePoped.  self recomputeScrollBarbrickApi  ^brickApi ifNil: [ brickApi := GLMBrickWrapper on: self ]resetChildrenContent  items := self calculateItems.  self resetDataCacheinitialize  super initialize.  self useVerticalLinearLayoutcurrentPresentation  ^(self displayValue isCollection and: [ self displayValue isString not ]) ifTrue: [ GLMListPresentation new           showOnly: 50;           pane: self pane ] ifFalse: [ GLMRubricTextPresentation new pane: self pane ]origin: aPoint length: aLength breadth: aBreadth  ^aPoint - (aBreadth @ 0) extent: aBreadth @ aLengthcondition  ^conditionrender: aBrowser  ^self renderWithExpanders: aBrowsertestMultipleSelectionWithChange  | composite textMorph textPresentation |  composite := GLMCompositePresentation new with: [:a |  a text display: '123456789' ].  window := composite openOn: 4.  textMorph := self find: RubScrolledTextMorph in: window.  self assertEmpty: textMorph selectionInterval.  textPresentation := composite presentations first.  textPresentation selectionInterval: (2 to: 5).  self assert: textMorph textArea selection asString equals: '2345'.  self assert: textPresentation selectedText asString equals: '2345'tagsBlock  ^tagsBlockglobalBounds  ^self boundstestCreateTabulator  | show |  show := GLMCompositePresentation new.  show tabulator with: [:b |  b row: #one.        b transmit           to: #one;           transformed: [:x |  x + 1 ];           andShow: [:a |  a text ] ].  self assert: show size equals: 1.  self assert: (show first isKindOf: GLMTabulator).  show startOn: 41.  self assert: show first panes size equals: 1.  self assert: (show first panes first port: #entity) value equals: 42glamourPresentation: aGLMFastTreePresentation  glamourPresentation := aGLMFastTreePresentationtestSuspendParticularAnnouncementWithInheritanceWhile  | announcement instance |  announcer when: Announcement do: [:ann |  announcement := ann ].  announcement := nil.  instance := announcer announce: Announcement.  self assert: announcement equals: instance.  announcement := nil.  announcer suspendAll: {Announcement} while: [ instance := announcer announce: GLMTestAnnouncement ].  self assert: announcement isNilcodeEditingSelectionActions  ^{(GLMGenericAction new     title: 'Cut';     action: [:aPresentation |  aPresentation cut ];     iconName: #smallCutIcon;     shortcut: $x;     withSeparatorBefore;     yourself) .   (GLMGenericAction new     title: 'Copy';     action: [:aPresentation |  aPresentation copySelection ];     iconName: #smallCopyIcon;     shortcut: $c;     yourself) .   (GLMGenericAction new     title: 'Paste';     action: [:aPresentation |  aPresentation paste ];     iconName: #smallPasteIcon;     shortcut: $v;     yourself) .   (GLMGenericAction new     title: 'Paste...';     action: [:aPresentation |  aPresentation pasteRecent ];     iconName: #smallCopyIcon;     withSeparatorAfter;     yourself)}getMorphAt: anInteger recycled: aMorph  | newMorph |  newMorph := (self model morphAt: anInteger convert: aMorph) asBrick.  newMorph hSpaceFill.  self setIndex: anInteger in: newMorph.  ^newMorphmaxDepth  ^self parameters at: 'maxDepth' ifAbsent: [ nil ]isDependenciesShown  ^isDependenciesShowntestPresentations  | transmission presentation1 presentation2 presentation3 |  transmission := GLMTransmission new ensureReplacePresentationsStrategy.  transmission addActiveOrigin: (GLMSimplePort new           name: #port1;           value: 1).  transmission addPassiveOrigin: (GLMSimplePort new           name: #port2;           value: 2).  transmission destination: (GLMSimplePort new name: #port3).  presentation1 := GLMPresentation new title: 'presentation1'.  presentation2 := GLMPresentation new title: 'presentation2'.  presentation3 := GLMPresentation new title: 'presentation3'.  transmission transmissionStrategy addPresentation: presentation1.  transmission transmissionStrategy addPresentation: presentation2.  transmission transmissionStrategy addPresentation: presentation3.  self assert: transmission transmissionStrategy presentations size equals: 3.  self assert: (transmission transmissionStrategy presentations at: 1) title equals: presentation1 title.  self assert: (transmission transmissionStrategy presentations at: 2) title equals: presentation2 title.  self assert: (transmission transmissionStrategy presentations at: 3) title equals: presentation3 title.  self assert: (transmission transmissionStrategy presentations at: 1) ~~ presentation1.  self assert: (transmission transmissionStrategy presentations at: 2) ~~ presentation2.  self assert: (transmission transmissionStrategy presentations at: 3) ~~ presentation3testOriginValue  | port reference |  port := GLMSimplePort new value: 42.  reference := GLMOriginPortReference new port: port.  self assert: reference value equals: 42privateAddBrickLinkBack: aBrick  | link brick |  brick := aBrick asBrick.  link := brick asDoubleLink.  brick brickDoubleLink: link.  self hasSubbricks ifTrue: [ self lastSubbrick brickDoubleLink nextLink: link.        link previousLink: self lastSubbrick brickDoubleLink ].  brick owner: self.  ^aBrickkeystroke: anEvent from: aMorph  | action |  self deprecated: 'This method is needed only for the text rederer for PluggableTextMorph.'.  action := self allKeystrokeActions detect: [:a |  a shortcut = anEvent keyCharacter ] ifNone: [ nil ].  action ifNotNil: [ self announce: (GLMKeyStroke action: action).        ^true ].  ^falseglmPres  glmPres ifNil: [ glmPres := GLMPharoScriptPresentation new ].  ^glmPresbindingsStrategy: aBlock  bindingsStrategy := aBlockmenuIn: aMenuMorph for: aPresentation  | subMenus targetMenuMorph subMenu |  subMenus := Dictionary new.  (aPresentation allActions select: [:each |  each isMenu ]) do: [:action |  targetMenuMorph := action category notNil ifTrue: [ subMenus at: action category ifAbsentPut: [ subMenu := MenuMorph new.                    aMenuMorph add: action category subMenu: subMenu.                    subMenu ] ] ifFalse: [ aMenuMorph ].        (targetMenuMorph add: action title target: action selector: #morphicActOn: argument: aPresentation)           enabled: (action isEnabledOn: aPresentation);           icon: action icon;           keyText: (action hasShortcut ifTrue: [ action shortcutAsString ] ifFalse: [ nil ]) ].  ^aMenuMorphadoptPaneColor: aColor  super adoptPaneColor: aColor.  scrollBar adoptPaneColor: aColorarrangement  ^arrangement ifNil: [ arrangement := GLMTabbedArrangement of: self ]browser: anObject  browser := anObjectinitializeTableMorph  | presentation |  presentation := tableModel glamourPresentation.  tableMorph := self createFastTable.  tableMorph     dataSource: tableModel;     hResizing: #spaceFill;     vResizing: #spaceFill;     cornerStyle: tableMorph preferredCornerStyle;     borderStyle: (BorderStyle inset width: 0);     dragEnabled: presentation allowsItemDrag;     dropEnabled: presentation isDropTarget;     allowsDeselection: presentation allowsDeselection.  self setFastTableLayoutFrame: tableMorph.  presentation isMultiple ifTrue: [ tableMorph beMultipleSelection ] ifFalse: [ tableMorph beSingleSelection ].  self specificTableMorphInitializiationtestComplex  | layout |  layout := GLMTabulator new.  layout addColumn: [:column |  column addRow: #second.        column addRow: #third.        column addRow: #fourth.        column addRow: [:row |  row addColumn: #fifth.              row addColumn: #sixth ] ].  layout addColumn: #first.  self assert: layout cell children size equals: 2.  self assert: layout cell children first children size equals: 4.  self assert: layout cell children first children last children size equals: 2addPresentation: aPresentation  self transmissionStrategy addPresentation: aPresentationshouldRootsExpand: anObject  rootsExpanded := anObjectchildren  ^childrencheckInitializeBlockSetsTextSelectionForPresentation: aSelector  | browser textMorph |  browser := GLMTabulator new.  browser act: [:aBrowser |  aBrowser entity: '2 + 3 + 4' ] icon: GLMUIThemeExtraIcons glamorousRefresh entitled: 'Change text'.  browser row: #main.  browser transmit     to: #main;     andShow: [:c |  (c perform: aSelector)           title: 'Code';           initialize: [:script |  script selectionInterval: (1 to: 5) ] ].  window := browser openOn: '1 + 2 + 3'.  textMorph := self find: RubScrolledTextMorph in: window.  self assert: textMorph getSelectionFromModel equals: (1 to: 5).  self assert: textMorph selectionInterval equals: (1 to: 5).  browser entity: '2 + 3 + 4'.  self assert: textMorph getSelectionFromModel equals: (1 to: 5).  self assert: textMorph selectionInterval equals: (1 to: 5)allowDropOnItemBlock  ^allowDropOnItemBlock ifNil: [ allowDropOnItemBlock := [ false ] ]leftPosition  ^leftPosition ifNil: [ leftPosition := 0 ]sendOneOrMultipleAs: aCollectionClass  self sendOneOrMultipleAs: aCollectionClass updatedBy: [:aCollection |  aCollection ]wantsSteps  ^self model wantsStepsinitialize  super initialize.  self     hSpaceFill;     vShrinkWrapcount  ^countLogic ifNil: [ origin size ] ifNotNil: [ countLogic cull: origin ]privateRemoveAllBricks  self hasSubbricks ifFalse: [ ^self ].  self subbricks do: [:each |  each brickDoubleLink: nil.        each owner: nil ].  self subbricks removeAllselectedIndex: index  | oldIndex |  self selectedIndex == index ifTrue: [ ^self ].  oldIndex := self selectedIndex.  selectedIndex := index min: self tabs size.  self updateTabs.  self changed: #selectedIndex with: oldIndextestUpdateOnPortsUpdate  | col pane presentation announcer |  col := OrderedCollection with: 1 with: 2.  pane := GLMPane named: 'test'.  presentation := GLMListPresentation new.  announcer := Announcer new.  pane addPresentation: presentation.  presentation updateOn: GLMTestAnnouncement from: [ announcer ].  presentation entity: col.  presentation shouldValidate: true.  presentation registerAnnouncements.  presentation selection: 2.  self assert: presentation selection equals: 2.  col removeLast.  announcer announce: GLMTestAnnouncement.  self assert: presentation selection isNiltestPortInitializationDoesNotAffectTransmissionPort  | browser count |  count := 0.  browser := GLMTabulator new.  browser column: #one.  browser transmit     fromOutsidePort: #entity;     to: #one port: #entity;     andShow: [:a :entity |  a list initialize: [:pres |  count := count + 1.              pres entity: (1 to: 10) ] ].  self assert: (browser panes first port: #entity) value equals: nil.  browser startOn: (1 to: 42).  self assert: (browser panes first port: #entity) value equals: (1 to: 42).  self assert: count equals: 1.  (browser pane port: #entity) value: (1 to: 43).  self assert: (browser panes first port: #entity) value equals: (1 to: 43).  self assert: count equals: 2testTwoPanesMultipleSelectionWithChange  | browser treeMorphOne treeNodeMorph treeMorphTwo |  browser := GLMTabulator new.  browser     column: #one;     column: #two;     column: #three.  browser transmit     to: #one;     andShow: [:a |  a list display: [:x |  1 to: x ] ].  browser transmit     to: #two;     from: #one;     andShow: [:a |  a list           beMultiple;           display: [:x |  x * 10 to: x * 10 + 4 ] ].  browser transmit     to: #three;     from: #two;     andShow: [:a |  a text ].  window := browser openOn: 4.  treeMorphOne := (window submorphs last submorphs at: 3) submorphs first submorphs first.  treeNodeMorph := treeMorphOne scroller submorphs second.  self send: treeMorphOne mouseUpOnItem: treeNodeMorph.  treeMorphTwo := (window submorphs last submorphs at: 4) submorphs first submorphs first.  treeNodeMorph := treeMorphTwo scroller submorphs first.  self send: treeMorphTwo mouseUpOnItem: treeNodeMorph.  treeNodeMorph := treeMorphTwo scroller submorphs second.  self send: treeMorphTwo mouseUpWithShift: true onItem: treeNodeMorph.  self assert: ((browser paneNamed: #two) port: #selection) value asOrderedCollection equals: #(20 21) asOrderedCollection.  treeMorphOne := (window submorphs last submorphs at: 3) submorphs first submorphs first.  treeNodeMorph := treeMorphOne scroller submorphs last.  self send: treeMorphOne mouseUpOnItem: treeNodeMorph.  treeMorphTwo := (window submorphs last submorphs at: 4) submorphs first submorphs first.  self assert: (treeMorphTwo model roots collect: #item) equals: #(40 41 42 43 44) asOrderedCollection.  treeNodeMorph := treeMorphTwo scroller submorphs first.  self send: treeMorphTwo mouseUpOnItem: treeNodeMorph.  treeNodeMorph := treeMorphTwo scroller submorphs second.  self send: treeMorphTwo mouseUpWithShift: true onItem: treeNodeMorph.  self assert: ((browser paneNamed: #two) port: #selection) value asOrderedCollection equals: #(40 41) asOrderedCollectionfirstTransmission  ^firstTransmission ifNil: [ firstTransmission := GLMTransmission new ensureReplacePresentationsStrategy ]when: aBlock  self condition: aBlockoldPage: anObject  oldPage := anObjectasGlamourOriginIdentifier  self portName ifNil: [ self portName: self class defaultOriginPortName ].  ^selfact: aBlock entitled: aString categorized: anotherString  self addAction: (GLMGenericAction new           action: aBlock;           title: aString;           category: anotherString;           yourself)printOn: aStream  super printOn: aStream.  aStream nextPutAll: ' (pane = ' , self pane printString , ')'vAlign  ^self layout vAlignvSpaceFill  self vSpaceFill: 100newToggleButtonFor: aCollapsable  ^GLMActionButtonBrick new     icon: GLMUIThemeExtraIcons glamorousRight;     checkedImage: GLMUIThemeExtraIcons glamorousDown;     height: [:b |  b icon height * 1.2 ];     width: [:b |  b icon width * 1.2 ];     action: [:b |  aCollapsable toggle.        aCollapsable isExpanded ifTrue: [ b check ] ifFalse: [ b uncheck ] ]testSpawnTabulator  | browser |  browser := GLMTabulator new.  window := browser openOn: ($a to: $d).  self assert: window model identicalTo: browser.  self waitUntilUIRedrawed.  self assert: window submorphs last submorphs last submorphs last submorphs last class equals: GLMPaginatedMorphTreeMorphtestChangeInnerSelection  | browser1 browser2 list1 list2 |  browser1 := GLMExplicitBrowser new.  browser2 := GLMExplicitBrowser new.  list1 := GLMListPresentation new.  list2 := GLMListPresentation new.  browser1 addNewPane.  browser1 addNewPane.  browser2 addNewPane.  browser1 panes first addPresentation: list1.  browser1 panes last addPresentation: browser2.  browser2 panes first addPresentation: list2.  browser1 addTransmission: (GLMTransmission new           addActiveOrigin: (browser1 panes first port: #selection);           destination: (browser1 panes last port: #innerSelection);           yourself).  browser2 addTransmission: (GLMTransmission new           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: browser2;                 name: #innerSelection;                 yourself);           destination: (browser2 panes first port: #selection);           yourself).  list1 entity: #(1 2 3).  list2 entity: #(1 2 3).  list1 selection: 1.  self assert: list2 selection equals: 1.  list1 selection: 2.  self assert: list2 selection equals: 2isCategorized  ^self category notNilmaxWidth: anObject  maxWidth := anObjectrowMorphForColumn: aColumn item: anItem withIndex: aRowIndex  | rowElements |  rowElements := OrderedCollection new.  self table columns first == aColumn ifTrue: [ self rowMorphElementsForFirstColumn: aColumn item: anItem in: rowElements ].  rowElements addAll: (self rowMorphElementsForColumn: aColumn glamourColumn node: (self dataFromPresentationItem: anItem) withIndex: aRowIndex).  ^Smalltalk ui theme newRowIn: self currentWorld for: rowElementspopAndReplacePane: aMorph  self pagerModel popAndReplacePane: aMorphlayoutSubbricks: aBrick  aBrick ifNil: [ ^self ].  aBrick isBrick ifFalse: [ ^self ].  (self isClean: aBrick) & (self isOppositeClean: aBrick) ifFalse: [ ^self ].  (self isLayoutClean: aBrick) ifTrue: [ ^self ].  (aBrick subbricks allSatisfy: [:each |  each isBrick ifTrue: [ (self isClean: each) & (self isOppositeClean: each) ] ifFalse: [ false ] ]) ifFalse: [ ^self ].  aBrick invalidateLayout.  self markLayoutClean: aBrick.  aBrick onChildrenLayoutedbuttonPressedColor  ^self backgroundColor whitershouldAllExpand: anObject  allExpanded := anObjectinitialize  super initialize.  self composetextBrick: aBrick  textBrick := aBrick.  self textBrick     margin: #(0 3 3 3);     vShrinkWrap.  self addBrickBack: self textBrickclick: anEvent  clickAction ifNil: [ ^false ].  clickAction brickValue: self withEnoughArguments: {anEvent}.  ^trueopenInExternalWindowWith: aRenderer  ^aRenderer openInExternalWindow: selftestMinAndMaxHeightTwoParentDependencies  | root brick1 brick2 minHeight maxHeight |  minHeight := 60.  maxHeight := 20.  root := self newBrickWithStaticExtent.  root useVerticalLinearLayout.  brick1 := self newBrickWithFullFill.  brick1 vSpaceFill: 50.  brick1 minHeight: minHeight.  brick2 := self newBrickWithFullFill.  brick2 maxHeight: maxHeight.  root addAllBricks: {brick1 .         brick2}.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick1 extent equals: self staticWidth @ minHeight.  self assert: brick2 extent equals: self staticWidth @ maxHeightdisplayText  ^(UITheme current newTextIn: self currentWorld text: (self containerTree glamourPresentation formatedDisplayValueOf: self item))     backgroundColor: self textBackgroundColor;     yourselfregisterEventsForPresentation: aPresentation  super registerEventsForPresentation: aPresentation.  aPresentation when: GLMSelectCurrentLine send: #selectLine to: self.  aPresentation when: GLMEvaluateSelection send: #actOnEvaluateSelection: to: self.  aPresentation when: GLMHighlightAndEvaluate send: #actOnHighlightAndEvaluate: to: self.  aPresentation when: GLMCompileText send: #actOnCompileText: to: self.  aPresentation when: GLMDebugSelection send: #debugHighlightedText to: self.  aPresentation when: GLMProfileSelection send: #profileHighlightedText to: self.  aPresentation when: GLMPrintSelection send: #evaluateAndPopPrintHighlight to: self.  aPresentation when: GLMFormatCode send: #formatSourceCode to: selftestSelectToRight  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel scrollTo: 0.0 smooth: false.  self assert: pagerModel numberOfVisiblePages equals: 2.  self assert: pagerModel selectedPageIndex equals: 1.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 2.  pagerModel selectToRight.  self assert: pagerModel selectedPageIndex equals: 2.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 2.  pagerModel selectToRight.  self assert: pagerModel selectedPageIndex equals: 3.  self assert: pagerModel firstVisiblePageIndex equals: 2.  self assert: pagerModel lastVisiblePageIndex equals: 3.  pagerModel selectToRight.  self assert: pagerModel selectedPageIndex equals: 4.  self assert: pagerModel firstVisiblePageIndex equals: 3.  self assert: pagerModel lastVisiblePageIndex equals: 4.  pagerModel selectToRight.  self assert: pagerModel selectedPageIndex equals: 5.  self assert: pagerModel firstVisiblePageIndex equals: 4.  self assert: pagerModel lastVisiblePageIndex equals: 5.  pagerModel selectToRight.  self assert: pagerModel selectedPageIndex equals: 6.  self assert: pagerModel firstVisiblePageIndex equals: 5.  self assert: pagerModel lastVisiblePageIndex equals: 6doSearchOrFilter  inputText isEmptyOrNil ifTrue: [ self resetInput ] ifFalse: [ self glamourPresentation allowsFilter ifTrue: [ self executeFilter ] ifFalse: [ self executeSearch ] ]handlesMouseWheel: evt  ^truevelocity  ^velocity ifNil: [ velocity := self class defaultScrollVelocity ]registerAnnouncementsFor: aBrowser  aBrowser when: GLMPaneRemoved send: #actOnPaneRemoved: to: self.  aBrowser when: GLMPaneAdded send: #actOnPaneAdded: to: self.  aBrowser when: GLMPaneReplaced send: #actOnPaneReplaced: to: self.  aBrowser when: GLMBrowserClosed send: #actOnBrowserClosed: to: selfapproximateWidth  ^self textSize x + self hMargin + self hPaddingshouldStopStepping  ^stopStepping ifNil: [ false ]testMarkerOneStaticInParentWidth  | root brick |  root := self newBrickWithFullFill.  brick := self newBrickWithStaticExtent.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightCleanisOnChildren  ^trueisBottomOverscrolled  self isLastVisible ifFalse: [ ^false ].  self band brickBounds bottom < self height ifTrue: [ ^true ].  ^self band lastSubbrick brickBounds bottom + self band brickBounds top < self heightlabelMorph  ^labelMorphcanAnnouncePresentationsChanged: aPane  self can: aPane announce: GLMPresentationsChangedtextSecondaryColor  ^Color whitesmalltalkClass: aBlock  highlightSmalltalkContext := aBlockincludesPort: aPort  ^self ports includes: aPortalign: aPoint  position := aPointarguments: aCollection  arguments := aCollectiontestTwoShrinkInShrinkChange  | root brick1 brick2 brick3 |  root := self newBrickWithFullDependsOnChildren.  brick1 := self newBrickWithFullDependsOnChildren.  brick2 := self newBrickWithSmallStaticExtent.  brick3 := self newBrickWithSmallStaticExtent.  brick1 useVerticalLinearLayout.  root addBrickBack: brick1.  brick1 addBrickBack: brick2.  brick1 addBrickBack: brick3.  self assertAllSubbricksAreClean: root.  self assert: root brickBounds equals: (0 @ 0 extent: self staticSmallWidth @ (2 * self staticSmallHeight)).  self assert: brick1 brickBounds equals: (0 @ 0 extent: self staticSmallWidth @ (2 * self staticSmallHeight)).  self assert: brick2 brickBounds equals: (0 @ 0 extent: self staticSmallExtent).  self assert: brick3 brickBounds equals: (0 @ self staticSmallHeight extent: self staticSmallExtent).  brick2     width: self staticWidth;     height: self staticHeight.  self assert: root brickBounds equals: (0 @ 0 extent: self staticWidth @ (self staticHeight + self staticSmallHeight)).  self assert: brick1 brickBounds equals: (0 @ 0 extent: self staticWidth @ (self staticHeight + self staticSmallHeight)).  self assert: brick2 brickBounds equals: (0 @ 0 extent: self staticExtent).  self assert: brick3 brickBounds equals: (0 @ self staticHeight extent: self staticSmallExtent)shadowColor  ^self valueOfProperty: #brickShadowColor ifAbsentPut: [ Color transparent ]announcer  ^announcer ifNil: [ announcer := GLMAnnouncer new ]paddingRight  ^self wrappedBounds paddingRightdefaultBindingsStrategy  ^[:currentBindings :aSymbol |  currentBindings associationAt: aSymbol ifAbsent: [ nil ] ]transformedDraggedItem: anItem  ^self transformDraggedItemBlock ifNotNil: [:transform |  transform glamourValue: (GLMMultiValue with: anItem with: self) ] ifNil: [ anItem ]scrollpaneBackgroundColor  ^self contentBackgroundColortagsFilter: aBlock  tagsFilterBlock := aBlocksourceContext  ^sourceLinkoffset  < return: #Point>  ^self direction * self lengthspawn: aBlock icon: anIcon entitled: aString  self addAction: (GLMSpawnBrowserAction new           action: aBlock;           icon: anIcon;           title: aString;           yourself)dragTransferType  ^#GlamourmeasureSelectionTime  ^self measureSelectionTimeForSize: 1000hasBrowser  ^self browser isNil notisEntityPort  ^self port isEntityPortsizeOf: aString  ^(self font widthOfString: aString) @ self font heighttagsBlock: anObject  tagsBlock := anObjecttestChildren  | tree |  tree := GLMTreePresentation new.  tree transformation: [:aNumber |  (1 to: aNumber) collect: #printString ].  tree children: [:each |  self assert: (each isKindOf: String) ].  tree entity: 42from: aPaneSymbol port: aPortSymbol transformed: aBlock  ^(self from: (GLMPortIdentifier pane: aPaneSymbol port: aPortSymbol)) transformation: aBlocksetPotentialBackgroundColorFor: aRenderable  aRenderable colorValue ifNotNil: [ window borderColor: aRenderable colorValue ]basicItems  ^self glamourPresentation displayValuepageIndex: anObject  pageIndex := anObjectpostCopy  | newPane newPanes newPanesMapping newTransmission oldPane oldWatcherPane |  super postCopy.  newPanesMapping := Dictionary new.  newPanes := OrderedCollection new.  self panes do: [:each |  newPane := each copy.        newPane browser: self.        newPanes addLast: newPane.        newPanesMapping at: each put: newPane ].  oldPane := self pane.  oldWatcherPane := self watcherPane.  watcherPane := nil.  pane := nil.  newPanesMapping at: oldPane ifAbsentPut: [ self pane ].  newPanesMapping at: oldWatcherPane ifAbsentPut: [ self watcherPane ].  self flag: 'we should also copy the values of ports from pane and watcherPane'.  transmissions := self transmissions collect: [:each |  newTransmission := each copy.        newTransmission changePortsAccordingToPaneMapping: newPanesMapping fromOldBrowser: nil toNewBrowser: self.        newTransmission ].  panes := newPaneswithoutBorder  self rubricBorderWidth: 0.  self rubricBorderColor: Color transparentmorphicFont  ^self font ifNil: [ StandardFonts defaultFont ] ifNotNil: [:f |  f glamourValue: self entity ]hasChildren: anItem  ^self glamourPresentation hasChildrenBlock ifNil: [ anItem children isNotEmpty ] ifNotNil: [:aBlock |  aBlock cull: anItem data ]cellOrRow  ^cell ifNil: [ cell := GLMCustomRow new browser: self ]transmitIn: aContext  (self transmission destination hasPane and: [ self transmission destination pane presentations isEmpty ]) ifTrue: [ self transmission destination pane notingPresentationChangeDo: [ self transmission destination pane clearIn: aContext.              self transmission destination pane presentations: self presentations copy ] ]brick: anObject  brick := anObjectrenderWithTree: aBrowser  | treeMorph treeModel |  treeModel := GLMExpanderTreeMorphModel new glamourExpander: aBrowser.  treeMorph := MorphTreeMorph new.  treeMorph     makeLastColumnUnbounded;     getMenuSelector: #menu:shifted:;     keystrokeActionSelector: #keyStroke:from:;     cornerStyle: treeMorph preferredCornerStyle;     borderStyle: (BorderStyle inset width: 1);     hResizing: #spaceFill;     vResizing: #spaceFill;     layoutFrame: LayoutFrame identity;     preferedPaneColor: Color white;     model: treeModel;     columns: (OrderedCollection with: (MorphTreeColumn new rowMorphGetSelector: #elementColumn)).  treeMorph vShowScrollBar.  aBrowser when: GLMBrowserClosed send: #actOnBrowserClosed: to: self.  ^treeMorph buildContentsinitializeIn: aBrowser  self initializeNamed: self defaultName in: aBrowservalueOfProperty: aSymbol ifAbsentPut: aBlock  ^super valueOfProperty: aSymbol ifAbsentPut: aBlockoriginReferences  ^origins ifNil: [ origins := OrderedCollection new ]tree  hasStatusbar  ^statusPane notNilarguments  ^arguments ifNil: [ arguments := {} ]testCreateFinder  | show |  show := GLMCompositePresentation new.  show finder with: [:b |  b show: [:a |  a text ] ].  self assert: show size equals: 1.  self assert: (show first isKindOf: GLMFinder).  show startOn: 42.  self assert: show first panes size equals: 1.  self assert: (show first panes first port: #entity) value equals: 42matchingTag: anItem  | elementTags |  elementTags := self glamourPresentation tagsFor: anItem data to: #filter.  ((anItem children collect: [:it |  self matchingTag: it ]) reject: #isNil) ifNotEmpty: [:coll |  ^(self newStaticItemFrom: anItem)           children: coll asArray;           yourself ].  ^(self tagsToFilterBy allSatisfy: [:each |  elementTags includes: each ]) ifFalse: [ nil ] ifTrue: [ self newStaticItemFrom: anItem ]widthDependencies  ^widthDependencies ifNil: [ widthDependencies := OrderedCollection new ]enableElementIndex  self parameters at: 'withRowIndex' put: trueamountToShow  ^(amountToShowBlock ifNil: [ [ self defaultAmountToShow ] ]) glamourValue: self entitycustomDependencies: aBrick  ^self subclassResponsibilitychangePortsAccordingToPaneMapping: newPanesMapping  self destination: ((newPanesMapping at: self destination pane) port: self destination name)selectedColor: anObject  selectedColor := anObjecttree  ^self custom: GLMTreePresentation newstrongSelection  ^(self pane port: #strongSelection) valueminimumPageNumberForScrollbar: aNumber  minimumPageNumberForScrollbar := aNumberactionName  ^self parameters at: 'actionName' ifAbsent: 'Validate'rowMorphElementsForColumn: glamourColumn node: aNode withIndex: aRowIndex  | rowElements contentMorph tagMorphs |  contentMorph := glamourColumn modifiedBlock ifNotNil: [ self editRowMorphForColumn: glamourColumn node: aNode withIndex: aRowIndex ] ifNil: [ self viewRowMorphForColumn: glamourColumn node: aNode withIndex: aRowIndex ].  rowElements := OrderedCollection new     add: contentMorph;     yourself.  tagMorphs := self tagMorphsFrom: glamourColumn for: aNode.  tagMorphs ifNotEmpty: [ rowElements addAll: tagMorphs ].  ^rowElementssend: treeMorph mouseUpOnItem: treeNodeMorph  ^self send: treeMorph mouseUpWithShift: false onItem: treeNodeMorphisMorphBrick  ^trueselectionAct: aBlock iconName: aSymbol on: aCharacter entitled: aString  self selectionAct: aBlock icon: (self iconNamed: aSymbol) on: aCharacter entitled: aStringinitializeOn: aPort previouslyValued: anObject  self initializeOn: aPort previouslyValued: anObject in: OrderedCollection newrightShadowOf: aBrick on: aCanvas  | gradient width origin |  width := aBrick shadowWidth.  origin := aBrick brickBounds topRight + (width negated @ width / 2.0) + aBrick shadowOffset.  gradient := (self shadowGradientFor: aBrick)     origin: origin;     direction: width @ 0;     yourself.  aCanvas fillRectangle: (origin extent: width @ (aBrick height - width)) fillStyle: gradientcolorBottom  ^self color at: BottomtestAddAndUpdateBrowserManually  entity add: 4.  self assert: unupdatedListMorph model roots size equals: 3.  browser update.  self assert: unupdatedListMorph model roots size equals: 4.  entity add: 5.  browser panes first presentations update.  self assert: unupdatedListMorph model roots size equals: 5newContentBrick  ^GLMBandBrick new     hShrinkWrap;     vShrinkWrap;     yourselfscrollDown: anInteger  band brickBounds corner x <= self width ifTrue: [ ^self ].  band brickBounds: (band brickBounds translateBy: (anInteger @ 0) negated).  band brickBounds corner x < self width ifTrue: [ band brickBounds: (band brickBounds translateBy: (self width - band brickBounds corner x) @ 0) ]forbiddenAnnouncements  ^forbiddenAnnouncements ifNil: [ forbiddenAnnouncements := IdentityDictionary new ]initialize  super initialize.  vResizing := #spaceFill.  hResizing := #spaceFill.  self     beTransparent;     brickRoot: GLMBrick newrow: aBlockOrSymbol span: anInteger  ^self addRow: aBlockOrSymbol span: anIntegervalidate: anObject  ^truereceive: aTransmission  self seenTransmissions addLast: aTransmission.  ^super receive: aTransmissiontestIsPaneVisible  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self assert: pagerModel numberOfVisiblePages equals: 2.  self assert: (pagerModel isPaneVisible: 1) equals: false.  self assert: (pagerModel isPaneVisible: 2) equals: false.  self assert: (pagerModel isPaneVisible: 3) equals: false.  self assert: (pagerModel isPaneVisible: 4) equals: false.  self assert: (pagerModel isPaneVisible: 5) equals: true.  self assert: (pagerModel isPaneVisible: 6) equals: truetestSymbolAsOriginIdentifier  self assert: (#pane asGlamourOriginIdentifier isKindOf: GLMPortIdentifier).  self assert: #pane asGlamourOriginIdentifier paneName equals: #pane.  self assert: #pane asGlamourOriginIdentifier portName equals: #selectionbePassive  active := falseinitialize  super initialize.  self fillStyle: (Color lightBlue alpha: 0.2)oldPane: anObject  oldPane := anObjecttestDynamicActionsAreUpdated  < expectedFailure>  | browser toolbar status count |  count := 0.  browser := GLMTabulator new.  browser addStatusbar.  browser row: #one.  browser transmit     to: #one;     andShow: [:composite |  composite list           title: 'List 1';           dynamicActions: [:list |  | actions |              status := true.              actions := OrderedCollection new.              actions add: (GLMGenericAction new                       action: [:presentation :model |  browser update ];                       icon: GLMUIThemeExtraIcons glamorousAdd;                       title: count asString;                       yourself).              actions ] ].  window := browser openOn: (1 to: 10).  status := false.  count := 1.  browser update.  self assert: status.  toolbar := self findLast: ToolDockingBarMorph in: window.  self assert: toolbar submorphs first model title equals: '1'origins  ^self originReferences collect: [:each |  each port ]addColumn: aBlockOrSymbol  | newColumn cell |  cell := aBlockOrSymbol isSymbol ifTrue: [ self browser addNewPaneNamed: aBlockOrSymbol.        GLMCustomColumn new           id: aBlockOrSymbol;           browser: self browser ] ifFalse: [ newColumn := GLMCustomColumn new browser: self browser.        aBlockOrSymbol value: newColumn.        newColumn ].  self children addLast: cell.  ^cellintercellSpacing: aNumber  self parameters at: 'intercellSpacing' put: aNumberbuttonModel  ^buttonModelcheckbox  ^self addBrickBack: self newCheckboxhandleMouseOver: anEvent  super handleMouseOver: anEvent.  isResizing | (self isLeftResizingZone: anEvent) | (self isRightResizingZone: anEvent) ifTrue: [ self setCursorToResizing: anEvent ] ifFalse: [ self setCursorToNormal: anEvent ]task  ^task ifNil: [ task := [  ] ]contentBackgroundColor  ^Color transparentfindLastSatisfying: aBlock in: aMorph  | lastMatch |  lastMatch := nil.  aMorph allMorphsDo: [:each |  (aBlock value: each) ifTrue: [ lastMatch := each ] ].  ^lastMatch ifNil: [ self fail ]oldMatchingPresentations  ^oldMatchingPresentationsscrollPane  ^scrollPanecalculateTextPosition  self textPosition = #leftCenter ifTrue: [ ^(self brickBounds origin + self textPositionVerticalCenter) truncated ].  self textPosition = #center ifTrue: [ ^(self brickBounds origin + self textPositionVerticalCenter + self textPositionHorizontalCenter) floor ].  self textPosition = #leftTop ifTrue: [ ^self brickBounds origin ].  self textPosition = #rightCenter ifTrue: [ ^(self brickBounds topRight + self textPositionVerticalCenter - (self textSize x @ 0) max: self brickBounds origin) floor ].  ^self brickBounds originsorted  sortBlock := [:a :b |  a < b ]renderGlamorouslyOn: aRenderer  ^aRenderer renderTabulator: selfinitialize  super initialize.  transmissionStrategy := GLMNoStrategy new.  condition := truescrollbarPosition  ^self valueOfProperty: #brickScrollbarPosition ifAbsent: [ self themer scrollbarPosition ]layout  ^self layoutPropertiessize  ^self presentations sizepresentations: aCompositePresentation  self notingPresentationChangeDo: [ presentations pane: nil.        presentations resetAnnouncer.        aCompositePresentation pane: self.        presentations := aCompositePresentation.        presentations initializePresentation ]renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^self arrangement renderGlamorouslyOn: aRenderertestThreePanesTransmissions  | browser two |  browser := GLMTabulator new.  browser     column: #one;     column: #two;     column: #three.  browser transmit     to: #three;     from: #one;     passivelyFrom: #two;     andShow: [:a |  a text display: [:x :y |  two := y ] ].  self assert: browser transmissions size equals: 1.  self assert: browser transmissions first passiveOrigins size equals: 1.  self assert: browser transmissions first activeOrigins size equals: 1.  ((browser paneNamed: #two) port: #selection) value: 15.  self assert: ((browser paneNamed: #two) port: #selection) value equals: 15.  self assert: ((browser paneNamed: #three) port: #entity) value isNil.  ((browser paneNamed: #one) port: #selection) value: 20.  self assert: ((browser paneNamed: #one) port: #selection) value equals: 20.  self assert: ((browser paneNamed: #three) port: #entity) value first equals: 20.  self assert: ((browser paneNamed: #three) port: #entity) value last equals: 15testCreation  self deny: GLMNoBrowser new isNil.  self assert: GLMNoBrowser new identicalTo: GLMNoBrowser newprimarySelectionInterval  ^primarySelectionIntervalremoveLastPane  self panes last unregisterFromAllAnnouncements.  ^self panes removeLasthighlightedText  ^highlightedString ifNil: [ highlightedString := '' ]testPrivateRecomputeIndexesAfterScrollAt  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 1.  pagerModel privateRecomputeIndexesAfterScrollAt: 1.0.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 1.  pagerModel privateRecomputeIndexesAfterScrollAt: 0.0.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 1.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel privateRecomputeIndexesAfterScrollAt: 0.0.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 2.  pagerModel privateRecomputeIndexesAfterScrollAt: 0.85.  self assert: pagerModel firstVisiblePageIndex equals: 4.  self assert: pagerModel lastVisiblePageIndex equals: 5.  pagerModel privateRecomputeIndexesAfterScrollAt: 0.9.  self assert: pagerModel firstVisiblePageIndex equals: 5.  self assert: pagerModel lastVisiblePageIndex equals: 6.  pagerModel privateRecomputeIndexesAfterScrollAt: 0.875.  self assert: pagerModel firstVisiblePageIndex equals: 5.  self assert: pagerModel lastVisiblePageIndex equals: 6.  pagerModel privateRecomputeIndexesAfterScrollAt: 1.0.  self assert: pagerModel firstVisiblePageIndex equals: 5.  self assert: pagerModel lastVisiblePageIndex equals: 6textColor  ^self color whitenminWidth: anObject  minWidth := anObjectmargin  ^self wrappedBounds margintestPanePushAnnouncement  | count currentAnn paneMorph |  count := 0.  paneMorph := self createSimplePaneMorph.  pagerModel announcer when: GLMPagePushed do: [:ann |  count := count + 1.        currentAnn := ann ].  pagerModel pushPane: paneMorph smooth: false.  self assert: count equals: 1.  self assert: currentAnn morph equals: paneMorph.  paneMorph := self createSimplePaneMorph.  pagerModel pushPane: paneMorph smooth: false.  self assert: count equals: 2.  self assert: currentAnn morph equals: paneMorph.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self assert: count equals: 4normalStyleFor: aBrick  aBrick fillStyle: (self normalBackgroundStyleFor: aBrick).  aBrick borderStyle: (self normalBorderStyleFor: aBrick)align: aBrick in: parentBrick anchorPoint: aPoint inContext: aContext  ^self subclassResponsibilitytranslateX: anInteger  self wrappedBounds translateX: anIntegertestStatusbar  | browser statusMorph |  browser := GLMTabulator new.  browser addStatusbar.  browser row: #one.  browser transmit     to: #one;     andShow: [:a |  a list display: #(1 2 3) ].  window := browser openOn: 42.  ((browser paneNamed: #one) port: #status) value: 2.  self waitUntilUIRedrawed.  statusMorph := (window submorphs last: 2) first submorphs first.  self assert: (statusMorph isKindOf: LabelMorph)scrollbarPosition: aSymbol  self setProperty: #brickScrollbarPosition toValue: aSymbol.  self updateStyle* aNumber  ^self direction * aNumberports  ^ports ifNil: [ ports := OrderedCollection new ]initialize  super initialize.  hState := GLMBrickLayoutDummState new.  vState := GLMBrickLayoutDummState newglamourValueWithArgs: anArray  ^anArray allSatisfy: [:each |  each isNil ]hasPane  ^self pane notNilcheckedFocusedIcon: aForm  checkedFocusedIcon := aFormnotify: aString at: anInteger in: aStream  | pos |  pos := self editor selectionInterval notEmpty ifTrue: [ self editor startIndex + anInteger - 1 ] ifFalse: [ anInteger ].  self editor selectFrom: pos to: pos.  GLMErrorPopper installAlarm: #popupError: for: self withArguments: {aString}updateDimension: aBrick  ^self subclassResponsibilityhMargin  ^self marginLeft + self marginRightrenderDynamicPresentation: aPresentation  ^GLMMorphicDynamicRenderer render: aPresentation from: selfhighlightSmalltalk  ^highlightSmalltalk ifNil: [ highlightSmalltalk := false ]owner  ^ownertagsBlock  ^tagsBlockisInsideOfTriggerBrick: anEvent  self triggerBrick ifNil: [ ^false ] ifNotNil: [:aBrick |  anEvent withHandPositionDo: [:position |  ^aBrick globalBounds containsPoint: position ] ]valueFor: anElement withIndex: anInteger in: aGlamourColumn  ^self cacheAt: aGlamourColumn title for: anElement ifAbsentPut: [ self glamourPresentation column: aGlamourColumn valueFor: (self glamourPresentation isWithElementIndex ifTrue: [ anElement asGlamorousMultiValue , anInteger asGlamorousMultiValue ] ifFalse: [ anElement ]) ]check: aBoolean  aBoolean ifTrue: [ self check ] ifFalse: [ self uncheck ]renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderFastListPresentation: selffrom: anOriginPortReference  self lastTransmission addActiveOrigin: (self resolveOriginPort: anOriginPortReference)terminate  process ifNotNil: [ process terminate.        process := nil ]testUnregisterAnnouncementsWhenUpdatingPane  | announcer browser |  announcer := Announcer new.  browser := GLMTabulator new.  browser row: #one.  browser transmit     to: #one;     andShow: [:presenter |  presenter list           updateOn: GLMTestAnnouncement from: [ announcer ];           display: [:start |  start to: 10 ] ].  browser startOn: 1.  browser panes first presentations first registerAnnouncements.  browser unregisterFromAllAnnouncements.  self assert: announcer numberOfSubscriptions equals: 0dropOnItemBlock  ^dropOnItemBlockevaluateAndPopPrintHighlight  GLMPrintPopper installAlarm: #popupPrint for: selftestTreeMultipleSelectionWithCancellation  | browser treeNodeMorph lastTreeNodeMorph |  browser := GLMFinder new.  browser show: [:a |  a tree beMultiple allowDeselection ].  window := browser openOn: ($a to: $d).  treeNodeMorph := self treeVisibleItems first.  lastTreeNodeMorph := self treeVisibleItems last.  self send: self tree mouseUpOnItem: treeNodeMorph.  self send: self tree mouseUpWithShift: true onItem: lastTreeNodeMorph.  self send: self tree mouseUpOnItem: treeNodeMorph.  self send: self tree mouseUpOnItem: treeNodeMorph.  self assert: (browser panes first port: #selection) value isNillayoutChanged  super layoutChanged.  self morph ifNil: [ ^self ].  self isShrinking ifFalse: [ ^self ].  isLayouting ifTrue: [ ^self ].  isLayouting := true.  self changed.  self isHShrinking ifTrue: [ self width: [ self shrinkingWidth + self hPadding ] ].  self isVShrinking ifTrue: [ self height: [ self shrinkingHeight + self vPadding ] ].  self invalidateMorphBounds: true.  isLayouting := falseasFormValue  ^nilactOnKeyStroke: aPresentation event: anEvent from: aMorph  anEvent commandKeyPressed ifFalse: [ ^self ].  (self allKeyboardActionsFor: aPresentation) detect: [:each |  each shortcut = anEvent keyCharacter ] ifFound: [:action |  action actOn: aPresentation ]checkboxHeight  ^18testBundleTransmissionWithTransformation  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #one;     andShow: [:a |  a text ].  browser transmit     from: #one transformed: [:x |  x + 1 ];     to: #two;     andShow: [:a |  a text ].  browser startOn: 1.  ((browser paneNamed: #one) port: #selection) value: 41.  self assert: ((browser paneNamed: #two) port: #entity) value equals: 42modelFor: aPresentation  ^(super modelFor: aPresentation)     bindingsStrategy: self methodBindingsStrategy;     appendVariableBinding: aPresentation variableBindings;     yourselfdimensionPolicy: aBrick  ^(self stateOf: aBrick) layoutPolicy: aBrick on: selfmorphicAct: aBlock icon: anIcon entitled: aString  self addAction: (GLMMorphicAction new           action: aBlock;           title: aString;           icon: anIcon;           yourself)renderBackgroundColorOf: aBrick on: aCanvas in: aRectangle  aCanvas fillRectangle: aRectangle color: aBrick color.  aBrick fillStyle = Color transparent ifFalse: [ aCanvas fillRectangle: aRectangle fillStyle: aBrick fillStyle borderStyle: aBrick borderStyle ]isEmpty  ^self presentations isEmptyinitialize  super initialize.  self initializeInspectButton.  self initializeTextMorphseparator  ^GLMMorphic emptyMorphcolor  ^color ifNil: [ color := Array braceWith: Color transparent with: Color transparent with: Color transparent with: Color transparent ]pane: aPane  pane := aPaneprimarySelectionInterval  ^primarySelectionIntervalinitialize  super initialize.  anchorBrick := Morph new extent: 1 @ 1.  popupLayout := self defaultPopupLayout.  closer := self defaultCloser.  inset := self themer popupThemer inset asMargin.  spacing := self themer popupThemer spacing.  self     initializeListeners;     useVerticalLinearLayout;     vShrinkWrap;     hShrinkWrap;     enable;     initializeLayouttestMinHeightOneStatic  | brick |  brick := self newBrickWithSmallStaticExtent.  brick minHeight: self staticHeight.  brick doLayoutForce.  self assertAllSubbricksAreClean: brick.  self assert: brick brickBounds equals: (0 @ 0 extent: self staticSmallWidth @ self staticHeight)render: aPresentation  | textMorph |  textMorph := (DiffMorph from: aPresentation displayValue first to: aPresentation displayValue last contextClass: aPresentation contextClassValue)     layoutFrame: LayoutFrame identity;     vResizing: #spaceFill;     hResizing: #spaceFill;     yourself.  ^textMorphnewLabelBrick  ^GLMLabelBrick newtext  ^self custom: GLMPhlowTextBrick newnewScrollPane  | sp |  sp := GLMRubTextScrollPane new.  sp scrollTarget: self defaultScrollTarget.  ^spisVSpaceFill  ^self vState isOnParentrubricBackgroundColor  ^self contentBackgroundColorwithSeparators  self parameters at: 'withSeparators' put: trueprivateSubbricks: aCollection  submorphs := aCollectionaddAction: anAction  self actions addLast: anActionbrickBounds  ^self wrappedBounds brickBoundsmenuMorph  ^menuMorphtestDynamic  | browser childBrowser |  childBrowser := GLMFinder new.  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a custom: (GLMDynamicPresentation new display: [ childBrowser ]) ].  browser startOn: 42.  self assert: browser panes first presentations first currentPresentation first identicalTo: childBrowser.  self assert: childBrowser pane identicalTo: browser panes firstwithHeight: anInteger  self wrappedBounds height: anIntegertestTreeMultipleSelection  | browser treeNodeMorph lastTreeNodeMorph |  browser := GLMFinder new.  browser show: [:a |  a tree beMultiple ].  window := browser openOn: ($a to: $d).  treeNodeMorph := self treeVisibleItems first.  lastTreeNodeMorph := self treeVisibleItems last.  self send: self tree mouseUpOnItem: treeNodeMorph.  self send: self tree mouseUpWithShift: true onItem: lastTreeNodeMorph.  self assert: (browser panes first port: #selection) value notNil.  self assert: (browser panes first port: #selection) value asSet equals: ($a to: $d) asSetupdateVisibleTop: invisibleBricks  | before |  before := self band hasSubbricks not ifFalse: [ self band firstSubbrick ] ifTrue: [ self addBrickBackNoLayout: (self getMorphAt: self visibleIndex recycled: (self getAndRemoveInvisibleMorph: invisibleBricks)) ].  [ before isNotNil and: [ (self isPartiallyVisible: before) and: [ (self getIndex: before) > 1 ] ] ] whileTrue: [ before := self addItemMorph: (self getMorphAt: (self getIndex: before) - 1 recycled: (self getAndRemoveInvisibleMorph: invisibleBricks)) before: before ]brickRoot  ^brickRootselectionAct: aBlock icon: anIcon on: aCharacter entitled: aString  self addSelectionAction: (GLMGenericAction new           action: aBlock;           icon: anIcon;           shortcut: aCharacter;           title: aString;           yourself)checkedIcon  ^checkedIconsouth  direction := Southrenderer: anObject  renderer := anObjectinitializeTextMorph  textMorph := RubScrolledTextMorph new.  textMorph     beReadOnly;     beWrapped;     textFont: self theme textFont;     textColor: self theme textColor;     backgroundColor: BalloonMorph balloonColor.  self     vResizing: #spaceFill;     hResizing: #spaceFill;     addMorph: textMorph fullFrame: LayoutFrame identityvalidate: anObject on: aPort  self shouldValidate ifFalse: [ ^true ].  ^self doValidate: anObject on: aPortbeHelp  self beMode: #beHelpindex  ^indexbeUpward  self popupLayout: GLMPopupBrickUpwardLayout newactOnHighlightAndEvaluate: ann  UIManager default defer: [ textMorph textArea handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: ann action.              textMorph shoutStyler style: textMorph text ] ]staticExtent  ^self staticWidth @ self staticHeighthasMinDimensionRestriction: aBrick  ^aBrick layout hasMinHeightpresentation: aPresentation  presentation := aPresentationtext: anObject  text := anObjectprintOn: aStream  super printOn: aStream.  aStream     nextPut: Character space;     nextPutAll: self identityHash printString;     nextPutAll: ' ('.  port printOn: aStream.  aStream nextPut: $)testSelectionChangeAfterPopOfLastPage  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self assert: pagerModel selectedPageIndex equals: 1.  pagerModel selectedPageIndex: 5.  self assert: pagerModel selectedPageIndex equals: 5.  pagerModel popPane.  self assert: pagerModel selectedPageIndex equals: 4.  self assert: pagerModel size equals: 4.  self assert: pagerModel firstVisiblePageIndex equals: 3.  self assert: pagerModel lastVisiblePageIndex equals: 4.  self assert: pagerModel numberOfVisiblePages equals: 2.  pagerModel popPane.  self assert: pagerModel selectedPageIndex equals: 3.  self assert: pagerModel size equals: 3.  self assert: pagerModel firstVisiblePageIndex equals: 2.  self assert: pagerModel lastVisiblePageIndex equals: 3.  self assert: pagerModel numberOfVisiblePages equals: 2.  pagerModel popPane.  self assert: pagerModel selectedPageIndex equals: 2.  self assert: pagerModel size equals: 2.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 2.  self assert: pagerModel numberOfVisiblePages equals: 2.  pagerModel popPane.  self assert: pagerModel selectedPageIndex equals: 1.  self assert: pagerModel size equals: 1.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 1.  self assert: pagerModel numberOfVisiblePages equals: 2formatedDisplayValueOf: anElement  ^self cacheAt: #formatedDisplayValue for: anElement ifAbsentPut: [ self glamourPresentation formatedDisplayValueOf: anElement ]initialize  super initialize.  self     useVerticalLinearLayout;     titleBrick: self newTitleBrick;     hSpaceFill;     vSpaceFillhintText: aBrick  hintText := aBrick.  self hintBrick ifNotNil: [ self hintBrick text: self hintText ]addPresentations: aCollection  aCollection do: [:each |  self addPresentation: each ]renderTablePresentation: aPresentation  ^GLMMorphicTableRenderer render: aPresentation from: selftestOneFixedSizePane  | finder |  finder := GLMFinder new fixedSizePanes: 1.  window := finder openOn: 40.  self assert: window submorphs last submorphs first submorphs first width equals: window submorphs last width.  (finder panes first port: #selection) value: 42.  self assert: window submorphs last submorphs last submorphs size equals: 3.  self assert: window submorphs last submorphs last submorphs first extent equals: window submorphs last submorphs last submorphs last extent.  self assert: window submorphs last submorphs last submorphs first width equals: window submorphs last widthaddColumn: aBlockOrSymbol span: anInteger  ^(self addColumn: aBlockOrSymbol)     span: anInteger;     size: 0testNestedBrowsersWithMultipleOrigins  | browser innerBrowser transmittedOne transmittedTwo |  innerBrowser := GLMTabulator new.  innerBrowser row: #inner.  innerBrowser transmit     to: #inner;     andShow: [:a |  a text ].  browser := GLMTabulator new.  browser     column: #one;     column: #two;     column: #three.  browser transmit     to: #three;     from: #one;     from: #two;     andShow: [:a |  a custom: (innerBrowser display: [:one :two |  transmittedOne := one.                    transmittedTwo := two ]) ].  browser startOn: 1.  ((browser paneNamed: #one) port: #selection) value: 1.  ((browser paneNamed: #two) port: #selection) value: 2.  self assert: transmittedOne equals: 1.  self assert: transmittedTwo equals: 2computeTagsFor: aGlamourValue from: aBlock  | value |  aBlock ifNil: [ ^OrderedCollection new ].  value := aBlock glamourValue: aGlamourValue.  ^value isString ifTrue: [ OrderedCollection with: value ] ifFalse: [ value asOrderedCollection ]hasTags  ^self tagsBlock notNilrender: aPresentation  | container |  container := super render: aPresentation.  aPresentation shouldRootsExpand ifTrue: [ treeMorph expandRoots.        treeMorph makeLastColumnBounded ].  ^containerallowSeparators  ^self parameters at: 'withSeparators' ifAbsent: [ false ]executeFilter  self updateRootstearDown  GLMLogger reset.  super tearDowntestMarkerOneChildrenInChildrenHeight  | root brick |  root := self newBrickWithFullDependsOnChildren.  brick := self newBrickWithFullDependsOnChildren.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthClean.  self assert: brick wrappedBounds isHeightDirty.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightDirtystart: anObject  start := anObjectaction  ^actionisFirstVisible  self band hasSubbricks ifFalse: [ ^true ].  ^self isVisible: self band firstSubbrickmatchingPresentations  ^cachedMatchingPresentations := presentations matchingPresentationsunregisterFromAllAnnouncements  super unregisterFromAllAnnouncements.  self presentations do: [:each |  each unregisterFromAllAnnouncements ]renderPane: aPane  ^GLMMorphicPaneRenderer render: aPane from: selfinitialize  super initialize.  self     useVerticalLinearLayout;     vShrinkWraptext  ^textleft  ^GLMWestDirection uniqueInstancepane  ^panerenderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderDropDownListPresentation: selfallKeyboardActionsFor: aPresentation  ^aPresentation allActions , aPresentation allSelectionActions select: [:action |  action hasShortcut ]scrollpane  ^scrollpanepresentation  ^GLMCompositePresentation new with: [:a |  | t |        t := a text.        t withLineNumbers: true.        t withAnnotation: true.        t wrapped: true.        t tabWidth: 40.        t withColumns: true ]testNoOverrideStrategy  | pane1 pane2 transmission presentation |  pane1 := GLMPane named: 'pane1'.  pane2 := GLMPane named: 'pane2'.  transmission := GLMTransmission new.  transmission ensurePresentIfNoneStrategy.  transmission addActiveOrigin: (pane1 port: #port1).  transmission destination: (pane2 port: #port2).  transmission addPresentation: GLMPresentation new.  self assert: transmission presentations size equals: 1.  self assert: transmission destination pane identicalTo: pane2.  self assert: transmission transmissionStrategy transmission identicalTo: transmission.  (pane1 port: #port1) value: 1.  transmission transmit.  self assert: pane2 presentations size equals: 1.  presentation := pane2 presentations first.  self assert: transmission destination pane identicalTo: pane2.  (pane1 port: #port1) value: 2.  transmission transmit.  self assert: pane2 presentations first rootPrototype equals: presentation rootPrototype.  self assert: pane2 presentations first identicalTo: presentationinset  ^self borderWidthaddLazyPage: aBlock label: aStringOrMorph toolbar: aToolbar collapsable: aBoolean  | newPage label |  newPage := LazyTabPage new.  newPage     lazyPageMorphCreation: aBlock;     labelMorph: aStringOrMorph;     toolbar: aToolbar.  label := self buildLabelFrom: aStringOrMorph withAction: (aBoolean ifTrue: [ GLMActionButtonBrick new                 action: [ self removePage: newPage ];                 icon: self theme windowCloseForm ] ifFalse: [ nil ]).  self addPage: newPage label: labelelementOrZeroAt: rowIndex  ^rowIndex = 0 ifTrue: [ 0 ] ifFalse: [ self elementAt: rowIndex ]color  ^colorisColorSet  ^self hasProperty: #brickBackgroundColorisCompleted  ^isCompleted ifNil: [ isCompleted := false ]rowHeight  ^self rowHeightBlock glamourValue: self asGlamorousMultiValue , self entity asGlamorousMultiValuepanes: blocksOrSymbols  ^blocksOrSymbols do: [:each |  self aPane: each ]passivelyFrom: aPort  ^self addPassiveOrigin: (self browser resolveOriginPort: aPort)fontSize: aNumber  < brickBuilderProperty: #Text name: 'Font size' as: #asInteger getter: #fontSize model: #GLMUIBuilderTextFieldProperty>  self label fontSize: aNumber.  self dotsBrick fontSize: aNumberdimension  ^dimensiontextMorphForModel: aTextModel  | morph |  morph := RubPluggableTextMorph new.  morph styler workspace: aTextModel.  morph     on: aTextModel text: #text accept: #accept:notifying: readSelection: #selection menu: #menu:shifted:;     changedAction: [:aText |  aText asString trimBoth ifNotEmpty: [ aTextModel text: aText ] ];     onKeyStrokeSend: #keystroke:from: to: aTextModel;     layoutFrame: LayoutFrame identity;     vResizing: #spaceFill;     hResizing: #spaceFill;     color: self theme backgroundColor;     font: StandardFonts codeFont;     yourself.  ^morphtestEntityPropogation  | browser1 browser2 presentation innerBrowser transmission1 transmission2 |  browser1 := GLMExplicitBrowser new.  browser2 := GLMExplicitBrowser new.  presentation := GLMPresentation new.  browser1 title: 'browser1'.  browser2 title: 'browser2'.  browser1 addNewPane name: 'pane1'.  browser2 addNewPane name: 'innerpane 1'.  transmission1 := GLMTransmission new ensureReplacePresentationsStrategy.  transmission1 transmissionStrategy addPresentation: browser2.  browser1 addTransmission: (transmission1           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: browser1;                 name: #entity;                 yourself);           destination: (browser1 panes first port: #entity);           yourself).  transmission2 := GLMTransmission new ensureReplacePresentationsStrategy.  transmission2 transmissionStrategy addPresentation: presentation.  browser2 addTransmission: (transmission2           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: browser2;                 name: #entity;                 yourself);           destination: (browser2 panes first port: #entity);           yourself).  self assert: (browser1 pane port: #entity) value isNil.  self assert: browser1 panes size equals: 1.  self assert: (browser1 panes first port: #entity) value isNil.  self assertEmpty: browser1 panes first presentations.  self assert: browser2 panes size equals: 1.  self assert: (browser2 panes first port: #entity) value isNil.  self assertEmpty: browser2 panes first presentations.  (browser1 pane port: #entity) value: 42.  self assert: (browser1 pane port: #entity) value equals: 42.  self assert: browser1 panes size equals: 1.  self assert: (browser1 panes first port: #entity) value equals: 42.  self assert: browser1 panes first presentations size equals: 1.  innerBrowser := browser1 panes first presentations first.  self assert: innerBrowser rootPrototype equals: browser2.  self assert: innerBrowser pane identicalTo: browser1 panes first.  self assert: innerBrowser panes size equals: 1.  self assert: (innerBrowser panes first port: #entity) value equals: 42.  self assert: innerBrowser panes first presentations size equals: 1.  self assert: innerBrowser panes first presentations first rootPrototype equals: presentationlastActivePresentation: aPresentation  lastActivePresentation := aPresentationbindingThemer  ^self registerModule: GTPlayBindingDarkThemer new to: GLMActionBrickDarkThemer newrender: aPresentation  ^self subclassResponsibilitybeRegular  self font     forceNotBold;     forceNotItalictestUpdateBrowserTitle  browser title: 'something'.  browser update.  self assert: window label equals: 'something'noTitleIcon  titleIcon := nilexpandLevel  ^expandLevelvalue  ^valueremovePageIndex: anInteger  self removePage: (self pages at: anInteger)highlightSmalltalk: anObject  highlightSmalltalk := anObjectlayoutIn: aBrick  self     markDependent: aBrick;     layout: aBricktoOutsidePort: aPortSymbol  ^self to: #outer -> aPortSymbolopenHintPopup: aMode  self closePopup.  hintBrick := GLMPopupBrick new     beUpward;     hintText: self hintText;     titleText: self hintTitle;     perform: aMode withEnoughArguments: {};     openOn: selftestExplicitAcceptDoesNotAffectTextPort  | composite textMorph |  composite := GLMCompositePresentation new with: [:a |  a text display: '123' ].  window := composite openOn: 4.  window position: 0 @ 0.  window extent > Display extent ifTrue: [ ^self ].  textMorph := self find: RubScrolledTextMorph in: window.  self simulateOnlyOneClickOn: textMorph.  self simulateKeyStrokes: '4'.  self assert: (composite pane port: #text) value equals: '1234'.  self simulateKeyStroke: $s meta.  self simulateKeyStrokes: '56'.  self assert: (composite pane port: #text) value equals: '123456'setBoundsOf: aMorph before: beforeMorph  | origin corner |  aMorph withWidth: self band width.  corner := beforeMorph brickBounds topRight.  origin := beforeMorph brickBounds topLeft - (0 @ aMorph height).  aMorph brickBounds: (origin corner: corner)sendUsageData  ^self class environment at: #Privacy ifPresent: [:privacy |  privacy sendDiagnosticsAndUsageData ] ifAbsent: [ false ]onChildrenLayouted  self doNotUpdateDuring: [ self update ]act: aBlock on: aCharacter entitled: aString categorized: anotherString  self addAction: (GLMGenericAction new           action: aBlock;           shortcut: aCharacter;           title: aString;           category: anotherString;           yourself)withAllPanesAndPresentationsDo: aBlock  super withAllPanesAndPresentationsDo: aBlock.  self panes do: [:each |  each withAllPanesAndPresentationsDo: aBlock ]bindingThemer  ^self registerModule: GTPlayBindingThemer new to: GLMActionBrickThemer newincludes: aPresentation  ^self presentations includes: aPresentationbrickThemerChanged  self brickRoot themerChangedrowHeight  ^self rowHeightBlock glamourValue: self asGlamorousMultiValue , self entity asGlamorousMultiValuehasChildrenBlock  ^self parameters at: 'hasChildrenBlock' ifAbsent: [ nil ]isAvailableOn: aPresentation  ^self condition glamourValueWithArgs: (Array with: aPresentation withAll: aPresentation entity asGlamorousArray)toggle  self isChecked ifTrue: [ self uncheck ] ifFalse: [ self check ]initialize  super initialize.  panes := OrderedCollection new.  transmissions := OrderedCollection newfontSize  ^fontSizetextBrick: aBrick  super textBrick: aBrick.  self textBrick beForSmalltalkCode beReadOnlycolumn: aBlockOrString evaluated: aBlock tags: anObject filtered: anotherObject  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           tagsBlock: anObject;           tagsFilter: anotherObject)openCenteredInBrickWindow  self openCenteredInBrickWindowLabeled: selfwith: aBlock  self presentationTransformation: aBlockaddPassiveOrigin: aPort  ^self originReferences add: (GLMOriginPortReference new           port: aPort;           bePassive;           yourself)populate: aPortSymbol icon: anIcon on: aCharacter entitled: aString with: aBlock  self addAction: (GLMGenericAction new           action: (GLMPortUpdater new                 portSymbol: aPortSymbol;                 valueBlock: aBlock;                 yourself);           shortcut: aCharacter;           icon: anIcon;           title: aString;           yourself)backgroundColor  ^Color r: 251 g: 201 b: 193 range: 255doNotNotifyDuring: aBlock  | allowed |  allowed := self isNotificationsAllowed.  isNotificationsAllowed := false.  aBlock cull: self.  allowed ifTrue: [ isNotificationsAllowed := true ]testCreationWithTransmissionContext  | anEvent aContext portOne portTwo |  aContext := OrderedCollection new.  portOne := GLMSimplePort new     name: #portOne;     value: 1.  portTwo := GLMSimplePort new     name: #portTwo;     value: 2.  anEvent := GLMPortEvent on: portOne previouslyValued: portTwo in: aContext.  self assert: anEvent port equals: portOne.  self assert: anEvent oldValue equals: portTwo.  self assert: anEvent transmissionContext equals: aContexttestInfinity  window := GLMScrollListBrick exampleInfinity.  self assert: window isSystemWindowcomposite: aBlock  | composite |  composite := GLMCompositePresentation new.  aBlock value: composite.  ^self custom: compositeisHFilling  ^hResizing = #spaceFillwhiten  ^Color brickColorRegistry at: #brickWhiten ifAbsentPut: [ Color r: 241 g: 241 b: 241 range: 255 ]testMarkerOneParentHeight  | brick |  brick := self newBrickWithFullFill.  self markFullyClean: brick.  brick wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthClean.  self assert: brick wrappedBounds isHeightDirtyscrollTo: aFloat smooth: isSmooth callback: aBlock  self privateRecomputeIndexesAfterScrollAt: aFloat.  self notifyScrollPositionChanged: isSmooth callback: aBlockdoItReceiver: aOneArgBlock  doItReceiver := aOneArgBlockfontSize: aNumber  fontSize := aNumber.  self updateFontshouldUseCache: aBoolean  ^self parameters at: 'shouldUseCache' put: aBooleanselectedImage  ^selectedImageonThemerChanged  super onThemerChanged.  self updateStylehasTags  ^self tagsBlock notNilselectionTransformation  ^self selectionTransmission transformation ifNil: [ #yourself ]newDataSourceMatching: aFTFilter  ^(super newDataSourceMatching: aFTFilter)     glamourPresentation: self glamourPresentation;     yourselfwidthParentDependency: aBrick  | allowedWidth |  aBrick owner ifNil: [ Exception signal: 'My width depends on parent, but it is nil' ].  allowedWidth := aBrick owner subbricks inject: aBrick owner innerBounds width into: [:width :each |  each isWidthClean ifTrue: [ (each layout hState isOnParent not or: [ self hasWidthRestrictions: each ]) ifTrue: [ each layout hasMaxWidth ifFalse: [ width - each outerBounds width ] ifTrue: [ width ] ] ifFalse: [ width ] ] ifFalse: [ width ] ].  ^(allowedWidth * aBrick layout hPercent / 100) ceilinginteractionModel  ^selfwith: aBlock  aBlock cull: selfonDrawAthensCanvas: aCanvas  | wrappedCanvas |  super onDrawAthensCanvas: aCanvas.  wrappedCanvas := AthensCanvasWrapper on: aCanvas.  self highlightedText isEmpty ifFalse: [ self calculateHighlightingBounds do: [:each |  self highlightingLogic ifNil: [ wrappedCanvas line: each bottomLeft to: each bottomRight width: 1 color: self textColor ] ifNotNil: [ self highlightingLogic cull: wrappedCanvas cull: each ] ] ].  aCanvas pathTransform restoreAfter: [ aCanvas pathTransform translateBy: self calculateTextPosition - self brickBounds origin.        aCanvas pathTransform translateX: 0 Y: font getPreciseAscent.        aCanvas pathTransform scaleBy: 1.0000001 @ 1.0000001.        aCanvas setPaint: self textColor.        aCanvas setFont: self font.        aCanvas drawString: self text from: 1 to: self text size ].  wrappedCanvas drawString: self text at: self calculateTextPosition - self brickBounds origin font: self font color: self textColortestMarkerOneStaticInStaticWidth  | root brick |  root := self newBrickWithStaticExtent.  brick := self newBrickWithStaticExtent.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightCleanannouncement  ^announcementtestTextPortIsPopulatedByDefault  < expectedFailure>  | composite |  composite := (GLMCompositePresentation new with: [:a |  a text ]) startOn: '42'.  self assert: composite presentations first text equals: '42'actOnEvaluateSelection: ann  ann isSyncronous ifTrue: [ textMorph textArea editor evaluateSelectionAndDo: ann action.        ^self ].  UIManager default defer: [ textMorph textArea editor evaluateSelectionAndDo: ann action ]matchingPresentations  ^self pane matchingPresentationstestMultiplePresentationsValidation  | browser |  browser := GLMFinder new.  browser show: [:a |  a list.        a text ].  window := browser openOn: ($a to: $d).  (browser panes first port: #selection) value: $z.  self assert: (browser panes first port: #selection) value equals: $ztestCopy  | context copy |  context := GLMTransmissionContext new.  context addPort: GLMSimplePort new.  copy := context copy.  self assert: copy ~~ context.  self assert: copy ports equals: context ports.  self assert: copy ports ~~ context portsfloating  ^floating ifNil: [ floating := #none ]filterStrategy  ^filterBlockcheckedColor  ^checkedColorpopupLayout  < return: #GLMPopupBrickLayout>  self assert: [ popupLayout isNotNil ] description: [ 'Popup layout can not be nil' ].  ^popupLayouthintText  ^hintText ifNil: [ hintText := 'Need help?' ]renderExpander: aBrowser  ^GLMMorphicExpanderRenderer render: aBrowser from: selftestStackedVerticallyWithTitle  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a stackedVerticallyArrangement.        a title: 'title'.        a list title: 'list'.        a text title: 'text' ].  window := browser openOn: 42.  self assert: self compositeTabGroup submorphs notEmpty.  self assert: self compositeTabGroup submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph class equals: GLMPanelMorph.  self assert: self compositeTabGroup contentMorph submorphs size equals: 1.  self assert: self compositeTabGroup contentMorph submorphs first class equals: GLMPanelMorph.  self assert: self compositeTabGroup contentMorph submorphs first submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph submorphs first submorphs first class equals: LazyTabGroupMorphdiminishToRight  self actualNumberOfVisiblePages = 1 ifTrue: [ ^self ].  self virtualFirstVisiblePageIndex: self firstVisiblePageIndex + 1.  self recomputeStatesetUp  super setUp.  GLMLogger instance: GLMMemoryLogger newtestOneSimpleColumnAndOneNested  | layout |  layout := GLMTabulator new.  layout addColumn: [:column |  column addRow: #second.        column addRow: #third.        column addRow: #fourth ].  layout addColumn: #first.  self assert: layout cell children size equals: 2.  self assert: layout cell children first children size equals: 3currentColor  ^self colorrowMorphForElement: element  | rowElements |  rowElements := OrderedCollection new.  (self iconFor: element) ifNotNil: [:icon |  rowElements add: icon asMorph ].  rowElements     add: (self formatedDisplayValueOf: element) asMorph;     addAll: (self tagMorphsFrom: self glamourPresentation for: element).  ^self theme newRowIn: self currentWorld for: rowElementsrender: aBrowser  container := GLMPaneScroller new     name: 'scroller';     vResizing: #spaceFill;     hResizing: #spaceFill;     yourself.  container maxPanes: aBrowser fixedSizePanes.  self registerAnnouncementsFor: aBrowser.  aBrowser panes do: [:each |  container pushPane: (self renderObject: each) ].  ^containeronFocusedPageChanged  self     updateButtonsFocus;     updateButtonsduration  ^duration ifNil: [ duration := 0 ]notingPresentationChangeDo: aBlock  self pane notingPresentationChangeDo: aBlockdefaultCloser  < return: #GLMPopupBrickCloser>  ^GLMPopupBrickCloser new     predicate: GLMPopupBrickUnhoverPredicate new;     yourselfbasicElements  ^self glamourPresentation displayValuevariableBindings  ^(variableBindingsBlock glamourValue: self entity) ifNil: [ OrderedCollection new ]modified: aGlamourColumn with: aText  aGlamourColumn modifiedBlock cull: aText cull: self item cull: self containerTree glamourPresentationcolorLeft: aColor  self color at: Left put: aColorexecuteMenuAction: anAction  self announcer announce: (GLMMenuItemSelected action: anAction)testHasTitle  | presentation |  presentation := GLMPresentation new.  self assert: presentation hasTitle not.  presentation title: 'something'.  self assert: presentation hasTitletitle: aBlock  aBlock cull: self titletestSimpleTransmission  | browser pane1 pane2 presentation1 presentation2 transmission announcement |  browser := GLMExplicitBrowser new.  presentation1 := GLMPresentation new.  presentation2 := GLMPresentation new.  pane1 := browser addNewPane.  pane2 := browser addNewPane.  pane1 addPresentation: presentation1.  pane2 addPresentation: presentation2.  transmission := GLMMockSimpleTransmission new     addActiveOrigin: (pane1 port: #selection);     destination: (pane2 port: #entity);     yourself.  browser addTransmission: transmission.  announcement := nil.  presentation2 when: GLMContextChanged do: [:ann |  announcement := ann ].  presentation1 selection: 'foo'.  self assert: transmission wasTransmited.  self assert: (pane1 port: #selection) value equals: 'foo'.  self assert: (pane2 port: #entity) value equals: 'foo'.  self assert: announcement notNilhState  ^GLMBrickLayoutDummState newunsubscribeDataSource: aTableModel  aTableModel announcer unsubscribe: self.  tableMorph announcer unsubscribe: aTableModeldisable  isEnabled := falsecurrentImage  ^self state pressed: self isPressed selected: self isSelected checked: self isChecked of: selfsend: aBlock as: aPortSymbol  (self rawSelectionTransmissionFor: aPortSymbol ifNone: [ self addRawSelectionTransmissionTo: aPortSymbol ]) transformation: aBlocktestFixedSize  window := GLMFinder new openOn: 123.  self assert: window submorphs last class equals: GLMPaneScrollershiftMenu  ^nilhasOwner  ^self owner isNotNilselectedTextBlock  ^selectedTextBlock ifNil: [ [ '' ] ]testStatusbarTransmissions  | browser pane |  browser := GLMBrowser new.  browser addStatusbar.  pane := GLMPane new.  browser addPane: pane.  self assert: browser transmissions size equals: 1.  self assert: browser transmissions first origins size equals: 1.  self assert: browser transmissions first origins first equals: (pane port: #status).  self assert: browser transmissions first destination equals: (browser panes first port: #entity).  self assert: (browser transmissions first presentations first isKindOf: GLMLabelPresentation)owner  ^self brick owner ifNotNil: #brickApirenderCornerShadow: aBrick vector: aVector origin: anOrigin on: aCanvas  | anInset anOffset aShadowWidth aShadowOrigin aShadowEnd aGradient aRectangle |  anOffset := aBrick shadowOffset.  aShadowWidth := aBrick shadowWidth.  (aVector rightAngle: aVector next) ifTrue: [ aGradient := self shadowGradientReverseFor: aBrick.        aShadowOrigin := aVector + anOrigin + (aVector next * aShadowWidth) + (aVector next left * aShadowWidth).        aShadowEnd := aVector + anOrigin.        aRectangle := (aVector similar: aShadowWidth) origin: aShadowOrigin breadth: aShadowWidth ] ifFalse: [ aGradient := self shadowGradientFor: aBrick.        aShadowOrigin := aVector + anOrigin.        aShadowEnd := aVector + anOrigin + (aVector left * aShadowWidth) + (aVector * aShadowWidth).        aRectangle := (aVector left similar: aShadowWidth) origin: aVector + anOrigin breadth: aShadowWidth ].  anInset := (aShadowEnd - aShadowOrigin) sign * aBrick shadowInset.  (aVector rightAngle: aVector next) ifTrue: [ aShadowOrigin := aShadowOrigin - anInset.        aRectangle := aRectangle translateBy: anInset negated ] ifFalse: [ aShadowOrigin := aShadowOrigin + anInset.        aRectangle := aRectangle translateBy: anInset ].  aShadowOrigin := aShadowOrigin + anOffset.  aRectangle := aRectangle translateBy: anOffset.  aGradient     origin: aShadowOrigin;     direction: aVector * aShadowWidth;     radial: true;     yourself.  aCanvas fillRectangle: aRectangle fillStyle: aGradientasGlamorousArray  ^self asArraynewRubricMorph  ^RubScrolledTextMorph newrenderFastTablePresentation: aPresentation  ^GLMMorphicFastTableRenderer render: aPresentation from: selfposition  ^positionhasTagsFilter  ^self columns anySatisfy: [:aColumn |  aColumn hasTagsFilter ]hShrinkWrap  self hResizing: #rigid.  self width: #approximateWidthfilterBlock  ^self parameters at: 'filterBlock'testToPort  browser transmit to: #one port: #port.  self assert: browser transmissions first destination pane equals: browser panes first.  self assert: browser transmissions first destination name equals: #portselectionInterval  ^(self pane port: #selectionInterval) valuefastTree  ^self custom: GLMFastTreePresentation newallowsDeselection  ^allowsDeselection ifNil: [ allowsDeselection := false ]