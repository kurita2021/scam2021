foundationBrick  ^(self owner isKindOf: GLMFoundationBrick) ifTrue: [ self owner ] ifFalse: [ self ]-=JUAMPI=-renderBorder: aBrick on: aCanvas  aCanvas drawPolygon: aBrick area vertices color: Color transparent borderWidth: aBrick border widthTop borderColor: aBrick border colorTop-=JUAMPI=-click: evt  | result |  result := super click: evt.  result ifTrue: [ self closePopup ].  ^result-=JUAMPI=-selectedLabel  ^selectedLabel-=JUAMPI=-stepAt: millisecondClockValue  hasInitialStep ifFalse: [ hasInitialStep := true.        ^self ].  super stepAt: millisecondClockValue-=JUAMPI=-submorphAfter  ^self subbrickAfter-=JUAMPI=-value  ^value-=JUAMPI=-enableFilterWithAction: aBlock  self enableFilter.  self parameters at: 'actionBlock' put: aBlock-=JUAMPI=-pane  ^pane ifNil: [ pane := (GLMPane named: 'root' in: GLMNoBrowser new)           addPresentationSilently: self;           yourself ]-=JUAMPI=-updateWidthPercentage  self subbricks ifEmpty: [ ^self ].  self subbricks do: [:each |  each hSpaceFill: 100 / self subbricksCount ]-=JUAMPI=-testEmptyList  window := GLMScrollListBrick exampleEmptyCollection.  self assert: window isSystemWindow-=JUAMPI=-defaultWaitDuration  ^500 milliSecond-=JUAMPI=-announce: anAnnouncement  self logger logAnnouncement: anAnnouncement from: self.  super announce: anAnnouncement-=JUAMPI=-isFocused  ^focused-=JUAMPI=-resetChildrenContent  elements := self calculateElements.  self resetDataCache-=JUAMPI=-bar  ^bar-=JUAMPI=-firstSubbrick  ^self subbricks first-=JUAMPI=-drawingBounds: aBrick  | aRectangle anOffset |  aRectangle := aBrick brickBounds.  anOffset := aBrick shadowOffset.  ^aBrick shadowWidth isZero ifTrue: [ aRectangle ] ifFalse: [ aRectangle quickMerge: ((aRectangle expandBy: aBrick shadowWidth) translateBy: anOffset) ]-=JUAMPI=-shouldValidate  ^shouldValidate ifNil: [ shouldValidate := false ]-=JUAMPI=-basicElements  ^self glamourPresentation displayValue-=JUAMPI=-cancel  self borderColor: self themer color alizarin.  self beNormal-=JUAMPI=-mouseDown: evt  startDragX := evt position x - self globalBounds left.  startResizingWidth := self width.  isRightResizing := self isRightResizingZone: evt.  isRightResizing ifFalse: [ isLeftResizing := self isLeftResizingZone: evt ] ifTrue: [ isLeftResizing := false ].  isResizing := isLeftResizing or: isRightResizing.  super mouseDown: evt-=JUAMPI=-rubricBackgroundColor  ^self valueOfProperty: #brickRubricBackgroundColor ifAbsent: [ self themer rubricBackgroundColor ]-=JUAMPI=-renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderRubricTextPresentation: self-=JUAMPI=-newBand  ^super newBand height: [:bandBrick |  bandBrick subbricks isEmpty ifTrue: [ 0 ] ifFalse: [ bandBrick lastSubbrick brickBounds bottom ] ]-=JUAMPI=-doesNotUnderstand: aMessage  ^self rubric perform: aMessage selector withArguments: aMessage arguments-=JUAMPI=-compositeMorph  ^window submorphs last submorphs last submorphs last-=JUAMPI=-replaceFrom: start to: stop with: aText  self okToStyle ifFalse: [ ^next replaceFrom: start to: stop with: aText ].  self disableDrawingWhile: [ aText addAttribute: self defaultFontChange.        text ifNil: [ text := self text ].        text replaceFrom: start to: stop with: (self styler format: aText).        self style: text.        next text: text.        self recomposeFrom: start to: start + aText size - 1 delta: aText size - (stop - start + 1).        self textArea paragraphWasComposedFrom: start to: start + aText size - 1.        self textArea paragraphReplacedTextFrom: start to: stop with: aText ]-=JUAMPI=-installEntity  self textBrick setTextWith: (self displayLogic phlowValue: self entity).  self textBrick selectionInterval: (self selectionInterval phlowValue: self entity)-=JUAMPI=-resetInput  self updateRoots-=JUAMPI=-render: aBrowser  ^self subclassResponsibility-=JUAMPI=-onDoubleClick  self announcer announce: (GLMTreeMorphStrongSelectionChanged new strongSelectionValue: (self selection ifNotNil: [ self selection selectedItemOrItemsOrNil ]))-=JUAMPI=-isButton  ^self hasIcon-=JUAMPI=-defaultBrowser  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #one;     andShow: [:a |  a list display: [:x |  1 to: x * 3 ] ].  browser transmit     to: #two;     from: #one;     andShow: [:a |  a list display: [:x |  1 to: x * 3 ] ].  browser transmit     to: #one;     from: #two;     andShow: [:a |  a list display: [:x |  1 to: x * 3 ] ].  ^browser-=JUAMPI=-initialize  super initialize.  isSyncronous := false-=JUAMPI=-testLeftFloatingMySelfDependencyWithMargin  | root floating margin brick |  margin := 10.  floating := #left.  root := self newBrickWithStaticExtent.  brick := self newBrickWithSmallStaticExtent.  brick marginLeft: margin.  brick layout floating: floating.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticSmallExtent.  self assert: brick brickBounds equals: (margin @ 0 extent: self staticSmallExtent)-=JUAMPI=-floatingMethodFor: aSymbol  ^('layoutFloating' , aSymbol capitalized , ':in:') asSymbol-=JUAMPI=-testPaneCreation  | browser |  browser := GLMFinder new.  browser addPresentation: (GLMPresentation new title: 'presentation1').  self assert: browser panes isEmpty.  (browser pane port: #entity) value: #value1.  self assert: browser panes size equals: 1.  self assert: browser panes first browser identicalTo: browser.  self assert: (browser panes first port: #entity) value equals: #value1.  self assert: browser panes first presentations size equals: 1.  self assert: browser panes first presentations first title equals: 'presentation1'.  self assert: browser panes first presentations first ~~ browser transmission transmissionStrategy presentations first.  (browser panes first port: #selection) value: #value2.  self assert: browser panes size equals: 2.  self assert: browser panes last browser identicalTo: browser.  self assert: (browser panes last port: #entity) value equals: #value2.  self assert: browser panes last presentations first title equals: 'presentation1'.  self assert: browser panes last presentations first ~~ browser transmission transmissionStrategy presentations first.  self assert: browser panes last presentations first ~~ browser panes first presentations first.  (browser panes last port: #selection) value: #value3.  self assert: browser panes size equals: 3.  self assert: browser panes last browser identicalTo: browser.  self assert: (browser panes last port: #entity) value equals: #value3.  (browser panes first port: #selection) value: #value4.  self assert: browser panes size equals: 2.  self assert: browser panes last browser identicalTo: browser.  self assert: (browser panes last port: #entity) value equals: #value4.  (browser pane port: #entity) value: #value5.  self assert: browser panes size equals: 1.  self assert: browser panes last browser identicalTo: browser.  self assert: (browser panes last port: #entity) value equals: #value5-=JUAMPI=-state  ^#vState-=JUAMPI=-onThemerChanged  self updateStyle-=JUAMPI=-markClean: aBrick  ^self subclassResponsibility-=JUAMPI=-addAllBricks: aCollection  self brickRoot addAllBricks: aCollection-=JUAMPI=-copyAccordingToPaneMapping: newPanesMapping inNewBrowser: anotherBrowser  ^self copy presentation: anotherBrowser-=JUAMPI=-customDependencies: aBrick  ^aBrick layout heightDependencies-=JUAMPI=-dimension: anObject  dimension := anObject-=JUAMPI=-prioritySortedSubbricks: aBrick  | sorted |  sorted := OrderedCollection newFrom: aBrick subbricks.  sorted sort: [:first :second |  (self isDependsOnParent: first) ifFalse: [ true ] ifTrue: [ (self isDependsOnParent: second) ifFalse: [ false ] ifTrue: [ (self hasDimensionRestrictions: first) ifFalse: [ false ] ifTrue: [ (self hasDimensionRestrictions: second) ifFalse: [ true ] ifTrue: [ (self hasMinDimensionRestriction: first) ifFalse: [ false ] ifTrue: [ true ] ] ] ] ] ].  ^sorted-=JUAMPI=-sorted: aBlock  sortBlock := aBlock-=JUAMPI=-testTrasmissions  self assert: copiedBrowser transmissions size equals: 2.  self assert: copiedBrowser transmissions first ~~ browser transmissions first.  self assert: copiedBrowser transmissions last ~~ browser transmissions last.  self assert: (copiedBrowser transmissions first destination pane browser isKindOf: GLMNoBrowser).  self assert: copiedBrowser transmissions last destination pane browser identicalTo: copiedBrowser.  self assert: copiedBrowser transmissions first origins first pane browser identicalTo: copiedBrowser.  self assert: copiedBrowser transmissions last origins first pane browser identicalTo: copiedBrowser-=JUAMPI=-text  ^(self pane port: #text) value ifNil: [ self textBlock value ] ifNotNil: [ (self pane port: #text) value ]-=JUAMPI=-scrollToPane: anIndex smooth: isSmooth  self scrollTo: (pagerModel convertIndexToValue: anIndex) smooth: isSmooth-=JUAMPI=-testWithDisplay  < expectedFailure>  | browser dynamic stacker text textMorph |  browser := GLMTabulator new     column: #stacker;     yourself.  browser transmit     to: #stacker;     andShow: [:c |  c dynamic display: [:number |  | st |              st := GLMStacker new.              st aPane: #all.              st transmit                 to: #all;                 andShow: [:a |  a text display: [ 'All ' , number asString ] ].              st ] ].  window := browser openOn: 10.  dynamic := browser panes first presentations first.  stacker := dynamic cachedPresentation first.  self assert: stacker panes first presentations size equals: 1.  text := stacker panes first presentations first.  textMorph := self findWherePresentationIs: text in: window.  self assert: textMorph text asString equals: 'All 10'-=JUAMPI=-hShrinkWrap  super hShrinkWrap.  self labelBrick hShrinkWrap.  self editBrick hShrinkWrap-=JUAMPI=-shouldFilterByTag: aTag  ^self tagsToFilterBy includes: aTag-=JUAMPI=-transmission  ^transmission ifNil: [ transmission := GLMTransmission new ensureReplacePresentationsStrategy.        transmission ]-=JUAMPI=-isOnMyself  ^true-=JUAMPI=-beCentered  isCentered := true.  self isVFilling ifTrue: [ self rubric forceHeight: [ self height - self vPadding ] ]-=JUAMPI=-testTo  browser transmit to: #one.  self assert: browser transmissions first destination pane equals: browser panes first.  self assert: browser transmissions first destination name equals: GLMPortIdentifier defaultTargetPortName-=JUAMPI=-settingsButtonBrick: anObject  settingsButtonBrick := anObject.  self settingsButtonBrick     text: self settingsButtonLabel;     hShrinkWrap;     vAlign: #center;     margin: 10;     when: #onClicked do: [ self openSettingsBrowser ].  self addBrickBack: self settingsButtonBrick-=JUAMPI=-unregisterFromAllAnnouncements  updateActions do: [:each |  each unregisterFromAllAnnouncements ]-=JUAMPI=-resetDataCache  dataCache := nil-=JUAMPI=-hintText  ^hintText ifNil: [ hintText := 'Need help?' ]-=JUAMPI=-actOnPresentationUpdated: ann  self setLabelOf: window for: ann presentation-=JUAMPI=-testShortcutFromKeymap  | action modifier |  modifier := Smalltalk os defaultModifier.  action := GLMAction new.  action keymap: modifier + $i asShortcut.  self assert: action keymap equals: modifier + $i asShortcut.  action keymap: modifier + $i shift.  self assert: action keymap equals: modifier + $i shift.  action keymap: nil.  self assertEmpty: action shortcutAsString-=JUAMPI=-removeProperty: aSymbol  super removeProperty: aSymbol-=JUAMPI=-testPortsInmmutability  < expectedFailure>  | aPane ports |  aPane := GLMPane in: 1.  self assertEmpty: aPane ports.  ports := aPane ports.  ports add: 1.  self assert: ports size equals: 1.  self assertEmpty: aPane ports-=JUAMPI=-addAllBricks: aCollection  | bricks |  bricks := self privateAddAllBricks: aCollection.  bricks do: [:b |  self privatePrepareBrickAfterAdding: b ].  self doLayoutForce.  ^aCollection-=JUAMPI=-minWidth  ^minWidth ifNil: [ minWidth := 0 ]-=JUAMPI=-testSelectionAvailableWhenNoSelectionDisabled  | presentation |  presentation := GLMPresentation new.  presentation selection: 1.  self assert: presentation selection equals: 1.  self assert: presentation rawSelection equals: 1-=JUAMPI=-paddingLeft: anInteger  self padding at: Left put: anInteger.  self updateCache-=JUAMPI=-list: anObject  list := anObject-=JUAMPI=-addContentsMorph  self contentsMorph: GLMMorphic emptyMorph.  self contentsMorph     layoutFrame: (LayoutFrame identity           leftOffset: 10;           topOffset: 10;           rightOffset: -10;           bottomOffset: -10);     hResizing: #spaceFill;     vResizing: #spaceFill.  self addMorphBack: self contentsMorph-=JUAMPI=-updateTabs  | selectedTab |  self removeAllBricks.  self tabs ifEmpty: [ ^self ].  selectedTab := self selectedTab.  self tabs do: [:t |  t selected: t == selectedTab.        t hSpaceFill: (100 / self tabs size) asFloat ].  self addAllBricks: self tabs-=JUAMPI=-textLightColor  ^Color gray-=JUAMPI=-verticallyStackedArrangement  ^self stackedVerticallyArrangement-=JUAMPI=-updateState: aRectangle  self brickBounds width = aRectangle width ifFalse: [ self markWidthDirty ].  self brickBounds height = aRectangle height ifFalse: [ self markHeightDirty ]-=JUAMPI=-testBundleStrategy  | pane1 pane2 transmission presentation |  pane1 := GLMPane named: 'pane1'.  pane2 := GLMPane named: 'pane2'.  transmission := GLMTransmission new.  transmission ensureReplacePresentationsStrategy.  transmission addActiveOrigin: (pane1 port: #port1).  transmission destination: (pane2 port: #port2).  transmission addPresentation: GLMPresentation new.  (pane1 port: #port1) value: 1.  transmission transmit.  self assert: pane2 presentations size equals: 1.  presentation := pane2 presentations first.  (pane1 port: #port1) value: 2.  transmission transmit.  self assert: pane2 presentations first rootPrototype equals: presentation rootPrototype.  self assert: pane2 presentations first ~~ presentation-=JUAMPI=-dataCache  ^dataCache ifNil: [ dataCache := self class defaultCache ]-=JUAMPI=-zIndex  ^self layout zIndex brickValue: self-=JUAMPI=-children  ^children ifNil: [ children := OrderedCollection new ]-=JUAMPI=-shortcut  ^self keymap ifNotNil: [ self keymap currentCharacter ]-=JUAMPI=-cell  ^cell-=JUAMPI=-popupEditorShadowThemer  ^self registerModule: [ GLMBrickPopupEditShadowThemer new ] to: self named: #popupThemer-=JUAMPI=-textBrick: aBrick  textBrick := aBrick.  self textBrick wrapped: true.  self textBrick layoutProperties     vSpaceFill;     hSpaceFill.  self addBrickBack: self textBrick-=JUAMPI=-leftoverScrollRange  ^(self totalScrollRange - self innerBounds width roundTo: self scrollDeltaWidth) max: 0-=JUAMPI=-renderPager: aBrowser  ^aBrowser hasFixedSizePanes ifTrue: [ GLMMorphicPagerRenderer render: aBrowser from: self ] ifFalse: [  ]-=JUAMPI=-resetContentsRecursively  self resetContents.  self allContents do: [:each |  each resetContentsRecursively ]-=JUAMPI=-profileSelection  self announce: GLMProfileSelection-=JUAMPI=-renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderRubricHighlightedTextPresentation: self-=JUAMPI=-newTextBrick  ^GLMRubEditingAreaBrick new-=JUAMPI=-destination: aPort  destination := aPort-=JUAMPI=-scrollToBottom  self band hasSubbricks ifFalse: [ ^self ].  self scrollTo: self band lastSubbrick-=JUAMPI=-widthLeft: anInteger  self width at: Left put: anInteger-=JUAMPI=-hintBrick: anObject  hintBrick := anObject.  self hintBrick textColor: self themer popupThemer textColor.  self contentBrick addBrickBack: self hintBrick-=JUAMPI=-newHeaderMorph  ^(self theme newRowIn: self theme for: {self tabSelectorMorph .         self toolbarMorph})     cellInset: 0;     cellPositioning: #bottomCenter;     borderWidth: 0-=JUAMPI=-scrollpane: anObject  scrollpane := anObject-=JUAMPI=-actOnPaneRemoved: ann  container popPane-=JUAMPI=-showAt: aPoint  self     openInWorld;     align: aPoint-=JUAMPI=-createSimplePaneMorph  ^Morph new-=JUAMPI=-evaluateSelection  self evaluateSelectionAndDo: [:result |  result ]-=JUAMPI=-modifiedBlock  ^modifiedBlock-=JUAMPI=-when: anAnnouncementClass send: selector to: target  self announcer when: anAnnouncementClass send: selector to: target-=JUAMPI=-resetDataCache  dataCache := nil-=JUAMPI=-rowMorphFor: aNodeMorph  | rowMorph cont |  rowMorph := aNodeMorph rowMorphForColumn: glamourColumn.  rowMorph ifNotNil: [ rowMorph borderWidth: 0 ] ifNil: [ rowMorph := self defaultRowMorph ].  cont := Morph new     color: Color transparent;     layoutPolicy: RowLayout new;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     layoutInset: container columnInset @ container rowInset;     yourself.  cont addMorph: rowMorph.  self isFirstColumn ifTrue: [ | icon |        icon := container iconBlock value: aNodeMorph.        icon ifNotNil: [ cont addMorph: icon asMorph ].        cont layoutInset: 0 @ container rowInset ].  ^cont-=JUAMPI=-paste  self announce: (GLMTextEditorRequest for: #paste)-=JUAMPI=-width: anInteger  self brickBounds: (self brickBounds withWidth: anInteger)-=JUAMPI=-calculateScrollbarHeight  | bandHeight firstIndex lastIndex |  bandHeight := self approximateBandHeight.  bandHeight = 0 ifTrue: [ ^0 ].  self scrollPane isFullyVisible ifTrue: [ ^0 ].  firstIndex := self scrollPane getIndex: self scrollPane band firstSubbrick.  lastIndex := self scrollPane getIndex: self scrollPane band lastSubbrick.  ^((lastIndex - firstIndex + 1) / self scrollPane model count * self height) ceiling-=JUAMPI=-outOfWorld: aWorld  super outOfWorld: aWorld.  self brickRoot onRemovedFrom: self-=JUAMPI=-hasBindingOf: aSymbol  ^self variableBindings includesKey: aSymbol-=JUAMPI=-newTreeMorph  ^GLMPaginatedMorphTreeMorph new-=JUAMPI=-isForScripting  ^isForScripting ifNil: [ false ]-=JUAMPI=-valueFor: anElement withIndex: anInteger in: aGlamourColumn  ^self cacheAt: aGlamourColumn title for: anElement ifAbsentPut: [ self glamourPresentation column: aGlamourColumn valueFor: (self glamourPresentation isWithElementIndex ifTrue: [ anElement asGlamorousMultiValue , anInteger asGlamorousMultiValue ] ifFalse: [ anElement ]) ]-=JUAMPI=-render: aPresentation  | container |  container := super render: aPresentation.  aPresentation shouldAllExpand ifTrue: [ treeMorph expandAll ].  aPresentation shouldRootsExpand ifTrue: [ treeMorph expandRoots ].  aPresentation shouldExpandToLevel ifTrue: [ treeMorph expandAllTo: aPresentation expandLevel ].  ^container-=JUAMPI=-iconBrick  ^iconBrick-=JUAMPI=-onOpened  super onOpened.  self textEditBrick     takeKeyboardFocus;     selectAll-=JUAMPI=-custom: aPresentation  ^self add: aPresentation-=JUAMPI=-actOnTextEditorRequest: ann  ann action value: textMorph textArea editor-=JUAMPI=-initialize  super initialize.  self     useHorizontalLinearLayout;     hShrinkWrap-=JUAMPI=-hShrinkWrap  self layout hShrinkWrap-=JUAMPI=-testFreshBrickIsDirty  self assertBrickDirty: GLMBrick new-=JUAMPI=-shadowColor: aColor  < brickBuilderProperty: #'Look&Feel' name: 'Shadow Color' as: #brickBuilderEvaluate getter: #shadowColor model: #GLMUIBuilderTextFieldProperty>  self setProperty: #brickShadowColor toValue: aColor-=JUAMPI=-openInBrickWindowLabeled: aLabel  ^self class environment at: #GLMSystemWindowBrick ifPresent: [:glmSystemWindowBrick |  glmSystemWindowBrick new           label: aLabel;           color: Color transparent;           addBrickBack: (GLMBrick new vSpaceFill                 hSpaceFill;                 addBrickBack: self;                 yourself);           extent: 400 @ 400 * self currentWorld displayScaleFactor;           openCenteredInWorld ] ifAbsent: [ self asMorph openInWindow ]-=JUAMPI=-normalizeWidth: anInteger of: aBrick  ^(anInteger max: (aBrick layout minWidth brickValue: aBrick)) min: (aBrick layout maxWidth brickValue: aBrick)-=JUAMPI=-postCopy  port := port copy-=JUAMPI=-resolveOriginPort: aPortReference  ^self resolvePort: aPortReference asGlamourOriginIdentifier defaultPortName: #selection-=JUAMPI=-testMarkerOneStaticHeight  | brick |  brick := self newBrickWithStaticExtent.  self markFullyClean: brick.  brick wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthClean.  self assert: brick wrappedBounds isHeightDirty-=JUAMPI=-sendToOutside: aPortName from: anOriginPortReference  self sendTo: #outer -> aPortName from: anOriginPortReference-=JUAMPI=-calculateScrollbarTopOffset  | bandHeight firstIndex lastIndex |  bandHeight := self approximateBandHeight.  bandHeight = 0 ifTrue: [ ^0 ].  firstIndex := self scrollPane getIndex: self scrollPane band firstSubbrick.  lastIndex := self scrollPane getIndex: self scrollPane band lastSubbrick.  ^((firstIndex - 1) / self scrollPane model count * self height) floor-=JUAMPI=-mouseLeave: evt  super mouseLeave: evt.  ^self deselect: evt-=JUAMPI=-approximateWidth  ^self label approximateWidth + self hMargin + self hPadding-=JUAMPI=-icon  ^nil-=JUAMPI=-noActions  actions := nil.  dynamicActionsBlock := nil-=JUAMPI=-updateCache  | left top right bottom |  left := self brickBounds origin x.  top := self brickBounds origin y.  right := self brickBounds corner x.  bottom := self brickBounds corner y.  innerBounds := (left + self paddingLeft) @ (top + self paddingTop) corner: (right - self paddingRight) @ (bottom - self paddingBottom).  outerBounds := (left - self marginLeft) @ (top - self marginTop) corner: (right + self marginRight) @ (bottom + self marginBottom)-=JUAMPI=-interval  ^self start to: self end-=JUAMPI=-glamourPresentation: aGlamourPresentation  glamourPresentation := aGlamourPresentation-=JUAMPI=-color: aSymbolOrColor  color := aSymbolOrColor-=JUAMPI=-alizarin  ^Color brickColorRegistry at: #brickAlizarin ifAbsentPut: [ Color r: 231 g: 76 b: 60 range: 255 ]-=JUAMPI=-west  direction := West-=JUAMPI=-printOn: aStream  super printOn: aStream.  aStream nextPut: $(.  ports printOn: aStream.  aStream nextPut: $)-=JUAMPI=-portSymbol  ^portSymbol-=JUAMPI=-tabLabelThemer  ^self registerModule: GLMBrickTabLabelDarkThemer new-=JUAMPI=-testReferences  | browser pane1 |  browser := GLMExplicitBrowser new.  pane1 := browser addNewPaneNamed: #pane1.  self assert: (browser resolveOriginPort: #pane1) identicalTo: (pane1 port: #selection).  self assert: (browser resolveOriginPort: #pane1 -> #foo) identicalTo: (pane1 port: #foo).  self assert: (browser resolveDestinationPort: #pane1) identicalTo: (pane1 port: #entity).  self assert: (browser resolveDestinationPort: #pane1 -> #foo) identicalTo: (pane1 port: #foo).  self assert: ((browser resolveOriginPort: #outer) isKindOf: GLMPresentationBoundPort).  self assert: (browser resolveOriginPort: #outer) presentation identicalTo: browser.  self assert: (browser resolveOriginPort: #outer) name equals: #selection.  self assert: ((browser resolveOriginPort: #outer -> #foo) isKindOf: GLMPresentationBoundPort).  self assert: (browser resolveOriginPort: #outer -> #foo) presentation identicalTo: browser.  self assert: (browser resolveOriginPort: #outer -> #foo) name equals: #foo.  self assert: ((browser resolveDestinationPort: #outer) isKindOf: GLMPresentationBoundPort).  self assert: (browser resolveDestinationPort: #outer) presentation identicalTo: browser.  self assert: (browser resolveDestinationPort: #outer) name equals: #entity.  self assert: ((browser resolveDestinationPort: #outer -> #foo) isKindOf: GLMPresentationBoundPort).  self assert: (browser resolveDestinationPort: #outer -> #foo) presentation identicalTo: browser.  self assert: (browser resolveDestinationPort: #outer -> #foo) name equals: #foo-=JUAMPI=-first  ^self presentations first-=JUAMPI=-testSuspendAllWhile  | announcement instance |  announcer when: GLMTestAnnouncement do: [:ann |  announcement := ann ].  announcement := nil.  instance := announcer announce: GLMTestAnnouncement.  self assert: announcement equals: instance.  announcement := nil.  announcer suspendAllWhile: [ instance := announcer announce: GLMTestAnnouncement ].  self assert: announcement isNil-=JUAMPI=-isHSpaceFill  ^self hState isOnParent-=JUAMPI=-isLeftResizingZone: evt  ^(self globalBounds withWidth: resizingZoneWidth) containsPoint: evt position-=JUAMPI=-toString: anObject  ^self glamourPresentation hasFilterBlock ifTrue: [ anObject ] ifFalse: [ super toString: anObject ]-=JUAMPI=-testNoSelection  | browser treeMorph treeNodeMorph |  browser := GLMFinder new.  browser show: [:a |  a tree noSelection ].  window := browser openOn: ($a to: $d).  treeMorph := window submorphs last submorphs first submorphs first submorphs first submorphs first.  treeNodeMorph := treeMorph scroller submorphs first.  self send: treeMorph mouseUpOnItem: treeNodeMorph.  self assert: browser panes size equals: 1-=JUAMPI=-scrollingDelay: anInteger  scrollingDelay := anInteger-=JUAMPI=-allowDropOnItem: aBlock  allowDropOnItemBlock := aBlock-=JUAMPI=-useExplicitNotNil  implicitNotNil := false-=JUAMPI=-testEquality  self assert: (copiedBrowser = browser) not-=JUAMPI=-check  self isChecked ifFalse: [ isChecked := true.        self announce: #onChecked.        self changed ]-=JUAMPI=-actOnVariableBindingsUpdated: ann  textModel variableBindings: nil.  self addVariableBindingsOn: textModel from: ann presentation.  textModel changed: #text.  self flag: 'update just the style here'-=JUAMPI=-totalPaneWidth  ^self innerBounds width - ((self sizing - 1) * self separatorWidth)-=JUAMPI=-dynamicActionsOnSelection  (selectionDynamicActionsBlock isNil or: [ self selectedText isNil ]) ifTrue: [ ^OrderedCollection new ].  ^selectionDynamicActionsBlock glamourValue: self-=JUAMPI=-onCompleted: aBlock  callback := aBlock-=JUAMPI=-updateWidth: aBrick  aBrick isWidthClean ifTrue: [ Exception signal: 'Clean width can''t be updated!' ].  aBrick layout hState updateWidth: aBrick on: self-=JUAMPI=-pane  ^pane-=JUAMPI=-testPresentationTransformation  | dynamic |  dynamic := GLMDynamicPresentation new.  dynamic entity: 42.  dynamic presentationTransformation: [:some :entity |  (1 to: entity) do: [:each |  some text title: each asString ] ].  self assert: dynamic currentPresentation presentations size equals: 42.  self assert: dynamic currentPresentation pane identicalTo: dynamic pane-=JUAMPI=-setUp  super setUp.  pagerModel := GLMPagerModel new scrollingDelay: 0.  pagerModel defaultNumberOfVisiblePages: 2-=JUAMPI=-testMarkerOneChildrenWidth  | brick |  brick := self newBrickWithFullDependsOnChildren.  self markFullyClean: brick.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean-=JUAMPI=-synchronizeScrollTo: aValue  pagerModel synchronizeScrollTo: aValue-=JUAMPI=-privateHeight: anObject  self layout height: anObject-=JUAMPI=-testPresentations  | expander |  expander := GLMExpander new.  expander show: [:a |  a text ].  expander startOn: #(#a #b #c).  self assert: expander panes size equals: 3.  self assert: expander panes first presentations entity value equals: #a.  self assert: expander panes first presentations size equals: 1.  self assert: (expander panes first presentations first isKindOf: GLMRubricTextPresentation)-=JUAMPI=-defaultScrollButtonStyleFor: aButton  aButton checkedIcon: GLMUIThemeExtraIcons glamorousGrayCircleEmpty.  aButton checkedFocusedIcon: GLMUIThemeExtraIcons glamorousGrayCircle.  aButton normalImage: GLMUIThemeExtraIcons glamorousGrayCircleEmpty.  aButton selectedImage: GLMUIThemeExtraIcons glamorousGrayCircle.  aButton checkedImage: aButton checkedIcon-=JUAMPI=-glamourPresentation: anObject  glamourPresentation := anObject-=JUAMPI=-renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderFastTreePresentation: self-=JUAMPI=-rubricTextFontSize  ^self valueOfProperty: #brickRubricTextFontSize ifAbsent: [ self themer rubricTextFontSize ]-=JUAMPI=-doesNotUnderstand: aMessage  ^self brickRoot perform: aMessage selector withArguments: aMessage arguments-=JUAMPI=-debugSelection  self announce: GLMDebugSelection-=JUAMPI=-childrenValueOf: anObject atLevel: anInteger  self flag: 'this is rather hackish, but needed to treat list and tree in the same way.'.  ^OrderedCollection new-=JUAMPI=-update  super update-=JUAMPI=-padding  ^self wrappedBounds padding-=JUAMPI=-sortByColumn: aGlamourColumn  columnToSortBy := columnToSortBy == aGlamourColumn ifTrue: [ nil ] ifFalse: [ aGlamourColumn ].  elements := self elementsSorted.  self glamourPresentation changed-=JUAMPI=-allowItemDragBlock  ^allowItemDragBlock-=JUAMPI=-addBrick: aBrick after: otherBrick  | result |  result := self privateAddBrick: aBrick asBrick after: otherBrick.  self privatePrepareBrickAfterAdding: result.  self doLayoutForce.  ^aBrick-=JUAMPI=-testShortcutAsString  | action modifier |  modifier := Smalltalk os menuShortcutModifierString.  action := GLMAction new.  action shortcut: $i.  self assert: action shortcutAsString equals: modifier , '+i'.  action shortcut: $I.  self assert: action shortcutAsString equals: modifier , '+shift+i'.  action shortcut: nil.  self assertEmpty: action shortcutAsString-=JUAMPI=-roots  roots ifNil: [ self roots: self glamourExpander panes ].  ^roots-=JUAMPI=-add: newObject before: oldObject  collection add: newObject before: oldObject.  self announce: GLMItemAdded-=JUAMPI=-actOnPresentationToolbarUpdated: ann  | dock |  self setLabelOf: window for: ann presentation.  dock := self renderToolbarForPresentation: ann presentation inMorph: window.  dock hResizing: #shrinkWrap.  window toolbarBox: dock-=JUAMPI=-paneCount  ^paneCount-=JUAMPI=-fromOutside: aPortName  ^self fromOutsidePort: aPortName-=JUAMPI=-backgroundColor  ^self theme backgroundColor-=JUAMPI=-measureOpeningTime  | browser numberOfOpenings time |  numberOfOpenings := 15.  browser := self defaultBrowser.  time := Time millisecondsToRun: [ numberOfOpenings timesRepeat: [ (browser openOn: 10) delete ] ].  ^{numberOfOpenings .   time}-=JUAMPI=-bounds  ^bounds-=JUAMPI=-click: evt  super click: evt.  ^true-=JUAMPI=-firstVisiblePageIndex  ^firstVisiblePageIndex-=JUAMPI=-outerBoundsInParent  ^self owner ifNotNil: [ self wrappedBounds outerBounds translateBy: self owner brickBounds origin ] ifNil: [ self wrappedBounds outerBounds ]-=JUAMPI=-newBrickWithStaticExtent  ^GLMBrick new     height: self staticHeight;     width: self staticWidth;     color: Color random;     yourself-=JUAMPI=-addItemMorph: aMorph after: anotherMorph  self addBrickBackNoLayout: aMorph.  self setBoundsOf: aMorph after: anotherMorph.  (self isPartiallyVisible: aMorph) ifFalse: [ self removeBrickNoLayout: aMorph.        ^nil ].  ^aMorph-=JUAMPI=-isDoubleClickEnabled  ^isDoubleClickEnabled ifNil: [ isDoubleClickEnabled := false ]-=JUAMPI=-addTransmission: aTransmission  aTransmission browser: self.  ^self transmissions addLast: aTransmission-=JUAMPI=-layoutMorphs: aBoolean  shouldLayoutMorphs := aBoolean-=JUAMPI=-hasUnacceptedEdits  ^hasUnacceptedEdits ifNil: [ hasUnacceptedEdits := false ]-=JUAMPI=-* aNumber  < return: #Point>  ^aNumber negated @ 0-=JUAMPI=-testMarkerOneParentWidth  | brick |  brick := self newBrickWithFullFill.  self markFullyClean: brick.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean-=JUAMPI=-renderMorphPresentation: aMorphPresentation  ^GLMMorphicMorphRenderer render: aMorphPresentation from: self-=JUAMPI=-isCollection  ^true-=JUAMPI=-registerEventsForPresentation: aPresentation  super registerEventsForPresentation: aPresentation.  aPresentation when: GLMVariableBindingsChanged send: #actOnVariableBindingsUpdated: to: self.  aPresentation when: GLMEvaluateSelection send: #actOnEvaluateSelection: to: self.  aPresentation when: GLMCompileText send: #actOnCompileText: to: self.  aPresentation when: GLMDebugSelection send: #debugSelection to: self.  aPresentation when: GLMProfileSelection send: #profileSelection to: self.  aPresentation when: GLMPrintSelection send: #evaluateAndPrintSelection to: self-=JUAMPI=-selectedBorderStyleFor: aBrick  ^self theme tabLabelSelectedBorderStyleFor: aBrick-=JUAMPI=-compileTextIn: aContext from: aSession andDo: aBlock  self announce: (GLMCompileText new           presentation: self;           context: aContext;           session: aSession;           action: aBlock)-=JUAMPI=-sortByColumn: aGlamourColumn  columnToSortBy := columnToSortBy == aGlamourColumn ifTrue: [ nil ] ifFalse: [ aGlamourColumn ].  columnToSortBy ifNotNil: [ self rootItem children: (self rootItem children sorted: self sortBlock) ] ifNil: [ self rootItem data: self basicRoots ].  self glamourPresentation changed-=JUAMPI=-onRemovedFrom: aBrick  -=JUAMPI=-registerModule: aModule  ^self registerModule: aModule to: self named: thisContext sender selector-=JUAMPI=-acceptDroppingMorph: transferMorph event: evt inMorph: listMorph  | targetItem |  targetItem := (listMorph scrollerSubMorphFromPoint: evt position) complexContents item.  ^self glamourPresentation accept: transferMorph passenger droppedOnItem: targetItem-=JUAMPI=-composite: anObject  composite := anObject-=JUAMPI=-shouldUseCache  ^self parameters at: 'shouldUseCache' ifAbsent: [ false ]-=JUAMPI=-delete  super delete.  isOpen := false-=JUAMPI=-testCompositeInTheParentPane  | browser |  browser := GLMBrowser new.  self assert: (browser pane presentations isKindOf: GLMCompositePresentation).  self assert: browser pane presentations size equals: 1.  self assert: browser pane presentations first equals: browser-=JUAMPI=-isHeightClean  ^self brick wrappedBounds isHeightClean-=JUAMPI=-wrapped  ^wrapped ifNil: [ wrapped := true ]-=JUAMPI=-percent  ^percent-=JUAMPI=-testMultipleSelectionWithChange  | browser firstTreeMorph secondTreeMorph treeNodeMorph lastTreeNodeMorph |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list           beMultiple;           display: [:x |  x - 2 to: x ] ].  window := browser openOn: 4.  firstTreeMorph := window submorphs last submorphs first submorphs first submorphs first.  treeNodeMorph := firstTreeMorph scroller submorphs first.  lastTreeNodeMorph := firstTreeMorph scroller submorphs last.  self send: firstTreeMorph mouseUpOnItem: treeNodeMorph.  self send: firstTreeMorph mouseUpWithShift: true onItem: lastTreeNodeMorph.  self assert: (firstTreeMorph model selection selectedNodePathList collect: [:each |  each first item ]) asOrderedCollection equals: #(2 3 4) asOrderedCollection.  (browser pane port: #entity) value: 42.  secondTreeMorph := window submorphs last submorphs first submorphs first submorphs first.  treeNodeMorph := secondTreeMorph scroller submorphs first.  lastTreeNodeMorph := secondTreeMorph scroller submorphs second.  self send: secondTreeMorph mouseUpOnItem: treeNodeMorph.  self send: secondTreeMorph mouseUpWithShift: true onItem: lastTreeNodeMorph.  self assert: (secondTreeMorph model selection selectedNodePathList collect: [:each |  each first item ]) asOrderedCollection equals: #(40 41) asOrderedCollection-=JUAMPI=-id: anObject  id := anObject-=JUAMPI=-specificTableMorphInitializiation  | presentation |  presentation := tableModel glamourPresentation.  tableMorph rowHeight: presentation rowHeight.  presentation isSearchable ifTrue: [ tableMorph enableSearch ].  presentation isFilterable ifTrue: [ presentation needActionButton ifTrue: [ tableMorph enableFilterWithAction: presentation actionBlock named: presentation actionName ] ifFalse: [ presentation hasFilterBlock ifTrue: [ tableMorph enableFilter: (GLMFilterBlock block: presentation filterBlock) ] ifFalse: [ tableMorph enableFilter ] ] ].  (presentation isFilterable or: [ presentation isSearchable ]) ifFalse: [ tableMorph disableFunction ] ifTrue: [ tableMorph explicitFunction ]-=JUAMPI=-spotterThemer  ^self registerModule: GTSpotterWidgetThemer new to: GTSpotterBrickThemer new-=JUAMPI=-readyToBeDisplayed  self glamourPresentation announcer announce: (GLMDataSourceUpdated newDataSource: self)-=JUAMPI=-invalidateLayout  ^self brick invalidateLayout-=JUAMPI=-addLazyPage: aBlock label: aStringOrMorph toolbar: aToolbar  self addLazyPage: aBlock label: aStringOrMorph toolbar: aToolbar collapsable: false-=JUAMPI=-isMenu  ^self hasTitle and: [ self hasIcon not ]-=JUAMPI=-render: aPane  paneMorph := GLMMorphic containerMorph.  aPane when: GLMMatchingPresentationsChanged send: #actOnMatchingPresentationsChanged: to: self.  self renderMorphFor: aPane.  ^paneMorph-=JUAMPI=-addRow: aBlockOrSymbol  | newRow cell |  cell := aBlockOrSymbol isSymbol ifTrue: [ self browser addNewPaneNamed: aBlockOrSymbol.        GLMCustomRow new           id: aBlockOrSymbol;           browser: self browser ] ifFalse: [ newRow := GLMCustomRow new browser: self browser.        aBlockOrSymbol value: newRow.        newRow ].  self children addLast: cell.  ^cell-=JUAMPI=-privateStyle: aText  | styledText |  aText makeAllColor: Color red.  styledText := self parser parse: aText asString onError: [  ].  (styledText notNil and: [ styledText ~~ aText ]) ifTrue: [ self flag: 'change only the runs array of the original text.'.        aText setString: aText string setRunsChecking: styledText runs ]-=JUAMPI=-newPane  ^newPane-=JUAMPI=-initializeTextMorph  textMorph := RubScrolledTextMorph new.  textMorph     beReadOnly;     beWrapped;     textFont: self theme textFont;     textColor: self theme textColor;     backgroundColor: self theme errorPopperBackgroundColor.  self     vResizing: #spaceFill;     hResizing: #spaceFill;     addMorph: textMorph fullFrame: LayoutFrame identity-=JUAMPI=-allowItemDrag: aBlock  allowItemDragBlock := aBlock-=JUAMPI=-privateScrollPosition: anInteger  scrollPosition := anInteger.  self announcer announce: GLMBrickScrollPositionChanged new-=JUAMPI=-relabelTab: aTab with: aStringOrBrick  aTab label: aStringOrBrick.  self updateTabs-=JUAMPI=-newVerticalScrollbar  ^GLMScrollbarBrick new-=JUAMPI=-shouldBeDisplayedByText  self containerTree shouldFilterByTextInput ifFalse: [ ^true ].  self withContentsDo: [:node |  self flag: 'this should be delegated to the presentation		and glamourValue should be used to include the entity ports'.        (self containerTree glamourPresentation filterStrategy value: self containerTree inputText asString value: node item) == true ifTrue: [ ^true ] ].  ^false-=JUAMPI=-isOnParent  ^false-=JUAMPI=-asyncTask  ^asyncTask ifNil: [ asyncTask := GLMAsyncTask new ]-=JUAMPI=-isVShrinking  ^vResizing = #shrinkWrap-=JUAMPI=-addBrickBackNoLayout: aBrick before: anotherBrick  self band doNotLayoutDuring: [ self band addBrick: aBrick before: anotherBrick ].  ^aBrick-=JUAMPI=-renderCustomColumn: aCell ofPane: aPane inUI: aMorph inBrowser: aBrowser  | pane totalSpans totalSizes currentSpanPosition currentOffset |  totalSpans := aCell children inject: 0 into: [:sum :each |  sum + each span ].  totalSizes := aCell children inject: 0 into: [:sum :each |  sum + each size ].  currentSpanPosition := 0.  currentOffset := 0.  aCell children keysAndValuesDo: [:index :each |  each hasId ifTrue: [ pane := self renderObject: (aBrowser paneNamed: each id) ] ifFalse: [ pane := GLMMorphic containerMorph.              self renderCustomRow: each ofPane: aPane inUI: pane inBrowser: aBrowser.              pane addPaneSplitters ].        pane layoutFrame: (LayoutFrame new                 topFraction: currentSpanPosition / totalSpans offset: currentOffset - (totalSizes * currentSpanPosition / totalSpans) rounded + self margin;                 leftFraction: 0 offset: 0;                 bottomFraction: (currentSpanPosition + each span) / totalSpans offset: currentOffset + each size - (totalSizes * (currentSpanPosition + each span) / totalSpans) rounded - self margin;                 rightFraction: 1 offset: 0;                 yourself).        aMorph addMorphBack: pane.        currentSpanPosition := currentSpanPosition + each span.        currentOffset := currentOffset + each size ].  aCell children last size > 0 ifTrue: [ (aMorph submorphs atLast: 2) layoutFrame bottomOffset: (aMorph submorphs atLast: 2) layoutFrame bottomOffset - currentOffset.        aMorph submorphs last layoutFrame topOffset: aMorph submorphs last layoutFrame topOffset - currentOffset.        aMorph submorphs last layoutFrame bottomOffset: aMorph submorphs last layoutFrame bottomOffset - currentOffset ].  aMorph addPaneSplitters-=JUAMPI=-testFillBrickInsideStatic  | root brick |  root := self newBrickWithStaticExtent.  brick := self newBrickWithFullFill.  brick brickApi layout hState isOnParent.  brick brickApi layout vState isOnParent.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: brick extent equals: root extent-=JUAMPI=-press  super press.  self closePopup-=JUAMPI=-modelFor: aPresentation  | highlightContext |  highlightContext := aPresentation highlightSmalltalkContext.  ^GLMRubricSmalltalkTextModel new     glamourPresentation: aPresentation;     highlightSmalltalk: highlightContext notNil;     highlightSmalltalkContext: highlightContext;     yourself-=JUAMPI=-complete: anObject callback: aBlock  process ifNil: [ ^self terminate ].  process isTerminated ifFalse: [ ^self ].  callback = aBlock ifFalse: [ ^self terminate ].  callback ifNotNil: [ callback cull: anObject ].  process := nil-=JUAMPI=-glmSubscriptions  ^registry subscriptions-=JUAMPI=-updatePanes  self basicUpdateSizing.  self layoutPanes.  self hideOrShowScrollBar.  self setScrollDeltas.  self scrollToRight-=JUAMPI=-verticalScrollbar  ^verticalScrollbar-=JUAMPI=-rowMorphForItem: anItem  | rowElements |  rowElements := OrderedCollection new.  anItem depth timesRepeat: [ rowElements add: self class emptyMorph ].  rowElements add: (self buttonFor: anItem).  (self iconFor: anItem data) ifNotNil: [:icon |  rowElements add: icon asMorph ].  rowElements     add: (self formatedDisplayValueOf: anItem data) asMorph asReadOnlyMorph;     addAll: (self tagMorphsFrom: self glamourPresentation for: anItem data).  ^Smalltalk ui theme newRowIn: self currentWorld for: rowElements-=JUAMPI=-bindingsStrategy: aBlock  bindingsStrategy := aBlock-=JUAMPI=-postCopy  super postCopy.  presentations ifNotNil: [:arg |  presentations := presentations collect: [:each |  each copy ] ].  arrangement ifNotNil: [:arg |  arrangement := arrangement copy.        arrangement composite: self ]-=JUAMPI=-text: aTextOrString  text := aTextOrString.  self glamourPresentation ifNotNil: [:presentation |  presentation text: text ]-=JUAMPI=-click: anEvent  super click: anEvent.  self announcer announce: (GLMPagerButtonClicked new buttonModel: self)-=JUAMPI=-measureSelectionTimeForSize: size  | browser numberOfSelections time port window |  numberOfSelections := 15.  browser := self defaultBrowser.  window := browser openOn: size.  port := browser panes first ports second.  time := Time millisecondsToRun: [ size - numberOfSelections to: size do: [:i |  port value: i ] ].  window delete.  ^{size .   time}-=JUAMPI=-computeTagsFilterFor: aGlamourValue  ^self computeTagsFor: aGlamourValue from: self tagsFilterBlock-=JUAMPI=-textColor: aColor  < brickBuilderProperty: #Text name: 'Text color' as: #brickBuilderEvaluate getter: #textColor model: #GLMUIBuilderTextFieldProperty>  self label textColor: aColor.  self dotsBrick textColor: aColor-=JUAMPI=-cellColumn: column row: rowIndex  | element cell |  element := self elementAt: rowIndex.  cell := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForElement: element);     yourself.  ^cell-=JUAMPI=-sortBlock: aBlock  sortBlock := aBlock-=JUAMPI=-testBrickDependsOnChildrenOneStatic  | root brick |  root := self newBrickWithFullDependsOnChildren.  brick := self newBrickWithStaticExtent.  root addBrickBack: brick.  self assert: root brickApi layout hState isOnChildren.  self assert: root brickApi layout vState isOnChildren.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: brick extent-=JUAMPI=-headerFor: anObject in: aCollapsable  | header |  header := GLMBrick new.  header     hSpaceFill;     vShrinkWrap.  header addBrickBack: (anObject isVariableBinding ifTrue: [ anObject key asBrick ] ifFalse: [ anObject asBrick ]) hSpaceFill.  (self hasChildren: anObject) ifTrue: [ header addBrickFirst: (self newToggleButtonFor: aCollapsable) ].  ^header-=JUAMPI=-act: aBlock on: aCharacter  self addAction: (GLMGenericAction new           action: aBlock;           shortcut: aCharacter;           yourself)-=JUAMPI=-remove: anObject  collection remove: anObject.  self announce: GLMItemRemoved-=JUAMPI=-separatorAfter  ^separatorAfter ifNil: [ false ]-=JUAMPI=-paneMargin  self flag: 'fix support of margin'.  ^0-=JUAMPI=-property  ^property-=JUAMPI=-testUnregisterFromAnnouncementsWhenUpdating  | composite announcingCollection numberOfExecutions |  numberOfExecutions := 0.  announcingCollection := GLMAnnouncingCollection new.  composite := GLMCompositePresentation new with: [:a |  a text           updateOn: GLMItemAdded from: [ announcingCollection ];           display: [ numberOfExecutions := numberOfExecutions + 1 ] ].  window := composite openOn: announcingCollection.  1 to: 3 do: [:each |  announcingCollection add: each ].  self assert: numberOfExecutions equals: 4-=JUAMPI=-onLayouted  self doNotUpdateDuring: [ self update ]-=JUAMPI=-rowHeight  ^self rowHeightBlock glamourValue: self asGlamorousMultiValue , self entity asGlamorousMultiValue-=JUAMPI=-lazyPageMorphCreation: anObject  lazyPageMorphCreation := anObject-=JUAMPI=-loremIpsum  ^String loremIpsum: 81233-=JUAMPI=-updatePreview: anIndex  self announcer announce: (GLMPagerPreviewUpdate new pageIndex: anIndex)-=JUAMPI=-transformation  ^transformation ifNil: [ transformation := [:x |  x ] ]-=JUAMPI=-onMyselfDo: aBlock  ^self on: #isOnMyself do: aBlock ifAbsent: [ GLMBrickLayoutMyselfState new ]-=JUAMPI=-findSatisfying: aBlock in: aMorph  aMorph allMorphsDo: [:each |  (aBlock value: each) ifTrue: [ ^each ] ].  self fail-=JUAMPI=-paddingLeft  ^self wrappedBounds paddingLeft-=JUAMPI=-withIndexDo: aBlock  ^collection withIndexDo: aBlock-=JUAMPI=-asGlamourTargetIdentifier  self portName ifNil: [ self portName: self class defaultTargetPortName ].  ^self-=JUAMPI=-arrangement: anArrangement  anArrangement composite: self.  ^arrangement := anArrangement-=JUAMPI=-entity  ^entity-=JUAMPI=-minimumPageNumberForScrollbar  ^minimumPageNumberForScrollbar-=JUAMPI=-assertHeightDirty: aBrick  self assert: aBrick wrappedBounds heightState equals: #dirty.  self assert: aBrick wrappedBounds isHeightDirty.  self assert: aBrick wrappedBounds isHeightClean not-=JUAMPI=-isHorizontal: anObject  isHorizontal := anObject-=JUAMPI=-registerModule: aModule to: aThemer  ^self registerModule: aModule to: aThemer named: thisContext sender selector-=JUAMPI=-toWatcher  ^self destination: (self browser watcherPane port: #entity)-=JUAMPI=-populate: aPortSymbol iconName: aSymbol on: aCharacter entitled: aString with: aBlock  self populate: aPortSymbol icon: (self iconNamed: aSymbol) on: aCharacter entitled: aString with: aBlock-=JUAMPI=-presentations: anObject  presentations := anObject-=JUAMPI=-menuColumn: column row: rowIndex  | menu subMenus targetMenuMorph subMenu |  menu := UIManager default newMenuIn: self table for: self.  subMenus := Dictionary new.  self allMenuActions do: [:action |  targetMenuMorph := action category notNil ifTrue: [ subMenus at: action category ifAbsentPut: [ subMenu := MenuMorph new.                    menu add: action category subMenu: subMenu.                    subMenu ] ] ifFalse: [ menu ].        (targetMenuMorph add: action title target: self selector: #executeMenuAction: argument: action)           icon: action icon;           balloonText: action help;           enabled: (action isEnabledOn: self glamourPresentation);           keyText: (action hasShortcut ifTrue: [ action shortcutAsString ] ifFalse: [ nil ]) ].  ^menu-=JUAMPI=-cellColumn: aColumn row: aRowIndex  | item cell |  item := self elementAt: aRowIndex.  cell := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForColumn: aColumn item: item withIndex: aRowIndex);     yourself.  ^cell-=JUAMPI=-testCodeExecutionWithBindings  | composite textMorph result |  composite := GLMCompositePresentation new.  composite pharoScript.  window := composite openOn: 'a:=1'.  result := nil.  textMorph := self find: RubScrolledTextMorph in: window.  textMorph textArea editor evaluateSelectionAndDo: [:r |  result := r ].  self assert: result equals: 1-=JUAMPI=-rightAngle: aDirection  ^aDirection = GLMNorthDirection uniqueInstance-=JUAMPI=-stylerStyled: styledCopyOfText  next ifNil: [ ^self ].  text runs: styledCopyOfText runs.  (self textArea scrollPane ifNil: [ self textArea ]) changed-=JUAMPI=-onDraw: aCanvas  self renderer render: self on: aCanvas-=JUAMPI=-render: aPresentation  textModel := self textModelFor: aPresentation.  textMorph := self textMorphForModel: textModel.  textModel text: textMorph text.  textMorph setSelection: textModel selection.  self installActionsOnModel: textModel fromPresentation: aPresentation.  self installKeystrokeActionsOnMorph: textMorph textMorph fromPresentation: aPresentation.  textMorph announcer when: GLMSelectedTextChanged do: [:ann |  aPresentation announcer suspendAllWhile: [ aPresentation selectionInterval: ann interval.              aPresentation selectedText: ann selectedText ] ].  textMorph announcer when: GLMTextChanged do: [:ann |  aPresentation suspendAllWhile: [ aPresentation text: ann text ] ].  self registerEventsForPresentation: aPresentation.  ^textMorph-=JUAMPI=-open: aPopupBrick with: aRectangle  ^aPopupBrick openAbove: aRectangle-=JUAMPI=-isWidthClean  ^self brick wrappedBounds isWidthClean-=JUAMPI=-buttonBorderColor  ^Color lightGray-=JUAMPI=-presentation  presentation ifNil: [ | morph |        morph := GLMMorphicRenderer new render: self glmPres.        morph hResizing: #spaceFill.        morph vResizing: #spaceFill.        presentation := MorphicGenericAdapter morph: morph ].  ^presentation-=JUAMPI=-selectedIndex  ^selectedIndex ifNil: [ selectedIndex := 0 ]-=JUAMPI=-selectionIndex: anInteger  selectionIndex := anInteger-=JUAMPI=-onButtonDeselected  GLMPagerPanePreviewMorph uniqueInstance hideFromWorld-=JUAMPI=-readyToBeDisplayed  self glamourPresentation announcer announce: (GLMDataSourceUpdated newDataSource: self)-=JUAMPI=-onLostFocus  self isCancelOnFocusLost & self isEditMode ifTrue: [ self cancel ].  self isEditMode ifTrue: [ self animateToEditNotFocused ] ifFalse: [ self animateToNormal ]-=JUAMPI=-watcherPane  ^watcherPane ifNil: [ watcherPane := GLMPane named: #_watcher ]-=JUAMPI=-privateRemoveOutWorld: aBrick  aBrick outOfWorld: aBrick world-=JUAMPI=-actionSelector  ^#morphicActOn:-=JUAMPI=-border  ^self valueOfProperty: #brickBorder ifAbsentPut: [ GLMBrickBorder new ]-=JUAMPI=-variableBindings  ^(variableBindingsBlock glamourValue: self entity) ifNil: [ OrderedCollection new ]-=JUAMPI=-testAccordion  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a accordionArrangement.        a list title: 'List'.        a text title: 'Text' ].  window := browser openOn: 42.  self assert: self compositePanel submorphs notEmpty.  self assert: self compositePanel submorphs size equals: 2.  self assert: self compositePanel submorphs first class equals: ExpanderMorph.  self assert: self compositePanel submorphs last class equals: ExpanderMorph-=JUAMPI=-clear  arrangement := nil.  presentations := nil-=JUAMPI=-testPanes  self assert: copiedBrowser panes size equals: 2.  self assert: copiedBrowser panes first ~~ browser panes first.  self assert: copiedBrowser panes last ~~ browser panes last.  self assert: copiedBrowser panes first browser identicalTo: copiedBrowser.  self assert: copiedBrowser panes last browser identicalTo: copiedBrowser.  self assert: copiedBrowser panes first ports size equals: 1.  self assert: copiedBrowser panes first ports first name equals: #selection.  self assert: copiedBrowser panes first ports first pane identicalTo: copiedBrowser panes first.  self assert: copiedBrowser panes last ports size equals: 2.  self assert: copiedBrowser panes last ports first name equals: #selection.  self assert: copiedBrowser panes last ports last name equals: #entity-=JUAMPI=-addBrick: aBrick before: otherBrick  | result |  result := self privateAddBrick: aBrick asBrick before: otherBrick.  self privatePrepareBrickAfterAdding: result.  self doLayoutForce.  ^aBrick-=JUAMPI=-glmAnimateValue: aValue duration: anInteger  self glmAnimateValue: aValue duration: anInteger callback: nil-=JUAMPI=-layoutSubbricks  self layoutPolicy layout: self brickApi in: self innerBounds-=JUAMPI=-actionThemer  ^GLMActionBrickThemer new-=JUAMPI=-textEditBrick  ^textEditBrick-=JUAMPI=-renderFastTreePresentation: aPresentation  ^GLMMorphicFastTreeRenderer render: aPresentation from: self-=JUAMPI=-separatorWidth  ^20-=JUAMPI=-columns: aCollection  columns := aCollection-=JUAMPI=-animateToEditNotFocused  self borderAnimation     from: self borderColor first;     to: self themer normalBorderColor;     animate: self-=JUAMPI=-column: aBlockOrString evaluated: aBlock modified: aModifiedBlock  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           modifiedBlock: aModifiedBlock)-=JUAMPI=-defaultSelectionActions  ^self executionSelectionActions-=JUAMPI=-leftShadowOf: aBrick on: aCanvas  | gradient width origin offset |  width := aBrick shadowWidth.  offset := width negated @ width / 2.0.  origin := aBrick brickBounds topLeft + offset + aBrick shadowOffset.  gradient := (self shadowGradientFor: aBrick)     origin: origin - offset + ((width / 2.0) @ 0);     direction: (width @ 0) negated;     yourself.  aCanvas fillRectangle: (origin extent: width @ (aBrick height - width)) fillStyle: gradient-=JUAMPI=-changed  self world ifNil: [ ^self ].  ^fullBounds ifNil: [ self invalidRect: self bounds ] ifNotNil: [ self invalidRect: fullBounds ]-=JUAMPI=-testMarkerOneChildrenInStaticWidth  | root brick |  root := self newBrickWithStaticExtent.  brick := self newBrickWithFullDependsOnChildren.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightClean-=JUAMPI=-announcer  ^announcer ifNil: [ announcer := GLMAnnouncer new ]-=JUAMPI=-popup: aPopupBrick event: anEvent  < return: #Boolean>  ^anEvent type == #keystroke and: [ anEvent keyCharacter = Character escape ]-=JUAMPI=-shouldDisplayPresentationCreatedBy: aCollection  ^true-=JUAMPI=-scrollBarColor  ^self valueOfProperty: #brickScrollbarColor ifAbsent: [ self themer scrollbarColor ]-=JUAMPI=-tabWidth  ^tabWidth ifNil: [ TextStyle default rubTabWidth ]-=JUAMPI=-actualPageMorph: anObject  actualPageMorph := anObject-=JUAMPI=-subbrickBefore  | link |  link := self brickDoubleLink.  link ifNil: [ ^nil ].  link previousLink ifNil: [ ^nil ].  ^link previousLink value-=JUAMPI=-renderFastListPresentation: aPresentation  ^GLMMorphicFastListRenderer render: aPresentation from: self-=JUAMPI=-scrollDown: anInteger  self band translateY: anInteger negated.  self isBottomOverscrolled ifTrue: [ self moveBandBottom ]-=JUAMPI=-tearDown  window ifNotNil: [ window delete ].  super tearDown-=JUAMPI=-variableBindings: aBlock  ^variableBindingsBlock := aBlock-=JUAMPI=-colorRight  ^self color at: Right-=JUAMPI=-testUnregisterAnnouncementsWhenRemovingPane  | announcer presentation browser pane |  announcer := Announcer new.  browser := GLMBrowser new.  pane := GLMPane new.  presentation := GLMPresentation new.  pane addPresentation: presentation.  browser addPane: pane.  presentation updateOn: GLMTestAnnouncement from: [ announcer ].  presentation registerAnnouncements.  self assert: announcer numberOfSubscriptions equals: 1.  browser removePane: pane.  self assert: announcer numberOfSubscriptions equals: 0-=JUAMPI=-vMargin  ^self marginTop + self marginBottom-=JUAMPI=-addActiveOrigin: aPort  ^self originReferences add: (GLMOriginPortReference new           port: aPort;           beActive;           yourself)-=JUAMPI=-glamourPresentation  ^glamourPresentation-=JUAMPI=-testFinder  | finder |  finder := GLMFinder new.  finder show: [:a |  a title: 'something'.        a stackedArrangement.        a list.        a text ].  self assert: finder transmission transmissionStrategy presentations size equals: 2.  finder startOn: (1 to: 42).  self assert: finder panes first presentations size equals: 2.  self assert: (finder panes first presentations arrangement isKindOf: GLMStackedVerticallyArrangement).  window := finder open.  self find: LazyTabGroupMorph in: window-=JUAMPI=-presentations  ^self pane presentations-=JUAMPI=-removeTabIndex: anInteger  self tabs removeAt: anInteger.  self selectedIndex: 0.  self tabs ifNotEmpty: [ self selectedIndex: (self selectedIndex - 1) \\ self tabs size + 1 ]-=JUAMPI=-font: aLogicalFont  self label font: aLogicalFont.  self dotsBrick font: aLogicalFont-=JUAMPI=-selectToLeft  self selectedPageIndex: self selectedPageIndex - 1-=JUAMPI=-glamourPresentation  ^glamourPresentation-=JUAMPI=-openInBrickWindow  ^self openInBrickWindowLabeled: self-=JUAMPI=-sizeLogic: aBlockWithNoParameters  countLogic := aBlockWithNoParameters-=JUAMPI=-initialize  super initialize.  self on: #keyStroke send: #handleKeyStroke: to: self.  hasInitialStep := false-=JUAMPI=-textModelFor: aPresentation  ^GLMTextModel new     text: aPresentation formatedDisplayValue;     glamourPresentation: aPresentation-=JUAMPI=-testAccordionWithTitle  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a accordionArrangement.        a title: 'title'.        a list.        a text ].  window := browser openOn: 42.  self assert: self compositeTabGroup submorphs notEmpty.  self assert: self compositeTabGroup submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph class equals: GLMPanelMorph.  self assert: self compositeTabGroup contentMorph submorphs first submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph submorphs first submorphs first class equals: ExpanderMorph-=JUAMPI=-gtActionsIn: composite  < gtInspectorPresentationOrder: 50>  composite list     title: 'Actions';     display: [ self actions ];     format: [:each |  each gtDisplayString ]-=JUAMPI=-column: aBlockOrString evaluated: aBlock width: aNumber tags: anObject sortedBy: aSortingBlock  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           width: aNumber;           tags: anObject;           sortBlock: aSortingBlock yourself)-=JUAMPI=-origin: aPoint length: aLength breadth: aBreadth  ^aPoint extent: aLength @ aBreadth-=JUAMPI=-from: anObject  fromLogic := anObject-=JUAMPI=-hAlign  ^self layout hAlign-=JUAMPI=-helpMessage  ^helpMessage ifNil: [ helpMessage := 'Search Input' ]-=JUAMPI=-newSliderBrick  ^GLMPagerScrollSlidingBrick new-=JUAMPI=-isWidthDirty  ^self widthState = #dirty-=JUAMPI=-transformation  ^transformation-=JUAMPI=-render: aBrowser  container := GLMMorphic containerMorph.  container     changeTableLayout;     listDirection: #leftToRight;     vResizing: #spaceFill;     hResizing: #shrinkWrap.  scrollPane := GeneralScrollPane new     changeScrollerTableLayout;     scrollTarget: container;     yourself.  self registerAnnouncementsFor: aBrowser.  aBrowser panes do: [:each |  self addMorphFromObject: each toContainer: container ].  ^scrollPane-=JUAMPI=-modules  ^modules ifNil: [ modules := Dictionary new ]-=JUAMPI=-glamourAction: anObject  glamourAction := anObject-=JUAMPI=-transformation: anObject  transformation := anObject-=JUAMPI=-testInnerTransmissions  | browser1 browser2 presentation innerBrowser |  browser1 := GLMExplicitBrowser new.  browser2 := GLMExplicitBrowser new.  presentation := GLMPresentation new.  browser1 addNewPane name: 'pane1'.  browser2 addNewPane name: 'innerpane 1'.  browser1 addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: browser1;                 name: #entity;                 yourself);           destination: (browser1 panes first port: #entity);           addPresentation: browser2;           yourself).  browser2 addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: browser2;                 name: #entity;                 yourself);           destination: (browser2 panes first port: #entity);           addPresentation: presentation;           yourself).  (browser1 pane port: #entity) value: 42.  innerBrowser := browser1 panes first presentations first.  self assert: innerBrowser transmissions size equals: 1.  self assert: (innerBrowser transmissions first origins first isKindOf: GLMPresentationBoundPort).  self assert: innerBrowser transmissions first origins first pane identicalTo: browser1 panes first-=JUAMPI=-hasMinHeight  ^(self minHeight isNumber ifTrue: [ self minHeight <= 0 ] ifFalse: [ false ]) not-=JUAMPI=-action  ^action-=JUAMPI=-vPadding  ^self paddingTop + self paddingBottom-=JUAMPI=-isEntityPort  ^self name = #entity-=JUAMPI=-when: anAnnouncementClass send: selector to: target  self announcer when: anAnnouncementClass send: selector to: target-=JUAMPI=-toggleFilteringByTag: aTag  (self shouldFilterByTag: aTag) ifTrue: [ self tagsToFilterBy remove: aTag ] ifFalse: [ self tagsToFilterBy add: aTag ].  self resetChildrenContent.  self tableRefresh-=JUAMPI=-printSelection  self announce: GLMPrintSelection-=JUAMPI=-actOnPaneReplaced: ann  container brickRoot popAndReplacePane: (self renderObject: ann newPane)-=JUAMPI=-renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderFastTablePresentation: self-=JUAMPI=-selectedClassOrMetaClass  ^self highlightSmalltalkContext-=JUAMPI=-addPresentations: aCollection  self notingPresentationChangeDo: [ aCollection do: [:each |  self addPresentationSilently: each ] ]-=JUAMPI=-category  ^category-=JUAMPI=-testFullAlignCenterShrinkWrapInSpaceFill  | root brick1 brick2 brick3 increment |  increment := 10.  root := self newBrickWithStaticExtent.  brick1 := self newBrickWithFullFill.  brick2 := self newBrickWithFullDependsOnChildren.  brick3 := self newBrickWithSmallStaticExtent.  brick2     vAlign: #center;     hAlign: #center.  root addBrickBack: brick1.  brick1 addBrickBack: brick2.  brick2 addBrickBack: brick3.  self assertAllSubbricksAreClean: root.  self assert: brick2 brickBounds equals: ((self staticExtent - self staticSmallExtent) / 2 extent: self staticSmallExtent) ceiling.  brick3     height: brick3 height + increment;     width: brick3 width + increment.  self assertAllSubbricksAreClean: root.  self assert: brick2 brickBounds equals: ((self staticExtent - self staticSmallExtent) / 2 - (increment / 2) extent: self staticSmallExtent + increment) ceiling-=JUAMPI=-icon  ^icon ifNil: [ icon := [ nil ] ]-=JUAMPI=-acceptsSelection: aBoolean  acceptsSelection := aBoolean-=JUAMPI=-filterBlock: anObject  filterBlock := anObject-=JUAMPI=-color  ^self valueOfProperty: #brickBackgroundColor ifAbsent: [ self themer backgroundColor ]-=JUAMPI=-testStartingPreservesItself  | composite finder |  composite := GLMCompositePresentation new.  finder := composite finder.  composite startOn: 42.  self assert: composite pane presentations equals: composite.  self assert: composite first identicalTo: finder-=JUAMPI=-presentation  ^presentation-=JUAMPI=-layoutPolicy  ^self brick layoutPolicy-=JUAMPI=-addRow: aBlockOrSymbol size: anInteger  ^(self addRow: aBlockOrSymbol)     size: anInteger;     span: 0-=JUAMPI=-buttonForTag: each filter: filter  ^(GLMMorphic togglingButtonLabelled: each pressed: (self shouldFilterByTag: filter) style: self glamourPresentation tagsStyle)     target: self;     actionSelector: #toggleFilteringByTag:;     arguments: (Array with: filter);     yourself-=JUAMPI=-collapse  self contentBrick ifNil: [ ^self ].  self isExpanded ifTrue: [ self removeBrick: self contentBrick ]-=JUAMPI=-bindingsStrategy  ^bindingsStrategy ifNil: [ bindingsStrategy := self defaultBindingsStrategy ]-=JUAMPI=-testGlamourValueWithArgs  self assert: ([ #foo ] glamourValueWithArgs: #(1 2)) equals: #foo.  self assert: ([:first |  Array with: first ] glamourValueWithArgs: #(1 2)) equals: #(1).  self assert: ([:first :second |  Array with: first with: second ] glamourValueWithArgs: #(1 2)) equals: #(1 2).  self assert: ([:first :second :third |  Array with: first with: second with: third ] glamourValueWithArgs: #(1 2)) equals: #(1 2 nil).  self assert: (#yourself glamourValueWithArgs: #(1 2)) equals: 1.  self assert: (#yourself glamourValueWithArgs: #()) equals: nil-=JUAMPI=-markWidthClean  ^self brick wrappedBounds markWidthClean-=JUAMPI=-isVFilling  ^vResizing = #spaceFill-=JUAMPI=-browser  browser ifNil: [ ^GLMNoBrowser new ].  ^browser-=JUAMPI=-vState  ^GLMBrickLayoutDummState new-=JUAMPI=-testCachedPresentation  | dynamic currentPresentation |  dynamic := GLMDynamicPresentation new.  dynamic entity: 42.  dynamic transformation: [:entity |  GLMRubricTextPresentation new ].  currentPresentation := dynamic currentPresentation.  self assert: dynamic cachedPresentation identicalTo: currentPresentation-=JUAMPI=-buttonsBrick: aBrick  buttonsBrick := aBrick.  self buttonsBrick pagerModel: pagerModel.  self buttonsBrick     hShrinkWrap;     vShrinkWrap.  self addBrickBack: self buttonsBrick-=JUAMPI=-act  self subclassResponsibility-=JUAMPI=-beEdit  self isEditMode ifTrue: [ ^self ].  self editBrick updateTextWith: self labelBrick text.  self editBrick moveCursorToIndex: self labelBrick text size + 1.  self addBrickFirst: self editBrick.  self removeBrick: self labelBrick.  self borderColor: (self themer focusedBorderColor alpha: 0).  self editBrick rubric takeKeyboardFocus.  self announce: #onEditMode-=JUAMPI=-maxWidth: anObject  self layout maxWidth: anObject-=JUAMPI=-backgroundColor  ^Color transparent-=JUAMPI=-maxHeight: anObject  maxHeight := anObject-=JUAMPI=-sendOneOrMultiple  self sendOneOrMultipleAs: Array-=JUAMPI=-testJumpstartTransmission  | browser presentation |  browser := GLMExplicitBrowser new.  presentation := GLMPresentation new.  browser addNewPane.  browser addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           addActiveOrigin: (browser pane port: #entity);           destination: (browser panes first port: #entity);           addPresentation: presentation;           yourself).  self assert: (browser panes first port: #entity) value isNil.  self assertEmpty: browser panes first presentations.  (browser pane port: #entity) value: #foo.  self assert: (browser panes first port: #entity) value equals: #foo.  self assert: browser panes first presentations size equals: 1.  self assert: browser panes first presentations first rootPrototype equals: presentation-=JUAMPI=-markDirtyCustomDependency: aBrick inContext: aContextBrick  aBrick isBrick not | (aBrick = aContextBrick) ifTrue: [ ^self ].  (self hasCustomDependencies: aBrick) ifTrue: [ self markDirty: aBrick.        aBrick subbricks do: [:each |  each isBrick ifTrue: [ self markDirty: each.                    self markDirtyAround: each inContext: aBrick ] ].        (self customDependencies: aBrick) do: [:each |  | brick |              [ brick := (each brickValue: aBrick) brickApi ] on: Exception do: [ brick := nil ].              brick ifNotNil: [ (brick = aContextBrick) not & (brick = aBrick) not & brick isBrick ifTrue: [ (self isClean: brick) ifTrue: [ self markDirty: brick.                                self markDirtyAround: brick inContext: aBrick ] ] ] ] ]-=JUAMPI=-onChangeOfPort: aPortName act: aBlock  self portChangeActions add: (GLMPortChangeAction new           portName: aPortName;           action: aBlock)-=JUAMPI=-setFocused  focused ifFalse: [ self checkedImage: checkedFocusedIcon.        self check.        focused := true ]-=JUAMPI=-value: anObject in: aContext  (self validate: anObject) ifFalse: [ ^self ].  self port value: anObject in: aContext-=JUAMPI=-notingPresentationChangeDo: aBlock  aBlock value-=JUAMPI=-glamourExpander  ^glamourExpander-=JUAMPI=-testIsRendered  self assert: tabs pages first isRendered not.  tabs selectedPageIndex: 1.  self assert: tabs pages first isRendered.  self assert: tabs pages second isRendered not-=JUAMPI=-column: aBlockOrSymbol  ^self addColumn: aBlockOrSymbol-=JUAMPI=-dragResizingLeft: anEvent  | left right |  right := self brickBounds right.  left := anEvent position x - self owner globalBounds left - startDragX.  left := (left max: 0) min: right - self pagerModel circleButtonSize.  self setPosition: left @ right-=JUAMPI=-checkBrick: anObject  checkBrick := anObject.  self box     borderColor: self themer checkboxBorderColor;     borderWidth: self themer checkboxBorderWidth;     vAlign: #center;     checkedImage: self themer checkboxCheckedImage;     width: self themer checkboxWidth;     height: self themer checkboxHeight.  self addBrickFirst: self box-=JUAMPI=-newDataSource: anObject  newDataSource := anObject-=JUAMPI=-shoutAboutToStyle: aPluggableShoutMorph  self highlightSmalltalk ifFalse: [ ^false ].  self highlightSmalltalkContext ifNotNil: [:classOrMetaClass |  aPluggableShoutMorph classOrMetaClass: classOrMetaClass ].  ^true-=JUAMPI=-shouldUseCache  ^self glamourPresentation shouldUseCache-=JUAMPI=-step  | newText |  newText := self textLogic value asString.  self text = newText ifTrue: [ ^self ].  self text: newText.  self doLayoutForce-=JUAMPI=-updateInsetAndSpacing  self triggerBrick margin: {self inset top .         self inset right .         0 .         self inset left}.  self contentBrick margin: {self spacing .         self inset right .         self inset bottom .         self inset left}-=JUAMPI=-computeWidth  ^self pagerModel ifNil: [ 0 ] ifNotNil: [:m |  m circleButtonSize * m actualNumberOfVisiblePages ]-=JUAMPI=-invalidateMorphBounds: isForce  | origin corner newBounds |  isLayouting & isForce not ifTrue: [ ^self ].  origin := self paddingLeft @ self paddingTop.  corner := self paddingRight @ self paddingBottom.  newBounds := self globalBounds.  newBounds := newBounds origin + origin corner: newBounds corner - corner.  self morph bounds: newBounds-=JUAMPI=-in: aTableBrick  table := aTableBrick.  self initializeColumns-=JUAMPI=-popAndReplacePane: aMorph  transform removeMorph: transform lastSubmorph.  transform submorphs isEmpty ifFalse: [ transform removeMorph: transform lastSubmorph ].  paneCount := paneCount - 1.  aMorph     borderWidth: 0;     hResizing: #spaceFill;     vResizing: #spaceFill;     layoutInset: 0.  transform hasSubmorphs ifTrue: [ transform addMorphBack: self separator ].  transform addMorphBack: (aMorph adoptPaneColor: self paneColor).  paneCount := paneCount + 1.  self updatePanes-=JUAMPI=-morph: aBlock  morphBuilder := aBlock-=JUAMPI=-isHeightCustom  ^self vState isOnMyself-=JUAMPI=-addDefaultStatusbarTransmissionFrom: aPane  | defaultTransmission |  defaultTransmission := GLMTransmission new     ensureReplacePresentationsStrategy;     addActiveOrigin: (aPane port: #status);     destination: (self statusbarPane port: #entity);     addPresentation: self statusbarPresentation;     yourself.  self addTransmission: defaultTransmission-=JUAMPI=-setProperty: aSymbol toValue: anObject  super setProperty: aSymbol toValue: anObject-=JUAMPI=-scrollToPane: pageIndex callback: aBlock  self scrollTo: (self convertIndexToValue: pageIndex) smooth: true callback: aBlock-=JUAMPI=-