foundationBrick  ^(self owner isKindOf: GLMFoundationBrick) ifTrue: [ self owner ] ifFalse: [ self ]-======-renderBorder: aBrick on: aCanvas  aCanvas drawPolygon: aBrick area vertices color: Color transparent borderWidth: aBrick border widthTop borderColor: aBrick border colorTop-======-click: evt  | result |  result := super click: evt.  result ifTrue: [ self closePopup ].  ^result-======-selectedLabel  ^selectedLabel-======-stepAt: millisecondClockValue  hasInitialStep ifFalse: [ hasInitialStep := true.        ^self ].  super stepAt: millisecondClockValue-======-submorphAfter  ^self subbrickAfter-======-value  ^value-======-enableFilterWithAction: aBlock  self enableFilter.  self parameters at: 'actionBlock' put: aBlock-======-pane  ^pane ifNil: [ pane := (GLMPane named: 'root' in: GLMNoBrowser new)           addPresentationSilently: self;           yourself ]-======-updateWidthPercentage  self subbricks ifEmpty: [ ^self ].  self subbricks do: [:each |  each hSpaceFill: 100 / self subbricksCount ]-======-testEmptyList  window := GLMScrollListBrick exampleEmptyCollection.  self assert: window isSystemWindow-======-defaultWaitDuration  ^500 milliSecond-======-announce: anAnnouncement  self logger logAnnouncement: anAnnouncement from: self.  super announce: anAnnouncement-======-isFocused  ^focused-======-resetChildrenContent  elements := self calculateElements.  self resetDataCache-======-bar  ^bar-======-firstSubbrick  ^self subbricks first-======-drawingBounds: aBrick  | aRectangle anOffset |  aRectangle := aBrick brickBounds.  anOffset := aBrick shadowOffset.  ^aBrick shadowWidth isZero ifTrue: [ aRectangle ] ifFalse: [ aRectangle quickMerge: ((aRectangle expandBy: aBrick shadowWidth) translateBy: anOffset) ]-======-shouldValidate  ^shouldValidate ifNil: [ shouldValidate := false ]-======-basicElements  ^self glamourPresentation displayValue-======-cancel  self borderColor: self themer color alizarin.  self beNormal-======-mouseDown: evt  startDragX := evt position x - self globalBounds left.  startResizingWidth := self width.  isRightResizing := self isRightResizingZone: evt.  isRightResizing ifFalse: [ isLeftResizing := self isLeftResizingZone: evt ] ifTrue: [ isLeftResizing := false ].  isResizing := isLeftResizing or: isRightResizing.  super mouseDown: evt-======-rubricBackgroundColor  ^self valueOfProperty: #brickRubricBackgroundColor ifAbsent: [ self themer rubricBackgroundColor ]-======-renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderRubricTextPresentation: self-======-newBand  ^super newBand height: [:bandBrick |  bandBrick subbricks isEmpty ifTrue: [ 0 ] ifFalse: [ bandBrick lastSubbrick brickBounds bottom ] ]-======-doesNotUnderstand: aMessage  ^self rubric perform: aMessage selector withArguments: aMessage arguments-======-compositeMorph  ^window submorphs last submorphs last submorphs last-======-replaceFrom: start to: stop with: aText  self okToStyle ifFalse: [ ^next replaceFrom: start to: stop with: aText ].  self disableDrawingWhile: [ aText addAttribute: self defaultFontChange.        text ifNil: [ text := self text ].        text replaceFrom: start to: stop with: (self styler format: aText).        self style: text.        next text: text.        self recomposeFrom: start to: start + aText size - 1 delta: aText size - (stop - start + 1).        self textArea paragraphWasComposedFrom: start to: start + aText size - 1.        self textArea paragraphReplacedTextFrom: start to: stop with: aText ]-======-installEntity  self textBrick setTextWith: (self displayLogic phlowValue: self entity).  self textBrick selectionInterval: (self selectionInterval phlowValue: self entity)-======-resetInput  self updateRoots-======-render: aBrowser  ^self subclassResponsibility-======-onDoubleClick  self announcer announce: (GLMTreeMorphStrongSelectionChanged new strongSelectionValue: (self selection ifNotNil: [ self selection selectedItemOrItemsOrNil ]))-======-isButton  ^self hasIcon-======-defaultBrowser  | browser |  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #one;     andShow: [:a |  a list display: [:x |  1 to: x * 3 ] ].  browser transmit     to: #two;     from: #one;     andShow: [:a |  a list display: [:x |  1 to: x * 3 ] ].  browser transmit     to: #one;     from: #two;     andShow: [:a |  a list display: [:x |  1 to: x * 3 ] ].  ^browser-======-initialize  super initialize.  isSyncronous := false-======-testLeftFloatingMySelfDependencyWithMargin  | root floating margin brick |  margin := 10.  floating := #left.  root := self newBrickWithStaticExtent.  brick := self newBrickWithSmallStaticExtent.  brick marginLeft: margin.  brick layout floating: floating.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: self staticExtent.  self assert: brick extent equals: self staticSmallExtent.  self assert: brick brickBounds equals: (margin @ 0 extent: self staticSmallExtent)-======-floatingMethodFor: aSymbol  ^('layoutFloating' , aSymbol capitalized , ':in:') asSymbol-======-testPaneCreation  | browser |  browser := GLMFinder new.  browser addPresentation: (GLMPresentation new title: 'presentation1').  self assert: browser panes isEmpty.  (browser pane port: #entity) value: #value1.  self assert: browser panes size equals: 1.  self assert: browser panes first browser identicalTo: browser.  self assert: (browser panes first port: #entity) value equals: #value1.  self assert: browser panes first presentations size equals: 1.  self assert: browser panes first presentations first title equals: 'presentation1'.  self assert: browser panes first presentations first ~~ browser transmission transmissionStrategy presentations first.  (browser panes first port: #selection) value: #value2.  self assert: browser panes size equals: 2.  self assert: browser panes last browser identicalTo: browser.  self assert: (browser panes last port: #entity) value equals: #value2.  self assert: browser panes last presentations first title equals: 'presentation1'.  self assert: browser panes last presentations first ~~ browser transmission transmissionStrategy presentations first.  self assert: browser panes last presentations first ~~ browser panes first presentations first.  (browser panes last port: #selection) value: #value3.  self assert: browser panes size equals: 3.  self assert: browser panes last browser identicalTo: browser.  self assert: (browser panes last port: #entity) value equals: #value3.  (browser panes first port: #selection) value: #value4.  self assert: browser panes size equals: 2.  self assert: browser panes last browser identicalTo: browser.  self assert: (browser panes last port: #entity) value equals: #value4.  (browser pane port: #entity) value: #value5.  self assert: browser panes size equals: 1.  self assert: browser panes last browser identicalTo: browser.  self assert: (browser panes last port: #entity) value equals: #value5-======-state  ^#vState-======-onThemerChanged  self updateStyle-======-markClean: aBrick  ^self subclassResponsibility-======-addAllBricks: aCollection  self brickRoot addAllBricks: aCollection-======-copyAccordingToPaneMapping: newPanesMapping inNewBrowser: anotherBrowser  ^self copy presentation: anotherBrowser-======-customDependencies: aBrick  ^aBrick layout heightDependencies-======-dimension: anObject  dimension := anObject-======-prioritySortedSubbricks: aBrick  | sorted |  sorted := OrderedCollection newFrom: aBrick subbricks.  sorted sort: [:first :second |  (self isDependsOnParent: first) ifFalse: [ true ] ifTrue: [ (self isDependsOnParent: second) ifFalse: [ false ] ifTrue: [ (self hasDimensionRestrictions: first) ifFalse: [ false ] ifTrue: [ (self hasDimensionRestrictions: second) ifFalse: [ true ] ifTrue: [ (self hasMinDimensionRestriction: first) ifFalse: [ false ] ifTrue: [ true ] ] ] ] ] ].  ^sorted-======-sorted: aBlock  sortBlock := aBlock-======-testTrasmissions  self assert: copiedBrowser transmissions size equals: 2.  self assert: copiedBrowser transmissions first ~~ browser transmissions first.  self assert: copiedBrowser transmissions last ~~ browser transmissions last.  self assert: (copiedBrowser transmissions first destination pane browser isKindOf: GLMNoBrowser).  self assert: copiedBrowser transmissions last destination pane browser identicalTo: copiedBrowser.  self assert: copiedBrowser transmissions first origins first pane browser identicalTo: copiedBrowser.  self assert: copiedBrowser transmissions last origins first pane browser identicalTo: copiedBrowser-======-text  ^(self pane port: #text) value ifNil: [ self textBlock value ] ifNotNil: [ (self pane port: #text) value ]-======-scrollToPane: anIndex smooth: isSmooth  self scrollTo: (pagerModel convertIndexToValue: anIndex) smooth: isSmooth-======-testWithDisplay  < expectedFailure>  | browser dynamic stacker text textMorph |  browser := GLMTabulator new     column: #stacker;     yourself.  browser transmit     to: #stacker;     andShow: [:c |  c dynamic display: [:number |  | st |              st := GLMStacker new.              st aPane: #all.              st transmit                 to: #all;                 andShow: [:a |  a text display: [ 'All ' , number asString ] ].              st ] ].  window := browser openOn: 10.  dynamic := browser panes first presentations first.  stacker := dynamic cachedPresentation first.  self assert: stacker panes first presentations size equals: 1.  text := stacker panes first presentations first.  textMorph := self findWherePresentationIs: text in: window.  self assert: textMorph text asString equals: 'All 10'-======-hShrinkWrap  super hShrinkWrap.  self labelBrick hShrinkWrap.  self editBrick hShrinkWrap-======-shouldFilterByTag: aTag  ^self tagsToFilterBy includes: aTag-======-transmission  ^transmission ifNil: [ transmission := GLMTransmission new ensureReplacePresentationsStrategy.        transmission ]-======-isOnMyself  ^true-======-beCentered  isCentered := true.  self isVFilling ifTrue: [ self rubric forceHeight: [ self height - self vPadding ] ]-======-testTo  browser transmit to: #one.  self assert: browser transmissions first destination pane equals: browser panes first.  self assert: browser transmissions first destination name equals: GLMPortIdentifier defaultTargetPortName-======-settingsButtonBrick: anObject  settingsButtonBrick := anObject.  self settingsButtonBrick     text: self settingsButtonLabel;     hShrinkWrap;     vAlign: #center;     margin: 10;     when: #onClicked do: [ self openSettingsBrowser ].  self addBrickBack: self settingsButtonBrick-======-unregisterFromAllAnnouncements  updateActions do: [:each |  each unregisterFromAllAnnouncements ]-======-resetDataCache  dataCache := nil-======-hintText  ^hintText ifNil: [ hintText := 'Need help?' ]-======-actOnPresentationUpdated: ann  self setLabelOf: window for: ann presentation-======-testShortcutFromKeymap  | action modifier |  modifier := Smalltalk os defaultModifier.  action := GLMAction new.  action keymap: modifier + $i asShortcut.  self assert: action keymap equals: modifier + $i asShortcut.  action keymap: modifier + $i shift.  self assert: action keymap equals: modifier + $i shift.  action keymap: nil.  self assertEmpty: action shortcutAsString-======-removeProperty: aSymbol  super removeProperty: aSymbol-======-testPortsInmmutability  < expectedFailure>  | aPane ports |  aPane := GLMPane in: 1.  self assertEmpty: aPane ports.  ports := aPane ports.  ports add: 1.  self assert: ports size equals: 1.  self assertEmpty: aPane ports-======-addAllBricks: aCollection  | bricks |  bricks := self privateAddAllBricks: aCollection.  bricks do: [:b |  self privatePrepareBrickAfterAdding: b ].  self doLayoutForce.  ^aCollection-======-minWidth  ^minWidth ifNil: [ minWidth := 0 ]-======-testSelectionAvailableWhenNoSelectionDisabled  | presentation |  presentation := GLMPresentation new.  presentation selection: 1.  self assert: presentation selection equals: 1.  self assert: presentation rawSelection equals: 1-======-paddingLeft: anInteger  self padding at: Left put: anInteger.  self updateCache-======-list: anObject  list := anObject-======-addContentsMorph  self contentsMorph: GLMMorphic emptyMorph.  self contentsMorph     layoutFrame: (LayoutFrame identity           leftOffset: 10;           topOffset: 10;           rightOffset: -10;           bottomOffset: -10);     hResizing: #spaceFill;     vResizing: #spaceFill.  self addMorphBack: self contentsMorph-======-updateTabs  | selectedTab |  self removeAllBricks.  self tabs ifEmpty: [ ^self ].  selectedTab := self selectedTab.  self tabs do: [:t |  t selected: t == selectedTab.        t hSpaceFill: (100 / self tabs size) asFloat ].  self addAllBricks: self tabs-======-textLightColor  ^Color gray-======-verticallyStackedArrangement  ^self stackedVerticallyArrangement-======-updateState: aRectangle  self brickBounds width = aRectangle width ifFalse: [ self markWidthDirty ].  self brickBounds height = aRectangle height ifFalse: [ self markHeightDirty ]-======-testBundleStrategy  | pane1 pane2 transmission presentation |  pane1 := GLMPane named: 'pane1'.  pane2 := GLMPane named: 'pane2'.  transmission := GLMTransmission new.  transmission ensureReplacePresentationsStrategy.  transmission addActiveOrigin: (pane1 port: #port1).  transmission destination: (pane2 port: #port2).  transmission addPresentation: GLMPresentation new.  (pane1 port: #port1) value: 1.  transmission transmit.  self assert: pane2 presentations size equals: 1.  presentation := pane2 presentations first.  (pane1 port: #port1) value: 2.  transmission transmit.  self assert: pane2 presentations first rootPrototype equals: presentation rootPrototype.  self assert: pane2 presentations first ~~ presentation-======-dataCache  ^dataCache ifNil: [ dataCache := self class defaultCache ]-======-zIndex  ^self layout zIndex brickValue: self-======-children  ^children ifNil: [ children := OrderedCollection new ]-======-shortcut  ^self keymap ifNotNil: [ self keymap currentCharacter ]-======-cell  ^cell-======-popupEditorShadowThemer  ^self registerModule: [ GLMBrickPopupEditShadowThemer new ] to: self named: #popupThemer-======-textBrick: aBrick  textBrick := aBrick.  self textBrick wrapped: true.  self textBrick layoutProperties     vSpaceFill;     hSpaceFill.  self addBrickBack: self textBrick-======-leftoverScrollRange  ^(self totalScrollRange - self innerBounds width roundTo: self scrollDeltaWidth) max: 0-======-renderPager: aBrowser  ^aBrowser hasFixedSizePanes ifTrue: [ GLMMorphicPagerRenderer render: aBrowser from: self ] ifFalse: [  ]-======-resetContentsRecursively  self resetContents.  self allContents do: [:each |  each resetContentsRecursively ]-======-profileSelection  self announce: GLMProfileSelection-======-renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderRubricHighlightedTextPresentation: self-======-newTextBrick  ^GLMRubEditingAreaBrick new-======-destination: aPort  destination := aPort-======-scrollToBottom  self band hasSubbricks ifFalse: [ ^self ].  self scrollTo: self band lastSubbrick-======-widthLeft: anInteger  self width at: Left put: anInteger-======-hintBrick: anObject  hintBrick := anObject.  self hintBrick textColor: self themer popupThemer textColor.  self contentBrick addBrickBack: self hintBrick-======-newHeaderMorph  ^(self theme newRowIn: self theme for: {self tabSelectorMorph .         self toolbarMorph})     cellInset: 0;     cellPositioning: #bottomCenter;     borderWidth: 0-======-scrollpane: anObject  scrollpane := anObject-======-actOnPaneRemoved: ann  container popPane-======-showAt: aPoint  self     openInWorld;     align: aPoint-======-createSimplePaneMorph  ^Morph new-======-evaluateSelection  self evaluateSelectionAndDo: [:result |  result ]-======-modifiedBlock  ^modifiedBlock-======-when: anAnnouncementClass send: selector to: target  self announcer when: anAnnouncementClass send: selector to: target-======-resetDataCache  dataCache := nil-======-rowMorphFor: aNodeMorph  | rowMorph cont |  rowMorph := aNodeMorph rowMorphForColumn: glamourColumn.  rowMorph ifNotNil: [ rowMorph borderWidth: 0 ] ifNil: [ rowMorph := self defaultRowMorph ].  cont := Morph new     color: Color transparent;     layoutPolicy: RowLayout new;     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     layoutInset: container columnInset @ container rowInset;     yourself.  cont addMorph: rowMorph.  self isFirstColumn ifTrue: [ | icon |        icon := container iconBlock value: aNodeMorph.        icon ifNotNil: [ cont addMorph: icon asMorph ].        cont layoutInset: 0 @ container rowInset ].  ^cont-======-paste  self announce: (GLMTextEditorRequest for: #paste)-======-width: anInteger  self brickBounds: (self brickBounds withWidth: anInteger)-======-calculateScrollbarHeight  | bandHeight firstIndex lastIndex |  bandHeight := self approximateBandHeight.  bandHeight = 0 ifTrue: [ ^0 ].  self scrollPane isFullyVisible ifTrue: [ ^0 ].  firstIndex := self scrollPane getIndex: self scrollPane band firstSubbrick.  lastIndex := self scrollPane getIndex: self scrollPane band lastSubbrick.  ^((lastIndex - firstIndex + 1) / self scrollPane model count * self height) ceiling-======-outOfWorld: aWorld  super outOfWorld: aWorld.  self brickRoot onRemovedFrom: self-======-hasBindingOf: aSymbol  ^self variableBindings includesKey: aSymbol-======-newTreeMorph  ^GLMPaginatedMorphTreeMorph new-======-isForScripting  ^isForScripting ifNil: [ false ]-======-valueFor: anElement withIndex: anInteger in: aGlamourColumn  ^self cacheAt: aGlamourColumn title for: anElement ifAbsentPut: [ self glamourPresentation column: aGlamourColumn valueFor: (self glamourPresentation isWithElementIndex ifTrue: [ anElement asGlamorousMultiValue , anInteger asGlamorousMultiValue ] ifFalse: [ anElement ]) ]-======-render: aPresentation  | container |  container := super render: aPresentation.  aPresentation shouldAllExpand ifTrue: [ treeMorph expandAll ].  aPresentation shouldRootsExpand ifTrue: [ treeMorph expandRoots ].  aPresentation shouldExpandToLevel ifTrue: [ treeMorph expandAllTo: aPresentation expandLevel ].  ^container-======-iconBrick  ^iconBrick-======-onOpened  super onOpened.  self textEditBrick     takeKeyboardFocus;     selectAll-======-custom: aPresentation  ^self add: aPresentation-======-actOnTextEditorRequest: ann  ann action value: textMorph textArea editor-======-initialize  super initialize.  self     useHorizontalLinearLayout;     hShrinkWrap-======-hShrinkWrap  self layout hShrinkWrap-======-testFreshBrickIsDirty  self assertBrickDirty: GLMBrick new-======-shadowColor: aColor  < brickBuilderProperty: #'Look&Feel' name: 'Shadow Color' as: #brickBuilderEvaluate getter: #shadowColor model: #GLMUIBuilderTextFieldProperty>  self setProperty: #brickShadowColor toValue: aColor-======-openInBrickWindowLabeled: aLabel  ^self class environment at: #GLMSystemWindowBrick ifPresent: [:glmSystemWindowBrick |  glmSystemWindowBrick new           label: aLabel;           color: Color transparent;           addBrickBack: (GLMBrick new vSpaceFill                 hSpaceFill;                 addBrickBack: self;                 yourself);           extent: 400 @ 400 * self currentWorld displayScaleFactor;           openCenteredInWorld ] ifAbsent: [ self asMorph openInWindow ]-======-normalizeWidth: anInteger of: aBrick  ^(anInteger max: (aBrick layout minWidth brickValue: aBrick)) min: (aBrick layout maxWidth brickValue: aBrick)-======-postCopy  port := port copy-======-resolveOriginPort: aPortReference  ^self resolvePort: aPortReference asGlamourOriginIdentifier defaultPortName: #selection-======-testMarkerOneStaticHeight  | brick |  brick := self newBrickWithStaticExtent.  self markFullyClean: brick.  brick wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthClean.  self assert: brick wrappedBounds isHeightDirty-======-sendToOutside: aPortName from: anOriginPortReference  self sendTo: #outer -> aPortName from: anOriginPortReference-======-calculateScrollbarTopOffset  | bandHeight firstIndex lastIndex |  bandHeight := self approximateBandHeight.  bandHeight = 0 ifTrue: [ ^0 ].  firstIndex := self scrollPane getIndex: self scrollPane band firstSubbrick.  lastIndex := self scrollPane getIndex: self scrollPane band lastSubbrick.  ^((firstIndex - 1) / self scrollPane model count * self height) floor-======-mouseLeave: evt  super mouseLeave: evt.  ^self deselect: evt-======-approximateWidth  ^self label approximateWidth + self hMargin + self hPadding-======-icon  ^nil-======-noActions  actions := nil.  dynamicActionsBlock := nil-======-updateCache  | left top right bottom |  left := self brickBounds origin x.  top := self brickBounds origin y.  right := self brickBounds corner x.  bottom := self brickBounds corner y.  innerBounds := (left + self paddingLeft) @ (top + self paddingTop) corner: (right - self paddingRight) @ (bottom - self paddingBottom).  outerBounds := (left - self marginLeft) @ (top - self marginTop) corner: (right + self marginRight) @ (bottom + self marginBottom)-======-interval  ^self start to: self end-======-glamourPresentation: aGlamourPresentation  glamourPresentation := aGlamourPresentation-======-color: aSymbolOrColor  color := aSymbolOrColor-======-alizarin  ^Color brickColorRegistry at: #brickAlizarin ifAbsentPut: [ Color r: 231 g: 76 b: 60 range: 255 ]-======-west  direction := West-======-printOn: aStream  super printOn: aStream.  aStream nextPut: $(.  ports printOn: aStream.  aStream nextPut: $)-======-portSymbol  ^portSymbol-======-tabLabelThemer  ^self registerModule: GLMBrickTabLabelDarkThemer new-======-testReferences  | browser pane1 |  browser := GLMExplicitBrowser new.  pane1 := browser addNewPaneNamed: #pane1.  self assert: (browser resolveOriginPort: #pane1) identicalTo: (pane1 port: #selection).  self assert: (browser resolveOriginPort: #pane1 -> #foo) identicalTo: (pane1 port: #foo).  self assert: (browser resolveDestinationPort: #pane1) identicalTo: (pane1 port: #entity).  self assert: (browser resolveDestinationPort: #pane1 -> #foo) identicalTo: (pane1 port: #foo).  self assert: ((browser resolveOriginPort: #outer) isKindOf: GLMPresentationBoundPort).  self assert: (browser resolveOriginPort: #outer) presentation identicalTo: browser.  self assert: (browser resolveOriginPort: #outer) name equals: #selection.  self assert: ((browser resolveOriginPort: #outer -> #foo) isKindOf: GLMPresentationBoundPort).  self assert: (browser resolveOriginPort: #outer -> #foo) presentation identicalTo: browser.  self assert: (browser resolveOriginPort: #outer -> #foo) name equals: #foo.  self assert: ((browser resolveDestinationPort: #outer) isKindOf: GLMPresentationBoundPort).  self assert: (browser resolveDestinationPort: #outer) presentation identicalTo: browser.  self assert: (browser resolveDestinationPort: #outer) name equals: #entity.  self assert: ((browser resolveDestinationPort: #outer -> #foo) isKindOf: GLMPresentationBoundPort).  self assert: (browser resolveDestinationPort: #outer -> #foo) presentation identicalTo: browser.  self assert: (browser resolveDestinationPort: #outer -> #foo) name equals: #foo-======-first  ^self presentations first-======-testSuspendAllWhile  | announcement instance |  announcer when: GLMTestAnnouncement do: [:ann |  announcement := ann ].  announcement := nil.  instance := announcer announce: GLMTestAnnouncement.  self assert: announcement equals: instance.  announcement := nil.  announcer suspendAllWhile: [ instance := announcer announce: GLMTestAnnouncement ].  self assert: announcement isNil-======-isHSpaceFill  ^self hState isOnParent-======-isLeftResizingZone: evt  ^(self globalBounds withWidth: resizingZoneWidth) containsPoint: evt position-======-toString: anObject  ^self glamourPresentation hasFilterBlock ifTrue: [ anObject ] ifFalse: [ super toString: anObject ]-======-testNoSelection  | browser treeMorph treeNodeMorph |  browser := GLMFinder new.  browser show: [:a |  a tree noSelection ].  window := browser openOn: ($a to: $d).  treeMorph := window submorphs last submorphs first submorphs first submorphs first submorphs first.  treeNodeMorph := treeMorph scroller submorphs first.  self send: treeMorph mouseUpOnItem: treeNodeMorph.  self assert: browser panes size equals: 1-======-scrollingDelay: anInteger  scrollingDelay := anInteger-======-allowDropOnItem: aBlock  allowDropOnItemBlock := aBlock-======-useExplicitNotNil  implicitNotNil := false-======-testEquality  self assert: (copiedBrowser = browser) not-======-check  self isChecked ifFalse: [ isChecked := true.        self announce: #onChecked.        self changed ]-======-actOnVariableBindingsUpdated: ann  textModel variableBindings: nil.  self addVariableBindingsOn: textModel from: ann presentation.  textModel changed: #text.  self flag: 'update just the style here'-======-totalPaneWidth  ^self innerBounds width - ((self sizing - 1) * self separatorWidth)-======-dynamicActionsOnSelection  (selectionDynamicActionsBlock isNil or: [ self selectedText isNil ]) ifTrue: [ ^OrderedCollection new ].  ^selectionDynamicActionsBlock glamourValue: self-======-onCompleted: aBlock  callback := aBlock-======-updateWidth: aBrick  aBrick isWidthClean ifTrue: [ Exception signal: 'Clean width can''t be updated!' ].  aBrick layout hState updateWidth: aBrick on: self-======-pane  ^pane-======-testPresentationTransformation  | dynamic |  dynamic := GLMDynamicPresentation new.  dynamic entity: 42.  dynamic presentationTransformation: [:some :entity |  (1 to: entity) do: [:each |  some text title: each asString ] ].  self assert: dynamic currentPresentation presentations size equals: 42.  self assert: dynamic currentPresentation pane identicalTo: dynamic pane-======-setUp  super setUp.  pagerModel := GLMPagerModel new scrollingDelay: 0.  pagerModel defaultNumberOfVisiblePages: 2-======-testMarkerOneChildrenWidth  | brick |  brick := self newBrickWithFullDependsOnChildren.  self markFullyClean: brick.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean-======-synchronizeScrollTo: aValue  pagerModel synchronizeScrollTo: aValue-======-privateHeight: anObject  self layout height: anObject-======-testPresentations  | expander |  expander := GLMExpander new.  expander show: [:a |  a text ].  expander startOn: #(#a #b #c).  self assert: expander panes size equals: 3.  self assert: expander panes first presentations entity value equals: #a.  self assert: expander panes first presentations size equals: 1.  self assert: (expander panes first presentations first isKindOf: GLMRubricTextPresentation)-======-defaultScrollButtonStyleFor: aButton  aButton checkedIcon: GLMUIThemeExtraIcons glamorousGrayCircleEmpty.  aButton checkedFocusedIcon: GLMUIThemeExtraIcons glamorousGrayCircle.  aButton normalImage: GLMUIThemeExtraIcons glamorousGrayCircleEmpty.  aButton selectedImage: GLMUIThemeExtraIcons glamorousGrayCircle.  aButton checkedImage: aButton checkedIcon-======-glamourPresentation: anObject  glamourPresentation := anObject-======-renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderFastTreePresentation: self-======-rubricTextFontSize  ^self valueOfProperty: #brickRubricTextFontSize ifAbsent: [ self themer rubricTextFontSize ]-======-doesNotUnderstand: aMessage  ^self brickRoot perform: aMessage selector withArguments: aMessage arguments-======-debugSelection  self announce: GLMDebugSelection-======-childrenValueOf: anObject atLevel: anInteger  self flag: 'this is rather hackish, but needed to treat list and tree in the same way.'.  ^OrderedCollection new-======-update  super update-======-padding  ^self wrappedBounds padding-======-sortByColumn: aGlamourColumn  columnToSortBy := columnToSortBy == aGlamourColumn ifTrue: [ nil ] ifFalse: [ aGlamourColumn ].  elements := self elementsSorted.  self glamourPresentation changed-======-allowItemDragBlock  ^allowItemDragBlock-======-addBrick: aBrick after: otherBrick  | result |  result := self privateAddBrick: aBrick asBrick after: otherBrick.  self privatePrepareBrickAfterAdding: result.  self doLayoutForce.  ^aBrick-======-testShortcutAsString  | action modifier |  modifier := Smalltalk os menuShortcutModifierString.  action := GLMAction new.  action shortcut: $i.  self assert: action shortcutAsString equals: modifier , '+i'.  action shortcut: $I.  self assert: action shortcutAsString equals: modifier , '+shift+i'.  action shortcut: nil.  self assertEmpty: action shortcutAsString-======-roots  roots ifNil: [ self roots: self glamourExpander panes ].  ^roots-======-add: newObject before: oldObject  collection add: newObject before: oldObject.  self announce: GLMItemAdded-======-actOnPresentationToolbarUpdated: ann  | dock |  self setLabelOf: window for: ann presentation.  dock := self renderToolbarForPresentation: ann presentation inMorph: window.  dock hResizing: #shrinkWrap.  window toolbarBox: dock-======-paneCount  ^paneCount-======-fromOutside: aPortName  ^self fromOutsidePort: aPortName-======-backgroundColor  ^self theme backgroundColor-======-measureOpeningTime  | browser numberOfOpenings time |  numberOfOpenings := 15.  browser := self defaultBrowser.  time := Time millisecondsToRun: [ numberOfOpenings timesRepeat: [ (browser openOn: 10) delete ] ].  ^{numberOfOpenings .   time}-======-bounds  ^bounds-======-click: evt  super click: evt.  ^true-======-firstVisiblePageIndex  ^firstVisiblePageIndex-======-outerBoundsInParent  ^self owner ifNotNil: [ self wrappedBounds outerBounds translateBy: self owner brickBounds origin ] ifNil: [ self wrappedBounds outerBounds ]-======-newBrickWithStaticExtent  ^GLMBrick new     height: self staticHeight;     width: self staticWidth;     color: Color random;     yourself-======-addItemMorph: aMorph after: anotherMorph  self addBrickBackNoLayout: aMorph.  self setBoundsOf: aMorph after: anotherMorph.  (self isPartiallyVisible: aMorph) ifFalse: [ self removeBrickNoLayout: aMorph.        ^nil ].  ^aMorph-======-isDoubleClickEnabled  ^isDoubleClickEnabled ifNil: [ isDoubleClickEnabled := false ]-======-addTransmission: aTransmission  aTransmission browser: self.  ^self transmissions addLast: aTransmission-======-layoutMorphs: aBoolean  shouldLayoutMorphs := aBoolean-======-hasUnacceptedEdits  ^hasUnacceptedEdits ifNil: [ hasUnacceptedEdits := false ]-======-* aNumber  < return: #Point>  ^aNumber negated @ 0-======-testMarkerOneParentWidth  | brick |  brick := self newBrickWithFullFill.  self markFullyClean: brick.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean-======-renderMorphPresentation: aMorphPresentation  ^GLMMorphicMorphRenderer render: aMorphPresentation from: self-======-isCollection  ^true-======-registerEventsForPresentation: aPresentation  super registerEventsForPresentation: aPresentation.  aPresentation when: GLMVariableBindingsChanged send: #actOnVariableBindingsUpdated: to: self.  aPresentation when: GLMEvaluateSelection send: #actOnEvaluateSelection: to: self.  aPresentation when: GLMCompileText send: #actOnCompileText: to: self.  aPresentation when: GLMDebugSelection send: #debugSelection to: self.  aPresentation when: GLMProfileSelection send: #profileSelection to: self.  aPresentation when: GLMPrintSelection send: #evaluateAndPrintSelection to: self-======-selectedBorderStyleFor: aBrick  ^self theme tabLabelSelectedBorderStyleFor: aBrick-======-compileTextIn: aContext from: aSession andDo: aBlock  self announce: (GLMCompileText new           presentation: self;           context: aContext;           session: aSession;           action: aBlock)-======-sortByColumn: aGlamourColumn  columnToSortBy := columnToSortBy == aGlamourColumn ifTrue: [ nil ] ifFalse: [ aGlamourColumn ].  columnToSortBy ifNotNil: [ self rootItem children: (self rootItem children sorted: self sortBlock) ] ifNil: [ self rootItem data: self basicRoots ].  self glamourPresentation changed-======-onRemovedFrom: aBrick  -======-registerModule: aModule  ^self registerModule: aModule to: self named: thisContext sender selector-======-acceptDroppingMorph: transferMorph event: evt inMorph: listMorph  | targetItem |  targetItem := (listMorph scrollerSubMorphFromPoint: evt position) complexContents item.  ^self glamourPresentation accept: transferMorph passenger droppedOnItem: targetItem-======-composite: anObject  composite := anObject-======-shouldUseCache  ^self parameters at: 'shouldUseCache' ifAbsent: [ false ]-======-delete  super delete.  isOpen := false-======-testCompositeInTheParentPane  | browser |  browser := GLMBrowser new.  self assert: (browser pane presentations isKindOf: GLMCompositePresentation).  self assert: browser pane presentations size equals: 1.  self assert: browser pane presentations first equals: browser-======-isHeightClean  ^self brick wrappedBounds isHeightClean-======-wrapped  ^wrapped ifNil: [ wrapped := true ]-======-percent  ^percent-======-testMultipleSelectionWithChange  | browser firstTreeMorph secondTreeMorph treeNodeMorph lastTreeNodeMorph |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a list           beMultiple;           display: [:x |  x - 2 to: x ] ].  window := browser openOn: 4.  firstTreeMorph := window submorphs last submorphs first submorphs first submorphs first.  treeNodeMorph := firstTreeMorph scroller submorphs first.  lastTreeNodeMorph := firstTreeMorph scroller submorphs last.  self send: firstTreeMorph mouseUpOnItem: treeNodeMorph.  self send: firstTreeMorph mouseUpWithShift: true onItem: lastTreeNodeMorph.  self assert: (firstTreeMorph model selection selectedNodePathList collect: [:each |  each first item ]) asOrderedCollection equals: #(2 3 4) asOrderedCollection.  (browser pane port: #entity) value: 42.  secondTreeMorph := window submorphs last submorphs first submorphs first submorphs first.  treeNodeMorph := secondTreeMorph scroller submorphs first.  lastTreeNodeMorph := secondTreeMorph scroller submorphs second.  self send: secondTreeMorph mouseUpOnItem: treeNodeMorph.  self send: secondTreeMorph mouseUpWithShift: true onItem: lastTreeNodeMorph.  self assert: (secondTreeMorph model selection selectedNodePathList collect: [:each |  each first item ]) asOrderedCollection equals: #(40 41) asOrderedCollection-======-id: anObject  id := anObject-======-specificTableMorphInitializiation  | presentation |  presentation := tableModel glamourPresentation.  tableMorph rowHeight: presentation rowHeight.  presentation isSearchable ifTrue: [ tableMorph enableSearch ].  presentation isFilterable ifTrue: [ presentation needActionButton ifTrue: [ tableMorph enableFilterWithAction: presentation actionBlock named: presentation actionName ] ifFalse: [ presentation hasFilterBlock ifTrue: [ tableMorph enableFilter: (GLMFilterBlock block: presentation filterBlock) ] ifFalse: [ tableMorph enableFilter ] ] ].  (presentation isFilterable or: [ presentation isSearchable ]) ifFalse: [ tableMorph disableFunction ] ifTrue: [ tableMorph explicitFunction ]-======-spotterThemer  ^self registerModule: GTSpotterWidgetThemer new to: GTSpotterBrickThemer new-======-readyToBeDisplayed  self glamourPresentation announcer announce: (GLMDataSourceUpdated newDataSource: self)-======-invalidateLayout  ^self brick invalidateLayout-======-addLazyPage: aBlock label: aStringOrMorph toolbar: aToolbar  self addLazyPage: aBlock label: aStringOrMorph toolbar: aToolbar collapsable: false-======-isMenu  ^self hasTitle and: [ self hasIcon not ]-======-render: aPane  paneMorph := GLMMorphic containerMorph.  aPane when: GLMMatchingPresentationsChanged send: #actOnMatchingPresentationsChanged: to: self.  self renderMorphFor: aPane.  ^paneMorph-======-addRow: aBlockOrSymbol  | newRow cell |  cell := aBlockOrSymbol isSymbol ifTrue: [ self browser addNewPaneNamed: aBlockOrSymbol.        GLMCustomRow new           id: aBlockOrSymbol;           browser: self browser ] ifFalse: [ newRow := GLMCustomRow new browser: self browser.        aBlockOrSymbol value: newRow.        newRow ].  self children addLast: cell.  ^cell-======-privateStyle: aText  | styledText |  aText makeAllColor: Color red.  styledText := self parser parse: aText asString onError: [  ].  (styledText notNil and: [ styledText ~~ aText ]) ifTrue: [ self flag: 'change only the runs array of the original text.'.        aText setString: aText string setRunsChecking: styledText runs ]-======-newPane  ^newPane-======-initializeTextMorph  textMorph := RubScrolledTextMorph new.  textMorph     beReadOnly;     beWrapped;     textFont: self theme textFont;     textColor: self theme textColor;     backgroundColor: self theme errorPopperBackgroundColor.  self     vResizing: #spaceFill;     hResizing: #spaceFill;     addMorph: textMorph fullFrame: LayoutFrame identity-======-allowItemDrag: aBlock  allowItemDragBlock := aBlock-======-privateScrollPosition: anInteger  scrollPosition := anInteger.  self announcer announce: GLMBrickScrollPositionChanged new-======-relabelTab: aTab with: aStringOrBrick  aTab label: aStringOrBrick.  self updateTabs-======-newVerticalScrollbar  ^GLMScrollbarBrick new-======-shouldBeDisplayedByText  self containerTree shouldFilterByTextInput ifFalse: [ ^true ].  self withContentsDo: [:node |  self flag: 'this should be delegated to the presentation		and glamourValue should be used to include the entity ports'.        (self containerTree glamourPresentation filterStrategy value: self containerTree inputText asString value: node item) == true ifTrue: [ ^true ] ].  ^false-======-isOnParent  ^false-======-asyncTask  ^asyncTask ifNil: [ asyncTask := GLMAsyncTask new ]-======-isVShrinking  ^vResizing = #shrinkWrap-======-addBrickBackNoLayout: aBrick before: anotherBrick  self band doNotLayoutDuring: [ self band addBrick: aBrick before: anotherBrick ].  ^aBrick-======-renderCustomColumn: aCell ofPane: aPane inUI: aMorph inBrowser: aBrowser  | pane totalSpans totalSizes currentSpanPosition currentOffset |  totalSpans := aCell children inject: 0 into: [:sum :each |  sum + each span ].  totalSizes := aCell children inject: 0 into: [:sum :each |  sum + each size ].  currentSpanPosition := 0.  currentOffset := 0.  aCell children keysAndValuesDo: [:index :each |  each hasId ifTrue: [ pane := self renderObject: (aBrowser paneNamed: each id) ] ifFalse: [ pane := GLMMorphic containerMorph.              self renderCustomRow: each ofPane: aPane inUI: pane inBrowser: aBrowser.              pane addPaneSplitters ].        pane layoutFrame: (LayoutFrame new                 topFraction: currentSpanPosition / totalSpans offset: currentOffset - (totalSizes * currentSpanPosition / totalSpans) rounded + self margin;                 leftFraction: 0 offset: 0;                 bottomFraction: (currentSpanPosition + each span) / totalSpans offset: currentOffset + each size - (totalSizes * (currentSpanPosition + each span) / totalSpans) rounded - self margin;                 rightFraction: 1 offset: 0;                 yourself).        aMorph addMorphBack: pane.        currentSpanPosition := currentSpanPosition + each span.        currentOffset := currentOffset + each size ].  aCell children last size > 0 ifTrue: [ (aMorph submorphs atLast: 2) layoutFrame bottomOffset: (aMorph submorphs atLast: 2) layoutFrame bottomOffset - currentOffset.        aMorph submorphs last layoutFrame topOffset: aMorph submorphs last layoutFrame topOffset - currentOffset.        aMorph submorphs last layoutFrame bottomOffset: aMorph submorphs last layoutFrame bottomOffset - currentOffset ].  aMorph addPaneSplitters-======-testFillBrickInsideStatic  | root brick |  root := self newBrickWithStaticExtent.  brick := self newBrickWithFullFill.  brick brickApi layout hState isOnParent.  brick brickApi layout vState isOnParent.  root addBrickBack: brick.  self assertAllSubbricksAreClean: root.  self assert: brick extent equals: root extent-======-press  super press.  self closePopup-======-modelFor: aPresentation  | highlightContext |  highlightContext := aPresentation highlightSmalltalkContext.  ^GLMRubricSmalltalkTextModel new     glamourPresentation: aPresentation;     highlightSmalltalk: highlightContext notNil;     highlightSmalltalkContext: highlightContext;     yourself-======-complete: anObject callback: aBlock  process ifNil: [ ^self terminate ].  process isTerminated ifFalse: [ ^self ].  callback = aBlock ifFalse: [ ^self terminate ].  callback ifNotNil: [ callback cull: anObject ].  process := nil-======-glmSubscriptions  ^registry subscriptions-======-updatePanes  self basicUpdateSizing.  self layoutPanes.  self hideOrShowScrollBar.  self setScrollDeltas.  self scrollToRight-======-verticalScrollbar  ^verticalScrollbar-======-rowMorphForItem: anItem  | rowElements |  rowElements := OrderedCollection new.  anItem depth timesRepeat: [ rowElements add: self class emptyMorph ].  rowElements add: (self buttonFor: anItem).  (self iconFor: anItem data) ifNotNil: [:icon |  rowElements add: icon asMorph ].  rowElements     add: (self formatedDisplayValueOf: anItem data) asMorph asReadOnlyMorph;     addAll: (self tagMorphsFrom: self glamourPresentation for: anItem data).  ^Smalltalk ui theme newRowIn: self currentWorld for: rowElements-======-bindingsStrategy: aBlock  bindingsStrategy := aBlock-======-postCopy  super postCopy.  presentations ifNotNil: [:arg |  presentations := presentations collect: [:each |  each copy ] ].  arrangement ifNotNil: [:arg |  arrangement := arrangement copy.        arrangement composite: self ]-======-text: aTextOrString  text := aTextOrString.  self glamourPresentation ifNotNil: [:presentation |  presentation text: text ]-======-click: anEvent  super click: anEvent.  self announcer announce: (GLMPagerButtonClicked new buttonModel: self)-======-measureSelectionTimeForSize: size  | browser numberOfSelections time port window |  numberOfSelections := 15.  browser := self defaultBrowser.  window := browser openOn: size.  port := browser panes first ports second.  time := Time millisecondsToRun: [ size - numberOfSelections to: size do: [:i |  port value: i ] ].  window delete.  ^{size .   time}-======-computeTagsFilterFor: aGlamourValue  ^self computeTagsFor: aGlamourValue from: self tagsFilterBlock-======-textColor: aColor  < brickBuilderProperty: #Text name: 'Text color' as: #brickBuilderEvaluate getter: #textColor model: #GLMUIBuilderTextFieldProperty>  self label textColor: aColor.  self dotsBrick textColor: aColor-======-cellColumn: column row: rowIndex  | element cell |  element := self elementAt: rowIndex.  cell := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForElement: element);     yourself.  ^cell-======-sortBlock: aBlock  sortBlock := aBlock-======-testBrickDependsOnChildrenOneStatic  | root brick |  root := self newBrickWithFullDependsOnChildren.  brick := self newBrickWithStaticExtent.  root addBrickBack: brick.  self assert: root brickApi layout hState isOnChildren.  self assert: root brickApi layout vState isOnChildren.  self assertAllSubbricksAreClean: root.  self assert: root extent equals: brick extent-======-headerFor: anObject in: aCollapsable  | header |  header := GLMBrick new.  header     hSpaceFill;     vShrinkWrap.  header addBrickBack: (anObject isVariableBinding ifTrue: [ anObject key asBrick ] ifFalse: [ anObject asBrick ]) hSpaceFill.  (self hasChildren: anObject) ifTrue: [ header addBrickFirst: (self newToggleButtonFor: aCollapsable) ].  ^header-======-act: aBlock on: aCharacter  self addAction: (GLMGenericAction new           action: aBlock;           shortcut: aCharacter;           yourself)-======-remove: anObject  collection remove: anObject.  self announce: GLMItemRemoved-======-separatorAfter  ^separatorAfter ifNil: [ false ]-======-paneMargin  self flag: 'fix support of margin'.  ^0-======-property  ^property-======-testUnregisterFromAnnouncementsWhenUpdating  | composite announcingCollection numberOfExecutions |  numberOfExecutions := 0.  announcingCollection := GLMAnnouncingCollection new.  composite := GLMCompositePresentation new with: [:a |  a text           updateOn: GLMItemAdded from: [ announcingCollection ];           display: [ numberOfExecutions := numberOfExecutions + 1 ] ].  window := composite openOn: announcingCollection.  1 to: 3 do: [:each |  announcingCollection add: each ].  self assert: numberOfExecutions equals: 4-======-onLayouted  self doNotUpdateDuring: [ self update ]-======-rowHeight  ^self rowHeightBlock glamourValue: self asGlamorousMultiValue , self entity asGlamorousMultiValue-======-lazyPageMorphCreation: anObject  lazyPageMorphCreation := anObject-======-loremIpsum  ^String loremIpsum: 81233-======-updatePreview: anIndex  self announcer announce: (GLMPagerPreviewUpdate new pageIndex: anIndex)-======-transformation  ^transformation ifNil: [ transformation := [:x |  x ] ]-======-onMyselfDo: aBlock  ^self on: #isOnMyself do: aBlock ifAbsent: [ GLMBrickLayoutMyselfState new ]-======-findSatisfying: aBlock in: aMorph  aMorph allMorphsDo: [:each |  (aBlock value: each) ifTrue: [ ^each ] ].  self fail-======-paddingLeft  ^self wrappedBounds paddingLeft-======-withIndexDo: aBlock  ^collection withIndexDo: aBlock-======-asGlamourTargetIdentifier  self portName ifNil: [ self portName: self class defaultTargetPortName ].  ^self-======-arrangement: anArrangement  anArrangement composite: self.  ^arrangement := anArrangement-======-entity  ^entity-======-minimumPageNumberForScrollbar  ^minimumPageNumberForScrollbar-======-assertHeightDirty: aBrick  self assert: aBrick wrappedBounds heightState equals: #dirty.  self assert: aBrick wrappedBounds isHeightDirty.  self assert: aBrick wrappedBounds isHeightClean not-======-isHorizontal: anObject  isHorizontal := anObject-======-registerModule: aModule to: aThemer  ^self registerModule: aModule to: aThemer named: thisContext sender selector-======-toWatcher  ^self destination: (self browser watcherPane port: #entity)-======-populate: aPortSymbol iconName: aSymbol on: aCharacter entitled: aString with: aBlock  self populate: aPortSymbol icon: (self iconNamed: aSymbol) on: aCharacter entitled: aString with: aBlock-======-presentations: anObject  presentations := anObject-======-menuColumn: column row: rowIndex  | menu subMenus targetMenuMorph subMenu |  menu := UIManager default newMenuIn: self table for: self.  subMenus := Dictionary new.  self allMenuActions do: [:action |  targetMenuMorph := action category notNil ifTrue: [ subMenus at: action category ifAbsentPut: [ subMenu := MenuMorph new.                    menu add: action category subMenu: subMenu.                    subMenu ] ] ifFalse: [ menu ].        (targetMenuMorph add: action title target: self selector: #executeMenuAction: argument: action)           icon: action icon;           balloonText: action help;           enabled: (action isEnabledOn: self glamourPresentation);           keyText: (action hasShortcut ifTrue: [ action shortcutAsString ] ifFalse: [ nil ]) ].  ^menu-======-cellColumn: aColumn row: aRowIndex  | item cell |  item := self elementAt: aRowIndex.  cell := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForColumn: aColumn item: item withIndex: aRowIndex);     yourself.  ^cell-======-testCodeExecutionWithBindings  | composite textMorph result |  composite := GLMCompositePresentation new.  composite pharoScript.  window := composite openOn: 'a:=1'.  result := nil.  textMorph := self find: RubScrolledTextMorph in: window.  textMorph textArea editor evaluateSelectionAndDo: [:r |  result := r ].  self assert: result equals: 1-======-rightAngle: aDirection  ^aDirection = GLMNorthDirection uniqueInstance-======-stylerStyled: styledCopyOfText  next ifNil: [ ^self ].  text runs: styledCopyOfText runs.  (self textArea scrollPane ifNil: [ self textArea ]) changed-======-onDraw: aCanvas  self renderer render: self on: aCanvas-======-render: aPresentation  textModel := self textModelFor: aPresentation.  textMorph := self textMorphForModel: textModel.  textModel text: textMorph text.  textMorph setSelection: textModel selection.  self installActionsOnModel: textModel fromPresentation: aPresentation.  self installKeystrokeActionsOnMorph: textMorph textMorph fromPresentation: aPresentation.  textMorph announcer when: GLMSelectedTextChanged do: [:ann |  aPresentation announcer suspendAllWhile: [ aPresentation selectionInterval: ann interval.              aPresentation selectedText: ann selectedText ] ].  textMorph announcer when: GLMTextChanged do: [:ann |  aPresentation suspendAllWhile: [ aPresentation text: ann text ] ].  self registerEventsForPresentation: aPresentation.  ^textMorph-======-open: aPopupBrick with: aRectangle  ^aPopupBrick openAbove: aRectangle-======-isWidthClean  ^self brick wrappedBounds isWidthClean-======-buttonBorderColor  ^Color lightGray-======-presentation  presentation ifNil: [ | morph |        morph := GLMMorphicRenderer new render: self glmPres.        morph hResizing: #spaceFill.        morph vResizing: #spaceFill.        presentation := MorphicGenericAdapter morph: morph ].  ^presentation-======-selectedIndex  ^selectedIndex ifNil: [ selectedIndex := 0 ]-======-selectionIndex: anInteger  selectionIndex := anInteger-======-onButtonDeselected  GLMPagerPanePreviewMorph uniqueInstance hideFromWorld-======-readyToBeDisplayed  self glamourPresentation announcer announce: (GLMDataSourceUpdated newDataSource: self)-======-onLostFocus  self isCancelOnFocusLost & self isEditMode ifTrue: [ self cancel ].  self isEditMode ifTrue: [ self animateToEditNotFocused ] ifFalse: [ self animateToNormal ]-======-watcherPane  ^watcherPane ifNil: [ watcherPane := GLMPane named: #_watcher ]-======-privateRemoveOutWorld: aBrick  aBrick outOfWorld: aBrick world-======-actionSelector  ^#morphicActOn:-======-border  ^self valueOfProperty: #brickBorder ifAbsentPut: [ GLMBrickBorder new ]-======-variableBindings  ^(variableBindingsBlock glamourValue: self entity) ifNil: [ OrderedCollection new ]-======-testAccordion  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a accordionArrangement.        a list title: 'List'.        a text title: 'Text' ].  window := browser openOn: 42.  self assert: self compositePanel submorphs notEmpty.  self assert: self compositePanel submorphs size equals: 2.  self assert: self compositePanel submorphs first class equals: ExpanderMorph.  self assert: self compositePanel submorphs last class equals: ExpanderMorph-======-clear  arrangement := nil.  presentations := nil-======-testPanes  self assert: copiedBrowser panes size equals: 2.  self assert: copiedBrowser panes first ~~ browser panes first.  self assert: copiedBrowser panes last ~~ browser panes last.  self assert: copiedBrowser panes first browser identicalTo: copiedBrowser.  self assert: copiedBrowser panes last browser identicalTo: copiedBrowser.  self assert: copiedBrowser panes first ports size equals: 1.  self assert: copiedBrowser panes first ports first name equals: #selection.  self assert: copiedBrowser panes first ports first pane identicalTo: copiedBrowser panes first.  self assert: copiedBrowser panes last ports size equals: 2.  self assert: copiedBrowser panes last ports first name equals: #selection.  self assert: copiedBrowser panes last ports last name equals: #entity-======-addBrick: aBrick before: otherBrick  | result |  result := self privateAddBrick: aBrick asBrick before: otherBrick.  self privatePrepareBrickAfterAdding: result.  self doLayoutForce.  ^aBrick-======-glmAnimateValue: aValue duration: anInteger  self glmAnimateValue: aValue duration: anInteger callback: nil-======-layoutSubbricks  self layoutPolicy layout: self brickApi in: self innerBounds-======-actionThemer  ^GLMActionBrickThemer new-======-textEditBrick  ^textEditBrick-======-renderFastTreePresentation: aPresentation  ^GLMMorphicFastTreeRenderer render: aPresentation from: self-======-separatorWidth  ^20-======-columns: aCollection  columns := aCollection-======-animateToEditNotFocused  self borderAnimation     from: self borderColor first;     to: self themer normalBorderColor;     animate: self-======-column: aBlockOrString evaluated: aBlock modified: aModifiedBlock  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           modifiedBlock: aModifiedBlock)-======-defaultSelectionActions  ^self executionSelectionActions-======-leftShadowOf: aBrick on: aCanvas  | gradient width origin offset |  width := aBrick shadowWidth.  offset := width negated @ width / 2.0.  origin := aBrick brickBounds topLeft + offset + aBrick shadowOffset.  gradient := (self shadowGradientFor: aBrick)     origin: origin - offset + ((width / 2.0) @ 0);     direction: (width @ 0) negated;     yourself.  aCanvas fillRectangle: (origin extent: width @ (aBrick height - width)) fillStyle: gradient-======-changed  self world ifNil: [ ^self ].  ^fullBounds ifNil: [ self invalidRect: self bounds ] ifNotNil: [ self invalidRect: fullBounds ]-======-testMarkerOneChildrenInStaticWidth  | root brick |  root := self newBrickWithStaticExtent.  brick := self newBrickWithFullDependsOnChildren.  root addBrickBack: brick.  self markFullyClean: root.  brick wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: brick brickApi.  self assert: brick wrappedBounds isWidthDirty.  self assert: brick wrappedBounds isHeightClean.  self assert: root wrappedBounds isWidthClean.  self assert: root wrappedBounds isHeightClean-======-announcer  ^announcer ifNil: [ announcer := GLMAnnouncer new ]-======-popup: aPopupBrick event: anEvent  < return: #Boolean>  ^anEvent type == #keystroke and: [ anEvent keyCharacter = Character escape ]-======-shouldDisplayPresentationCreatedBy: aCollection  ^true-======-scrollBarColor  ^self valueOfProperty: #brickScrollbarColor ifAbsent: [ self themer scrollbarColor ]-======-tabWidth  ^tabWidth ifNil: [ TextStyle default rubTabWidth ]-======-actualPageMorph: anObject  actualPageMorph := anObject-======-subbrickBefore  | link |  link := self brickDoubleLink.  link ifNil: [ ^nil ].  link previousLink ifNil: [ ^nil ].  ^link previousLink value-======-renderFastListPresentation: aPresentation  ^GLMMorphicFastListRenderer render: aPresentation from: self-======-scrollDown: anInteger  self band translateY: anInteger negated.  self isBottomOverscrolled ifTrue: [ self moveBandBottom ]-======-tearDown  window ifNotNil: [ window delete ].  super tearDown-======-variableBindings: aBlock  ^variableBindingsBlock := aBlock-======-colorRight  ^self color at: Right-======-testUnregisterAnnouncementsWhenRemovingPane  | announcer presentation browser pane |  announcer := Announcer new.  browser := GLMBrowser new.  pane := GLMPane new.  presentation := GLMPresentation new.  pane addPresentation: presentation.  browser addPane: pane.  presentation updateOn: GLMTestAnnouncement from: [ announcer ].  presentation registerAnnouncements.  self assert: announcer numberOfSubscriptions equals: 1.  browser removePane: pane.  self assert: announcer numberOfSubscriptions equals: 0-======-vMargin  ^self marginTop + self marginBottom-======-addActiveOrigin: aPort  ^self originReferences add: (GLMOriginPortReference new           port: aPort;           beActive;           yourself)-======-glamourPresentation  ^glamourPresentation-======-testFinder  | finder |  finder := GLMFinder new.  finder show: [:a |  a title: 'something'.        a stackedArrangement.        a list.        a text ].  self assert: finder transmission transmissionStrategy presentations size equals: 2.  finder startOn: (1 to: 42).  self assert: finder panes first presentations size equals: 2.  self assert: (finder panes first presentations arrangement isKindOf: GLMStackedVerticallyArrangement).  window := finder open.  self find: LazyTabGroupMorph in: window-======-presentations  ^self pane presentations-======-removeTabIndex: anInteger  self tabs removeAt: anInteger.  self selectedIndex: 0.  self tabs ifNotEmpty: [ self selectedIndex: (self selectedIndex - 1) \\ self tabs size + 1 ]-======-font: aLogicalFont  self label font: aLogicalFont.  self dotsBrick font: aLogicalFont-======-selectToLeft  self selectedPageIndex: self selectedPageIndex - 1-======-glamourPresentation  ^glamourPresentation-======-openInBrickWindow  ^self openInBrickWindowLabeled: self-======-sizeLogic: aBlockWithNoParameters  countLogic := aBlockWithNoParameters-======-initialize  super initialize.  self on: #keyStroke send: #handleKeyStroke: to: self.  hasInitialStep := false-======-textModelFor: aPresentation  ^GLMTextModel new     text: aPresentation formatedDisplayValue;     glamourPresentation: aPresentation-======-testAccordionWithTitle  | browser |  browser := GLMTabulator new.  browser column: #one.  browser transmit     to: #one;     andShow: [:a |  a accordionArrangement.        a title: 'title'.        a list.        a text ].  window := browser openOn: 42.  self assert: self compositeTabGroup submorphs notEmpty.  self assert: self compositeTabGroup submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph class equals: GLMPanelMorph.  self assert: self compositeTabGroup contentMorph submorphs first submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph submorphs first submorphs first class equals: ExpanderMorph-======-gtActionsIn: composite  < gtInspectorPresentationOrder: 50>  composite list     title: 'Actions';     display: [ self actions ];     format: [:each |  each gtDisplayString ]-======-column: aBlockOrString evaluated: aBlock width: aNumber tags: anObject sortedBy: aSortingBlock  self addColumn: (GLMTableColumn new           title: aBlockOrString;           computation: aBlock;           width: aNumber;           tags: anObject;           sortBlock: aSortingBlock yourself)-======-origin: aPoint length: aLength breadth: aBreadth  ^aPoint extent: aLength @ aBreadth-======-from: anObject  fromLogic := anObject-======-hAlign  ^self layout hAlign-======-helpMessage  ^helpMessage ifNil: [ helpMessage := 'Search Input' ]-======-newSliderBrick  ^GLMPagerScrollSlidingBrick new-======-isWidthDirty  ^self widthState = #dirty-======-transformation  ^transformation-======-render: aBrowser  container := GLMMorphic containerMorph.  container     changeTableLayout;     listDirection: #leftToRight;     vResizing: #spaceFill;     hResizing: #shrinkWrap.  scrollPane := GeneralScrollPane new     changeScrollerTableLayout;     scrollTarget: container;     yourself.  self registerAnnouncementsFor: aBrowser.  aBrowser panes do: [:each |  self addMorphFromObject: each toContainer: container ].  ^scrollPane-======-modules  ^modules ifNil: [ modules := Dictionary new ]-======-glamourAction: anObject  glamourAction := anObject-======-transformation: anObject  transformation := anObject-======-testInnerTransmissions  | browser1 browser2 presentation innerBrowser |  browser1 := GLMExplicitBrowser new.  browser2 := GLMExplicitBrowser new.  presentation := GLMPresentation new.  browser1 addNewPane name: 'pane1'.  browser2 addNewPane name: 'innerpane 1'.  browser1 addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: browser1;                 name: #entity;                 yourself);           destination: (browser1 panes first port: #entity);           addPresentation: browser2;           yourself).  browser2 addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: browser2;                 name: #entity;                 yourself);           destination: (browser2 panes first port: #entity);           addPresentation: presentation;           yourself).  (browser1 pane port: #entity) value: 42.  innerBrowser := browser1 panes first presentations first.  self assert: innerBrowser transmissions size equals: 1.  self assert: (innerBrowser transmissions first origins first isKindOf: GLMPresentationBoundPort).  self assert: innerBrowser transmissions first origins first pane identicalTo: browser1 panes first-======-hasMinHeight  ^(self minHeight isNumber ifTrue: [ self minHeight <= 0 ] ifFalse: [ false ]) not-======-action  ^action-======-vPadding  ^self paddingTop + self paddingBottom-======-isEntityPort  ^self name = #entity-======-when: anAnnouncementClass send: selector to: target  self announcer when: anAnnouncementClass send: selector to: target-======-toggleFilteringByTag: aTag  (self shouldFilterByTag: aTag) ifTrue: [ self tagsToFilterBy remove: aTag ] ifFalse: [ self tagsToFilterBy add: aTag ].  self resetChildrenContent.  self tableRefresh-======-printSelection  self announce: GLMPrintSelection-======-actOnPaneReplaced: ann  container brickRoot popAndReplacePane: (self renderObject: ann newPane)-======-renderGlamorouslyOn: aRenderer  self registerAnnouncements.  ^aRenderer renderFastTablePresentation: self-======-selectedClassOrMetaClass  ^self highlightSmalltalkContext-======-addPresentations: aCollection  self notingPresentationChangeDo: [ aCollection do: [:each |  self addPresentationSilently: each ] ]-======-category  ^category-======-testFullAlignCenterShrinkWrapInSpaceFill  | root brick1 brick2 brick3 increment |  increment := 10.  root := self newBrickWithStaticExtent.  brick1 := self newBrickWithFullFill.  brick2 := self newBrickWithFullDependsOnChildren.  brick3 := self newBrickWithSmallStaticExtent.  brick2     vAlign: #center;     hAlign: #center.  root addBrickBack: brick1.  brick1 addBrickBack: brick2.  brick2 addBrickBack: brick3.  self assertAllSubbricksAreClean: root.  self assert: brick2 brickBounds equals: ((self staticExtent - self staticSmallExtent) / 2 extent: self staticSmallExtent) ceiling.  brick3     height: brick3 height + increment;     width: brick3 width + increment.  self assertAllSubbricksAreClean: root.  self assert: brick2 brickBounds equals: ((self staticExtent - self staticSmallExtent) / 2 - (increment / 2) extent: self staticSmallExtent + increment) ceiling-======-icon  ^icon ifNil: [ icon := [ nil ] ]-======-acceptsSelection: aBoolean  acceptsSelection := aBoolean-======-filterBlock: anObject  filterBlock := anObject-======-color  ^self valueOfProperty: #brickBackgroundColor ifAbsent: [ self themer backgroundColor ]-======-testStartingPreservesItself  | composite finder |  composite := GLMCompositePresentation new.  finder := composite finder.  composite startOn: 42.  self assert: composite pane presentations equals: composite.  self assert: composite first identicalTo: finder-======-presentation  ^presentation-======-layoutPolicy  ^self brick layoutPolicy-======-addRow: aBlockOrSymbol size: anInteger  ^(self addRow: aBlockOrSymbol)     size: anInteger;     span: 0-======-buttonForTag: each filter: filter  ^(GLMMorphic togglingButtonLabelled: each pressed: (self shouldFilterByTag: filter) style: self glamourPresentation tagsStyle)     target: self;     actionSelector: #toggleFilteringByTag:;     arguments: (Array with: filter);     yourself-======-collapse  self contentBrick ifNil: [ ^self ].  self isExpanded ifTrue: [ self removeBrick: self contentBrick ]-======-bindingsStrategy  ^bindingsStrategy ifNil: [ bindingsStrategy := self defaultBindingsStrategy ]-======-testGlamourValueWithArgs  self assert: ([ #foo ] glamourValueWithArgs: #(1 2)) equals: #foo.  self assert: ([:first |  Array with: first ] glamourValueWithArgs: #(1 2)) equals: #(1).  self assert: ([:first :second |  Array with: first with: second ] glamourValueWithArgs: #(1 2)) equals: #(1 2).  self assert: ([:first :second :third |  Array with: first with: second with: third ] glamourValueWithArgs: #(1 2)) equals: #(1 2 nil).  self assert: (#yourself glamourValueWithArgs: #(1 2)) equals: 1.  self assert: (#yourself glamourValueWithArgs: #()) equals: nil-======-markWidthClean  ^self brick wrappedBounds markWidthClean-======-isVFilling  ^vResizing = #spaceFill-======-browser  browser ifNil: [ ^GLMNoBrowser new ].  ^browser-======-vState  ^GLMBrickLayoutDummState new-======-testCachedPresentation  | dynamic currentPresentation |  dynamic := GLMDynamicPresentation new.  dynamic entity: 42.  dynamic transformation: [:entity |  GLMRubricTextPresentation new ].  currentPresentation := dynamic currentPresentation.  self assert: dynamic cachedPresentation identicalTo: currentPresentation-======-buttonsBrick: aBrick  buttonsBrick := aBrick.  self buttonsBrick pagerModel: pagerModel.  self buttonsBrick     hShrinkWrap;     vShrinkWrap.  self addBrickBack: self buttonsBrick-======-act  self subclassResponsibility-======-beEdit  self isEditMode ifTrue: [ ^self ].  self editBrick updateTextWith: self labelBrick text.  self editBrick moveCursorToIndex: self labelBrick text size + 1.  self addBrickFirst: self editBrick.  self removeBrick: self labelBrick.  self borderColor: (self themer focusedBorderColor alpha: 0).  self editBrick rubric takeKeyboardFocus.  self announce: #onEditMode-======-maxWidth: anObject  self layout maxWidth: anObject-======-backgroundColor  ^Color transparent-======-maxHeight: anObject  maxHeight := anObject-======-sendOneOrMultiple  self sendOneOrMultipleAs: Array-======-testJumpstartTransmission  | browser presentation |  browser := GLMExplicitBrowser new.  presentation := GLMPresentation new.  browser addNewPane.  browser addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           addActiveOrigin: (browser pane port: #entity);           destination: (browser panes first port: #entity);           addPresentation: presentation;           yourself).  self assert: (browser panes first port: #entity) value isNil.  self assertEmpty: browser panes first presentations.  (browser pane port: #entity) value: #foo.  self assert: (browser panes first port: #entity) value equals: #foo.  self assert: browser panes first presentations size equals: 1.  self assert: browser panes first presentations first rootPrototype equals: presentation-======-markDirtyCustomDependency: aBrick inContext: aContextBrick  aBrick isBrick not | (aBrick = aContextBrick) ifTrue: [ ^self ].  (self hasCustomDependencies: aBrick) ifTrue: [ self markDirty: aBrick.        aBrick subbricks do: [:each |  each isBrick ifTrue: [ self markDirty: each.                    self markDirtyAround: each inContext: aBrick ] ].        (self customDependencies: aBrick) do: [:each |  | brick |              [ brick := (each brickValue: aBrick) brickApi ] on: Exception do: [ brick := nil ].              brick ifNotNil: [ (brick = aContextBrick) not & (brick = aBrick) not & brick isBrick ifTrue: [ (self isClean: brick) ifTrue: [ self markDirty: brick.                                self markDirtyAround: brick inContext: aBrick ] ] ] ] ]-======-onChangeOfPort: aPortName act: aBlock  self portChangeActions add: (GLMPortChangeAction new           portName: aPortName;           action: aBlock)-======-setFocused  focused ifFalse: [ self checkedImage: checkedFocusedIcon.        self check.        focused := true ]-======-value: anObject in: aContext  (self validate: anObject) ifFalse: [ ^self ].  self port value: anObject in: aContext-======-notingPresentationChangeDo: aBlock  aBlock value-======-glamourExpander  ^glamourExpander-======-testIsRendered  self assert: tabs pages first isRendered not.  tabs selectedPageIndex: 1.  self assert: tabs pages first isRendered.  self assert: tabs pages second isRendered not-======-column: aBlockOrSymbol  ^self addColumn: aBlockOrSymbol-======-dragResizingLeft: anEvent  | left right |  right := self brickBounds right.  left := anEvent position x - self owner globalBounds left - startDragX.  left := (left max: 0) min: right - self pagerModel circleButtonSize.  self setPosition: left @ right-======-checkBrick: anObject  checkBrick := anObject.  self box     borderColor: self themer checkboxBorderColor;     borderWidth: self themer checkboxBorderWidth;     vAlign: #center;     checkedImage: self themer checkboxCheckedImage;     width: self themer checkboxWidth;     height: self themer checkboxHeight.  self addBrickFirst: self box-======-newDataSource: anObject  newDataSource := anObject-======-shoutAboutToStyle: aPluggableShoutMorph  self highlightSmalltalk ifFalse: [ ^false ].  self highlightSmalltalkContext ifNotNil: [:classOrMetaClass |  aPluggableShoutMorph classOrMetaClass: classOrMetaClass ].  ^true-======-shouldUseCache  ^self glamourPresentation shouldUseCache-======-step  | newText |  newText := self textLogic value asString.  self text = newText ifTrue: [ ^self ].  self text: newText.  self doLayoutForce-======-updateInsetAndSpacing  self triggerBrick margin: {self inset top .         self inset right .         0 .         self inset left}.  self contentBrick margin: {self spacing .         self inset right .         self inset bottom .         self inset left}-======-computeWidth  ^self pagerModel ifNil: [ 0 ] ifNotNil: [:m |  m circleButtonSize * m actualNumberOfVisiblePages ]-======-invalidateMorphBounds: isForce  | origin corner newBounds |  isLayouting & isForce not ifTrue: [ ^self ].  origin := self paddingLeft @ self paddingTop.  corner := self paddingRight @ self paddingBottom.  newBounds := self globalBounds.  newBounds := newBounds origin + origin corner: newBounds corner - corner.  self morph bounds: newBounds-======-in: aTableBrick  table := aTableBrick.  self initializeColumns-======-popAndReplacePane: aMorph  transform removeMorph: transform lastSubmorph.  transform submorphs isEmpty ifFalse: [ transform removeMorph: transform lastSubmorph ].  paneCount := paneCount - 1.  aMorph     borderWidth: 0;     hResizing: #spaceFill;     vResizing: #spaceFill;     layoutInset: 0.  transform hasSubmorphs ifTrue: [ transform addMorphBack: self separator ].  transform addMorphBack: (aMorph adoptPaneColor: self paneColor).  paneCount := paneCount + 1.  self updatePanes-======-morph: aBlock  morphBuilder := aBlock-======-isHeightCustom  ^self vState isOnMyself-======-addDefaultStatusbarTransmissionFrom: aPane  | defaultTransmission |  defaultTransmission := GLMTransmission new     ensureReplacePresentationsStrategy;     addActiveOrigin: (aPane port: #status);     destination: (self statusbarPane port: #entity);     addPresentation: self statusbarPresentation;     yourself.  self addTransmission: defaultTransmission-======-setProperty: aSymbol toValue: anObject  super setProperty: aSymbol toValue: anObject-======-scrollToPane: pageIndex callback: aBlock  self scrollTo: (self convertIndexToValue: pageIndex) smooth: true callback: aBlock-======-