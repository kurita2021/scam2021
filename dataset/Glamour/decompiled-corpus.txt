shadowGradientReverseFor: arg1  ^GradientFillStyle ramp: {(0.0 -> (arg1 shadowColor alpha: 0)) .         (1.0 -> arg1 shadowColor)}onTabClicked: arg1 with: arg2  self selectedIndex: (self tabs indexOf: arg2)initialize  super initialize.  self enablevirtualFirstVisiblePageIndex: arg1  virtualFirstVisiblePageIndex := self normalizePaneIndex: arg1hasActions  ^self allActions notEmptypressedImage: arg1  pressedImage := arg1textColor: arg1  self setProperty: #brickTextColor toValue: arg1.  self updateFontisSearchable  ^self parameters at: 'isSearchable' ifAbsent: [ false ]rowHeight: arg1  self parameters at: 'rowHeight' put: arg1heightChildrenDependency: arg1  ^arg1 paddingTop + arg1 paddingBottom + (((self nonFloatSubbricks: arg1) detectMax: [:arg2 |  arg2 outerBounds height ]) ifNil: [ 0 ] ifNotNil: [:arg3 |  arg3 outerBounds height ])send: arg1 doubleClickWithShift: arg2 onItem: arg3  | tmp1 |  tmp1 := MouseButtonEvent basicNew setType: #mouseDown position: arg3 bounds origin + (1 @ 1) which: 4 buttons: (arg2 ifTrue: [ 8 ] ifFalse: [ 0 ]) hand: (HandMorph new           mouseFocus: arg3;           yourself) stamp: nil.  arg1 doubleClick: tmp1addPresentation: arg1  | tmp1 |  tmp1 := self presentations.  self presentationsFactory: [:arg2 |  tmp1 do: [:arg3 |  arg2 add: arg3 ].        arg2 add: arg1 copy ]staticHeight  ^100 * self currentWorld displayScaleFactorfastTable  ^self custom: GLMFastTablePresentation newshowTitle  shouldShowTitle := truemargin: arg1  arg1 ifNil: [ ^self margin: #(0) ].  arg1 isCollection ifTrue: [ arg1 isEmpty ifTrue: [ ^self margin: #(0) ].        self           marginTop: (arg1 at: 1);           marginRight: (arg1 at: 1);           marginBottom: (arg1 at: 1);           marginLeft: (arg1 at: 1).        arg1 size > 1 ifTrue: [ self                 marginRight: (arg1 at: 2);                 marginLeft: (arg1 at: 2) ].        arg1 size > 2 ifTrue: [ self marginBottom: (arg1 at: 3) ].        arg1 size > 3 ifTrue: [ self marginLeft: (arg1 at: 4) ] ] ifFalse: [ ^self margin: {arg1} ].  self updateCachestartOn: arg1  self initializeScriptingDefaults.  self entity: arg1testGlamourValue  self assert: ([:arg1 |  arg1 + 2 ] glamourValue: 40) equals: 42.  self assert: ([:arg1 |  arg1 + 2 ] glamourValue: 40 asGlamorousMultiValue) equals: 42.  self assert: ([ 42 ] glamourValue: 40 asGlamorousMultiValue) equals: 42.  self assert: ([:arg1 |  arg1 first + arg1 last ] glamourValue: #(40 2)) equals: 42.  self assert: ([:arg1 :arg2 |  arg1 + arg2 ] glamourValue: (GLMMultiValue withAll: #(40 2))) equals: 42.  self assert: ([:arg1 |  arg1 + 2 ] glamourValue: (GLMMultiValue withAll: #(40 2))) equals: 42.  self assert: ([ 42 ] glamourValue: (GLMMultiValue withAll: #(40 2))) equals: 42createDataSourceFrom: arg1  ^arg1 allowSeparators ifTrue: [ GLMFastListOutlineDataSource new ] ifFalse: [ GLMFastListDataSource new ]bindingOf: arg1  ^self bindingsStrategy cull: self variableBindings cull: arg1 cull: selfrenderToolbarForPresentation: arg1 inMorph: arg2  | tmp1 tmp2 |  tmp1 := arg2 theme newToolDockingBarIn: arg2.  tmp2 := self toolbarButtonsForPresentation: arg1.  tmp1 addAllMorphs: tmp2.  tmp1 addMorphBack: (self dropDownMenuFrom: [ | tmp3 tmp4 |              tmp4 := arg2 buildWindowMenu.              (arg1 allActions select: #isMenu) ifNotEmpty: [ tmp4 addLine ].              tmp3 := self menuIn: tmp4 for: arg1.              tmp3 popUpEvent: self currentEvent in: arg2 world ] withIcon: arg2 theme windowMenuForm).  ^tmp1when: arg1 do: arg2  self announcer when: arg1 do: arg2basicUpdateSizing  sizing := (self paneCount min: self maxPanes) max: 1testRemovingVariableSizePanes  | tmp1 |  tmp1 := GLMFinder new variableSizePanes.  window := tmp1 openOn: 40.  self assert: window submorphs last scrollTarget submorphs size equals: 2.  (tmp1 panes first port: #selection) value: 41.  self assert: window submorphs last scrollTarget submorphs size equals: 4.  (tmp1 panes first port: #selection) value: 42.  self assert: window submorphs last scrollTarget submorphs size equals: 4.  (tmp1 panes second port: #selection) value: 43.  self assert: window submorphs last scrollTarget submorphs size equals: 6.  (tmp1 panes first port: #selection) value: 44.  self assert: window submorphs last scrollTarget submorphs size equals: 4defaultDotsText  ^'...'bottomShadowOf: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := arg1 shadowWidth.  tmp4 := tmp2 @ tmp2 negated / 2.0.  tmp3 := arg1 brickBounds bottomLeft + tmp4 + arg1 shadowOffset.  tmp1 := (self shadowGradientFor: arg1)     origin: tmp3 - tmp4 - (0 @ (tmp2 / 2.0));     direction: 0 @ tmp2;     yourself.  arg2 fillRectangle: (tmp3 extent: (arg1 width - tmp2) @ tmp2) fillStyle: tmp1index: arg1  index := arg1marginLeft  ^self brick marginLeftnewToolbarMorph  ^GLMPanelMorph new     fillStyle: (SolidFillStyle color: Color transparent);     borderStyle: (BorderStyle width: 0);     vResizing: #spaceFill;     hResizing: #shrinkWrap;     cellPositioning: #center;     changeTableLayout;     cellInset: 0;     yourselfremoveBrick: arg1  | tmp1 |  arg1 ifNil: [ ^arg1 ].  tmp1 := self privateRemoveBrick: arg1.  self privatePrepareBrickAfterRemoving: arg1.  self doLayoutForce.  ^tmp1pagerBar: arg1  pagerBar := arg1.  self pagerBar     vShrinkWrap;     hShrinkWrap.  self pagerBar layout hAlign: #center.  self pagerBar pagerModel: pagerModel.  self addBrickBack: self pagerBarportName  ^self port nameinstallKeystrokeActionsOnMorph: arg1 fromPresentation: arg2  arg2 allActionsWithShortcuts do: [:arg3 |  arg3 installKeyCombinationForPresentation: arg2 onMorph: arg1 ]onChildrenDo: arg1  ^self on: #isOnChildren do: arg1 ifAbsent: [ GLMBrickLayoutChildrenState new ]tabs  ^tabs ifNil: [ tabs := OrderedCollection new ]isCancelOnFocusLost  ^cancelOnFocusLost ifNil: [ cancelOnFocusLost := false ]testOneTabWithActions  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list act: #inspect entitled: 'Inspect' ].  window := tmp1 openOn: 42.  self assert: self compositeMorph class equals: GLMPanelMorph.  self assert: self compositeMorph submorphs size equals: 2listBrick: arg1  scrollList := arg1.  self listBrick     vSpaceFill;     hSpaceFill.  self addBrickBack: self listBrickaddMorphFromObject: arg1 toContainer: arg2  | tmp1 |  tmp1 := (self renderObject: arg1)     vResizing: #spaceFill;     hResizing: #rigid;     minimumExtent: 200 @ 10;     extent: 200 @ 10;     yourself.  arg2 addMorphBack: tmp1.  arg2 addMorphBack: (EdgeGripMorph new           width: ProportionalSplitterMorph splitterWidth;           hResizing: #rigid;           target: tmp1)removePane: arg1  arg1 unregisterFromAllAnnouncements.  self panes remove: arg1initialize  super initialize.  fontSize := self themer textFontSize.  familyName := self themer textFamilyName.  text := ''.  textPosition := #leftCenter.  self     hShrinkWrap;     vShrinkWrap.  self updateFontlayout: arg1 in: arg2  self layout: arg1 in: arg2 inject: arg1 paddingLeft @ arg1 paddingTop into: [:arg3 :arg4 |  arg4 outerOrigin: arg3.        arg4 outerBounds width @ 0 ]taskbarTask  ^nilcalculateScrollbarTopOffset  ^(self height / self scrollPane band height * self scrollPane band brickBounds top abs) floorstepCondition  ^stepCondition ifNil: [ [ false ] ]scrollPositionBottom  ^self scrollPositionTop + self innerBounds heightisLayotingAllowed: arg1  self setProperty: #brickLayoutingAllowed toValue: arg1presentations: arg1  self transmissionStrategy presentations: arg1suspendedAnnouncemets  ^suspendedAnnouncemets ifNil: [ suspendedAnnouncemets := OrderedCollection new ]newButton  ^GLMPagerScrollButtonBrick newactOnVariableBindingsAccessRequest: arg1  arg1 action ifNotNil: [:arg2 |  arg2 cull: textModel variableBindings ]testTitle  | tmp1 |  tmp1 := GLMPresentation new.  tmp1 entity: #foo.  self assert: tmp1 titleValue isNil.  tmp1 title: '41'.  self assert: tmp1 titleValue equals: '41'.  tmp1 entity: '4'.  tmp1 title: [:arg1 |  arg1 , '2' ].  self assert: tmp1 titleValue equals: '42'.  tmp1 entity: (GLMMultiValue withAll: #('4' '3')).  tmp1 title: [:arg2 :arg3 |  arg2 , arg3 ].  self assert: tmp1 titleValue equals: '43'isHovered  ^self isSelectedthemer: arg1  themer := arg1testToSendAs  | tmp1 |  tmp1 := GLMPresentation new.  tmp1 selection: #foo.  self assert: tmp1 selection equals: #foo.  self assert: (tmp1 pane port: #newport) value equals: nil.  tmp1 send: [:arg1 |  arg1 + 1 ] as: #newport.  tmp1 selection: 1.  self assert: (tmp1 pane port: #newport) value equals: 2.  self assert: tmp1 selection equals: 1selectionAct: arg1 entitled: arg2 enabledWhen: arg3  self addSelectionAction: (GLMGenericAction new           action: arg1;           title: arg2;           enabledCondition: arg3;           yourself)translateX: arg1  self translateBy: arg1 @ 0shouldValidate: arg1  shouldValidate := arg1actionColumn: arg1  arg1 execute.  self tableRefreshactOnContextChanged: arg1  arg1 property = #selection ifTrue: [ listModel announcer suspendAllWhile: [ dropDownMorph listSelectionIndex: (listModel glamourPresentation displayValue indexOf: arg1 value) ] ]isHeightDirty  ^self brick wrappedBounds isHeightDirtyvAlign: arg1  vAlign := arg1selectionAct: arg1 entitled: arg2 categorized: arg3  self addSelectionAction: (GLMGenericAction new           action: arg1;           title: arg2;           category: arg3;           yourself)explicitSelection: arg1  self glamourPresentation isMultiple ifTrue: [ self explicitlySelectMultipleItems: arg1 ] ifFalse: [ self explicitlySelectItem: arg1 ]textColor  ^Color r: 16 g: 172 b: 221 range: 255testSimplePropagation  < expectedFailure>  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #pane1.  tmp1 transmit     to: #pane1;     andShow: [:arg1 |  arg1 text ].  tmp1 startOn: 42.  self assert: GLMLogger instance announcements copy size equals: 8triggerBrick: arg1  self assert: [ arg1 isNotNil ] description: [ 'Trigger brick must not be nil' ].  triggerBrick ifNotNil: [ self removeBrick: triggerBrick ].  triggerBrick := arg1.  self addBrickBack: self triggerBrickmenu: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Dictionary new.  tmp4 := self allMenuActions.  tmp4 do: [:arg2 |  tmp2 := arg2 category notNil ifTrue: [ tmp1 at: arg2 category ifAbsentPut: [ tmp3 := MenuMorph new.                    arg1 add: arg2 category subMenu: tmp3.                    tmp3 ] ] ifFalse: [ arg1 ].        (arg2 separatorBefore and: [ tmp4 first ~= arg2 ]) ifTrue: [ tmp2 addLine ].        (tmp2 add: arg2 title target: self selector: #executeMenuAction: argument: arg2)           enabled: (arg2 isEnabledOn: self glamourPresentation);           icon: arg2 icon;           keyText: (arg2 hasShortcut ifTrue: [ arg2 shortcutAsString ] ifFalse: [ nil ]).        (arg2 separatorAfter and: [ tmp4 last ~= arg2 ]) ifTrue: [ tmp2 addLine ] ].  ^arg1vShrinkWrap  self height: [ self vPadding + (self icon isNil & self hoverIcon isNil ifTrue: [ 0 ] ifFalse: [ self icon ifNil: [ self hoverIcon height ] ifNotNil: [ self hoverIcon ifNil: [ self icon height ] ifNotNil: [ self icon height max: self hoverIcon height ] ] ]) ]worksWithMorphic  ^truedisplayValue  ^sortBlock ifNil: [ super displayValue ] ifNotNil: [ super displayValue sorted: sortBlock ]renderPresentation: arg1  ^nilnewBrickWithSmallStaticExtent  ^GLMBrick new     height: self staticSmallHeight;     width: self staticSmallWidth;     color: Color random;     yourselfselectedBorderStyleFor: arg1  ^self normalBorderStyleFor: arg1presentation  ^presentationwaitUntilUIRedrawed  self isRunningInUIProcess ifTrue: [ self currentWorld doOneCycle.        ^self ].  self currentWorld defer: [ uiWaitingSemaphore ifNotNil: #signal ].  uiWaitingSemaphore wait: self defaultWaitDurationmodel  ^adaptorhPercent  ^self hState percentaction  ^actionBlockscrollToPane: arg1 smooth: arg2  self scrollToPane: arg1 smooth: arg2 callback: nilcustomFont  font := LogicalFont new     familyName: self familyName;     fallbackFamilyNames: nil;     pointSize: self fontSize;     weightValue: 400;     stretchValue: 5;     slantValue: 0;     yourselfclearUserEdits  self flag: 'Should remove the need for using #defer:. Currently it used as	the rendered suspends all announcements for a presentation when it handles a text changed request.'.  UIManager default defer: [ self announce: (GLMTextEditorRequest new action: [:arg1 |  arg1 model clearUserEdits ]) ]position  ^positiondefaultScrollButtonIconRenderBlock  ^[:arg1 |  {Form new .   Form new} ]tagMorphsFrom: arg1 for: arg2  | tmp1 tmp2 tmp3 |  tmp1 := OrderedCollection new.  tmp2 := self glamourPresentation tagsFor: arg2 fromProvider: arg1 to: #show.  tmp3 := self glamourPresentation tagsFor: arg2 fromProvider: arg1 to: #filter.  tmp2 withIndexDo: [:arg3 :arg4 |  tmp1 addLast: (self buttonForTag: arg3 filter: (tmp3 at: arg4 ifAbsentPut: [ arg3 ])) ].  ^tmp1normalizeHeight: arg1 of: arg2  ^(arg1 max: (arg2 layout minHeight brickValue: arg2)) min: (arg2 layout maxHeight brickValue: arg2)rubricCursorColor: arg1  self setProperty: #brickRubricCursorColor toValue: arg1.  self updateStyletestColumnBlockTakesEntity  | tmp1 tmp2 |  tmp1 := GLMFinder new.  tmp2 := nil.  tmp1 show: [:arg1 |  arg1 table column: 'Even' evaluated: [:arg2 :arg3 |  tmp2 := arg3.              'x' ] ].  window := tmp1 openOn: (1 to: 5).  self waitUntilUIRedrawed.  self assert: tmp2 equals: (1 to: 5)containerTree: arg1  containerTree := arg1context: arg1  context := arg1borderAnimation  ^borderAnimation ifNil: [ borderAnimation := GLMAnimation borderColor duration: 200 ]vShrinkWrap  super vShrinkWrap.  self label vShrinkWrap.  self dotsBrick vShrinkWraptestSelectionValidation  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: [:arg1 |  arg1           row: #one;           row: #two ];     column: #three.  tmp1 transmit     to: #one;     andShow: [:arg2 |  arg2 list display: [:arg3 |  1 to: arg3 ] ].  tmp1 transmit     to: #two;     from: #one;     andShow: [:arg2 |  arg2 list           beMultiple;           display: [:arg3 |  1 to: arg3 ] ].  tmp1 transmit     to: #three;     from: #two;     andShow: [:arg2 |  arg2 text ].  tmp1 startOn: 42.  ((tmp1 paneNamed: #one) port: #selection) value: 40.  self assert: ((tmp1 paneNamed: #two) port: #entity) value equals: 40.  ((tmp1 paneNamed: #two) port: #selection) value: #(10 30 40).  self assert: ((tmp1 paneNamed: #two) port: #selection) value equals: #(10 30 40).  self assert: ((tmp1 paneNamed: #three) port: #entity) value equals: #(10 30 40).  ((tmp1 paneNamed: #two) port: #selection) value: #(10 30).  self assert: ((tmp1 paneNamed: #two) port: #selection) value equals: #(10 30).  self assert: ((tmp1 paneNamed: #three) port: #entity) value equals: #(10 30).  ((tmp1 paneNamed: #one) port: #selection) value: 5.  self assert: ((tmp1 paneNamed: #two) port: #entity) value equals: 5.  ((tmp1 paneNamed: #two) port: #selection) value: #(1 3).  self assert: ((tmp1 paneNamed: #two) port: #selection) value equals: #(1 3).  self assert: ((tmp1 paneNamed: #three) port: #entity) value equals: #(1 3)haloClass  ^#GLMHaloBricktransformation: arg1  transformation := arg1onStepped: arg1  steppedLogic := arg1onChildrenLayouted  ^self brick onChildrenLayouteddefaultValidate: arg1 on: arg2  arg2 name == #selection ifFalse: [ ^true ].  self entity ifNil: [ ^false ].  self allDisplayedDo: [:arg3 |  arg3 = arg1 ifTrue: [ ^true ] ].  ^falseaddNewPane  ^self addNewPaneNamed: 'undefined'boundsInWorld  ^self globalBoundsrender: arg1  container := GLMMorphic containerMorph.  container     changeTableLayout;     listDirection: #leftToRight;     vResizing: #spaceFill;     hResizing: #spaceFill.  container addMorphBack: arg1 displayValue widget widget.  arg1 when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  ^containerthemer  ^themerpane: arg1  pane := arg1oldPresentations: arg1  oldPresentations := arg1isFloating: arg1  arg1 layout floating = #none ifTrue: [ ^false ].  ^self respondsTo: (self floatingMethodFor: arg1 layout floating)title: arg1  title := arg1list  ^self custom: GLMListPresentation newcursorPosition  ^cursorPositiontestToWatcher  browser transmit toWatcher.  self assert: browser transmissions first destination pane equals: browser watcherPaneallowsRecursiveSearch: arg1  allowsRecursiveSearch := arg1textSize  ^textSize ifNil: [ textSize := self sizeOf: self text ]isDotsAdded  ^self hasSubbrick: self dotsBrickmarginBottom  ^self brick marginBottomtestAllActions  | tmp1 |  tmp1 := GLMPresentation new.  self assert: tmp1 hasActions not.  tmp1 addAction: GLMAction new.  tmp1 addAction: GLMAction new.  tmp1 dynamicActions: [:arg1 |  OrderedCollection with: GLMAction new with: GLMAction new with: GLMAction new ].  self assert: tmp1 allActions size equals: 5.  self assert: tmp1 hasActionstearDown  window ifNotNil: [ window delete ].  super tearDowncustomValidation: arg1  customValidation := arg1.  shouldValidate := trueenabledCondition: arg1  enabledCondition := arg1toggleFilteringByTag: arg1  (self shouldFilterByTag: arg1) ifTrue: [ self tagsToFilterBy remove: arg1 ] ifFalse: [ self tagsToFilterBy add: arg1 ].  self resetChildrenContent.  self tableRefreshdisplay: arg1  self transformation: arg1enableElementIndex  self parameters at: 'withRowIndex' put: truefilterOn: arg1  self error: 'This presentation does not allow filtering with a block for now. In the futur we should have a new filter with FastTable to do that. If you want to give it a try look FTFunction and his subclasses.'editRowMorphForColumn: arg1 node: arg2 withIndex: arg3  | tmp1 |  tmp1 := self viewRowMorphForColumn: arg1 node: arg2 withIndex: arg3.  tmp1 hResizing: #spaceFill.  tmp1 on: #mouseDown send: #value: to: [:arg4 |  arg4 shiftPressed ifTrue: [ GLMEditorPopupBrick new                 in: [:arg5 |  arg5 themer: arg5 themer popupEditorBorderThemer themer ];                 closer: (GLMPopupBrickCloser new                       predicate: GLMPopupBrickOutisideClickPredicate new;                       predicate: GLMPopupBrickEscPredicate new;                       yourself);                 textModel: (self valueFor: arg2 withIndex: arg3 in: arg1);                 when: #textAccepted do: [:arg6 |  arg1 modifiedBlock cull: arg6 morph text cull: arg2 cull: self glamourPresentation ];                 openOn: tmp1 ] ifFalse: [ arg4 wasHandled: false ] ].  ^tmp1paneAt: arg1  ^self panes at: arg1predicates  ^predicatestransformation  ^transformationnext  < return: #GLMVector>  ^nextactOnUpdatedPresentation: arg1  treeMorph model updateRoots.  self flag: 'Calling update list explicitly here is a hack. This should be solvable by the model through a notification mechanism'.  treeMorph updateListrender: arg1  listModel := GLMDropListModel new glamourPresentation: arg1.  listModel announcer when: GLMDropDownListMorphSelectionChanged do: [:arg2 |  arg1 selectedIndex: arg2 selectionIndex.        arg1 selection: arg2 selectionValue ].  listModel selectionIndex: arg1 selectedIndex.  dropDownMorph := (MorphDropListMorph on: listModel list: #list selected: #selectionIndex changeSelected: #selectionIndex: useIndex: true)     hResizing: #spaceFill;     vResizing: #shrinkWrap.  arg1 when: GLMContextChanged send: #actOnContextChanged: to: self.  arg1 when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  ^dropDownMorphcomputeTagsFor: arg1  ^self computeTagsFor: arg1 from: self tagsBlockvisibleIndex  ^visibleIndex ifNil: [ visibleIndex := 1 ]extent: arg1  | tmp1 tmp2 tmp3 |  super extent: arg1.  tmp3 := (self height - self textArea height) / 2.0.  tmp2 := tmp3 fractionPart rounded - tmp3 sign.  tmp1 := (tmp3 + tmp2) truncated abs.  self textArea top: tmp1intercellSpacing  ^self parameters at: 'intercellSpacing' ifAbsent: [ self class defaultIntercellSpacing ]markDirty: arg1  self markLayoutDirty: arg1 owner.  arg1 markHeightDirtystyle: arg1  self styler ifNotNil: [:arg2 |  arg2 styleInBackgroundProcess: arg1 ]updateButtons  self buttons select: #isFocused thenDo: #uncheck.  self pagerModel size > 0 ifTrue: [ self buttons from: self pagerModel firstVisiblePageIndex to: self pagerModel lastVisiblePageIndex do: #check ]open  self presentation openOn: self loremIpsumselectionIndex: arg1  selectionIndex := arg1.  self announcer announce: (GLMDropDownListMorphSelectionChanged new           selectionValue: self selectedItem;           selectionIndex: selectionIndex;           yourself)searchStrategy  ^searchBlockupdateFont  font := LogicalFont familyName: self familyName pointSize: self fontSizeinitialize  super initialize.  parameters := Dictionary newanimate: arg1  self asyncTask terminate.  animatedObject := arg1.  self reset.  stamp := Time millisecondClockValue.  self asyncTask     doInBackground: [ [ self shouldStop ] whileFalse: [ self needsStep ifTrue: [ self animationStep ] ] ];     onCompleted: [ isCompleted := true.        [ callback brickValue: self animatedObject ] ensure: [ ensureLogic brickValue: self animatedObject ] ];     priority: Processor userSchedulingPriority;     executetestDefaultStrategy  self assert: GLMTransmission new transmissionStrategy class equals: GLMNoStrategymarginRight  ^self brick marginRightshouldStop  ^shouldStop ifNil: [ shouldStop := false ]smooth: arg1  smooth := arg1isCancelOnEscape  ^cancelOnEscape ifNil: [ cancelOnEscape := false ]closePopup  self stopSteppingSelector: #openHintPopup:.  hintBrick ifNotNil: [ hintBrick close.        hintBrick := nil ]contentsMorph  ^contentsMorphnumberOfVisiblePages  ^numberOfVisiblePagespopPane: arg1  self invariant.  pagesCount >= 1 ifTrue: [ | tmp1 tmp2 |        tmp2 := arg1.        focusedViews removeKey: pagesCount ifAbsent: [ true ].        pagesCount := pagesCount - 1.        firstVisiblePageIndex = 1 ifTrue: [ tmp2 := false ].        lastVisiblePageIndex > pagesCount ifTrue: [ firstVisiblePageIndex := firstVisiblePageIndex - 1.              lastVisiblePageIndex := lastVisiblePageIndex - 1 ].        firstVisiblePageIndex := firstVisiblePageIndex max: 1.        pagesCount = 0 ifTrue: [ selectedPageIndex := 0.              firstVisiblePageIndex := 0 ].        self selectedPageIndex > pagesCount ifTrue: [ self selectedPageIndex: pagesCount ].        tmp1 := pagesCount = firstVisiblePageIndex & (pagesCount > self numberOfVisiblePages).        self notifyPagePoped: tmp2 ].  self invariantto: arg1  ^self destination: (self browser resolveDestinationPort: arg1)color: arg1  arg1 ifNil: [ ^self color: #(0) ].  arg1 isCollection ifTrue: [ arg1 isEmpty ifTrue: [ ^self color: #(0) ].        self           colorTop: (arg1 at: 1);           colorRight: (arg1 at: 1);           colorBottom: (arg1 at: 1);           colorLeft: (arg1 at: 1).        arg1 size > 1 ifTrue: [ self                 colorRight: (arg1 at: 2);                 colorLeft: (arg1 at: 2) ].        arg1 size > 2 ifTrue: [ self colorBottom: (arg1 at: 3) ].        arg1 size > 3 ifTrue: [ self colorLeft: (arg1 at: 4) ] ] ifFalse: [ ^self color: {arg1} ]testStartTransmissionFromInitializationBlock  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list initialize: [:arg2 |  arg2 selection: 4 ] ].  tmp1 transmit     from: #one port: #selection;     to: #two port: #entity;     andShow: [:arg1 |  arg1 text ].  self assertEmpty: (tmp1 paneNamed: #one) presentations.  self assertEmpty: (tmp1 paneNamed: #two) presentations.  tmp1 startOn: 42.  self assert: (tmp1 paneNamed: #one) presentations size equals: 1.  self assert: (tmp1 paneNamed: #one) presentations first selection equals: 4.  self assert: (tmp1 paneNamed: #two) presentations size equals: 1calculateItems  ^self basicItems collect: [:arg1 |  arg1 select: [:arg2 |  self elementShouldBeDisplayed: arg2 ] ]themer  ^self privateThemer ifNotNil: [ self privateThemer ] ifNil: [ self owner isNotNil ifTrue: [ self owner isBrick ifTrue: [ self owner themer ] ifFalse: [ super brickThemer ] ] ifFalse: [ self theme brickThemer ] ]calculateElements  ^self tagsToFilterBy ifEmpty: [ self basicElements ] ifNotEmpty: [ self basicElements select: [:arg1 |  self elementShouldBeDisplayed: arg1 ] ]condition: arg1  condition := arg1newLabel  ^GLMLabelBrick new margin: #(3 0)smooth  ^smoothtestUpdateFromModel  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  arg2 - 3 to: arg2 ] ].  tmp1 transmit     to: #two;     from: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  arg2 * 10 to: arg2 * 10 + 2 ] ].  window := tmp1 openOn: 4.  tmp2 := self find: MorphTreeMorph in: window.  self assert: (tmp2 model roots collect: #item) equals: #(1 2 3 4) asOrderedCollection.  ((tmp1 paneNamed: #one) port: #selection) value: 2.  tmp3 := self findLast: MorphTreeMorph in: window.  self assert: (tmp3 model roots collect: #item) equals: #(20 21 22) asOrderedCollection.  tmp1 entity: 8.  tmp4 := self find: MorphTreeMorph in: window.  self assert: (tmp4 model roots collect: #item) equals: #(5 6 7 8) asOrderedCollection.  self assert: tmp2 ~= tmp4.  self assertEmpty: window submorphs last submorphs last submorphs first submorphs.  ((tmp1 paneNamed: #one) port: #selection) value: 5.  tmp5 := self findLast: MorphTreeMorph in: window.  self assert: (tmp5 model roots collect: #item) equals: #(50 51 52) asOrderedCollection.  self assert: tmp3 ~= tmp5flash  self announce: (GLMTextEditorRequest new action: [:arg1 |  arg1 flash ])buttonCenterByIndex: arg1  | tmp1 |  tmp1 := self pagerModel circleButtonSize.  ^(arg1 - 1) * tmp1 + (tmp1 / 2)popupSuccessThemer  ^self registerModule: GLMBrickPopupSuccessThemer new to: self named: #popupThemergetText  ^self glamourPresentation formatedDisplayValuehShrinkWrap  hResizing := #shrinkWrap.  self width: [ self morph width ]containerTree: arg1  containerTree := arg1setLabelOf: arg1 for: arg2  arg1 setLabel: (self titleFor: arg2)marginBottom  ^self wrappedBounds marginBottompane: arg1  pane := arg1defaultBorderStyle  ^FillStyleBorder color: (Color white darker alpha: 0.5) width: 10testCopyNotTheSameRegistry  | tmp1 tmp2 |  tmp1 := GLMPresentation new.  tmp2 := tmp1 copy.  self assert: tmp1 glmSubscriptions ~~ tmp2 glmSubscriptionsdarken  ^Color brickColorRegistry at: #brickDarken ifAbsentPut: [ Color r: 29 g: 29 b: 29 range: 255 ]testListDoubleClickWithMultipleSelection  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 tree beMultiple ].  window := tmp1 openOn: ($a to: $d).  tmp2 := window submorphs last submorphs first submorphs first submorphs first submorphs first.  tmp3 := tmp2 scroller submorphs first.  tmp4 := tmp2 scroller submorphs last.  self send: tmp2 mouseUpWithShift: false onItem: tmp3.  self send: tmp2 mouseUpWithShift: true onItem: tmp4.  self send: tmp2 doubleClickWithShift: false onItem: tmp3.  self assert: (tmp1 panes first port: #strongSelection) value asSet equals: ($a to: $d) asSettestSimpleTransmission  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 sendTo: #two -> #port2 from: #one -> #port1.  self assert: tmp1 transmissions size equals: 1.  self assert: (tmp1 transmissions first transmissionStrategy isKindOf: GLMNoStrategy).  self assert: tmp1 transmissions first origins first equals: ((tmp1 paneNamed: #one) port: #port1).  self assert: tmp1 transmissions first destination equals: ((tmp1 paneNamed: #two) port: #port2)isLastAdded  ^(self getIndex: self band lastSubbrick) = self model countisHeightClean  ^self heightState = #cleanentity: arg1  entity := arg1.  self setTitle: (self titleLogic phlowValue: self entity)announcer  ^announcer ifNil: [ announcer := GLMAnnouncer new ]isSyncronous  ^isSyncronouscopyAccordingToPaneMapping: arg1 inNewBrowser: arg2  ^self subclassResponsibilityborderWidth: arg1  < brickBuilderProperty: #'Look&Feel' name: 'Border width' as: #brickBuilderEvaluate getter: #borderWidth model: #GLMUIBuilderTextFieldProperty>  self border width: arg1bindingThemer  ^self registerModule: GTPlayBindingDarkThemer newpopulate: arg1 icon: arg2 entitled: arg3 with: arg4  self addAction: (GLMGenericAction new           action: (GLMPortUpdater new                 portSymbol: arg1;                 valueBlock: arg4;                 yourself);           icon: arg2;           title: arg3;           yourself)markLayoutDirty  self layout markDirtywithSmalltalkSearch  self     searchOn: [:arg1 :arg2 |  Smalltalk compiler           receiver: arg2;           evaluate: ' | entity each | each := self. entity := each.' , arg1 ];     helpMessage: 'Quick selection field. Given your INPUT, it executes: self select: [:each | INPUT ]'styler  ^styler ifNil: [ styler := self defaultStyler ]testMultipleInitialSelection  | tmp1 tmp2 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 tree           beMultiple;           display: [:arg2 |  1 to: arg2 * 3 ] ].  window := tmp1 openOn: 5.  (tmp1 panes first port: #selection) value: #(2 5 3).  tmp2 := self find: MorphTreeMorph in: window.  self assert: tmp2 model selection notNil.  self assert: tmp2 model selection selectedItemOrItemsOrNil size equals: 3isSelected  ^isSelectedupdateToolbar  super updateToolbar.  cachedPresentation ifNotNil: [ cachedPresentation updateToolbar.        cachedPresentation presentations do: #updateToolbar ]testValidSubscriptionsInComplexBrowser  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 tmp10 |  tmp2 := GLMTabulator new.  tmp2     row: #content;     row: #details.  tmp2 transmit     to: #content;     andShow: [:arg1 |  arg1 list display: #allSuperclasses ].  tmp2 transmit     from: #content;     to: #details;     andShow: [:arg1 |  arg1 text ].  tmp2 transmit     from: #content;     toOutsidePort: #selection.  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 custom: tmp2 ].  self assertEmpty: tmp1 panes.  (tmp1 pane port: #entity) value: String.  self assert: tmp1 panes size equals: 1.  tmp5 := tmp1 panes first.  tmp3 := tmp5 presentations first.  tmp7 := tmp3 panes first.  self assert: tmp7 presentations first displayValue size equals: 5.  (tmp7 port: #selection) value: Collection.  self assert: tmp1 panes size equals: 2.  tmp6 := tmp1 panes second.  tmp4 := tmp6 presentations first.  tmp8 := tmp4 panes first.  self assert: tmp7 presentations first displayValue size equals: 5.  self assert: tmp8 presentations first displayValue size equals: 2.  tmp9 := tmp3 panes second.  self assert: tmp9 presentations first displayValue equals: Collection.  (tmp8 port: #selection) value: Object.  self assert: tmp9 presentations first displayValue equals: Collection.  tmp10 := tmp4 panes second.  self assert: tmp10 presentations first displayValue equals: Object.  self assert: tmp7 presentations first displayValue size equals: 5.  self assert: tmp8 presentations first displayValue size equals: 2testPorts  | tmp1 |  tmp1 := GLMTransmission new.  tmp1 addActiveOrigin: (GLMSimplePort new           name: #port1;           value: 1).  tmp1 addPassiveOrigin: (GLMSimplePort new           name: #port2;           value: 2).  tmp1 addActiveOrigin: (GLMSimplePort new           name: #port3;           value: 3).  tmp1 addPassiveOrigin: (GLMSimplePort new           name: #port4;           value: 4).  tmp1 destination: (GLMSimplePort new name: #port5).  self assert: tmp1 originReferences size equals: 4.  tmp1 originReferences do: [:arg1 |  self assert: (arg1 isKindOf: GLMOriginPortReference) ].  self assert: (tmp1 originReferences at: 1) port name equals: #port1.  self assert: (tmp1 originReferences at: 2) port name equals: #port2.  self assert: (tmp1 originReferences at: 3) port name equals: #port3.  self assert: (tmp1 originReferences at: 4) port name equals: #port4.  self assert: tmp1 origins size equals: 4.  tmp1 origins do: [:arg1 |  self assert: (arg1 isKindOf: GLMSimplePort) ].  self assert: (tmp1 origins at: 1) name equals: #port1.  self assert: (tmp1 origins at: 2) name equals: #port2.  self assert: (tmp1 origins at: 3) name equals: #port3.  self assert: (tmp1 origins at: 4) name equals: #port4.  self assert: tmp1 activeOrigins size equals: 2.  tmp1 activeOrigins do: [:arg1 |  self assert: (arg1 isKindOf: GLMSimplePort) ].  self assert: (tmp1 activeOrigins at: 1) name equals: #port1.  self assert: (tmp1 activeOrigins at: 2) name equals: #port3.  self assert: tmp1 passiveOrigins size equals: 2.  tmp1 passiveOrigins do: [:arg1 |  self assert: (arg1 isKindOf: GLMSimplePort) ].  self assert: (tmp1 passiveOrigins at: 1) name equals: #port2.  self assert: (tmp1 passiveOrigins at: 2) name equals: #port4.  self assert: (tmp1 destination isKindOf: GLMSimplePort).  self assert: tmp1 destination name equals: #port5action: arg1  clickAction := arg1layoutFloatingRight: arg1 in: arg2  | tmp1 tmp2 |  tmp1 := arg1 owner width - arg1 width - arg1 marginRight - arg1 owner paddingRight.  tmp2 := arg1 marginTop + arg1 owner paddingTop.  arg1 brickBounds: (tmp1 @ tmp2 extent: arg1 extent).  ^0icon  ^self normalImagetransmitIn: arg1  initialExtent: arg1  initialExtent := arg1testInterdependentPanesShouldUpdateTheFocusTriggerPane  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp3 := GLMTabulator new.  tmp3     column: #one;     column: #two;     column: #three.  tmp3 transmit     to: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 ] ].  tmp3 transmit     to: #two;     from: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 * 2 ] ].  tmp3 transmit     to: #three;     from: #two;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 * 3 ] ].  tmp3 transmit     toOutsidePort: #focus;     from: #three port: #focus.  tmp3 transmit     to: #one port: #selection;     fromOutsidePort: #focus;     transformed: [:arg2 |  arg2 + 1 ].  tmp3 transmit     to: #two port: #selection;     fromOutsidePort: #focus;     transformed: [:arg2 |  arg2 + 2 ].  window := tmp3 openOn: 5.  ((tmp3 paneNamed: #one) port: #selection) value: 3.  ((tmp3 paneNamed: #two) port: #selection) value: 6.  tmp1 := self findWherePresentationIs: (tmp3 paneNamed: #three) presentations first in: window.  ((tmp3 paneNamed: #three) port: #selection) value: 2.  ((tmp3 paneNamed: #three) port: #focus) value: 1.  self assert: ((tmp3 paneNamed: #one) port: #entity) value equals: 5.  self assert: ((tmp3 paneNamed: #one) port: #selection) value equals: 2.  self assert: ((tmp3 paneNamed: #two) port: #entity) value equals: 2.  self assert: ((tmp3 paneNamed: #two) port: #selection) value equals: 3.  self assert: ((tmp3 paneNamed: #three) port: #entity) value equals: 3.  self assert: ((tmp3 paneNamed: #three) port: #selection) value isNil.  tmp2 := self findWherePresentationIs: (tmp3 paneNamed: #three) presentations first in: window.  self assert: tmp1 ~= tmp2.  self assert: tmp2 selectedMorph isNil.  tmp5 := self findWherePresentationIs: (tmp3 paneNamed: #one) presentations first in: window.  self assert: tmp5 selectedMorph notNil.  tmp4 := self findWherePresentationIs: (tmp3 paneNamed: #two) presentations first in: window.  self assert: tmp4 selectedMorph notNillabel  ^self isSelected ifTrue: [ self selectedLabel userString ifNil: [ self firstSubmorph ] ] ifFalse: [ self normalLabel userString ifNil: [ self firstSubmorph ] ]columns  ^columns ifNil: [ columns := OrderedCollection new ]testPresentations  | tmp1 tmp2 tmp3 |  tmp1 := GLMPane named: 'test'.  tmp2 := GLMPresentation new.  self assertEmpty: tmp1 presentations.  tmp3 := nil.  tmp1 when: GLMPresentationsChanged do: [:arg1 |  tmp3 := arg1 ].  tmp1 addPresentation: tmp2.  self assert: tmp1 presentations size equals: 1.  self assert: tmp1 presentations first identicalTo: tmp2.  self assert: tmp2 pane identicalTo: tmp1.  self assert: tmp3 notNilinnerPortEvent: arg1  arg1 portName = #entity ifFalse: [ (self pane port: arg1 portName) value: arg1 value ]hPercent: arg1  hState := self hState onParentDo: [:arg2 |  arg2 percent: arg1 ]renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderDiffPresentation: selftestCustomInstance  | tmp1 |  self assert: GLMLogger instance identicalTo: GLMLogger nullInstance.  tmp1 := GLMMemoryLogger new.  GLMLogger instance: tmp1.  self assert: GLMLogger instance identicalTo: tmp1.  GLMLogger reset.  self assert: GLMLogger instance identicalTo: GLMLogger nullInstanceaddColumn: arg1 span: arg2  ^(self addColumn: arg1) span: arg2testForbiddenAnnouncements  | tmp1 tmp2 |  tmp1 := GLMTransmissionContext new.  tmp2 := GLMPane new.  self assert: (tmp1 canAnnounceMatchingPresentationsChanged: tmp2).  tmp1 forbidToAnnounceMatchingPresentationsChanged: tmp2.  self assert: (tmp1 canAnnounceMatchingPresentationsChanged: tmp2) notinitialize  super initialize.  self     removeMorph: self contentMorph;     removeMorph: self tabSelectorMorph;     toolbarMorph: self newToolbarMorph;     headerMorph: self newHeaderMorph;     addMorph: self headerMorph;     addMorph: self contentMorphdebugSelection  textMorph debugItactOnMatchingPresentationChanged: arg1  container removeAllMorphs.  self renderContainerFor: arg1 pane.  self renderer window ifNotNil: [ self flag: 'this check is fishy'.        self renderer window fullBounds ]synchronizeScrollTo: arg1  self notifySynchronizeScrollTo: arg1resetLayout  self vResizing: #rigid.  self hResizing: #rigid.  self height: nil.  self width: nilnewText  ^GLMRubTextAreaBrick new     width: 200;     margin: #(3 0);     vShrinkWrap;     rubricTextFamilyName: StandardFonts defaultFont familyNamedelay  ^delay ifNil: [ delay := 0 ]asBrick  ^selfact: arg1 icon: arg2 entitled: arg3  self addAction: (GLMGenericAction new           action: arg1;           icon: arg2;           title: arg3;           yourself)addBrickBack: arg1  | tmp1 |  tmp1 := self privateAddBrickBack: arg1 asBrick.  self privatePrepareBrickAfterAdding: tmp1.  self doLayoutForce.  ^arg1highlightSmalltalk  ^highlightSmalltalkinitializeAnnouncementForPresentation: arg1  arg1 when: GLMDataSourceUpdated send: #dataSourceUpdated: to: self.  arg1 when: GLMContextChanged send: #actOnContextChanged: to: self.  arg1 when: GLMPresentationUpdated send: #actOnUpdatedPresentation: to: self.  arg1 when: GLMPresentationRefreshRequest send: #actOnPresentationRefreshRequest: to: selftransmitIn: arg1  self subclassResponsibilitydefaultValidate: arg1 on: arg2  arg2 name == #selection ifFalse: [ ^true ].  self entity ifNil: [ ^false ].  ^self isMultiple ifTrue: [ arg1 isCollection and: [ arg1 allSatisfy: [:arg3 |  self displayValue includes: arg3 ] ] ] ifFalse: [ self displayValue includes: arg1 ]peterRiver  ^Color brickColorRegistry at: #brickPeterRiver ifAbsentPut: [ Color r: 52 g: 152 b: 219 range: 255 ]beNormal  self isReadMode ifTrue: [ ^self ].  self animateToNormal.  self removeBrick: self editBrick.  self activeHand releaseKeyboardFocus.  self addBrickBack: self labelBrick.  self announce: #onReadModehighlightSmalltalkContext  ^highlightSmalltalkContext ifNil: [ nil ] ifNotNil: [ highlightSmalltalkContext glamourValue: self entity ]watcherPane  ^nilscrollUp: arg1  self scrollBy: (self isFirstAdded ifTrue: [ arg1 min: self topOffset - self bandTopOffset ] ifFalse: [ arg1 ])spacing  ^6actOnEvaluateSelection: arg1  UIManager default defer: [ textMorph evaluateSelectionAndDo: arg1 action ]show: arg1  self transmission transmissionStrategy presentationsFactory: arg1scrollbarWidth  ^self valueOfProperty: #brickScrollbarWidth ifAbsent: [ self themer scrollbarWidth ]menu: arg1 shifted: arg2  self selectedNode ifNotNil: [:arg3 |  arg3 menu: arg1 shifted: arg2 ].  ^arg1roots: arg1  roots := arg1 isCollection ifTrue: [ arg1 collect: [:arg2 |  self nodeModelFor: arg2 ] ] ifFalse: [ OrderedCollection with: (self nodeModelFor: arg1) ]tagsBlock  ^tagsBlocktestNestedSuspendParticularAnnouncementWhile  | tmp1 tmp2 tmp3 |  announcer when: GLMTestAnnouncement , GLMTestAnnouncement2 do: [:arg1 |  tmp1 := arg1 ].  tmp3 := nil.  announcer suspendAll: {GLMTestAnnouncement} while: [ announcer suspendAll: {GLMTestAnnouncement2} while: [ tmp2 := announcer announce: GLMTestAnnouncement.              tmp3 := tmp1.              tmp1 := nil ].        announcer announce: GLMTestAnnouncement ].  self assert: tmp1 isNil.  self assert: tmp3 equals: tmp2sizing  ^sizing ifNil: [ self updateSizing ]beForScripting  isForScripting := truedefaultValidate: arg1 on: arg2  arg2 name == #selection ifFalse: [ ^true ].  self entity ifNil: [ ^false ].  ^self displayValue includes: arg1fromOutsideEntityPortTransformed: arg1  ^self fromOutsidePort: #entity transformed: arg1openOn: arg1 with: arg2  self startOn: arg1.  ^self openWith: arg2computeTagsFor: arg1 from: arg2  | tmp1 |  arg2 ifNil: [ ^OrderedCollection new ].  tmp1 := arg2 glamourValue: arg1.  ^tmp1 isString ifTrue: [ OrderedCollection with: tmp1 ] ifFalse: [ tmp1 asOrderedCollection ]data  ^datavalueFor: arg1  ^self containerTree glamourPresentation column: arg1 valueFor: self itemactionBlock  ^self parameters at: 'actionBlock'allowsFilter  ^filterBlock notNilpresentation: arg1  presentation := arg1privacyMessage  ^self sendUsageData ifTrue: [ 'You are sending diagnostic and usage data to help us improve Pharo. Thanks!' ] ifFalse: [ 'No diagnostic and usage data is being sent. Would you like to send diagnostic and usage data to help us improve Pharo?' ]onLayoutEvent: arg1  ^self brick onLayoutEvent: arg1testUpdatingTextPortUpdatesTheMorph  < expectedFailure>  | tmp1 tmp2 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text ].  window := tmp1 openOn: 'fourtytwo'.  tmp1 first text: '42'.  self assert: (tmp1 pane port: #text) value asString equals: '42'.  tmp2 := self find: RubScrolledTextMorph in: window.  self assert: tmp2 text asString equals: '42'column: arg1 evaluated: arg2 sortedBy: arg3  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           sortBlock: arg3)childrenValueOf: arg1  ^self children glamourValue: arg1 asGlamorousMultiValue , self entity asGlamorousMultiValuetestAllowNil  | tmp1 tmp2 tmp3 |  tmp1 := GLMTabulator new.  tmp1     column: [:arg1 |  arg1           row: #one;           row: #two ];     column: #details.  tmp1 transmit     to: #one;     andShow: [:arg2 |  arg2 tree display: #(1 2 3) ].  tmp1 transmit     to: #two;     andShow: [:arg2 |  arg2 tree display: #(#a #b #c) ].  tmp1 transmit     to: #details;     from: #one;     from: #two;     andShow: [:arg2 |  arg2 text           display: [:arg3 :arg4 |  arg3 asString , arg4 asString ];           allowNil ].  tmp1 startOn: 42.  (tmp1 paneNamed: #details) when: GLMPresentationsChanged do: [:arg2 |  tmp2 := true ].  (tmp1 paneNamed: #details) when: GLMMatchingPresentationsChanged do: [:arg2 |  tmp3 := true ].  tmp2 := false.  tmp3 := false.  ((tmp1 paneNamed: #one) port: #selection) value: 2.  self assert: tmp2.  self assert: tmp3.  self assert: (tmp1 paneNamed: #details) presentations first displayValue equals: '2nil'.  tmp2 := false.  ((tmp1 paneNamed: #two) port: #selection) value: #c.  self assert: tmp2.  self assert: tmp3.  self assert: (tmp1 paneNamed: #details) presentations first displayValue equals: '2c'.  tmp2 := false.  ((tmp1 paneNamed: #one) port: #selection) value: nil.  self assert: tmp2.  self assert: tmp3.  self assert: (tmp1 paneNamed: #details) presentations first displayValue equals: 'nilc'testTransmitting  | tmp1 |  tmp1 := GLMTransmission new.  tmp1 addActiveOrigin: (GLMSimplePort new           name: #port1;           value: 1).  tmp1 destination: (GLMSimplePort new name: #port5).  self assert: tmp1 value equals: 1.  self assert: tmp1 destination value isNil.  tmp1 transmit.  self assert: tmp1 destination value equals: 1.  tmp1 addPassiveOrigin: (GLMSimplePort new           name: #port2;           value: 2).  tmp1 addActiveOrigin: (GLMSimplePort new           name: #port3;           value: 3).  tmp1 addPassiveOrigin: (GLMSimplePort new           name: #port4;           value: 4).  self assert: tmp1 value equals: (GLMMultiValue withAll: #(1 2 3 4)).  tmp1 transmit.  self assert: tmp1 destination value equals: (GLMMultiValue withAll: #(1 2 3 4))oldValue  ^oldValueopenInWorld  super openInWorld.  isOpen := trueprofileSelection  self announce: GLMProfileSelectionscrollToPane: arg1 smooth: arg2 callback: arg3  self scrollTo: (pagerModel convertIndexToValue: arg1) smooth: arg2 callback: arg3selectedBackgroundStyleFor: arg1  ^self theme tabLabelSelectedFillStyleFor: arg1tabSelector  ^tabSelectoronPositionChanged: arg1  self scrollToPane: pagerModel firstVisiblePageIndex smooth: arg1 smoothtearDown  window ifNotNil: [ window delete ].  super tearDownamountToFilterBy: arg1  amountToFilterBy := arg1customWidth  ^self layout width brickValue: selfacceptContents: arg1  self announce: #textAccepted event: arg1.  self closechildrenBlock  ^childrenBlock ifNil: [ childrenBlock := self glamourPresentation children isNil ifFalse: [ self glamourPresentation children ] ifTrue: [ OrderedCollection new ] ]testAddSetsCorrectPane  | tmp1 tmp2 |  tmp1 := GLMCompositePresentation new.  tmp2 := GLMPresentation new.  tmp1 add: tmp2.  self assert: tmp1 pane equals: tmp2 panescrollBarIsVisible  ^submorphs includes: scrollBarouterHeight: arg1  ^self brick wrappedBounds outerHeight: arg1glamourColumn: arg1  glamourColumn := arg1action: arg1  action := arg1list  ^list ifNil: [ list := self glamourPresentation displayValue collect: [:arg1 |  (self glamourPresentation formatedDisplayValueOf: arg1) asMorph ] ]addColumn: arg1  | tmp1 |  tmp1 := (arg1 computation phlowValue: self entity) asBrick.  tmp1 := arg1 style phlowValue: tmp1.  ^self addBrickBack: tmp1marginTop: arg1  self translateY: arg1 - self marginTop.  self margin at: Top put: arg1.  self updateCachetitleOrIconOrNilOf: arg1 in: arg2  ^arg1 hasTitleIcon ifTrue: [ | tmp1 |        tmp1 := self theme newImageIn: arg2 form: arg1 titleIconValue.        arg1 titleValue ifNotNil: [ tmp1 setBalloonText: arg1 titleValue maxLineLength: 10 ] ] ifFalse: [ arg1 hasTitle ifTrue: [ arg1 titleValue ] ifFalse: [ nil ] ]testTreeWithTags  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp2 := Dictionary new.  tmp2 at: #even put: #(2 6 8).  tmp2 at: #odd put: #(3 7 9).  tmp2 at: #some put: #(1 2 3 4).  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 tree           display: [ tmp2 keys ];           sortBlock: [:arg2 :arg3 |  arg2 <= arg3 ];           children: [:arg4 |  arg4 isNumber ifFalse: [ tmp2 at: arg4 ] ];           tags: [:arg5 |  arg5 isNumber ifTrue: [ arg5 even ifTrue: [ #('even') ] ifFalse: [ #('odd') ] ] ifFalse: [ #() ] ] ].  window := tmp1 openOn: tmp2.  self waitUntilUIRedrawed.  tmp3 := self treeVisibleItems second.  tmp3 toggleExpandedState.  self waitUntilUIRedrawed.  tmp4 := self treeVisibleItems third.  (self find: SimpleButtonMorph in: tmp4) doButtonAction.  self waitUntilUIRedrawed.  tmp5 := self treeVisibleItems fifth.  tmp5 toggleExpandedState.  self waitUntilUIRedrawed.  tmp6 := self find: TextMorph in: self treeVisibleItems seventh.  self assert: tmp6 text asString equals: '3'height: arg1  vState := self vState onMyselfDo: [:arg2 |  arg2 dimension: arg1 ]borderWidth  ^self border widthenabled  ^truefontSize  ^self label fontSizetransformedEntity  ^transformedEntityupdateFoundationBounds  self owner ifNotNil: [:arg1 |  arg1 isFoundationBrick ifTrue: [ self doNotLayoutDuring: [ arg1 isVShrinking | arg1 isHShrinking ifTrue: [ arg1 privateExtent: self outerBounds extent ] ] ] ]send: arg1 mouseUpWithShift: arg2 onItem: arg3  | tmp1 |  tmp1 := MouseButtonEvent basicNew setType: #mouseUp position: arg3 bounds origin + (1 @ 1) which: 4 buttons: (arg2 ifTrue: [ 8 ] ifFalse: [ 0 ]) hand: (HandMorph new           mouseFocus: arg3;           yourself) stamp: nil.  arg1 listManager mouseUp: tmp1 on: arg3testRemovePage  tabs removePage: tabs pages first.  self assert: tabs pages size equals: 1normalBackgroundStyleFor: arg1  ^self theme tabLabelNormalFillStyleFor: arg1gtInspectorPortsIn: arg1  < gtInspectorPresentationOrder: 30>  ^arg1 table     title: 'Ports';     display: [ self ports ];     column: 'Port' evaluated: [:arg2 |  arg2 name ];     column: 'Value' evaluated: [:arg2 |  arg2 value asString ]cachedMatchingPresentations  ^cachedMatchingPresentations ifNil: [ cachedMatchingPresentations := self matchingPresentations ]render: arg1 on: arg2  self     renderShadowOf: arg1 on: arg2;     renderBackgroundColorOf: arg1 on: arg2;     renderBorderOf: arg1 on: arg2testWithPresentation  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMTabulator new     column: #stacker;     yourself.  tmp1 transmit     to: #stacker;     andShow: [:arg1 |  arg1 dynamic presentation: [:arg2 :arg3 |  arg2 text display: [ 'All ' , arg3 asString ] ] ].  window := tmp1 openOn: 10.  tmp2 := tmp1 panes first presentations first.  tmp3 := tmp2 cachedPresentation first.  tmp4 := self findWherePresentationIs: tmp3 in: window.  self assert: tmp4 text asString equals: 'All 10'= arg1  ^self species = arg1 species and: [ self item = arg1 item ]contextClass  ^contextClasscheckedIcon: arg1  checkedIcon := arg1resetChildrenContents  self roots do: [:arg1 |  arg1 resetContentsRecursively ]buttonBackgroundColor  ^Color veryVeryLightGray lighternoTestAcceptKeyCanBeOverriden  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := false.  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text act: [:arg2 |  tmp3 := true ] on: $s entitled: 'Override' ].  window := tmp1 openOn: '4'.  tmp2 := self find: RubScrolledTextMorph in: window.  self simulateOnlyOneClickOn: tmp2.  (Delay forMilliseconds: HandMorph doubleClickTime + 1) wait.  self assert: ActiveHand keyboardFocus equals: tmp2 textArea.  tmp4 := $s meta asKeyCombination.  tmp2 textArea handleKeystroke: (KeyboardEvent new setType: #keystroke buttons: tmp4 modifier eventCode position: tmp2 textArea center keyValue: tmp4 key asciiValue charCode: tmp4 key asciiValue hand: nil stamp: DateAndTime now).  self assert: tmp3renderShadowOf: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 |  arg1 shadowWidth = 0 ifTrue: [ ^self ].  tmp1 := arg1 area.  tmp3 := arg1 area vector.  tmp2 := tmp3.  tmp4 := arg1 area origin.  [ tmp2 next ~= tmp3 ] whileTrue: [ self renderShadow: arg1 vector: tmp2 origin: tmp4 on: arg2.        self renderCornerShadow: arg1 vector: tmp2 origin: tmp4 on: arg2.        tmp4 := tmp2 + tmp4.        tmp2 := tmp2 next ].  self renderShadow: arg1 vector: tmp2 origin: tmp4 on: arg2.  self renderCornerShadow: arg1 vector: tmp2 origin: tmp4 on: arg2.  arg2 drawPolygon: (tmp1 vertices collect: [:arg3 |  arg3 + arg1 shadowOffset ]) color: arg1 shadowColor borderWidth: 0 borderColor: Color transparentannouncer  ^super announcerselectPreviousTab  self selectedIndex: (self selectedIndex < 2 ifTrue: [ self tabs size ] ifFalse: [ self selectedIndex - 1 ])vSpaceFill: arg1  < brickBuilderProperty: #Layout name: 'Vertical percent' as: #asInteger getter: #vPercent model: #GLMUIBuilderTextFieldProperty>  self layout vSpaceFill: arg1isWithElementIndex  ^self parameters at: 'withRowIndex' ifAbsent: [ false ]printString  ^collection printStringaddTab: arg1  self tabs add: (self newLabelBrick: arg1).  self updateTabspresentation: arg1  presentation := arg1initialize  super initialize.  lastScrollTimeStamp := 0.  self useVerticalLinearLayout.  self band: self newBand.  self verticalScrollbar: self newVerticalScrollbar.  self initializeListenerstabbedArrangement  ^self arrangement: GLMTabbedArrangement newsend: arg1 mouseDownWithShift: arg2 onItem: arg3  | tmp1 |  tmp1 := MouseButtonEvent basicNew setType: #mouseDown position: arg3 bounds origin + (1 @ 1) which: 4 buttons: (arg2 ifTrue: [ 8 ] ifFalse: [ 0 ]) hand: (HandMorph new           mouseFocus: arg3;           yourself) stamp: nil.  arg1 mouseUp: tmp1 onMorph: arg3variableSizePanes  self hasFixedSizePanes: falseinitialize  super initialize.  morphBuilder := [:arg1 :arg2 |  arg2 asMorph ]outOfWorld: arg1  super outOfWorld: arg1.  self unsubscribeListenersstyle  ^stylelayout  ^self brick layoutPropertiesprivateSetText: arg1  text := arg1 asString.  textSize := nilpassivelyFrom: arg1  self lastTransmission addPassiveOrigin: (self resolveOriginPort: arg1)testUnregisterAnnouncements  | tmp1 tmp2 |  tmp1 := Announcer new.  tmp2 := GLMPresentation new.  tmp2 updateOn: GLMTestAnnouncement from: [ tmp1 ].  tmp2 registerAnnouncements.  self assert: tmp1 numberOfSubscriptions equals: 1.  tmp2 unregisterFromAllAnnouncements.  self assert: tmp1 numberOfSubscriptions equals: 0diff  ^self custom: GLMDiffPresentation newtestEmptyPopPane  | tmp1 |  tmp1 := 0.  pagerModel announcer when: GLMPagePoped do: [:arg1 |  tmp1 := tmp1 + 1 ].  pagerModel popPane.  self assert: tmp1 equals: 0.  self assert: pagerModel size equals: 0.  self assert: pagerModel firstVisiblePageIndex equals: 0.  self assert: pagerModel lastVisiblePageIndex equals: 0.  self assert: pagerModel numberOfVisiblePages equals: 2.  pagerModel popPane.  pagerModel popPane.  self assert: tmp1 equals: 0paddingLeft  ^self brick paddingLeftstepTime  ^stepTime ifNil: [ super stepTime ]testLastActivePresentation  | tmp1 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 list title: 'a'.        arg1 text title: 'b'.        arg1 table title: 'c' ].  tmp1 startOn: 1.  self assert: tmp1 lastActivePresentation isNil.  (tmp1 panes first port: #selection) value: 2.  self assert: tmp1 lastActivePresentation isNil.  tmp1 panes last lastActivePresentation: tmp1 panes last presentations last.  self assert: tmp1 lastActivePresentation equals: tmp1 panes last presentations last.  (tmp1 panes first port: #selection) value: 3.  self assert: tmp1 panes last lastActivePresentation title equals: 'c'testOnChangeOfPortAct  | tmp1 tmp2 tmp3 |  tmp1 := GLMPane named: 'test'.  tmp2 := GLMPresentation new.  tmp1 addPresentation: tmp2.  tmp3 := 0.  tmp2 onChangeOfPort: #test act: [ tmp3 := tmp3 + 1 ].  (tmp1 port: #test) value: 42.  self assert: tmp3 equals: 1staticWidth  ^100 * self currentWorld displayScaleFactorpopupThemer  ^self registerModule: GLMActionBrickPopupThemer newwidthBottom: arg1  self width at: Bottom put: arg1iconBrick: arg1  iconBrick := arg1childrenBlock: arg1  childrenBlock := arg1iconFor: arg1  ^self cacheAt: #icon for: arg1 ifAbsentPut: [ self glamourPresentation icon cull: arg1 ]testSurroundingPanel  | tmp1 tmp2 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 dynamic presentation: [:arg2 :arg3 |  arg2 text ] ].  window := tmp1 openOn: 4.  tmp2 := window submorphs last submorphs first submorphs first.  self assert: (tmp2 isKindOf: PanelMorph).  self assert: (tmp2 submorphs first isKindOf: RubScrolledTextMorph)isWidthCustom  ^self hState isOnMyselftestFixedSize  | tmp1 |  tmp1 := GLMFinder new.  self assert: tmp1 hasFixedSizePanes.  tmp1 hasFixedSizePanes: false.  self assert: tmp1 hasFixedSizePanes nottestAdd  entity add: 4.  announcer announce: GLMTestAnnouncement.  self assert: listMorph roots size equals: 4.  self assert: listMorph model roots size equals: 4.  self assert: treeMorph roots size equals: 4.  self assert: treeMorph model roots size equals: 4.  self assert: tableMorph roots size equals: 4.  self assert: tableMorph model roots size equals: 4.  self assert: labelMorph contents equals: '4'scrollBrick: arg1  scrollBrick := arg1.  self scrollBrick pagerModel: pagerModel.  self scrollBrick     vSpaceFill;     hSpaceFill.  self addBrickBack: self scrollBricksetUp  super setUp.  tabs := LazyTabGroupMorph new.  tabs addLazyPage: (PanelMorph new fillStyle: (SolidFillStyle color: Color red)) label: 'one'.  tabs addLazyPage: (PanelMorph new fillStyle: (SolidFillStyle color: Color yellow)) label: (GLMLabelBrick new text: 'two').  window := tabs openInWindowmargin: arg1  < brickBuilderProperty: #Geometry name: 'Margin' as: #brickBuilderEvaluate getter: #margin model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds margin: arg1childrenValueOf: arg1 atLevel: arg2  ^self children glamourValue: arg1 asGlamorousMultiValue , self entity asGlamorousMultiValue , arg2 asGlamorousMultiValue , self asGlamorousMultiValueaddRow: arg1  ^self cellOrColumn addRow: arg1textPosition  ^self label textPositiontestOneReplacePane  pagerModel popAndReplacePane: self createSimplePaneMorph.  self assert: pagerModel size equals: 1.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 1.  self assert: pagerModel numberOfVisiblePages equals: 2pagerModel  ^pagerModeltestBottomMarginParentDependency  | tmp1 tmp2 tmp3 |  tmp2 := 10.  tmp1 := self newBrickWithStaticExtent.  tmp3 := self newBrickFullHeightAndWidthDependsOnParent: 100.  tmp3 marginBottom: tmp2.  tmp1 addBrickBack: tmp3.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp3 extent equals: self staticExtent - (0 @ tmp2).  self assert: tmp3 brickBounds equals: (0 @ 0 corner: self staticExtent - (0 @ tmp2))testTabsWithActions  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list act: #inspect entitled: 'Inspect'.        arg1 text ].  window := tmp1 openOn: 42.  self denyEmpty: self compositeTabGroup toolbarMorph submorphs.  self compositeTabGroup selectedPageIndex: 2.  self assertEmpty: self compositeTabGroup toolbarMorph submorphs.  self compositeTabGroup selectedPageIndex: 1.  self denyEmpty: self compositeTabGroup toolbarMorph submorphslogger: arg1  logger := arg1cellColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp1 := self elementAt: arg2.  tmp2 := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForElement: tmp1);     yourself.  (self needSeparatorBefore: arg2) ifTrue: [ tmp2 withTopSeparator ].  ^tmp2color  ^self registerModule: GLMBrickColorThemer newlayout: arg1  < brickBuilderProperty: #Layout name: 'Orientation' as: #brickBuilderLayout getter: #layoutPolicy model: #GLMUIBuilderTextFieldProperty>  self layoutPolicy: arg1bounds: arg1  self updateState: arg1.  self brickBounds: arg1widthParentDependency: arg1  ^self subclassResponsibilitycomputeTagsFilterFor: arg1  ^self computeTagsFor: arg1 from: self tagsFilterBlockassertWidthClean: arg1  self assert: arg1 wrappedBounds widthState equals: #clean.  self assert: arg1 wrappedBounds isWidthDirty not.  self assert: arg1 wrappedBounds isWidthCleaninitialize  super initialize.  logger := GLMLogger instancetagsToFilterBy  ^tagsToFilterBy ifNil: [ tagsToFilterBy := OrderedCollection new ]hideFromWorld  self deleteheaderBrick: arg1  headerBrick := arg1.  self headerBrick hSpaceFill.  self addBrickFirst: self headerBrickoldPage  ^oldPageborderDo: arg1  arg1 cull: self border.  ^selfvelocity: arg1  velocity := arg1contentPadding  ^0testEntityPortInitialization  | tmp1 tmp2 |  tmp1 := GLMPane named: 'test'.  tmp2 := GLMPresentation new initialize: [:arg1 |  arg1 entity: 2 ].  tmp1 addPresentation: tmp2.  self assert: tmp2 entity equals: nil.  tmp2 initializePresentation.  self assert: (tmp1 port: #entity) value equals: 2.  self assert: tmp2 entity equals: 2width: arg1  arg1 ifNil: [ ^self width: #(0) ].  arg1 isCollection ifTrue: [ arg1 isEmpty ifTrue: [ ^self width: #(0) ].        self           widthTop: (arg1 at: 1);           widthRight: (arg1 at: 1);           widthBottom: (arg1 at: 1);           widthLeft: (arg1 at: 1).        arg1 size > 1 ifTrue: [ self                 widthRight: (arg1 at: 2);                 widthLeft: (arg1 at: 2) ].        arg1 size > 2 ifTrue: [ self widthBottom: (arg1 at: 3) ].        arg1 size > 3 ifTrue: [ self widthLeft: (arg1 at: 4) ] ] ifFalse: [ ^self width: {arg1} ]isRow  ^trueonCreated: arg1  onCreatedBlock := arg1populate: arg1 iconName: arg2 entitled: arg3 with: arg4  self populate: arg1 icon: (self iconNamed: arg2) entitled: arg3 with: arg4hasChanged  ^self value ~~ self oldValueoriginatesAt: arg1  ^(self activeOrigins includes: arg1) and: [ self meetsCondition ]sendersOfIt  self announce: (GLMTextEditorRequest for: #sendersOfIt)isMorphBrick  ^falsesetLabelOf: arg1 for: arg2  textPosition: arg1  textPosition := arg1noTestEnteringTextInPort  | tmp1 tmp2 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text display: '' ].  window := tmp1 openOn: 4.  tmp2 := self find: RubScrolledTextMorph in: window.  self simulateOnlyOneClickOn: tmp2.  self simulateKeyStrokes: 'hello'.  self assert: (tmp1 pane port: #text) value asString equals: 'hello'width  ^self brickBounds widthhasTagsFilter  ^self tagsFilterBlock notNiluseExplicitAllNil  implicitAllNil := trueactOnPresentationUpdated: arg1  self setLabelOf: window for: arg1 presentationbuttonLabel  ^self glamourAction titlelabelBrick: arg1  labelBrick := arg1.  self label     vShrinkWrap;     hShrinkWrap;     text: 'button';     textPosition: #center;     vAlign: #center;     hAlign: #center.  self addBrickBack: self labeltestCreation  | tmp1 tmp2 tmp3 |  tmp2 := GLMSimplePort new     name: #portOne;     value: 1.  tmp3 := GLMSimplePort new     name: #portTwo;     value: 2.  tmp1 := GLMPortEvent on: tmp2 previouslyValued: tmp3.  self assert: tmp1 port equals: tmp2.  self assert: tmp1 oldValue equals: tmp3.  self assertEmpty: tmp1 transmissionContextisBrick  ^self brick isBrickdrawKeyboardFocusOnAthensCanvas: arg1  layoutChanged  normalBorderColor  ^self color silveropenWith: arg1  ^arg1 open: selfgtInspectorTransmissionsIn: arg1  < gtInspectorPresentationOrder: 35>  ^arg1 list     title: 'Transmissions';     display: [ self transmissions ]printOn: arg1  arg1 nextPutAll: 'a NodeModel with '.  arg1 nextPutAll: self item printStringcolumn: arg1 valueFor: arg2  ^arg1 computation glamourValue: arg2 asGlamorousMultiValue , self entity asGlamorousMultiValue , self asGlamorousMultiValuerenderRubricTextPresentation: arg1  ^GLMMorphicRubricTextRenderer render: arg1 from: selfcolumn: arg1 valueFor: arg2  ^arg1 computation glamourValue: arg2 asGlamorousMultiValue , self entity asGlamorousMultiValue , self asGlamorousMultiValueheaderMorph  ^headerMorphpresentation: arg1  self presentationTransformation: arg1presentationsFactory: arg1  presentationsFactory := arg1layoutPolicy  ^super layoutPolicywasTransmited  ^wasTransmitedheightParentDependency: arg1  ^self subclassResponsibilityactOnPaneRemoved: arg1  container removeMorph: container submorphs last.  container removeMorph: container submorphs lasttestDiminishToRight  | tmp1 tmp2 |  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  tmp1 := pagerModel defaultNumberOfVisiblePages.  tmp2 := pagerModel lastVisiblePageIndex.  self assert: pagerModel numberOfVisiblePages equals: tmp1.  self assert: pagerModel numberOfVisiblePages equals: tmp2 - pagerModel firstVisiblePageIndex + 1.  self assert: pagerModel lastVisiblePageIndex equals: tmp2.  [ tmp1 > 1 ] whileTrue: [ pagerModel diminishToRight.        tmp1 := tmp1 - 1.        self assert: pagerModel numberOfVisiblePages equals: tmp1.        self assert: pagerModel numberOfVisiblePages equals: tmp2 - pagerModel firstVisiblePageIndex + 1.        self assert: pagerModel lastVisiblePageIndex equals: tmp2 ].  (1 to: 3) do: [:arg1 |  pagerModel diminishToRight.        self assert: pagerModel numberOfVisiblePages equals: 1.        self assert: pagerModel numberOfVisiblePages equals: tmp2 - pagerModel firstVisiblePageIndex + 1.        self assert: pagerModel lastVisiblePageIndex equals: tmp2 ]testPresentationConditions  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMPane named: 'test'.  tmp2 := GLMPresentation new condition: [:arg1 :arg2 |  arg1 = 1 and: [ arg2 = 2 ] ].  tmp3 := GLMPresentation new condition: [:arg1 |  arg1 = #foo ].  tmp4 := GLMPresentation new useExplicitNotNil.  tmp1 addPresentation: tmp2.  tmp1 addPresentation: tmp3.  tmp1 addPresentation: tmp4.  (tmp1 port: #entity) value: (GLMMultiValue withAll: #(1 2)).  self assert: tmp1 matchingPresentations size equals: 2.  self assert: tmp1 matchingPresentations first identicalTo: tmp2.  self assert: tmp1 matchingPresentations last identicalTo: tmp4.  (tmp1 port: #entity) value: (GLMMultiValue withAll: #(#foo 2)).  self assert: tmp1 matchingPresentations size equals: 2.  self assert: tmp1 matchingPresentations first identicalTo: tmp3.  self assert: tmp1 matchingPresentations last identicalTo: tmp4.  (tmp1 port: #entity) value: (GLMMultiValue withAll: #(nil 2)).  self assert: tmp1 matchingPresentations size equals: 1testDefaultValidate  | tmp1 |  tmp1 := GLMPane named: 'test'.  self assert: ((tmp1 port: #selection) validate: 5)step  self window ifNil: [ ^self ].  self window isActive ifFalse: [ ^self ].  (self wantsSteps and: [ self model shouldDoStep ]) ifFalse: [ ^self ].  (self window boundsInWorld containsRect: self boundsInWorld) ifFalse: [ ^self ].  self model updateRoots.  self updateListexecute: arg1  ^self execute: self task withArguments: arg1 callback: self callback priority: self priority delay: self delayaddContent: arg1  | tmp1 |  process ifNotNil: [ process terminate ].  process := nil.  process := [ tmp1 := arg1 value.  WorldState addDeferredUIMessage: [ self contentsMorph           removeAllMorphs;           addMorph: tmp1 fullFrame: LayoutFrame identity ] ] newProcess.  process priority: Processor userBackgroundPriority.  process resumehasBindingThatBeginsWith: arg1  ^self variableBindings keys anySatisfy: [:arg2 |  arg2 beginsWith: arg1 ]notingPresentationChangeDo: arg1  | tmp1 tmp2 |  self isAllowedToNotePresentationsChanged ifFalse: [ arg1 value.        ^self ].  allowedToNotePresentationsChanged := false.  tmp1 := presentations presentations copy.  tmp2 := self cachedMatchingPresentations.  arg1 value.  presentations presentations ~= tmp1 ifTrue: [ self announce: (GLMPresentationsChanged new                 pane: self;                 oldPresentations: tmp1;                 yourself) ].  self matchingPresentations ~= tmp2 ifTrue: [ self announce: (GLMMatchingPresentationsChanged new                 pane: self;                 oldMatchingPresentations: tmp2;                 yourself) ].  allowedToNotePresentationsChanged := trueupdateWidth: arg1 on: arg2  arg1 withWidth: (arg2 normalizeWidth: (arg2 widthMyselfDependency: arg1) of: arg1)cellOrColumn  ^cell ifNil: [ cell := GLMCustomColumn new browser: self ]compositeTabGroup  | tmp1 |  tmp1 := self compositeMorph.  self assert: (tmp1 isKindOf: LazyTabGroupMorph).  ^tmp1labelBrick: arg1  labelBrick := arg1.  self labelBrick textPosition: #leftCenter.  self addBrickBack: labelBricktranslateBy: arg1  self wrappedBounds translateBy: arg1morph  ^morphassertAllSubbricksAreClean: arg1  arg1 withAllSubbricks do: [:arg2 |  self assertBrickClean: arg2 ]acceptAction: arg1  self flag: #TODO.  self model ifNotNil: [:arg2 |  arg2 acceptAction: arg1 ]updateMorphBounds  self withAllSubbricks select: #isMorphBrick thenDo: #onLayoutedallowNil  ^self useExplicitNotNilcollect: arg1  ^collection collect: arg1forbidToAnnounceMatchingPresentationsChanged: arg1  self forbid: arg1 toAnnounce: GLMMatchingPresentationsChangedtheme  ^UITheme currenttestFinderWithPreviousPort  < expectedFailure>  | tmp1 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 list           title: 'Presentation1';           display: [:arg2 |  1 to: arg2 ] ].  tmp1     fromPrevious: #selection;     passivelyFromPrevious: #highlight;     andShow: [:arg1 |  arg1 list           title: 'Presentation2';           display: [:arg3 :arg4 |  1 to: arg3 + arg4 ] ].  tmp1 startOn: 42.  self assert: tmp1 panes first presentations size equals: 1.  self assert: tmp1 presentations first title equals: 'Presentation1'.  self assert: tmp1 transmissions size equals: 1.  self assert: tmp1 transmissions last origins size equals: 2.  self assert: tmp1 transmissions last transmissionStrategy presentations size equals: 1.  self assert: tmp1 transmissions last transmissionStrategy presentations first title equals: 'Presentation2'.  self assert: (tmp1 panes first port: #entity) value equals: 42.  (tmp1 panes first port: #highlight) value: 43.  (tmp1 panes first port: #selection) value: 41.  self assert: tmp1 panes size equals: 2.  self assert: tmp1 panes last presentations size equals: 2.  self assert: tmp1 panes last presentations last displayValue size equals: 84.  self assert: tmp1 panes last presentations size equals: 2shoutAboutToStyle: arg1  self highlightSmalltalk ifFalse: [ ^false ].  self highlightSmalltalkContext notNil ifTrue: [ arg1 classOrMetaClass: self highlightSmalltalkContext ].  ^truedata: arg1  ^self setProperty: #brickDataObject toValue: arg1selection: arg1  self selection = arg1 ifTrue: [ ^self ].  super selection: arg1.  self announcer announce: (GLMTreeMorphSelectionChanged new           selectionValue: (arg1 ifNotNil: [ arg1 selectedItemOrItemsOrNil ]);           selectionPathValue: self selectionPathItems;           yourself)markHeightDirty  self heightState: #dirtywhen: arg1 do: arg2  self announcer when: arg1 do: arg2hasSubbrick: arg1  ^arg1 owner = selfmarkButtonsInside: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self flag: 'refactor me'.  tmp4 := false.  tmp5 := false.  tmp1 := 0.  pagerModel size = 0 ifTrue: [ ^self ].  tmp2 := arg1 x.  tmp3 := arg1 y.  self buttons do: [:arg2 |  tmp1 := tmp1 + 1.        (self isScrollMustBeChecked: tmp1 withLeft: tmp2 andRight: tmp3) ifTrue: [ arg2 check.              tmp4 ifFalse: [ pagerModel virtualFirstVisiblePageIndex: tmp1.                    tmp4 := true ] ] ifFalse: [ arg2 isFocused ifFalse: [ arg2 uncheck ].              tmp4 & (tmp5 = false) ifTrue: [ pagerModel virtualLastVisiblePageIndex: tmp1 - 1.                    tmp5 := true ] ] ].  tmp5 ifFalse: [ pagerModel virtualLastVisiblePageIndex: tmp1.        tmp5 := true ]titleValueOfColumn: arg1  ^arg1 title glamourValue: self entitydynamicActions: arg1  dynamicActionsBlock := arg1tagMorphsFrom: arg1 for: arg2  | tmp1 tmp2 tmp3 |  tmp1 := OrderedCollection new.  tmp2 := self glamourPresentation tagsFor: arg2 fromProvider: arg1 to: #show.  tmp3 := self glamourPresentation tagsFor: arg2 fromProvider: arg1 to: #filter.  tmp2 withIndexDo: [:arg3 :arg4 |  tmp1 addLast: (self buttonForTag: arg3 filter: (tmp3 at: arg4 ifAbsentPut: [ arg3 ])) ].  ^tmp1testWithBlockPassesTheParentPresentation  | tmp1 tmp2 |  tmp1 := GLMPresentation new.  tmp1 with: [:arg1 |  tmp2 := arg1 ].  self assert: tmp2 identicalTo: tmp1smalltalkClassLogic  ^self valueOfProperty: #phlowSmalltalkClass ifAbsent: [ #yourself ]showScrollBarWhenNeeded: arg1  showScrollBarWhenNeeded := arg1useCache  self parameters at: 'shouldUseCache' put: trueallMenuActions  ^self glamourPresentation allSelectionActions select: [:arg1 |  arg1 hasTitle ]passivelyFromPrevious: arg1  self flag: 'needs revisiting. it does not work anymore'.  self scriptTransmission addPassiveOrigin: (GLMPort new name: arg1)isInsideOfPopupBrick: arg1  ^(self isInsideOfTriggerBrick: arg1) | (self isInsideOfContentBrick: arg1)column: arg1 evaluated: arg2 width: arg3  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           width: arg3;           yourself)isRightResizingZone: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := self globalBounds.  tmp2 := tmp4 top.  tmp3 := tmp4 right - resizingZoneWidth.  tmp1 := tmp3 @ tmp2 corner: tmp4 corner.  ^tmp1 containsPoint: arg1 positionexpandParentPath  self containerTree expandNodePath: self pathdefaultBottomMargin  ^11registerAnnouncements  self flag: 'The announcements should potentially be interested in any ports, not just in entity'.  updateActions do: [:arg1 |  arg1 registerInPresentation ]setTitle: arg1  self titleBrick text: arg1.  titleBrick height: (arg1 isEmpty | arg1 isNil ifFalse: [ 30 ] ifTrue: [ 0 ])entity  ^entitycopyAccordingToPaneMapping: arg1 inNewBrowser: arg2  ^(arg1 at: self pane) port: self nametestDefaultPresentation  | tmp1 |  tmp1 := GLMDynamicPresentation new.  tmp1 entity: 42.  tmp1 transformation: [:arg1 |  GLMRubricTextPresentation new ].  self assert: tmp1 currentPresentation presentations size equals: 1.  self assert: (tmp1 currentPresentation presentations first isKindOf: GLMRubricTextPresentation).  self assert: tmp1 currentPresentation pane identicalTo: tmp1 panecontentBackgroundColor  ^self theme backgroundColoradoptPaneColor: arg1  self assureExtension.  extension fillStyle ifNil: [ self color: arg1 ].  self borderStyle baseColor: arg1 darker.  self submorphsDo: [:arg2 |  arg2 adoptPaneColor: arg1 ]testMinHeightTwoParentDependencies  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := 80.  tmp1 := self newBrickWithStaticExtent.  tmp1 useVerticalLinearLayout.  tmp2 := self newBrickWithFullFill.  tmp2 vSpaceFill: 50.  tmp2 minHeight: tmp4.  tmp3 := self newBrickWithFullFill.  tmp1 addAllBricks: {tmp2 .         tmp3}.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp2 extent equals: self staticWidth @ tmp4.  self assert: tmp3 extent equals: self staticWidth @ (self staticHeight - tmp4)testDisplay  | tmp1 |  tmp1 := GLMPresentation new.  tmp1 entity: #foo.  self assert: tmp1 displayValue equals: #foo.  tmp1 entity: #(#foo #bar).  self assert: tmp1 displayValue equals: #(#foo #bar).  tmp1 entity: (GLMMultiValue withAll: #(#foo #bar)).  self assert: tmp1 displayValue equals: #foo.  tmp1 transformation: [:arg1 :arg2 |  (arg1 , arg2) asSymbol ].  self assert: tmp1 displayValue equals: #foobaractOnPaneAdded: arg1  self subclassResponsibilityexplicitlySelectMultipleItems: arg1  | tmp1 tmp2 |  arg1 ifNil: [ ^self ].  tmp2 := arg1 isCollection ifTrue: [ arg1 ] ifFalse: [ arg1 asOrderedCollection ].  (self selection notNil and: [ self selection selectedItemOrItemsOrNil = tmp2 asOrderedCollection ]) ifTrue: [ ^self ].  tmp1 := OrderedCollection new.  self roots do: [:arg2 |  arg2 withContentsDo: [:arg3 |  (tmp2 includes: arg3 item) ifTrue: [ tmp1 add: arg3 path ] ] ].  self selectAllNodePaths: tmp1marginLeft  ^self wrappedBounds marginLeftcollapsableFor: arg1  | tmp1 |  tmp1 := GLMCollapsableBrick new.  tmp1     vShrinkWrap;     hSpaceFill.  tmp1 headerBrick: (self headerFor: arg1 in: tmp1).  (self hasChildren: arg1) ifTrue: [ tmp1 contentBrick: (self class new on: arg1 value).        tmp1 contentBrick           vShrinkWrap;           hSpaceFill;           marginLeft: 19 ].  tmp1 expand.  ^tmp1isHShrinkWrap  ^self hState isOnChildrenrightAngle: arg1  ^arg1 = GLMSouthDirection uniqueInstanceexportToCSV  FileSystem workingDirectory / 'table-export.csv' writeStreamDo: [:arg1 |  self columns do: [:arg2 |  arg1                 nextPut: $";                 nextPutAll: (self titleValueOfColumn: arg2);                 nextPut: $" ] separatedBy: [ arg1 nextPut: $, ].        arg1 cr.        self displayValue do: [:arg3 |  self columns do: [:arg2 |  arg1                       nextPut: $";                       nextPutAll: (self column: arg2 valueFor: arg3) asString;                       nextPut: $" ] separatedBy: [ arg1 nextPut: $, ].              arg1 cr ] displayingProgress: 'Exporting' ]pushPane: arg1  arg1     borderWidth: 0;     hResizing: #spaceFill;     vResizing: #spaceFill;     layoutInset: 0.  transform hasSubmorphs ifTrue: [ transform addMorphBack: self separator ].  transform addMorphBack: (arg1 adoptPaneColor: self paneColor).  paneCount := paneCount + 1.  self updatePanesgtDisplayOn: arg1  self hasTitle ifTrue: [ arg1           nextPutAll: self title;           space ].  self hasShortcut ifTrue: [ self keymap gtDisplayOn: arg1.        arg1 space ].  self action gtDisplayOn: arg1paddingRight: arg1  < brickBuilderProperty: #Geometry name: 'Padding Right' as: #asInteger getter: #paddingRight model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds paddingRight: arg1open: arg1  window := GLMMorphicWindowRenderer render: arg1 from: self.  ^window openInWorldpopupErrorThemer  ^self registerModule: GLMBrickPopupErrorThemer new to: self named: #popupThemeractOnPresentationRefreshRequest: arg1  tableMorph window ifNil: [ ^self ].  tableMorph window isActive ifFalse: [ ^self ].  (tableMorph window boundsInWorld containsRect: tableMorph boundsInWorld) ifFalse: [ ^self ].  tableModel resetDataCache.  tableMorph refreshwidthTraverser  ^GLMBrickWidthTraverser uniqueInstanceopenOn: arg1 inExternalWindowWith: arg2  self startOn: arg1.  ^arg2 openInExternalWindow: selfcolumn: arg1 evaluated: arg2 sortedBy: arg3  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           sortBlock: arg3)dataCacheFor: arg1  ^self dataCache at: arg1 ifAbsentPut: [ Dictionary new ]hAlign: arg1  hAlign := arg1close  self announce: GLMBrowserClosed new* arg1  < return: #Point>  ^arg1 @ 0widthState  ^widthState ifNil: [ widthState := #dirty ]pane  ^panetext  ^self custom: GLMRubricTextPresentation newexecute  self glamourAction actOn: self glamourPresentationallowsRecursiveSearch  ^allowsRecursiveSearch ifNil: [ allowsRecursiveSearch := true ]selectedIndex: arg1  selectedIndex := arg1shadowWidth: arg1  < brickBuilderProperty: #'Look&Feel' name: 'Shadow Width' as: #asInteger getter: #shadowWidth model: #GLMUIBuilderTextFieldProperty>  self setProperty: #brickShadowWidth toValue: arg1valueOfProperty: arg1  ^super valueOfProperty: arg1layoutPolicy: arg1 on: arg2  ^(arg1 owner ifNil: [ arg1 ] ifNotNil: [:arg3 |  arg3 isBrick ifTrue: [ arg3 ] ifFalse: [ arg1 ] ]) layoutPolicyscrollTo: arg1 smooth: arg2  self scrollTo: arg1 smooth: arg2 callback: nilisFoundationBrick  ^trueaction: arg1  action := arg1testMaxHeightOneStatic  | tmp1 |  tmp1 := self newBrickWithStaticExtent.  tmp1 maxHeight: self staticSmallHeight.  tmp1 doLayoutForce.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 brickBounds equals: (0 @ 0 extent: self staticWidth @ self staticSmallHeight)pageIndex  ^pageIndextestToRawSelection  | tmp1 |  tmp1 := GLMPresentation new.  tmp1 selection: 1.  self assert: tmp1 selection equals: 1.  self assert: tmp1 rawSelection equals: 1.  tmp1 selectionTransformation: [:arg1 |  arg1 + 1 ].  tmp1 selection: 1.  self assert: tmp1 selection equals: 2.  self assert: tmp1 rawSelection equals: 1translateY: arg1  ^self brick translateY: arg1beNormal  self removeAllBricks.  self addBrickBack: self normalLabel.  self themer tabLabelThemer normalStyleFor: self.  self changedicon  ^self containerTree glamourPresentation iconFor: self itemaction: arg1  self     when: #onChecked do: [:arg2 :arg3 |  arg1 cull: true cull: self cull: arg2 cull: arg3 ];     when: #onUnchecked do: [:arg2 :arg3 |  arg1 cull: false cull: self cull: arg2 cull: arg3 ]indexOf: arg1  ^collection indexOf: arg1glamourExpander: arg1  glamourExpander := arg1fullBounds  ^self globalBoundswhenKindOf: arg1  self when: [:arg2 |  arg2 isKindOf: arg1 ]filterBlock  ^filterBlockcancelOnFocusLost  cancelOnFocusLost := truedrawingBounds  ^self renderer drawingBounds: selfprintOn: arg1  super printOn: arg1.  arg1     nextPutAll: ' (presentation = ';     nextPutAll: self presentation printString;     nextPutAll: ', property = #';     nextPutAll: self property;     nextPutAll: ', oldValue = ';     nextPutAll: self oldValue gtDisplayString;     nextPutAll: ', value = ';     nextPutAll: self value gtDisplayString;     nextPutAll: ')'shouldFilterByTag: arg1  ^self tagsToFilterBy includes: arg1testOnlyOneMorphPerRowInList  | tmp1 tmp2 tmp3 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  arg2 ] ].  window := tmp1 openOn: (1 to: 100).  self waitUntilUIRedrawed.  tmp2 := self find: MorphTreeMorph in: window.  tmp3 := (self find: MorphTreeTransformMorph in: tmp2) submorphs.  self assert: tmp3 size equals: 100.  tmp3 do: [:arg3 |  self assert: arg3 submorphs size equals: 1 ]beHelp  self themer: self themer popupHelpThemer themerpaddingLeft  ^self padding at: LeftaddBrickBack: arg1  | tmp1 |  tmp1 := arg1 asDoubleLink.  arg1 brickDoubleLink: tmp1.  self hasSubbricks ifTrue: [ self lastSubbrick brickDoubleLink nextLink: tmp1.        tmp1 previousLink: self lastSubbrick brickDoubleLink ].  self privateSubbricks: (self subbricks copyWith: arg1).  arg1 privateOwner: selfnewButtonsBrick  ^GLMPagerButtonsPaneBrick newsuspendedAnnouncements  ^OrderedCollection with: GLMTreeMorphSelectionChanged with: GLMTreeMorphStrongSelectionChanged with: GLMMenuItemSelected with: GLMKeyStrokeresetValue  | tmp1 |  tmp1 := GLMTransmissionContext new.  tmp1 addPort: self.  self changeValueTo: nil in: tmp1computation: arg1  computation := arg1tabSelector: arg1  tabSelector := arg1findWherePresentationIs: arg1 in: arg2  ^self findSatisfying: [:arg3 |  arg3 model notNil and: [ (arg3 model respondsTo: #glamourPresentation) and: [ arg3 model glamourPresentation == arg1 ] ] ] in: arg2glamourPresentation  ^glamourPresentationoldPresentations  ^oldPresentationsinitializeOn: arg1 previouslyValued: arg2 in: arg3  port := arg1.  oldValue := arg2.  transmissionContext := arg3isPaneVisible: arg1  ^arg1 >= self firstVisiblePageIndex & (arg1 <= self lastVisiblePageIndex)handlePotentialStatusbarFor: arg1  | tmp1 tmp2 |  tmp2 := 0.  arg1 hasStatusbar ifTrue: [ tmp1 := GLMMorphicPaneWithoutTitleRenderer render: arg1 statusbarPane from: self renderer.        tmp2 := (0 - (LabelMorph contents: 'XXX') minHeight) * 1.2.        window addMorph: tmp1 fullFrame: (LayoutFrame identity                 topFraction: 1;                 leftOffset: 2;                 topOffset: tmp2;                 rightOffset: -2) ].  ^tmp2rawSelectionTransmissionFor: arg1 ifNone: arg2  ^rawSelectionTransmissions detect: [:arg3 |  arg3 destination port name = arg1 ] ifNone: arg2doLayoutForce  self wrappedBounds     markHeightDirty;     markWidthDirty.  self doLayouthash  ^self port hashgtDisplayOn: arg1  self origins asArray gtDisplayOn: arg1.  arg1 nextPutAll: '->'.  self destination gtDisplayOn: arg1rubricBorderWidth: arg1  self setProperty: #brickRubricBorderWidth toValue: arg1.  self updateStyleisHShrinking  ^hResizing = #shrinkWrapcolumns  ^columns ifNil: [ columns := OrderedCollection new ]testAllowNilConditionWhenEmbedded  | tmp1 tmp2 |  tmp1 := GLMExpander new.  tmp1 allowNil.  tmp1 display: [:arg1 :arg2 |  arg1 + arg2 ].  tmp1 show: [:arg3 |  arg3 text display: [:arg1 :arg2 |  arg1 asString , arg2 asString ] ].  tmp2 := GLMTabulator new.  tmp2     column: #one;     column: #two.  tmp2 transmit     to: #two;     fromOutsidePort: #entity;     from: #one port: #nilPort;     andShow: [:arg3 |  arg3 custom: tmp1 ].  self should: [ tmp2 startOn: 1 ] raise: ErrorsetBoundsOf: arg1 after: arg2  arg1     withWidth: self band width;     brickBounds: (arg2 brickBounds bottomLeft extent: arg1 extent)testUnregisterAnnouncementsWhenEntityChanges  | tmp1 tmp2 |  tmp1 := Announcer new.  tmp2 := GLMPresentation new.  tmp2 updateOn: GLMTestAnnouncement from: [ tmp1 ].  tmp2 entity: 1.  tmp2 registerAnnouncements.  self assert: tmp1 numberOfSubscriptions equals: 1.  tmp2 entity: 2.  self assert: tmp1 numberOfSubscriptions equals: 0.  tmp2 registerAnnouncements.  self assert: tmp1 numberOfSubscriptions equals: 1.  tmp2 entity: nil.  self assert: tmp1 numberOfSubscriptions equals: 0testMarkerOneStaticInStaticHeight  | tmp1 tmp2 |  tmp1 := self newBrickWithStaticExtent.  tmp2 := self newBrickWithStaticExtent.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthClean.  self assert: tmp2 wrappedBounds isHeightDirty.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightCleanaddColumn: arg1  self columns add: arg1displayLogic  ^self valueOfProperty: #phlowDisplay ifAbsent: [ #yourself ]hideScrollBar  self removeMorph: scrollBar.  self adjustPaneHeightstylerDecorator  ^stylerDecoratorcomputeMorphWidths  | tmp1 tmp2 |  tmp1 := self paneWidthsToFit: self totalPaneWidth.  tmp2 := OrderedCollection new.  tmp1 do: [:arg1 |  tmp2 add: arg1 ] separatedBy: [ tmp2 add: self separatorWidth ].  ^tmp2 asArrayextent: arg1  super extent: arg1.  self fullBoundstranslateBy: arg1  self brickBounds: (self brickBounds translateBy: arg1)defaultDimension  ^50isFocused  ^falseheightTraverser  ^GLMBrickHeightTraverser uniqueInstancepresentationClass: arg1 startOn: arg2  glmPres := arg1 new startOn: arg2action  ^actionscrollTo: arg1  self shouldBeImplementedannouncements: arg1  announcements := arg1action  ^actionhighlightSmalltalkContext  ^highlightSmalltalkContextwidthRight  ^self width at: RighttestChangeChildrenInParent  | tmp1 tmp2 |  tmp1 := self newBrickWithFullDependsOnChildren.  tmp2 := self newBrickWithStaticExtent.  tmp1 addBrickBack: tmp2.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: tmp2 extent.  tmp2 height: self staticHeight * 2.  tmp2 width: self staticWidth * 2.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp2 extent equals: self staticExtent * 2.  self assert: tmp1 extent equals: tmp2 extenttestNestedBrowserOther  | tmp1 tmp2 tmp3 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp2 := GLMTabulator new.  tmp2 column: #innerOne.  tmp2 transmit     to: #innerOne;     andShow: [:arg1 |  arg1 text ].  tmp2 transmit     toOutsidePort: #selection;     from: #innerOne.  tmp1 transmit     to: #one;     andShow: [:arg1 |  (arg1 custom: tmp2) display: [:arg2 |  arg2 + 2 ] ].  tmp1 transmit     to: #two;     from: #one;     andShow: [:arg1 |  arg1 text ].  tmp1 startOn: 40.  tmp3 := (tmp1 paneNamed: #one) presentations first.  self assert: ((tmp1 paneNamed: #one) port: #entity) value equals: 40.  self assert: (tmp3 pane port: #entity) value equals: 40.  self assert: ((tmp3 paneNamed: #innerOne) port: #entity) value equals: 42.  (tmp3 panes first port: #selection) value: 7.  self assert: (tmp3 pane port: #selection) value equals: 7.  self assert: (tmp1 panes last port: #entity) value equals: 7column: arg1 evaluated: arg2 tags: arg3 sortedBy: arg4  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           tags: arg3;           sortBlock: arg4)updateDimension: arg1  arg1 isHeightClean ifTrue: [ ^self ].  (self dimensionPolicy: arg1) updateHeight: arg1resetAnnouncer  super resetAnnouncer.  self panes do: [:arg1 |  arg1 resetAnnouncer ]testCondition  | tmp1 tmp2 tmp3 |  tmp1 := GLMExplicitBrowser new.  tmp2 := GLMExplicitBrowser new.  tmp1 title: 'browser1'.  tmp2 title: 'browser2'.  tmp2     transformation: [:arg1 |  arg1 = 42 ifFalse: [ self fail.              42 ] ifTrue: [ 84 ] ];     condition: [:arg1 |  arg1 = 42 ].  tmp1 addNewPane name: 'pane1'.  tmp3 := GLMTransmission new ensureReplacePresentationsStrategy.  tmp3 transmissionStrategy addPresentation: tmp2.  tmp1 addTransmission: (tmp3           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: tmp1;                 name: #entity;                 yourself);           destination: (tmp1 panes first port: #entity);           yourself).  self assert: (tmp1 pane port: #entity) value isNil.  self assert: (tmp1 panes first port: #entity) value isNil.  self assertEmpty: tmp1 panes first presentations.  (tmp1 pane port: #entity) value: 41.  self assert: (tmp1 pane port: #entity) value equals: 41.  self assert: (tmp1 panes first port: #entity) value equals: 41.  self assert: tmp1 panes first presentations size equals: 1.  self assertEmpty: tmp1 panes first matchingPresentations.  (tmp1 pane port: #entity) value: 42.  self assert: (tmp1 pane port: #entity) value equals: 42.  self assert: tmp1 panes first presentations size equals: 1.  self assert: tmp1 panes first matchingPresentations size equals: 1span: arg1  span := arg1pushPane: arg1  self band addBrickBack: (self configurePane: arg1)* arg1  < return: #Point>  ^0 @ arg1 negatedwantsSteps  ^self shouldStopStepping not and: [ self glamourPresentation wantsSteps ]items  ^items ifNil: [ items := self calculateItems ]transmissions  ^transmissionsborderWidth  ^1click: arg1  self toggle.  ^truetoggleAmountToFilterBy  self amountToFilterBy notNil ifTrue: [ self amountToFilterBy isZero ifTrue: [ amountToFilterBy := self glamourPresentation amountToShow ] ifFalse: [ amountToFilterBy := 0 ].        self changed: #rootNodes ]isChecked  ^isCheckedrow: arg1 span: arg2  ^self addRow: arg1 span: arg2updateTextAreaWhenPlugged  self withStyler.  super updateTextAreaWhenPluggedorigin  ^originscrollTo: arg1  self moveLeft: (owner width - self width) * arg1changed  ^self brick changedrubricCursorColor  ^self valueOfProperty: #brickRubricCursorColor ifAbsent: [ self themer rubricCursorColor ]addPresentation: arg1  self transmission transmissionStrategy addPresentation: arg1sliderBrick  ^sliderBricktestTopMarginMyselfDependency  | tmp1 tmp2 tmp3 |  tmp2 := 10.  tmp1 := self newBrickWithStaticExtent.  tmp3 := self newBrickWithSmallStaticExtent.  tmp3 marginTop: tmp2.  tmp1 addBrickBack: tmp3.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp3 extent equals: self staticSmallExtent.  self assert: tmp3 brickBounds equals: (0 @ tmp2 extent: self staticSmallExtent)newLabelBrick: arg1 selected: arg2  ^GLMTabLabelBrick new     label: arg1 selected: arg2;     when: #onClicked send: #onTabClicked:with: to: self;     tabSelector: self;     vSpaceFilliconName: arg1  self icon: (Smalltalk ui icons iconNamed: arg1)renderPopupAction: arg1  ^GLMMorphicPopupActionRenderer render: arg1 from: selfmorphicLayerNumber  ^10actOnPaneRemoved: arg1  container brickRoot popPaneonPagePoped  self showOrHideScrollBarprintOn: arg1  super printOn: arg1.  arg1     nextPut: $(;     nextPutAll: self identityHash printString;     space;     nextPutAll: self name;     nextPut: $)assertWidthDirty: arg1  self assert: arg1 wrappedBounds widthState equals: #dirty.  self assert: arg1 wrappedBounds isWidthDirty.  self assert: arg1 wrappedBounds isWidthClean notaddColumn: arg1  ^self cellOrRow addColumn: arg1band: arg1  band := arg1.  self band scrollpane: self.  self band hSpaceFill.  super addBrickBack: self bandrenderMorphFor: arg1  paneMorph     addMorph: (self renderObject: arg1 presentations) fullFrame: LayoutFrame identity;     yourselfscrollButtonIconRenderBlock: arg1  scrollButtonIconRenderBlock := arg1updatePosition  | tmp1 tmp2 tmp3 |  self scrollPane ifNil: [ ^self ].  self scrollPane band height = 0 ifTrue: [ self bar brickBounds: (0 @ 0 extent: 0 @ 0).        ^self changed ].  tmp1 := self calculateScrollbarHeight.  tmp2 := self calculateScrollbarTopOffset.  tmp3 := tmp1 >= self height ifTrue: [ 0 ] ifFalse: [ self width ].  self bar brickBounds: (0 @ tmp2 extent: tmp3 @ tmp1).  self changedremoveCloserListener  self assert: [ self closer isNotNil ] description: [ 'Closer must not be nil' ].  self activeHand removeEventListener: self closer.  self closer popup: nilhandlesMouseDown: arg1  ^truetitleAction: arg1  labelActionBlock := arg1onLayouted  super onLayouted.  self invalidateMorphBoundsportName  ^portNamenoTestExplicitAcceptDoesNotAffectTextPort  | tmp1 tmp2 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text display: '123' ].  window := tmp1 openOn: 4.  tmp2 := self find: RubScrolledTextMorph in: window.  self simulateOnlyOneClickOn: tmp2.  self simulateKeyStrokes: '4'.  self assert: (tmp1 pane port: #text) value asString equals: '1234'.  self simulateKeyStroke: $s meta.  self simulateKeyStrokes: '56'.  self assert: (tmp1 pane port: #text) value asString equals: '123456'width  ^width ifNil: [ width := Array braceWith: 0 with: 0 with: 0 with: 0 ]scrollbarWidth  ^2newScrollList  ^GLMFallbackScrollListBrick newouterOrigin: arg1  self brickBounds: (arg1 + (self marginLeft @ self marginTop) extent: self extent)spec  ^self custom: GLMSpecPresentation newmoreToolbarActions: arg1 on: arg2  | tmp1 |  tmp1 := MenuMorph new.  arg1 do: [:arg3 |  (tmp1 add: arg3 title target: arg3 selector: #actOn: argument: arg2)           enabled: (arg3 isEnabledOn: arg2);           yourself ].  ^tmp1testRemove  entity removeLast.  announcer announce: GLMTestAnnouncement.  self assert: listMorph model roots size equals: 2.  self assert: treeMorph model roots size equals: 2.  self assert: tableMorph model roots size equals: 2.  self assert: labelMorph contents equals: '2'hasMaxDimensionRestriction: arg1  ^self subclassResponsibilitymarginRight  ^self wrappedBounds marginRightmouseUp: arg1  super mouseUp: arg1.  (self bounds containsPoint: arg1 position) & self isPressed ifTrue: [ self depress.        ^self click: arg1 ] ifFalse: [ self deselect: arg1.        ^self depress ]testIn  | tmp1 |  tmp1 := GLMPane in: 1.  self assert: tmp1 name equals: tmp1 defaultName.  self assert: tmp1 browser equals: 1.  self assertEmpty: tmp1 ports.  self assertEmpty: tmp1 presentationsvShrinkWrap  super vShrinkWrap.  self labelBrick vShrinkWrap.  self editBrick vShrinkWrapannounce: arg1  (self isAnnouncementSuspended: arg1) ifTrue: [ ^arg1 asAnnouncement ].  ^super announce: arg1addButton: arg1  self buttons add: arg1.  arg1 enable.  arg1 index: self buttons size.  arg1 announcer when: GLMPagerButtonClicked send: #onButtonClicked: to: self.  arg1 announcer when: GLMPagerButtonSelected send: #onButtonSelected: to: self.  arg1 announcer when: GLMPagerButtonDeselected send: #onButtonDeselected to: self.  self theme pagerWidgetThemer defaultScrollButtonStyleFor: arg1.  arg1 height: self pagerModel circleButtonSize.  arg1 width: self pagerModel circleButtonSize.  self addBrickBack: arg1.  self buttons size = 1 ifTrue: [ self updateButtonsFocus ].  self updateButtonsprimarySelectionInterval: arg1  primarySelectionInterval := arg1innerBounds  ^self brick innerBoundsbeDownward  self popupLayout: GLMPopupBrickDownwardLayout newrowHeightBlock  ^self parameters at: 'rowHeight' ifAbsent: [ self class defaultRowHeight ]activeOrigins  ^(self originReferences select: [:arg1 |  arg1 isActive ]) collect: [:arg1 |  arg1 port ]pane  self subclassResponsibilitytestCopyNotTheSameRegistry  | tmp1 tmp2 |  tmp1 := GLMPane new.  tmp2 := tmp1 copy.  self assert: tmp1 glmSubscriptions ~~ tmp2 glmSubscriptionsisEmpty  ^collection isEmptytestPresentationInitializationBlockIsCalled  | tmp1 tmp2 tmp3 |  tmp3 := 0.  tmp1 := GLMPane named: 'test'.  tmp2 := GLMPresentation new initialize: [:arg1 |  tmp3 := tmp3 + 1 ].  tmp1 addPresentation: tmp2.  self assert: tmp3 equals: 0.  tmp2 initializePresentation.  self assert: tmp3 equals: 1.  tmp2 initializePresentation.  self assert: tmp3 equals: 2data: arg1  data := arg1initialize  super initialize.  next := self.  previous := selftestModelInitialization  self assert: pagerModel size equals: 0.  self assert: pagerModel firstVisiblePageIndex equals: 0.  self assert: pagerModel lastVisiblePageIndex equals: 0.  self assert: pagerModel actualNumberOfVisiblePages equals: 0.  self assert: pagerModel numberOfVisiblePages equals: 2themer: arg1  self setProperty: #brickThemer toValue: arg1.  self brickRoot themerChangedbrick  ^brickasGlamorousPane  ^selfallDisplayedDo: arg1  self displayValue do: [:arg2 |  self withChildrenOf: arg2 do: arg1 ]resetDataCache  dataCache := nilupdateVisibleBottom: arg1  | tmp1 |  tmp1 := self band lastSubbrick.  [ tmp1 isNotNil and: [ (self isPartiallyVisible: tmp1) and: [ (self getIndex: tmp1) < self model count ] ] ] whileTrue: [ tmp1 := self addItemMorph: (self getMorphAt: (self getIndex: tmp1) + 1 recycled: (self getAndRemoveInvisibleMorph: arg1)) after: tmp1 ]outOfWorld: arg1  Morph announcer unsubscribe: self.  ^super outOfWorld: arg1maxDepth: arg1  self parameters at: 'maxDepth' put: arg1renderAction: arg1  ^GLMMorphicActionRenderer render: arg1 from: selfallSubbricks  | tmp1 |  tmp1 := OrderedCollection new.  self allSubbricksDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1dragSliding: arg1  | tmp1 tmp2 |  tmp1 := arg1 position x - self owner globalBounds left - startDragX.  tmp2 := self computeScrollValue: tmp1.  self scrollTo: tmp2.  self synchronizeScrollTo: tmp2simulateOnlyOneClickOn: arg1  arg1 simulateClickcontentBackgroundColor  ^Color whitetestExplicitTransmissionComplex  | tmp1 tmp2 |  tmp1 := GLMFinder new.  tmp1 transmit     fromOutsidePort: #entity;     toOutsidePort: #something.  tmp2 := GLMTabulator new.  tmp2     row: #explorer;     row: #details.  tmp2 transmit     to: #explorer;     andShow: [:arg1 |  arg1 custom: tmp1 ].  tmp2 transmit     from: #explorer port: #something;     to: #details;     andShow: [:arg1 |  arg1 text ].  tmp2 startOn: 42.  self assert: (tmp2 panes first port: #something) value equals: 42submorphBefore  ^self subbrickBeforeshadowColor  ^Color black alpha: 0.5delete  self model notNil ifTrue: [ self model unregisterFromAllAnnouncements ].  super deleteenlargeToLeft  self virtualFirstVisiblePageIndex: self firstVisiblePageIndex - 1.  self recomputeStatetitleValueOfColumn: arg1  ^arg1 title glamourValue: self entityappendVariableBinding: arg1  arg1 ifNotNil: [ arg1 do: [:arg2 |  self variableBindings add: (arg2 class = WorkspaceVariable ifTrue: [ arg2 ] ifFalse: [ WorkspaceVariable key: arg2 key value: arg2 value ]) ] ]pharoScript  ^self custom: GLMPharoScriptPresentation newrenderGlamorouslyOn: arg1  self deprecated: 'Use GLMRubricTextPresentation instead.'.  self registerAnnouncements.  ^arg1 renderTextPresentation: selftestSimpleEmptyPane  | tmp1 |  tmp1 := GLMPane new.  tmp1 browser: GLMBrowser new.  (tmp1 port: #entity) value: 42.  self assert: GLMLogger instance announcements size equals: 1.  self assert: (GLMLogger instance announcements first isKindOf: GLMContextChanged)actOnMatchingPresentationsChanged: arg1  paneMorph removeAllMorphs.  self renderMorphFor: arg1 pane.  self renderer window fullBoundsonCreated  self textEditBrick: self newTextEditFieldactOnCompileText: arg1  (arg1 session recompileMethodTo: arg1 presentation text inContext: arg1 context notifying: textMorph) ifTrue: [ arg1 action ifNotNil: [:arg2 |  arg2 value ] ]testSetup  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMExplicitBrowser new.  tmp2 := tmp1 addNewPane.  tmp3 := tmp1 addNewPane.  tmp4 := GLMTransmission new     addActiveOrigin: (tmp2 port: #selection);     destination: (tmp3 port: #entity);     yourself.  tmp1 addTransmission: tmp4.  self assert: tmp1 panes size equals: 2.  self assert: tmp1 transmissions size equals: 1.  self assert: tmp1 panes first identicalTo: tmp2.  self assert: tmp1 panes last identicalTo: tmp3.  self assert: tmp2 browser identicalTo: tmp1.  self assert: tmp3 browser identicalTo: tmp1.  self assert: tmp1 transmissions first identicalTo: tmp4testAddRaisesAnnouncement  | tmp1 tmp2 tmp3 |  tmp1 := GLMCompositePresentation new.  tmp3 := tmp1 pane.  tmp2 := 0.  tmp1 entity: 42.  tmp3 when: GLMMatchingPresentationsChanged do: [:arg1 |  tmp2 := tmp2 + 1 ].  tmp1 add: GLMPresentation new.  self assert: tmp2 equals: 1openInExternalWindow  ^self defaultRenderer openInExternalWindow: selfchildrenItems  ^OrderedCollection with: ((GLMExpanderContentsNodeModel with: self -> self item) containerNode: self)computeTagsFor: arg1  ^self computeTagsFor: arg1 from: self tagsBlockreadyToBeDisplayed  self glamourPresentation announcer announce: (GLMDataSourceUpdated newDataSource: self)enableFilter  self parameters at: 'isFilterable' put: truedoItReceiver  ^self glamourPresentation doItReceiverisPartiallyVisible: arg1  | tmp1 tmp2 |  tmp1 := (self allowedBounds withWidth: 1) translateBy: self allowedBounds origin negated x @ 0.  tmp2 := (arg1 globalBounds withWidth: 1) translateBy: arg1 globalBounds origin negated x @ 0.  ^tmp1 intersects: tmp2updateWidth: arg1 on: arg2  arg1 withWidth: (arg2 normalizeWidth: (arg2 widthChildrenDependency: arg1) of: arg1)showOnlyFinderBrowser  | tmp1 |  tmp1 := GLMFinder new.  tmp1 list     title: 'title';     display: [:arg1 |  1 to: arg1 ];     showOnly: 50.  ^tmp1pane  ^panecollect: arg1  ^self copy     presentations: (self presentations collect: arg1);     yourselfouterBounds  ^outerBounds ifNil: [ self updateCache.        outerBounds ]paddingTop  ^self brick paddingTopopenAt: arg1  < return: #GLMFoundationBrick>  | tmp1 |  tmp1 := self asBrickedMorph     vShrinkWrap;     hShrinkWrap;     position: arg1;     openInWorld.  self onOpened.  ^tmp1onParentDo: arg1  ^self on: #isOnParent do: arg1 ifAbsent: [ GLMBrickLayoutParentState new ]titleOrIconOf: arg1 in: arg2  ^arg1 hasTitleIcon ifTrue: [ | tmp1 |        tmp1 := GLMInteractableBrick new normalImage: arg1 titleIconValue.        tmp1 maxWidth: [ arg1 titleIconValue width * 2 ].        tmp1 hSpaceFill.        tmp1 vSpaceFill.        arg1 titleValue ifNotNil: [ tmp1 setBalloonText: arg1 titleValue maxLineLength: 100 ].        tmp1 ] ifFalse: [ arg1 titleValue ifNil: [ '' ] ]renderFinder: arg1  ^arg1 hasFixedSizePanes ifTrue: [ GLMMorphicFixedPanesFinderRenderer render: arg1 from: self ] ifFalse: [ GLMMorphicVariablePanesFinderRenderer render: arg1 from: self ]lastPane  self subbricksCount = 0 ifTrue: [ ^nil ].  ^self panes lastrenderBorderOf: arg1 on: arg2  | tmp1 tmp2 |  arg1 border renderBorderOf: arg1 on: arg2.  tmp1 := arg1 valueOfProperty: #brickMarkBorderColor ifAbsent: nil.  tmp2 := arg1 valueOfProperty: #brickMarkBorderWidth ifAbsent: nil.  tmp1 isNotNil & tmp2 isNotNil ifTrue: [ arg2 frameRectangle: arg1 brickBounds width: tmp2 color: tmp1 ]testSimpleRows  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 addRow: #first.  tmp1 addRow: #second.  self assert: tmp1 cell children size equals: 2.  self assert: tmp1 cell isColumn.  self assert: tmp1 cell children first isRowtestMinAndMaxHeightTwoParentDependenciesReverse  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := 20.  tmp5 := 60.  tmp1 := self newBrickWithStaticExtent.  tmp1 useVerticalLinearLayout.  tmp2 := self newBrickWithFullFill.  tmp2 vSpaceFill: 0.  tmp2 minHeight: tmp4.  tmp3 := self newBrickWithFullFill.  tmp3 maxHeight: tmp5.  tmp1 addAllBricks: {tmp2 .         tmp3}.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp2 extent equals: self staticWidth @ tmp4.  self assert: tmp3 extent equals: self staticWidth @ tmp5computeVertices  vector ifNil: [ ^self ].  vertices := Array streamContents: [:arg1 |  | tmp1 tmp2 |        tmp1 := vector.        tmp2 := origin.        arg1 nextPut: tmp2.        [ tmp1 next ~= vector ] whileTrue: [ tmp2 := tmp1 + tmp2.              arg1 nextPut: tmp2.              tmp1 := tmp1 next ] ]virtualLastVisiblePageIndex: arg1  virtualLastVisiblePageIndex := self normalizePaneIndex: arg1animatedObject  ^animatedObjectbeVertical  self isHorizontal: falsepressedColor: arg1  pressedColor := arg1fromValue  ^fromValue ifNil: [ fromValue := fromLogic brickValue: self animatedObject ]actionSelector  ^#popupActOn:from:variableBindings: arg1  variableBindings := arg1unregisterFromAllAnnouncements  self announcerObjects do: [:arg1 |  [ arg1 unsubscribe: self ] on: Error do: [:arg2 |  arg2 resume ] ]entity: arg1  (self pane port: #entity) value: arg1isDependsOnParent: arg1  ^(self stateOf: arg1) isOnParentopen: arg1 with: arg2  < return: #GLMFoundationBrick>  ^self subclassResponsibilitymarkDependent: arg1  arg1 isWidthDirty | arg1 isHeightDirty ifTrue: [ arg1 layout markDirty.        arg1 owner ifNotNil: [:arg2 |  arg2 isBrick ifTrue: [ arg2 layout markDirty ] ] ].  arg1 isWidthDirty ifTrue: [ self widthTraverser markDirtyAround: arg1 inContext: nil ].  arg1 isHeightDirty ifTrue: [ self heightTraverser markDirtyAround: arg1 inContext: nil ]testResettingTheSelection  | tmp1 tmp2 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text display: '123456789' ].  window := tmp1 openOn: 4.  tmp2 := tmp1 presentations first.  tmp2 selectionInterval: (2 to: 5).  tmp2 selectionInterval: nilroots: arg1  roots := arg1 asOrderedCollection collect: [:arg2 |  self nodeModelFor: arg2 ]receive: arg1 in: arg2  self subclassResponsibilityactOnContextChanged: arg1  arg1 property = #selection ifTrue: [ treeModel announcer suspendAll: self suspendedAnnouncements while: [ treeMorph model explicitSelection: arg1 value ] ]text: arg1  arg1 cull: self texttitleBrick  ^titleBrickpaddingRight  ^self padding at: Righttitle: arg1  title := arg1contentBrick: arg1  contentBrick := arg1.  self contentBrick     hSpaceFill;     vShrinkWrapselectionValue: arg1  selectionValue := arg1scrollTo: arg1  | tmp1 |  (self isVisible: arg1) ifTrue: [ ^self ].  tmp1 := self allowedBounds top - band globalBounds top - (arg1 globalBounds top - band globalBounds top).  tmp1 < 0 ifTrue: [ tmp1 := tmp1 + self allowedBounds height - arg1 height ].  self band translateY: tmp1.  self isBottomOverscrolled ifTrue: [ self moveBandBottom ].  self isTopOverscrolled ifTrue: [ self moveBandTop ].  self update.  self changedshouldUseCache: arg1  ^self parameters at: 'shouldUseCache' put: arg1onButtonSelected: arg1  GLMPagerPanePreviewMorph uniqueInstance showAt: (self buttons at: arg1 buttonModel index) globalBounds topCenter.  self pagerModel updatePreview: arg1 buttonModel indextestTreeAllowDeseletion  | tmp1 tmp2 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 list allowDeselection ].  window := tmp1 openOn: ($a to: $d).  tmp2 := self treeVisibleItems first.  self send: self tree mouseUpOnItem: tmp2.  self send: self tree mouseUpOnItem: tmp2.  self assert: (tmp1 panes first port: #selection) value isNilexecuteSearch  | tmp1 tmp2 |  tmp1 := OrderedCollection new.  roots do: [:arg1 |  tmp2 := self glamourPresentation searchStrategy value: self inputText value: arg1 item.        tmp2 ifTrue: [ tmp1 add: arg1 path ] ].  tmp1 isEmpty ifFalse: [ self selection: (MorphTreeMorphMultipleSelection new selectedNodePathList: tmp1) ] ifTrue: [ self selection: nil ]renderer  ^rendererpopupLayout: arg1  popupLayout := arg1.  self popupLayout build: self trigger: self triggerBrick content: self contentBrickcontentsMorph: arg1  contentsMorph := arg1spacing  ^spacingselectedPageIndex  ^selectedPageIndexshadowOffset  ^self valueOfProperty: #brickShadowOffset ifAbsentPut: [ 0 @ 0 ]action: arg1  action := arg1viewRowMorphForColumn: arg1 node: arg2 withIndex: arg3  ^(self valueFor: arg2 withIndex: arg3 in: arg1) asMorph asReadOnlyMorphselectedBehavior  ^self highlightSmalltalkContextrenderGlamorouslyOn: arg1  ^arg1 renderTabbedCompositePresentation: self compositetestScriptingDefaults  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 startOn: 42.  self assert: tmp1 panes size equals: 1.  self assert: tmp1 transmissions size equals: 1.  self assert: tmp1 transmissions first origins first equals: (tmp1 pane port: #entity).  self assert: tmp1 transmissions first destination equals: (tmp1 panes first port: #entity)testListDoubleClick  | tmp1 tmp2 tmp3 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 list ].  window := tmp1 openOn: ($a to: $d).  tmp2 := window submorphs last submorphs first submorphs first submorphs first submorphs first.  tmp3 := tmp2 scroller submorphs first.  self send: tmp2 mouseUpWithShift: false onItem: tmp3.  self send: tmp2 doubleClickWithShift: false onItem: tmp3.  self assert: (tmp1 panes first port: #strongSelection) value equals: $agatherInvisibleItems  ^self band subbricks select: [:arg1 |  (self isPartiallyVisible: arg1) not ]titleIcon  ^titleIcondisplay: arg1  self setProperty: #phlowDisplay toValue: arg1newTitleBrick  ^GLMLabelBrick new     text: self titleText;     padding: #(0 10);     width: [:arg1 |  arg1 approximateWidth ];     height: [:arg1 |  arg1 approximateHeight ]getIndex: arg1  ^arg1 valueOfProperty: #brickScrollListIndex ifAbsent: [  ]selectedText: arg1  (self pane port: #selectedText) value: arg1 copywithHeight: arg1  ^self brick withHeight: arg1selectNextTab  self selectedIndex: self selectedIndex \\ self tabs size + 1dynamicActionsOnSelection: arg1  selectionDynamicActionsBlock := arg1render: arg1 on: arg2  self renderShadowOf: arg1 on: arg2.  self renderBackground: arg1 on: arg2.  self renderBorder: arg1 on: arg2newEditBrick  ^GLMRubTextFieldBrick newfocusedMorphChanged: arg1 at: arg2  self assignFocusableMorph: arg1 withPaneAt: arg2.  focusedPageIndex = arg2 ifFalse: [ focusedPageIndex := arg2.        self notifyFocusedPageChanged ]allKeystrokeActions  ^self glamourPresentation allActions , self glamourPresentation allSelectionActions select: [:arg1 |  arg1 hasShortcut ]action  ^actiontestCopyAnnouncementsDoNotRaise  | tmp1 tmp2 |  tmp1 := GLMPresentation new.  tmp1 when: GLMContextChanged do: [:arg1 |  self fail ].  self assert: tmp1 numberOfSubscriptions equals: 1.  tmp2 := tmp1 copy.  tmp2 announce: GLMContextChanged.  self assert: tmp2 numberOfSubscriptions equals: 0port: arg1  ^ports detect: [:arg2 |  arg2 name = arg1 ] ifNone: [ ports addLast: (self class portClass new                 pane: self;                 name: arg1;                 yourself) ]onThemerChanged  super onThemerChanged.  self updateStylebottomRightCornerShadowOf: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := arg1 shadowWidth.  tmp4 := (tmp2 @ tmp2) negated / 2.0.  tmp3 := arg1 brickBounds bottomRight + tmp4 + arg1 shadowOffset.  tmp1 := (self shadowGradientFor: arg1)     origin: tmp3;     direction: tmp2 @ tmp2 / 1.4;     radial: true;     yourself.  arg2 fillRectangle: (tmp3 extent: tmp2 @ tmp2) fillStyle: tmp1normalLabel  ^normalLabelshouldUseCache: arg1  ^self parameters at: 'shouldUseCache' put: arg1window  ^self class environment at: #GLMWindowBrick ifPresent: [:arg1 |  (self ownerThatIsA: arg1) ifNil: [ self ownerThatIsA: SystemWindow ] ] ifAbsent: [ self ownerThatIsA: SystemWindow ]testDefault  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 startOn: #(1 2 3).  self assert: (tmp1 panes first presentations first isKindOf: GLMFlexiblePresentation).  tmp1 startOn: 1.  self assert: (tmp1 panes first presentations first isKindOf: GLMFlexiblePresentation)text: arg1  self rubric updateTextWith: arg1basicElements  ^self glamourPresentation displayValuebuild: arg1 trigger: arg2 content: arg3  arg1 removeAllBricks.  arg1 triggerBrick: arg2.  arg1 contentBrick: arg3isScrollMustBeChecked: arg1 withLeft: arg2 andRight: arg3  | tmp1 |  tmp1 := self buttonCenterByIndex: arg1.  ^arg2 <= tmp1 & (arg3 > tmp1)popPane: arg1  (arg1 not or: [ self lastPane isNil ]) ifTrue: [ ^self popPane ].  self band doNotLayoutDuring: [:arg2 |  arg2 removeBrick: arg2 lastSubbrick ].  self scrollTo: (pagerModel convertIndexToValue: pagerModel firstVisiblePageIndex with: self band subbricksCount) smooth: arg1 callback: [ self doLayoutForce ]silver  ^Color brickColorRegistry at: #brickSilver ifAbsentPut: [ Color r: 189 g: 195 b: 199 range: 255 ]mouseDown: arg1  | tmp1 |  self isDoubleClickEnabled ifFalse: [ super mouseDown: arg1.        ^self press ].  tmp1 := Array with: #click: with: #doubleClick: with: #singleClick: with: nil.  arg1 hand waitForClicksOrDrag: self event: arg1 selectors: tmp1 threshold: 10hasFilterBlock  ^self parameters at: 'filterBlock' ifPresent: [ true ] ifAbsent: [ false ]spotterThemer  ^self registerModule: GTSpotterWidgetDarkThemer new to: GTSpotterBrickDarkThemer newassertBrickClean: arg1  self assertWidthClean: arg1.  self assertHeightClean: arg1render: arg1  arg1 when: GLMMatchingPresentationsChanged send: #actOnMatchingPresentationsChanged: to: selfcacheAt: arg1 for: arg2 ifAbsentPut: arg3  | tmp1 |  self shouldUseCache ifFalse: [ ^arg3 value ].  tmp1 := self dataCacheFor: arg2.  (tmp1 includesKey: arg1) ifTrue: [ ^tmp1 at: arg1 ].  ^arg3 value ifNotNil: [:arg4 |  tmp1 at: arg1 ifAbsentPut: [ arg4 ] ]initialize  super initialize.  self     vShrinkWrap;     hShrinkWraptestValidatePorts  | tmp1 tmp2 |  tmp1 := GLMPane named: 'test'.  tmp2 := GLMListPresentation new.  tmp1 addPresentation: tmp2.  tmp2 shouldValidate: true.  tmp2 entity: #(1 2).  tmp2 selection: 2.  self assert: tmp2 selection equals: 2.  tmp2 selection: 3.  self assert: tmp2 selection equals: 2updateHeight: arg1 on: arg2  arg1 outerHeight: (arg2 normalizeHeight: (arg2 heightParentDependency: arg1) of: arg1)scrollTo: arg1  | tmp1 tmp2 |  self band doNotLayoutDuring: [ self band removeAllBricks ].  self moveBandTop.  visibleIndex := nil.  self model count > 0 ifTrue: [ tmp2 := (arg1 max: 1) min: self model count.        tmp1 := self getMorphAt: tmp2 recycled: nil.        tmp1 withWidth: self band width.        tmp1 doLayout.        tmp1 brickBounds: (0 @ (0 max: (self height - tmp1 height) / 2) extent: tmp1 extent).        self addBrickBackNoLayout: tmp1 ].  self update.  self changedworkspaceBindingsStrategy  ^[:arg1 :arg2 :arg3 |  (arg3 doItReceiver class allInstVarNames includes: arg2) ifTrue: [ nil ] ifFalse: [ (arg1 includesKey: arg2) ifFalse: [ arg1 add: (WorkspaceVariable key: arg2 asSymbol) ].        arg1 associationAt: arg2 ] ]pressedImage  ^pressedImagerowHeightBlock  ^self parameters at: 'rowHeight' ifAbsent: [ self class defaultRowHeight ]select: arg1  super select: arg1.  self box select: arg1.  self label select: arg1rightAngle: arg1  ^self direction rightAngle: arg1 directionshadowWidth  ^self valueOfProperty: #brickShadowWidth ifAbsentPut: [ 0 ]postCopy  super postCopy.  registry := registry copyfocusedViewAt: arg1  ^focusedViews at: arg1 ifAbsent: [ nil ]transmit  ^self addTransmission: (GLMTransmission new           browser: self;           yourself)setCursorToNormal: arg1  arg1 hand showTemporaryCursor: nilcontext  ^contextonOpened  testStatusbarTransmissionsTriggered  | tmp1 tmp2 |  tmp1 := GLMTabulator new.  tmp1 addStatusbar.  self assert: tmp1 statusbarPane notNil.  self assert: tmp1 statusbarPane ~= tmp1.  tmp2 := (GLMPane in: tmp1) name: #one.  tmp1 addPane: tmp2.  self assert: tmp1 transmissions size equals: 1.  (tmp2 port: #status) value: #test.  self assert: tmp1 statusbarPane ~= tmp1.  self assert: (tmp1 statusbarPane port: #entity) value equals: #test.  self assert: tmp1 statusbarPane presentations size equals: 1.  self assert: (tmp1 statusbarPane presentations first isKindOf: GLMLabelPresentation)isFullyVisible  self band hasSubbricks ifFalse: [ ^true ].  ^self isLastAdded & self isFirstAdded & super isFullyVisibleonChildrenLayouted  super onChildrenLayouted.  self translateXTo: self leftPositionprivateExtent: arg1  super extent: arg1shouldLayoutMorphs  ^shouldLayoutMorphs ifNil: [ shouldLayoutMorphs := false ]helpMessage: arg1  helpMessage := arg1updateStyle  self color: self scrollpaneBackgroundColorlabel: arg1  self label: arg1 selected: arg1position: arg1  self translateBy: arg1 asNonFractionalPoint - self brickBounds topLeftscrollbarOffset  ^self valueOfProperty: #brickScrollbarOffset ifAbsent: [ self themer scrollbarOffset ]buttonMorph: arg1  ^UITheme current newButtonIn: nil for: arg1 getState: nil action: #execute arguments: nil getEnabled: nil label: arg1 buttonLabel help: nilenableFilterWithAction: arg1 named: arg2  self enableFilter.  self parameters     at: 'actionBlock' put: arg1;     at: 'actionName' put: arg2testInitializeBlockSetsTextSelectionForTextPresentation  self checkInitializeBlockSetsTextSelectionForPresentation: #textrenderGlamorouslyOn: arg1  ^arg1 renderPager: selftestRightMarginParentDependency  | tmp1 tmp2 tmp3 |  tmp2 := 10.  tmp1 := self newBrickWithStaticExtent.  tmp3 := self newBrickFullHeightAndWidthDependsOnParent: 100.  tmp3 marginRight: tmp2.  tmp1 addBrickBack: tmp3.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp3 extent equals: self staticExtent - (tmp2 @ 0).  self assert: tmp3 brickBounds equals: (0 @ 0 corner: self staticExtent - (tmp2 @ 0))newButton  ^GLMButtonBrick new margin: #(3 0)testStartTransmission  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list ].  self assert: tmp1 transmissions size equals: 1.  self assertEmpty: (tmp1 paneNamed: #one) presentations.  self assertEmpty: (tmp1 paneNamed: #two) presentations.  tmp1 startOn: 15.  self assert: (tmp1 paneNamed: #one) presentations size equals: 1.  self assertEmpty: (tmp1 paneNamed: #two) presentationscolumn: arg1 evaluated: arg2  self column: arg1 evaluated: arg2 styled: nildrawSubmorphsOnAthensCanvas: arg1  | tmp1 tmp2 |  self submorphs isEmpty ifTrue: [ ^self ].  tmp1 := arg1 clipRect intersect: self globalInnerBounds ifNone: (0 @ 0 extent: 0 @ 0).  tmp1 width = 0 | (tmp1 height = 0) ifTrue: [ ^self ].  tmp2 := OrderedCollection new.  self subbricks do: [:arg2 |  | tmp3 tmp4 |        arg2 ifNotNil: [ self flag: 'fix nil case'.              tmp4 := arg2 isBrick ifTrue: [ arg2 globalBounds ] ifFalse: [ arg2 fullBounds ].              (tmp1 intersects: tmp4) ifTrue: [ | tmp5 |                    tmp5 := arg2 layoutProperties zIndex brickValue: arg2.                    tmp5 = 1 ifTrue: [ tmp3 := tmp1 intersect: tmp4 ifNone: (0 @ 0 extent: 0 @ 0).                          arg1 clipBy: tmp3 during: [ arg2 fullDrawOnAthensCanvas: arg1 ] ] ifFalse: [ tmp2 add: arg2 ] ] ] ].  tmp2 sort: [:arg3 :arg4 |  (arg3 layoutProperties zIndex brickValue: arg3) < (arg4 layoutProperties zIndex brickValue: arg4) ].  tmp2 do: [:arg2 |  | tmp3 tmp4 |        arg2 ifNotNil: [ self flag: 'fix nil case'.              tmp4 := arg2 isBrick ifTrue: [ arg2 globalBounds ] ifFalse: [ arg2 fullBounds ].              tmp3 := tmp1 intersect: tmp4 ifNone: (0 @ 0 extent: 0 @ 0).              arg1 clipBy: tmp3 during: [ arg2 fullDrawOnAthensCanvas: arg1 ] ] ]renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderListPresentation: selftestAddTransmissionReturn  | tmp1 |  tmp1 := GLMTransmission new.  self assert: (GLMExplicitBrowser new addTransmission: tmp1) identicalTo: tmp1predicate: arg1  predicates add: arg1initialize  super initialize.  self     enable;     labelBrick: self newLabelBrick;     hShrinkWrap;     vShrinkWraporiginMorphFor: arg1  (arg1 textArea hasSelection not and: [ arg1 textArea hasHighlightSegment ]) ifTrue: [ ^arg1 textArea getHighlightSegment ].  ^arg1 textArea cursorprivateInvalidateMorph: arg1  selectItem  self containerTree explicitlySelectItem: self itemkeyboardFocusChange: arg1  super keyboardFocusChange: arg1.  self focusChangedtextEditBrick: arg1  textEditBrick := arg1.  self contentBrick addBrickBack: self textEditBrick.  self textEditBrick rubric announcer when: RubTextAcceptRequest send: #acceptContents: to: selfvalue  ^valuedropOnItem: arg1  dropOnItemBlock := arg1row: arg1  ^self addRow: arg1allKeystrokeActions  ^self glamourPresentation allActions , self glamourPresentation allSelectionActions select: [:arg1 |  arg1 hasShortcut ]vSpaceFill: arg1  super vSpaceFill: arg1.  vResizing := #spaceFillactOnPresentationUpdated: arg1  container removeAllMorphs.  container addMorphBack: (self morphFrom: arg1 presentation)animationStep  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self needsStep: false.  tmp3 := Time millisecondClockValue.  tmp4 := tmp3 >= self finishTime.  tmp1 := self duration = 0 ifTrue: [ 1 ] ifFalse: [ (tmp3 - startTime min: self duration) / self duration ].  tmp1 = 1 ifTrue: [ tmp4 := true ].  tmp2 := stepLogic brickValue: self animatedObject withEnoughArguments: {self fromValue .         self toValue .         tmp1}.  tmp1 = 1 | (tmp2 = self toValue) ifTrue: [ tmp4 := true ].  tmp5 := stamp.  UIManager default defer: [ self asyncTask isTerminated not & (tmp5 = stamp) ifTrue: [ steppedLogic brickValue: self animatedObject withEnoughArguments: {tmp1}.              animationLogic brickValue: self animatedObject withEnoughArguments: {tmp2}.              tmp4 ifFalse: [ self needsStep: true.                    self asyncTask resume ] ifTrue: [ self shouldStop: true.                    self asyncTask resume ] ] ].  self asyncTask pauseactionArguments  ^nilcut  self announce: (GLMTextEditorRequest for: #cut)containerNode: arg1  containerNode := arg1value: arg1  value := arg1isRow  ^falsehasBindingThatBeginsWith: arg1  ^self variableBindings keys anySatisfy: [:arg2 |  arg2 beginsWith: arg1 ]normalLabel: arg1  normalLabel := arg1openSettingsBrowser  self class openSettingsBrowsertestSelectionActions  | tmp1 |  tmp1 := GLMPresentation new.  tmp1 selectionActions isEmpty.  tmp1 addSelectionAction: GLMAction new.  self assert: tmp1 selectionActions size equals: 1end: arg1  end := arg1text: arg1  < brickBuilderProperty: #Text name: 'Text' as: #asString getter: #text model: #GLMUIBuilderTextFieldProperty>  self label text: arg1.  self wrappedBounds markWidthDirty.  self doLayouttestTransmissionBundle  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := GLMExplicitBrowser new.  tmp5 := GLMPresentation new.  tmp6 := GLMPresentation new.  tmp2 := GLMTestPane new.  tmp3 := GLMTestPane new.  tmp4 := GLMTestPane new.  tmp2 addPresentation: GLMPresentation new.  tmp3 addPresentation: GLMPresentation new.  tmp4 addPresentation: tmp5.  tmp7 := GLMTransmission new     ensureReplacePresentationsStrategy;     addActiveOrigin: (tmp2 port: #selection);     addPassiveOrigin: (tmp3 port: #selection);     destination: (tmp4 port: #entity);     addPresentation: tmp6;     yourself.  tmp1 addPane: tmp2.  tmp1 addPane: tmp3.  tmp1 addPane: tmp4.  tmp1 addTransmission: tmp7.  self assert: tmp4 presentations size equals: 1.  self assert: tmp4 presentations first identicalTo: tmp5.  tmp3 presentations first selection: #foo.  self assert: (tmp3 port: #selection) seenTransmissions size equals: 1.  self assert: (tmp4 port: #entity) seenTransmissions size equals: 0.  tmp2 presentations first selection: #bar.  self assert: (tmp2 port: #selection) seenTransmissions size equals: 1.  self assert: (tmp4 port: #entity) seenTransmissions size equals: 1.  self assert: (tmp4 port: #entity) seenTransmissions last identicalTo: tmp7.  self assert: (tmp4 port: #entity) value equals: (GLMMultiValue withAll: #(#bar #foo)).  self assert: tmp4 presentations size equals: 1.  self assert: tmp4 presentations first rootPrototype equals: tmp6strongSelectionValue  ^strongSelectionValuerowMorphForColumn: arg1  | tmp1 tmp2 tmp3 |  arg1 modifiedBlock ifNil: [ tmp2 := (self containerTree glamourPresentation column: arg1 valueFor: self item) asMorph asReadOnlyMorph ] ifNotNil: [ tmp2 := GLMEditableLabelBrick new           cancelOnEscape;           cancelOnFocusLost;           text: (self valueFor: arg1);           hSpaceFill;           with: [:arg2 |  arg2 editBrick rubricBackgroundColor: arg2 themer rubricBackgroundColor ];           when: #onEditMode do: [ self containerTree forceStopStepping ];           when: #onReadMode do: [ self containerTree resetStopStepping ];           when: #onSingleClicked do: [:arg3 :arg4 |  arg4 isReadMode ifTrue: [ (arg4 ownerThatIsA: GLMPaginatedResizableMorphTreeMorph) listManager mouseUp: arg3 on: arg4 owner owner owner ] ];           when: #onAccepted do: [ self modified: arg1 with: tmp2 text ];           yourself.        tmp2 := tmp2 asMorph           hSpaceFill;           vShrinkWrap ].  tmp3 := self tagMorphsFrom: arg1.  tmp3 ifEmpty: [ ^tmp2 ].  tmp1 := OrderedCollection new     add: tmp2;     addAll: tmp3;     yourself.  ^UITheme current newRowIn: self currentWorld for: tmp1inputText  ^inputText ifNil: [ inputText := '' ]fromOutsidePort: arg1  ^self from: #outer -> arg1initialExtent  ^initialExtent ifNil: [ initialExtent := RealEstateAgent standardWindowExtent ]dropDownList  ^self custom: GLMDropDownListPresentation newcomputeBounds  duration: arg1  duration := arg1totalScrollRange  | tmp1 |  tmp1 := transform localSubmorphBounds ifNil: [ ^0 ].  ^tmp1 widthmarkLayoutDirty: arg1  arg1 ifNotNil: [:arg2 |  arg2 isBrick ifTrue: [ arg2 markLayoutDirty ] ]titleFor: arg1  ^arg1 titleValue ifNil: [ 'Glamorous Browser' ]smalltalkClass: arg1  highlightSmalltalkContext := arg1margin  ^margin ifNil: [ margin := Array braceWith: 0 with: 0 with: 0 with: 0 ]wantsSteps: arg1  wantsSteps := arg1hSpaceFill: arg1  super hSpaceFill: arg1.  self label hSpaceFillpaddingRight: arg1  self padding at: Right put: arg1.  self updateCacheinstallEntity  self textBrick model: self.  self textBrick classOrMetaClass: (self smalltalkClassLogic phlowValue: self entity).  self textBrick setTextWith: (self displayLogic phlowValue: self entity).  self textBrick selectionInterval: (self selectionInterval phlowValue: self entity)openCenteredInBrickWindowLabeled: arg1  self     vAlign: #center;     hAlign: #center;     openInBrickWindowLabeled: arg1testUpdateYourselfOn  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := Announcer new.  tmp2 := OrderedCollection with: 1 with: 2 with: 3.  tmp3 := GLMTabulator new.  tmp3 column: #one.  tmp3 transmit     to: #one;     andShow: [:arg1 |  tmp4 := arg1 list           updateOn: GLMTestAnnouncement from: [ tmp1 ];           shouldValidate: true ].  tmp3 startOn: tmp2.  tmp4 registerAnnouncements.  tmp4 selection: 3.  tmp2 removeLast.  tmp1 announce: GLMTestAnnouncement.  self assert: tmp4 selection isNilreceive: arg1 in: arg2  self value: arg1 value in: arg2children: arg1  children := arg1brick: arg1  brick := arg1showOrHideScrollBar  self pagerModel size > self pagerModel minimumPageNumberForScrollbar & self showScrollBarWhenNeeded ifTrue: [ (self hasSubbrick: self pagerBar) ifFalse: [ self addBrickBack: self pagerBar ] ] ifFalse: [ self removeBrick: self pagerBar ]custom: arg1  self flag: 'for now we only allow one subbrick in the composite.	We have to revisit this implementation after the composite will allow for multiple subbricks'.  self hasSubbricks ifFalse: [ self addBrickBack: arg1 ].  ^arg1withAllPresentations  | tmp1 |  tmp1 := OrderedCollection new.  self withAllPanesAndPresentationsDo: [:arg1 |  (arg1 isKindOf: GLMPresentation) ifTrue: [ tmp1 add: arg1 ] ].  ^tmp1markHeightDirty  ^self brick wrappedBounds markHeightDirtyvSpaceFill: arg1  super vSpaceFill: arg1.  self isCentered ifTrue: [ self beCentered ]intercellSpacing  ^self parameters at: 'intercellSpacing' ifAbsent: [ self class defaultIntercellSpacing ]initialize  super initialize.  self     useVerticalLinearLayout;     vShrinkWrapopenBelow: arg1  ^self openAt: arg1 originhasMaxDimensionRestriction: arg1  ^arg1 layout hasMaxWidthselectionAct: arg1 iconName: arg2 entitled: arg3  self selectionAct: arg1 icon: (self iconNamed: arg2) entitled: arg3paddingTop  ^self padding at: TopisHShrinking  ^hResizing = #shrinkWrapdynamic  ^self custom: GLMDynamicPresentation newdeselect: arg1  super deselect: arg1.  unhoverAction ifNotNil: [:arg2 |  arg2 brickValue: self withEnoughArguments: {arg1} ]testAccordionExpanded  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 accordionArrangement.        arg1 list title: 'List'.        arg1 text title: 'Text' ].  window := tmp1 openOn: 42.  self assert: self compositePanel submorphs first expanded.  self assert: self compositePanel submorphs last expanded notvalue  < debuggingStone: #transmissionTransformation label: 'Transmission transformation'>  | tmp1 |  tmp1 := self originReferences size = 1 ifTrue: [ self originReferences first value ] ifFalse: [ GLMMultiValue withAll: (self originReferences collect: [:arg1 |  arg1 value ]) ].  ^self transformation ifNil: [ tmp1 ] ifNotNil: [ self transformation glamourValue: tmp1 asGlamorousMultiValue , self origins asGlamorousMultiValue ]morphFrom: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self rectangleMorphFrom: arg1.  arg1 allActions do: [:arg2 |  tmp2 := GLMButtonModel new.        tmp2 glamourPresentation: arg1.        tmp2 glamourAction: arg2.        tmp3 := self buttonMorph: tmp2.        tmp1 addMorphBack: tmp3.        tmp3 width: self class defaultWidth ].  ^tmp1layoutBounds: arg1  seenTransmissions  ^seenTransmissions ifNil: [ seenTransmissions := OrderedCollection new ]shadowWidth  ^0entity: arg1  entity := arg1.  self initializeColumnsdisplay: arg1  self setProperty: #phlowDisplay toValue: arg1updatePageAtIndex: arg1 withLabel: arg2 toolbar: arg3 action: arg4  (self pages at: arg1) toolbar: arg3.  self relabelPage: (self pages at: arg1) with: (self buildLabelFrom: arg2 withAction: arg4).  self tabSelectorMorph selectedIndex = arg1 ifTrue: [ self updatePageIndex: arg1 ]enable  isEnabled := trueacceptContents: arg1  self flag: #TODO.  self model ifNotNil: [:arg2 |  arg2 acceptContents: arg1 ]postCopy  ports := ports copyresetContents  contents := nilact: arg1 iconName: arg2 on: arg3 entitled: arg4  self act: arg1 icon: (self iconNamed: arg2) on: arg3 entitled: arg4elementsSorted  elements ifNil: [ ^nil ].  ^columnToSortBy ifNotNil: [ elements sorted: self sortBlock ] ifNil: [ self calculateElements ]defaultStyler  ^nilbrickBounds: arg1  bounds := arg1 ceiling.  self updateCachehelp  ^helprubricBorderColor: arg1  self setProperty: #brickRubricBorderColor toValue: arg1.  self updateStyledefaultNumberOfVisiblePages: arg1  self size = 0 ifFalse: [ GLMPagerException signal: 'You can change default number of visible pages only when there is no pages' ].  numberOfVisiblePages := arg1updateWithString: arg1 from: arg2  textMorph textArea     updateTextWith: arg1;     takeKeyboardFocus;     on: Character escape do: [ self delete.        arg2 textArea removeHighlightSegment.        arg2 takeKeyboardFocus ];     on: PharoShortcuts current cancelShortcut do: [ self delete.        arg2 textArea editor cancel.        arg2 takeKeyboardFocus ];     on: Character backspace do: [ self delete.        arg2 textArea removeHighlightSegment.        arg2 takeKeyboardFocus ];     onAnnouncement: MorphLostFocus do: [:arg3 |  self delete.        arg2 textArea removeHighlightSegment ]receive: arg1  self receive: arg1 in: GLMTransmissionContext newinitialize  super initialize.  self     useVerticalLinearLayout;     bar: self newBarhState  ^hStateouterPortEvent: arg1  | tmp1 |  super outerPortEvent: arg1.  arg1 port name = #entity ifFalse: [ ^self ].  self panes isEmpty ifFalse: [ tmp1 := self panes first.        panes := nil.        self addPaneFromOuter: arg1 port.        self announce: (GLMPaneReplaced oldPane: tmp1 newPane: self panes first fromBrowser: self) ] ifTrue: [ self addPaneFromOuter: arg1 port.        self announce: (GLMPaneAdded pane: self panes last atPosition: self panes size inBrowser: self) ]shouldDoStep  ^self glamourPresentation stepCondition cull: selfinitialize  super initialize.  parameters := Dictionary newisFitsInParent  ^self owner ifNil: [ self brickBounds containsRect: (self outerBounds origin extent: self textSize) ] ifNotNil: [ self owner brickBounds width >= self textSize x ]isDependenciesShown: arg1  isDependenciesShown := arg1labelMorph: arg1  labelMorph := arg1open  ^self openWith: self defaultRendereraddFastTableIn: arg1  arg1 addMorphBack: tableMorphupdateHeight: arg1 on: arg2  arg1 withHeight: (arg2 normalizeHeight: (arg2 heightChildrenDependency: arg1) of: arg1)checkboxCheckedImage  ^GLMUIThemeExtraIcons glamorousAccepthasFixedSizePanes  ^hasFixedSizePanes ifNil: [ hasFixedSizePanes := true ]isSingle  ^self isMultiple notinstallDefaultSelectionActions  self defaultSelectionActions do: [:arg1 |  self addSelectionAction: arg1 ]testCachedMatchingPresentations  | tmp1 tmp2 |  tmp1 := GLMPane in: nil.  tmp2 := tmp1 cachedMatchingPresentations.  self assert: tmp2 identicalTo: tmp1 cachedMatchingPresentations.  tmp1 matchingPresentations.  self assert: tmp2 ~~ tmp1 cachedMatchingPresentationssettingsButtonBrick  ^settingsButtonBrickaddVariableBindingsOn: arg1 from: arg2  arg2 variableBindings do: [:arg3 |  arg1 addVariableBinding: arg3 ]initialize  super initialize.  self     hShrinkWrap;     vShrinkWrap;     enableevaluateAndPrintSelection  UIManager default defer: [ textMorph printIt ]height: arg1  < brickBuilderProperty: #Geometry name: 'Height' as: #asInteger getter: #height model: #GLMUIBuilderTextFieldProperty>  self privateHeight: arg1.  self updateHeightisWidthClean  ^self widthState = #cleanwidthRight: arg1  self width at: Right put: arg1perform: arg1 delay: arg2 priority: arg3  self execute: [  ] withArguments: {} callback: arg1 priority: arg3 delay: arg2testCompositeWithinCompositePanePropagation  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := GLMCompositePresentation new.  tmp2 := GLMCompositePresentation new.  tmp3 := GLMCompositePresentation new.  tmp4 := GLMCompositePresentation new.  tmp3 add: GLMPresentation new.  tmp2 add: tmp3.  tmp4 add: GLMPresentation new.  tmp2 add: tmp4.  tmp1 add: tmp2.  tmp5 := GLMPane new.  tmp5 presentations: tmp1.  self assert: tmp1 first first first pane equals: tmp5.  self assert: (tmp1 first at: 2) pane equals: tmp5.  self assert: tmp1 first first first pane equals: tmp5.  self assert: (tmp1 first at: 2) first pane equals: tmp5rowHeight: arg1  self parameters at: 'rowHeight' put: arg1presentation: arg1  presentation := arg1model: arg1  model := arg1testResettingTheSelection  | tmp1 tmp2 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text display: '123456789' ].  window := tmp1 openOn: 4.  tmp2 := tmp1 presentations first.  tmp2 selectionInterval: (2 to: 5).  self shouldnt: [ tmp2 selectionInterval: nil ] raise: ErrortestDefault  | tmp1 tmp2 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 pharoScript display: '123456789' ].  window := tmp1 openOn: 4.  tmp2 := window submorphs last submorphs first submorphs first.  self assert: (tmp2 isKindOf: RubScrolledTextMorph)showScrollBar  self scrollBarIsVisible ifTrue: [ ^self ].  self resizeScrollBar.  self addMorphFront: scrollBar.  self adjustPaneHeightmorphicAct: arg1 on: arg2 icon: arg3 entitled: arg4  self addAction: (GLMMorphicAction new           action: arg1;           shortcut: arg2;           icon: arg3;           title: arg4;           yourself)selection: arg1  (self pane port: #rawSelection) value: arg1.  self acceptsSelection ifFalse: [ ^self ].  rawSelectionTransmissions do: #transmitnewCheckbox  ^GLMCheckboxBrick new margin: #(3 0)addPresentations: arg1  textModel  ^textModel ifNil: [ textModel := '' ]onResized  self setWidthAfterResizingshouldShowTitle  ^shouldShowTitle ifNil: [ shouldShowTitle := false ]displayValue  ^columnToSortBy ifNil: [ self glamourPresentation displayValue ] ifNotNil: [ self glamourPresentation displayValue sorted: self sortBlock ]evaluateSelectionAndDo: arg1  self announce: (GLMEvaluateSelection new action: arg1)hideHeader  shouldShowHeader := falsedeselect  super deselect.  self announcer announce: (GLMPagerButtonDeselected new buttonModel: self)fullDrawOn: arg1  super fullDrawOn: (arg1 copyClipRect: self fullBounds)renderTextPresentation: arg1  ^GLMMorphicTextRenderer render: arg1 from: selftestMarkerOneParentInParentHeight  | tmp1 tmp2 |  tmp1 := self newBrickWithFullFill.  tmp2 := self newBrickWithFullFill.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthClean.  self assert: tmp2 wrappedBounds isHeightDirty.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightCleanannounce: arg1  self announcer announce: arg1scrollpaneBackgroundColor  ^self valueOfProperty: #brickScrollpaneBackgroundColor ifAbsent: [ self themer scrollpaneBackgroundColor ]hintBrick  ^hintBricknotifyPagePoppedAndReplaced: arg1  self notifyAll: (GLMPagePopedAndReplaced new brick: arg1)onChildrenLayouted  super onChildrenLayouted.  self band translateY: self scrollPositionTopdefaultRenderer  ^GLMRenderer subclasses first newsubmit  ^self addBrickBack: (self newButton           text: 'Submit';           when: #onClicked do: [ self submitForm ])smalltalkCode  self deprecated: 'Use #pharoMethod (if you need to display a method) 	or #pharoScript (if you need to display snippets of code that do not belong to a method)'.  ^self custom: GLMSmalltalkCodePresentation newdisplayText  ^UITheme current newTextIn: self currentWorld text: (self item presentations titleValue ifNil: [ 'noname' ])hoverIcon: arg1  self selectedImage: arg1.  self doLayoutForceinitialize  super initialize.  self initializeTextMorphaccordionArrangement  ^self arrangement: GLMAccordionArrangement newglobalBoundsTranslateFactor  ^self owner ifNotNil: [ self owner globalBoundsTranslateFactor + self brickBounds origin ] ifNil: [ 0 @ 0 ]dragPassengerFor: arg1 inMorph: arg2  ^self glamourPresentation transformedDraggedItem: arg1 complexContents itemsmooth  ^smoothto: arg1 port: arg2  ^self to: (GLMPortIdentifier pane: arg1 port: arg2)brickBounds: arg1  ^self brick brickBounds: arg1initialize  announcements := OrderedCollection newnotifyAll: arg1  self isNotificationsAllowed ifTrue: [ self announcer announce: arg1 ]textPosition  ^textPositionnotifyPagePoped: arg1  self notifyAll: (GLMPagePoped new smooth: arg1)normalBorderStyleFor: arg1  ^BorderStyle simple     width: 1;     baseColor: Color transparentrenderListPresentation: arg1  ^GLMMorphicListRenderer render: arg1 from: selfgetText  ^self displayLogic phlowValue: self entityhasShortcut  ^self keymap notNilprivateAddBrick: arg1 after: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := arg1 asBrick.  tmp3 := arg2 brickDoubleLink.  tmp3 = self lastSubbrick brickDoubleLink ifTrue: [ ^self privateAddBrickBack: arg1 ].  tmp2 := tmp1 asDoubleLink.  tmp1 brickDoubleLink: tmp2.  tmp4 := tmp3 nextLink.  tmp3 nextLink: tmp2.  tmp2 previousLink: tmp3.  tmp2 nextLink: tmp4.  tmp4 previousLink: tmp2.  tmp5 := (self subbricks indexOf: arg2) + 1.  self privateSubbricks: (self subbricks copyReplaceFrom: tmp5 to: tmp5 - 1 with: (Array with: tmp1)).  tmp1 owner: self.  ^arg1testFromPort  browser transmit from: #one port: #port.  self assert: browser transmissions first origins first pane equals: browser panes first.  self assert: browser transmissions first origins first name equals: #portinitialize  super initialize.  self themer: self themer actionThemer.  onCreatedBlock := [  ]last  ^self presentations lastupdateToolbar  self announce: (GLMPresentationToolbarUpdated new presentation: self presentations)vShrinkWrap  self vResizing: #rigid.  self height: #approximateHeightresetData  list := nil.  selectionIndex := niltestUpdateOnFromAllPortsUpdate  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := (1 to: 4) asOrderedCollection.  tmp1 := GLMPane named: 'test'.  tmp2 := GLMListPresentation new.  tmp3 := tmp4 collect: [:arg1 |  Announcer new ].  tmp1 addPresentation: tmp2.  tmp2 updateOn: GLMTestAnnouncement fromAll: [ tmp3 ].  tmp2 when: GLMPresentationUpdated do: [:arg2 |  tmp5 := true ].  tmp2 entity: tmp4.  tmp2 shouldValidate: true.  tmp2 registerAnnouncements.  tmp5 := false.  tmp3 last announce: GLMTestAnnouncement.  self assert: tmp5.  tmp5 := false.  tmp3 last announce: GLMTestAnnouncement.  self assert: tmp5enableFilter: arg1  self enableFilter.  self parameters at: 'filterBlock' put: arg1initializeShortcuts  self bindKeyCombination: Character arrowLeft alt command toAction: [ self pagerModel selectToLeft ].  self bindKeyCombination: Character arrowRight alt command toAction: [ self pagerModel selectToRight ].  self bindKeyCombination: Character arrowLeft alt shift command toAction: [ self pressedScrollerSizeCombination: #left ].  self bindKeyCombination: Character arrowRight alt shift command toAction: [ self pressedScrollerSizeCombination: #right ]defaultPageSize  ^defaultPageSizetagsFilter: arg1  tagsFilterBlock := arg1update  self notingPresentationChangeDo: [  ].  self presentations do: [:arg1 |  arg1 update ]hintModifier  ^hintModifier ifNil: [ hintModifier := #shift ]testExplicitTransmission  | tmp1 |  tmp1 := GLMFinder new.  tmp1 transmit     fromOutsidePort: #entity;     toOutsidePort: #selection.  tmp1 startOn: 42.  self assert: (tmp1 pane port: #selection) value equals: 42stepTime  ^self glamourPresentation stepTimetitle: arg1  self setProperty: #phlowTitle toValue: arg1globalBounds  ^self owner ifNotNil: [ self brickBounds translateBy: self owner globalBoundsTranslateFactor ] ifNil: [ self brickBounds ]heightParentDependency: arg1  arg1 owner ifNil: [ Exception signal: 'My height depends on parent, but it is nil' ].  ^(arg1 owner innerBounds height * arg1 layout vPercent / 100) ceilingcolumn: arg1 evaluated: arg2 tags: arg3 sortedBy: arg4  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           tags: arg3;           sortBlock: arg4)onCreated  | tmp1 |  tmp1 := onCreatedBlock brickValue: self withEnoughArguments: {self triggerBrick}.  tmp1 := tmp1 asOrderedCollection select: #isNotNil.  self contentBrick addAllBricks: tmp1buttonSelectedColor  ^Color veryDarkGray lighter slightlyDarkerstep: arg1  stepLogic := arg1popupError: arg1  (GLMErrorPopper new withString: arg1 from: self editor textArea owner owner owner) openInWorldregisterModule: arg1 to: arg2 named: arg3  ^self modules at: arg3 ifAbsent: [ arg2 addModule: arg1 value named: arg3 ]scrollValue: arg1  currentScrollDelta := arg1.  self band doNotLayoutDuring: [:arg2 |  arg2 translateXTo: self scrollValue ].  self changedlayoutAfter: arg1  self doNotLayoutDuring: arg1.  self doLayoutonPagePreviewUpdate: arg1  GLMPagerPanePreviewMorph uniqueInstance updateFor: (self paneAt: arg1 pageIndex)updateStyle  self color: self rubricBackgroundColor.  self rubric borderColor: self rubricBorderColor.  self rubric borderWidth: self rubricBorderWidth.  self rubric textColor: self rubricTextColor.  self rubric font: (LogicalFont familyName: self rubricTextFamilyName pointSize: self rubricTextFontSize).  self rubric cursor visibleCursorColor: self rubricCursorColormorph  ^morphBuilder glamourValue: self asGlamorousMultiValue , self displayValue asGlamorousMultiValuemorphicAct: arg1 on: arg2 entitled: arg3  self addAction: (GLMMorphicAction new           action: arg1;           shortcut: arg2;           title: arg3;           yourself)update  self hasItems ifFalse: [ ^self ].  isUpdating := true.  self updateVisible.  self doNotLayoutDuring: [ | tmp1 |        tmp1 := self bandTopOffset + self topOffset.        self band doLayoutForce.        self band translateY: tmp1 ].  self preventOverscrolling.  self verticalScrollbar updatePosition.  isUpdating := falseinitialize  super initialize.  self color: Color transparent.  self theme pagerWidgetThemer previewPaneStyleFor: self.  self borderWidth: self defaultBorderWidthprivateAddIntoWorld: arg1  self world == arg1 world ifFalse: [ self privateRemoveOutWorld: arg1 ].  arg1 intoWorld: self worldtestCopy  | tmp1 tmp2 |  tmp1 := GLMTransmission new.  tmp1 addActiveOrigin: (GLMSimplePort new           name: #port1;           value: 1).  tmp1 addPassiveOrigin: (GLMSimplePort new           name: #port2;           value: 2).  tmp1 addActiveOrigin: (GLMSimplePort new           name: #port3;           value: 3).  tmp1 addPassiveOrigin: (GLMSimplePort new           name: #port4;           value: 4).  tmp1 destination: (GLMSimplePort new name: #port5).  tmp2 := tmp1 copy.  self assert: tmp1 originReferences first ~= tmp2 originReferences firstbeError  self themer: self themer popupErrorThemer themervalue: arg1 in: arg2  arg2 addPort: self.  self silentValue: arg1textSecondaryColor  ^Color r: 25 g: 35 b: 45 range: 255privateAddBrickFirst: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := arg1 asBrick.  tmp2 := nil.  tmp3 := nil.  self hasSubbricks ifTrue: [ tmp2 := self firstSubbrick brickDoubleLink.        tmp3 := self lastSubbrick brickDoubleLink ].  tmp1 := tmp4 asDoubleLink.  tmp4 brickDoubleLink: tmp1.  tmp1 nextLink: tmp2.  tmp2 ifNotNil: [ tmp2 previousLink: tmp1 ].  self privateSubbricks: (self subbricks copyWithFirst: tmp4).  tmp4 owner: self.  ^arg1maxPanes  ^maxPanestestPane  | tmp1 tmp2 tmp3 |  tmp1 := GLMPane new.  tmp2 := GLMCompositePresentation new.  tmp3 := GLMPresentation new.  tmp2 add: tmp3.  tmp2 pane: tmp1.  self assert: tmp2 pane identicalTo: tmp1.  self assert: tmp2 first pane identicalTo: tmp1scrollbarCornerRadius: arg1  self setProperty: #brickScrollbarCornerRadius toValue: arg1.  self updateStylesubbricks  ^self submorphstestSimpleTransmissionWithTransformation  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     from: #one port: #port1;     fromOutsidePort: #entity;     to: #two port: #port2;     when: [:arg1 :arg2 |  arg1 notNil and: [ arg2 notNil ] ];     transformed: [:arg1 :arg2 |  arg1 + arg2 ].  tmp1 startOn: 2.  self assert: ((tmp1 paneNamed: #two) port: #port2) value isNil.  ((tmp1 paneNamed: #one) port: #port1) value: 40.  self assert: ((tmp1 paneNamed: #two) port: #port2) value equals: 42getAndRemoveInvisibleMorph: arg1  | tmp1 |  tmp1 := self retrieveLast: arg1.  ^tmp1 ifNotNil: [ self removeBrickNoLayout: tmp1.        tmp1 morph ]callback  ^callbackrenderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderPresentation: selfprevious: arg1  previous := arg1layoutFloating: arg1 in: arg2  | tmp1 tmp2 |  tmp1 := arg1 layout floating.  tmp2 := self floatingMethodFor: tmp1.  ^(self respondsTo: tmp2) ifTrue: [ self perform: tmp2 with: arg1 with: arg2 ] ifFalse: [ 0 ]testToSend  | tmp1 |  tmp1 := GLMPresentation new.  tmp1 selection: #foo.  self assert: tmp1 selection equals: #foo.  tmp1 selection: #(#foo #bar).  self assert: tmp1 selection equals: #(#foo #bar).  tmp1 selectionTransformation: [:arg1 :arg2 |  (arg1 , arg2) asSymbol ].  tmp1 selection: (GLMMultiValue withAll: #(#foo #bar)).  self assert: tmp1 selection equals: #foobarselectionTransformation: arg1  self selectionTransmission transformation: arg1calculateElements  ^self tagsToFilterBy ifEmpty: [ self basicElements ] ifNotEmpty: [ self basicElements select: [:arg1 |  self elementShouldBeDisplayed: arg1 ] ]glamourPresentation  ^glamourPresentationpagerModel: arg1  pagerModel := arg1.  pagerModel announcer when: GLMNumberOfVisiblePagesChanged send: #onResized to: self.  pagerModel announcer when: GLMPagerScrollPositionChanged send: #onPositionChanged: to: self.  self width: self computeWidthalign: arg1 in: arg2 anchorPoint: arg3 inContext: arg4  | tmp1 |  self = arg4 ifTrue: [ ^self ].  arg2 subbricks size = 1 & arg4 isNil ifTrue: [ GLMHorizontalLinearLayout uniqueInstance align: arg1 in: arg2 anchorPoint: arg3 inContext: self ].  tmp1 := arg1 layout hAlign.  tmp1 = #none ifTrue: [ ^self ].  tmp1 = #left ifTrue: [ ^self ].  tmp1 = #center ifTrue: [ ^arg1 translateX: ((arg2 innerBounds width - arg1 outerBounds width) / 2) asInteger ].  tmp1 = #right ifTrue: [ ^arg1 translateX: (arg2 innerBounds width - arg1 outerBounds width) asInteger ]selectedText  ^selectedTexttestConditionWhenEmbedded  | tmp1 tmp2 |  tmp1 := GLMExpander new.  tmp1 display: [:arg1 :arg2 |  arg1 + arg2 ].  tmp1 show: [:arg3 |  arg3 text display: [:arg1 :arg2 |  arg1 asString , arg2 asString ] ].  tmp2 := GLMTabulator new.  tmp2     column: #one;     column: #two.  tmp2 transmit     to: #two;     fromOutsidePort: #entity;     from: #one port: #nilPort;     andShow: [:arg3 |  arg3 custom: tmp1 ].  self shouldnt: [ tmp2 startOn: 1 ] raise: ErroractiveTitleFillStyle  ^SolidFillStyle color: Color transparentstepTime  ^self model stepTimeassertBrickDirty: arg1  self assertWidthDirty: arg1.  self assertHeightDirty: arg1doubleClick: arg1  self announce: #onDoubleClicked event: arg1.  ^falsevPercent: arg1  vState := self vState onParentDo: [:arg2 |  arg2 percent: arg1 ]action: arg1  action := arg1openOn: arg1  ^self openOn: arg1 with: self defaultRendererbrowser  ^browseroldPane  ^oldPanecacheAt: arg1 for: arg2 ifAbsentPut: arg3  | tmp1 |  self shouldUseCache ifFalse: [ ^arg3 value ].  tmp1 := self dataCacheFor: arg2.  (tmp1 includesKey: arg1) ifTrue: [ ^tmp1 at: arg1 ].  ^arg3 value ifNotNil: [:arg4 |  tmp1 at: arg1 ifAbsentPut: [ arg4 ] ]valueBlock: arg1  valueBlock := arg1drawOn: arg1  arg1 translateBy: self globalBounds origin - self brickBounds origin during: [:arg2 |  self onDraw: arg2 ]render: arg1 on: arg2  self     renderShadowOf: arg1 on: arg2;     renderBackgroundColorOf: arg1 on: arg2;     renderColorOf: arg1 on: arg2;     renderImageOf: arg1 on: arg2;     renderBorderOf: arg1 on: arg2announcer  iconProvider  ^(Smalltalk respondsTo: #ui) ifTrue: [ (Smalltalk perform: #ui) icons ] ifFalse: [ UITheme current ]contents  ^self childrenItemshasHeightRestrictions: arg1  ^arg1 layout hasMinHeight | arg1 layout hasMaxHeightshadowOffset  ^0.5 @ 0.5testEnlargeToRight  | tmp1 tmp2 |  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel scrollTo: 0.0 smooth: false.  tmp1 := pagerModel numberOfVisiblePages.  tmp2 := pagerModel firstVisiblePageIndex.  self assert: pagerModel numberOfVisiblePages equals: tmp1.  self assert: pagerModel numberOfVisiblePages equals: pagerModel lastVisiblePageIndex - tmp2 + 1.  self assert: pagerModel firstVisiblePageIndex equals: tmp2.  [ tmp1 < 6 ] whileTrue: [ tmp1 := tmp1 + 1.        pagerModel enlargeToRight.        self assert: pagerModel numberOfVisiblePages equals: tmp1.        self assert: pagerModel numberOfVisiblePages equals: pagerModel lastVisiblePageIndex - tmp2 + 1.        self assert: pagerModel firstVisiblePageIndex equals: tmp2 ].  (1 to: 3) do: [:arg1 |  pagerModel enlargeToRight.        self assert: pagerModel numberOfVisiblePages equals: 6.        self assert: pagerModel numberOfVisiblePages equals: pagerModel lastVisiblePageIndex - tmp2 + 1.        self assert: pagerModel firstVisiblePageIndex equals: tmp2.        self assert: pagerModel lastVisiblePageIndex equals: 6 ]testPanesHaveDifferentRegistries  | tmp1 |  tmp1 := GLMFinder new.  tmp1 addPresentation: (GLMPresentation new title: 'presentation1').  self assertEmpty: tmp1 panes.  (tmp1 pane port: #entity) value: #value1.  self assert: tmp1 panes size equals: 1.  (tmp1 panes first port: #selection) value: #value2.  self assert: tmp1 panes size equals: 2.  self deny: (tmp1 panes first instVarNamed: 'registry') identicalTo: (tmp1 panes second instVarNamed: 'registry')nodeModelFor: arg1  ^GLMExpanderLabelNodeModel with: arg1 in: selftestCompositeWithinCompositeOuterPortEvents  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := 0.  tmp1 := GLMCompositePresentation new.  tmp2 := tmp1 finder.  tmp2 show: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 ] ].  tmp2 when: GLMPaneAdded do: [:arg1 |  tmp4 := tmp4 + 1 ].  tmp3 := GLMCompositePresentation new.  tmp3 custom: tmp1.  tmp3 startOn: 10.  self assert: tmp4 equals: 1widthTop: arg1  self width at: Top put: arg1updateContextWith: arg1  vSpaceFill: arg1  self vPercent: arg1menu  ^self menu: MenuMorph newrootNodes  ^self rootsexecute: arg1 withArguments: arg2 callback: arg3  ^self execute: arg1 withArguments: arg2 callback: arg3 priority: Processor userSchedulingPriorityactionThemer  ^GLMActionBrickDarkThemer newtestUpdateConditionallyTriggered  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMPane named: 'test'.  (tmp1 port: #entity) value: 40.  tmp2 := GLMPresentation new.  tmp3 := Announcer new.  tmp1 addPresentation: tmp2.  tmp4 := 0.  tmp2 when: GLMPresentationUpdated do: [:arg1 |  tmp4 := tmp4 + 1 ].  tmp2 updateOn: GLMTestAnnouncement from: [:arg2 |  tmp3 ] when: [:arg3 :arg4 |  arg3 parameter + arg4 = 42 ].  tmp2 registerAnnouncements.  tmp3 announce: (GLMTestAnnouncement new parameter: 0).  self assert: tmp4 equals: 0.  tmp3 announce: (GLMTestAnnouncement new parameter: 2).  self assert: tmp4 equals: 1newTransmission  ^self transmission copyisExpanded  ^self hasSubbrick: self contentBrickenableSearch  self parameters at: 'isSearchable' put: truevalue: arg1 in: arg2  self subclassResponsibilityend  ^endbeBold  self font forceBoldhPadding  ^self paddingLeft + self paddingRightcompileTextIn: arg1 from: arg2 andDo: arg3  self announce: (GLMCompileText new           presentation: self;           context: arg1;           session: arg2;           action: arg3)nodeModelFor: arg1  ^(GLMTreeMorphNodeModel with: arg1)     containerTree: self;     yourselfpopupEditorBorderThemer  ^self registerModule: GLMBrickPopupEditBorderThemer new to: self named: #popupThemerselectedPaneStyleFor: arg1  arg1 borderColor: Color transparentmaxPanes: arg1  maxPanes := arg1searchOn: arg1  self error: 'This presentation does not allow searching with a block for now. In the futur we should have a new filter with FastTable to do that. If you want to give it a try look FTFunction and his subclasses.'notifyScrollerBoundsChanged: arg1  self notifyAll: (GLMPagerBoundsChanged new bounds: arg1)testGlamourValue  self assert: ([ #foo ] glamourValue: #(1 2)) equals: #foo.  self assert: ([:arg1 |  Array with: arg1 ] glamourValue: #(1 2)) equals: #(#(1 2)).  self assert: ([:arg1 :arg2 |  Array with: arg1 with: arg2 ] glamourValue: #(1 2)) equals: #(#(1 2) nil).  self assert: ([:arg1 :arg2 |  Array with: arg1 with: arg2 ] glamourValue: (GLMMultiValue with: 1 with: 2)) equals: #(1 2).  self assert: (#yourself glamourValueWithArgs: #(1 2)) equals: 1.  self assert: (#yourself glamourValueWithArgs: #()) equals: nilindex: arg1  index := arg1table  ^self custom: GLMPhlowTableBrick newat: arg1  ^self presentations at: arg1withColumns: arg1  withColumns := arg1resizeScrollBar  | tmp1 tmp2 |  tmp2 := super innerBounds.  tmp1 := tmp2 withHeight: tmp2 height - self scrollBarHeight.  scrollBar bounds: (tmp1 left @ tmp1 bottom corner: tmp2 bottomRight)createDataSourceFrom: arg1  ^GLMFastTreeDataSource newisDropTarget  ^self dropOnItemBlock notNilmaxPanes  ^maxPanesdeselect: arg1  self deselectrenderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderPharoScriptPresentation: selftree  ^self find: MorphTreeMorph in: windowrenderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderPharoMethodPresentation: selfpopup  ^popupmorphicActOn: arg1  ^self actOn: arg1stylerStyledInBackground: arg1  next ifNil: [ ^self ].  text string = arg1 string ifTrue: [ self stylerStyled: arg1 ]isClean: arg1  ^self subclassResponsibilityinitializeTransform  transform := TransformMorph new.  transform     color: Color transparent;     borderWidth: 0;     vResizing: #spaceFill;     hResizing: #spaceFill;     disableTableLayout;     bounds: super innerBounds.  self addMorphBack: transformvirtualFirstVisiblePageIndex  ^virtualFirstVisiblePageIndexdelay: arg1  delay := arg1initializeLayout  self popupLayout build: self trigger: self newTriggerBrick content: self newContentBricktestStackedVertically  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 stackedVerticallyArrangement.        arg1 list title: 'list'.        arg1 text title: 'text' ].  window := tmp1 openOn: 42.  self assert: self compositeMorph class equals: GLMPanelMorph.  self assert: self compositeMorph submorphs size equals: 2.  self assert: self compositeMorph submorphs size equals: 2.  self assert: self compositeMorph submorphs first class equals: LazyTabGroupMorphnewTriggerBrick  ^GLMActionButtonBrick new     hShrinkWrap;     vShrinkWrap;     yourselfnewBand  ^GLMHorizontalBandBrick newwantsAutomaticRefresh  ^wantsAutomaticRefresh ifNil: [ false ]updateHeight  self layout isHeightCustom ifFalse: [ ^self ].  [ self bounds: (self brickBounds withHeight: self customHeight) ] on: Exception do: [  ]icon: arg1  icon := arg1update  self pane ports do: [:arg1 |  (self validate: arg1 value on: arg1) ifFalse: [ arg1 resetValue ] ].  self presentations do: [:arg1 |  arg1 update ].  self announce: (GLMPresentationUpdated new presentation: self)selectTable: arg1 element: arg2  arg1 selectIndex: (self elements indexOf: arg2)newTextBrick  ^GLMRubScrolledTextBrick newdragTransferType  ^#Glamourtext  ^next textfrom: arg1  ^self addActiveOrigin: (self browser resolveOriginPort: arg1)isFirstInOwner  ^self brickDoubleLink ifNotNil: [:arg1 |  arg1 hasPredecessor not ] ifNil: [ false ]themeChanged  self isSelected ifTrue: [ self themer tabLabelThemer selectedStyleFor: self ] ifFalse: [ self themer tabLabelThemer normalStyleFor: self ].  super themeChangedtestDefaultCompositePresentation  | tmp1 |  tmp1 := GLMPane named: 'test'.  self assert: (tmp1 presentations isKindOf: GLMCompositePresentation)defaultRenderer  ^GLMRenderer subclasses first newtagsToFilterBy  ^tagsToFilterBy ifNil: [ tagsToFilterBy := OrderedCollection new ]privateThemer  ^self valueOfProperty: #brickThemer ifAbsentPut: [ nil ]withBindingsDo: arg1  self announce: (GLMVariableBindingsAccessRequest new action: arg1)onThemerChanged  super onThemerChanged.  self updateStyletestValidate  | tmp1 tmp2 |  tmp1 := GLMPane named: 'test'.  tmp2 := GLMListPresentation new.  tmp1 addPresentation: tmp2.  tmp2 entity: (OrderedCollection with: 1 with: 2).  tmp2 shouldValidate: true.  self assert: ((tmp1 port: #selection) validate: 1).  self assert: ((tmp1 port: #selection) validate: 2).  self deny: ((tmp1 port: #selection) validate: 5)allSatisfy: arg1  ^self presentations allSatisfy: arg1render: arg1  | tmp1 |  tmp1 := GLMPluggableButtonMorph on: arg1 getState: nil action: self actionSelector.  tmp1     theme: UITheme current;     arguments: (self actionArguments ifNil: [ {tmp1} ]);     cornerStyle: (UITheme current buttonCornerStyleIn: nil);     hResizing: #shrinkWrap;     vResizing: #shrinkWrap;     getEnabledSelector: nil;     setBalloonText: ((arg1 help ifNil: [ arg1 title ]) , Character tab asString , arg1 shortcutAsString) trimBoth;     extent: tmp1 minExtent;     removeProperty: #theme.  arg1 shouldShowTitle ifTrue: [ tmp1           icon: arg1 icon;           label: arg1 title font: UITheme current buttonFont ] ifFalse: [ tmp1 label: (AlphaImageMorph new image: arg1 icon) ].  tmp1     valueOfProperty: #noBorder ifAbsentPut: [ true ];     valueOfProperty: #noFill ifAbsentPut: [ true ];     setProperty: #wantsKeyboardFocusNavigation toValue: false;     borderWidth: 0.  ^tmp1entity: arg1  super entity: arg1.  self installEntityresetBindings  self withBindingsDo: [:arg1 |  arg1 removeAll ]selectionPopulate: arg1 entitled: arg2 with: arg3  self addSelectionAction: (GLMGenericAction new           action: (GLMPortUpdater new                 portSymbol: arg1;                 valueBlock: arg3;                 yourself);           title: arg2;           yourself)highlightSmalltalkContext  ^highlightSmalltalkContext ifNil: [ nil ] ifNotNil: [ highlightSmalltalkContext glamourValue: self entity ]treeMorphFor: arg1 and: arg2  | tmp1 tmp2 |  tmp1 := self newTreeMorph.  tmp1     makeLastColumnUnbounded;     doubleClickSelector: #onDoubleClick;     getMenuSelector: #menu:shifted:;     keystrokeActionSelector: #keyStroke:from:;     columnInset: 3;     rowInset: 1;     cornerStyle: tmp1 preferredCornerStyle;     borderStyle: (BorderStyle inset width: 1);     autoDeselection: arg2 allowsDeselection;     dragEnabled: arg1 dragEnabled;     dropEnabled: arg1 dropEnabled;     hResizing: #spaceFill;     vResizing: #spaceFill;     layoutFrame: LayoutFrame identity.  tmp2 := arg2 columns isEmpty ifTrue: [ OrderedCollection with: (MorphTreeColumn new rowMorphGetSelector: #elementColumn) ] ifFalse: [ arg2 columns collect: [:arg3 |  GLMMorphTreeColumn new                 startWidth: arg3 width;                 glamourColumn: arg3;                 headerButtonLabel: (arg2 titleValueOfColumn: arg3) font: StandardFonts menuFont target: arg1 actionSelector: #sortByColumn: arguments: {arg3};                 yourself ] ].  tmp1     preferedPaneColor: Smalltalk ui theme backgroundColor;     model: arg1;     columns: tmp2.  arg2 isMultiple ifTrue: [ tmp1 beMultiple ] ifFalse: [ tmp1 beSingle ].  tmp1 chunkSize: arg2 amountToShow.  tmp1 pageSize: arg2 amountToShow.  tmp1 vShowScrollBar.  tmp1 hShowScrollBar.  ^tmp1 buildContentscursorPosition: arg1  cursorPosition := arg1transformation  ^transformationadd: arg1 beforeOrLast: arg2  (collection includes: arg2) ifTrue: [ collection add: arg1 before: arg2 ] ifFalse: [ collection add: arg1 ].  self announce: GLMItemAddeddepress  self isPressed ifTrue: [ isPressed := false.        self changed.        ^true ].  ^falseisModifierPressed: arg1  self hintModifier ifNil: [ ^false ].  self hintModifier = #shift ifTrue: [ ^arg1 shiftPressed ].  self hintModifier = #option ifTrue: [ ^arg1 optionKeyPressed ].  self hintModifier = #alt ifTrue: [ ^arg1 altKeyPressed ].  self hintModifier = #command ifTrue: [ ^arg1 commandKeyPressed ].  self hintModifier = #control ifTrue: [ ^arg1 controlKeyPressed ].  ^falseactOnPresentationUpdated: arg1  container removeAllMorphs.  container addMorph: (self renderObject: arg1 presentation currentPresentation) fullFrame: LayoutFrame identityrenderFastTreeWithColumnsPresentation: arg1  ^GLMMorphicFastTreeWithColumnsRenderer render: arg1 from: selftextBackgroundColor  ^self containerTree glamourPresentation textBackgroundColorFor: self itemenableDoubleClick  isDoubleClickEnabled := trueborderWidth  ^self theme borderWidthtabWidth: arg1  tabWidth := arg1actOn: arg1  ^self action glamourValueWithArgs: (Array with: arg1 withAll: arg1 entity asGlamorousArray)innerPortEvent: arg1  testPushPanesBeforeOpen  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self openInWindow.  self assert: pagerModel size equals: 3.  self assert: self panesMorphs size equals: 3.  self assert: self buttonsMorphs size equals: 3shouldShowTitle: arg1  shouldShowTitle := arg1testPaneRemovedAnnouncement  | tmp1 tmp2 |  tmp2 := 0.  tmp1 := GLMFinder new.  tmp1 when: GLMPaneRemoved do: [:arg1 |  tmp2 := tmp2 + 1 ].  tmp1 startOn: #a.  self assert: tmp2 equals: 0.  (tmp1 panes first port: #selection) value: #b.  self assert: tmp2 equals: 0.  (tmp1 panes second port: #selection) value: #c.  self assert: tmp2 equals: 0.  (tmp1 panes first port: #selection) value: #d.  self assert: tmp2 equals: 1pagerModel  ^pagerModelnormalImage  ^normalImagetransmitIn: arg1  self flag: 'The transmitIt: and receive:in: both end up calling notingPresentationChangeDo:. So they should be handled by a surrounding notingPresentationChangeDo:. However, by doing that it seems that we break the morphic updating. No idea why'.  self destination notingPresentationChangeDo: [ self transmissionStrategy transmitIn: arg1.        self destination receive: self in: arg1 ].  self browser notNil ifTrue: [ self browser announce: GLMTransmissionTriggered new ]vAlign  ^vAlign ifNil: [ vAlign := #none ]list  ^self custom: GLMPhlowListBrick newwithChildrenOf: arg1 do: arg2  arg2 value: arg1.  (self childrenValueOf: arg1) do: [:arg3 |  self withChildrenOf: arg3 do: arg2 ]smooth  ^smoothcomputeAnnouncerObjects  self subclassResponsibilityaddColumn: arg1 size: arg2  ^(self addColumn: arg1)     size: arg2;     span: 0morph  ^selfaddPaneFromOuter: arg1  | tmp1 |  tmp1 := self panes addLast: (GLMPane named: (self panes size + 1) asString in: self).  self newFirstTransmission     addActiveOrigin: arg1;     destination: (tmp1 port: #entity);     transmitdragTransferTypeForMorph: arg1  ^self dragTransferTyperenderAccordionCompositePresentation: arg1  ^GLMMorphicAccordionRenderer render: arg1 from: selfinitialize  super initialize.  dimension := self defaultDimensioninputText: arg1  inputText := arg1.  self doSearchOrFiltertestMarkerOneStaticWidth  | tmp1 |  tmp1 := self newBrickWithStaticExtent.  self markFullyClean: tmp1.  tmp1 wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp1 brickApi.  self assert: tmp1 wrappedBounds isWidthDirty.  self assert: tmp1 wrappedBounds isHeightCleantestValidateOn  | tmp1 tmp2 |  tmp1 := GLMPane named: 'test'.  tmp2 := GLMListPresentation new.  tmp1 addPresentation: tmp2.  tmp2 shouldValidate: true.  tmp2 entity: ($a to: $d).  self deny: (tmp2 validate: (Array with: $a) on: (tmp1 port: #selection)).  self deny: (tmp2 validate: (Array with: $a with: $b) on: (tmp1 port: #selection)).  self assert: (tmp2 validate: $a on: (tmp1 port: #selection)).  self assert: (tmp2 validate: $b on: (tmp1 port: #selection)).  self deny: (tmp2 validate: $z on: (tmp1 port: #selection))sendTo: arg1 fromOutside: arg2  self sendTo: arg1 from: #outer -> arg2testMarkerOneParentInStaticWidth  | tmp1 tmp2 |  tmp1 := self newBrickWithStaticExtent.  tmp2 := self newBrickWithFullFill.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthDirty.  self assert: tmp2 wrappedBounds isHeightClean.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightCleanselectedText: arg1  selectedText := arg1newVerticalScrollbar  ^GLMApproximateScrollbarBrick newvalue: arg1 in: arg2  (self validate: arg1) ifFalse: [ ^self ].  arg2 addPort: self.  self changeValueTo: arg1 in: arg2toValue  ^toValue ifNil: [ toValue := toLogic brickValue: self animatedObject ]onPagePushed: arg1  self buttonsBrick onPagePushed: arg1.  self recomputeScrollBarpanesMorphs  ^pagerMorph subbricks first subbricks first subbricksisDependsOnMyself: arg1  ^(self stateOf: arg1) isOnMyselftestCreation  | tmp1 |  tmp1 := GLMExpander new.  tmp1 show: [:arg1 |  arg1 text ].  window := tmp1 openOn: #(#a #b #c).  self assert: window submorphs last class equals: GeneralScrollPane.  self assert: window submorphs last scrollTarget submorphs size equals: 3.  self assert: window submorphs last scrollTarget submorphs first complexContents class equals: ExpanderMorphvalue  ^valueisDebug  ^trueisOppositeClean: arg1  ^arg1 isHeightCleanname  ^namescrollbarColor  ^Color black alpha: 0.5cacheAt: arg1 for: arg2 ifAbsentPut: arg3  | tmp1 |  self shouldUseCache ifFalse: [ ^arg3 value ].  tmp1 := self dataCacheFor: arg2.  (tmp1 includesKey: arg1) ifTrue: [ ^tmp1 at: arg1 ].  ^arg3 value ifNotNil: [:arg4 |  tmp1 at: arg1 ifAbsentPut: [ arg4 ] ]border: arg1  self setProperty: #brickBorder toValue: arg1defaultName  ^'undefined'hAlign: arg1  < brickBuilderProperty: #Layout name: 'Horizontal align' as: #asSymbol getter: #hAlign model: #GLMUIBuilderTextFieldProperty>  self layout hAlign: arg1suspendAll  ^suspendAll ifNil: [ suspendAll := false ]vShrinkWrap  vState := self vState onChildrenDo: #yourselfpresentation  ^presentationnormalImage: arg1  normalImage := arg1hasTagsFilter  ^self tagsFilterBlock notNiltestAllSelectionActionsWithSelection  | tmp1 |  tmp1 := GLMPresentation new.  tmp1 addSelectionAction: GLMAction new.  tmp1 addSelectionAction: GLMAction new.  tmp1 selection: Object new.  tmp1 dynamicActionsOnSelection: [:arg1 |  OrderedCollection with: GLMAction new with: GLMAction new with: GLMAction new ].  self assert: tmp1 allSelectionActions size equals: 5pagerModel: arg1  pagerModel := arg1.  maxPanes := arg1 numberOfVisiblePages.  pagerModel announcer when: GLMPagePushed send: #onPagePushed: to: self.  pagerModel announcer when: GLMPagePoped send: #onPagePoped: to: self.  pagerModel announcer when: GLMPagePopedAndReplaced send: #onPagePopedAndReplaced: to: self.  pagerModel announcer when: GLMPagerSynchronizeScrollAnnouncement send: #onSynchronizeScroll: to: self.  pagerModel announcer when: GLMPagerScrollPositionChanged send: #onPositionChanged: to: self.  pagerModel announcer when: GLMNumberOfVisiblePagesChanged send: #onPagesNumberChanged to: self.  pagerModel announcer when: GLMSelectedPageChanged send: #onSelectedPageChanged to: self.  pagerModel announcer when: GLMPagerPreviewUpdate send: #onPagePreviewUpdate: to: selfsetScrollDeltas  | tmp1 tmp2 tmp3 |  transform hasSubmorphs ifFalse: [ scrollBar interval: 1.0.        ^self ].  tmp1 := self leftoverScrollRange.  tmp1 = 0 ifTrue: [ ^scrollBar           interval: 1.0;           setValue: 0 ].  tmp2 := (self innerBounds width / self totalScrollRange) asFloat.  tmp3 := (transform offset x / tmp1 min: 1.0) asFloat.  scrollBar interval: tmp2.  scrollBar setValue: tmp3useVerticalLinearLayout  self layout: GLMVerticalLinearLayout uniqueInstancevalue  self flag: 'checking for #entity is rather not elegant, but it is a solution to not affect the other custom ports that will probably be desired to be populated in other ways.'.  ^self name == #entity ifTrue: [ self presentation transformation glamourValue: self port value asGlamorousMultiValue ] ifFalse: [ self port value ]sortBlock  ^sortBlockpressedColor  ^pressedColorcheckedColor: arg1  checkedColor := arg1testTriggerConditionsWithParentPort  | tmp1 tmp2 |  tmp1 := GLMTransmission new.  tmp2 := GLMPresentation new.  tmp1 addActiveOrigin: (GLMPresentationBoundPort new           presentation: tmp2;           name: #port1;           yourself).  self assert: (tmp1 originatesAt: (GLMPresentationBoundPort new                 presentation: tmp2;                 name: #port1;                 yourself)).  self assert: (tmp1 originatesAt: (tmp2 pane port: #port1))scrollToRightTask  ^scrollToRightTask ifNil: [ scrollToRightTask := GLMAsyncTask new.        scrollToRightTask           doInBackground: [:arg1 |  arg1 ];           onCompleted: [:arg1 |  self scrollToRight: arg1 ];           delay: self scrollingDelay ]testMorphUpdateOnAnnounce  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp5 := GLMAnnouncer new.  tmp2 := 42.  tmp1 := GLMTabulator new.  tmp1 row: #morph.  tmp1 transmit     to: #morph;     andShow: [:arg1 |  arg1 morph           updateOn: Announcement from: [ tmp5 ];           display: [:arg2 |  tmp2 asString asMorph ] ].  window := tmp1 openOn: 42.  tmp3 := self findLast: StringMorph in: window.  self assert: tmp3 notNil.  self assert: tmp3 contents equals: 42 asString.  tmp2 := 43.  tmp5 announce: Announcement.  tmp4 := self findLast: StringMorph in: window.  self assert: tmp4 ~= tmp3.  self assert: tmp4 notNil.  self assert: tmp4 notNil.  self assert: tmp4 contents equals: 43 asStringselectedImage: arg1  selectedImage := arg1condition  ^condition ifNil: [ condition := [ true ] ]textLogic  ^textLogicbottomLeftCornerShadowOf: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := arg1 shadowWidth.  tmp4 := (tmp2 @ tmp2) negated / 2.0.  tmp3 := arg1 brickBounds bottomLeft + tmp4 + arg1 shadowOffset.  tmp1 := (self shadowGradientFor: arg1)     origin: tmp3 + (tmp2 @ 0);     direction: tmp2 negated @ tmp2 / 1.4;     radial: true;     yourself.  arg2 fillRectangle: (tmp3 extent: tmp2 @ tmp2) fillStyle: tmp1testWithReturnsTheOriginalPresentation  | tmp1 tmp2 |  tmp1 := GLMPresentation new.  tmp2 := tmp1 with: [:arg1 |  GLMPresentation new ].  self assert: tmp2 identicalTo: tmp1convertIndexToValue: arg1 with: arg2  arg2 = self actualNumberOfVisiblePages ifTrue: [ ^0 ] ifFalse: [ ^(arg1 - 1) / (arg2 - self actualNumberOfVisiblePages) ]gtInspectorBrowserIn: arg1  < gtInspectorPresentationOrder: 40>  ^arg1 tabulator with: [:arg2 |  arg2 title: 'Live'.        arg2 column: #default.        arg2 transmit           to: #default;           transformed: [:arg3 |  self entity ];           andShow: [:arg4 |  arg4 custom: self copy ].        arg2 transmit           from: #default port: #selection;           toOutsidePort: #selection ]morph  ^self custom: GLMMorphPresentation newsetUp  super setUp.  announcer := Announcer new.  entity := OrderedCollection with: 1 with: 2 with: 3.  browser := GLMTabulator new.  browser     column: #one;     column: #two.  browser transmit     to: #one;     andShow: [:arg1 |  arg1 verticallyStackedArrangement.        arg1 list           title: [:arg2 |  arg2 printString ];           updateOn: GLMTestAnnouncement from: [ announcer ];           shouldValidate: true.        arg1 tree           title: [:arg2 |  arg2 printString ];           children: #();           updateOn: GLMTestAnnouncement from: [ announcer ];           shouldValidate: true.        arg1 table           title: [:arg2 |  arg2 printString ];           updateOn: GLMTestAnnouncement from: [ announcer ];           shouldValidate: true.        arg1 text updateOn: GLMTestAnnouncement from: [ announcer ].        arg1 list           title: 'Not updated automatically';           shouldValidate: true.        arg1 label           display: [:arg2 |  arg2 isEmpty ifTrue: [ '#()' ] ifFalse: [ arg2 last ] ];           updateOn: GLMTestAnnouncement from: [ announcer ] ].  browser transmit     to: #two;     from: #one;     andShow: [:arg1 |  arg1 text ].  window := browser openOn: entity.  listLabelMorph := window submorphs last submorphs second submorphs first submorphs first tabSelectorMorph submorphs first submorphs first.  listMorph := window submorphs last submorphs second submorphs first submorphs first submorphs first submorphs first submorphs first.  treeMorph := window submorphs last submorphs second submorphs first submorphs second submorphs first submorphs first submorphs first.  tableMorph := window submorphs last submorphs second submorphs first submorphs third submorphs first submorphs first submorphs first.  unupdatedListMorph := window submorphs last submorphs second submorphs first submorphs fifth submorphs first submorphs first submorphs first.  labelMorph := window submorphs last submorphs second submorphs first submorphs last submorphs first submorphs firstsubbricks  ^self brick subbricks collect: #brickApitestExample  window := GLMScrollListBrick example.  self assert: window isSystemWindowbeSingle  allowsMultipleSelection := falserenderSmalltalkCodePresentation: arg1  ^GLMMorphicSmalltalkCodeRenderer render: arg1 from: selfdoInBackground: arg1  task := arg1marginRight  ^self margin at: RighttestTwoInterdependentPanesShouldUpdateTheRenderedSelectionOnTheTriggerPane  | tmp1 tmp2 tmp3 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 ] ].  tmp1 transmit     from: #one;     to: #two;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 ] ].  tmp1 transmit     from: #two port: #toSelect;     toOutsidePort: #toSelect.  tmp1 transmit     fromOutsidePort: #toSelect;     to: #one port: #selection.  tmp1 transmit     fromOutsidePort: #toSelect;     to: #two port: #selection.  window := tmp1 openOn: 100.  ((tmp1 paneNamed: #one) port: #selection) value: 10.  ((tmp1 paneNamed: #two) port: #toSelect) value: 5.  self assert: ((tmp1 paneNamed: #one) port: #selection) value equals: 5.  self assert: ((tmp1 paneNamed: #two) port: #selection) value equals: 5.  self waitUntilUIRedrawed.  tmp3 := self findWherePresentationIs: (tmp1 paneNamed: #one) presentations first in: window.  self assert: tmp3 notNil.  self assert: tmp3 selectedMorph notNil.  tmp2 := self findWherePresentationIs: (tmp1 paneNamed: #two) presentations first in: window.  self assert: tmp2 notNil.  self assert: tmp2 selectedMorph notNilextent: arg1  self changed.  self width: arg1 x.  self height: arg1 y.  self wrappedBounds bounds: (self brickBounds origin extent: arg1).  self flag: 'do I need to layout morphs inside?'.  self doLayout.  self changedminHeight: arg1  minHeight := arg1renderCustomRow: arg1 ofPane: arg2 inUI: arg3 inBrowser: arg4  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp2 := arg1 children inject: 0 into: [:arg5 :arg6 |  arg5 + arg6 span ].  tmp3 := arg1 children inject: 0 into: [:arg5 :arg6 |  arg5 + arg6 size ].  tmp4 := 0.  tmp5 := 0.  arg1 children keysAndValuesDo: [:arg7 :arg6 |  arg6 hasId ifTrue: [ tmp1 := self renderObject: (arg4 paneNamed: arg6 id) ] ifFalse: [ tmp1 := GLMMorphic containerMorph.              self renderCustomColumn: arg6 ofPane: arg2 inUI: tmp1 inBrowser: arg4.              tmp1 addPaneSplitters ].        tmp1 layoutFrame: (LayoutFrame new                 topFraction: 0 offset: 0;                 leftFraction: tmp4 / tmp2 offset: tmp5 - (tmp3 * tmp4 / tmp2) rounded + self margin;                 bottomFraction: 1 offset: 0;                 rightFraction: (tmp4 + arg6 span) / tmp2 offset: tmp5 + arg6 size - (tmp3 * (tmp4 + arg6 span) / tmp2) rounded - self margin;                 yourself).        arg3 addMorphBack: tmp1.        tmp4 := tmp4 + arg6 span.        tmp5 := tmp5 + arg6 size ].  arg1 children last size > 0 ifTrue: [ (arg3 submorphs atLast: 2) layoutFrame rightOffset: (arg3 submorphs atLast: 2) layoutFrame rightOffset - tmp5.        arg3 submorphs last layoutFrame leftOffset: arg3 submorphs last layoutFrame leftOffset - tmp5.        arg3 submorphs last layoutFrame rightOffset: arg3 submorphs last layoutFrame rightOffset - tmp5 ].  arg3 addPaneSplitterstestStartTabulator  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list.        arg1 text ].  tmp1 startOn: 42.  self assert: ((tmp1 paneNamed: #one) presentations isKindOf: GLMCompositePresentation).  self assert: (tmp1 paneNamed: #one) presentations size equals: 2result: arg1  result := arg1printOn: arg1  super printOn: arg1.  arg1 nextPutAll: '(port='.  self port printOn: arg1.  arg1     nextPutAll: ' oldValue=';     nextPutAll: self oldValue printString;     nextPut: $)padding: arg1  arg1 ifNil: [ ^self padding: #(0) ].  arg1 isCollection ifTrue: [ arg1 isEmpty ifTrue: [ ^self padding: #(0) ].        self           paddingTop: (arg1 at: Top);           paddingRight: (arg1 at: Top);           paddingBottom: (arg1 at: Top);           paddingLeft: (arg1 at: Top).        arg1 size > Top ifTrue: [ self                 paddingRight: (arg1 at: Right);                 paddingLeft: (arg1 at: Right) ].        arg1 size > Right ifTrue: [ self paddingBottom: (arg1 at: Bottom) ].        arg1 size > Bottom ifTrue: [ self paddingLeft: (arg1 at: Left) ] ] ifFalse: [ ^self padding: {arg1} ].  self updateCachescrollbarPosition  ^#rightchildrenValueOf: arg1  ^self children glamourValue: arg1 asGlamorousMultiValue , self entity asGlamorousMultiValuecreateRootItem  | tmp1 |  tmp1 := FTRootItem data: self basicRoots from: self.  ^self tagsToFilterBy ifEmpty: [ tmp1 ] ifNotEmpty: [ | tmp2 |        tmp2 := OrderedCollection new.        tmp1 children do: [:arg1 |  (self matchingTag: arg1) ifNotNil: [:arg2 |  tmp2 add: arg2 ] ] displayingProgress: [:arg3 |  'Looking inside ' , arg3 printString ].        FTRootItem new           dataSource: self;           children: tmp2 asArray;           yourself ]withSeparatorAfter  self separatorAfter: trueallSelectionActions  ^self selectionActions , self dynamicActionsOnSelection select: [:arg1 |  arg1 isAvailableOn: self ]modelFor: arg1  ^(super modelFor: arg1)     highlightSmalltalk: true;     bindingsStrategy: self workspaceBindingsStrategy;     appendVariableBinding: arg1 variableBindings;     yourselfpresentation: arg1  presentation := arg1resolvePort: arg1 defaultPortName: arg2  ^arg1 paneName = #outer ifTrue: [ GLMPresentationBoundPort new           presentation: self;           name: arg1 portName;           yourself ] ifFalse: [ (self paneNamed: arg1 paneName) port: arg1 portName ]searchOn: arg1  self error: 'This presentation does not allow searching with a block for now. In the futur we should have a new filter with FastTable to do that. If you want to give it a try look FTFunction and his subclasses.'testTriggerConditionsWithParentPort  | tmp1 tmp2 |  tmp1 := GLMTransmission new.  tmp2 := GLMPresentation new.  tmp1 addActiveOrigin: (GLMPresentationBoundPort new           presentation: tmp2;           name: #port1;           yourself).  self assert: (tmp1 originatesAt: (GLMPresentationBoundPort new                 presentation: tmp2;                 name: #port1;                 yourself)).  self assert: (tmp1 originatesAt: (tmp2 pane port: #port1))pageIndex: arg1  pageIndex := arg1markFullyClean: arg1  arg1 withAllSubbricks do: [:arg2 |  arg2 wrappedBounds           markWidthClean;           markHeightClean ].  ^arg1hasMaxHeight  ^(self maxHeight isNumber ifTrue: [ self maxHeight isInfinite ] ifFalse: [ false ]) notemptyBrick  ^emptyBrickasString  ^'horizontal'buttonForTag: arg1 filter: arg2  ^(GLMMorphic togglingButtonLabelled: arg1 pressed: (self shouldFilterByTag: arg2) style: self glamourPresentation tagsStyle)     target: self;     actionSelector: #toggleFilteringByTag:;     arguments: (Array with: arg2);     yourselfnotifyNumberOfVisiblePagesChanged  self notifyAll: GLMNumberOfVisiblePagesChanged newhShrinkWrap  hState := self hState onChildrenDo: #yourselfenableSearch  self parameters at: 'isSearchable' put: truedefaultPageSize: arg1  defaultPageSize := arg1selectionPath: arg1  (self pane port: #selectionPath) value: arg1testTabsWithTitleIconWithoutTitle  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 titleIcon: GLMUIThemeExtraIcons glamorousBrowse.        arg1 list.        arg1 text ].  window := tmp1 openOn: 42.  self assert: self compositeTabGroup submorphs size equals: 2.  self assert: self compositeTabGroup submorphs first class equals: GLMPanelMorph.  self assert: self compositeTabGroup submorphs first submorphs size equals: 1.  self assert: self compositeTabGroup submorphs first submorphs first class equals: LazyTabGroupMorph.  self assert: self compositeTabGroup submorphs first submorphs first pages size equals: 2browser: arg1  browser := arg1render: arg1  | tmp1 tmp2 tmp3 |  tmp1 := arg1 matchingPresentations.  tmp1 isEmpty ifTrue: [ ^GLMMorphic emptyMorph ].  tmp1 size = 1 ifTrue: [ ^self renderWithToolbar: tmp1 first ].  tmp2 := GLMMorphic containerMorph.  tmp2 changeTableLayout.  tmp1 do: [:arg2 |  tmp3 := self theme newExpanderIn: tmp2 label: (self titleOrIconOf: arg2 in: tmp2) forAll: {(self renderWithToolbar: arg2)}.        tmp2 addMorphBack: tmp3.        (arg1 pane lastActivePresentation notNil and: [ arg2 title = arg1 pane lastActivePresentation title ]) ifTrue: [ tmp3 expanded: true ] ].  (arg1 pane lastActivePresentation isNil and: [ tmp2 submorphs notEmpty ]) ifTrue: [ tmp2 submorphs first expanded: true ].  ^tmp2initialize  super initialize.  self changeProportionalLayout.  self     onAnnouncement: MorphLostFocus do: [:arg1 |  arg1 morph delete ];     color: Color transparenttestOneDependsOnParentOneStaticInsideStatic  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := 20.  tmp1 := self newBrickWithStaticExtent.  tmp2 := self newBrickFullHeightAndWidthDependsOnParent: 100.  tmp3 := GLMBrick new     width: tmp4;     vSpaceFill;     yourself.  tmp1     addBrickBack: tmp2;     addBrickBack: tmp3.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp2 brickBounds equals: (0 @ 0 extent: (self staticWidth - tmp4) @ self staticHeight).  self assert: tmp3 brickBounds equals: ((self staticWidth - tmp4) @ 0 extent: tmp4 @ self staticHeight)testBuildingNestedComposites  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list.        arg1 text.        arg1 composite: [:arg2 |  arg2 text.              arg2 list ] ].  tmp1 startOn: 42.  self assert: ((tmp1 paneNamed: #one) presentations isKindOf: GLMCompositePresentation).  self assert: (tmp1 paneNamed: #one) presentations size equals: 3.  self assert: ((tmp1 paneNamed: #one) presentations last isKindOf: GLMCompositePresentation).  self assert: (tmp1 paneNamed: #one) presentations last size equals: 2initializeAnnouncementForDataSource  tableModel announcer when: GLMTreeMorphSelectionChanged do: [:arg1 |  tableModel glamourPresentation announcer suspendAllWhile: [ tableModel glamourPresentation selection: arg1 selectionValue.              tableModel glamourPresentation selectionPath: arg1 selectionPathValue ] ].  tableModel announcer when: GLMTreeMorphStrongSelectionChanged do: [:arg1 |  tableModel glamourPresentation strongSelection: arg1 strongSelectionValue ].  tableMorph     onAnnouncement: FTStrongSelectionChanged send: #strongSelection: to: tableModel;     onAnnouncement: FTSelectionChanged send: #selection: to: tableModel.  self installActionsOnModel: tableModel fromPresentation: tableModel glamourPresentation.  self installKeystrokeActionsOnMorph: tableMorph fromPresentation: tableModel glamourPresentationdefaultAmountToShow  ^500containerNode  ^containerNodecondition  ^conditionwidthDependency: arg1  self widthDependencies add: arg1isClean: arg1  ^arg1 isWidthCleanopenInExternalWindowOn: arg1  ^self openOn: arg1 inExternalWindowWith: self defaultRendereraddStatusbar  self hasStatusbar: trueaddTextSegment: arg1  self textSegments add: arg1layoutOwnerOf: arg1  arg1 owner ifNotNil: [ self layoutAround: arg1 owner inContext: arg1 ]testRawSelectionAvailableWhenNoSelectionActive  | tmp1 |  tmp1 := GLMPresentation new.  tmp1 acceptsSelection: false.  tmp1 selection: 1.  self assert: tmp1 selection equals: nil.  self assert: tmp1 rawSelection equals: 1defaultValidate: arg1 on: arg2  arg2 name == #selection ifFalse: [ ^true ].  self entity ifNil: [ ^false ].  self allDisplayedDo: [:arg3 |  arg3 = arg1 ifTrue: [ ^true ] ].  ^falsepostCopy  super postCopy.  announcerObjects := nilpushPane: arg1 smooth: arg2  self invariant.  pagesCount := pagesCount + 1.  self size = 1 ifTrue: [ firstVisiblePageIndex := 1.        lastVisiblePageIndex := 1.        selectedPageIndex := 1 ] ifFalse: [ self actualNumberOfVisiblePages < self numberOfVisiblePages ifTrue: [ lastVisiblePageIndex := lastVisiblePageIndex + 1 ] ].  self notifyPagePushed: arg1 scrollTo: true smooth: arg2.  self size = 1 ifTrue: [ self notifySelectedPageChanged ].  self invariantbindingsStrategy  ^bindingsStrategytext  ^self label textcontentBrick  ^contentBrickbeTransparent  self rubricBackgroundColor: Color transparentrenderGlamorouslyOn: arg1  ^arg1 renderAccordionCompositePresentation: self compositeheightParentDependency: arg1  | tmp1 |  arg1 owner ifNil: [ Exception signal: 'My height depends on parent, but it is nil' ].  tmp1 := arg1 owner subbricks inject: arg1 owner innerBounds height into: [:arg2 :arg3 |  arg3 isHeightClean ifTrue: [ arg3 layout vState isOnParent not | (self hasHeightRestrictions: arg3) ifTrue: [ arg2 - arg3 outerBounds height ] ifFalse: [ arg2 ] ] ifFalse: [ arg2 ] ].  ^(tmp1 * arg1 layout vPercent / 100) ceilingglamourValueWithArgs: arg1  (arg1 first pane port: self portSymbol) value: (self valueBlock glamourValueWithArgs: arg1)borderColor  ^Color r: 48 g: 194 b: 240 range: 255title  ^titlevState  ^self layout vStatepane  ^self port panedataSourceUpdated: arg1  tableModel ifNotNil: [ self unsubscribeDataSource: tableModel ].  tableModel := arg1 newDataSource.  self initializeAnnouncementForDataSourcetestInclues  | tmp1 tmp2 |  tmp2 := GLMSimplePort new.  tmp1 := GLMTransmissionContext new.  tmp1 addPort: tmp2.  self assert: (tmp1 includesPort: tmp2)setConstrainedPosition: arg1 hangOut: arg2  | tmp1 tmp2 tmp3 |  self owner ifNil: [ ^self ].  tmp1 := 0 @ 0 extent: self outerBounds extent.  tmp3 := self owner paddingLeft @ self owner paddingTop extent: self owner innerBounds extent.  tmp2 := (arg1 + tmp1 corner min: tmp3 corner) - tmp1 corner max: tmp3 origin.  self position: tmp2.  self changedwhen: arg1 do: arg2  self announcer when: arg1 do: arg2titleText: arg1  titleText := arg1.  self titleBrick ifNotNil: [ self titleBrick text: self titleText ]testDirectEventsPropagationTransformation  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp3 := 0.  tmp1 := GLMDynamicPresentation new.  tmp1 entity: '42'.  tmp1 display: [:arg1 |  tmp2 := GLMRubricTextPresentation new ].  tmp1 currentPresentation.  tmp2 announcer when: GLMContextChanged do: [:arg2 |  tmp3 := tmp3 + 1 ].  tmp4 := GLMSimplePort new     name: #portOne;     value: 1.  tmp5 := GLMSimplePort new     name: #portTwo;     value: 2.  tmp1 outerPortEvent: (GLMPortEvent on: tmp4 previouslyValued: tmp5).  self assert: tmp3 equals: 1adjustLayoutBounds  testDefault  (GLMLoggedObject withAllSubclasses reject: [:arg1 |  arg1 allMethods anySatisfy: [:arg2 |  arg2 sendsSelector: #subclassResponsibility ] ]) do: [:arg1 |  self assert: arg1 new logger identicalTo: GLMLogger nullInstance ]render: arg1  container := GLMMorphic containerMorph.  container     changeTableLayout;     listDirection: #leftToRight;     vResizing: #spaceFill;     hResizing: #spaceFill.  container addMorphBack: (self morphFrom: arg1).  arg1 when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  ^containernewDataSource  ^newDataSourcesubmitForm  self announce: (GLMFormSubmitted new result: self asFormValue)postCopy  super postCopy.  pane := nil.  self flag: 'self unregisterFromAllAnnouncements.'.  updateActions := updateActions collect: [:arg1 |  arg1 copy           presentation: self;           yourself ].  rawSelectionTransmissions := rawSelectionTransmissions collect: [:arg1 |  arg1 copy ].  rawSelectionTransmissions do: [:arg2 |  arg2 originReferences do: [:arg3 |  arg3 port presentation: self ] ].  rawSelectionTransmissions do: [:arg2 |  arg2 destination presentation: self ]execute: arg1 withArguments: arg2 callback: arg3 priority: arg4  ^self execute: arg1 withArguments: arg2 callback: arg3 priority: arg4 delay: 0initializeColumns  self removeAllBricks.  self entity isNil | self table isNil ifTrue: [ ^self ].  self table columns do: [:arg1 |  self addColumn: arg1 ].  self updateWidthPercentagecircleButtonSize  ^22populate: arg1 on: arg2 entitled: arg3 with: arg4  self addAction: (GLMGenericAction new           action: (GLMPortUpdater new                 portSymbol: arg1;                 valueBlock: arg4;                 yourself);           shortcut: arg2;           title: arg3;           yourself)outerPortEvent: arg1  super outerPortEvent: arg1.  arg1 hasChanged ifTrue: [ (self transmissions select: [:arg2 |  (arg2 originatesAt: arg1 port) and: [ (arg1 transmissionContext includesPort: arg2 destination) not ] ]) do: [:arg2 |  arg2 transmitIn: arg1 transmissionContext copy ] ]isFocusedMorphVisibleAt: arg1  | tmp1 |  tmp1 := self focusedViewAt: arg1.  tmp1 ifNil: [ ^false ].  ^tmp1 isInWorldpagerModel: arg1  pagerModel := arg1.  self pagerModel announcer when: GLMPagePushed send: #onPagePushed to: self.  self pagerModel announcer when: GLMPagePoped send: #onPagePoped to: self.  self initializeShortcuts.  self scrollBrick: self newScrollBrick.  self pagerBar: self newPagerBarportName  ^portNameseparatorAfter: arg1  separatorAfter := arg1stackedVerticallyArrangement  ^self arrangement: (GLMStackedVerticallyArrangement of: self)styled: arg1  self setProperty: #phlowStyled toValue: arg1initialize  super initialize.  self themer: self themer popupEditorBorderThemer themerreceive: arg1 in: arg2  self value: arg1 value in: arg2specificTableMorphInitializiation  self specificTableMorphColumnsInitialization.  super specificTableMorphInitializiationtestDiminishToLeft  | tmp1 tmp2 |  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  tmp1 := pagerModel numberOfVisiblePages.  tmp2 := pagerModel firstVisiblePageIndex.  self assert: pagerModel numberOfVisiblePages equals: tmp1.  self assert: pagerModel numberOfVisiblePages equals: pagerModel lastVisiblePageIndex - tmp2 + 1.  self assert: pagerModel firstVisiblePageIndex equals: tmp2.  [ tmp1 > 1 ] whileTrue: [ pagerModel diminishToLeft.        tmp1 := tmp1 - 1.        self assert: pagerModel numberOfVisiblePages equals: tmp1.        self assert: pagerModel numberOfVisiblePages equals: pagerModel lastVisiblePageIndex - tmp2 + 1.        self assert: pagerModel firstVisiblePageIndex equals: tmp2 ].  (1 to: 3) do: [:arg1 |  pagerModel diminishToLeft.        self assert: pagerModel numberOfVisiblePages equals: 1.        self assert: pagerModel numberOfVisiblePages equals: pagerModel lastVisiblePageIndex - tmp2 + 1.        self assert: pagerModel firstVisiblePageIndex equals: tmp2 ]showOnly: arg1  amountToShowBlock := arg1setPosition: arg1  self changedWith: [:arg2 |  arg2           translateXTo: arg1 x;           leftPosition: arg1 x;           doNotLayoutDuring: [ arg2 width: arg1 y - arg1 x.              arg2 wrappedBounds markWidthClean ] ].  self pagerModel notifyScrollerBoundsChanged: arg1checkbox: arg1  arg1 cull: self checkboxchanged  self brickRoot changedinvalidate  pageAt: arg1  ^(self pages at: arg1) actualPageMorphpresentation  ^presentationacceptsSelection  ^acceptsSelection ifNil: [ acceptsSelection := true ]notifyScrollPositionChanged: arg1  self notifyScrollPositionChanged: arg1 callback: nilchangedText: arg1  text := arg1.  self changed: #texthShrinkWrap  self width: [ self vPadding + (self icon isNil & self hoverIcon isNil ifTrue: [ 0 ] ifFalse: [ self icon ifNil: [ self hoverIcon width ] ifNotNil: [ self hoverIcon ifNil: [ self icon width ] ifNotNil: [ self icon width max: self hoverIcon width ] ] ]) ]meetsCondition  < debuggingStone: #transmissionCondition label: 'Transmission condition'>  | tmp1 |  tmp1 := self originReferences size = 1 ifTrue: [ self originReferences first value ] ifFalse: [ GLMMultiValue withAll: (self originReferences collect: [:arg1 |  arg1 value ]) ].  ^self condition glamourValue: tmp1isReadMode  ^self isEditMode notpresentation  ^presentationdisplayedValue  ^cachedDisplayedValuebuttonFor: arg1  ^((self canDisplayChildrenOf: arg1) and: [ self hasChildren: arg1 ]) ifTrue: [ arg1 generateButton ] ifFalse: [ self class emptyMorph ]testUpdatePresentationTitle  < expectedFailure>  browser panes first presentations first title: 'something'.  browser panes first presentations first update.  self assert: listLabelMorph contents equals: 'something'selectedColor  ^selectedColorband  ^bandalign: arg1 in: arg2 anchorPoint: arg3 inContext: arg4  | tmp1 |  self = arg4 ifTrue: [ ^self ].  arg2 subbricks size = 1 & arg4 isNil ifTrue: [ GLMVerticalLinearLayout uniqueInstance align: arg1 in: arg2 anchorPoint: arg3 inContext: self ].  tmp1 := arg1 layout vAlign.  tmp1 = #none ifTrue: [ ^self ].  tmp1 = #center ifTrue: [ ^arg1 translateY: ((arg2 innerBounds height - arg1 outerBounds height) / 2) asInteger ].  tmp1 = #bottom ifTrue: [ ^arg1 translateY: (arg2 innerBounds height - arg1 outerBounds height) asInteger ]actOnPresentationToolbarUpdated: arg1  | tmp1 |  tmp1 := arg1 presentation.  contentMorph updatePageAtIndex: 1 withLabel: (self titleOrIconOf: tmp1 in: contentMorph) toolbar: (self renderToolbarForPresentation: tmp1 inMorph: contentMorph) action: (self labelActionBrickFor: tmp1)addItemMorph: arg1 before: arg2  self addBrickBackNoLayout: arg1 before: arg2.  self setBoundsOf: arg1 before: arg2.  (self isPartiallyVisible: arg1) ifFalse: [ self removeBrickNoLayout: arg1.        ^nil ].  arg1 brickBounds top < 0 ifTrue: [ self moveAllSubbricksBy: arg1 brickBounds top negated ] ifFalse: [ (self getIndex: arg1) = 1 ifTrue: [ self moveAllSubbricksBy: arg1 brickBounds top negated ] ].  ^arg1selectionPath  ^(self pane port: #selectionPath) valueuseHorizontalLinearLayout  self layout: GLMHorizontalLinearLayout uniqueInstanceaction: arg1  action := arg1testPastingUpdatesTextPort  | tmp1 tmp2 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text display: '' ].  window := tmp1 openOn: 42.  tmp2 := self find: RubScrolledTextMorph in: window.  Clipboard clipboardText: '42'.  tmp2 textArea editor paste.  self assert: (tmp1 pane port: #text) value equals: '42'when: arg1  self condition: arg1normalBorderStyleFor: arg1  ^self theme tabLabelNormalBorderStyleFor: arg1column: arg1 size: arg2  ^self addColumn: arg1 size: arg2changePortsAccordingToPaneMapping: arg1 fromOldBrowser: arg2 toNewBrowser: arg3  | tmp1 |  self destination: (self destination copyAccordingToPaneMapping: arg1 inNewBrowser: arg3).  self originReferences do: [:arg4 |  tmp1 := arg4 port copyAccordingToPaneMapping: arg1 inNewBrowser: arg3.        arg4 port: tmp1 ]statusbarPane  ^statusPaneselectionTransmission  ^self rawSelectionTransmissionFor: #selection ifNone: [ nil ]setUp  super setUp.  announcer := GLMAnnouncer newdisplayFormat: arg1  displayFormat := arg1testSelectedText  | tmp1 |  tmp1 := GLMRubricTextPresentation new.  self assert: tmp1 selectedText equals: ''.  tmp1 selectedTextBlock: [ 'selection' ].  self assert: tmp1 selectedText equals: 'selection'stepCondition: arg1  stepCondition := arg1testTopMarginParentDependency  | tmp1 tmp2 tmp3 |  tmp2 := 10.  tmp1 := self newBrickWithStaticExtent.  tmp3 := self newBrickFullHeightAndWidthDependsOnParent: 100.  tmp3 marginTop: tmp2.  tmp1 addBrickBack: tmp3.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp3 extent equals: self staticExtent - (0 @ tmp2).  self assert: tmp3 brickBounds equals: (0 @ tmp2 corner: self staticExtent)heightState  ^heightState ifNil: [ heightState := #dirty ]isWidthDirty  ^self brick wrappedBounds isWidthDirtyshouldUseCache  ^self parameters at: 'shouldUseCache' ifAbsent: [ false ]east  direction := EastscrollButtonIconRenderBlock  ^scrollButtonIconRenderBlockhasId  ^id notNilfont: arg1  font := arg1.  arg1 ifNil: [ self updateFont ].  familyName := font familyName.  fontSize := font pointSizeensureReplacePresentationsStrategy  self transmissionStrategy class = GLMReplacePresentationsStrategy ifFalse: [ self transmissionStrategy: (GLMReplacePresentationsStrategy of: self) ]browser: arg1  browser := arg1testRightFloatingMySelfDependencyWithMargin  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := 10.  tmp3 := #right.  tmp1 := self newBrickWithStaticExtent.  tmp4 := self newBrickWithSmallStaticExtent.  tmp4 layout floating: tmp3.  tmp4 marginRight: tmp2.  tmp1 addBrickBack: tmp4.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp4 extent equals: self staticSmallExtent.  self assert: tmp4 brickBounds equals: ((self staticWidth - tmp2 - self staticSmallWidth) @ 0 extent: self staticSmallExtent)resume  process ifNotNil: [ process resume ]displayLogic  ^self valueOfProperty: #phlowDisplay ifAbsent: [ #yourself ]titleAction  ^self titleActionBlock ifNil: [ nil ] ifNotNil: [:arg1 |  arg1 glamourValue: self ]renderGlamorouslyOn: arg1  self deprecated: 'Use GLMPharoMethodPresentation GLMPharoScriptPresentation instead.'.  self registerAnnouncements.  ^arg1 renderSmalltalkCodePresentation: selfaddContentBricks  self onCreated.  self announce: #onCreated event: self triggerBricktestTransientValue  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     fromOutsidePort: #entity;     to: #one port: #entity.  tmp1 transmit     from: #one port: #entity;     to: #two;     andShow: [:arg1 |  arg1 text ].  tmp1 startOn: 42.  self assert: (tmp1 panes first port: #entity) value equals: 42.  self assert: (tmp1 panes last port: #entity) value equals: 42.  (tmp1 panes first port: #entity) transientValue: 43.  self assert: (tmp1 pane port: #entity) value equals: 42.  self assert: (tmp1 panes first port: #entity) value equals: 42.  self assert: (tmp1 panes last port: #entity) value equals: 43.  (tmp1 pane port: #entity) transientValue: 44.  self assert: (tmp1 pane port: #entity) value equals: 42.  self assert: (tmp1 panes first port: #entity) value equals: 44.  self assert: (tmp1 panes last port: #entity) value equals: 44column: arg1 evaluated: arg2 width: arg3 tags: arg4 sortedBy: arg5  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           width: arg3;           tags: arg4;           sortBlock: arg5 yourself)composite  ^compositebeMode: arg1  self hoverAction: [:arg2 :arg3 |  | tmp1 |        tmp1 := (self isModifierPressed: arg3) ifTrue: [ 0 ] ifFalse: [ self hintDelay ].        self startStepping: #openHintPopup: at: Time millisecondClockValue + tmp1 arguments: {arg1} stepTime: 3000 ]containerTree  ^containerTreefocusedBorderColor  ^self color peterRiverremoveBrick: arg1  self band removeBrick: arg1isVShrinkWrap  ^self vState isOnChildrenenableFilter  self parameters at: 'isFilterable' put: truepresentation: arg1  presentation := arg1passivelyFrom: arg1 port: arg2  ^self passivelyFrom: (GLMPortIdentifier pane: arg1 port: arg2)selectionInterval  ^self valueOfProperty: #phlowSelectionInterval ifAbsent: [ 1 to: 0 ]spawn: arg1 iconName: arg2 entitled: arg3  self spawn: arg1 icon: (self iconNamed: arg2) entitled: arg3innerPortEvent: arg1  createFastTable  ^FTTableMorph newleft  ^self subclassResponsibilityrenderStacker: arg1  ^GLMMorphicStackerRenderer render: arg1 from: selfinvalidateLayout  brick  ^selfbox  ^checkBrickisHFilling  ^hResizing = #spaceFillannouncer  ^selftextMorphForModel: arg1  ^(RubPluggableTextMorph on: arg1 text: #text accept: #accept:notifying: readSelection: #selection menu: #menu:shifted:)     changedAction: [:arg2 |  arg2 asString trimBoth ifNotEmpty: [ arg1 text: arg2 ] ];     onKeyStrokeSend: #keystroke:from: to: arg1;     layoutFrame: LayoutFrame identity;     vResizing: #spaceFill;     hResizing: #spaceFill;     color: self theme backgroundColor;     detachAllKeymapCategories;     yourselfcollectionToDragPassenger: arg1  ^arg1 size = 1 ifTrue: [ arg1 anyOne ] ifFalse: [ arg1 ]toolbarMorph: arg1  toolbarMorph := arg1scrollPane: arg1  scrollPane := arg1.  self updatePositiondefaultSortBlockForPresentation: arg1  ^[:arg2 :arg3 |  (arg1 column: self valueFor: arg2) asString < (arg1 column: self valueFor: arg3) asString ]renderPharoScriptPresentation: arg1  ^GLMMorphicPharoScriptRenderer render: arg1 from: selfisBrick  ^falsemodelFor: arg1  ^GLMRubricTextModel new     glamourPresentation: arg1;     yourselfbeSuccess  self beMode: #beSuccessnewIndex  ^newIndexrender: arg1  | tmp1 tmp2 tmp3 |  window := GLMOSWindowWorldMorph new model: arg1.  self installActionsOnModel: window fromPresentation: arg1.  self installKeystrokeActionsOnMorph: window fromPresentation: arg1.  self setLabelOf: window for: arg1.  tmp2 := 4.  tmp3 := 0.  tmp1 := self renderToolbarForPresentation: arg1 inMorph: window.  tmp1 hResizing: #shrinkWrap.  window toolbarBox: tmp1.  tmp3 := self handlePotentialStatusbarFor: arg1.  window addMorph: (self renderObject: arg1) fullFrame: ((0 @ 0 corner: 1 @ 1) asLayoutFrame           topLeftOffset: 0 @ tmp2;           bottomRightOffset: 0 @ tmp3).  self setPotentialBackgroundColorFor: arg1.  arg1 when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  arg1 when: GLMWindowRequest send: #actOnWindowRequest: to: window.  arg1 watcherPane notNil ifTrue: [ GLMMorphicWatcherRenderer render: arg1 watcherPane from: self renderer ].  ^windowhasItems  ^self model notNil and: [ self model count > 0 ]defaultBorderWidth  ^5currentBindings  self withBindingsDo: [:arg1 |  ^arg1 copy ]scrollBarHeight  ^self theme scrollbarThicknessbrickRoot: arg1  self brickRoot ifNotNil: [ self removeMorph: self brickRoot.        brickRoot := nil ].  brickRoot := arg1.  self addMorphBack: brickRoot.  brickRoot onThemerChangedexecute: arg1 withArguments: arg2 callback: arg3 priority: arg4 delay: arg5  self terminate.  callback := arg3.  process := [ | tmp1 |  arg5 > 0 ifTrue: [ arg5 milliSeconds wait ].  tmp1 := arg1 valueWithEnoughArguments: arg2.  UIManager default defer: [ self complete: tmp1 callback: arg3 ] ] newProcess.  process priority: arg4.  process resume.  ^selfshortcutAsString  self shortcut ifNil: [ ^'' ].  ^self keymap printOsRepresentationwidthChildrenDependency: arg1  ^arg1 paddingLeft + arg1 paddingRight + (((self nonFloatSubbricks: arg1) detectMax: [:arg2 |  arg2 outerBounds width ]) ifNil: [ 0 ] ifNotNil: [:arg3 |  arg3 outerBounds width ])dropElements: arg1 index: arg2  self glamourPresentation accept: (self collectionToDragPassenger: arg1) droppedOnItem: (self elementOrZeroAt: arg2)themer: arg1  self setProperty: #brickThemer toValue: arg1.  self themerChangedstylerDecorator: arg1  stylerDecorator := arg1selectionValue  ^selectionValueselect  self owner ifNil: [ ^self ].  self minWidth: [ self owner width min: (self hasSubbricks ifTrue: [ self label layout maxWidth brickValue: self label ] ifFalse: [ 0 ]) ].  self owner doLayoutForcetestEntity  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list ].  tmp1 startOn: ($a to: $d).  self assert: ((tmp1 paneNamed: #one) port: #entity) value equals: ($a to: $d)vSpaceFill: arg1  super vSpaceFill: arg1.  self label vSpaceFillupdateStyle  self bar color: self scrollBarColor.  self layout floating: self scrollbarPosition.  self width: self scrollbarWidth.  self layout floating = #right ifTrue: [ self marginRight: self scrollbarOffset ].  self layout floating = #bottom ifTrue: [ self marginBottom: self scrollbarOffset ].  self layout floating = #left ifTrue: [ self marginLeft: self scrollbarOffset ].  self layout floating = #top ifTrue: [ self marginTop: self scrollbarOffset ]calculateMaxVelocity  ^(self height * 0.9) asIntegertestTwoTransmissionsWithOnlyOneEvent  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two;     column: #three.  tmp1 transmit     to: #two;     from: #one;     andShow: [:arg1 |  arg1 list ].  tmp1 transmit     to: #three;     from: #two;     andShow: [:arg1 |  arg1 text ].  self assert: tmp1 transmissions size equals: 2.  self assertEmpty: (tmp1 paneNamed: #one) presentations.  self assertEmpty: (tmp1 paneNamed: #two) presentations.  self assertEmpty: (tmp1 paneNamed: #three) presentations.  ((tmp1 paneNamed: #one) port: #selection) value: 42.  self assert: ((tmp1 paneNamed: #two) port: #entity) value equals: 42.  self assertEmpty: (tmp1 paneNamed: #one) presentations.  self assert: (tmp1 paneNamed: #two) presentations size equals: 1.  self assert: (tmp1 paneNamed: #two) matchingPresentations size equals: 1.  self assertEmpty: (tmp1 paneNamed: #three) presentations.  self assertEmpty: (tmp1 paneNamed: #three) matchingPresentationsshowOn: arg1  self addTransmission: (GLMTransmission new           ensureReplacePresentationsStrategy;           destination: (self resolveDestinationPort: arg1);           yourself)andShow: arg1  self ensureReplacePresentationsStrategy.  self transmissionStrategy presentationsFactory: arg1.  self origins isEmpty ifTrue: [ self from: #outer port: #entity ]newTextEditField  ^GLMRubEditingAreaBrick new     wrapped: false;     hShrinkWrap;     vShrinkWrap;     withoutBorder;     withoutMargins;     beForSmalltalkCode;     text: self textModel;     yourselftestBundleTransmission  | tmp1 tmp2 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two;     column: #three.  tmp1 transmit     from: #one port: #port1;     from: #two port: #port2;     to: #three -> #port3;     andShow: [:arg1 |  arg1 list.        arg1 table ].  tmp2 := tmp1 transmissions first.  self assert: tmp1 transmissions size equals: 1.  self assert: tmp2 browser identicalTo: tmp1.  self assert: (tmp2 transmissionStrategy isKindOf: GLMReplacePresentationsStrategy).  self assert: tmp2 origins size equals: 2.  self assert: tmp2 origins first equals: ((tmp1 paneNamed: #one) port: #port1).  self assert: tmp2 origins last equals: ((tmp1 paneNamed: #two) port: #port2).  self assert: tmp2 destination equals: ((tmp1 paneNamed: #three) port: #port3).  self assert: (tmp2 transmissionStrategy presentations isKindOf: GLMCompositePresentation).  self assert: tmp2 transmissionStrategy presentations size equals: 2testMatching  | tmp1 |  tmp1 := GLMPresentation new.  self assert: tmp1 usesImplicitNotNil.  (tmp1 pane port: #entity) value: (GLMMultiValue withAll: #(nil 1)).  self assert: tmp1 matches not.  (tmp1 pane port: #entity) value: 1.  self assert: tmp1 matches.  tmp1 useExplicitNotNil.  self assert: tmp1 usesImplicitNotNil not.  (tmp1 pane port: #entity) value: (GLMMultiValue withAll: #(nil 1)).  self assert: tmp1 matches.  (tmp1 pane port: #entity) value: 1.  self assert: tmp1 matches.  tmp1 condition: [:arg1 |  arg1 > 1 ].  tmp1 useImplicitNotNil.  self assert: tmp1 usesImplicitNotNil.  (tmp1 pane port: #entity) value: nil.  self assert: tmp1 matches not.  (tmp1 pane port: #entity) value: 1.  self assert: tmp1 matches not.  (tmp1 pane port: #entity) value: 2.  self assert: tmp1 matches.  tmp1 useExplicitNotNil.  (tmp1 pane port: #entity) value: 1.  self assert: tmp1 matches not.  (tmp1 pane port: #entity) value: 2.  self assert: tmp1 matches.  self assert: tmp1 usesImplicitNotNil not.  [ (tmp1 pane port: #entity) value: (GLMMultiValue withAll: #(nil 1)).  tmp1 matches.  self signalFailure: 'Should have raised error' ] on: MessageNotUnderstood do: [:arg2 |  self assert: arg2 message selector equals: #>.        self assert: arg2 message arguments equals: (Array with: 1) ]widthChildrenDependency: arg1  ^arg1 paddingLeft + arg1 paddingRight + ((self nonFloatSubbricks: arg1) detectSum: [:arg2 |  arg2 outerBounds width ])focusedPageIndex  ^focusedPageIndexisSearchable  ^self parameters at: 'isSearchable' ifAbsent: [ false ]openInWindow  window := pagerMorph asBrickedMorph openInWindowselectedStyleFor: arg1  arg1 fillStyle: (self selectedBackgroundStyleFor: arg1).  arg1 borderStyle: (self selectedBorderStyleFor: arg1)scrollbarCornerRadius  ^0name  ^nameextent  ^self brick extenttitleFor: arg1  ^arg1 titleValue ifNil: [ 'Glamorous Browser' ]staticSmallExtent  ^self staticSmallWidth @ self staticSmallHeightfilterOn: arg1  filterBlock := arg1outOfWorld: arg1  GLMPagerPanePreviewMorph remove.  ^super outOfWorld: arg1topLeftCornerShadowOf: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp2 := arg1 shadowWidth.  tmp5 := tmp2 @ tmp2.  tmp4 := tmp5 negated / 2.0.  tmp3 := arg1 brickBounds origin + tmp4 + arg1 shadowOffset.  tmp1 := (self shadowGradientFor: arg1)     origin: tmp3 + (tmp4 * 2 negated);     direction: tmp5 / 1.4 negated;     radial: true;     yourself.  arg2 fillRectangle: (tmp3 extent: tmp5) fillStyle: tmp1presentation  ^presentationscrollButtonIconRenderBlock  ^scrollButtonIconRenderBlockdrawingBounds: arg1  | tmp1 tmp2 |  tmp2 := arg1 shadowOffset.  tmp1 := arg1 brickBounds expandBy: arg1 border widthTop + arg1 shadowWidth.  tmp2 isZero ifFalse: [ tmp1 := tmp1 quickMerge: (tmp1 translateBy: tmp2) ].  ^tmp1size  ^size ifNil: [ 0 ]parentPrototype: arg1  parentPrototype := arg1hAlign  ^hAlign ifNil: [ hAlign := #none ]gtInspectorPanePortsIn: arg1  < gtInspectorPresentationOrder: 50>  (self pane gtInspectorPortsIn: arg1) title: 'Pane ports'paddingBottom: arg1  self padding at: Bottom put: arg1.  self updateCacheglobalClippingBounds  ^self owner ifNotNil: [:arg1 |  self drawingBounds translateBy: arg1 globalBoundsTranslateFactor ] ifNil: [ self drawingBounds ]custom: arg1  self lastTransmission addPresentation: arg1.  ^arg1enable: arg1  isEnabled := arg1marginLeft  ^self margin at: LeftaddRow: arg1 size: arg2  ^(self addRow: arg1)     size: arg2;     span: 0unhoverAction: arg1  unhoverAction := arg1withString: arg1 from: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp6 := self computeOriginFor: arg2.  tmp4 := RubEditingArea new     font: self theme textFont;     updateTextWith: arg1.  tmp2 := tmp4 width + 12 min: self currentWorld width / 3.  tmp3 := tmp6 x + tmp2 > self currentWorld width ifTrue: [ self currentWorld width - tmp2 ] ifFalse: [ tmp6 x ].  tmp5 := (tmp4     beWrapped;     width: tmp2;     yourself) height + 2 min: self currentWorld height / 3.  tmp1 := tmp6 y + tmp5 > self currentWorld height ifTrue: [ self currentWorld height - tmp5 ] ifFalse: [ tmp6 y ].  self updateWithString: arg1 from: arg2.  self     top: tmp1;     left: tmp3;     width: tmp2;     height: tmp5renderObject: arg1  ^self renderer render: arg1rubric: arg1  self morph ifNotNil: [ self removeMorph: self morph ].  self on: arg1browseFullClass  self announce: (GLMTextEditorRequest for: #browseFullClass)renderGlamorouslyOn: arg1  ^arg1 renderStackedVerticallyCompositePresentation: self compositeheightDependency: arg1  self heightDependencies add: arg1doesNotUnderstand: arg1  ^self modules at: arg1 selector ifAbsent: [ super doesNotUnderstand: arg1 ]transmitIn: arg1  wasTransmited := true.  super transmitIn: arg1renderGlamorouslyOn: arg1  ^arg1 renderPane: selflabelActionMorphFor: arg1  ^arg1 titleAction ifNil: [ nil ] ifNotNil: [:arg2 |  ((arg2 isAvailableOn: arg1) and: [ arg2 hasIcon ]) ifTrue: [ MultistateButtonMorph new                 extent: arg2 icon extent;                 activeEnabledOverUpFillStyle: (ImageFillStyle form: arg2 icon);                 setBalloonText: arg2 title;                 addUpAction: [ arg2 actOn: arg1 ] ] ifFalse: [ nil ] ]moveAllSubbricksBy: arg1  self band subbricks do: [:arg2 |  arg2 translateY: arg1 ].  self band translateY: arg1 negatedlayout: arg1  arg1 isWidthDirty ifTrue: [ self widthTraverser layoutAround: arg1 inContext: nil ].  arg1 isHeightDirty ifTrue: [ self heightTraverser layoutAround: arg1 inContext: nil ]testNoDuplicateRegistrationsInFastTableRenderer  | tmp1 |  window := GLMCompositePresentation new     with: [:arg1 |  arg1 fastList ];     openOn: (1 to: 42).  tmp1 := self find: FTTableMorph in: window.  self assertNoDuplicatedAnnouncementsIn: tmp1 announcer.  self assertNoDuplicatedAnnouncementsIn: tmp1 dataSource announcerisActive  ^active ifNil: [ active := true ]testMultipleSelectionWithChangeFromModel  | tmp1 tmp2 tmp3 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list           beMultiple;           display: [:arg2 |  arg2 - 2 to: arg2 ] ].  window := tmp1 openOn: 4.  tmp2 := window submorphs last submorphs first submorphs first submorphs first.  self assert: (tmp2 model roots collect: #item) equals: #(2 3 4) asOrderedCollection.  ((tmp1 paneNamed: #one) port: #selection) value: #(2 3).  self assert: ((tmp1 paneNamed: #one) port: #selection) value asOrderedCollection equals: #(2 3) asOrderedCollection.  (tmp1 pane port: #entity) value: 42.  tmp3 := window submorphs last submorphs first submorphs first submorphs first.  self assert: (tmp3 model roots collect: #item) equals: #(40 41 42) asOrderedCollection.  ((tmp1 paneNamed: #one) port: #selection) value: #(40 41).  self assert: ((tmp1 paneNamed: #one) port: #selection) value asOrderedCollection equals: #(40 41) asOrderedCollection.  self assert: tmp2 ~= tmp3hintDelay  ^hintDelay ifNil: [ hintDelay := 700 ]context: arg1  context := arg1render: arg1  | tmp1 tmp2 |  tmp1 := arg1 matchingPresentations.  tmp1 isEmpty ifTrue: [ ^GLMMorphic emptyMorph ].  (tmp1 size = 1 and: [ tmp1 first hasTitle not ]) ifTrue: [ ^self renderWithTitleOrNil: tmp1 first ].  tabs := LazyTabGroupMorph new.  tabs     vResizing: #spaceFill;     hResizing: #spaceFill;     cornerStyle: (self theme tabGroupCornerStyleIn: nil);     font: self theme buttonFont.  tabs announcer when: LazyTabPageChanged do: [:arg2 |  arg1 announcer suspendAllWhile: [ arg1 pane lastActivePresentation: (arg1 matchingPresentations at: arg2 pageIndex) ] ].  tmp1 do: [:arg3 |  tabs addLazyPage: [ self renderObject: arg3 ] label: (self titleOrIconOf: arg3 in: tabs) toolbar: (self renderToolbarForPresentation: arg3 inMorph: tabs) action: (self labelActionBrickFor: arg3) ].  tmp2 := 1.  tmp1 withIndexDo: [:arg3 :arg4 |  (arg1 pane isLastActivePresentation: arg3) ifTrue: [ tmp2 := arg4 ] ].  tabs announcer suspendAllWhile: [ tabs selectedPageIndex: tmp2 ].  arg1 when: GLMContextChanged send: #actOnContextChanged: to: self.  arg1 when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  arg1 when: GLMPresentationToolbarUpdated send: #actOnPresentationToolbarUpdated: to: self.  ^tabsclose  self foundationBrick delete.  self onClosedbrickDoubleLink: arg1  self setProperty: #brickDoubleLink toValue: arg1withAllSubbricks  ^self allSubbricks     add: self;     yourselfprevious  ^previousasOrderedCollection  ^selfremoveBrickNoLayout: arg1  self band doNotLayoutDuring: [ self band removeBrick: arg1 ]explicitSelection: arg1  self table selectIndex: (self elements indexOf: arg1)worksWithMorphic  ^truefrom: arg1 transformed: arg2  ^(self addActiveOrigin: (self browser resolveOriginPort: arg1)) transformation: arg2mouseUp: arg1  super mouseUp: arg1.  pagerModel recomputeState: isResizing not.  isResizing ifTrue: [ self setWidthAfterResizing ].  isResizing := false.  (self globalBounds containsPoint: arg1 position) ifFalse: [ self setCursorToNormal: arg1 ] ifTrue: [ self setCursorToResizing: arg1 ]sendTo: arg1 from: arg2  self transmissions addLast: (GLMTransmission new           addActiveOrigin: (self resolveOriginPort: arg2);           destination: (self resolveDestinationPort: arg1);           yourself)on: arg1  self removeAllBricks.  arg1 isCollection & arg1 isString not ifFalse: [ self addBrickBack: (self collapsableFor: arg1) ] ifTrue: [ arg1 do: [:arg2 |  self addBrickBack: (self collapsableFor: arg2) ] ]shrinkingWidth  self rubric width: self rubric textArea width.  self onLayouted.  ^self rubric textArea widthrender: arg1  container := GLMMorphic containerMorph.  self renderContainerFor: arg1.  arg1 when: GLMMatchingPresentationsChanged send: #actOnMatchingPresentationChanged: to: self.  (arg1 presentations hasTitle or: [ arg1 presentations hasTitleIcon ]) ifTrue: [ arg1 when: GLMPresentationToolbarUpdated send: #actOnPresentationToolbarUpdated: to: self ].  ^containerhasFilterBlock  ^self parameters at: 'filterBlock' ifPresent: [ true ] ifAbsent: [ false ]do: arg1  ^self presentations do: arg1selectedClassOrMetaClass  ^self selectedBehaviorparentPrototype  ^parentPrototypestaticSmallWidth  ^50 * self currentWorld displayScaleFactorouterWidth: arg1  self brickBounds: (self brickBounds withWidth: arg1 - self marginLeft - self marginRight)scrollUp: arg1  self band translateY: arg1.  self isTopOverscrolled ifTrue: [ self moveBandTop ]hShrinkWrap  super hShrinkWrap.  self label hShrinkWrap.  self dotsBrick hShrinkWrapnewTitleBrick  ^GLMLabelBrick newrowMorphForColumn: arg1 item: arg2 withIndex: arg3  | tmp1 |  tmp1 := OrderedCollection new.  self table columns first == arg1 ifTrue: [ self rowMorphElementsForFirstColumn: arg1 item: arg2 in: tmp1 ].  tmp1 addAll: (self rowMorphElementsForColumn: arg1 glamourColumn node: (self dataFromPresentationItem: arg2) withIndex: arg3).  ^Smalltalk ui theme newRowIn: self currentWorld for: tmp1left  ^GLMNorthDirection uniqueInstanceelementColumn  | tmp1 |  tmp1 := OrderedCollection with: self displayText.  ^(UITheme current newRowIn: self currentWorld for: tmp1) fillStyle: Color veryLightGraytestSelectionTriggeredOnSelectedIndex  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := GLMTabulator new.  tmp1     row: #one;     row: #two.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 dropDownList           display: [:arg2 |  (1 to: arg2) + 10 ];           selectedIndex: 2 ].  tmp1 transmit     from: #one;     to: #two;     andShow: [:arg1 |  arg1 text ].  window := tmp1 openOn: 5.  tmp2 := tmp1 panes first presentations first.  self assert: tmp1 panes second presentations size equals: 1.  tmp3 := tmp1 panes second presentations first.  tmp4 := self findWherePresentationIs: tmp2 in: window.  tmp5 := self findWherePresentationIs: tmp3 in: window.  self assert: tmp4 selectedItem contents equals: '12'.  self assert: tmp5 text asString equals: '12'glamourColumn: arg1  glamourColumn := arg1asMorph  ^self asBrickedMorphselectionAct: arg1 icon: arg2 entitled: arg3  self addSelectionAction: (GLMGenericAction new           action: arg1;           icon: arg2;           title: arg3;           yourself)presentation  ^GLMCompositePresentation new with: [:arg1 |  | tmp1 tmp2 |        tmp1 := arg1 text.        tmp2 := RubPlainSegmentMorph from: 400 to: 746.        tmp2 color: (Color green alpha: 0.3).        tmp2 setBalloonText: 'This sentence should be removed. Click on it to remove it'.        tmp2 when: #mouseDown send: #value to: [ tmp2 textArea selectFrom: tmp2 firstIndex to: tmp2 lastIndex.              tmp2 textArea replaceSelectionWith: ''.              tmp2 delete ].        tmp1 addTextSegment: tmp2 ]anchorBrick  ^anchorBrickouterBounds  ^self wrappedBounds outerBoundsvariableBindings: arg1  variableBindings := arg1column: arg1 evaluated: arg2 styled: arg3  self addColumn: (GLMPhlowTableColumn new           title: arg1;           computation: arg2;           style: arg3)textFieldHeight  ^customHeight ifNil: [ self textArea height ] ifNotNil: [ customHeight brickValue: self ]resetTagsToFilterBy  tagsToFilterBy := OrderedCollection new.  self changed: #rootNodesselected: arg1  self isSelected ifTrue: [ self beSelected ] ifFalse: [ self beNormal ]onClosed  tagsFor: arg1 to: arg2  ^self tagsFor: arg1 fromProvider: self to: arg2forbidToAnnouncePresentationsChanged: arg1  self forbid: arg1 toAnnounce: GLMPresentationsChangedextent  ^self brickBounds extenthasUnacceptedEdits: arg1  hasUnacceptedEdits := arg1.  self announce: RubEditsStateChangedInModel newtestEmbeddedBrowserRefreshesRendering  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := GLMTabulator new.  tmp1     row: #content;     row: #details.  tmp1 transmit     to: #content;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 ] ].  tmp1 transmit     from: #content;     to: #details;     andShow: [:arg1 |  arg1 text ].  tmp1 transmit     from: #content;     toOutsidePort: #selection.  tmp2 := GLMFinder new.  tmp2 show: [:arg1 |  arg1 custom: tmp1 ].  window := tmp2 openOn: 42.  tmp3 := tmp2 panes first presentations first.  tmp6 := tmp3 panes first.  tmp7 := tmp3 panes second.  (tmp6 port: #selection) value: 41.  tmp4 := self findWherePresentationIs: tmp7 presentations first in: window.  self assert: tmp4 model getText equals: '41'.  (tmp6 port: #selection) value: 42.  self assert: tmp3 identicalTo: tmp2 panes first presentations first.  self assert: tmp7 identicalTo: tmp3 panes second.  self assert: tmp7 presentations first text asString equals: '42'.  tmp5 := self findWherePresentationIs: tmp7 presentations first in: window.  self assert: tmp5 model getText asString equals: '42'isVShrinking  ^vResizing = #shrinkWrapsession  ^sessionsendEvent: arg1 to: arg2  arg2 onLayoutEvent: arg1withWidth: arg1  self wrappedBounds width: arg1newScrollBrick  ^GLMPagerScrollBrick newtestMorphicActionDefinition  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 text morphicAct: [  ] entitled: ''.        arg1 list morphicAct: [  ] entitled: ''.        arg1 tree morphicAct: [  ] entitled: '' ].  tmp1 startOn: #(42).  tmp1 panes first presentations do: [:arg2 |  self assert: arg2 actions size equals: 1 ]outerWidth: arg1  ^self brick wrappedBounds outerWidth: arg1shadowOffset: arg1  self setProperty: #brickShadowOffset toValue: arg1textPosition: arg1  < brickBuilderProperty: #Text name: 'Text position' as: #asSymbol getter: #textPosition model: #GLMUIBuilderTextFieldProperty>  self label textPosition: arg1.  self dotsBrick textPosition: arg1portSymbol: arg1  portSymbol := arg1pagerModel  ^pagerModelprivateMoveBy: arg1  bounds := bounds translateBy: arg1.  fullBounds ifNotNil: [ fullBounds := fullBounds translateBy: arg1 ]hScrollbarInterval  self scrollTarget width = 0 ifTrue: [ ^0 ].  ^self scrollBounds width asFloat / self scrollTarget width min: 1.0defaultSelectionActions  ^{(GLMGenericAction new     title: 'Print it';     action: [:arg1 |  arg1 printSelection ];     shortcut: $p;     yourself) .   (GLMGenericAction new     title: 'Do it';     action: [:arg1 |  arg1 evaluateSelection ];     shortcut: $d;     icon: GLMUIThemeExtraIcons glamorousSpawn;     yourself) .   (GLMGenericAction new     title: 'Inspect it';     action: [:arg1 |  arg1 evaluateSelectionAndDo: [:arg2 |  arg2 inspect ] ];     shortcut: $i;     icon: GLMUIThemeExtraIcons glamorousInspect;     yourself) .   (GLMGenericAction new     title: 'Debug it';     action: [:arg1 |  arg1 debugSelection ];     yourself) .   (GLMGenericAction new     title: 'Profile it';     action: [:arg1 |  arg1 profileSelection ];     yourself)}hasTags  ^self tagsBlock notNilseparatorBefore: arg1  separatorBefore := arg1doItReceiver  ^self glamourPresentation doItReceivernotifySynchronizeScrollTo: arg1  self notifyAll: (GLMPagerSynchronizeScrollAnnouncement new value: arg1)themerChanged  self onThemerChanged.  self subbricks do: #themerChangednewPagerBar  ^GLMPagerBarBrick newproperty: arg1  property := arg1recomputeScrollBar  self sliderBrick ifNotNil: #setWidthAfterResizingnewTitleBrick  ^GLMRubTextAreaBrick newfromOutsidePort: arg1  ^self from: #outer port: arg1testLeftMarginChangeMyselfDependency  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := 10.  tmp3 := 20.  tmp1 := self newBrickWithStaticExtent.  tmp4 := self newBrickWithSmallStaticExtent.  tmp4 marginLeft: tmp2.  tmp1 addBrickBack: tmp4.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp4 extent equals: self staticSmallExtent.  self assert: tmp4 brickBounds equals: (tmp2 @ 0 extent: self staticSmallExtent).  tmp4 marginLeft: tmp3.  tmp4 doLayoutForce.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp4 extent equals: self staticSmallExtent.  self assert: tmp4 brickBounds equals: (tmp3 @ 0 extent: self staticSmallExtent)borderColor  ^self border colorhideOrShowScrollBar  self isScrollable ifTrue: [ self showScrollBar ] ifFalse: [ self hideScrollBar ]initializeItems  self band layoutAfter: [ 1 to: self model count do: [:arg1 |  self band addBrickBack: ((self model morphAt: arg1 convert: nil) asBrick with: [:arg2 |  arg2 brickApi layout vState isOnParent ifTrue: [ arg2 height: 30 ] ]) ] ].  self band hasSubbricks ifFalse: [ self emptyBrick ifNotNil: [:arg2 |  self band addBrickBack: arg2 ] ]direction  ^directionallowAllNil  ^self useExplicitAllNilselectionPathValue  ^selectionPathValuestrongSelection: arg1  self announcer announce: (GLMTreeMorphStrongSelectionChanged new           strongSelectionValue: (self elementAt: arg1 selectedIndex);           yourself)position: arg1  position := arg1testPropagationDuringCircularDependencies  | tmp1 tmp2 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 ] ].  tmp1 transmit     from: #one;     to: #two;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 ] ].  tmp1 transmit     from: #two port: #toSelect;     toOutsidePort: #toSelect.  tmp1 transmit     fromOutsidePort: #toSelect;     to: #one port: #selection.  tmp1 transmit     fromOutsidePort: #toSelect;     to: #two port: #selection.  tmp1 startOn: 100.  ((tmp1 paneNamed: #one) port: #selection) value: 50.  ((tmp1 paneNamed: #two) port: #toSelect) value: 42.  self assert: ((tmp1 paneNamed: #one) port: #selection) value equals: 42.  self assert: ((tmp1 paneNamed: #two) port: #selection) value equals: 42.  tmp2 := GLMLogger instance announcements reverse reject: [:arg3 |  arg3 isKindOf: GLMTransmissionTriggered ].  self assert: (tmp2 first isKindOf: GLMMatchingPresentationsChanged).  self assert: (tmp2 second isKindOf: GLMPresentationsChanged).  self assert: (tmp2 third isKindOf: GLMContextChanged).  self assert: tmp2 third property equals: #toSelect.  self assert: (tmp2 fourth isKindOf: GLMContextChanged).  self assert: tmp2 fourth property equals: #toSelect.  self assert: (tmp2 fourth isKindOf: GLMContextChanged).  self assert: tmp2 fifth property equals: #selection.  self assert: tmp2 fifth value equals: 42.  self assert: (tmp2 fifth presentation isKindOf: GLMListPresentation).  self assert: tmp2 fifth presentation pane name equals: #two.  self assert: tmp2 sixth property equals: #selection.  self assert: tmp2 sixth value equals: 42.  self assert: (tmp2 sixth presentation isKindOf: GLMCompositePresentation).  self assert: tmp2 sixth presentation pane name equals: #tworightAngle: arg1  ^self subclassResponsibilitylayoutPanes  | tmp1 tmp2 |  tmp1 := self computeMorphWidths.  tmp2 := 0 @ 0 extent: 0 @ self paneHeight.  transform submorphs with: tmp1 do: [:arg1 :arg2 |  tmp2 := tmp2 withWidth: arg2.        arg1 bounds: tmp2.        tmp2 := tmp2 translateBy: arg2 @ 0 ]height  ^self brickBounds heightonPagePushed: arg1  self addButton: self newButtonmorphAt: arg1 convert: arg2  self subclassResponsibilityisLastActivePresentation: arg1  ^self lastActivePresentation notNil and: [ arg1 title = self lastActivePresentation title ]withSeparatorBefore  self separatorBefore: truemarkWidthDirty  self widthState: #dirtycontentBackgroundColor  ^Color darkGray darkershowBoundsInHalo  ^truesetUp  super setUp.  pagerModel := GLMPagerModel new.  pagerMorph := GLMPagerBrick new pagerModel: pagerModel yourselfallExpanded  self shouldAllExpand: truetext: arg1  self label text: arg1.  self label text isEmpty ifTrue: [ self removeBrick: self label ] ifFalse: [ (self hasSubbrick: self label) ifFalse: [ self addBrickBack: self label ] ].  self doLayoutForceaddVariableBinding: arg1  self variableBindings at: arg1 key put: arg1 valueannouncer  ^announcer ifNil: [ announcer := GLMAnnouncer new ]allowedBounds  ^allowedBounds ifNil: [ allowedBounds := self globalBounds ]okButton: arg1  okButton := arg1.  self okButton     marginBottom: 3;     text: 'OK';     hAlign: #center;     when: #onClicked do: [ self window ifNotNil: [:arg2 |  arg2 close ] ].  self addBrickBack: self okButtonpopulate: arg1 on: arg2 with: arg3  self addAction: (GLMGenericAction new           action: (GLMPortUpdater new                 portSymbol: arg1;                 valueBlock: arg3;                 yourself);           shortcut: arg2;           yourself)strategy  ^self parameters at: 'strategy' ifAbsent: [ #default ]layoutAround: arg1 inContext: arg2  arg1 isBrick ifFalse: [ ^self ].  (self isClean: arg1) ifTrue: [ ^self ].  arg1 changed.  (self customDependencies: arg1) do: [:arg3 |  | tmp1 |        [ tmp1 := (arg3 brickValue: arg1) brickApi ] on: Exception do: [ tmp1 := nil ].        tmp1 ifNotNil: [ self layoutAround: tmp1 inContext: arg1 ] ].  (self stateOf: arg1) layout: arg1 on: self.  self layoutSubbricks: arg1.  self layoutSubbricks: arg1 owner.  arg1 changedannouncesNewSelection  ^self property = #selection and: [ self presentation selection ~~ self value ]vState  ^vStateinitialize  super initialize.  self     checkBrick: self newCheckboxBrick;     labelBrick: self newLabelBrick;     useHorizontalLinearLayout;     vShrinkWrap;     hShrinkWrap;     enableisBrick  ^trueactOnCompileText: arg1  (arg1 session recompileMethodTo: arg1 presentation text inContext: arg1 context notifying: textMorph) ifTrue: [ arg1 action ifNotNil: [:arg2 |  arg2 value ] ]scrollPositionTop  ^scrollPosition ifNil: [ scrollPosition := 0 ]layout: arg1 on: arg2  arg1 owner ifNil: [ ^arg2 markClean: arg1 ].  (arg2 isDependsOnChildren: arg1 owner) ifTrue: [ Error signal: 'Circle dependency detected!' ].  arg2 layoutOwnerOf: arg1.  arg2 updateDimension: arg1.  arg2 markClean: arg1.  arg2 layoutChildrenOf: arg1update  self scrollDown: 0.  self scrollUp: 0.  self privateScrollPosition: self band brickBounds top.  self band onChildrenLayoutedpostCopy  super postCopy.  self resetAnnouncerresetAnnouncer  super resetAnnouncer.  self presentations do: [:arg1 |  arg1 resetAnnouncer ]shouldStop: arg1  shouldStop := arg1handleKeyStroke: arg1  self allKeystrokeActions detect: [:arg2 |  arg1 commandKeyPressed and: [ arg2 shortcut = arg1 keyCharacter ] ] ifFound: [:arg3 |  self announcer announce: (GLMKeyStroke action: arg3) ]renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderActionListPresentation: selfinstallExportToCSV  self act: [ self exportToCSV ] entitled: 'Export to CSV'text: arg1  (self pane port: #text) value: arg1 copyrender: arg1  | tmp1 |  arg1 panes isEmpty ifTrue: [ ^GLMMorphic emptyMorph ].  tmp1 := LazyTabGroupMorph new.  tmp1     vResizing: #spaceFill;     hResizing: #spaceFill;     cornerStyle: (self theme tabGroupCornerStyleIn: nil);     font: self theme labelFont.  arg1 panes do: [:arg2 |  self flag: 'add toolbar'.        tmp1 addLazyPage: [ GLMMorphicPaneWithoutTitleRenderer new                 renderer: self renderer;                 render: arg2 ] label: (self titleOrIconOf: arg2 presentations in: tmp1) toolbar: (self renderToolbarForPresentation: arg2 presentations inMorph: tmp1) ].  tmp1 selectedPageIndex: 1.  arg1 when: GLMBrowserClosed send: #actOnBrowserClosed: to: self.  ^tmp1shouldExpandToLevel  ^expandLevel isNil notdiminishToLeft  self actualNumberOfVisiblePages = 1 ifTrue: [ ^self ].  self virtualLastVisiblePageIndex: self lastVisiblePageIndex - 1.  self recomputeStatemarkDirty  isDirty := truemarginLeft: arg1  self translateX: arg1 - self marginLeft.  self margin at: Left put: arg1.  self updateCachename: arg1  name := arg1needsStep: arg1  doStep := arg1marginBottom: arg1  self translateY: self marginBottom - arg1.  self margin at: Bottom put: arg1.  self updateCachemouseLeave: arg1  self setCursorToNormal: arg1.  super mouseLeave: arg1shortcut: arg1  arg1 ifNil: [ keymap := nil.        ^self ].  keymap := KMModifier meta + arg1 asKeyCombinationtestHasTitleIcon  | tmp1 |  tmp1 := GLMPresentation new.  self assert: tmp1 hasTitleIcon not.  tmp1 titleIcon: 'something'.  self assert: tmp1 hasTitleIconselectedTab  ^self selectedIndex = 0 ifFalse: [ self tabs at: self selectedIndex ifAbsent: [ nil ] ]select: arg1  self selectinvalidate  self scrollTo: self visibleIndexlayoutFloatingLeft: arg1 in: arg2  | tmp1 tmp2 |  tmp1 := arg1 marginLeft.  tmp2 := arg1 marginTop.  arg1 brickBounds: (tmp1 @ tmp2 extent: arg1 extent).  ^0explicitlySelectItem: arg1  (self selectedItem notNil and: [ self selectedItem = arg1 ]) ifTrue: [ ^self ].  (self selectedItem isNil and: [ arg1 isNil ]) ifTrue: [ ^self ].  arg1 ifNil: [ self selectNodePath: nil.        self selection: nil ].  self roots do: [:arg2 |  arg2 withContentsDo: [:arg3 |  arg3 item = arg1 ifTrue: [ arg3 expandParentPath.                    self selectNodePath: arg3 path.                    ^self ] ] ]hasFixedSizePanes: arg1  hasFixedSizePanes := arg1shadowGradientFor: arg1  ^GradientFillStyle ramp: {(0.0 -> arg1 shadowColor) .         (1.0 -> (arg1 shadowColor alpha: 0))}testPresentationsInmmutability  < expectedFailure>  | tmp1 tmp2 |  tmp1 := GLMPane in: 1.  self assertEmpty: tmp1 presentations.  tmp2 := tmp1 presentations.  tmp2 add: 1.  self assert: tmp2 size equals: 1.  self assertEmpty: tmp1 presentationsallContents  ^self childrenItems collect: [:arg1 |  (self class with: arg1)           parentNode: self;           containerTree: self containerTree;           yourself ]helpText  ^niltestToSendMultipleValue  < expectedFailure>  | tmp1 |  tmp1 := GLMPresentation new.  tmp1 selection: (GLMMultiValue withAll: #(#foo #bar)).  self assert: tmp1 selection equals: #foo.  tmp1 selectionTransformation: [:arg1 :arg2 |  (arg1 , arg2) asSymbol ]inset  ^6scrollerSizeShortcutAction: arg1 second: arg2  arg1 = #left & (arg2 = #left) ifTrue: [ pagerModel enlargeToLeft ].  arg1 = #left & (arg2 = #right) ifTrue: [ pagerModel diminishToRight ].  arg1 = #right & (arg2 = #left) ifTrue: [ pagerModel diminishToLeft ].  arg1 = #right & (arg2 = #right) ifTrue: [ pagerModel enlargeToRight ]scrollBrick  ^scrollBrickwhiteRectangledTags  tagsStyle := #whiteRectangledButtonwithAnnotation  ^withAnnotation ifNil: [ withAnnotation := false ]lastVisiblePageIndex  | tmp1 |  tmp1 := self firstVisiblePageIndex + self numberOfVisiblePages - 1.  ^tmp1 > self size ifTrue: [ self size ] ifFalse: [ tmp1 ]pagerModel  ^pagerModeltestRemovingVariableSizePanesWhenChangingEntity  | tmp1 |  tmp1 := GLMFinder new variableSizePanes.  window := tmp1 openOn: #a.  self assert: window submorphs last scrollTarget submorphs size equals: 2.  tmp1 entity: #b.  self assert: window submorphs last scrollTarget submorphs size equals: 2testMarkerOneChildrenHeight  | tmp1 |  tmp1 := self newBrickWithFullDependsOnChildren.  self markFullyClean: tmp1.  tmp1 wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp1 brickApi.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightDirtytestChildrenBlock  | tmp1 tmp2 |  tmp1 := GLMFinder new.  tmp2 := false.  tmp1 show: [:arg1 |  arg1 tree children: [:arg2 |  tmp2 := true.              #() ] ].  window := tmp1 openOn: ($a to: $d).  self waitUntilUIRedrawed.  self assert: tmp2 equals: trueouterBounds  ^self brick outerBoundsactionList  ^self custom: GLMActionListPresentation newrubricCursorColor  ^self rubricTextColorintercellSpacing: arg1  self parameters at: 'intercellSpacing' put: arg1firstOwnerSuchThat: arg1  self allOwnersDo: [:arg2 |  (arg1 cull: arg2) ifTrue: [ ^arg2 ] ].  ^niltestPanePortTransmissionCallingReceiveIn  | tmp1 tmp2 tmp3 |  tmp1 := GLMTestPane new port: #originPort.  tmp2 := GLMTestPane new port: #destinationPort.  self assertEmpty: tmp2 seenTransmissions.  tmp3 := GLMTransmission new     addActiveOrigin: tmp1;     destination: tmp2;     transformation: [:arg1 |  arg1 + 1 ].  tmp1 value: 41.  tmp3 transmit.  self assert: tmp2 seenTransmissions size equals: 1.  self assert: tmp2 seenTransmissions first origins first value equals: 41.  self assert: tmp2 seenTransmissions first destination identicalTo: tmp2.  self assert: tmp2 value equals: 42doItContext  ^self glamourPresentation doItContextowner: arg1  | tmp1 |  tmp1 := self owner.  self privateOwner: arg1.  arg1 ifNotNil: [ self themerChanged ] ifNil: [ self onRemovedFrom: tmp1 ]newContentMorph  | tmp1 |  tmp1 := GLMPanelMorph new     roundedCorners: #(2 3 4);     changeTableLayout;     layoutInset: 4;     cellInset: 8;     vResizing: #spaceFill;     hResizing: #spaceFill.  tmp1 borderStyle: (self theme tabPanelBorderStyleFor: self).  ^tmp1deselect  self owner ifNil: [ ^self ].  self layoutProperties minWidth: 0.  self owner doLayoutForcetestChangeChildrenInParentAndSubchildren  | tmp1 tmp2 tmp3 |  tmp1 := self newBrickWithFullDependsOnChildren.  tmp2 := self newBrickWithStaticExtent.  tmp3 := self newBrickFullHeightAndWidthDependsOnParent: 100.  tmp1 addBrickBack: tmp2.  tmp2 addBrickBack: tmp3.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: tmp2 extent.  self assert: tmp3 extent equals: tmp2 extent.  tmp2 height: self staticHeight * 2.  tmp2 width: self staticWidth * 2.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp2 extent equals: self staticExtent * 2.  self assert: tmp1 extent equals: tmp2 extent.  self assert: tmp3 extent equals: tmp2 extentdisplay: arg1  self setProperty: #phlowDisplay toValue: arg1allActions  ^self actions , self dynamicActions select: [:arg1 |  arg1 isAvailableOn: self ]sortByColumn: arg1  columnToSortBy := columnToSortBy == arg1 ifTrue: [ nil ] ifFalse: [ arg1 ].  self updateRootshasSubbricks  ^self subbricks isEmpty notcolorBottom: arg1  self color at: Bottom put: arg1shouldShowHeader  ^self parameters at: 'shouldShowHeader' ifAbsent: [ true ]markClean: arg1  arg1 markWidthCleantestPortInitializationFromTransmission  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     fromOutsidePort: #entity;     to: #one port: #entity;     andShow: [:arg1 :arg2 |  arg1 text initialize: [:arg3 |  arg3                 text: 'foo' , arg2 asString;                 selectionInterval: (2 to: 3) ] ].  self assert: (tmp1 panes first port: #text) value equals: nil.  self assert: (tmp1 panes first port: #selectionInterval) value equals: nil.  tmp1 startOn: 42.  self assert: (tmp1 panes first port: #text) value equals: 'foo42'.  self assert: (tmp1 panes first port: #selectionInterval) value equals: (2 to: 3).  (tmp1 pane port: #entity) transientValue: 43.  self assert: (tmp1 panes first port: #text) value equals: 'foo43'.  self assert: (tmp1 panes first port: #selectionInterval) value equals: (2 to: 3).  (tmp1 pane port: #entity) value: 44.  self assert: (tmp1 panes first port: #text) value equals: 'foo44'.  self assert: (tmp1 panes first port: #selectionInterval) value equals: (2 to: 3)morph  | tmp1 |  tmp1 := super morph.  tmp1 editingMode: textModel glamourPresentation editingMode.  tmp1 textFont: textModel glamourPresentation morphicFont.  tmp1 hasUnacceptedEdits: false.  ^tmp1updateHeight: arg1 on: arg2  arg1 withHeight: (arg2 normalizeHeight: (arg2 heightMyselfDependency: arg1) of: arg1)amountToFilterBy  ^nildisplayFormat  ^displayFormat ifNil: [ displayFormat := self glamourPresentation format ]selection  ^(self pane port: #selection) valuerenderBackground: arg1 on: arg2  arg2 drawPolygon: arg1 area vertices color: arg1 color borderWidth: 0 borderColor: Color transparenttext  ^self addBrickBack: self newTextassertHeightClean: arg1  self assert: arg1 wrappedBounds heightState equals: #clean.  self assert: arg1 wrappedBounds isHeightDirty not.  self assert: arg1 wrappedBounds isHeightCleannormalColor: arg1  normalColor := arg1addGrabHandle: arg1  initialize  super initialize.  collection := OrderedCollection newevaluateAndPrintSelection  UIManager default defer: [ textMorph textArea editor printIt ]widthLeft  ^self width at: LeftisNotificationsAllowed  ^isNotificationsAllowed ifNil: [ isNotificationsAllowed := true ]testUpdateRecomputesMatchingPresentations  | tmp1 tmp2 tmp3 |  tmp2 := GLMAnnouncingCollection new.  tmp2 add: 1.  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list when: [:arg2 |  arg2 isEmpty not ] ].  tmp1 startOn: tmp2.  tmp3 := false.  tmp1 panes first when: GLMMatchingPresentationsChanged do: [:arg3 |  tmp3 := true ].  tmp2 removeLast.  tmp1 update.  self assert: tmp3presentation  ^presentationmarkDirty: arg1  self markLayoutDirty: arg1 owner.  arg1 markWidthDirtytestOnePanesShouldUpdateTheRenderedSelectionOnTheTriggerPane  | tmp1 tmp2 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 ] ].  tmp1 transmit     from: #one port: #strongSelection;     toOutsidePort: #toSelect.  tmp1 transmit     fromOutsidePort: #toSelect;     to: #one port: #selection;     transformed: [:arg2 |  arg2 + 1 ].  window := tmp1 openOn: 100.  (tmp1 panes first port: #strongSelection) value: 41.  self assert: ((tmp1 paneNamed: #one) port: #selection) value equals: 42.  tmp2 := self findWherePresentationIs: (tmp1 paneNamed: #one) presentations first in: window.  self assert: tmp2 notNil.  self assert: tmp2 selectedMorph notNilpopup: arg1 event: arg2  < return: #Boolean>  ^arg2 type = #mouseDown and: [ (arg1 isInsideOfPopupBrick: arg2) not ]asFormValue  | tmp1 |  tmp1 := OrderedCollection new.  self subbricks do: [:arg1 |  arg1 asFormValue ifNotNil: [:arg2 |  tmp1 addAll: arg2 asOrderedCollection ] ].  ^tmp1valueBlock  ^valueBlockonSynchronizeScroll: arg1  self scrollTo: arg1 value smooth: falsebounds  ^self globalBoundssortBlock  ^columnToSortBy sortBlock ifNil: [ columnToSortBy defaultSortBlockForPresentation: self glamourPresentation ]row: arg1  ^self addRow: arg1port  ^portrightAngle: arg1  ^arg1 = GLMEastDirection uniqueInstanceisSelected  ^self tabSelector ifNil: [ false ] ifNotNil: [:arg1 |  arg1 selectedTab == self ]perform: arg1 delay: arg2  self execute: [  ] withArguments: {} callback: arg1 delay: arg2defaultInsetBeforeDots  ^1actOnMatchingPresentationsChanged: arg1  GLMWatcherWindow uniqueInstance addContent: [ self renderObject: arg1 pane presentations ]window  ^windowaddBrickFirst: arg1  | tmp1 |  tmp1 := self privateAddBrickFirst: arg1 asBrick.  self privatePrepareBrickAfterAdding: tmp1.  self doLayoutForce.  ^arg1beError  self beMode: #beErrorfamilyName  ^familyNamebasicRoots  ^self glamourPresentation displayValueisDirty  ^isDirty ifNil: [ isDirty := true ]addTab: arg1 selected: arg2  self tabs add: (self newLabelBrick: arg1 selected: arg2).  self updateTabspresentations  ^OrderedCollection newstrongSelection: arg1  (self pane port: #strongSelection) value: (self selectionTransformation glamourValue: arg1)port  ^portformat: arg1  format := arg1testTabsLastActivePresentation  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list.        arg1 text ].  window := tmp1 openOn: 42.  self compositeTabGroup selectedPageIndex: 2.  self assert: tmp1 panes first lastActivePresentation notNil.  self assert: (tmp1 panes first lastActivePresentation isKindOf: GLMRubricTextPresentation)lastActivePresentation  ^lastActivePresentationscrollAtIndex: arg1  self primarySelectionInterval: (arg1 to: arg1 - 1)collectionToDragPassenger: arg1  ^arg1 size = 1 ifTrue: [ arg1 anyOne ] ifFalse: [ arg1 ]assignFocusableMorph: arg1 withPaneAt: arg2  focusedViews at: arg2 put: arg1postCopy  | tmp1 |  super postCopy.  self flag: 'self unregisterFromAllAnnouncements ?'.  presentations := presentations copy.  ports := ports collect: [:arg1 |  tmp1 := arg1 copy.        tmp1 pane: self.        self flag: 'what about value?'.        tmp1 ]popPane  self popPane: falsedeselect  self isSelected ifTrue: [ isSelected := false.        self announce: #onMouseUnhover.        self changed ]titleValue  ^self title glamourValue: self entitysortBlock: arg1  sortBlock := arg1actions: arg1  self deprecated: 'use dynamicActionsOnSelection: for contextual actions, and dynamicActions for presentation-wide actions'.  ^self dynamicActionsOnSelection: arg1presentation  ^presentationscrollUp: arg1  band brickBounds origin x >= 0 ifTrue: [ ^self ].  band brickBounds: (band brickBounds translateBy: arg1 @ 0).  band brickBounds origin x > 0 ifTrue: [ band brickBounds: (band brickBounds translateBy: (band brickBounds origin x @ 0) negated) ]addPaneFrom: arg1  self panes addLast: (GLMPane in: self).  self newTransmission     addActiveOrigin: arg1;     destination: (self panes last port: #entity);     transmit.  self announce: (GLMPaneAdded pane: self panes last atPosition: self panes size inBrowser: self)rubricTextFontSize  ^StandardFonts codeFont pointSizetransformation: arg1  transformation := arg1testUpdatingScriptPresentationPreservesSelection  | tmp1 tmp2 tmp3 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 pharoScript           title: 'Code';           act: [:arg2 |  arg2 update ] icon: GLMUIThemeExtraIcons glamorousRefresh entitled: 'Update presentation' ].  window := tmp1 openOn: '1 + 2 + 3'.  tmp2 := tmp1 presentations first.  tmp2 selectionInterval: (1 to: 5).  tmp3 := self find: RubScrolledTextMorph in: window.  self assert: tmp2 selectionInterval equals: (1 to: 5).  self assert: tmp3 selectionInterval equals: (1 to: 5).  self assert: tmp3 getSelectionFromModel equals: (1 to: 0).  tmp2 update.  self assert: tmp2 selectionInterval equals: (1 to: 5).  self assert: tmp3 selectionInterval equals: (1 to: 5).  self assert: tmp3 getSelectionFromModel equals: (1 to: 0)paddingTop  ^self wrappedBounds paddingToptestTabsWithUpdate  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list.        arg1 text ].  window := tmp1 openOn: 42.  self assert: self compositeTabGroup pages size equals: 2.  self shouldnt: [ tmp1 panes first presentations update ] raise: Errorto: arg1  toLogic := arg1invalidate  self band removeAllBricks.  self initializeItems.  self doLayoutForce.  self updaterenderStackedVerticallyCompositePresentation: arg1  ^GLMMorphicVerticallyStackedRenderer render: arg1 from: selfmarginRight: arg1  self translateX: self marginRight - arg1.  self margin at: Right put: arg1.  self updateCacheclouds  ^Color brickColorRegistry at: #brickClouds ifAbsentPut: [ Color r: 236 g: 240 b: 241 range: 255 ]resetStopStepping  stopStepping := false.  self changedtextPositionVerticalCenter  ^0 @ (self brickBounds height / 2.0) - (0 @ (self font height / 2.0)) truncatedmenu: arg1 shifted: arg2  ^self menu: arg1shouldFilterByTextInput  ^self glamourPresentation allowsFilter and: [ self inputText notEmpty ]transmit  self transmitIn: GLMTransmissionContext newopposite  ^GLMBrickHeightTraverser uniqueInstanceisOppositeClean: arg1  ^arg1 isWidthCleanvector  ^vectorglobalOuterBounds  ^self owner ifNotNil: [ self outerBounds translateBy: self owner globalBoundsTranslateFactor ] ifNil: [ self outerBounds ]isOnMyself  ^falseisFullyVisible  ^self isFirstVisible & self isLastVisibletestOneSimpleRowAndOneNested  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 addRow: #first.  tmp1 addRow: [:arg1 |  arg1 addColumn: #second.        arg1 addColumn: #third.        arg1 addColumn: #fourth ].  self assert: tmp1 cell children size equals: 2.  self assert: tmp1 cell children last children size equals: 3rowMorphElementsForFirstColumn: arg1 item: arg2 in: arg3  arg2 depth timesRepeat: [ arg3 add: self class emptyMorph ].  arg3 add: (self buttonFor: arg2).  (self iconFor: arg2 data) ifNotNil: [:arg4 |  arg3 add: arg4 asMorph ]wrappedBounds: arg1  brickBounds := arg1allSubbricksDo: arg1  self subbricks do: [:arg2 |  arg2 isBrick ifTrue: [ arg1 value: arg2.              arg2 allSubbricksDo: arg1 ] ]hasTransformation  ^transformation isNotNil and: [ transformation ~= #yourself ]marginBottom  ^self margin at: BottomlogAnnouncement: arg1 from: arg2  testPublishingToOutsideAndInsideFinder  | tmp1 tmp2 tmp3 |  tmp2 := GLMFinder new.  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: 43 ] ].  tmp1 transmit     to: #two;     from: #one;     andShow: [:arg1 |  arg1 text ].  tmp1 transmit     toOutsidePort: #selection;     from: #one port: #selection.  tmp2 show: [:arg1 |  arg1 custom: tmp1 ].  self assert: tmp1 transmissions size equals: 3.  self assert: tmp1 transmissions second origins first pane identicalTo: tmp1 panes first.  self assert: tmp1 transmissions second destination pane identicalTo: tmp1 panes last.  tmp2 startOn: 43.  tmp3 := tmp1.  self assert: tmp3 transmissions size equals: 3.  self assert: tmp3 transmissions second origins first pane identicalTo: tmp3 panes first.  self assert: tmp3 transmissions second destination pane identicalTo: tmp3 panes laststrategy: arg1  self parameters at: 'strategy' put: arg1renderShadowOf: arg1 on: arg2  arg1 shadowWidth = 0 ifTrue: [ ^self ].  self     topLeftCornerShadowOf: arg1 on: arg2;     topRightCornerShadowOf: arg1 on: arg2;     bottomRightCornerShadowOf: arg1 on: arg2;     bottomLeftCornerShadowOf: arg1 on: arg2;     leftShadowOf: arg1 on: arg2;     topShadowOf: arg1 on: arg2;     rightShadowOf: arg1 on: arg2;     bottomShadowOf: arg1 on: arg2.  arg2 fillRectangle: ((arg1 brickBounds insetBy: arg1 shadowWidth / 2.0) translateBy: arg1 shadowOffset) color: arg1 shadowColortestTypeOfMultipleSelection  | tmp1 tmp2 tmp3 |  tmp1 := GLMCompositePresentation new.  tmp1 fastList beMultiple.  window := tmp1 openOn: {{1} asSet .         {1} asOrderedCollection}.  tmp2 := self find: FTTableMorph in: window.  tmp3 := tmp2 selectionStrategy toggleIndex: 1.  self assert: tmp1 selection asOrderedCollection equals: {{1} asSet} asOrderedCollectioncomputation  ^computationtags: arg1  self tagsBlock: arg1.  self hasTagsFilter ifFalse: [ self tagsFilter: arg1 ]canAnnounceMatchingPresentationsChanged: arg1  ^self can: arg1 announce: GLMMatchingPresentationsChangedrubricText  self deprecated: 'Use #text instead'.  ^self custom: GLMRubricTextPresentation newfilteredRoots  | tmp1 |  roots ifNil: [ self roots: self displayValue ].  tmp1 := roots select: [:arg1 |  arg1 shouldBeDisplayed ].  ^tmp1installKeyCombinationForPresentation: arg1 onMorph: arg2  arg2 bindKeyCombination: self keymap toAction: [ self actOn: arg1 ]cellColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp1 := self elementAt: arg2.  tmp2 := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForItem: tmp1);     yourself.  ^tmp2initialize  super initialize.  color := Color transparent.  self fillStyle: nil.  submorphs := OrderedCollection new.  self     layoutProperties: GLMBrickLayoutProperties new;     useHorizontalLinearLayout;     renderer: self defaultRendererrenderShadow: arg1 vector: arg2 origin: arg3 on: arg4  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 |  tmp1 := arg1 shadowInset.  tmp2 := arg1 shadowOffset.  tmp3 := arg1 shadowWidth.  tmp5 := arg2 left length: tmp3.  tmp6 := arg2 length + (tmp1 * 2.0).  ((arg2 rightAngle: arg2 next) or: [ arg2 previous rightAngle: arg2 ]) ifTrue: [ tmp6 := tmp6 - tmp3 + (tmp1 negated * 2) ].  tmp4 := arg3 + tmp2 + (tmp5 * tmp1) - (arg2 * tmp1).  (arg2 previous rightAngle: arg2) ifTrue: [ tmp4 := tmp4 + (arg2 * tmp3) + (arg2 * tmp1 * 2) ].  tmp7 := (self shadowGradientFor: arg1)     origin: tmp4;     direction: tmp5 * tmp3;     yourself.  tmp8 := tmp5 origin: tmp4 breadth: tmp6.  arg4 fillRectangle: tmp8 fillStyle: tmp7changed  ^fullBounds ifNil: [ self invalidRect: self privateFullBounds ] ifNotNil: [ self invalidRect: fullBounds ]testMarkerOneChildrenInParentWidth  | tmp1 tmp2 |  tmp1 := self newBrickWithFullFill.  tmp2 := self newBrickWithFullDependsOnChildren.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthDirty.  self assert: tmp2 wrappedBounds isHeightClean.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightCleanokToStyle  ^truesetUp  super setUp.  browser := GLMExplicitBrowser new.  browser addPane: (GLMPane new name: #one).  browser addPane: (GLMPane new name: #two).  browser addPane: (GLMPane new name: #three)testSimplePresentations  | tmp1 tmp2 tmp3 |  tmp1 := GLMPane named: 'test'.  tmp2 := GLMPresentation new.  self assertEmpty: tmp1 presentations.  tmp3 := nil.  tmp1 when: GLMPresentationsChanged do: [:arg1 |  tmp3 := arg1 ].  tmp1 addPresentation: tmp2.  self assert: tmp1 presentations size equals: 1.  self assert: tmp1 presentations first identicalTo: tmp2.  self assert: tmp2 pane identicalTo: tmp1.  self assert: tmp3 notNilwatcherPane: arg1  watcherPane := arg1removeAllBricks  | tmp1 |  tmp1 := self subbricks copy.  self privateRemoveAllBricks.  tmp1 do: [:arg1 |  self privatePrepareBrickAfterRemoving: arg1 ].  self doLayoutForcerenderDiffPresentation: arg1  ^GLMMorphicDiffRenderer render: arg1 from: selftestAllSelectionActionsWithNoSelection  | tmp1 |  tmp1 := GLMPresentation new.  tmp1 addSelectionAction: GLMAction new.  tmp1 addSelectionAction: GLMAction new.  tmp1 dynamicActionsOnSelection: [:arg1 |  OrderedCollection with: GLMAction new with: GLMAction new with: GLMAction new ].  self assert: tmp1 allSelectionActions size equals: 2testEquality  | tmp1 |  tmp1 := GLMPresentation new.  self assert: (tmp1 = tmp1 copy) notnonFloatSubbricks: arg1  ^arg1 subbricks select: [:arg2 |  arg2 layout floating = #none ]renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderDynamicPresentation: selfregisterEventsForPresentation: arg1  arg1 when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  arg1 when: GLMContextChanged send: #actOnContextChanged: to: self.  arg1 when: GLMSelectCurrentLine send: #selectLine to: selfspecificTableMorphInitializiation  | tmp1 |  super specificTableMorphInitializiation.  tmp1 := tableModel glamourPresentation.  tmp1 shouldAllExpand ifTrue: [ tableModel expandAll ].  tmp1 shouldRootsExpand ifTrue: [ tableModel expandRoots ].  tmp1 shouldExpandToLevel ifTrue: [ tableModel expandAllTo: tmp1 expandLevel ]beMultiple  allowsMultipleSelection := trueisKeyboardScrollEvent: arg1  arg1 controlKeyPressed | arg1 commandKeyPressed ifFalse: [ ^false ].  arg1 keyValue = 30 ifTrue: [ ^true ].  arg1 keyValue = 31 ifTrue: [ ^true ].  ^falserenderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderTreePresentation: selfopen  ^self openWith: self defaultRenderertitle: arg1  title := arg1onCreated  self subclassResponsibilityact  self popup closenotifySelectedPageChanged  self notifyAll: GLMSelectedPageChanged newtestPorts  | tmp1 tmp2 |  tmp1 := GLMPane named: 'test'.  self assertEmpty: tmp1 ports.  tmp2 := tmp1 port: #foo.  self assert: tmp1 ports size equals: 1.  self assert: tmp1 ports first identicalTo: tmp2.  self assert: (tmp1 port: #foo) identicalTo: tmp2debugHighlightedText  UIManager default defer: [ textMorph textArea editor debugHighlight.        textMorph shoutStyler style: textMorph text ]defaultRenderer  ^GLMInteractableBrickRenderer newenableFilterWithAction: arg1 named: arg2  self enableFilter.  self parameters     at: 'actionBlock' put: arg1;     at: 'actionName' put: arg2testInterdependentPanesProperPorts  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two;     column: #three.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 ] ].  tmp1 transmit     to: #two;     from: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 * 2 ] ].  tmp1 transmit     to: #three;     from: #two;     andShow: [:arg1 |  arg1 list           display: [:arg2 |  1 to: arg2 * 3 ];           populate: #focus on: $f entitled: 'Focus' with: [:arg3 |  arg3 selection ] ].  tmp1 transmit     toOutsidePort: #focus;     from: #three port: #focus.  tmp1 transmit     to: #one port: #selection;     fromOutsidePort: #focus;     transformed: [:arg2 |  arg2 + 1 ].  tmp1 transmit     to: #two port: #selection;     fromOutsidePort: #focus;     transformed: [:arg2 |  arg2 + 2 ].  tmp1 startOn: 5.  ((tmp1 paneNamed: #one) port: #selection) value: 3.  ((tmp1 paneNamed: #two) port: #selection) value: 6.  ((tmp1 paneNamed: #three) port: #selection) value: 12.  ((tmp1 paneNamed: #three) port: #focus) value: 12.  self assert: (tmp1 pane port: #focus) value equals: 12.  self assert: ((tmp1 paneNamed: #one) port: #entity) value equals: 5.  self assert: ((tmp1 paneNamed: #one) port: #selection) value equals: 13.  self assert: ((tmp1 paneNamed: #two) port: #entity) value equals: 13.  self assert: ((tmp1 paneNamed: #two) port: #selection) value equals: 14.  self assert: ((tmp1 paneNamed: #three) port: #entity) value equals: 14.  self assert: ((tmp1 paneNamed: #three) port: #selection) value equals: nilhighlightingLogic: arg1  self setProperty: #brickHighlightingLogic toValue: arg1testSimple  | tmp1 tmp2 tmp3 |  tmp1 := GLMPane named: 'test1'.  tmp2 := GLMPane named: 'test2'.  tmp3 := GLMTransmission new     addActiveOrigin: (tmp1 port: #output);     destination: (tmp2 port: #input);     yourself.  (tmp1 port: #output) value: 42.  self assert: (tmp1 port: #output) value equals: 42.  self assert: (tmp2 port: #input) value equals: nil.  tmp3 transmit.  self assert: (tmp1 port: #output) value equals: 42.  self assert: (tmp2 port: #input) value equals: 42press  self isPressed ifFalse: [ isPressed := true.        self changed ].  ^falsestrongSelection: arg1  self announcer announce: (GLMTreeMorphStrongSelectionChanged new           strongSelectionValue: (self elementAt: arg1 selectedIndex);           yourself)validate: arg1  self pane presentations isEmpty ifTrue: [ ^true ].  ^self pane presentations allSatisfy: [:arg2 |  arg2 validate: arg1 on: self ]padding: arg1  < brickBuilderProperty: #Geometry name: 'Padding' as: #brickBuilderEvaluate getter: #padding model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds padding: arg1innerPortEvent: arg1  arg1 isEntityPort ifFalse: [ (self pane port: arg1 portName) value: arg1 value ].  arg1 isSelectionPort ifTrue: [ | tmp1 tmp2 |        tmp1 := self panes reversed indexOf: arg1 pane.        (self panes reversed first: tmp1 - 2) do: [:arg2 |  self removeLastPane.              self announce: (GLMPaneRemoved pane: arg2 fromBrowser: self) ].        tmp1 <= 1 ifTrue: [ self addPaneFromInner: arg1 port.              self announce: (GLMPaneAdded pane: self panes last atPosition: self panes size inBrowser: self) ] ifFalse: [ tmp2 := self removeLastPane.              self lastActivePresentation: tmp2 lastActivePresentation.              self addPaneFromInner: arg1 port.              self announce: (GLMPaneReplaced oldPane: tmp2 newPane: self panes last fromBrowser: self) ] ]needActionButton  ^self parameters at: 'actionBlock' ifPresent: [ true ] ifAbsent: [ false ]selectionAct: arg1 on: arg2 entitled: arg3  self addSelectionAction: (GLMGenericAction new           action: arg1;           shortcut: arg2;           title: arg3;           yourself)text: arg1  self label text: arg1popPane  self band doNotLayoutDuring: [:arg1 |  arg1 removeBrick: arg1 lastSubbrick ].  self doLayoutForcecustom: arg1  self subclassResponsibilitytestNestedBrowserEntity  | tmp1 tmp2 tmp3 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp2 := GLMTabulator new.  tmp2 column: #innerOne.  tmp2 transmit     to: #innerOne;     from: #outer port: #entity;     andShow: [:arg1 |  arg1 text ].  tmp1 transmit     to: #one;     andShow: [:arg1 |  (arg1 custom: tmp2) display: [:arg2 |  arg2 + 2 ] ].  tmp1 startOn: 40.  tmp3 := (tmp1 paneNamed: #one) presentations first.  self assert: ((tmp1 paneNamed: #one) port: #entity) value equals: 40.  self assert: (tmp3 pane port: #entity) value equals: 40.  self assert: ((tmp3 paneNamed: #innerOne) port: #entity) value equals: 42find: arg1 in: arg2  ^self findSatisfying: [:arg3 |  arg3 isKindOf: arg1 ] in: arg2select: arg1  super select: arg1.  hoverAction ifNotNil: [:arg2 |  arg2 brickValue: self withEnoughArguments: {arg1} ]formatedDisplayValueOf: arg1  ^self format glamourValue: arg1 asGlamorousMultiValue , self entity asGlamorousMultiValueinputTextEnabled  ^truebounds: arg1  bounds := arg1addRow: arg1 span: arg2  ^(self addRow: arg1)     span: arg2;     size: 0tagsStyle  ^tagsStyle ifNil: [ self grayRoundedTags.        tagsStyle ]usesExplicitNotNil  ^self usesImplicitNotNil notrubricTextFamilyName  ^StandardFonts codeFont familyNamedrawKeyboardFocusOn: arg1  initialize  super initialize.  ports := OrderedCollection new.  presentations := GLMCompositePresentation new     pane: self;     yourselfinitialize  super initialize.  origin := 0 @ 0shouldUseCache  ^self glamourPresentation shouldUseCachelayoutMorphs: arg1  self band layoutMorphs: arg1parameter: arg1  parameter := arg1requestRefresh  self pane ports do: [:arg1 |  (self validate: arg1 value on: arg1) ifFalse: [ arg1 resetValue ] ].  self announce: (GLMPresentationRefreshRequest new presentation: self)testContext  | tmp1 tmp2 |  tmp1 := GLMPane named: 'test'.  tmp2 := GLMPresentation new.  tmp1 addPresentation: tmp2.  tmp2 selection: 42.  self assert: (tmp1 port: #selection) value equals: 42.  (tmp1 port: #entity) value: 'foo'.  self assert: tmp2 entity equals: 'foo'focusPaneAt: arg1  (self isFocusedMorphVisibleAt: arg1) ifTrue: [ focusedPageIndex := arg1.        (self focusedViewAt: arg1) activeHand newKeyboardFocus: (self focusedViewAt: arg1).        self notifyFocusedPageChanged ]alertOn: arg1  self textBrick text: arg1 asStringtestSetup  | tmp1 |  tmp1 := GLMPresentation new.  self assert: tmp1 pane notNil.  self assert: (tmp1 pane presentations includes: tmp1)privateRemoveBrick: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  arg1 ifNil: [ ^arg1 ].  (self hasSubbrick: arg1) ifFalse: [ ^arg1 ].  tmp3 := arg1 brickDoubleLink.  tmp4 := self firstSubbrick brickDoubleLink.  tmp5 := self lastSubbrick brickDoubleLink.  tmp1 := tmp3 previousLink.  tmp2 := tmp3 nextLink.  tmp1 ifNotNil: [ tmp1 nextLink: tmp2 ].  tmp2 ifNotNil: [ tmp2 previousLink: tmp1 ].  tmp3 clearLinks.  arg1 brickDoubleLink: nil.  tmp6 := self subbricks find: arg1.  self privateSubbricks: (self subbricks copyWithoutIndex: tmp6).  arg1 owner: nil.  ^arg1portEvent: arg1  arg1 portName = #entity ifTrue: [ self unregisterFromAllAnnouncements ].  self browser innerPortEvent: arg1.  self presentations outerPortEvent: arg1hasStatusbar: arg1  arg1 ifTrue: [ statusPane := self addPane: (GLMPane new name: self class defaultStatusbarPane) ]withChildrenOf: arg1 do: arg2  arg2 value: arg1.  (self childrenValueOf: arg1) do: [:arg3 |  self withChildrenOf: arg3 do: arg2 ]defaultPopupLayout  ^GLMPopupBrickDownwardLayout newtestValidateWithMultipleSelection  | tmp1 tmp2 |  tmp1 := GLMPane named: 'test'.  tmp2 := GLMListPresentation new.  tmp2 beMultiple.  tmp2 shouldValidate: true.  tmp1 addPresentation: tmp2.  tmp2 entity: ($a to: $d).  self assert: (tmp2 validate: (Array with: $a) on: (tmp1 port: #selection)).  self assert: (tmp2 validate: (Array with: $a with: $b) on: (tmp1 port: #selection)).  self deny: (tmp2 validate: $a on: (tmp1 port: #selection)).  self deny: (tmp2 validate: (Array with: $z) on: (tmp1 port: #selection))isColumn  ^trueaddRawSelectionTransmissionTo: arg1  ^rawSelectionTransmissions add: (GLMTransmission new           addActiveOrigin: (GLMPresentationBoundPort new                 name: #rawSelection;                 presentation: self;                 yourself);           destination: (GLMPresentationBoundPort new                 name: arg1;                 presentation: self;                 yourself))ensure: arg1  ensureLogic := arg1bounds: arg1  self layoutAfter: [:arg2 |  arg2 wrappedBounds bounds: arg1 ]isVFilling  ^vResizing = #spaceFillsortBlock  ^sortBlockwithoutMargins  self margins: 0 asMarginshouldRootsExpand  ^rootsExpanded ifNil: [ false ]uncheck  self box uncheck.  self label uncheck.  super uncheckvalue  self subclassResponsibilitywidthTop  ^self width at: ToptestSimple  | tmp1 |  tmp1 := GLMExpander new.  tmp1 startOn: #(#a #b #c).  self assert: tmp1 panes size equals: 3.  self assert: (tmp1 panes first port: #entity) value equals: #atestPresentationBoundPort  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := GLMExplicitBrowser new.  tmp1 addNewPane.  GLMTestPane new addPresentation: tmp1.  tmp2 := GLMPresentationBoundPort new     presentation: tmp1;     name: #outerPort1;     yourself.  tmp3 := GLMPresentationBoundPort new     presentation: tmp1;     name: #outerPort2;     yourself.  tmp1 addTransmission: (tmp4 := GLMMockSimpleTransmission new           addActiveOrigin: tmp2;           destination: (tmp1 panes first port: #innerPort1);           yourself).  tmp1 addTransmission: ((tmp5 := GLMMockSimpleTransmission new)           addActiveOrigin: (tmp1 panes first port: #innerPort2);           destination: tmp3;           yourself).  (tmp1 pane port: #outerPort1) value: 42.  self assert: (tmp1 panes first port: #innerPort1) value equals: 42.  self assert: tmp4 wasTransmited.  self deny: tmp5 wasTransmited.  (tmp1 panes first port: #innerPort2) value: 43.  self assert: (tmp1 pane port: #outerPort2) value equals: 43actOnContextChanged: arg1  arg1 property = #selectionInterval ifTrue: [ arg1 value notNil ifTrue: [ textMorph setSelection: arg1 value ] ifFalse: [ textMorph setSelection: (1 to: 0) ] ]includes: arg1  ^collection includes: arg1useCache  self parameters at: 'shouldUseCache' put: truerenderListingPresentation: arg1  ^GLMMorphicListingRenderer render: arg1 from: selfelementOrZeroAt: arg1  ^arg1 = 0 ifTrue: [ 0 ] ifFalse: [ self elementAt: arg1 ]initializeAction: arg1 on: arg2  self action: arg1.  menuMorph := arg2isOnParent  ^trueinitialize  super initialize.  children := [ #() ]markHeightClean  self heightState: #cleanrubricTextFamilyName  ^self valueOfProperty: #brickRubricTextFamilyName ifAbsent: [ self themer rubricTextFamilyName ]withAllPanesAndPresentationsDo: arg1  super withAllPanesAndPresentationsDo: arg1.  self cachedPresentation ifNotNil: [:arg2 |  arg2 withAllPanesAndPresentationsDo: arg1 ]allowsDeselection: arg1  allowsDeselection := arg1paddingBottom: arg1  < brickBuilderProperty: #Geometry name: 'Padding Bottom' as: #asInteger getter: #paddingBottom model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds paddingBottom: arg1testSymbolAsTargetIdentifier  self assert: (#pane asGlamourTargetIdentifier isKindOf: GLMPortIdentifier).  self assert: #pane asGlamourTargetIdentifier paneName equals: #pane.  self assert: #pane asGlamourTargetIdentifier portName equals: #entityscrollDeltaWidth  ^1editingMode  ^editingMode ifNil: [ nil ] ifNotNil: [ editingMode glamourValue: self ]renderWithToolbar: arg1  | tmp1 |  tmp1 := self renderObject: arg1.  ^self morph: tmp1 withToolbarOf: arg1installActionsOnModel: arg1 fromPresentation: arg2  arg1 when: GLMMenuItemSelected do: [:arg3 |  arg3 action morphicActOn: arg2 ].  arg1 when: GLMKeyStroke do: [:arg3 |  arg3 action actOn: arg2 ]testColumnLabel  | tmp1 tmp2 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 table           display: [:arg2 |  arg2 - 3 to: arg2 ];           column: 'Column' evaluated: [:arg2 |  arg2 asString ];           column: [:arg2 |  'Number ' , arg2 asString ] evaluated: #asString ].  window := tmp1 openOn: 4.  tmp2 := self find: MorphTreeMorph in: window.  self assert: (tmp2 model roots collect: #item) equals: #(1 2 3 4) asOrderedCollection.  self assert: tmp2 columns first header label equals: 'Column'.  self assert: tmp2 columns last header label equals: 'Number 4'action  ^actiontestFormat  | tmp1 |  tmp1 := GLMFormatedPresentation new.  tmp1 format: [:arg1 |  arg1 ].  self assert: (tmp1 formatedDisplayValueOf: 1) equals: 1.  tmp1 entity: 41.  tmp1 format: [:arg2 :arg1 |  arg2 + arg1 ].  self assert: (tmp1 formatedDisplayValueOf: 1) equals: 42.  tmp1 entity: (GLMMultiValue with: 20 with: 21).  tmp1 format: [:arg2 :arg3 :arg1 |  arg2 + arg3 + arg1 ].  self assert: (tmp1 formatedDisplayValueOf: 1) equals: 42onButtonClicked: arg1  self pagerModel switchPaneTo: arg1 buttonModel indextestSelectionIntervalInitialization  | tmp1 |  tmp1 := GLMRubricTextPresentation new initialize: [:arg1 |  arg1 selectionInterval: (3 to: 9) ].  self assert: tmp1 selectionInterval equals: nil.  tmp1 initializePresentation.  self assert: tmp1 selectionInterval equals: (3 to: 9)handleListenEvent: arg1  self predicates detect: [:arg2 |  arg2 popup: self popup event: arg1 ] ifFound: [:arg2 |  self act ]scrollingDelay  ^scrollingDelay ifNil: [ scrollingDelay := 100 ]value: arg1  self value: arg1 in: GLMTransmissionContext newdrawOnAthensCanvas: arg1  arg1 pathTransform restoreAfter: [ arg1 pathTransform translateBy: self globalBounds origin - self brickBounds origin.        self onDrawAthensCanvas: arg1 ]anySatisfy: arg1  ^self presentations anySatisfy: arg1pane: arg1  super pane: arg1.  self presentations do: [:arg2 |  arg2 pane: arg1 ]selectionValue  ^selectionValuepane  ^pane ifNil: [ pane := (GLMPane named: 'root' in: GLMNoBrowser new)           presentations: self;           yourself ]setCursorToResizing: arg1  arg1 hand showTemporaryCursor: self resizeCursorwidth  ^width ifNil: [ 200 ]spacing  ^0brickBounds: arg1  self wrappedBounds brickBounds: arg1openWith: arg1  ^arg1 open: selfcolorLeft  ^self color at: Leftport: arg1  port := arg1usesImplicitAllNil  ^implicitAllNil ifNil: [ implicitAllNil := false ]priority  ^priority ifNil: [ priority := Processor userSchedulingPriority ]newButtonBrick  ^GLMButtonBrick newrawSelection  ^(self pane port: #rawSelection) valueisInsideOfContentBrick: arg1  self contentBrick ifNil: [ ^false ] ifNotNil: [:arg2 |  arg1 withHandPositionDo: [:arg3 |  ^arg2 boundsInWorld containsPoint: arg3 ] ]keymap  ^keymaptestUnregisterAnnouncementsWhenRemovingPane  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := GLMAnnouncer new.  tmp2 := GLMFinder new.  tmp3 := GLMPresentation new.  tmp3 title: [:arg1 |  arg1 ].  tmp2 addPresentation: tmp3.  tmp3 updateOn: GLMTestAnnouncement from: [ tmp1 ].  tmp2 entity: #value1.  tmp4 := tmp2 panes first presentations first.  tmp4 registerAnnouncements.  self assert: tmp1 numberOfSubscriptions equals: 1.  self assert: tmp1 glmSubscriptions anyOne announcementClass equals: GLMTestAnnouncement.  self assert: tmp1 glmSubscriptions anyOne subscriber presentation equals: tmp4.  self assert: tmp1 glmSubscriptions anyOne subscriber presentation identicalTo: tmp4.  (tmp2 panes first port: #selection) value: #value2.  tmp2 panes last presentations first registerAnnouncements.  tmp5 := tmp2 panes last presentations first.  self assert: tmp1 numberOfSubscriptions equals: 2.  self assert: (tmp1 glmSubscriptions allSatisfy: [:arg2 |  arg2 announcementClass = GLMTestAnnouncement ]).  self assert: (tmp1 glmSubscriptions anySatisfy: [:arg2 |  arg2 subscriber presentation = tmp4 ]).  self assert: (tmp1 glmSubscriptions anySatisfy: [:arg2 |  arg2 subscriber presentation == tmp4 ]).  (tmp2 panes first port: #selection) value: #value3.  tmp5 := tmp2 panes last presentations first.  self assert: tmp1 numberOfSubscriptions equals: 1.  self assert: tmp1 glmSubscriptions anyOne announcementClass equals: GLMTestAnnouncement.  self assert: tmp1 glmSubscriptions anyOne subscriber presentation equals: tmp4.  self assert: tmp1 glmSubscriptions anyOne subscriber presentation identicalTo: tmp4allMenuActions  ^self glamourPresentation allSelectionActions select: [:arg1 |  arg1 hasTitle ]specificDataSourceInitializiation  addLazyPage: arg1 label: arg2  self addLazyPage: arg1 label: arg2 toolbar: nilscrollbarWidth  ^3privatePrepareBrickAfterAdding: arg1  arg1 wrappedBounds     markWidthDirty;     markHeightDirty.  self privateAddIntoWorld: arg1withString: arg1 from: arg2  arg2 textArea removeHighlightSegment.  super withString: arg1 from: arg2printOn: arg1  super printOn: arg1.  arg1     nextPutAll: '(id=';     print: self identityHash;     nextPutAll: ' title=';     print: self titleValue;     nextPutAll: ' pane=';     print: self pane;     nextPutAll: ')'column: arg1 span: arg2  ^self addColumn: arg1 span: arg2configurePane: arg1  | tmp1 |  tmp1 := arg1 asBrick.  tmp1     layoutProperties: GLMBrickLayoutProperties new;     width: [ self band width / self band subbricksCount ];     vSpaceFill;     marginLeft: self paneMargin;     marginRight: self paneMargin.  tmp1 layout widthDependency: self band.  ^tmp1pageIndex  ^pageIndexactOnPaneReplaced: arg1  self subclassResponsibilitytransformation: arg1  transformation := arg1onPageSwitched  self updateButtonsdrawKeyboardFocusOnAthensCanvas: arg1  value  ^self port valuedoNotUpdateDuring: arg1  self isUpdating ifTrue: [ ^self ].  isUpdating := true.  arg1 cull: self.  isUpdating := falsecalculateMaxVelocity  ^self band height / 15 max: self class defaultMaxVelocityopposite  ^GLMBrickWidthTraverser uniqueInstancescrollToTop  self scrollTo: 1finishTime  ^self startTime + self durationonChildrenLayouted  super onChildrenLayouted.  self scrollpane ifNotNil: [:arg1 |  arg1 updateScrollbar ].  self shouldLayoutMorphs ifFalse: [ ^self ].  self asyncTask perform: [ self updateMorphBounds ] delay: 400 priority: Processor userBackgroundPriority + 1computeAnnouncerObjects  self flag: 'We catch the error because if there is a problem in the computation of the announcer object, we still want to be able to continue the execution'.  ^OrderedCollection with: ([ self transformation glamourValue: self presentation entity ] on: Error do: [:arg1 |  self presentation entity.              arg1 resume ])vSpaceFill  self vSpaceFill: 100testCopyTheTransformation  | tmp1 tmp2 |  tmp1 := GLMPresentation new.  tmp1 selectionTransformation: [:arg1 |  arg1 + 1 ].  tmp2 := tmp1 copy.  self assert: (tmp1 selectionTransformation value: 1) equals: 2.  self assert: (tmp2 selectionTransformation value: 1) equals: 2hasMinDimensionRestriction: arg1  ^self subclassResponsibilitymorphicSelectionAct: arg1 entitled: arg2  self addSelectionAction: (GLMMorphicAction new           action: arg1;           title: arg2;           yourself)contentBrick: arg1  contentBrick := arg1.  self addBrickBack: contentBrickselectionAct: arg1 entitled: arg2  self addSelectionAction: (GLMGenericAction new           action: arg1;           title: arg2;           yourself)testOriginTransformedValue  | tmp1 tmp2 |  tmp1 := GLMSimplePort new value: 41.  tmp2 := GLMOriginPortReference new     port: tmp1;     transformation: [:arg1 |  arg1 + 1 ].  self assert: tmp2 value equals: 42enableFilterWithAction: arg1  self enableFilter.  self parameters at: 'actionBlock' put: arg1andShowIfNone: arg1  self ensurePresentIfNoneStrategy.  self transmissionStrategy presentationsFactory: arg1.  self origins isEmpty ifTrue: [ self from: #outer port: #entity ]isVisible: arg1  | tmp1 tmp2 |  tmp1 := (self allowedBounds withWidth: 0) translateBy: self allowedBounds origin negated x @ 0.  tmp2 := (arg1 globalBounds withWidth: 0) translateBy: arg1 globalBounds origin negated x @ 0.  ^tmp1 containsRect: tmp2moveBandTop  self band translateY: self bandTopOffset negatedtestDefaultPresentations  | tmp1 |  tmp1 := GLMPane named: 'test'.  self assert: (tmp1 presentations isKindOf: GLMCompositePresentation)morphFrom: arg1  | tmp1 |  tmp1 := arg1 morph     vResizing: #spaceFill;     hResizing: #spaceFill;     yourself.  (self allKeyboardActionsFor: arg1) ifNotEmpty: [ tmp1 on: #keyStroke send: #actOnKeyStroke:event:from: to: self withValue: arg1 ].  ^tmp1initialize  super initialize.  updateActions := OrderedCollection new.  portChangeActions := OrderedCollection new.  rawSelectionTransmissions := IdentitySet new.  self addRawSelectionTransmissionTo: #selectiontestPopLastPageOf5  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel popPane.  self assert: pagerModel size equals: 4.  self assert: pagerModel firstVisiblePageIndex equals: 3.  self assert: pagerModel lastVisiblePageIndex equals: 4.  self assert: pagerModel numberOfVisiblePages equals: 2smalltalkClass: arg1  self setProperty: #phlowSmalltalkClass toValue: arg1hShrinkWrap  hResizing := #shrinkWrapwantsDroppedMorph: arg1 event: arg2 inMorph: arg3  | tmp1 tmp2 |  (arg1 isKindOf: TransferMorph) ifFalse: [ ^false ].  arg1 dragTransferType = self dragTransferType ifFalse: [ ^false ].  tmp2 := arg3 scrollerSubMorphFromPoint: arg2 position.  tmp2 ifNotNil: [ tmp1 := tmp2 complexContents item.        ^self glamourPresentation allow: arg1 passenger droppedOnItem: tmp1 ].  self flag: 'we should ask the whole presentation if it wants to receive a dropped object'.  ^falseinitializePresentation  initializationBlock ifNotNil: [ initializationBlock value: self ]portChangeActions  ^portChangeActionslayout: arg1 in: arg2  self layout: arg1 in: arg2 inject: arg1 paddingLeft @ arg1 paddingTop into: [:arg3 :arg4 |  arg4 outerOrigin: arg3.        0 @ arg4 outerBounds height ]fixedSizePanes: arg1  self hasFixedSizePanes: true.  fixedSizePanes := arg1subbricks  ^self brick submorphsenableElementIndex  self parameters at: 'withRowIndex' put: trueresetAnnouncer  super resetAnnouncer.  self presentations do: [:arg1 |  arg1 resetAnnouncer ]initialize  super initialize.  self useHorizontalLinearLayout.  self hSpaceFill.  self vShrinkWrap.  self messageBrick: self newTitleBrick.  self settingsButtonBrick: self newButtonBrickports  ^portsselectionInterval: arg1  self setProperty: #phlowSelectionInterval toValue: arg1maxHeight: arg1  self layout maxHeight: arg1deselect: arg1  super deselect: arg1.  self box deselect: arg1.  self label deselect: arg1position: arg1  position := arg1updateButtonsFocus  self buttons do: #setNotFocused.  self pagerModel focusedPageIndex ifNotNil: [ (self buttons at: self pagerModel focusedPageIndex) setFocused ]testIndirectEventsPropagationTransformation  | tmp1 tmp2 tmp3 |  tmp3 := 0.  tmp1 := GLMDynamicPresentation new.  tmp1 entity: '42'.  tmp1 display: [:arg1 |  tmp2 := GLMRubricTextPresentation new ].  tmp1 currentPresentation.  tmp2 announcer when: GLMContextChanged do: [:arg2 |  arg2 property = #selectionInterval ifTrue: [ tmp3 := tmp3 + 1 ] ].  tmp2 selectionInterval: (1 to: 2).  self assert: tmp3 equals: 1setIndex: arg1 in: arg2  arg2 setProperty: #brickScrollListIndex toValue: arg1markBorderColor: arg1 width: arg2  self setProperty: #brickMarkBorderColor toValue: arg1.  self setProperty: #brickMarkBorderWidth toValue: arg2verticalScrollbar: arg1  verticalScrollbar := arg1.  verticalScrollbar scrollPane: self.  verticalScrollbar height: [ self height ].  verticalScrollbar layout heightDependency: self.  super addBrickBack: verticalScrollbarscrollbarOffset: arg1  self setProperty: #brickScrollbarOffset toValue: arg1.  self updateStyledotsBrick  ^dotsBrickbuttonMinHeight  ^26 * self currentWorld displayScaleFactorpressedScrollerSizeCombination: arg1  firstCombination ifNil: [ firstCombination := arg1.        ^self ].  self scrollerSizeShortcutAction: firstCombination second: arg1.  firstCombination := nilnewBrickWithFullDependsOnChildren  ^GLMBrick new     hShrinkWrap;     vShrinkWrap;     color: Color random;     yourselfnotifyPagePushed: arg1 scrollTo: arg2 smooth: arg3  self notifyAll: (GLMPagePushed new morph: arg1).  arg2 ifTrue: [ self scrollingDelay > 0 ifTrue: [ self scrollToRightTask execute: {arg3} ] ifFalse: [ self scrollToRight: arg3 ] ]actOnPaneReplaced: arg1  container removeMorph: container submorphs last.  container removeMorph: container submorphs last.  self addMorphFromObject: arg1 newPane toContainer: container.  scrollPane hScrollbar glmAnimateValue: 1.0 duration: 200dataFromPresentationItem: arg1  ^arg1 dataopenInExternalWindow: arg1  window := GLMOSWindowMorphWorldRenderer render: arg1 from: self.  ^window openselectionAct: arg1 on: arg2  self addSelectionAction: (GLMGenericAction new           action: arg1;           shortcut: arg2;           yourself)activeFillStyle  ^self theme watcherWindowActiveFillStyleFor: selfscrollTo: arg1 smooth: arg2 callback: arg3  arg2 ifTrue: [ self glmAnimateValue: arg1 duration: 300 callback: arg3 ] ifFalse: [ self scrollValue: (self convertScrollValue: arg1).        self updatePaneBounds.        arg3 value ]searchOn: arg1  self error: 'This presentation does not allow searching with a block for now. In the futur we should have a new filter with FastTable to do that. If you want to give it a try look FTFunction and his subclasses.'testWatcherCopy  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMBrowser new.  tmp2 := GLMPane named: 'one'.  tmp1 addPane: tmp2.  tmp3 := GLMTransmission new.  tmp1 addTransmission: tmp3.  tmp3 addActiveOrigin: (tmp1 panes first port: #origin).  tmp3 toWatcher.  tmp4 := tmp1 copy.  self assert: tmp4 transmissions size equals: 1.  self assert: (tmp4 panes first port: #origin) value equals: nil.  self assert: (tmp4 watcherPane port: #entity) value equals: nil.  (tmp4 panes first port: #origin) value: 42.  tmp4 transmissions first transmit.  self assert: (tmp4 watcherPane port: #entity) value equals: 42preventOverscrolling  self band hasSubbricks ifFalse: [ ^self ].  self isFirstAdded & self isFirstVisible ifTrue: [ self bandTopOffset > 0 ifTrue: [ self moveAllSubbricksBy: self topOffset negated.              self moveBandTop.              self update ].        ^self ].  self isTopOverscrolled ifTrue: [ self moveBandTop.        ^self update ].  self isBottomOverscrolled & self isFullyVisible not ifTrue: [ self moveBandBottom.        ^self update ]renderWithTitleOrNil: arg1  | tmp1 |  tmp1 := self renderObject: arg1.  ^self morph: tmp1 withTitleOrNilOf: arg1currentColor  ^self state pressedColor: self isPressed selectedColor: self isSelected checkedColor: self isChecked of: selfresizeCursor  ^Cursor resizeForEdge: #lefttestSorted  | tmp1 |  tmp1 := GLMListPresentation new.  tmp1 entity: #(#foo #bar #blurp).  self assert: tmp1 displayValue equals: #(#foo #bar #blurp).  tmp1 sorted.  self assert: tmp1 displayValue equals: #(#bar #blurp #foo).  tmp1 sorted: [:arg1 :arg2 |  arg1 size < arg2 size ].  self assert: tmp1 displayValue equals: #(#bar #foo #blurp)popup: arg1  popup := arg1oldValue  ^oldValuetestTabs  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list.        arg1 text ].  window := tmp1 openOn: 42.  self assert: self compositeTabGroup pages size equals: 2iconFor: arg1  ^self cacheAt: #icon for: arg1 ifAbsentPut: [ self glamourPresentation icon cull: arg1 ]initialize  super initialize.  self listBrick: self newScrollListshouldUseCache  ^self parameters at: 'shouldUseCache' ifAbsent: [ false ]unsubscribeListeners  self removeCloserListeneronThemerChanged  super onThemerChanged.  self titleBrick textColor: self themer textLightColorinitialize  super initialize.  self textBrick: self newTextBrickhasMaxDimensionRestriction: arg1  ^arg1 layout hasMaxHeightrenderGlamorouslyOn: arg1  ^arg1 renderFinder: selftearDown  window ifNotNil: [:arg1 |  arg1 delete ].  super tearDowntoolbarButtonsForPresentation: arg1  ^(arg1 allActions select: [:arg2 |  arg2 isButton ]) collect: [:arg2 |  | tmp1 |        tmp1 := arg2 renderGlamorouslyOn: self renderer.        tmp1 arguments ifNil: [ tmp1 arguments: {arg1} ] ifNotNil: [ tmp1 arguments: {arg1} , tmp1 arguments ].        tmp1 ]selectLine  textMorph textArea editor lineSelectAndEmptyCheck: [ ^nil ]renderLabelPresentation: arg1  ^GLMMorphicLabelRenderer render: arg1 from: selfscrollToTop  self scrollBy: self scrollPositionTop negated direction: #upaddSelectionAction: arg1  self selectionActions add: arg1grayRoundedTags  tagsStyle := #grayRoundedButtonhintTitle  ^hintTitle ifNil: [ hintTitle := 'Hi,' ]isFilterable  ^self parameters at: 'isFilterable' ifAbsent: [ false ]enableFilterWithAction: arg1 named: arg2  self enableFilter.  self parameters     at: 'actionBlock' put: arg1;     at: 'actionName' put: arg2vShrinkWrap  vResizing := #shrinkWrapselectLine  textMorph selectLineresetChildrenContent  self rootItem: self createRootItem.  self resetDataCachehasTitle  ^self title notNilformat  ^format ifNil: [ format := #asString ]textFamilyName  ^self theme labelFont familyNamesingleClick: arg1  self announce: #onSingleClicked event: arg1renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderSpecPresentation: selfopen: arg1 with: arg2  ^arg1 openBelow: arg2floating: arg1  self layout floating: arg1style: arg1  style := arg1formatedDisplayValue  ^self formatedDisplayValueOf: self displayValueshouldAllExpand  ^allExpanded ifNil: [ false ]toggleOpen  isOpen ifFalse: [ ^self openInWorld ].  self visible ifTrue: [ self hide ] ifFalse: [ self show ]textColor  ^self label textColorforSmalltalk  highlightSmalltalk := truetestTriggeringConditions  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMExplicitBrowser new.  tmp1 pane: GLMTestPane new.  tmp2 := GLMTestPane new.  tmp3 := GLMTestPane new.  tmp4 := GLMTransmission new     addActiveOrigin: (tmp2 port: #selection);     destination: (tmp3 port: #entity);     yourself.  tmp1 addPane: tmp2.  tmp1 addPane: tmp3.  tmp1 addTransmission: tmp4.  self assertEmpty: (tmp2 port: #selection) seenTransmissions.  self assertEmpty: (tmp3 port: #entity) seenTransmissions.  (tmp2 port: #selection) value: 12.  self assertEmpty: (tmp2 port: #selection) seenTransmissions.  self assert: (tmp3 port: #entity) seenTransmissions size equals: 1.  self assert: (tmp3 port: #entity) seenTransmissions first identicalTo: tmp4.  (tmp2 port: #selection) value: 12.  self assertEmpty: (tmp2 port: #selection) seenTransmissions.  self assert: (tmp3 port: #entity) seenTransmissions size equals: 1.  self assert: (tmp3 port: #entity) seenTransmissions first identicalTo: tmp4elementColumn  | tmp1 |  tmp1 := OrderedCollection new     add: self displayText;     addAll: (self tagMorphsFrom: self containerTree glamourPresentation);     yourself.  ^UITheme current newRowIn: self currentWorld for: tmp1textBlock: arg1  textBlock := arg1shouldFilterByTag: arg1  ^self tagsToFilterBy includes: arg1compose  vectors: arg1  | tmp1 |  self assert: [ arg1 size >= 4 ] description: [ 'There must be at least four vectors (rectangular area)!' ].  vector := arg1 first.  tmp1 := vector.  2 to: arg1 size do: [:arg2 |  | tmp2 |        tmp2 := arg1 at: arg2.        tmp1 next: tmp2.        tmp2 previous: tmp1.        tmp1 := tmp2 ].  tmp1 next: vector.  vector previous: tmp1.  self computeVerticesannounce: arg1 event: arg2  self announcer subscriptions subscriptions do: [:arg3 |  arg3 announcementClass = arg1 ifTrue: [ (arg3 handlesAnnouncement: arg1) ifTrue: [ [ arg3 action cull: arg2 cull: self ] on: UnhandledError fork: [:arg4 |  arg4 pass ] ] ] ]formatedDisplayValueOf: arg1  ^self cacheAt: #formatedDisplayValue for: arg1 ifAbsentPut: [ self glamourPresentation formatedDisplayValueOf: arg1 ]hasTagsFilter  ^self tagsFilterBlock notNilactOnPresentationUpdated: arg1  labelMorph contents: arg1 presentation formatedDisplayValueprivateWidth: arg1  self layout width: arg1selectionPathItems  ^self selectedNodePath ifNil: [ nil ] ifNotNil: [ self selectedNodePath collect: [:arg1 |  arg1 item ] ]fullBounds  super fullBounds.  ^self brickRoot globalClippingBoundsenableFilter: arg1  self enableFilter.  self parameters at: 'filterBlock' put: arg1testDefaultFixedSizePanes  | tmp1 tmp2 |  tmp1 := GLMFinder new.  window := tmp1 openOn: 40.  window width: 522.  tmp2 := self find: TransformMorph in: window.  self assert: tmp2 submorphs first width equals: window submorphs last width.  (tmp1 panes first port: #selection) value: 42.  self assert: tmp2 submorphs size equals: 3.  self assert: tmp2 submorphs first extent equals: tmp2 submorphs last extent.  self assert: tmp2 submorphs first width <= (window submorphs last width / 2)setPotentialBackgroundColorFor: arg1  arg1 colorValue ifNotNil: [ window borderColor: arg1 colorValue ]browser: arg1  browser := arg1testCondition  self assert: (GLMAction new isAvailableOn: GLMPresentation new).  self deny: (GLMAction new           condition: [ false ];           isAvailableOn: GLMPresentation new).  self deny: (GLMAction new           condition: [:arg1 :arg2 |  false ];           isAvailableOn: GLMPresentation new)announcement: arg1  announcement := arg1tagsToFilterBy  ^tagsToFilterBy ifNil: [ tagsToFilterBy := OrderedCollection new ]hasCustomDependencies: arg1  ^(self customDependencies: arg1) isEmpty notchangeValueTo: arg1 in: arg2  | tmp1 |  tmp1 := self value.  self pane notingPresentationChangeDo: [ self silentValue: arg1.        self pane portEvent: (GLMPortEvent on: self previouslyValued: tmp1 in: arg2) ]testPortPublishing  | tmp1 |  tmp1 := GLMFinder new.  (tmp1 pane port: #entity) value: #value1.  self assert: tmp1 panes size equals: 1.  self assert: tmp1 pane ports size equals: 1.  self assert: (tmp1 pane port: #entity) value equals: #value1.  (tmp1 panes first port: #selection) value: #value2.  self assert: tmp1 panes size equals: 2.  self assert: tmp1 pane ports size equals: 3.  self assert: (tmp1 pane port: #entity) value equals: #value1.  self assert: (tmp1 pane port: #selection) value equals: #value2.  (tmp1 panes last port: #selection) value: #value3.  self assert: tmp1 panes size equals: 3.  self assert: tmp1 pane ports size equals: 3.  self assert: (tmp1 pane port: #entity) value equals: #value1.  self assert: (tmp1 pane port: #selection) value equals: #value3.  (tmp1 panes first port: #hover) value: #value4.  self assert: tmp1 panes size equals: 3.  self assert: tmp1 pane ports size equals: 4.  self assert: (tmp1 pane port: #entity) value equals: #value1.  self assert: (tmp1 pane port: #selection) value equals: #value3.  self assert: (tmp1 pane port: #hover) value equals: #value4pharoPlayground  self deprecated: 'Use #pharoScript instead'.  ^self custom: GLMPharoScriptPresentation newstate  ^self classtestLeftMarginParentDependency  | tmp1 tmp2 tmp3 |  tmp2 := 10.  tmp1 := self newBrickWithStaticExtent.  tmp3 := self newBrickFullHeightAndWidthDependsOnParent: 100.  tmp3 marginLeft: tmp2.  tmp1 addBrickBack: tmp3.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp3 extent equals: self staticExtent - (tmp2 @ 0).  self assert: tmp3 brickBounds equals: (tmp2 @ 0 corner: self staticExtent)panes  ^panes ifNil: [ panes := OrderedCollection new ]enlargeToRight  self virtualLastVisiblePageIndex: self lastVisiblePageIndex + 1.  self recomputeStatesilentValue: arg1  self subclassResponsibilitypopAndReplacePane: arg1  self doNotNotifyDuring: [:arg2 |  arg2           popPane;           pushPane: arg1 smooth: false ].  self notifyPagePoppedAndReplaced: arg1addPort: arg1  self ports add: arg1wantsSteps  ^truerenderContainerFor: arg1  contentMorph := self morph: (self renderObject: arg1 presentations) withTitleOrNilOf: arg1 presentations.  container     addMorph: contentMorph fullFrame: LayoutFrame identity;     yourselfmorph  | tmp1 |  tmp1 := RubScrolledTextMorph new     beForSmalltalkCode;     getSelectionSelector: #primarySelectionInterval;     model: textModel;     color: self theme backgroundColor;     textFont: StandardFonts codeFont;     yourself.  (tmp1 textArea decoratorNamed: #shoutStyler) ifNotNil: [:arg1 |  textModel glamourPresentation variableBindings ifNotEmpty: [ arg1 styler                 workspace: textModel;                 isForWorkspace: false.              arg1 refreshStyling ] ].  ^tmp1bounds  ^self brickBoundssimulateOnlyOneClickOn: arg1  (Delay forMilliseconds: HandMorph doubleClickTime + 1) wait.  arg1 simulateClickscrollBy: arg1 direction: arg2  self isFullyVisible ifTrue: [ ^self ].  arg2 = #up ifTrue: [ self scrollUp: arg1 ].  arg2 = #down ifTrue: [ self scrollDown: arg1 ].  self update.  self changedbasicValue: arg1  value := arg1renderGlamorouslyOn: arg1  self registerAnnouncements.  ^self currentPresentation renderGlamorouslyOn: arg1animation  ^animationactOnBrowserClosed: arg1  self renderer window deletetestMarkerOneChildrenInParentHeight  | tmp1 tmp2 |  tmp1 := self newBrickWithFullFill.  tmp2 := self newBrickWithFullDependsOnChildren.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthClean.  self assert: tmp2 wrappedBounds isHeightDirty.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightCleanband  ^bandtestForSmalltalkWorkspace  | tmp1 tmp2 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 pharoScript variableBindings: [:arg2 |  {(#theNumber -> arg2)} ] ].  window := tmp1 openOn: 42.  tmp2 := self find: RubScrolledTextMorph in: window.  self assert: (tmp2 model hasBindingOf: #theNumber)approximateHeight  ^self font height + self vMargin + self vPaddingisSplitIntoColumns  ^self children allSatisfy: [:arg1 |  arg1 isColumn ]selection: arg1  | tmp1 |  tmp1 := arg1 newSelectedIndexes select: [:arg2 |  arg2 ~= 0 ] thenCollect: [:arg2 |  self elementAt: arg2 ].  tmp1 ifNotEmpty: [ self announcer announce: (GLMTreeMorphSelectionChanged new                 selectionValue: ((tmp1 size = 1 and: [ self glamourPresentation isSingle ]) ifTrue: [ tmp1 first ] ifFalse: [ tmp1 ]);                 selectionPathValue: tmp1;                 yourself) ]rubricTextBackgroundColor  ^Color transparentstep  shadowWidth  ^3computeAnnouncerObjects  ^self transformation glamourValue: self presentation entitylabelActionBrickFor: arg1  ^arg1 titleAction ifNil: [ nil ] ifNotNil: [:arg2 |  ((arg2 isAvailableOn: arg1) and: [ arg2 hasIcon ]) ifTrue: [ GLMActionButtonBrick new                 icon: arg2 icon;                 setBalloonText: arg2 title;                 action: [ arg2 actOn: arg1 ] ] ifFalse: [ nil ] ]left  ^GLMEastDirection uniqueInstancechildrenCount  ^self children inject: 0 into: [:arg1 :arg2 |  arg1 + arg2 span ]scrollBy: arg1  self privateScrollPosition: arg1.  self band translateY: arg1updateVariableBindings  self announce: (GLMVariableBindingsChanged new presentation: self)glamourAction  ^glamourActioninitialize  super initialize.  focus := Dictionary new.  currentScrollDelta := 0.  maxPanes := 2.  self band: self newBand.  Morph announcer weak when: MorphGotFocus send: #focusChanged: to: selftestTextPortPopulatedByDefault  | tmp1 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text ].  window := tmp1 openOn: '42'.  self assert: (tmp1 pane port: #text) value asString equals: '42'textColor  ^Color r: 206 g: 38 b: 11 range: 255calculateVelocity: arg1  | tmp1 |  tmp1 := arg1 timeStamp - lastScrollTimeStamp.  self velocity: (tmp1 > self class defaultScrollTimeReset ifTrue: [ self class defaultScrollVelocity ] ifFalse: [ self velocityValue: tmp1 ]).  lastScrollTimeStamp := arg1 timeStamp.  ^self velocity ceilingtransientValue: arg1  | tmp1 |  tmp1 := self value.  self value: arg1.  self silentValue: tmp1defaultPercent  ^100resetElements  self resetDataCache.  self updateDatahSpaceFill: arg1  super hSpaceFill: arg1.  self label hSpaceFill.  self dotsBrick hShrinkWraptarget: arg1 actionSelector: arg2 arguments: arg3  target := arg1.  selector := arg2.  arguments := arg3glmAnimateValue: arg1 duration: arg2 callback: arg3  self animation ifNotNil: #terminate.  animation := GLMAnimation new     linear;     duration: 200;     from: self scrollValue;     to: (self convertScrollValue: arg1);     ensure: [:arg4 |  arg4 updatePaneBounds.        arg3 brickValue: arg4 ];     animation: [:arg4 :arg5 |  arg4 scrollValue: arg5 ];     animate: selfaddAllBricks: arg1  self band addAllBricks: arg1selectedItem  ^self selectionIndex = 0 ifTrue: [ nil ] ifFalse: [ self glamourPresentation displayValue at: self selectionIndex ]opposite  ^self subclassResponsibilitysubbricksReverseDo: arg1  self subbricks reverseDo: arg1debugSelection  self announce: GLMDebugSelectiontestMultipleSelectionWithChange  | tmp1 tmp2 tmp3 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text display: '123456789' ].  window := tmp1 openOn: 4.  tmp2 := self find: RubScrolledTextMorph in: window.  self assertEmpty: tmp2 selectionInterval.  tmp3 := tmp1 presentations first.  tmp3 selectionInterval: (2 to: 5).  self assert: tmp2 textArea editor selection asString equals: '2345'.  self assert: tmp3 selectedText asString equals: '2345'checkboxWidth  ^18noTitle  title := nil.  titleIcon := nilsize  ^collection sizeworksWithSeaside  ^truebrowser  ^browserid: arg1  id := arg1tabulator  ^self custom: GLMTabulator newtestInterdependentPanesCycleBreak  | tmp1 tmp2 tmp3 |  tmp2 := 0.  tmp3 := 0.  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two;     column: #three.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 ] ].  tmp1 transmit     to: #two;     from: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 * 2 ] ].  tmp1 transmit     to: #three;     from: #two;     andShow: [:arg1 |  arg1 list           display: [:arg2 |  1 to: arg2 * 3 ];           populate: #focus on: $f entitled: 'Focus' with: [:arg3 |  arg3 selection ] ].  tmp1 transmit     toOutsidePort: #focus;     from: #three port: #focus;     transformed: [:arg2 |  tmp2 := tmp2 + 1 ].  tmp1 transmit     to: #one port: #selection;     fromOutsidePort: #focus;     transformed: [:arg2 |  tmp3 := tmp3 + 1 ].  tmp1 startOn: 5.  ((tmp1 paneNamed: #one) port: #selection) value: 3.  ((tmp1 paneNamed: #two) port: #selection) value: 6.  ((tmp1 paneNamed: #three) port: #selection) value: 12.  ((tmp1 paneNamed: #three) port: #focus) value: 12.  self assert: tmp3 equals: 1.  self assert: tmp2 equals: 1actOnPresentationUpdated: arg1  | tmp1 tmp2 |  tmp2 := arg1 presentation matchingPresentations.  tabs pages size to: 1 by: -1 do: [:arg2 |  tabs removePageIndex: arg2 ].  tmp2 do: [:arg3 |  tabs addLazyPage: [ self renderObject: arg3 ] label: (self titleOrIconOf: arg3 in: tabs) toolbar: (self renderToolbarForPresentation: arg3 inMorph: tabs) action: (self labelActionBrickFor: arg3) ].  tmp1 := 1.  tmp2 withIndexDo: [:arg3 :arg2 |  arg1 presentation pane lastActivePresentation notNil and: [ arg3 title = arg1 presentation pane lastActivePresentation title ifTrue: [ tmp1 := arg2 ] ] ].  tabs selectedPageIndex: tmp1markWidthDirty  ^self brick wrappedBounds markWidthDirtyscrollDown: arg1  self scrollBy: (self isLastAdded ifTrue: [ arg1 min: self band brickBounds bottom - self height ] ifFalse: [ arg1 ]) negatedrenderer  ^renderer ifNil: [ renderer := GLMMorphicRenderer new ]scrollBarColor: arg1  self setProperty: #brickScrollbarColor toValue: arg1.  self updateStyleborderColor  ^self theme borderColorbindingOf: arg1  ^self bindingsStrategy cull: self variableBindings cull: arg1buttonSelectedColor  ^Color veryVeryLightGray lighter slightlyDarkeronTextAccepted: arg1  | tmp1 |  tmp1 := (self text asString = arg1 morph text asString) not.  arg1 morph text isEmpty ifFalse: [ self accept ] ifTrue: [ self cancel ].  tmp1 ifTrue: [ self announce: #onAccepted ]customHeight  ^self layout height brickValue: selfaddBrick: arg1 before: arg2  self band addBrick: arg1 before: arg2isAnnouncementSuspended: arg1  ^self suspendAll or: [ | tmp1 |        tmp1 := arg1 isClass ifTrue: [ arg1 ] ifFalse: [ arg1 class ].        self suspendedAnnouncemets anySatisfy: [:arg2 |  tmp1 = arg2 or: [ tmp1 inheritsFrom: arg2 ] ] ]silentValue: arg1  value := arg1morph: arg1  morph := arg1iconFor: arg1  ^self cacheAt: #icon for: arg1 ifAbsentPut: [ self glamourPresentation icon cull: arg1 ]rootsExpanded  self shouldRootsExpand: truehSpaceFill: arg1  super hSpaceFill: arg1.  self label hSpaceFillwithAllPanes  | tmp1 |  tmp1 := OrderedCollection new.  self withAllPanesAndPresentationsDo: [:arg1 |  (arg1 isKindOf: GLMPane) ifTrue: [ tmp1 add: arg1 ] ].  ^tmp1spacing: arg1  spacing := arg1.  self updateInsetAndSpacingshrinkingWidth  self rubric width: self rubric textArea width.  self onLayouted.  ^self rubric textArea widthonPagePushed  self showOrHideScrollBarscrollBarValue: arg1  transform hasSubmorphs ifFalse: [ ^self ].  transform offset: (self leftoverScrollRange * arg1) rounded @ 0testCopyAnnouncementsDoNotRaise  | tmp1 tmp2 |  tmp1 := GLMPane new.  tmp1 when: GLMPresentationsChanged do: [:arg1 |  self fail ].  self assert: tmp1 numberOfSubscriptions equals: 1.  tmp2 := tmp1 copy.  tmp2 announce: GLMPresentationsChanged.  self assert: tmp2 numberOfSubscriptions equals: 0toolbarMorph  ^toolbarMorphrenderGlamorouslyOn: arg1  ^arg1 renderPopupAction: selfdragEnabled  ^self glamourPresentation allowsItemDragbounds: arg1  super bounds: arg1.  self layoutWidgets.  self layoutPanes.  self setScrollDeltasaddModule: arg1 named: arg2  self modules at: arg2 put: arg1.  arg1 themer: self.  ^arg1testInitializeBlockSetsTextSelectionForMethodPresentation  self checkInitializeBlockSetsTextSelectionForPresentation: #pharoMethodeditBrick  ^editBrickannouncerObjects  ^announcerObjects := self computeAnnouncerObjects ifNil: [ OrderedCollection new ]execute  target ifNil: [ ^self ].  selector ifNil: [ ^self ].  target perform: selector withArguments: argumentshighlightEvaluateAndDo: arg1  self announce: (GLMHighlightAndEvaluate new action: arg1)sliderBrick: arg1  sliderBrick := arg1.  self sliderBrick     pagerModel: self pagerModel;     height: self pagerModel circleButtonSize;     width: [ self pagerModel circleButtonSize * self pagerModel actualNumberOfVisiblePages ].  self sliderBrick layout floating: #left.  self addBrickBack: self sliderBrickpresentations: arg1  oldMatchingPresentations: arg1  oldMatchingPresentations := arg1isSplitIntoRows  ^self children allSatisfy: [:arg1 |  arg1 isRow ]dataCacheFor: arg1  ^self dataCache at: arg1 ifAbsentPut: [ Dictionary new ]maxHeight  ^maxHeight ifNil: [ maxHeight := Float infinity ]textBlock  ^textBlocktestSelectToLeft  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel switchPaneTo: 6.  self assert: pagerModel numberOfVisiblePages equals: 2.  self assert: pagerModel selectedPageIndex equals: 6.  self assert: pagerModel firstVisiblePageIndex equals: 5.  self assert: pagerModel lastVisiblePageIndex equals: 6.  pagerModel selectToLeft.  self assert: pagerModel selectedPageIndex equals: 5.  self assert: pagerModel firstVisiblePageIndex equals: 5.  self assert: pagerModel lastVisiblePageIndex equals: 6.  pagerModel selectToLeft.  self assert: pagerModel selectedPageIndex equals: 4.  self assert: pagerModel firstVisiblePageIndex equals: 4.  self assert: pagerModel lastVisiblePageIndex equals: 5.  pagerModel selectToLeft.  self assert: pagerModel selectedPageIndex equals: 3.  self assert: pagerModel firstVisiblePageIndex equals: 3.  self assert: pagerModel lastVisiblePageIndex equals: 4.  pagerModel selectToLeft.  self assert: pagerModel selectedPageIndex equals: 2.  self assert: pagerModel firstVisiblePageIndex equals: 2.  self assert: pagerModel lastVisiblePageIndex equals: 3.  pagerModel selectToLeft.  self assert: pagerModel selectedPageIndex equals: 1.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 2lazyPageMorphCreation  ^lazyPageMorphCreationclick: arg1  self announce: #onClicked event: arg1.  ^falseonPagesNumberChanged  self maxPanes: pagerModel numberOfVisiblePages.  self doLayoutForce.  self scrollToPane: pagerModel firstVisiblePageIndex smooth: falseinnerBounds  ^innerBounds ifNil: [ self updateCache.        innerBounds ]layout: arg1 in: arg2  ^self subclassResponsibilitytranslateY: arg1  self wrappedBounds translateY: arg1executeMenuAction: arg1  self announce: (GLMMenuItemSelected action: arg1)testClose  | tmp1 |  tmp1 := GLMFinder new.  window := tmp1 openOn: 123.  self assert: window owner notNil.  tmp1 close.  self assert: window owner isNilmoveLeft: arg1  | tmp1 |  tmp1 := arg1 + self width.  self changedWith: [:arg2 |  arg2 translateXTo: arg1.        arg2 leftPosition: arg1 ].  pagerModel notifyScrollerBoundsChanged: arg1 @ tmp1marginTop  ^self brick marginTopglamourPresentation  ^glamourPresentationstart  ^startpresentation  ^GLMCompositePresentation new with: [:arg1 |  | tmp1 tmp2 |        tmp1 := arg1 text.        tmp2 := RubUnderlinedSegmentMorph from: 1 to: 29.        tmp2 icon: (self iconNamed: #smallErrorIcon).        tmp2 label: 'Please review'.        tmp2 iconBlock: [:arg2 :arg3 |  arg2 delete ].        tmp1 addTextSegment: tmp2.        tmp2 := RubPlainSegmentMorph from: 535 to: 659.        tmp2 color: (Color green alpha: 0.3).        tmp2 icon: (self iconNamed: #smallErrorIcon).        tmp2 label: 'Remove'.        tmp2 iconBlock: [:arg2 :arg3 |  arg2 textArea selectFrom: arg2 firstIndex to: arg2 lastIndex.              arg2 textArea replaceSelectionWith: ''.              arg2 delete ].        tmp1 addTextSegment: tmp2.        tmp2 := RubUnderlinedSegmentMorph from: 1000 to: 1030.        tmp2 icon: (self iconNamed: #smallHelpIcon).        tmp2 label: 'Print it'.        tmp2 iconBlock: [:arg2 :arg3 |  self trace: arg2 getText ].        tmp1 addTextSegment: tmp2 ]margin  ^1spawn: arg1 entitled: arg2  self addAction: (GLMSpawnBrowserAction new           action: arg1;           title: arg2;           yourself)act: arg1 icon: arg2 on: arg3 entitled: arg4  self addAction: (GLMGenericAction new           action: arg1;           shortcut: arg3;           icon: arg2;           title: arg4;           yourself)pageIndex  ^pageIndextestPaneReplacedAnnouncement  | tmp1 tmp2 |  tmp2 := 0.  tmp1 := GLMFinder new.  tmp1 when: GLMPaneReplaced do: [:arg1 |  tmp2 := tmp2 + 1 ].  tmp1 startOn: #a.  self assert: tmp2 equals: 0.  (tmp1 panes first port: #selection) value: #b.  self assert: tmp2 equals: 0.  (tmp1 panes second port: #selection) value: #c.  self assert: tmp2 equals: 0.  (tmp1 panes first port: #selection) value: #d.  self assert: tmp2 equals: 1.  tmp1 entity: #e.  self assert: tmp2 equals: 2filterBlock  ^self parameters at: 'filterBlock'morphicSelectionAct: arg1 icon: arg2 entitled: arg3  self addSelectionAction: (GLMMorphicAction new           action: arg1;           icon: arg2;           title: arg3;           yourself)parameters  ^parameterscreateDataSourceFrom: arg1  self subclassResponsibilityorigin: arg1  origin := arg1.  self computeVerticescontainerTree  ^containerTreeactOnPresentationUpdated: arg1  | tmp1 |  tmp1 := arg1 presentation selectionInterval.  textMorph setText: arg1 presentation formatedDisplayValue.  textMorph setSelection: tmp1rubricBorderWidth  ^0testSimpleColumns  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 addColumn: #first.  tmp1 addColumn: #second.  self assert: tmp1 cell children size equals: 2newBrickWithFullFill  ^GLMBrick new     hSpaceFill;     vSpaceFill;     color: Color random;     yourselfthemerChanged  self onThemerChanged.  self morph brickThemerChangedactionBlock  ^self parameters at: 'actionBlock'selectToRight  self selectedPageIndex: self selectedPageIndex + 1isVertical  ^self isHorizontal nottestPublishingToOutsideFinder  | tmp1 tmp2 |  tmp2 := GLMFinder new.  tmp1 := GLMTabulator new.  tmp1 column: #any.  tmp1 transmit     to: #any;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: 43 ] ].  tmp1 transmit     toOutsidePort: #selection;     from: #any port: #selection.  tmp2 show: [:arg1 |  arg1 custom: tmp1 ].  tmp2 startOn: 43.  self assert: (tmp2 panes first port: #entity) value equals: 43.  self assert: (tmp2 panes first port: #selection) value isNil.  ((tmp2 panes first presentations first paneNamed: #any) port: #selection) value: 42.  self assert: (tmp2 panes first port: #selection) value equals: 42.  self assert: (tmp2 panes first port: #entity) value equals: 43.  self assert: tmp2 panes size equals: 2.  self assert: (tmp2 panes last port: #entity) value equals: 42.  self assert: (tmp2 panes first presentations first isKindOf: GLMTabulator).  self assert: (tmp2 panes last presentations first isKindOf: GLMTabulator).  self assert: (tmp2 panes first presentations first isKindOf: GLMTabulator)inset  ^insetcreateDataSourceFrom: arg1  ^GLMFastTreeTableDataSource newupdatePaneBounds  self band updateMorphBoundsbackgroundColor  ^self borderColor muchLighter darkertestAdd  | tmp1 |  tmp1 := GLMCompositePresentation new.  tmp1 add: GLMPresentation new.  self deny: tmp1 isEmpty.  self assert: tmp1 presentations size equals: 1fastTreeTable  ^self custom: GLMFastTreeTablePresentation newscrollToPane: arg1  self scrollToPane: arg1 callback: nilcurrentPresentation  | tmp1 |  tmp1 := GLMCompositePresentation new.  self presentationTransformation glamourValue: tmp1 asGlamorousMultiValue , self displayValue asGlamorousMultiValue.  tmp1 pane: self pane.  tmp1 initializePresentation.  cachedPresentation := tmp1.  ^tmp1displayValue  ^cachedDisplayedValue := self transformation glamourValue: self entitytakeKeyboardFocus  self rubric takeKeyboardFocusmarkHeightClean  ^self brick wrappedBounds markHeightCleansetLabelWidgetAllowance  ^labelWidgetAllowance := super setLabelWidgetAllowance + (toolbarBox ifNil: [ 0 ] ifNotNil: [:arg1 |  toolbarBox width ])testInvalidateSelection  (browser panes first port: #selection) value: 3.  entity removeLast.  announcer announce: GLMTestAnnouncement.  self assert: (browser panes first port: #selection) value isNil.  self assert: listMorph model selection isNiltestValidate  | tmp1 tmp2 |  tmp1 := GLMPane named: 'test'.  tmp2 := GLMPresentation new.  tmp1 addPresentation: tmp2.  tmp2 entity: (OrderedCollection with: 1 with: 2).  self assert: (tmp2 validate: 1 on: (tmp1 port: #foo)).  self assert: (tmp2 validate: 2 on: (tmp1 port: #foo)).  self assert: (tmp2 validate: 5 on: (tmp1 port: #foo))openAbove: arg1  | tmp1 |  tmp1 := arg1 origin - (0 @ self contentBrick height) - (0 @ self inset top).  ^self openAt: tmp1testCreation  self assertEmpty: GLMCompositePresentation newsize: arg1  size := arg1rowHeight: arg1  self parameters at: 'rowHeight' put: arg1silentValue: arg1  self port silentValue: arg1selectionIndex  ^selectionIndex ifNil: [ selectionIndex := self glamourPresentation selectedIndex ]finder  ^self custom: GLMFinder newfixedSizePanes  ^fixedSizePanes ifNil: [ fixedSizePanes := 2 ]open: arg1  ^self doOpen: (self render: arg1)selectionActions: arg1  selectionActions := arg1zIndex: arg1  zIndex := arg1onPagePoped  | tmp1 |  tmp1 := self buttons removeLast.  tmp1 announcer unsubscribe: self.  self owner changed.  self removeBrick: tmp1.  self updateButtonstestTriggerConditions  | tmp1 tmp2 tmp3 |  tmp1 := GLMTransmission new.  tmp2 := GLMSimplePort new name: #port1.  tmp3 := GLMSimplePort new name: #port2.  tmp1 addActiveOrigin: tmp2.  tmp1 addPassiveOrigin: tmp3.  tmp1 destination: (GLMPort new name: #port3).  self assert: (tmp1 originatesAt: tmp2).  self assert: (tmp1 originatesAt: tmp3) notcalculateScrollbarHeight  ^((self scrollPane height min: (self scrollPane layout maxHeight brickValue: self scrollPane)) / self scrollPane band height * (self height min: (self scrollPane layout maxHeight brickValue: self scrollPane))) ceilingmarginBottom: arg1  < brickBuilderProperty: #Geometry name: 'Margin Bottom' as: #asInteger getter: #marginBottom model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds marginBottom: arg1markClean: arg1  arg1 markHeightCleanspecificTableMorphInitializiation  self specificTableMorphColumnsInitialization.  super specificTableMorphInitializiationreceive: arg1 in: arg2  self port receive: arg1 in: arg2withAllPanes  | tmp1 |  tmp1 := OrderedCollection new.  self withAllPanesAndPresentationsDo: [:arg1 |  (arg1 isKindOf: GLMPane) ifTrue: [ tmp1 add: arg1 ] ].  ^tmp1toggle  self isExpanded ifTrue: [ self collapse ] ifFalse: [ self expand ]isColumn  ^falseisSelectionPort  ^self name = #selectionselection  ^self glamourPresentation selectionInterval ifNil: [ 1 to: 0 ]withWidth: arg1  ^self brick withWidth: arg1triggerBrick  < return: #GLMInteractableBrick>  self assert: [ triggerBrick isNotNil ] description: [ 'Trigger brick can not be nil' ].  ^triggerBrickonDrawAthensCanvas: arg1  self renderer render: self onAthensCanvas: arg1withAllPanesAndPresentationsDo: arg1  ^arg1 value: selfinitialize  super initialize.  isChecked := false.  isPressed := false.  isSelected := false.  self disablecomputeTagsFor: arg1  ^self computeTagsFor: arg1 from: self tagsBlockinactiveTitleFillStyle  ^SolidFillStyle color: Color transparentpaddingBottom  ^self padding at: BottomtranslateY: arg1  self translateBy: 0 @ arg1action: arg1  action := arg1test100DependsOnChildrenBricksInsideOneStatic  | tmp1 tmp2 |  tmp1 := self newBrickWithFullDependsOnChildren.  tmp2 := tmp1.  1 to: 99 do: [:arg1 |  tmp2 := tmp2 addBrickBack: self newBrickWithFullDependsOnChildren ].  tmp2 := tmp2 addBrickBack: self newBrickWithStaticExtent.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: tmp2 extenteditingMode: arg1  editingMode := arg1viewRowMorphForColumn: arg1 node: arg2 withIndex: arg3  ^(self valueFor: arg2 withIndex: arg3 in: arg1) asMorph asReadOnlyMorphcolumn: arg1 span: arg2  ^self addColumn: arg1 span: arg2markLayoutClean: arg1  arg1 ifNotNil: [:arg2 |  arg2 markLayoutClean ]textBackgroundColorFor: arg1  ^self textBackgroundColor glamourValue: arg1 asGlamorousMultiValue , self entity asGlamorousMultiValueprofileSelection  textMorph tallyItextent  ^self brickBounds extentformatSourceCode  self announce: GLMFormatCodehighlight: arg1  highlightedString := arg1.  self changedinitialize  super initialize.  pagesCount := 0.  selectedPageIndex := 0.  focusedViews := Dictionary new.  isDependenciesShown := false.  numberOfVisiblePages := self defaultNumberOfVisiblePages.  firstVisiblePageIndex := 0.  lastVisiblePageIndex := 0.  self invariantpopPane  self pagerModel popPane: trueasyncTask  ^asyncTask ifNil: [ asyncTask := GLMAsyncTask new ]when: arg1 do: arg2  ^self announcer when: arg1 do: arg2row: arg1 size: arg2  ^self addRow: arg1 size: arg2childrenValueOf: arg1 atLevel: arg2  ^self children glamourValue: arg1 asGlamorousMultiValue , self entity asGlamorousMultiValue , arg2 asGlamorousMultiValue , self asGlamorousMultiValueparser  ^parsersetText: arg1 from: arg2  self glamourPresentation text: arg1.  ^truesendOneOrMultipleAs: arg1 updatedBy: arg2  self send: [:arg3 |  arg3 ifNotNil: [ arg3 size = 1 ifTrue: [ (arg3 first isCollection and: [ arg3 first size = 1 ]) ifTrue: [ arg3 first first ] ifFalse: [ arg3 first ] ] ifFalse: [ arg2 cull: (arg3 as: arg1) ] ] ]withGhostText: arg1  withGhostText := arg1removeAllPanes  self panes do: [:arg1 |  arg1 unregisterFromAllAnnouncements ].  ^self panes removeAlleditRowMorphForColumn: arg1 node: arg2 withIndex: arg3  | tmp1 |  tmp1 := self viewRowMorphForColumn: arg1 node: arg2 withIndex: arg3.  tmp1 hResizing: #spaceFill.  tmp1 on: #mouseDown send: #value: to: [:arg4 |  arg4 shiftPressed ifTrue: [ GLMEditorPopupBrick new                 in: [:arg5 |  arg5 themer: arg5 themer popupEditorBorderThemer themer ];                 closer: (GLMPopupBrickCloser new                       predicate: GLMPopupBrickOutisideClickPredicate new;                       predicate: GLMPopupBrickEscPredicate new;                       yourself);                 textModel: (self valueFor: arg2 withIndex: arg3 in: arg1);                 when: #textAccepted do: [:arg6 |  arg1 modifiedBlock cull: arg6 morph text cull: arg2 cull: self glamourPresentation ];                 openOn: tmp1 ] ifFalse: [ arg4 wasHandled: false ] ].  ^tmp1origin: arg1 length: arg2 breadth: arg3  ^arg1 - (0 @ arg2) extent: arg3 @ arg2transformedEntity: arg1  transformedEntity := arg1removeAllBricks  self band removeAllBricks.  self scrollToTopcolorValue  ^self color notNil ifTrue: [ self color glamourValue: self entity ] ifFalse: [ self color ]testSimple  GLMPresentation new announce: GLMContextChanged new.  self assert: GLMLogger instance announcements size equals: 1isMultiple  ^allowsMultipleSelection ifNil: [ allowsMultipleSelection := false ]workspaceBindingsStrategy  ^[:arg1 :arg2 |  (arg1 includesKey: arg2) ifFalse: [ arg1 add: (WorkspaceVariable key: arg2 asSymbol) ].  arg1 associationAt: arg2 ]parameters  ^parametersscrollbarWidth  ^2resetElements  self resetDataCache.  elements := nilstyler: arg1  styler := arg1.  styler view: selfborderColor: arg1  < brickBuilderProperty: #'Look&Feel' name: 'Border color' as: #brickBuilderEvaluate getter: #borderColor model: #GLMUIBuilderTextFieldProperty>  self border color: arg1scrollbarWidth: arg1  self setProperty: #brickScrollbarWidth toValue: arg1.  self updateStyleanimateToNormal  self borderAnimation     from: self borderColor first;     to: (self borderColor first alpha: 0);     animate: selftestPaneAddedAnnouncement  | tmp1 tmp2 |  tmp2 := 0.  tmp1 := GLMFinder new.  tmp1 when: GLMPaneAdded do: [:arg1 |  tmp2 := tmp2 + 1 ].  tmp1 startOn: #a.  self assert: tmp2 equals: 1.  (tmp1 panes first port: #selection) value: #b.  self assert: tmp2 equals: 2globalBoundsTranslateFactor  ^self globalBounds originannouncer  ^announcer ifNil: [ announcer := Announcer new ]buttonsMorphs  ^pagerMorph subbricks second subbricks second subbricksexecuteMenuAction: arg1  self containerTree announce: (GLMMenuItemSelected action: arg1)onSelectedPageChanged  self panes do: [:arg1 |  arg1 borderColor: Color transparent ].  self theme pagerWidgetThemer selectedPaneStyleFor: (self panes at: pagerModel selectedPageIndex)initialize  super initialize.  self useVerticalLinearLayoutrenderer: arg1  self setProperty: #brickRenderer toValue: arg1morphAtLogic: arg1  morphLogic := arg1testDefaultPane  | tmp1 |  tmp1 := GLMCompositePresentation new.  self assert: tmp1 pane presentations equals: tmp1testTextPortPopulatedByDefault  | tmp1 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text ].  window := tmp1 openOn: '42'.  self assert: (tmp1 pane port: #text) value asString equals: '42'vShrinkWrap  self layout vShrinkWraptitleLogic  ^self valueOfProperty: #phlowTitle ifAbsent: [ '' ]testMarkerOneStaticInChildrenHeight  | tmp1 tmp2 |  tmp1 := self newBrickWithFullDependsOnChildren.  tmp2 := self newBrickWithStaticExtent.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthClean.  self assert: tmp2 wrappedBounds isHeightDirty.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightDirtyrenderPharoMethodPresentation: arg1  ^GLMMorphicPharoMethodRenderer render: arg1 from: selftestUnregisterFromAnnouncementsWhenUpdating  | tmp1 tmp2 tmp3 |  tmp3 := 0.  tmp2 := GLMAnnouncingCollection new.  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text           updateOn: GLMItemAdded from: [ tmp2 ];           display: [ tmp3 := tmp3 + 1.              tmp3 asString ] ].  window := tmp1 openOn: tmp2.  1 to: 3 do: [:arg2 |  tmp2 add: arg2 ].  self assert: tmp3 equals: 4drawSubmorphsOn: arg1  arg1 translateBy: self bounds origin - self morph bounds origin + (self paddingLeft @ self paddingTop) during: [:arg2 |  self morph fullDrawOn: arg2 ]rowMorphForElement: arg1  | tmp1 |  tmp1 := OrderedCollection new.  (self iconFor: arg1) ifNotNil: [:arg2 |  tmp1 add: arg2 asMorph ].  tmp1     add: (self formatedDisplayValueOf: arg1) asMorph asReadOnlyMorph;     addAll: (self tagMorphsFrom: self glamourPresentation for: arg1).  ^self theme newRowIn: self currentWorld for: tmp1initialize  super initializewantsExpandBox  ^falsecontentBrick  ^contentBrickrubricTextColor  ^self textColorlabel  ^self custom: GLMLabelPresentation newinitialize  super initialize.  smooth := falseaddCloserListener  self assert: [ self closer isNotNil ] description: [ 'Closer must not be nil' ].  self closer popup: self.  self activeHand addEventListener: self closerswitchPaneTo: arg1  | tmp1 |  self invariant.  tmp1 := self normalizePaneIndex: arg1.  self scrollToPane: tmp1.  self focusPaneAt: tmp1.  selectedPageIndex := tmp1.  self notifySelectedPageChanged.  self invariantpadding  ^padding ifNil: [ padding := Array braceWith: 0 with: 0 with: 0 with: 0 ]onChildrenLayouted  super onChildrenLayouted.  self band translateXTo: (self convertScrollValue: (self pagerModel convertIndexToValue: self pagerModel firstVisiblePageIndex))withTextSegments: arg1  self textSegments addAll: arg1testNamedIn  | tmp1 |  tmp1 := GLMPane named: 1 in: 2.  self assert: tmp1 name equals: 1.  self assert: tmp1 browser equals: 2.  self assertEmpty: tmp1 ports.  self assert: tmp1 presentations isEmptytestPastingUpdatesTextPort  | tmp1 tmp2 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text display: '' ].  window := tmp1 openOn: 42.  tmp2 := self find: RubEditingArea in: window.  Clipboard clipboardText: '42'.  tmp2 editor paste.  self assert: (tmp1 pane port: #text) value asString equals: '42'isSearchable  ^self parameters at: 'isSearchable' ifAbsent: [ false ]pageOf: arg1  | tmp1 tmp2 |  arg1 ifNil: [ ^0 ].  tmp1 := arg1.  [ tmp1 isNotNil & (tmp1 == self band) not ] whileTrue: [ tmp2 := tmp1.        tmp1 := tmp1 owner ].  ^tmp1 ifNil: [ 0 ] ifNotNil: [ self panes indexOf: tmp2 ]onPagePoped: arg1  self popPane: arg1 smoothsetUp  super setUp.  uiWaitingSemaphore := Semaphore newexpandedUntil: arg1  self shouldExpandToLevel: arg1minWidth: arg1  self layout minWidth: arg1matches  < debuggingStone: #presentationCondition label: 'Presentation condition'>  ^(self usesImplicitAllNil ifTrue: [ GLMAllNilCondition new glamourValue: self entity ] ifFalse: [ self usesImplicitNotNil ifTrue: [ GLMAllNotNilCondition new glamourValue: self entity ] ifFalse: [ GLMSomeNotNilCondition new glamourValue: self entity ] ]) and: [ (self condition glamourValue: self entity) = true ]testPushPanesAfterOpen  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self openInWindow.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self assert: pagerModel size equals: 3.  self assert: self panesMorphs size equals: 3.  self assert: self buttonsMorphs size equals: 3asBrickedMorph  ^GLMFoundationBrick new brickRoot: selfcalculateHighlightingBounds  | tmp1 tmp2 tmp3 |  tmp2 := OrderedCollection new.  tmp1 := (self calculateTextPosition extent: self textSize) translateBy: (0 @ 0) negated.  tmp3 := self text asLowercase findString: self highlightedText asLowercase startingAt: 1.  tmp3 = 0 ifTrue: [ ^tmp2 ].  [ tmp3 > 0 ] whileTrue: [ | tmp4 tmp5 tmp6 |        tmp6 := self text copyFrom: tmp3 to: tmp3 + self highlightedText size - 1.        tmp5 := self sizeOf: tmp6.        tmp4 := self sizeOf: (self text first: tmp3 - 1).        tmp2 add: ((tmp1 translateBy: tmp4 x @ 0) withWidth: tmp5 x).        tmp3 := self text asLowercase findString: self highlightedText asLowercase startingAt: tmp3 + 1 ].  ^tmp2computeFullBounds  isPassive  ^self isActive notparser: arg1  parser := arg1enableFilterWithAction: arg1  self enableFilter.  self parameters at: 'actionBlock' put: arg1whenKindOf: arg1  self when: [:arg2 |  arg2 isKindOf: arg1 ]setFastTableLayoutFrame: arg1  arg1 layoutFrame: LayoutFrame identitytagsBlock: arg1  tagsBlock := arg1scrollToBottom  self scrollTo: self model countbrowser  ^browsertestCopyAnnouncements  | tmp1 tmp2 |  tmp1 := GLMPane new.  tmp1 when: GLMPresentationsChanged do: [:arg1 |  self fail ].  self assert: tmp1 numberOfSubscriptions equals: 1.  tmp2 := tmp1 copy.  tmp2 announce: GLMPresentationsChanged.  self assert: tmp2 numberOfSubscriptions equals: 0table  ^self custom: GLMTablePresentation newfromOutsideEntityPort  ^self fromOutsidePort: #entitydisplay: arg1  self subclassResponsibilitytestExplicitAcceptDoesNotAffectTextPort  | tmp1 tmp2 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 pharoScript display: '123' ].  window := tmp1 openOn: 4.  window position: 0 @ 0.  window extent > Display extent ifTrue: [ ^self ].  tmp2 := self find: RubScrolledTextMorph in: window.  tmp2 simulateClick.  self simulateKeyStrokes: '4'.  self assert: (tmp1 pane port: #text) value equals: '1234'.  self simulateKeyStroke: $s meta.  self simulateKeyStrokes: '56'.  self assert: (tmp1 pane port: #text) value equals: '123456'data  ^self valueOfProperty: #brickDataObject ifAbsentPut: [ nil ]onLayouted  super onLayouted.  self label isFitsInParent ifTrue: [ self isDotsAdded ifTrue: [ self privateRemoveBrick: self dotsBrick.              self doLayoutForce.              self changed ] ] ifFalse: [ self isDotsAdded ifFalse: [ self privateAddBrickBack: self dotsBrick.              self dotsBrick wrappedBounds height: self outerBounds height.              self layoutPolicy layoutFloating: self dotsBrick in: self brickBounds.              self doLayoutForce.              self changed ] ]logAnnouncement: arg1 from: arg2  announcements add: arg1contentPadding  ^5renderTabulator: arg1  ^GLMMorphicTabulatorRenderer render: arg1 from: selfisTerminated  process ifNil: [ ^true ].  ^process isTerminatedwidthParentDependency: arg1  arg1 owner ifNil: [ Exception signal: 'My width depends on parent, but it is nil' ].  ^(arg1 owner innerBounds width * arg1 layout hPercent / 100) ceilingcompositePanel  | tmp1 |  tmp1 := self compositeMorph.  self assert: (tmp1 isKindOf: PanelMorph).  self assert: (tmp1 submorphs allSatisfy: [:arg1 |  arg1 isKindOf: ExpanderMorph ]).  ^tmp1approximateHeight  ^self label approximateHeight + self vMargin + self vPaddinginitialize  super initialize.  stringBrick := self newStringBrick.  dotsBrick := self newStringBrick.  self     hShrinkWrap;     vShrinkWrap.  stringBrick marginRight: self defaultInsetBeforeDots.  self privateAddBrickBack: stringBrick.  dotsBrick     text: self defaultDotsText;     width: #approximateWidth;     floating: #right;     zIndex: 2;     marginTop: 1paddingBottom  ^self wrappedBounds paddingBottomisEnabled  ^isEnabledtranslateXTo: arg1  self translateX: self brickBounds left negated + arg1tagsFilter: arg1  tagsFilterBlock := arg1test100StaticBricksInsideEachOtherIndideStatic  | tmp1 tmp2 |  tmp1 := self newBrickWithStaticExtent.  tmp2 := tmp1.  1 to: 100 do: [:arg1 |  tmp2 := tmp2 addBrickBack: self newBrickWithStaticExtent ].  self assertAllSubbricksAreClean: tmp1.  self assert: tmp2 extent equals: tmp1 extentupdateOn: arg1 from: arg2 when: arg3  updateActions add: (GLMSingleUpdateAction new           presentation: self;           announcement: arg1;           transformation: arg2;           condition: arg3;           yourself)updateVariableBindings  self announce: (GLMVariableBindingsChanged new presentation: self)layout: arg1 on: arg2  arg2 layoutChildrenOf: arg1.  arg2 updateDimension: arg1.  arg2 markClean: arg1.  arg2 layoutOwnerOf: arg1actionArguments  ^{}heightDependencies  ^heightDependencies ifNil: [ heightDependencies := OrderedCollection new ]existsUIProcess  ^UIManager default uiProcess isNotNiltestActions  | tmp1 |  tmp1 := GLMPresentation new.  tmp1 actions isEmpty.  tmp1 addAction: GLMAction new.  tmp1 actions size = 1on: arg1 do: arg2 ifAbsent: arg3  | tmp1 |  tmp1 := (arg1 cull: self) ifTrue: [ self ] ifFalse: arg3.  arg2 cull: tmp1.  ^tmp1morph: arg1 withToolbarOf: arg2  | tmp1 tmp2 tmp3 |  arg2 hasActions ifFalse: [ ^arg1 ].  tmp1 := GLMMorphic containerMorph.  tmp2 := 0.  tmp3 := self renderToolbarForPresentation: arg2 inMorph: tmp1.  tmp2 := tmp3 minExtent y.  tmp1 addMorph: tmp3 fullFrame: (LayoutFrame identity           bottomFraction: 0;           bottomOffset: tmp2).  tmp1 addMorph: arg1 fullFrame: (LayoutFrame identity topOffset: tmp2).  ^tmp1column: arg1 evaluated: arg2 modified: arg3  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           modifiedBlock: arg3)updateColumnMorphs  super updateColumnMorphs.  self resizeColumnslabel: arg1 selected: arg2  arg1 vSpaceFill.  arg2 vSpaceFill.  self maxWidth: arg1 layout maxWidth.  self     normalLabel: arg1;     selectedLabel: arg2;     selected: self isSelected.  self doLayoutForcetestSuspendParticularAnnouncementWhile  | tmp1 tmp2 |  announcer when: GLMTestAnnouncement do: [:arg1 |  tmp1 := arg1 ].  announcer when: GLMTestAnnouncement2 do: [:arg1 |  tmp1 := arg1 ].  tmp1 := nil.  tmp2 := announcer announce: GLMTestAnnouncement.  self assert: tmp1 equals: tmp2.  tmp1 := nil.  announcer suspendAll: {GLMTestAnnouncement} while: [ tmp2 := announcer announce: GLMTestAnnouncement ].  self assert: tmp1 isNil.  tmp1 := nil.  announcer suspendAll: {GLMTestAnnouncement} while: [ tmp2 := announcer announce: Announcement ].  self assert: tmp1 isNil.  tmp1 := nil.  announcer suspendAll: {GLMTestAnnouncement} while: [ tmp2 := announcer announce: GLMTestAnnouncement2 ].  self assert: tmp1 equals: tmp2index  ^indexspecificDataSourceInitializiation  | tmp1 |  super specificDataSourceInitializiation.  tmp1 := tableModel glamourPresentation.  tableModel     childrenBlock: tmp1 children;     maxDepth: tmp1 maxDepth;     searchStrategy: tmp1 strategyonLayouted  super onLayouted.  self translateXTo: self leftPositionmarginRight: arg1  < brickBuilderProperty: #Geometry name: 'Margin Right' as: #asInteger getter: #marginRight model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds marginRight: arg1floating: arg1  floating := arg1area  | tmp1 tmp2 |  tmp1 := self subbricks first outerBounds.  tmp2 := self subbricks second outerBounds.  ^GLMArea origin: tmp1 origin vectors: {(GLMVector east: tmp1 width) .         (GLMVector south: tmp1 height) .         (GLMVector horizontal: tmp2 corner x - tmp1 corner x) .         (GLMVector south: tmp2 height) .         (GLMVector west: tmp2 width) .         (GLMVector north: tmp2 height) .         (GLMVector horizontal: tmp1 origin x - tmp2 origin x) .         (GLMVector north: tmp1 height)}elementOrZeroAt: arg1  ^arg1 = 0 ifTrue: [ 0 ] ifFalse: [ self elementAt: arg1 ]addColumn: arg1  self columns add: arg1priority: arg1  priority := arg1withAllPanesAndPresentationsDo: arg1  super withAllPanesAndPresentationsDo: arg1.  self do: [:arg2 |  arg2 withAllPanesAndPresentationsDo: arg1 ]on: arg1  origin := arg1convertValueToIndex: arg1  ^(self size - self actualNumberOfVisiblePages) * arg1 + 1titleIcon: arg1  titleIcon := arg1lastActivePresentation: arg1  textColor  ^self theme textColortestMarkerOneParentInParentWidth  | tmp1 tmp2 |  tmp1 := self newBrickWithFullFill.  tmp2 := self newBrickWithFullFill.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthDirty.  self assert: tmp2 wrappedBounds isHeightClean.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightCleantestMarkerOneChildrenInStaticHeight  | tmp1 tmp2 |  tmp1 := self newBrickWithStaticExtent.  tmp2 := self newBrickWithFullDependsOnChildren.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthClean.  self assert: tmp2 wrappedBounds isHeightDirty.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightCleanstepTime  ^self model stepTimerender: arg1  | tmp1 tmp2 |  tmp1 := arg1 matchingPresentations.  tmp1 isEmpty ifTrue: [ ^GLMMorphic emptyMorph ].  tmp2 := GLMMorphic containerMorph.  tmp2 changeTableLayout.  tmp1 do: [:arg2 |  tmp2 addMorphBack: (self renderWithTitle: arg2) ].  ^tmp2stackedArrangement  ^self stackedVerticallyArrangementisClean: arg1  ^arg1 isHeightCleanfindLast: arg1 in: arg2  ^self findLastSatisfying: [:arg3 |  arg3 isKindOf: arg1 ] in: arg2scrollbarColor  ^Color lightGray alpha: 0.5forbiddenAnnouncements: arg1  forbiddenAnnouncements := arg1statusbarPresentation  ^GLMLabelPresentation newonEscapePressed  self isCancelOnEscape ifTrue: [ self cancel ]testRemoveAllPages  tabs removePage: tabs pages first.  tabs removePage: tabs pages first.  self assertEmpty: tabs pages.  self assertEmpty: tabs contentMorph submorphsminHeight: arg1  self layout minHeight: arg1category: arg1  category := arg1contents  ^contents ifNil: [ contents := self allContents select: [:arg1 |  arg1 shouldBeDisplayed ] ]updateDimension: arg1  arg1 isWidthClean ifTrue: [ ^self ].  (self dimensionPolicy: arg1) updateWidth: arg1outerPortEvent: arg1  super outerPortEvent: arg1.  self cachedPresentation ifNotNil: [ self cachedPresentation outerPortEvent: arg1 ]announcer  ^announcer ifNil: [ announcer := GLMAnnouncer new ]tagsBlock: arg1  tagsBlock := arg1condition: arg1  condition := arg1makeSyncronous  isSyncronous := truelabel  ^self addBrickBack: self newLabelselectedText  ^(self pane port: #selectedText) value ifNil: [ self selectedTextBlock value ] ifNotNil: [ (self pane port: #selectedText) value ]closer: arg1  self removeCloserListener.  closer := arg1.  self addCloserListenerannouncements  ^announcementsrenderTabbedCompositePresentation: arg1  ^GLMMorphicTabbedRenderer render: arg1 from: selfprintSelection  self announce: GLMPrintSelectionnewRubricMorph  ^GLMRubEditingArea new beWrappedcreateSimplePaneMorph  ^Morph newonCreated  self contentBrick padding: #(5 0).  self titleBrick: self newTitleBrick.  self hintBrick: self newHintBrickenabledCondition  ^enabledCondition ifNil: [ true ]testOuterEntity  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 text ].  tmp1 transmit     to: #two;     fromOutsidePort: #entity;     andShow: [:arg1 |  arg1 text ].  tmp1 startOn: 42.  self assert: tmp1 transmissions first origins anyOne name equals: #entity.  self assert: tmp1 transmissions last origins anyOne name equals: #entity.  self assert: tmp1 transmissions size equals: 2next: arg1  next := arg1testWhenCondition  | tmp1 tmp2 tmp3 |  tmp1 := GLMTransmission new.  tmp2 := GLMSimplePort new     name: #port1;     value: #value1.  tmp3 := GLMSimplePort new name: #port2.  tmp1 addActiveOrigin: tmp2.  tmp1 destination: tmp3.  tmp1 condition: [:arg1 |  arg1 = #value1 ].  self assert: tmp1 meetsCondition.  tmp1 transmit.  self assert: tmp3 value equals: #value1renderSpecPresentation: arg1  ^GLMMorphicSpecRenderer render: arg1 from: selfmeasureSelectionTimeInFinderForSize: arg1  | tmp1 tmp2 tmp3 |  tmp1 := self defaultFinderBrowser.  tmp3 := tmp1 openOn: arg1.  tmp2 := Time millisecondsToRun: [ arg1 timesRepeat: [ (tmp3 model panes last port: #selection) value: arg1 ] ].  tmp3 delete.  ^{arg1 .   tmp2}hasMinWidth  ^(self minWidth isNumber ifTrue: [ self minWidth <= 0 ] ifFalse: [ false ]) notupdateTriggerBrick  | tmp1 |  tmp1 := self anchorBrick brickImageForm: self themer popupThemer backgroundColor.  self triggerBrick icon: tmp1window: arg1  window := arg1filterOn: arg1  self error: 'This presentation does not allow filtering with a block for now. In the futur we should have a new filter with FastTable to do that. If you want to give it a try look FTFunction and his subclasses.'removeAllMorphs  | tmp1 tmp2 |  tmp2 := self world.  submorphs do: [:arg1 |  tmp2 ifNotNil: [ arg1 outOfWorld: tmp2 ].        arg1 privateOwner: nil ].  tmp1 := submorphs.  submorphs := EmptyArray.  tmp1 do: [:arg1 |  self removedMorph: arg1 ]privateAddBrickBack: arg1  | tmp1 |  tmp1 := arg1 asBrick.  self privateAddBrickLinkBack: tmp1.  self privateSubbricks: (self subbricks copyWith: tmp1).  ^arg1needActionButton  ^self parameters at: 'actionBlock' ifPresent: [ true ] ifAbsent: [ false ]presentation: arg1  presentation := arg1resetAnnouncer  registry resetmatches: arg1  self filterBlock ifNil: [ ^true ].  ^self filterBlock valueWithEnoughArguments: {arg1 .         pattern}selection: arg1  | tmp1 |  tmp1 := arg1 newSelectedIndexes select: [:arg2 |  arg2 ~= 0 ] thenCollect: [:arg2 |  (self elementAt: arg2) data ].  tmp1 ifNotEmpty: [ self announcer announce: (GLMTreeMorphSelectionChanged new                 selectionValue: ((tmp1 size = 1 and: [ self glamourPresentation isSingle ]) ifTrue: [ tmp1 first ] ifFalse: [ tmp1 ]);                 selectionPathValue: tmp1;                 yourself) ]allOwnersDo: arg1  self owner ifNotNil: [ ^self owner withAllOwnersDo: arg1 ]computeTagsFilterFor: arg1  ^self computeTagsFor: arg1 from: self tagsFilterBlockwantsSteps  ^wantsSteps ifNil: [ false ]renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderMorphPresentation: selfchildren: arg1  children := arg1actOnPresentationUpdated: arg1  listModel resetData.  dropDownMorph     updateList;     updateListSelectionIndexisLastVisible  self band hasSubbricks ifFalse: [ ^true ].  ^self isVisible: self band lastSubbrickscrollPageDown  self     scrollDown: self height;     update;     changeddoItReceiver  ^doItReceiver glamourValue: self entityremove: arg1 ifAbsent: arg2  collection remove: arg1 ifAbsent: arg2.  self announce: GLMItemRemoveddropEnabled  ^self glamourPresentation isDropTargetroots  | tmp1 |  roots ifNil: [ self roots: self displayValue ].  tmp1 := roots select: [:arg1 |  arg1 shouldBeDisplayed ].  ((self shouldFilterByAmount and: [ self amountToFilterBy < tmp1 size ]) and: [ tmp1 notEmpty ]) ifTrue: [ tmp1 := tmp1 first: self amountToFilterBy ].  ^tmp1rightAngle: arg1  ^arg1 = GLMWestDirection uniqueInstancecomputeTagsFor: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self columns collect: [:arg2 |  tmp1 addAll: (arg2 computeTagsFor: arg1) ].  ^tmp1isRendered  ^actualPageMorph notNilshrinkingWidth  ^self morph widthinitialize  super initialize.  self     hShrinkWrap;     color: Color veryVeryLightGray muchLighter;     borderWidth: 1;     borderColor: Color veryVeryLightGray;     padding: #(4 7)testPaneName  | tmp1 |  tmp1 := GLMFinder new.  tmp1 addPresentation: (GLMPresentation new title: 'presentation1').  (tmp1 pane port: #entity) value: #value1.  self assert: tmp1 panes first name equals: '1'.  (tmp1 panes first port: #selection) value: #value2.  self assert: tmp1 panes last name equals: '2'variableBindings: arg1  ^variableBindingsBlock := arg1renderRubricHighlightedTextPresentation: arg1  ^GLMMorphicRubricHighlightedTextRenderer render: arg1 from: selfsetAdaptor  | tmp1 |  tmp1 := (GLMBrickListModel on: self entity) morphAtLogic: [:arg1 :arg2 |  self styledLogic phlowValue: (self formatLogic phlowValue: (self displayLogic phlowValue: (self entity at: arg1))) asBrick ].  self listBrick model: tmp1virtualLastVisiblePageIndex  ^virtualLastVisiblePageIndexwithAllPresentations  | tmp1 |  tmp1 := OrderedCollection new.  self withAllPanesAndPresentationsDo: [:arg1 |  (arg1 isKindOf: GLMPresentation) ifTrue: [ tmp1 add: arg1 ] ].  ^tmp1layout: arg1 on: arg2  beRightToLeftWithOffset: arg1  self invalidateWith: [ self triggerBrick hAlign: #right.        self triggerBrick marginRight: arg1.        self foundationBrick bounds: (self foundationBrick bounds translateBy: ((self width - self triggerBrick width - arg1 - inset left) @ 0) negated) ]action  ^actioncolumn: arg1 size: arg2  ^self addColumn: arg1 size: arg2testPortEquality  | tmp1 tmp2 |  tmp1 := GLMPresentation new.  tmp2 := GLMPresentationBoundPort new     name: #port;     presentation: tmp1.  self assert: tmp2 equals: (tmp1 pane port: #port).  self assert: (tmp1 pane port: #port) equals: tmp2.  self assert: tmp2 hash equals: (tmp1 pane port: #port) hash.  self assert: (tmp1 pane port: #port) hash equals: tmp2 hashborderColor  ^Color r: 127 g: 191 b: 127 range: 255testPortName  | tmp1 tmp2 |  tmp2 := GLMSimplePort new     name: #portTwo;     value: 2.  tmp1 := GLMPortEvent on: (GLMPort new           name: '1';           yourself) previouslyValued: tmp2.  self assert: tmp1 portName equals: '1'withAllOwnersDo: arg1  arg1 cull: self.  self owner ifNotNil: [ ^self owner withAllOwnersDo: arg1 ]allowsSearch  ^searchBlock notNilnewBar  ^GLMBrick newclearIn: arg1  self notingPresentationChangeDo: [ self presentations clear.        self ports do: [:arg2 |  arg2 value: nil in: arg1 copy ] ]newRubricMorph  ^GLMRubTextFieldMorph newexecuteMenuAction: arg1  self announcer announce: (GLMMenuItemSelected action: arg1)layoutChildrenOf: arg1  (self prioritySortedSubbricks: arg1) do: [:arg2 |  self layoutAround: arg2 inContext: arg1 ]hideHeader  ^self parameters at: 'shouldShowHeader' put: [ false ]heightState: arg1  heightState := arg1specificTableMorphColumnsInitialization  | tmp1 |  tmp1 := tableModel glamourPresentation.  tableMorph intercellSpacing: tableModel glamourPresentation intercellSpacing.  tableMorph beResizable.  tmp1 shouldShowHeader ifFalse: [ tableMorph hideColumnHeaders ] ifTrue: [ tableMorph showColumnHeaders ].  tableMorph columns: (tmp1 columns collect: [:arg1 |  GLMFastTableColumn new                 id: (tmp1 titleValueOfColumn: arg1);                 width: arg1 width;                 glamourColumn: arg1;                 target: tableModel actionSelector: #sortByColumn: arguments: {arg1};                 yourself ])updateVisible  | tmp1 |  self hasItems ifFalse: [ ^self ].  tmp1 := self gatherInvisibleItems.  tmp1 = self band subbricks & tmp1 isEmpty not ifTrue: [ ^self ].  self updateVisibleTop: tmp1.  self updateVisibleBottom: tmp1.  tmp1 do: [:arg1 |  self removeBrickNoLayout: arg1 ].  visibleIndex := self getIndex: self band firstSubbricklayoutPolicy: arg1 on: arg2  ^arg1 layoutPolicytestAddTransmissions  | tmp1 tmp2 |  tmp1 := GLMBrowser new.  self assertEmpty: tmp1 transmissions.  tmp2 := GLMTransmission new.  tmp1 addTransmission: tmp2.  self assert: tmp2 browser equals: tmp1id  ^id ifNil: [ self ]browsingSelectionActions  ^{(GLMGenericAction new     title: 'Browse Full Class';     action: [:arg1 |  arg1 browseFullClass ];     shortcut: $b;     category: 'Code search...';     yourself) .   (GLMGenericAction new     title: 'Senders';     action: [:arg1 |  arg1 sendersOfIt ];     shortcut: $n;     category: 'Code search...';     yourself) .   (GLMGenericAction new     title: 'Implementors';     action: [:arg1 |  arg1 implementorsOfIt ];     shortcut: $m;     category: 'Code search...';     yourself) .   (GLMGenericAction new     title: 'References';     action: [:arg1 |  arg1 referencesToIt ];     category: 'Code search...';     withSeparatorAfter;     yourself) .   (GLMGenericAction new     title: 'Extended string search';     action: [:arg1 |  arg1 selectLine.        self systemNavigation browseMethodsWithString: arg1 selectedText matchCase: false ];     shortcut: $E;     category: 'Code search...';     yourself) .   (GLMGenericAction new     title: 'Method source containing selection';     action: [:arg1 |  arg1 selectLine.        self systemNavigation browseMethodsWithSourceString: arg1 selectedText matchCase: false ];     category: 'Code search...';     withSeparatorAfter;     yourself)}font  ^fontnewBrickFullHeightAndWidthDependsOnParent: arg1  ^GLMBrick new     vSpaceFill;     hSpaceFill: arg1;     color: Color random;     yourselfisScrollable  ^self leftoverScrollRange > 0computation: arg1  computation := arg1vShrinkWrap  super vShrinkWrap.  self label vShrinkWraponThemerChanged  renderPane: arg1  ^nilonRemovedFrom: arg1  self subbricks do: [:arg2 |  arg2 onRemovedFrom: arg1 ]updateWidth: arg1 on: arg2  setAdaptor  | tmp1 |  tmp1 := (GLMBrickListModel on: self transformedEntity) morphAtLogic: [:arg1 |  GLMPhlowTableRowBrick new           in: self;           entity: (self transformedEntity at: arg1) ].  self listBrick model: tmp1testTreeDefaultAllowDeseletion  | tmp1 tmp2 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 tree ].  window := tmp1 openOn: ($a to: $d).  tmp2 := self treeVisibleItems first.  self send: self tree mouseUpOnItem: tmp2.  self send: self tree mouseUpOnItem: tmp2.  self assert: (tmp1 panes first port: #selection) value equals: $anewDataSourceMatching: arg1  ^(super newDataSourceMatching: arg1)     glamourPresentation: self glamourPresentation;     yourselfhasActions  ^falseactOnPaneAdded: arg1  container pushPane: (self renderObject: arg1 pane)render: arg1  | tmp1 tmp2 tmp3 |  window := GLMSystemWindow new model: arg1.  self installActionsOnModel: window fromPresentation: arg1.  self installKeystrokeActionsOnMorph: window fromPresentation: arg1.  self setLabelOf: window for: arg1.  tmp2 := 4.  tmp3 := 0.  tmp1 := self renderToolbarForPresentation: arg1 inMorph: window.  tmp1 hResizing: #shrinkWrap.  window toolbarBox: tmp1.  tmp3 := self handlePotentialStatusbarFor: arg1.  window addMorph: (self renderObject: arg1) fullFrame: ((0 @ 0 corner: 1 @ 1) asLayoutFrame           topLeftOffset: 0 @ tmp2;           bottomRightOffset: 0 @ tmp3).  self setPotentialBackgroundColorFor: arg1.  arg1 when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  arg1 when: GLMPresentationToolbarUpdated send: #actOnPresentationToolbarUpdated: to: self.  arg1 when: GLMWindowRequest send: #actOnWindowRequest: to: window.  arg1 watcherPane notNil ifTrue: [ GLMMorphicWatcherRenderer render: arg1 watcherPane from: self renderer ].  ^windowwindowIsClosing  | tmp1 |  tmp1 := GLMBrowserClosing new presentation: self.  self withAllPresentations do: [:arg1 |  arg1 announce: tmp1 ]testEmptyBrickDependsOnChildren  | tmp1 |  tmp1 := self newBrickWithFullDependsOnChildren.  self assert: tmp1 brickApi layout hState isOnChildren.  self assert: tmp1 brickApi layout vState isOnChildren.  self assertAllSubbricksAreDirty: tmp1.  tmp1 doLayout.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: 0 @ 0pharoMethod  ^self custom: GLMPharoMethodPresentation newhSpaceFill  self hSpaceFill: 100messageBrick  ^messageBricktestStartWithOnlyJumpStart  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list ].  tmp1 transmit     to: #two;     from: #one;     andShow: [:arg1 |  arg1 text ].  self assert: tmp1 transmissions size equals: 2.  self assertEmpty: (tmp1 paneNamed: #one) presentations.  self assertEmpty: (tmp1 paneNamed: #two) presentations.  tmp1 startOn: #(15 25 35).  self assert: (tmp1 paneNamed: #one) presentations size equals: 1.  self assert: (tmp1 paneNamed: #one) matchingPresentations size equals: 1.  self assertEmpty: (tmp1 paneNamed: #two) presentations.  self assertEmpty: (tmp1 paneNamed: #two) matchingPresentationstestMarkerOneParentInStaticHeight  | tmp1 tmp2 |  tmp1 := self newBrickWithStaticExtent.  tmp2 := self newBrickWithFullFill.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthClean.  self assert: tmp2 wrappedBounds isHeightDirty.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightCleanrenderer  ^self valueOfProperty: #brickRenderer ifAbsentPut: [ nil ]testAddPane  | tmp1 tmp2 |  tmp1 := GLMBrowser new.  self assertEmpty: tmp1 panes.  tmp2 := GLMPane new.  tmp1 addPane: tmp2.  self assert: tmp2 browser equals: tmp1layout: arg1 on: arg2  arg2 updateDimension: arg1.  arg2 markClean: arg1.  arg2 layoutChildrenOf: arg1.  arg2 layoutOwnerOf: arg1childrenItems  ^(self containerTree glamourPresentation childrenValueOf: self item atLevel: self path size) ifNil: [ OrderedCollection new ]action: arg1  actionBlock := arg1toggleFilteringByTag: arg1  (self shouldFilterByTag: arg1) ifTrue: [ self tagsToFilterBy remove: arg1 ] ifFalse: [ self tagsToFilterBy add: arg1 ].  self resetChildrenContent.  self tableRefreshtoolbar  ^toolbarcachedMatchingPresentations: arg1  ^cachedMatchingPresentations := arg1enableFilter  self parameters at: 'isFilterable' put: truetestOneStaticBrick  | tmp1 |  tmp1 := self newBrickWithStaticExtent.  self assert: tmp1 brickApi layout hState isOnMyself.  self assert: tmp1 brickApi layout vState isOnMyself.  self assertBrickClean: tmp1.  self assert: tmp1 extent equals: self staticExtentcontext  ^OrderedCollection newcustomDependencies: arg1  ^arg1 layout widthDependenciesrender: arg1  | tmp1 |  tmp1 := GLMPagerModel new     isDependenciesShown: false;     defaultNumberOfVisiblePages: arg1 fixedSizePanes;     minimumPageNumberForScrollbar: arg1 minimumPageNumberForScrollbar.  arg1 scrollButtonIconRenderBlock ifNotNil: [ tmp1 scrollButtonIconRenderBlock: [:arg2 |  arg1 scrollButtonIconRenderBlock cull: ((arg1 panes at: arg2) port: #entity) value ] ].  container := (GLMPagerBrick new     pagerModel: tmp1;     yourself) asBrickedMorph.  self registerAnnouncementsFor: arg1.  arg1 panes do: [:arg3 |  container brickRoot pushPane: (self renderObject: arg3) ].  ^containerinnerBounds  ^self wrappedBounds innerBoundsdefaultValidate: arg1 on: arg2  ^truemorphicAct: arg1 entitled: arg2  self addAction: (GLMMorphicAction new           action: arg1;           title: arg2;           yourself)with: arg1  arg1 value: selfextent: arg1  | tmp1 |  tmp1 := arg1 rounded.  (bounds extent closeTo: tmp1) ifTrue: [ ^self ].  self invalidRect: bounds.  bounds := bounds topLeft extent: tmp1.  self layoutChanged.  self invalidRect: boundspresentationTransformation: arg1  presentationTransformation := arg1computeTagsFilterFor: arg1  self subclassResponsibilityselectionValue: arg1  selectionValue := arg1direction: arg1  direction := arg1select  self isSelected ifFalse: [ isSelected := true.        self announce: #onMouseHover.        self changed ]+ arg1  ^arg1 + self offsetrender: arg1  textModel := self modelFor: arg1.  textModel primarySelectionInterval: (arg1 primarySelectionInterval ifNil: [ arg1 selectionInterval ifNil: [ 1 to: 0 ] ]).  textMorph := self morph.  arg1 text: textMorph text.  arg1 withLineNumbers ifTrue: [ textMorph withLineNumbers ] ifFalse: [ textMorph withoutLineNumbers ].  arg1 withAnnotation ifTrue: [ textMorph withAnnotation ] ifFalse: [ textMorph withoutAnnotation ].  arg1 withColumns ifTrue: [ textMorph withColumns ] ifFalse: [ textMorph withoutColumns ].  textMorph wrapped: arg1 wrapped.  textMorph tabWidth: arg1 tabWidth.  arg1 withGhostText ifNotNil: [ textMorph withGhostText: arg1 withGhostText asStringOrText ].  arg1 textSegments do: [:arg2 |  textMorph addSegment: arg2 ].  (arg1 textSegments anySatisfy: [:arg3 |  arg3 icon notNil ]) ifTrue: [ textMorph withTextSegmentIcons ] ifFalse: [ textMorph withoutTextSegmentIcons ].  textMorph textArea announcer when: RubTextChanged do: [:arg4 |  arg1 announcer suspendAllWhile: [ arg1 text: textMorph text ] ].  textMorph textArea announcer when: RubSelectionChanged do: [:arg4 |  arg1 announcer suspendAllWhile: [ arg1 selectionInterval: textMorph selectionInterval.              arg1 selectedText: textMorph textArea selection ] ].  textMorph textArea announcer when: RubTextAccepted do: [:arg4 |  arg1 suspendAllWhile: [ arg1 text: arg4 text ] ].  self installActionsOnModel: textModel fromPresentation: arg1.  self installKeystrokeActionsOnMorph: textMorph textArea fromPresentation: arg1.  self registerEventsForPresentation: arg1.  ^textMorphorigin  ^originhandleListenEvent: arg1  arg1 type = #keystroke ifTrue: [ (self boundsInWorld containsPoint: arg1 position) ifTrue: [ self scrollByKeyboard: arg1 ] ]bar: arg1  bar := arg1.  self addBrickBack: arg1renderBorderOf: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 tmp8 tmp9 |  tmp1 := arg2.  tmp2 := self widthLeft brickValue: arg1.  tmp3 := self widthRight brickValue: arg1.  tmp4 := self widthTop brickValue: arg1.  tmp5 := self widthBottom brickValue: arg1.  tmp6 := self colorLeft brickValue: arg1.  tmp7 := self colorRight brickValue: arg1.  tmp8 := self colorTop brickValue: arg1.  tmp9 := self colorBottom brickValue: arg1.  tmp1 fillRectangle: (arg1 brickBounds origin extent: (arg1 brickBounds width - tmp3) @ tmp4) color: tmp8.  tmp1 fillRectangle: ((arg1 brickBounds right - tmp3) @ arg1 brickBounds top corner: arg1 brickBounds corner - (0 @ tmp5)) color: tmp7.  tmp1 fillRectangle: (arg1 brickBounds bottomLeft - (tmp2 negated @ tmp5) corner: arg1 brickBounds corner) color: tmp9.  tmp1 fillRectangle: (arg1 brickBounds origin + (0 @ tmp4) corner: arg1 brickBounds bottomLeft + (tmp2 @ 0)) color: tmp6toggleFilteringByTag: arg1  self containerTree toggleFilteringByTag: arg1isLayoutClean: arg1  ^arg1 ifNotNil: [:arg2 |  arg2 layout isClean ] ifNil: [ true ]rectangleMorphFrom: arg1  ^BorderedMorph new     borderWidth: 0;     color: Color transparent;     layoutPolicy: TableLayout new;     cellPositioning: #topLeft;     hResizing: #spaceFill;     vResizing: #spaceFill;     listDirection: (arg1 isHorizontal ifTrue: [ #leftToRight ] ifFalse: [ #topToBottom ]);     listCentering: #topLeft;     wrapCentering: #topLeft;     cellInset: 5;     yourselftransmission: arg1  transmission := arg1execute: arg1 withArguments: arg2 callback: arg3 delay: arg4  ^self execute: arg1 withArguments: arg2 callback: arg3 priority: Processor userSchedulingPriority delay: arg4heightMyselfDependency: arg1  ^arg1 layout height brickValue: arg1 brickpresentation: arg1  presentation := arg1addBrickBack: arg1  self band addBrickBack: arg1newLabelBrick  ^GLMLabelBrick newremoveAllBricks  self brickRoot removeAllBrickscalculateMaxVelocity  ^self band width / 15 max: self class defaultMaxVelocityhShrinkWrap  super hShrinkWrap.  self label hShrinkWraptextSegments  ^textSegments ifNil: [ textSegments := OrderedCollection new ]newIndex: arg1  newIndex := arg1transmissionContext  ^transmissionContextpostCopy  origins := self originReferences collect: [:arg1 |  arg1 copy ].  destination := destination copy.  transmissionStrategy := transmissionStrategy copy.  transmissionStrategy transmission: selfpageIndex: arg1  pageIndex := arg1testPresentationAndBrowserConditions  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMPane named: 'test'.  tmp2 := GLMExplicitBrowser new condition: [:arg1 :arg2 |  arg1 = 1 and: [ arg2 = 2 ] ].  tmp3 := GLMTabulator new condition: [:arg1 |  arg1 = #foo ].  tmp4 := GLMExplicitBrowser new useExplicitNotNil.  tmp1 addPresentation: tmp2.  tmp1 addPresentation: tmp3.  tmp1 addPresentation: tmp4.  (tmp1 port: #entity) value: (GLMMultiValue withAll: #(1 2)).  self assert: tmp1 matchingPresentations size equals: 2.  self assert: tmp1 matchingPresentations first identicalTo: tmp2.  self assert: tmp1 matchingPresentations last identicalTo: tmp4.  (tmp1 port: #entity) value: (GLMMultiValue withAll: #(#foo 2)).  self assert: tmp1 matchingPresentations size equals: 2.  self assert: tmp1 matchingPresentations first identicalTo: tmp3.  self assert: tmp1 matchingPresentations last identicalTo: tmp4.  (tmp1 port: #entity) value: (GLMMultiValue withAll: #(nil 2)).  self assert: tmp1 matchingPresentations size equals: 1addBrickBackNoLayout: arg1  self band doNotLayoutDuring: [ self band addBrickBack: arg1 ].  ^arg1size  ^pagesCountonPagePopedAndReplaced: arg1  self popAndReplace: arg1 brickpopAndReplace: arg1  | tmp1 |  tmp1 := self configurePane: arg1.  tmp1 wrappedBounds: self band lastSubbrick wrappedBounds.  tmp1 updateMorphBounds.  self band doNotLayoutDuring: [:arg2 |  arg2           removeBrick: arg2 lastSubbrick;           addBrickBack: tmp1 ].  self changedhasPane  ^falseallowedBounds: arg1  allowedBounds := arg1onChildrenLayouted  self updateFoundationBoundstestUpdate  | tmp1 tmp2 tmp3 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 dynamic presentation: [:arg2 :arg3 |  arg2 custom: tmp3 ] ].  tmp3 := GLMRubricTextPresentation new.  window := tmp1 openOn: 42.  tmp2 := window submorphs last submorphs first submorphs first.  self assert: (tmp2 isKindOf: PanelMorph).  self assert: (tmp2 submorphs first isKindOf: RubScrolledTextMorph).  tmp3 := GLMListPresentation new.  tmp1 update.  tmp2 := window submorphs last submorphs first submorphs first.  self assert: (tmp2 isKindOf: PanelMorph).  self assert: (tmp2 submorphs first submorphs first isKindOf: MorphTreeMorph)font  ^fontallDisplayedDo: arg1  self displayValue do: [:arg2 |  self withChildrenOf: arg2 do: arg1 ]isLayoutDirty: arg1  ^arg1 ifNotNil: [:arg2 |  arg2 layout isDirty ] ifNil: [ true ]testActionDefinition  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 text act: [  ] entitled: ''.        arg1 list act: [  ] entitled: ''.        arg1 tree act: [  ] entitled: '' ].  tmp1 startOn: #(42).  tmp1 panes first presentations do: [:arg2 |  self assert: arg2 actions size equals: 1 ]icon: arg1  icon := arg1brickBounds  ^bounds ifNil: [ bounds := 0 @ 0 corner: 50 @ 50 ]state  ^#hStateact: arg1 on: arg2 entitled: arg3  self addAction: (GLMGenericAction new           action: arg1;           shortcut: arg2;           title: arg3;           yourself)allow: arg1 droppedOnItem: arg2  ^self allowDropOnItemBlock glamourValue: (GLMMultiValue with: arg1 with: arg2 with: self)popup: arg1 event: arg2  < return: #Boolean>  self subclassResponsibilityfamilyName: arg1  familyName := arg1.  self updateFontprofileHighlightedText  textMorph textArea editor tallyHighlight.  textMorph shoutStyler style: textMorph textpresentations  ^presentationsvShrinkWrap  super vShrinkWrap.  self label vShrinkWraptitleIconValue  ^self titleIcon notNil ifTrue: [ self titleIcon glamourValue: self entity ] ifFalse: [ self titleIcon ]withAllPanesAndPresentationsDo: arg1  arg1 value: self.  self presentations withAllPanesAndPresentationsDo: arg1paneName  ^paneNamecondition  ^condition ifNil: [ true ]privatePrepareBrickAfterRemoving: arg1  self privateRemoveOutWorld: arg1testPresentationInitializationBlock  | tmp1 tmp2 |  tmp2 := 0.  tmp1 := GLMDynamicPresentation new.  tmp1 transformation: [:arg1 |  GLMListPresentation new initialize: [:arg2 |  tmp2 := tmp2 + 1.              arg2 selection: 5 ] ].  tmp1 entity: (1 to: 42).  self assert: tmp2 equals: 0.  self assert: tmp1 currentPresentation presentations first selection equals: 5.  self assert: tmp2 equals: 1innerPortEvent: arg1  | tmp1 |  arg1 hasChanged ifFalse: [ ^self ].  tmp1 := self transmissions select: [:arg2 |  (arg2 originatesAt: arg1 port) and: [ (arg1 transmissionContext includesPort: arg2 destination) not ] ].  tmp1 do: [:arg2 |  arg2 transmitIn: arg1 transmissionContext copy ]browser: arg1  browser := arg1actOnPaneAdded: arg1  self addMorphFromObject: arg1 pane toContainer: container.  scrollPane hScrollbar glmAnimateValue: 1.0 duration: 2000emptyBrick: arg1  emptyBrick := arg1initialize  super initialize.  resizingZoneWidth := 7.  isRightResizing := false.  isLeftResizing := false.  isResizing := false.  self     normalColor: (Color veryLightGray alpha: 0.4);     selectedColor: (Color veryLightGray alpha: 0.55);     enablemorphicActOn: arg1  ^(self actOn: arg1) openpopPane  transform removeMorph: transform lastSubmorph.  transform submorphs isEmpty ifFalse: [ transform removeMorph: transform lastSubmorph ].  paneCount := paneCount - 1.  self updatePanesannouncer  ^glmAnnouncer ifNil: [ glmAnnouncer := GLMAnnouncer new ]testBottomMarginMyselfDependency  | tmp1 tmp2 tmp3 |  tmp2 := 10.  tmp1 := self newBrickWithStaticExtent.  tmp3 := self newBrickWithSmallStaticExtent.  tmp3 marginBottom: tmp2.  tmp1 addBrickBack: tmp3.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp3 extent equals: self staticSmallExtent.  self assert: tmp3 brickBounds equals: (0 @ 0 extent: self staticSmallExtent)title  ^titlecheckboxBorderWidth  ^2initialize: arg1  initializationBlock := arg1scrollbarOffset  ^1= arg1  ^((arg1 isKindOf: GLMBoundPort) and: [ self pane = arg1 pane ]) and: [ self name = arg1 name ]model: arg1  adaptor := arg1.  self band hasSubbricks ifFalse: [ self updateVisible ].  self updatereferencesToIt  self announce: (GLMTextEditorRequest for: #referencesToIt)isOnChildren  ^falseformat: arg1  self setProperty: #phlowFormat toValue: arg1toolbarBox: arg1  | tmp1 |  tmp1 := toolbarBox ifNil: [ menuBox ].  toolbarBox := arg1.  self setLabelWidgetAllowance.  self replacePane: tmp1 with: toolbarBoxenableSearch  self parameters at: 'isSearchable' put: truetestWith  | tmp1 tmp2 |  tmp1 := GLMPresentation new.  tmp1 with: [:arg1 |  tmp2 := arg1 ].  self assert: tmp2 identicalTo: tmp1onGotFocus: arg1  self animateToEditFocusedsubbricksCount  ^self subbricks sizetestMarkerOneChildrenInChildrenWidth  | tmp1 tmp2 |  tmp1 := self newBrickWithFullDependsOnChildren.  tmp2 := self newBrickWithFullDependsOnChildren.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthDirty.  self assert: tmp2 wrappedBounds isHeightClean.  self assert: tmp1 wrappedBounds isWidthDirty.  self assert: tmp1 wrappedBounds isHeightCleancontextClassValue  ^self contextClass glamourValue: self entitytitleActionBlock  ^labelActionBlockcallback  ^callback ifNil: [ callback := [  ] ]color: arg1  < brickBuilderProperty: #'Look&Feel' name: 'Color' as: #brickBuilderEvaluate getter: #color model: #GLMUIBuilderTextFieldProperty>  self setProperty: #brickBackgroundColor toValue: arg1dataCache  ^dataCache ifNil: [ dataCache := self class defaultCache ]actOnPresentationToolbarUpdated: arg1  | tmp1 |  tmp1 := arg1 presentation matchingPresentations.  tabs pages size to: 1 by: -1 do: [:arg2 |  (tabs pages at: arg2) toolbar: GLMMorphic emptyMorph ].  tmp1 withIndexDo: [:arg3 :arg2 |  tabs updatePageAtIndex: arg2 withLabel: (self titleOrIconOf: arg3 in: tabs) toolbar: (self renderToolbarForPresentation: arg3 inMorph: tabs) action: (self labelActionMorphFor: arg3) ]onTextChanged: arg1  self onTextAccepted: arg1withoutBackground  self rubric color: Color transparent.  self rubric textArea color: Color transparentlastActivePresentation  ^lastActivePresentation ifNil: [ self panes last lastActivePresentation ]testUpdatingTextPortUpdatesTheMorph  < expectedFailure>  | tmp1 tmp2 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text ].  window := tmp1 openOn: 'fourtytwo'.  tmp1 first text: '42'.  self assert: (tmp1 pane port: #text) value asString equals: '42'.  tmp2 := self find: RubPluggableTextMorph in: window.  self assert: tmp2 text asString equals: '42'buttons: arg1  buttons := arg1entity: arg1  super entity: arg1.  self setAdaptortagsFilterBlock  ^tagsFilterBlocktext: arg1  self privateSetText: arg1.  self wrappedBounds markWidthDirtyactionColumn: arg1  arg1 execute.  self tableRefreshunregisterFromAllAnnouncements  self presentations unregisterFromAllAnnouncementstestOneStackedVerticallyWithTitle  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 stackedVerticallyArrangement.        arg1 title: 'title'.        arg1 list ].  window := tmp1 openOn: 42.  self assert: self compositeTabGroup submorphs notEmpty.  self assert: self compositeTabGroup submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph class equals: GLMPanelMorph.  self assert: self compositeTabGroup contentMorph submorphs size equals: 1.  self assert: self compositeTabGroup contentMorph submorphs first class equals: GLMPanelMorph.  self assert: self compositeTabGroup contentMorph submorphs first submorphs size equals: 1.  self assert: self compositeTabGroup contentMorph submorphs first submorphs first class equals: LazyTabGroupMorphisOppositeClean: arg1  ^self subclassResponsibilityselectionSpawn: arg1 entitled: arg2  self addSelectionAction: (GLMSpawnBrowserAction new           action: arg1;           title: arg2;           yourself)allMenuActions  ^self glamourPresentation allSelectionActions select: #hasTitlegoAction  ^GLMGenericAction new     title: 'Do it and go';     action: [:arg1 :arg2 |  arg1 highlightEvaluateAndDo: [:arg3 |  arg1 selection: arg3 ] ];     shortcut: $g;     yourselfinitialize  super initialize.  wasTransmited := falsetestTextBackgroundColor  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list           display: [:arg2 |  1 to: arg2 ];           textBackgroundColor: [:arg3 |  (arg3 isDivisibleBy: 2) ifTrue: [ Color green ] ifFalse: [ Color red ] ] ].  window := tmp1 openOn: 4.  tmp2 := window submorphs last submorphs first submorphs first submorphs first.  tmp3 := tmp2 scroller submorphs first.  tmp4 := tmp3 submorphs first submorphs first submorphs first.  self assert: (tmp4 isKindOf: TextMorph).  self assert: tmp4 backgroundColor equals: Color red.  tmp3 := tmp2 scroller submorphs second.  tmp4 := tmp3 submorphs first submorphs first submorphs first.  self assert: (tmp4 isKindOf: TextMorph).  self assert: tmp4 backgroundColor equals: Color green.  tmp3 := tmp2 scroller submorphs third.  tmp4 := tmp3 submorphs first submorphs first submorphs first.  self assert: (tmp4 isKindOf: TextMorph).  self assert: tmp4 backgroundColor equals: Color red.  tmp3 := tmp2 scroller submorphs fourth.  tmp4 := tmp3 submorphs first submorphs first submorphs first.  self assert: (tmp4 isKindOf: TextMorph).  self assert: tmp4 backgroundColor equals: Color greenchanged  self world ifNil: [ ^self ].  self invalidRect: self globalClippingBoundsport  ^self pane port: self nametestMarkerOneStaticInParentHeight  | tmp1 tmp2 |  tmp1 := self newBrickWithFullFill.  tmp2 := self newBrickWithStaticExtent.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthClean.  self assert: tmp2 wrappedBounds isHeightDirty.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightCleanopenOn: arg1  ^self openOn: arg1 with: self defaultRenderercan: arg1 announce: arg2  ^((self forbiddenAnnouncements at: arg1 ifAbsent: [ Set new ]) includes: arg2) notalert: arg1  | tmp1 |  self alertOn: arg1.  tmp1 := self openInBrickWindowLabeled: 'Alert'.  self class environment at: #GLMSystemWindowBrick ifPresent: [ tmp1           noMenu;           innerExtent: self extent ]shouldFilterByTag: arg1  ^self tagsToFilterBy includes: arg1testLeftFloatingMySelfDependency  | tmp1 tmp2 tmp3 |  tmp2 := #left.  tmp1 := self newBrickWithStaticExtent.  tmp3 := self newBrickWithSmallStaticExtent.  tmp3 layout floating: tmp2.  tmp1 addBrickBack: tmp3.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp3 extent equals: self staticSmallExtent.  self assert: tmp3 brickBounds equals: (0 @ 0 extent: self staticSmallExtent)minimumPageNumberForScrollbar: arg1  minimumPageNumberForScrollbar := arg1buttonForTag: arg1 filter: arg2  | tmp1 |  tmp1 := GLMMorphic togglingButtonLabelled: arg1 pressed: (self containerTree shouldFilterByTag: arg2) style: self containerTree glamourPresentation tagsStyle.  tmp1     target: self;     actionSelector: #toggleFilteringByTag:;     arguments: (Array with: arg2).  ^tmp1textBackgroundColor  ^textBackgroundColor ifNil: [ textBackgroundColor := Color transparent ]isClean  ^self isDirty notsilentValue: arg1  value := arg1defaultNumberOfVisiblePages  ^2scrollpaneBackgroundColor: arg1  self setProperty: #brickScrollpaneBackgroundColor toValue: arg1.  self updateStylelabelBrick  ^labelBricktopShadowOf: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := arg1 shadowWidth.  tmp4 := tmp2 @ tmp2 negated / 2.0.  tmp3 := arg1 brickBounds topLeft + tmp4 + arg1 shadowOffset.  tmp1 := (self shadowGradientFor: arg1)     origin: tmp3 - tmp4 + (0 @ (tmp2 / 2.0));     direction: (0 @ tmp2) negated;     yourself.  arg2 fillRectangle: (tmp3 extent: (arg1 width - tmp2) @ tmp2) fillStyle: tmp1privateRecomputeIndexesAfterScrollAt: arg1  | tmp1 tmp2 |  self invariant.  tmp1 := self convertValueToIndex: arg1.  tmp2 := tmp1 + self actualNumberOfVisiblePages - 1.  firstVisiblePageIndex := tmp1 rounded.  lastVisiblePageIndex := tmp2 rounded.  lastVisiblePageIndex > self size ifTrue: [ | tmp3 |        tmp3 := lastVisiblePageIndex - self size.        firstVisiblePageIndex := firstVisiblePageIndex - tmp3.        lastVisiblePageIndex := lastVisiblePageIndex - tmp3 ].  self invariantcomputeTagsFor: arg1 from: arg2  | tmp1 |  arg2 ifNil: [ ^OrderedCollection new ].  tmp1 := arg2 glamourValue: arg1.  ^tmp1 isString ifTrue: [ OrderedCollection with: tmp1 ] ifFalse: [ tmp1 asOrderedCollection ]wrappedBounds  ^brickBounds ifNil: [ brickBounds := GLMBrickBounds new ]renderColorOf: arg1 on: arg2  | tmp1 |  tmp1 := arg1 currentColor.  tmp1 ifNotNil: [ arg2 fillRectangle: (arg1 brickBounds expandBy: arg1 shadowWidth negated) color: tmp1 ]formatSourceCode  textMorph formatSourceCodekeyStroke: arg1  (self navigationKey: arg1) ifTrue: [ ^self ].  arg1 keyCharacter = Character arrowLeft ifTrue: [ self selectPreviousTab ].  arg1 keyCharacter = Character arrowRight ifTrue: [ self selectNextTab ]rubricTextColor  ^self valueOfProperty: #brickRubricTextColor ifAbsent: [ self themer rubricTextColor ]allowedBounds  ^self globalBoundsrender: arg1  labelMorph := (LabelMorph contents: arg1 formatedDisplayValue)     layoutFrame: LayoutFrame identity;     vResizing: #spaceFill;     hResizing: #spaceFill;     font: StandardFonts haloFont;     yourself.  arg1 when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  ^labelMorphmarkWidthClean  self widthState: #cleanbackgroundColor  ^Color r: 204 g: 229 b: 204 range: 255render: arg1  ^arg1 renderGlamorouslyOn: selfcellColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp1 := self elementAt: arg2.  tmp2 := FTCellMorph new     cellInset: 5;     addMorph: (self rowMorphForColumn: arg1 item: tmp1 withIndex: arg2);     yourself.  ^tmp2withoutStyler  self textArea withoutDecorator: self stylerDecoratortestAsTargetIdentifier  | tmp1 |  tmp1 := GLMPortIdentifier new.  self assert: tmp1 asGlamourTargetIdentifier equals: tmp1scrollButtonIconRenderBlock: arg1  scrollButtonIconRenderBlock := arg1testCreationVariableSize  window := GLMFinder new     variableSizePanes;     openOn: 123.  self assert: window submorphs last class equals: GeneralScrollPaneheight  ^self vState dimensionouterPortEvent: arg1  super outerPortEvent: arg1.  self do: [:arg2 |  arg2 outerPortEvent: arg1 ]actionName  ^self parameters at: 'actionName' ifAbsent: 'Validate'testSimpleTransmission  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     from: #one port: #port1;     fromOutsidePort: #outerPort;     to: #two port: #port2.  tmp1 transmit     from: #one port: #port3;     toOutsidePort: #anotherOuterPort.  self assert: tmp1 transmissions size equals: 2.  self assert: tmp1 transmissions first browser identicalTo: tmp1.  self assert: (tmp1 transmissions first transmissionStrategy isKindOf: GLMNoStrategy).  self assert: tmp1 transmissions first origins first equals: ((tmp1 paneNamed: #one) port: #port1).  self assert: tmp1 transmissions first origins last equals: (tmp1 pane port: #outerPort).  self assert: tmp1 transmissions first destination equals: ((tmp1 paneNamed: #two) port: #port2).  self assert: tmp1 transmissions last browser identicalTo: tmp1.  self assert: (tmp1 transmissions last transmissionStrategy isKindOf: GLMNoStrategy).  self assert: tmp1 transmissions last origins first equals: ((tmp1 paneNamed: #one) port: #port3).  self assert: tmp1 transmissions last destination equals: (tmp1 pane port: #anotherOuterPort)sortBlock  ^columnToSortBy sortBlock ifNotNil: [:arg1 |  arg1 ] ifNil: [ columnToSortBy defaultSortBlockForPresentation: self glamourPresentation ]filterBlock  ^self parameters at: 'filterBlock'doesNotUnderstand: arg1  ^self labelBrick perform: arg1 selector withArguments: arg1 argumentssecond  ^self presentations secondtestExplicitSelectionDoesNotUpdate  | tmp1 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 tree           allowsRecursiveSearch: false;           children: [:arg2 |  arg2 to: arg2 + 10 ] ].  window := tmp1 openOn: {1}.  tmp1 selection: Object new.  self assert: self tree selectedMorph equals: niltransmit  wasTransmited := true.  super transmitcheckedImage  ^checkedImagehighlightSmalltalkContext  ^highlightSmalltalkContext ifNil: [ nil ] ifNotNil: [ highlightSmalltalkContext glamourValue: self entity ]title: arg1  title := arg1selectionPathValue: arg1  selectionPathValue := arg1titleBrick: arg1  titleBrick := arg1     textPosition: #center;     height: 0;     hSpaceFill.  self addBrickBack: titleBrickcomputeTagsFor: arg1  self subclassResponsibilitynewCheckboxBrick  ^GLMInteractableBrick newtestDynamicActions  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list           display: [:arg2 |  1 to: arg2 ];           dynamicActions: [:arg3 |  (1 to: arg3 selection) collect: [:arg4 |  GLMGenericAction new                       action: [ arg4 ];                       title: 'Action' , arg4 printString;                       yourself ] ] ].  tmp1 startOn: 42.  (tmp1 panes first port: #selection) value: 3.  self assert: tmp1 panes first presentations first dynamicActions size equals: 3.  (tmp1 panes first port: #selection) value: 5.  self assert: tmp1 panes first presentations first dynamicActions size equals: 5selectionPopulate: arg1 on: arg2 entitled: arg3 with: arg4  self addSelectionAction: (GLMGenericAction new           action: (GLMPortUpdater new                 portSymbol: arg1;                 valueBlock: arg4;                 yourself);           shortcut: arg2;           title: arg3;           yourself)paddingRight  ^self brick paddingRightpane: arg1  pane := arg1testSimpleNestedSuspendParticularAnnouncementWhile  | tmp1 |  announcer when: GLMTestAnnouncement do: [:arg1 |  tmp1 := arg1 ].  tmp1 := nil.  announcer suspendAll: {GLMTestAnnouncement} while: [ announcer suspendAll: {} while: [  ].        announcer announce: GLMTestAnnouncement ].  self assert: tmp1 isNiltestInitializeBlockSetsTextSelectionForScriptPresentation  self checkInitializeBlockSetsTextSelectionForPresentation: #pharoScriptcustomValidation  ^customValidationtestSimpleCreation  self assert: tabs pages size equals: 2from: arg1 port: arg2  ^self from: (GLMPortIdentifier pane: arg1 port: arg2)privateAddBrick: arg1 before: arg2  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp1 := arg1 asBrick.  tmp3 := arg2 brickDoubleLink.  tmp3 = self firstSubbrick brickDoubleLink ifTrue: [ ^self privateAddBrickFirst: arg1 ].  tmp2 := tmp1 asDoubleLink.  tmp1 brickDoubleLink: tmp2.  tmp4 := tmp3 previousLink.  tmp3 previousLink: tmp2.  tmp2 nextLink: tmp3.  tmp2 previousLink: tmp4.  tmp4 nextLink: tmp2.  tmp5 := (self subbricks indexOf: arg2) max: 1.  self privateSubbricks: (self subbricks copyReplaceFrom: tmp5 to: tmp5 - 1 with: (Array with: tmp1)).  tmp1 owner: self.  ^arg1buttonForTag: arg1 filter: arg2  ^(GLMMorphic togglingButtonLabelled: arg1 pressed: (self shouldFilterByTag: arg2) style: self glamourPresentation tagsStyle)     target: self;     actionSelector: #toggleFilteringByTag:;     arguments: (Array with: arg2);     yourselftestOnePanePush  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self assert: pagerModel size equals: 1.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 1.  self assert: pagerModel numberOfVisiblePages equals: 2render: arg1  arg1 when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  ^scrollPane := self scrollMorphFor: (self morphFrom: arg1)searchOn: arg1  searchBlock := arg1beActive  active := truedataFromPresentationItem: arg1  ^arg1actOnVariableBindingsUpdated: arg1  textModel variableBindings: nil.  textModel appendVariableBinding: arg1 presentation variableBindings.  textMorph shoutStyler style: textMorph textpause  process ifNotNil: [ process suspend ]hoverAction: arg1  hoverAction := arg1rubricBackgroundColor: arg1  self setProperty: #brickRubricBackgroundColor toValue: arg1.  self updateStyleheight: arg1  self brickBounds: (self brickBounds withHeight: arg1)addPaneFromInner: arg1  | tmp1 tmp2 |  tmp2 := self panes isEmpty ifTrue: [ nil ] ifFalse: [ self lastActivePresentation ].  tmp1 := GLMPane named: (self panes size + 1) asString in: self.  tmp1 lastActivePresentation: tmp2.  self panes addLast: tmp1.  self newTransmission     addActiveOrigin: arg1;     destination: (tmp1 port: #entity);     transmitnewLabelBrick: arg1  ^GLMTabLabelBrick new     label: arg1;     when: #onClicked send: #onTabClicked:with: to: self;     tabSelector: self;     vSpaceFillactOnPaneRemoved: arg1  self subclassResponsibilityisHorizontal  ^isHorizontal ifNil: [ isHorizontal := true ]elementShouldBeDisplayed: arg1  | tmp1 |  self tagsToFilterBy ifEmpty: [ ^true ].  tmp1 := self glamourPresentation tagsFor: arg1 to: #filter.  ^self tagsToFilterBy allSatisfy: [:arg2 |  tmp1 includes: arg2 ]testRightFloatingMySelfDependency  | tmp1 tmp2 tmp3 |  tmp2 := #right.  tmp1 := self newBrickWithStaticExtent.  tmp3 := self newBrickWithSmallStaticExtent.  tmp3 layout floating: tmp2.  tmp1 addBrickBack: tmp3.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp3 extent equals: self staticSmallExtent.  self assert: tmp3 brickBounds equals: ((self staticWidth - self staticSmallWidth) @ 0 extent: self staticSmallExtent)addRow: arg1 span: arg2  ^(self addRow: arg1) span: arg2dynamicActionsOnSelection  (selectionDynamicActionsBlock isNil or: [ self selection isNil ]) ifTrue: [ ^OrderedCollection new ].  ^selectionDynamicActionsBlock glamourValue: selfpreviewPaneStyleFor: arg1  arg1 borderColor: Color lightGraytestShrinkInShrinkChange  | tmp1 tmp2 tmp3 |  tmp1 := self newBrickWithFullDependsOnChildren.  tmp2 := self newBrickWithFullDependsOnChildren.  tmp3 := self newBrickWithSmallStaticExtent.  tmp1 addBrickBack: tmp2.  tmp2 addBrickBack: tmp3.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 brickBounds equals: (0 @ 0 extent: self staticSmallExtent).  tmp3     width: self staticWidth;     height: self staticHeight.  self assert: tmp1 brickBounds equals: (0 @ 0 extent: self staticExtent)elements  ^elements ifNil: [ elements := self calculateElements ]pagerModel  ^pagerModelports: arg1  ports := arg1approximateBandHeight  | tmp1 tmp2 |  tmp1 := self scrollPane band submorphs select: [:arg1 |  self scrollPane isPartiallyVisible: arg1 ].  tmp1 isEmpty ifTrue: [ ^0 ].  tmp2 := (tmp1 inject: 0 into: [:arg2 :arg1 |  arg2 + arg1 height ]) / tmp1 size.  ^self scrollPane model count * tmp2isFilterable  ^self parameters at: 'isFilterable' ifAbsent: [ false ]styledLogic  ^self valueOfProperty: #phlowStyled ifAbsent: [ #yourself ]adjustPaneHeight  transform bounds: self innerBounds.  transform submorphsDo: [:arg1 |  arg1 bounds: (arg1 bounds withHeight: self paneHeight) ]elementShouldBeDisplayed: arg1  | tmp1 |  self tagsToFilterBy ifEmpty: [ ^true ].  tmp1 := self glamourPresentation tagsFor: arg1 to: #filter.  ^self tagsToFilterBy allSatisfy: [:arg2 |  tmp1 includes: arg2 ]notifyFocusedPageChanged  self notifyAll: GLMFocusedPageChanged newinitialize  super initialize.  percent := self defaultPercenttext  ^textneedsStep  ^doStep ifNil: [ doStep := true ]stepTime: arg1  stepTime := arg1scrollToRight: arg1  self scrollTo: 1.0 smooth: arg1text  ^textpage  ^pagestartOn: arg1  self entity: arg1testMaxWidthOneStatic  | tmp1 |  tmp1 := self newBrickWithStaticExtent.  tmp1 maxWidth: self staticSmallWidth.  tmp1 doLayoutForce.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 brickBounds equals: (0 @ 0 extent: self staticSmallWidth @ self staticHeight)width: arg1  self hSpaceFill.  super width: arg1newDataSourceMatching: arg1  ^(super newDataSourceMatching: arg1)     glamourPresentation: self glamourPresentation;     yourselfnewRubricMorph  ^super newRubricMorph     beReadOnly;     withoutAnyDecoratorvSpaceFill: arg1  super vSpaceFill: arg1.  self label vSpaceFill.  self dotsBrick vSpaceFillallMenuActions  ^self glamourPresentation allSelectionActions select: #hasTitleinvalidateMorphBounds  self invalidateMorphBounds: falsetestTypeOfSingleSelection  | tmp1 tmp2 tmp3 |  tmp1 := GLMCompositePresentation new.  tmp1 list.  window := tmp1 openOn: {{1} asSet}.  tmp2 := self find: MorphTreeMorph in: window.  tmp3 := tmp2 scroller submorphs first.  self send: tmp2 mouseUpOnItem: tmp3.  self assert: tmp1 selection equals: {1} asSetrenderGlamorouslyOn: arg1  ^arg1 renderExpander: selfselectSilently: arg1  self changed: #selectionasFormValue  ^self id -> self isCheckedtestNoDuplicateRegistrationOfAnnouncementsOnDataSource  | tmp1 tmp2 |  window := GLMCompositePresentation new     with: [:arg1 |  arg1 fastList selectionAct: [ 42 inspect ] entitled: 'Answer' ];     openOn: (1 to: 42).  tmp1 := self find: FTTableMorph in: window.  tmp2 := tmp1 dataSource announcer subscriptions subscriptions count: [:arg2 |  arg2 announcementClass = GLMMenuItemSelected ].  self assert: tmp2 equals: 1updatePageIndex: arg1  | tmp1 tmp2 |  arg1 = 0 ifTrue: [ ^self ].  tmp2 := self tabSelectorMorph selectedTab.  tmp1 := self pageMorph.  tmp1 ifNil: [ self contentMorph addMorph: (self pageAt: arg1) ] ifNotNil: [ | tmp3 |        tmp3 := self pageMorph bounds.        self contentMorph replaceSubmorph: tmp1 by: (self pageAt: arg1).        self flag: 'Without setting here the bounds the pange moves a few pizels when refreshing the inspector'.        self pageMorph bounds: tmp3.        self pageMorph layoutChanged ].  ((self pages at: arg1) toolbar notNil and: [ (self pages at: arg1) toolbar hasSubmorphs ]) ifTrue: [ self toolbarMorph hasSubmorphs ifFalse: [ self toolbarMorph addMorph: (self pages at: arg1) toolbar ] ifTrue: [ self toolbarMorph replaceSubmorph: self toolbarMorph submorphs first by: (self pages at: arg1) toolbar ] ] ifFalse: [ self toolbarMorph removeAllMorphs ].  self headerMorph layoutChanged.  self pageMorph layoutChanged.  self adoptPaneColor: (self owner ifNil: [ self ]) paneColor.  (self tabSelectorMorph tabs at: arg1) font: self tabSelectorMorph font.  self announcer announce: (LazyTabPageChanged new           tabs: self;           page: (self pages at: arg1);           oldPage: tmp2;           pageIndex: arg1)allMenuActions  ^self glamourPresentation allSelectionActions select: #hasTitletextBackgroundColor: arg1  textBackgroundColor := arg1pagerModel: arg1  pagerModel := arg1.  self pagerModel announcer when: GLMPageSwitched send: #onPageSwitched to: self.  self pagerModel announcer when: GLMPagerBoundsChanged send: #onScrollBoundsChanged: to: self.  self pagerModel announcer when: GLMFocusedPageChanged send: #onFocusedPageChanged to: self.  self updateButtonsadd: arg1  self pane notingPresentationChangeDo: [ self presentations add: arg1.        arg1 pane: self pane ].  ^arg1parameters  ^parametersmarkDirtyChildrenAround: arg1 inContext: arg2  arg1 subbricks do: [:arg3 |  arg3 = arg2 ifFalse: [ arg3 isBrick ifTrue: [ (self isClean: arg3) ifTrue: [ self markDirty: arg3.                          self markDirtyAround: arg3 inContext: arg1 ] ] ] ]initialize  super initialize.  presentationTransformation := [:arg1 :arg2 |  arg1 custom: arg2 ]initialize  super initialize.  focused := falserecomputeState: arg1  | tmp1 tmp2 |  tmp2 := false.  self invariant.  virtualFirstVisiblePageIndex isNil & virtualLastVisiblePageIndex isNil ifTrue: [ ^self ].  virtualFirstVisiblePageIndex ifNil: [ virtualFirstVisiblePageIndex := self firstVisiblePageIndex ].  virtualLastVisiblePageIndex ifNil: [ virtualLastVisiblePageIndex := self lastVisiblePageIndex ].  tmp1 := virtualLastVisiblePageIndex - virtualFirstVisiblePageIndex + 1.  tmp1 = numberOfVisiblePages ifFalse: [ tmp2 := true ].  numberOfVisiblePages := tmp1.  firstVisiblePageIndex := virtualFirstVisiblePageIndex.  lastVisiblePageIndex := virtualLastVisiblePageIndex.  self invariant.  virtualFirstVisiblePageIndex = nil.  virtualLastVisiblePageIndex = nil.  tmp2 ifTrue: [ self notifyNumberOfVisiblePagesChanged ].  self notifyScrollPositionChanged: arg1fromOutside: arg1  self deprecated: 'Use fromOutsidePort: instead'.  ^self fromOutsidePort: arg1test100FillBricksInsideEachOtherIndideStatic  | tmp1 tmp2 |  tmp1 := self newBrickWithStaticExtent.  tmp2 := tmp1.  1 to: 100 do: [:arg1 |  tmp2 := tmp2 addBrickBack: self newBrickWithFullFill ].  self assertAllSubbricksAreClean: tmp1.  self assert: tmp2 extent equals: tmp1 extentmorphicPopulate: arg1 icon: arg2 on: arg3 entitled: arg4 with: arg5  self addAction: (GLMMorphicAction new           action: (GLMPortUpdater new                 portSymbol: arg1;                 valueBlock: arg5;                 yourself);           shortcut: arg3;           icon: arg2;           title: arg4;           yourself)innerBounds  | tmp1 |  tmp1 := super innerBounds.  ^self scrollBarIsVisible ifTrue: [ tmp1 withHeight: tmp1 height - self scrollBarHeight - 1 ] ifFalse: [ tmp1 ]vertices  ^verticesvalue  ^self transformation ifNil: [ self port value ] ifNotNil: [ self transformation value: self port value ]marginTop  ^self margin at: TopfilterOn: arg1  self error: 'This presentation does not allow filtering with a block for now. In the futur we should have a new filter with FastTable to do that. If you want to give it a try look FTFunction and his subclasses.'outerOrigin: arg1  ^self brick wrappedBounds outerOrigin: arg1collectionToDragPassenger: arg1  ^arg1 size = 1 ifTrue: [ arg1 anyOne ] ifFalse: [ arg1 ]addBrickBack: arg1  self brickRoot addBrickBack: arg1focusedBorderWidth  ^1variableBindings  ^variableBindings ifNil: [ variableBindings := Dictionary new ]setUp  super setUp.  layouter := GLMBrickLayouter newcalculateElements  ^self tagsToFilterBy ifEmpty: [ self basicElements ] ifNotEmpty: [ self basicElements select: [:arg1 |  self elementShouldBeDisplayed: arg1 ] ]initialize  super initialize.  predicates := OrderedCollection newtheme  ^Smalltalk ui themeband: arg1  band := arg1.  band     useHorizontalLinearLayout;     layoutMorphs: true;     width: [ self band subbricksCount * self width / ((self maxPanes min: self band subbricksCount) max: 1) ];     vSpaceFill.  band layout widthDependency: self.  self addBrickBack: banddo: arg1  ^collection do: arg1testSimpleOpen  | tmp1 |  tmp1 := GLMCompositePresentation new.  tmp1 tabulator with: [:arg1 |  arg1 row: #one.        arg1 transmit           to: #one;           andShow: [:arg2 |  arg2 text ] ].  window := tmp1 openOn: 42.  self assert: (window isKindOf: GLMSystemWindow)isCentered  ^isCentered ifNil: [ isCentered := false ]linear  self step: [:arg1 :arg2 :arg3 :arg4 |  (arg3 - arg2) * arg4 + arg2 ]testEntityInUpdateAction  | tmp1 tmp2 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 text populate: #foo on: $m with: [:arg2 :arg3 |  tmp2 := arg3 ] ].  tmp1 startOn: 42.  tmp1 panes first presentations first actions first actOn: tmp1 panes first presentations first.  self assert: tmp2 equals: 42accept: arg1 droppedOnItem: arg2  self dropOnItemBlock glamourValue: (GLMMultiValue with: arg1 with: arg2 with: self).  ^truecopySelection  self announce: (GLMTextEditorRequest for: #copySelection)length  ^length valuelabel: arg1  arg1 cull: self labelcondition: arg1  condition := arg1lastActivePresentation: arg1  selectionActions  ^selectionActions ifNil: [ selectionActions := OrderedCollection new ]markDirty: arg1  ^self subclassResponsibilityhSpaceFill  hResizing := #spaceFill.  self hResizing: #spaceFilltestWatcherCreation  | tmp1 |  tmp1 := GLMBrowser new.  self assert: tmp1 watcherPane name equals: #_watcher.  (tmp1 watcherPane port: #entity) value: 42.  self assert: (tmp1 watcherPane port: #entity) value equals: 42openFromRubric: arg1 withResult: arg2  | tmp1 |  tmp1 := arg2 printString.  self withString: tmp1 from: arg1.  self width: self width + inspectButton width.  textMorph textArea on: $i meta do: [ arg2 inspect ].  textMorph textArea on: Character cr asKeyCombination do: [ self delete.        arg1 textArea removeHighlightSegment.        arg1 editor atEndOfLineInsertAndSelect: tmp1 asComment.        arg1 takeKeyboardFocus ].  textMorph textArea on: $p meta do: [ self delete.        arg1 textArea removeHighlightSegment.        arg1 editor atEndOfLineInsertAndSelect: tmp1.        arg1 takeKeyboardFocus ].  inspectButton addUpAction: [ arg2 inspect ].  self openInWorldtitleBrick: arg1  titleBrick := arg1.  self titleBrick textColor: self themer popupThemer textColor.  self contentBrick addBrickFirst: self titleBricktestStatusbar  | tmp1 |  tmp1 := GLMTabulator withStatusbar.  tmp1 row: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list display: #(1 2 3) ].  self assert: tmp1 transmissions size equals: 2.  tmp1 startOn: 42childrenValueOf: arg1  self flag: 'this is rather hackish, but needed to treat list and tree in the same way.'.  ^OrderedCollection newlabel  ^stringBrickinstallDefaultSelectionActions  self defaultSelectionActions do: [:arg1 |  self addSelectionAction: arg1 ]path  ^self pathIn: OrderedCollection newopen: arg1 on: arg2 entitled: arg3  self addAction: (GLMGenericAction new           action: arg1;           shortcut: arg2;           title: arg3;           yourself)testUnregisterAnnouncementsWhenUpdatingPaneWithTwoAnnouncers  | tmp1 tmp2 tmp3 |  tmp1 := Announcer new.  tmp3 := Announcer new.  tmp2 := GLMTabulator new.  tmp2 row: #one.  tmp2 transmit     to: #one;     andShow: [:arg1 |  arg1 list           updateOn: GLMTestAnnouncement fromAll: [ {tmp1 .               nil .               tmp3} ];           display: [:arg2 |  arg2 to: 10 ] ].  tmp2 startOn: 1.  tmp2 panes first presentations first registerAnnouncements.  tmp2 unregisterFromAllAnnouncements.  self assert: tmp1 numberOfSubscriptions equals: 0.  self assert: tmp3 numberOfSubscriptions equals: 0label  ^labelBrickpresentation: arg1  presentation := arg1replaceBoxes  labelArea removeAllMorphs.  self setLabelWidgetAllowance.  self theme configureWatcherWindowLabelAreaFor: self.  self setFramesForLabelArea.  self isActive ifFalse: [ labelArea passivate ]send: arg1  self selectionTransformation: arg1icon  ^nilcomputeScrollValue: arg1  | tmp1 tmp2 |  tmp2 := self owner width - self width.  tmp1 := (arg1 max: 0) min: tmp2.  ^tmp2 = 0 ifTrue: [ 0 ] ifFalse: [ tmp1 / tmp2 ]initializeNamed: arg1 in: arg2  self initialize.  name := arg1 ifNil: [ self defaultName ].  browser := arg2hasWidthRestrictions: arg1  ^arg1 layout hasMinWidth or: [ arg1 layout hasMaxWidth ]vSpaceFill: arg1  super vSpaceFill: arg1.  self labelBrick vSpaceFill.  self editBrick vSpaceFilltestPageRemovedAnnouncement  | tmp1 |  tmp1 := 0.  tabs announcer when: LazyTabPageRemoved do: [:arg1 |  tmp1 := tmp1 + 1 ].  tabs announcer when: LazyTabPageChanged do: [:arg1 |  tmp1 := tmp1 + 1 ].  tabs removePage: tabs pages first.  self assert: tmp1 equals: 1mouseMove: arg1  isRightResizing ifTrue: [ self dragResizingRight: arg1 ] ifFalse: [ isLeftResizing ifTrue: [ self dragResizingLeft: arg1 ] ifFalse: [ self dragSliding: arg1 ] ]row: arg1 size: arg2  ^self addRow: arg1 size: arg2initializeWidgets  scrollPageUp  self     scrollUp: self height;     update;     changedcolumns  self flag: 'this is rather hackish, but needed to treat list and tree in the same way.'.  ^OrderedCollection newextent: arg1  | tmp1 tmp2 tmp3 tmp4 |  super extent: arg1.  tmp1 := self brickRoot marginLeft.  tmp2 := self brickRoot marginTop.  tmp3 := self extent x - self brickRoot marginRight.  tmp4 := self extent y - self brickRoot marginBottom.  self isHFilling ifTrue: [ self brickRoot width: tmp3 - tmp1 ].  self isVFilling ifTrue: [ self brickRoot height: tmp4 - tmp2 ].  self brickRoot wrappedBounds bounds: (tmp1 @ tmp2 corner: tmp3 @ tmp4).  self brickRoot doLayoutForceupdateHeight: arg1 on: arg2  width: arg1  hState := self hState onMyselfDo: [:arg2 |  arg2 dimension: arg1 ]actionBlock  ^self parameters at: 'actionBlock'rubricTextFamilyName: arg1  self setProperty: #brickRubricTextFamilyName toValue: arg1.  self updateStyleinitializeScriptingDefaults  ^selfmarginTop  ^self wrappedBounds marginTophasIcon  ^self icon notNilhasFilterBlock  ^self parameters at: 'filterBlock' ifPresent: [ true ] ifAbsent: [ false ]forbid: arg1 toAnnounce: arg2  (self forbiddenAnnouncements at: arg1 ifAbsentPut: [ Set new ]) add: arg2emerald  ^Color brickColorRegistry at: #brickEmerald ifAbsentPut: [ Color r: 46 g: 204 b: 113 range: 255 ]hSpaceFill: arg1  < brickBuilderProperty: #Layout name: 'Horizontal percent' as: #asInteger getter: #hPercent model: #GLMUIBuilderTextFieldProperty>  self layout hSpaceFill: arg1id  ^id ifNil: [ #anonymous ]selectLine  self announce: GLMSelectCurrentLineparameter  ^parametermorphAt: arg1 convert: arg2  ^morphLogic ifNil: [ (origin at: arg1) asMorph ] ifNotNil: [ morphLogic isSymbol ifTrue: [ origin perform: morphLogic withEnoughArguments: {arg1 .                     arg2} ] ifFalse: [ morphLogic cull: arg1 cull: arg2 ] ]privateFullBounds  ^self fullBoundsvSpaceFill  vResizing := #spaceFillbeNormal  self beMode: #beNormalcancelOnEscape  cancelOnEscape := truemorphicSelectionAct: arg1 icon: arg2 on: arg3 entitled: arg4  self addSelectionAction: (GLMMorphicAction new           action: arg1;           shortcut: arg3;           icon: arg2;           title: arg4;           yourself)privateAddAllBricks: arg1  | tmp1 |  tmp1 := arg1 collect: #asBrick.  tmp1 do: [:arg2 |  self privateAddBrickLinkBack: arg2 ].  self privateSubbricks: self subbricks , tmp1.  ^tmp1explicitSelection: arg1  self table selectIndex: (self elements indexOf: arg1)renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderLabelPresentation: selftestTransmissionTriggeredAnnounced  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp2 := OrderedCollection new.  tmp1 := GLMBrowser new.  tmp3 := GLMPane new.  tmp4 := GLMPane new.  tmp1 addPane: tmp3.  tmp1 addPane: tmp4.  tmp5 := GLMTransmission new.  tmp5 addActiveOrigin: (tmp3 port: #origin).  tmp5 destination: (tmp4 port: #destination).  tmp1 addTransmission: tmp5.  tmp1 when: GLMTransmissionTriggered do: [:arg1 |  tmp2 add: arg1 ].  self assertEmpty: tmp2.  tmp5 transmit.  self assert: tmp2 size equals: 1withoutBackground  self rubric color: Color transparentspan  ^span ifNil: [ span := 1 ]removeBrick: arg1  self brickRoot removeBrick: arg1layout: arg1 in: arg2 inject: arg3 into: arg4  arg1 subbricks inject: arg3 into: [:arg5 :arg6 |  | tmp1 |        tmp1 := arg5 + ((self isFloating: arg6) ifFalse: [ arg4 cull: arg5 cull: arg6 ] ifTrue: [ self layoutFloating: arg6 in: arg2 ]).        self align: arg6 in: arg1 anchorPoint: arg5 inContext: nil.        arg6 onLayouted.        tmp1 ]withLineNumbers: arg1  withLineNumbers := arg1withStyler  self textArea withDecorator: self stylerDecoratorlength: arg1  self assert: [ arg1 >= 0 ] description: [ 'Length must be non-negative' ].  length := arg1transmissionStrategy  ^transmissionStrategyonThemerChanged  | tmp1 |  super onThemerChanged.  tmp1 := self themer popupThemer.  self color: tmp1 backgroundColor.  self borderWidth: tmp1 borderWidth.  self borderColor: tmp1 borderColor.  self inset: tmp1 inset.  self spacing: tmp1 spacing.  self shadowWidth: tmp1 shadowWidth.  self shadowColor: tmp1 shadowColor.  self shadowOffset: tmp1 shadowOffset.  self shadowInset: tmp1 shadowInset.  self contentBrick padding: tmp1 contentPadding.  self contentBrick color: tmp1 contentBackgroundColor.  self updateTriggerBrickorigin: arg1 length: arg2 breadth: arg3  ^self subclassResponsibilityinitialize  super initialize.  textLogic := [:arg1 |  arg1 ]announce: arg1  self announcer announce: arg1doLayoutIn: arg1  initializeScrollbar  scrollBar := ScrollBar new     model: self;     setValueSelector: #scrollBarValue:;     yourself.  scrollBar     borderWidth: 0;     borderColor: #inset;     height: self scrollBarHeight.  self resizeScrollBarasyncTask: arg1  asyncTask := arg1help: arg1  help := arg1removeLast  collection removeLast.  self announce: GLMItemRemovedtopRightCornerShadowOf: arg1 on: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := arg1 shadowWidth.  tmp4 := (tmp2 @ tmp2) negated / 2.0.  tmp3 := arg1 brickBounds topRight + tmp4 + arg1 shadowOffset.  tmp1 := (self shadowGradientFor: arg1)     origin: tmp3 + (0 @ tmp2);     direction: tmp2 @ tmp2 negated / 1.4;     radial: true;     yourself.  arg2 fillRectangle: (tmp3 extent: tmp2 @ tmp2) fillStyle: tmp1position  ^positionisEditMode  ^self hasSubbrick: self editBrickmenuColumn: arg1 row: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := UIManager default newMenuIn: self table for: self.  tmp2 := Dictionary new.  self allMenuActions do: [:arg3 |  tmp3 := arg3 category notNil ifTrue: [ tmp2 at: arg3 category ifAbsentPut: [ tmp4 := MenuMorph new.                    tmp1 add: arg3 category subMenu: tmp4.                    tmp4 ] ] ifFalse: [ tmp1 ].        (tmp3 add: arg3 title target: self selector: #executeMenuAction: argument: arg3)           icon: arg3 icon;           balloonText: arg3 help;           enabled: (arg3 isEnabledOn: self glamourPresentation);           keyText: (arg3 hasShortcut ifTrue: [ arg3 shortcutAsString ] ifFalse: [ nil ]) ].  ^tmp1isDragSource  ^self dropOnItemBlock notNilallowsInput  ^self allowsFilter or: [ self allowsSearch ]newFirstTransmission  ^firstTransmission ifNil: [ self newTransmission ] ifNotNil: [ self firstTransmission copy ]minimumPageNumberForScrollbar  ^minimumPageNumberForScrollbar ifNil: [ 1 ]addPresentationSilently: arg1  ^presentations add: (arg1           pane: self;           yourself)doItContext  ^doItContext glamourValue: self entitymarginLeft: arg1  < brickBuilderProperty: #Geometry name: 'Margin Left' as: #asInteger getter: #marginLeft model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds marginLeft: arg1browser  ^browserrenderGlamorouslyOn: arg1  self subclassResponsibilitypaneHeight  ^transform bounds heightwhen: arg1 do: arg2  self announcer when: arg1 do: arg2popupActOn: arg1 from: arg2  GLMPopupActionBrick new     closer: (GLMPopupBrickCloser predicate: GLMPopupBrickOutisideClickPredicate new);     onCreated: [:arg3 |  self action glamourValueWithArgs: (Array with: arg1 withAll: {arg1 entity .                     arg3}) ];     openOn: arg2;     beRightToLeftWithOffset: 0registerEventsForPresentation: arg1  arg1 when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  arg1 when: GLMContextChanged send: #actOnContextChanged: to: self.  arg1 when: GLMTextEditorRequest send: #actOnTextEditorRequest: to: selfinitialize  super initialize.  parameters := Dictionary newbuttonBorderWidth  ^1markDirtyAround: arg1 inContext: arg2  arg1 isBrick ifFalse: [ ^self ].  arg1 = arg2 ifTrue: [ ^self ].  arg1 owner ifNotNil: [ (arg1 owner = arg2) not & arg1 owner isBrick ifTrue: [ (self isClean: arg1 owner) ifTrue: [ (self isDependsOnChildren: arg1 owner) ifTrue: [ self markDirty: arg1 owner.                          self markDirtyAround: arg1 owner inContext: arg1 ].                    (self isDependsOnMyself: arg1) | (self isDependsOnChildren: arg1) ifTrue: [ (arg1 owner subbricks anySatisfy: [:arg3 |  self isDependsOnParent: arg3 ]) ifTrue: [ self markDirty: arg1 owner.                                self markDirtyChildrenAround: arg1 owner inContext: arg1 ] ].                    (self isClean: arg1 owner) ifTrue: [ (arg1 layout floating = #none) not | (arg1 layout vAlign = #none) not | (arg1 layout hAlign = #none) not ifTrue: [ self markLayoutDirty: arg1 owner ] ] ] ] ].  arg1 subbricks do: [:arg3 |  arg3 = arg2 ifFalse: [ arg3 isBrick ifTrue: [ (self isDependsOnParent: arg3) & (self isClean: arg3) | (arg3 layout floating = #none) not | (arg3 layout vAlign = #none) not | (arg3 layout hAlign = #none) not ifTrue: [ self markDirty: arg3.                          self markDirtyAround: arg3 inContext: arg1 ] ] ] ].  self markDirtyCustomDependency: arg1 inContext: arg2.  arg1 subbricks do: [:arg3 |  self markDirtyCustomDependency: arg3 inContext: arg1 ]hash  ^super hashpresentationTransformation  ^presentationTransformationdynamicActions  dynamicActionsBlock ifNil: [ ^OrderedCollection new ].  ^dynamicActionsBlock glamourValue: selfpopupHelpThemer  ^self registerModule: GLMBrickPopupHelpThemer new to: self named: #popupThemeraddLazyPage: arg1 label: arg2 toolbar: arg3 action: arg4  | tmp1 tmp2 |  tmp1 := LazyTabPage new.  tmp1     lazyPageMorphCreation: arg1;     labelMorph: arg2;     toolbar: arg3.  tmp2 := self buildLabelFrom: arg2 withAction: arg4.  self addPage: tmp1 label: tmp2strongSelection: arg1  self announcer announce: (GLMTreeMorphStrongSelectionChanged new           strongSelectionValue: (self elementAt: arg1 selectedIndex) data;           yourself)paddingTop: arg1  < brickBuilderProperty: #Geometry name: 'Padding Top' as: #asInteger getter: #paddingTop model: #GLMUIBuilderTextFieldProperty>  self wrappedBounds paddingTop: arg1hasUnacceptedEdits  self announce: (GLMTextEditorRequest new action: [:arg1 |  ^arg1 model hasUnacceptedEdits ])selection: arg1  | tmp1 |  tmp1 := arg1 newSelectedIndexes select: [:arg2 |  arg2 ~= 0 ] thenCollect: [:arg2 |  self elementAt: arg2 ].  tmp1 ifNotEmpty: [ self announcer announce: (GLMTreeMorphSelectionChanged new                 selectionValue: ((tmp1 size = 1 and: [ self glamourPresentation isSingle ]) ifTrue: [ tmp1 first ] ifFalse: [ tmp1 ]);                 selectionPathValue: tmp1;                 yourself) ]allKeystrokeActions  ^self model notNil ifTrue: [ self model allActions , self model allSelectionActions select: [:arg1 |  arg1 hasShortcut ] ] ifFalse: [ #() ]act: arg1 iconName: arg2 entitled: arg3  self act: arg1 icon: (self iconNamed: arg2) entitled: arg3testPageChangedAnnouncement  | tmp1 tmp2 |  tmp1 := 0.  tabs announcer when: LazyTabPageChanged do: [:arg1 |  tmp1 := tmp1 + 1.        tmp2 := arg1 page ].  tabs selectedPageIndex: 1.  self assert: tmp1 equals: 1.  self assert: (tmp2 isKindOf: LazyTabPage)initialize  super initialize.  self beHelp.  self unhoverAction: [:arg1 :arg2 |  (arg1 globalBounds containsPoint: arg2 position) ifFalse: [ self closePopup ] ]tagsFilterBlock  ^tagsFilterBlocktransformDraggedItemBlock  ^transformDraggedItemBlocktestRightMarginMyselfDependency  | tmp1 tmp2 tmp3 |  tmp2 := 10.  tmp1 := self newBrickWithStaticExtent.  tmp3 := self newBrickWithSmallStaticExtent.  tmp3 marginRight: tmp2.  tmp1 addBrickBack: tmp3.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp3 extent equals: self staticSmallExtent.  self assert: tmp3 brickBounds equals: (0 @ 0 extent: self staticSmallExtent)paddingTop: arg1  self padding at: Top put: arg1.  self updateCachetestAnnouncement  | tmp1 tmp2 tmp3 |  tmp1 := GLMPane named: 'test'.  tmp2 := GLMPresentation new.  tmp1 addPresentation: tmp2.  tmp3 := nil.  tmp2 when: GLMContextChanged do: [:arg1 |  tmp3 := arg1 ].  (tmp1 port: #entity) value: 42.  self assert: tmp3 notNil.  self assert: tmp3 property equals: #entity.  self assert: tmp3 value equals: 42scrollMorphFor: arg1  ^GeneralScrollPane new     changeScrollerTableLayout;     scrollTarget: arg1;     layoutFrame: (LayoutFrame identity topOffset: 25);     yourselfinitialize  super initialize.  isLayouting := falselabelBrick: arg1  labelBrick := arg1.  labelBrick     vAlign: #center;     marginLeft: 5;     textPosition: #leftCentertoString: arg1  ^self glamourPresentation hasFilterBlock ifTrue: [ arg1 ] ifFalse: [ super toString: arg1 ]shadowInset  ^self valueOfProperty: #brickShadowInset ifAbsentPut: [ 0 ]entity  ^(self pane port: #entity) valueisEnabledOn: arg1  ^self enabledCondition glamourValueWithArgs: (Array with: arg1 withAll: arg1 entity asGlamorousArray)zIndex  ^zIndex ifNil: [ zIndex := 1 ]handlesMouseOverDragging: arg1  ^trueanchorBrick: arg1  anchorBrick := arg1.  self updateTriggerBricksetNotFocused  focused ifTrue: [ self checkedImage: checkedIcon.        self uncheck.        focused := false ]doValidate: arg1 on: arg2  ^self customValidation isNil ifFalse: [ self customValidation glamourValue: arg1 asGlamorousMultiValue , arg2 name asGlamorousMultiValue , self entity asGlamorousMultiValue ] ifTrue: [ self defaultValidate: arg1 on: arg2 ]toOutside: arg1  self deprecated: 'Use toOutsidePort: instead'.  ^self toOutsidePort: arg1lastSubbrick  ^self subbricks lastdragResizingRight: arg1  | tmp1 tmp2 |  tmp1 := self brickBounds left.  tmp2 := arg1 position x - self owner globalBounds left - (startDragX - self computeWidth).  tmp2 := (tmp2 max: tmp1 + self pagerModel circleButtonSize) min: self owner width.  self setPosition: tmp1 @ tmp2heightChildrenDependency: arg1  ^self subclassResponsibilityassertAllSubbricksAreDirty: arg1  arg1 withAllSubbricks do: [:arg2 |  self assertBrickDirty: arg2 ]tagMorphsFrom: arg1 for: arg2  | tmp1 tmp2 tmp3 |  tmp1 := OrderedCollection new.  tmp2 := self glamourPresentation tagsFor: arg2 fromProvider: arg1 to: #show.  tmp3 := self glamourPresentation tagsFor: arg2 fromProvider: arg1 to: #filter.  tmp2 withIndexDo: [:arg3 :arg4 |  tmp1 addLast: (self buttonForTag: arg3 filter: (tmp3 at: arg4 ifAbsentPut: [ arg3 ])) ].  ^tmp1initializeInspectButton  inspectButton := MultistateButtonMorph new     extent: GLMUIThemeExtraIcons glamorousInspect extent;     activeEnabledOverUpFillStyle: (ImageFillStyle form: GLMUIThemeExtraIcons glamorousInspect);     setBalloonText: 'Inspect' translated.  self addMorph: inspectButton fullFrame: (LayoutFrame identity           leftFraction: 1;           bottomFraction: 0;           leftOffset: inspectButton width;           bottomOffset: 2 * inspectButton width)portName: arg1  portName := arg1actOnPaneReplaced: arg1  container popAndReplacePane: (self renderObject: arg1 newPane)paddingBottom  ^self brick paddingBottomtranslateYTo: arg1  self translateY: self brickBounds top negated + arg1testCustomValidation  | tmp1 tmp2 |  tmp1 := GLMPane named: 'test'.  tmp2 := GLMPresentation new.  tmp1 addPresentation: tmp2.  tmp2 customValidation: [:arg1 :arg2 :arg3 |  arg2 ~= #selection or: [ arg1 = (arg3 last + 40) ] ].  tmp2 entity: (OrderedCollection with: 1 with: 2).  self assert: tmp2 entity last equals: 2.  self assert: (tmp2 validate: 42 on: (tmp1 port: #selection))brick  ^brickbuttonPressedColor  ^Color veryVeryLightGray lighter slightlyDarker slightlyDarkerorigin: arg1 length: arg2 breadth: arg3  ^arg1 - (arg2 @ arg3) extent: arg2 @ arg3mouseDown: arg1  (anchorBrick containsPoint: arg1 cursorPoint) ifTrue: [ anchorBrick mouseDown: arg1 ] ifFalse: [ super mouseDown: arg1 ]render: arg1  container := GLMMorphic containerMorph.  container addMorph: (self renderObject: arg1 currentPresentation) fullFrame: LayoutFrame identity.  arg1 when: GLMPresentationUpdated send: #actOnPresentationUpdated: to: self.  ^containeractOn: arg1  | tmp1 |  tmp1 := self condition glamourValue: arg1 asGlamorousMultiValue , self presentation entity asGlamorousMultiValue.  tmp1 ifTrue: [ self presentation update ]valueOfProperty: arg1 ifAbsent: arg2  ^super valueOfProperty: arg1 ifAbsent: arg2brickBounds: arg1  super brickBounds: arg1.  self invalidateMorphBoundsstateOf: arg1  ^self state cull: arg1render: arg1 onAthensCanvas: arg2  self render: arg1 on: (AthensCanvasWrapper on: arg2)outerHeight: arg1  self brickBounds: (self brickBounds withHeight: arg1 - self marginTop - self marginBottom)pane  ^self presentation panetestEntityPropogationAnnouncements  < expectedFailure>  | tmp1 tmp2 |  tmp1 := GLMTabulator new     title: '1';     yourself.  tmp2 := GLMTabulator new     title: '2';     yourself.  tmp1 pane name: 'b1 parent pane'.  tmp1 column: #'b1-pane'.  tmp2 column: #'b2-pane'.  self assert: tmp1 pane presentations size equals: 1.  self assert: tmp1 pane presentations first identicalTo: tmp1.  tmp1 transmit     to: #'b1-pane';     andShow: [:arg1 |  arg1 custom: tmp2 ].  tmp2 transmit     to: #'b2-pane';     andShow: [:arg1 |  arg1 text ].  self assertEmpty: GLMLogger instance announcements copy.  tmp1 startOn: 42.  self assert: GLMLogger instance announcements copy size equals: 12.  self assert: ((GLMLogger instance announcements copy at: 1) isKindOf: GLMContextChanged).  self assert: (GLMLogger instance announcements copy at: 1) presentation identicalTo: tmp1.  self assert: (GLMLogger instance announcements copy at: 1) property equals: #entity.  self assert: (GLMLogger instance announcements copy at: 1) value equals: 42.  self assert: ((GLMLogger instance announcements copy at: 2) isKindOf: GLMPresentationsChanged).  self assert: (GLMLogger instance announcements copy at: 2) pane identicalTo: tmp1 panes first.  self assertEmpty: (GLMLogger instance announcements copy at: 2) oldPresentations.  self assert: (GLMLogger instance announcements copy at: 2) presentations size equals: 1.  self assert: (GLMLogger instance announcements copy at: 2) presentations first equals: tmp2.  self assert: ((GLMLogger instance announcements copy at: 3) isKindOf: GLMContextChanged).  self assert: (GLMLogger instance announcements at: 3) presentation equals: tmp2.  self assert: (GLMLogger instance announcements at: 3) property equals: #entity.  self assert: (GLMLogger instance announcements at: 3) value equals: 42.  self assert: ((GLMLogger instance announcements at: 4) isKindOf: GLMPresentationsChanged).  self assert: (GLMLogger instance announcements at: 4) pane identicalTo: tmp2 panes first.  self assertEmpty: (GLMLogger instance announcements at: 4) oldPresentations.  self assert: (GLMLogger instance announcements at: 4) presentations size equals: 1.  self assert: (GLMLogger instance announcements at: 4) presentations first isNil.  self assert: ((GLMLogger instance announcements at: 5) isKindOf: GLMContextChanged).  self assert: (GLMLogger instance announcements at: 5) presentation isNil.  self assert: (GLMLogger instance announcements at: 5) property equals: #entity.  self assert: (GLMLogger instance announcements at: 5) value equals: 42.  self assert: ((GLMLogger instance announcements at: 6) isKindOf: GLMMatchingPresentationsChanged).  self assert: (GLMLogger instance announcements at: 6) pane identicalTo: tmp2 panes first.  self assertEmpty: (GLMLogger instance announcements at: 6) oldMatchingPresentations.  self assert: (GLMLogger instance announcements at: 6) matchingPresentations size equals: 1.  self assert: (GLMLogger instance announcements at: 6) matchingPresentations first isNil.  self assert: ((GLMLogger instance announcements at: 7) isKindOf: GLMMatchingPresentationsChanged).  self assert: (GLMLogger instance announcements at: 7) pane identicalTo: tmp1 panes first.  self assertEmpty: (GLMLogger instance announcements at: 7) oldMatchingPresentations.  self assert: (GLMLogger instance announcements at: 7) matchingPresentations size equals: 1.  self assert: (GLMLogger instance announcements at: 7) matchingPresentations first identicalTo: tmp2.  self assert: ((GLMLogger instance announcements at: 8) isKindOf: GLMMatchingPresentationsChanged).  self assert: (GLMLogger instance announcements at: 8) pane identicalTo: tmp1 pane.  self assertEmpty: (GLMLogger instance announcements at: 8) oldMatchingPresentations.  self assert: (GLMLogger instance announcements at: 8) matchingPresentations size equals: 1.  self assert: (GLMLogger instance announcements at: 8) matchingPresentations first identicalTo: tmp1theme  ^Smalltalk ui themewantsSteps  ^self model wantsStepswidth: arg1  width := arg1contents: arg1  self text: arg1 asStringlastTransmission  ^self transmissions lastfullDrawOn: arg1  arg1 clipRect hasPositiveExtent ifFalse: [ ^self ].  super fullDrawOn: arg1uncheck  self isChecked ifTrue: [ isChecked := false.        self announce: #onUnchecked.        self changed ]hasChildren: arg1  arg1 ifNil: [ ^false ].  arg1 isVariableBinding ifFalse: [ ^false ].  arg1 value ifNil: [ ^false ].  arg1 value isCollection ifTrue: [ ^arg1 value isEmpty not ].  ^truetagMorphsFrom: arg1  | tmp1 tmp2 tmp3 |  tmp1 := OrderedCollection new.  tmp2 := self containerTree glamourPresentation tagsFor: self item fromProvider: arg1 to: #show.  tmp3 := self containerTree glamourPresentation tagsFor: self item fromProvider: arg1 to: #filter.  tmp2 withIndexDo: [:arg2 :arg3 |  tmp1 addLast: (self buttonForTag: arg2 filter: (tmp3 at: arg3 ifAbsentPut: [ arg2 ])) ].  ^tmp1forSmalltalk: arg1  highlightSmalltalk := true.  highlightSmalltalkContext := arg1rootPrototype  ^self parentPrototype ifNil: [ self ] ifNotNil: [ self parentPrototype rootPrototype ]execute  ^self execute: self argumentstestPresentationBoundPort  | tmp1 tmp2 |  tmp1 := GLMPresentation new.  tmp2 := GLMPresentationBoundPort new     name: #port;     presentation: tmp1.  tmp2 value: 42.  self assert: (tmp1 pane port: #port) value equals: 42.  (tmp1 pane port: #port) value: 43.  self assert: tmp2 value equals: 43focusChanged: arg1  | tmp1 tmp2 |  tmp2 := arg1 morph.  currentFocus = tmp2 ifFalse: [ currentFocus := tmp2.        tmp1 := self pageOf: tmp2.        tmp1 > 0 ifTrue: [ pagerModel focusedMorphChanged: tmp2 at: tmp1 ] ]dataCacheFor: arg1  ^self dataCache at: arg1 ifAbsentPut: [ Dictionary new ]model: arg1  model := arg1result  ^resultisFitsInParent  ^self owner ifNotNil: [ self owner globalBounds containsRect: self globalBounds ] ifNil: [ self owner ifNotNil: [ self owner bounds containsRect: self globalBounds ] ifNil: [ ^true ] ]renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderTablePresentation: selfactOnContextChanged: arg1  arg1 property = #selection ifTrue: [ tableModel announcer suspendAll: self suspendedAnnouncements while: [ tableModel explicitSelection: arg1 value ] ]paneName: arg1  paneName := arg1createDataSourceFrom: arg1  ^GLMFastTableDataSource newshadowInset  ^0resizeColumns  | tmp1 |  self columns size > 1 ifFalse: [ ^self ].  tmp1 := self rowMorphsWidths.  self allNodeMorphs do: [:arg1 |  arg1 submorphs doWithIndex: [:arg2 :arg3 |  arg2                 hResizing: #rigid;                 width: (tmp1 at: arg3) ] ].  self hHideScrollBarshrinkingHeight  ^self morph heighttestNestedSuspendAllWhile  | tmp1 |  announcer when: GLMTestAnnouncement do: [:arg1 |  tmp1 := arg1 ].  tmp1 := nil.  announcer suspendAllWhile: [ announcer suspendAllWhile: [  ].        announcer announce: GLMTestAnnouncement ].  self assert: tmp1 isNilrenderWithExpanders: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := GLMPanelMorph new.  tmp3     fillStyle: Color transparent;     hResizing: #spaceFill;     vResizing: #shrinkWrap;     changeTableLayout;     layoutInset: 2;     cellInset: 2.  tmp2 := GeneralScrollPane new.  tmp2     changeScrollerTableLayout;     scrollTarget: tmp3.  arg1 panes do: [:arg2 |  tmp4 := ExpanderMorph titleText: (arg2 presentations titleValue ifNil: [ 'noname' ]).        tmp1 := GLMMorphicPaneWithoutTitleRenderer new render: arg2.        tmp1 borderStyle: (UITheme current buttonSelectedBorderStyleFor: tmp1).        tmp4 addMorphBack: tmp1.        tmp3 addMorph: tmp4 ].  ^tmp2invalidateWith: arg1  arg1 cull: self.  self doLayoutForceoutOfWorld: arg1  super outOfWorld: arg1.  self unsubscribeListenersportChangeActions: arg1  portChangeActions := arg1model  ^adaptorwantsDropElements: arg1 type: arg2 index: arg3  ^(arg1 isEmptyOrNil or: [ arg2 ~= self dragTransferType ]) ifFalse: [ self glamourPresentation allow: (self collectionToDragPassenger: arg1) droppedOnItem: (self elementOrZeroAt: arg3) ] ifTrue: [ false ]allowDeselection  self allowsDeselection: truefromPrevious: arg1  self flag: 'needs revisiting. it does not work anymore'.  self scriptTransmission addActiveOrigin: (GLMPort new name: arg1)changedWith: arg1  self changed.  arg1 cull: self.  self changedtestLeftMarginMyselfDependency  | tmp1 tmp2 tmp3 |  tmp2 := 10.  tmp1 := self newBrickWithStaticExtent.  tmp3 := self newBrickWithSmallStaticExtent.  tmp3 marginLeft: tmp2.  tmp1 addBrickBack: tmp3.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp3 extent equals: self staticSmallExtent.  self assert: tmp3 brickBounds equals: (tmp2 @ 0 extent: self staticSmallExtent)methodBindingsStrategy  ^[:arg1 :arg2 |  arg1 associationAt: arg2 ifAbsent: [ nil ] ]children  ^childrenmouseWheel: arg1  self scrollBy: (self calculateVelocity: arg1) direction: (arg1 isUp ifTrue: [ #up ] ifFalse: [ #down ])keymap: arg1  keymap := arg1testMaxHeightTwoParentDependencies  | tmp1 tmp2 tmp3 |  tmp1 := self newBrickWithStaticExtent.  tmp1 useVerticalLinearLayout.  tmp2 := self newBrickWithFullFill.  tmp2 maxHeight: self staticSmallHeight.  tmp3 := self newBrickWithFullFill.  tmp1 addAllBricks: {tmp2 .         tmp3}.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp2 extent equals: self staticWidth @ self staticSmallHeight.  self assert: tmp3 extent equals: self staticWidth @ (self staticHeight - self staticSmallHeight)font: arg1  font := arg1testTreeWithDisplay  | tmp1 tmp2 |  tmp2 := {(#root1 -> {(#child1 -> {}) .         (#child2 -> {})}) .   (#root2 -> {})}.  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 tree           display: [:arg2 |  arg2 value ];           children: [:arg3 |  arg3 value ] ].  window := tmp1 openOn: #something -> tmp2.  self assert: tmp1 panes first presentations first displayValue identicalTo: tmp2doNotLayoutDuring: arg1  | tmp1 |  tmp1 := self isLayotingAllowed.  self isLayotingAllowed: false.  [ arg1 cull: self ] ensure: [ tmp1 ifTrue: [ self isLayotingAllowed: true ] ]reset  isCompleted := false.  shouldStop := false.  doStep := true.  fromValue := nil.  toValue := nil.  currentValue := nil.  startTime := niltags: arg1  self tagsBlock: arg1.  self hasTagsFilter ifFalse: [ self tagsFilter: arg1 ]title  ^self addBrickBack: (self newLabel hAlign: #center)registerInPresentation  self announcerObjects do: [:arg1 |  arg1 notNil ifTrue: [ (arg1 when: self announcement send: #actOn: to: self) makeWeak.              self presentation registeredAnnouncers add: arg1 ] ]initialize  super initialize.  self band useVerticalLinearLayoutonLayouted  self updateFoundationBoundsaccept: arg1 notifying: arg2  arg1 asString trimBoth ifEmpty: [ ^self ].  self text: arg1.  self changed: #textheaderBrick  ^headerBricktestCopy  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMTransmission new.  tmp2 := GLMSimplePort new.  tmp3 := GLMSimplePort new.  tmp1 destination: tmp3.  tmp1 addActiveOrigin: tmp2.  tmp4 := tmp1 copy.  self assert: tmp4 destination ~~ tmp1 destination.  self assert: tmp4 origins first ~~ tmp1 origins firstname: arg1  name := arg1approximateWidth  ^self hMargin + self hPadding + (self isReadMode ifTrue: [ self labelBrick approximateWidth ] ifFalse: [ self editBrick width + self editBrick hPadding + self editBrick hMargin ])isPressed  ^isPressedupdate  self pane ports do: [:arg1 |  (self validate: arg1 value on: arg1) ifFalse: [ arg1 resetValue ] ].  self announce: (GLMPresentationUpdated new presentation: self)testTriggerConditions  | tmp1 tmp2 tmp3 |  tmp1 := GLMTransmission new.  tmp2 := GLMSimplePort new name: #port1.  tmp3 := GLMSimplePort new name: #port2.  tmp1 addActiveOrigin: tmp2.  tmp1 destination: tmp3.  self assert: (tmp1 originatesAt: tmp2).  self assert: (tmp1 originatesAt: tmp3) not.  self assert: (tmp1 originatesAt: GLMPort new) nottransformDraggedItem: arg1  transformDraggedItemBlock := arg1highlightSmalltalkContext  ^highlightSmalltalkContextrootItem  ^rootItem ifNil: [ rootItem := self createRootItem ]wantsAutomaticRefresh: arg1  wantsAutomaticRefresh := arg1textPositionHorizontalCenter  ^((self brickBounds width - self textSize x max: 0) / 2) @ 0width  ^self hState dimensionhandlesMouseDown: arg1  ^clickAction notNiltranslateX: arg1  ^self brick translateX: arg1presentations  ^self transmissionStrategy presentationslayoutWidgets  | tmp1 tmp2 |  tmp2 := super innerBounds.  tmp1 := self innerBounds.  transform bounds: tmp1.  scrollBar bounds: (tmp1 left @ tmp1 bottom corner: tmp2 bottomRight)morph  ^RubScrolledTextMorph new     getSelectionSelector: #primarySelectionInterval;     color: self theme backgroundColor;     textColor: self theme textColor;     textFont: StandardFonts defaultFont;     model: textModel;     yourselftags: arg1  self tagsBlock: arg1.  self hasTagsFilter ifFalse: [ self tagsFilter: arg1 ]morph  ^morphtestTransmissionWithTwoOrigins  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two;     column: #three.  tmp1 transmit     to: #three;     from: #one;     from: #two;     andShow: [:arg1 |  arg1 text ].  ((tmp1 paneNamed: #one) port: #selection) value: 42.  self assert: ((tmp1 paneNamed: #three) port: #entity) value first equals: 42.  self assert: ((tmp1 paneNamed: #three) port: #entity) value last equals: nil.  self assert: (tmp1 paneNamed: #three) presentations size equals: 1.  self assert: (tmp1 paneNamed: #three) matchingPresentations size equals: 0.  ((tmp1 paneNamed: #two) port: #selection) value: 43.  self assert: ((tmp1 paneNamed: #three) port: #entity) value first equals: 42.  self assert: ((tmp1 paneNamed: #three) port: #entity) value last equals: 43.  self assert: (tmp1 paneNamed: #three) matchingPresentations size equals: 1buttonPadding  ^#(3 7)actOnPresentationUpdated: arg1  scrollPane scrollTarget: (self morphFrom: arg1 presentation)testCreation  self assertEmpty: GLMExpander new panesnoSelection  self acceptsSelection: falsetestFinderWithEmbeddedBrowser  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMTabulator new.  tmp1     row: #content;     row: #details.  tmp1 transmit     to: #content;     andShow: [:arg1 |  arg1 list display: #allSuperclasses ].  tmp1 transmit     from: #content;     to: #details;     andShow: [:arg1 |  arg1 text ].  tmp1 transmit     from: #content;     toOutsidePort: #selection.  tmp2 := GLMFinder new.  tmp2 show: [:arg1 |  arg1 custom: tmp1 ].  window := tmp2 openOn: String.  (tmp2 panes first port: #selection) value: Collection.  self assert: tmp2 panes first presentations first ~= tmp2 panes last presentations first.  tmp3 := self find: MorphTreeMorph in: window submorphs last submorphs last submorphs first.  tmp4 := self findLast: MorphTreeMorph in: window submorphs last submorphs last submorphs last.  self assert: tmp3 notNil.  self assert: tmp4 notNil.  self assert: tmp3 ~= tmp4.  self assert: tmp3 model glamourPresentation pane ~= tmp4 model glamourPresentation pane.  self assert: tmp3 model glamourPresentation ~= tmp4 model glamourPresentation* arg1  < return: #Point>  ^0 @ arg1select: arg1  ^self presentations select: arg1testMarkerOneStaticInChildrenWidth  | tmp1 tmp2 |  tmp1 := self newBrickWithFullDependsOnChildren.  tmp2 := self newBrickWithStaticExtent.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthDirty.  self assert: tmp2 wrappedBounds isHeightClean.  self assert: tmp1 wrappedBounds isWidthDirty.  self assert: tmp1 wrappedBounds isHeightCleanisSelectionPort  ^self port isSelectionPortretrieveLast: arg1  ^arg1 isEmpty ifTrue: [ nil ] ifFalse: [ arg1 removeLast ]testAnnouncerUnregistration  self assert: announcer numberOfSubscriptions equals: 5.  browser entity: #($a $b).  self assert: announcer numberOfSubscriptions equals: 5.  browser entity: #($d).  self assert: announcer numberOfSubscriptions equals: 5.  browser entity: #().  self assert: announcer numberOfSubscriptions equals: 5.  browser unregisterFromAllAnnouncements.  self assert: announcer numberOfSubscriptions equals: 0initialize  super initialize.  self labelBrick: self newLabelBrick.  self editBrick: self newEditBrick.  self     padding: self themer focusedBorderWidth;     borderWidth: self themer focusedBorderWidth;     hShrinkWrap;     vShrinkWrap;     enable;     enableDoubleClick;     when: #onDoubleClicked do: [ (self hasSubbrick: self editBrick) ifFalse: [ self beEdit ] ];     bindKeyCombination: Character escape toAction: [ self onEscapePressed ]width: arg1  < brickBuilderProperty: #Geometry name: 'Width' as: #asInteger getter: #width model: #GLMUIBuilderTextFieldProperty>  self privateWidth: arg1.  self updateWidthisFilterable  ^self parameters at: 'isFilterable' ifAbsent: [ false ]initializePresentation  super initializePresentation.  self do: [:arg1 |  arg1 initializePresentation ]add: arg1  collection add: arg1.  self announce: GLMItemAddedactions  actions ifNil: [ actions := OrderedCollection new ].  ^actionslayoutProperties: arg1  super layoutProperties: arg1pushPane: arg1  | tmp1 |  tmp1 := self pagerModel size >= self pagerModel numberOfVisiblePages.  self pagerModel pushPane: arg1 smooth: tmp1renderImageOf: arg1 on: arg2  | tmp1 |  tmp1 := arg1 currentImage.  tmp1 ifNotNil: [ arg2 translucentImage: (GLMBrick resizeImage: tmp1 scale: (arg1 brickBounds expandBy: arg1 shadowWidth negated) extent / tmp1 extent) at: (arg1 brickBounds expandBy: arg1 shadowWidth negated) origin + ((arg1 paddingLeft - arg1 paddingRight) @ (arg1 paddingTop - arg1 paddingBottom) / 2.0) ]testEnlargeToLeft  | tmp1 tmp2 |  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  tmp1 := pagerModel numberOfVisiblePages.  tmp2 := pagerModel lastVisiblePageIndex.  self assert: pagerModel numberOfVisiblePages equals: tmp1.  self assert: pagerModel numberOfVisiblePages equals: tmp2 - pagerModel firstVisiblePageIndex + 1.  self assert: pagerModel lastVisiblePageIndex equals: tmp2.  [ tmp1 < 6 ] whileTrue: [ tmp1 := tmp1 + 1.        pagerModel enlargeToLeft.        self assert: pagerModel numberOfVisiblePages equals: tmp1.        self assert: pagerModel numberOfVisiblePages equals: tmp2 - pagerModel firstVisiblePageIndex + 1.        self assert: pagerModel lastVisiblePageIndex equals: tmp2 ].  (1 to: 3) do: [:arg1 |  pagerModel enlargeToLeft.        self assert: pagerModel numberOfVisiblePages equals: 6.        self assert: pagerModel numberOfVisiblePages equals: tmp2 - pagerModel firstVisiblePageIndex + 1.        self assert: pagerModel lastVisiblePageIndex equals: tmp2.        self assert: pagerModel firstVisiblePageIndex equals: 1 ]checkboxBorderColor  ^Color lightGrayinitializeListeners  self addCloserListenerstaticSmallHeight  ^50 * self currentWorld displayScaleFactorfont  ^fontsuspendAllWhile: arg1  | tmp1 |  tmp1 := suspendAll.  suspendAll := true.  arg1 ensure: [ suspendAll := tmp1 ]presentations  ^presentations ifNil: [ presentations := OrderedCollection new ]parentNode: arg1  parentNode := arg1privateOwner: arg1  owner := arg1handlesKeyboard: arg1  ^trueuseImplicitNotNil  implicitNotNil := trueinitialize  super initialize.  self     color: Color transparent;     borderWidth: 0;     vResizing: #spaceFill;     hResizing: #spaceFill.  self     initializeTransform;     initializeScrollbar.  paneCount := 0.  maxPanes := 2allowsItemDrag  ^self allowItemDragBlock notNilicon  ^iconheaderMorph: arg1  headerMorph := arg1.  headerMorph clipSubmorphs: trueensurePresentIfNoneStrategy  self transmissionStrategy class = GLMPresentIfNoneStrategy ifFalse: [ self transmissionStrategy: (GLMPresentIfNoneStrategy of: self) ]notifyScrollPositionChanged: arg1 callback: arg2  self notifyAll: (GLMPagerScrollPositionChanged new           smooth: arg1;           callback: arg2;           yourself)sourceContext: arg1  sourceLink := arg1at: arg1  ^collection at: arg1scrollTo: arg1 smooth: arg2  self scrollTo: arg1 smooth: arg2 callback: nilbackgroundColor  ^Color r: 220 g: 246 b: 255 range: 255widthBottom  ^self width at: BottomaddColumn: arg1  self columns add: arg1highlightSmalltalkContext: arg1  highlightSmalltalkContext := arg1tagsFor: arg1 fromProvider: arg2 to: arg3  | tmp1 |  tmp1 := arg1 asGlamorousMultiValue , self entity asGlamorousMultiValue.  ^arg3 == #show ifTrue: [ arg2 computeTagsFor: tmp1 ] ifFalse: [ arg2 computeTagsFilterFor: tmp1 ]initializeNamed: arg1  self initializeNamed: arg1 in: GLMNoBrowser newfloating  ^self layout floatingtextLogic: arg1  textLogic := arg1newBand  ^GLMScrollPaneBandBrick newdefaultRenderer  ^GLMBrickRenderer newcolorRight: arg1  self color at: Right put: arg1font: arg1  font := arg1session: arg1  session := arg1zIndex: arg1  self layout zIndex: arg1initialize  super initialize.  self fillStyle: self defaultFillStyle.  isOpen := false.  self setLabel: 'Glamorous Watcher'.  self addCornerGrips.  self addEdgeGrips.  self addContentsMorph.  self on: Character escape do: [ self hide ]onPagePushed: arg1  self pushPane: arg1 morphisShrinking  ^self isHShrinking | self isVShrinkinghintModifier: arg1  hintModifier := arg1value: arg1  value := arg1executionSelectionActions  ^{(GLMGenericAction new     title: 'Do it';     action: [:arg1 |  arg1 highlightEvaluateAndDo: [:arg2 |   ] ];     keymap: PharoShortcuts current doItShortcut;     icon: GLMUIThemeExtraIcons glamorousSpawn;     yourself) .   (GLMGenericAction new     title: 'Print it';     action: [:arg1 |  arg1 printSelection ];     keymap: PharoShortcuts current printItShortcut;     yourself) .   (GLMGenericAction new     title: 'Inspect it';     action: [:arg1 |  arg1 highlightEvaluateAndDo: [:arg2 |  arg2 inspect ] ];     keymap: PharoShortcuts current inspectItShortcut;     icon: GLMUIThemeExtraIcons glamorousInspect;     yourself) .   (GLMGenericAction new     title: 'Basic Inspect it';     action: [:arg1 |  arg1 highlightEvaluateAndDo: [:arg2 |  arg2 basicInspect ] ];     shortcut: $I;     icon: GLMUIThemeExtraIcons glamorousInspect;     yourself) .   (GLMGenericAction new     title: 'Debug it';     action: [:arg1 |  arg1 debugSelection ];     shortcut: $D;     yourself) .   (GLMGenericAction new     title: 'Profile it';     action: [:arg1 |  arg1 profileSelection ];     withSeparatorAfter;     yourself)}scrollbarCornerRadius  ^self valueOfProperty: #brickScrollbarCornerRadius ifAbsent: [ self themer scrollbarCornerRadius ]presentation  ^presentationwrapped: arg1  wrapped := arg1isFocused  ^falseleft  ^(GLMVector direction: self direction left) length: self lengthnoTestOKeyWithCtrlCannotBeOverriden  | tmp1 tmp2 tmp3 tmp4 |  tmp3 := false.  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text act: [:arg2 |  tmp3 := true ] on: $o entitled: 'Override' ].  window := tmp1 openOn: '4'.  tmp2 := self find: RubScrolledTextMorph in: window.  tmp4 := $o meta asKeyCombination.  tmp2 textArea handleKeystroke: (KeyboardEvent new setType: #keystroke buttons: tmp4 modifier eventCode position: tmp2 textArea center keyValue: tmp4 key asciiValue charCode: tmp4 key asciiValue hand: nil stamp: DateAndTime now).  self assert: tmp3 notstatus: arg1  self flag: 'what kind of transformation should we want here?'.  (self pane port: #status) value: (self selectionTransformation glamourValue: arg1)invariant  self isDebug ifFalse: [ ^self ].  pagesCount >= 0 ifFalse: [ GLMPagerException signal: 'The number of page must be non negative' ].  pagesCount > 1 ifTrue: [ firstVisiblePageIndex >= 1 ifFalse: [ GLMPagerException signal: 'First visible page index must be > 1 if number of pages > 0' ].        lastVisiblePageIndex >= 1 ifFalse: [ GLMPagerException signal: 'Last visible page index must be > 1 if number of pages > 0' ].        lastVisiblePageIndex <= pagesCount ifFalse: [ GLMPagerException signal: 'Last visible page index must be less or equals to the number of pages' ].        self actualNumberOfVisiblePages <= numberOfVisiblePages ifFalse: [ GLMPagerException signal: 'Actual number of visible pages must be less or equals to current number of visible pages' ].        selectedPageIndex >= 1 ifFalse: [ GLMPagerException signal: 'Selected page index must be greater or equals then 1 if number of pages is more than 1' ] ].  pagesCount = 1 ifTrue: [ firstVisiblePageIndex = 1 ifFalse: [ GLMPagerException signal: 'First visible page index must be 1 if number of pages is 1' ].        lastVisiblePageIndex = 1 ifFalse: [ GLMPagerException signal: 'Last visible page index must be 1 if number of pages is 1' ].        lastVisiblePageIndex = firstVisiblePageIndex ifFalse: [ GLMPagerException signal: 'First and Last visible page indexes must be equal if number of pages is 1' ].        self actualNumberOfVisiblePages = 1 ifFalse: [ GLMPagerException signal: 'Actual number of visible pages must be 1 if number of pages is 1' ].        selectedPageIndex = 1 ifFalse: [ GLMPagerException signal: 'Selected page index must be 1 if number of pages is 1' ] ].  pagesCount = 0 ifTrue: [ firstVisiblePageIndex = 0 ifFalse: [ GLMPagerException signal: 'First visible page index must be 0 if number of pages is 0' ].        lastVisiblePageIndex = 0 ifFalse: [ GLMPagerException signal: 'Last visible page index must be 0 if number of pages is 0' ].        self actualNumberOfVisiblePages = 0 ifFalse: [ GLMPagerException signal: 'Actual number of visible pages must be 0 if there is no pages' ].        selectedPageIndex = 0 ifFalse: [ GLMPagerException signal: 'Selected page index must be 0 if number of pages is 0' ] ]condition: arg1  condition := arg1morph: arg1 withTitleOrNilOf: arg2  (arg2 hasTitle or: [ arg2 hasTitleIcon ]) ifFalse: [ ^self morph: arg1 withToolbarOf: arg2 ].  ^self morph: arg1 withTitleOf: arg2testPresentationInitializationBlock  | tmp1 tmp2 tmp3 |  tmp3 := 0.  tmp1 := GLMPane named: 'test'.  tmp2 := GLMPresentation new initialize: [:arg1 |  (arg1 pane port: #test) value: tmp3 ].  tmp1 addPresentation: tmp2.  self assert: (tmp1 port: #test) value equals: nil.  tmp2 initializePresentation.  self assert: (tmp1 port: #test) value equals: 0.  self assert: (tmp2 pane port: #test) value equals: 0.  tmp3 := 1.  tmp2 initializePresentation.  self assert: (tmp1 port: #test) value equals: 1.  self assert: (tmp2 pane port: #test) value equals: 1rowMorphElementsForColumn: arg1 node: arg2 withIndex: arg3  | tmp1 tmp2 tmp3 |  tmp2 := arg1 modifiedBlock ifNotNil: [ self editRowMorphForColumn: arg1 node: arg2 withIndex: arg3 ] ifNil: [ self viewRowMorphForColumn: arg1 node: arg2 withIndex: arg3 ].  tmp1 := OrderedCollection new     add: tmp2;     yourself.  tmp3 := self tagMorphsFrom: arg1 for: arg2.  tmp3 ifNotEmpty: [ tmp1 addAll: tmp3 ].  ^tmp1north  direction := NorthborderWidth  ^0printOn: arg1  super printOn: arg1.  arg1 nextPutAll: ' (pane = ' , self pane printString , ')'table  ^tabledefaultSelectionActions  ^{self goAction} , super defaultSelectionActionsconvertIndexToValue: arg1  ^self convertIndexToValue: arg1 with: self sizetextBrick  ^textBrickhSpaceFill: arg1  super hSpaceFill: arg1.  self labelBrick hSpaceFill.  self editBrick hSpaceFilllogger  ^loggerenableFilter: arg1  self enableFilter.  self parameters at: 'filterBlock' put: arg1hasDimensionRestrictions: arg1  ^(self hasMinDimensionRestriction: arg1) | (self hasMaxDimensionRestriction: arg1)onDraw: arg1  super onDraw: arg1.  self highlightedText isEmpty ifFalse: [ self calculateHighlightingBounds do: [:arg2 |  self highlightingLogic ifNil: [ arg1 line: arg2 bottomLeft to: arg2 bottomRight width: 1 color: self textColor ] ifNotNil: [ self highlightingLogic cull: arg1 cull: arg2 ] ] ].  arg1 drawString: self text at: self calculateTextPosition font: self font color: self textColorhandlePotentialStatusbarFor: arg1  | tmp1 tmp2 |  tmp2 := 0.  arg1 hasStatusbar ifTrue: [ tmp1 := GLMMorphicPaneWithoutTitleRenderer render: arg1 statusbarPane from: self renderer.        tmp2 := (0 - (LabelMorph contents: 'XXX') minHeight) * 1.2.        window addMorph: tmp1 fullFrame: (LayoutFrame identity                 topFraction: 1;                 leftOffset: 2;                 topOffset: tmp2;                 rightOffset: -2) ].  ^tmp2testEmptyPanes  | tmp1 |  tmp1 := GLMFinder new.  self assertEmpty: tmp1 panes.  self assertEmpty: tmp1 transmissionsonCompleted: arg1  callback := arg1text  ^self label textwithContentsDo: arg1  arg1 value: self.  self containerTree glamourPresentation allowsRecursiveSearch ifTrue: [ self contents do: [:arg2 |  arg2 withContentsDo: arg1 ] ]titleText  ^titleText ifNil: [ titleText := 'Hi,' ]drawSubmorphsOn: arg1  | tmp1 tmp2 |  self submorphs isEmpty ifTrue: [ ^self ].  tmp1 := arg1 clipRect intersect: self globalInnerBounds ifNone: (0 @ 0 extent: 0 @ 0).  tmp1 width = 0 | (tmp1 height = 0) ifTrue: [ ^self ].  tmp2 := OrderedCollection new.  self subbricks do: [:arg2 |  | tmp3 tmp4 tmp5 |        arg2 ifNotNil: [ tmp5 := arg2 globalClippingBounds.              (tmp1 intersects: tmp5) ifTrue: [ | tmp6 |                    tmp6 := arg2 layoutProperties zIndex brickValue: arg2.                    tmp6 = 1 ifTrue: [ tmp3 := tmp1 intersect: tmp5 ifNone: (0 @ 0 extent: 0 @ 0).                          tmp4 := arg1 copyClipRect: tmp3.                          arg2 fullDrawOn: tmp4 ] ifFalse: [ tmp2 add: arg2 ] ] ] ].  tmp2 sort: [:arg3 :arg4 |  (arg3 layoutProperties zIndex brickValue: arg3) < (arg4 layoutProperties zIndex brickValue: arg4) ].  tmp2 do: [:arg2 |  | tmp3 tmp4 tmp5 |        arg2 ifNotNil: [ tmp5 := arg2 globalClippingBounds.              tmp3 := tmp1 intersect: tmp5 ifNone: (0 @ 0 extent: 0 @ 0).              tmp4 := arg1 copyClipRect: tmp3.              arg2 fullDrawOn: tmp4 ] ]defaultFinderBrowser  | tmp1 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 list           title: 'title';           display: [:arg2 |  1 to: arg2 ];           showOnly: 50 ].  ^tmp1primarySelectionInterval: arg1  primarySelectionInterval := arg1when: arg1 send: arg2 to: arg3  self announcer when: arg1 send: arg2 to: arg3window  self announce: (GLMWindowRequest new action: [:arg1 |  ^arg1 ]).  ^nilcheckboxBorderColor  ^Color lightGraytestSimpleTransmissionWithCondition  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     from: #one port: #port1;     fromOutsidePort: #entity;     to: #two port: #port2;     when: [:arg1 :arg2 |  arg1 notNil and: [ arg2 notNil and: [ arg1 + arg2 = 42 ] ] ].  tmp1 startOn: 2.  self assert: ((tmp1 paneNamed: #two) port: #port2) value isNil.  ((tmp1 paneNamed: #one) port: #port1) value: 39.  self assert: ((tmp1 paneNamed: #two) port: #port2) value isNil.  ((tmp1 paneNamed: #one) port: #port1) value: 40.  self assert: ((tmp1 paneNamed: #two) port: #port2) value notNilcomputation  ^computationtestDefaultPane  | tmp1 tmp2 |  tmp1 := GLMPresentation new.  tmp2 := tmp1 pane.  self assert: tmp2 presentations first pane identicalTo: tmp2.  self assert: tmp2 presentations pane identicalTo: tmp2.  self assert: tmp2 presentations first identicalTo: tmp1glamourPresentation  ^glamourPresentationhighlightingLogic  ^self valueOfProperty: #brickHighlightingLogic ifAbsentPut: [ [:arg1 :arg2 |  | tmp1 |        tmp1 := arg2 translateBy: (3 @ 1) negated + self brickBounds origin.        arg1 line: tmp1 bottomLeft to: tmp1 bottomRight width: 1 color: self textColor ] ]origin: arg1 breadth: arg2  < return: #Rectangle>  ^self direction origin: arg1 length: length breadth: arg2scrollpaneBackgroundColor  ^Color transparentusesImplicitNotNil  ^implicitNotNil ifNil: [ implicitNotNil := true ]glamourColumn  ^glamourColumnchildren: arg1  children := arg1withLineNumbers  ^withLineNumbers ifNil: [ withLineNumbers := false ]column: arg1 evaluated: arg2 tags: arg3  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           tags: arg3)position: arg1  position := arg1evaluateSelection  self announce: (GLMEvaluateSelection new           action: [:arg1 |  arg1 ];           makeSyncronous)familyName: arg1  self label familyName: arg1.  self dotsBrick familyName: arg1rubricBorderColor  ^self valueOfProperty: #brickRubricBorderColor ifAbsent: [ self themer rubricBorderColor ]keyStroke: arg1 from: arg2  ^falseterminate  self asyncTask terminate.  self isCompleted not & self animatedObject isNotNil ifTrue: [ ensureLogic brickValue: self animatedObject ]registerEventsForPresentation: arg1  super registerEventsForPresentation: arg1.  arg1 when: GLMVariableBindingsChanged send: #actOnVariableBindingsUpdated: to: self.  arg1 when: GLMVariableBindingsAccessRequest send: #actOnVariableBindingsAccessRequest: to: selfshadowInset: arg1  self setProperty: #brickShadowInset toValue: arg1editBrick: arg1  editBrick := arg1.  self editBrick     hShrinkWrap;     vShrinkWrap;     withoutMargins;     withoutAdornment;     withoutBorder;     beTransparent;     autoAccept: true;     rubricTextFamilyName: self themer textFamilyName;     rubricTextFontSize: self themer textFontSize.  self editBrick rubric forceHeight: [ self labelBrick height ].  self editBrick rubric announcer when: RubReturnEntered send: #onTextAccepted: to: self.  self editBrick rubric announcer when: MorphLostFocus send: #onLostFocus to: self.  self editBrick rubric announcer when: MorphGotFocus send: #onGotFocus: to: self.  self editBrick rubric announcer when: RubTextAcceptRequest send: #onTextChanged: to: selfonPagePoped  buttonsBrick onPagePoped.  self recomputeScrollBarbrickApi  ^brickApi ifNil: [ brickApi := GLMBrickWrapper on: self ]resetChildrenContent  items := self calculateItems.  self resetDataCacheinitialize  super initialize.  self useVerticalLinearLayoutcurrentPresentation  ^(self displayValue isCollection and: [ self displayValue isString not ]) ifTrue: [ GLMListPresentation new           showOnly: 50;           pane: self pane ] ifFalse: [ GLMRubricTextPresentation new pane: self pane ]origin: arg1 length: arg2 breadth: arg3  ^arg1 - (arg3 @ 0) extent: arg3 @ arg2condition  ^conditionrender: arg1  ^self renderWithExpanders: arg1testMultipleSelectionWithChange  | tmp1 tmp2 tmp3 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text display: '123456789' ].  window := tmp1 openOn: 4.  tmp2 := self find: RubScrolledTextMorph in: window.  self assertEmpty: tmp2 selectionInterval.  tmp3 := tmp1 presentations first.  tmp3 selectionInterval: (2 to: 5).  self assert: tmp2 textArea selection asString equals: '2345'.  self assert: tmp3 selectedText asString equals: '2345'tagsBlock  ^tagsBlockglobalBounds  ^self boundstestCreateTabulator  | tmp1 |  tmp1 := GLMCompositePresentation new.  tmp1 tabulator with: [:arg1 |  arg1 row: #one.        arg1 transmit           to: #one;           transformed: [:arg2 |  arg2 + 1 ];           andShow: [:arg3 |  arg3 text ] ].  self assert: tmp1 size equals: 1.  self assert: (tmp1 first isKindOf: GLMTabulator).  tmp1 startOn: 41.  self assert: tmp1 first panes size equals: 1.  self assert: (tmp1 first panes first port: #entity) value equals: 42glamourPresentation: arg1  glamourPresentation := arg1testSuspendParticularAnnouncementWithInheritanceWhile  | tmp1 tmp2 |  announcer when: Announcement do: [:arg1 |  tmp1 := arg1 ].  tmp1 := nil.  tmp2 := announcer announce: Announcement.  self assert: tmp1 equals: tmp2.  tmp1 := nil.  announcer suspendAll: {Announcement} while: [ tmp2 := announcer announce: GLMTestAnnouncement ].  self assert: tmp1 isNilcodeEditingSelectionActions  ^{(GLMGenericAction new     title: 'Cut';     action: [:arg1 |  arg1 cut ];     iconName: #smallCutIcon;     shortcut: $x;     withSeparatorBefore;     yourself) .   (GLMGenericAction new     title: 'Copy';     action: [:arg1 |  arg1 copySelection ];     iconName: #smallCopyIcon;     shortcut: $c;     yourself) .   (GLMGenericAction new     title: 'Paste';     action: [:arg1 |  arg1 paste ];     iconName: #smallPasteIcon;     shortcut: $v;     yourself) .   (GLMGenericAction new     title: 'Paste...';     action: [:arg1 |  arg1 pasteRecent ];     iconName: #smallCopyIcon;     withSeparatorAfter;     yourself)}getMorphAt: arg1 recycled: arg2  | tmp1 |  tmp1 := (self model morphAt: arg1 convert: arg2) asBrick.  tmp1 hSpaceFill.  self setIndex: arg1 in: tmp1.  ^tmp1maxDepth  ^self parameters at: 'maxDepth' ifAbsent: [ nil ]isDependenciesShown  ^isDependenciesShowntestPresentations  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMTransmission new ensureReplacePresentationsStrategy.  tmp1 addActiveOrigin: (GLMSimplePort new           name: #port1;           value: 1).  tmp1 addPassiveOrigin: (GLMSimplePort new           name: #port2;           value: 2).  tmp1 destination: (GLMSimplePort new name: #port3).  tmp2 := GLMPresentation new title: 'presentation1'.  tmp3 := GLMPresentation new title: 'presentation2'.  tmp4 := GLMPresentation new title: 'presentation3'.  tmp1 transmissionStrategy addPresentation: tmp2.  tmp1 transmissionStrategy addPresentation: tmp3.  tmp1 transmissionStrategy addPresentation: tmp4.  self assert: tmp1 transmissionStrategy presentations size equals: 3.  self assert: (tmp1 transmissionStrategy presentations at: 1) title equals: tmp2 title.  self assert: (tmp1 transmissionStrategy presentations at: 2) title equals: tmp3 title.  self assert: (tmp1 transmissionStrategy presentations at: 3) title equals: tmp4 title.  self assert: (tmp1 transmissionStrategy presentations at: 1) ~~ tmp2.  self assert: (tmp1 transmissionStrategy presentations at: 2) ~~ tmp3.  self assert: (tmp1 transmissionStrategy presentations at: 3) ~~ tmp4testOriginValue  | tmp1 tmp2 |  tmp1 := GLMSimplePort new value: 42.  tmp2 := GLMOriginPortReference new port: tmp1.  self assert: tmp2 value equals: 42privateAddBrickLinkBack: arg1  | tmp1 tmp2 |  tmp2 := arg1 asBrick.  tmp1 := tmp2 asDoubleLink.  tmp2 brickDoubleLink: tmp1.  self hasSubbricks ifTrue: [ self lastSubbrick brickDoubleLink nextLink: tmp1.        tmp1 previousLink: self lastSubbrick brickDoubleLink ].  tmp2 owner: self.  ^arg1keystroke: arg1 from: arg2  | tmp1 |  self deprecated: 'This method is needed only for the text rederer for PluggableTextMorph.'.  tmp1 := self allKeystrokeActions detect: [:arg3 |  arg3 shortcut = arg1 keyCharacter ] ifNone: [ nil ].  tmp1 ifNotNil: [ self announce: (GLMKeyStroke action: tmp1).        ^true ].  ^falseglmPres  glmPres ifNil: [ glmPres := GLMPharoScriptPresentation new ].  ^glmPresbindingsStrategy: arg1  bindingsStrategy := arg1menuIn: arg1 for: arg2  | tmp1 tmp2 tmp3 |  tmp1 := Dictionary new.  (arg2 allActions select: [:arg3 |  arg3 isMenu ]) do: [:arg4 |  tmp2 := arg4 category notNil ifTrue: [ tmp1 at: arg4 category ifAbsentPut: [ tmp3 := MenuMorph new.                    arg1 add: arg4 category subMenu: tmp3.                    tmp3 ] ] ifFalse: [ arg1 ].        (tmp2 add: arg4 title target: arg4 selector: #morphicActOn: argument: arg2)           enabled: (arg4 isEnabledOn: arg2);           icon: arg4 icon;           keyText: (arg4 hasShortcut ifTrue: [ arg4 shortcutAsString ] ifFalse: [ nil ]) ].  ^arg1adoptPaneColor: arg1  super adoptPaneColor: arg1.  scrollBar adoptPaneColor: arg1arrangement  ^arrangement ifNil: [ arrangement := GLMTabbedArrangement of: self ]browser: arg1  browser := arg1initializeTableMorph  | tmp1 |  tmp1 := tableModel glamourPresentation.  tableMorph := self createFastTable.  tableMorph     dataSource: tableModel;     hResizing: #spaceFill;     vResizing: #spaceFill;     cornerStyle: tableMorph preferredCornerStyle;     borderStyle: (BorderStyle inset width: 0);     dragEnabled: tmp1 allowsItemDrag;     dropEnabled: tmp1 isDropTarget;     allowsDeselection: tmp1 allowsDeselection.  self setFastTableLayoutFrame: tableMorph.  tmp1 isMultiple ifTrue: [ tableMorph beMultipleSelection ] ifFalse: [ tableMorph beSingleSelection ].  self specificTableMorphInitializiationtestComplex  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 addColumn: [:arg1 |  arg1 addRow: #second.        arg1 addRow: #third.        arg1 addRow: #fourth.        arg1 addRow: [:arg2 |  arg2 addColumn: #fifth.              arg2 addColumn: #sixth ] ].  tmp1 addColumn: #first.  self assert: tmp1 cell children size equals: 2.  self assert: tmp1 cell children first children size equals: 4.  self assert: tmp1 cell children first children last children size equals: 2addPresentation: arg1  self transmissionStrategy addPresentation: arg1shouldRootsExpand: arg1  rootsExpanded := arg1children  ^childrencheckInitializeBlockSetsTextSelectionForPresentation: arg1  | tmp1 tmp2 |  tmp1 := GLMTabulator new.  tmp1 act: [:arg2 |  arg2 entity: '2 + 3 + 4' ] icon: GLMUIThemeExtraIcons glamorousRefresh entitled: 'Change text'.  tmp1 row: #main.  tmp1 transmit     to: #main;     andShow: [:arg3 |  (arg3 perform: arg1)           title: 'Code';           initialize: [:arg4 |  arg4 selectionInterval: (1 to: 5) ] ].  window := tmp1 openOn: '1 + 2 + 3'.  tmp2 := self find: RubScrolledTextMorph in: window.  self assert: tmp2 getSelectionFromModel equals: (1 to: 5).  self assert: tmp2 selectionInterval equals: (1 to: 5).  tmp1 entity: '2 + 3 + 4'.  self assert: tmp2 getSelectionFromModel equals: (1 to: 5).  self assert: tmp2 selectionInterval equals: (1 to: 5)allowDropOnItemBlock  ^allowDropOnItemBlock ifNil: [ allowDropOnItemBlock := [ false ] ]leftPosition  ^leftPosition ifNil: [ leftPosition := 0 ]sendOneOrMultipleAs: arg1  self sendOneOrMultipleAs: arg1 updatedBy: [:arg2 |  arg2 ]wantsSteps  ^self model wantsStepsinitialize  super initialize.  self     hSpaceFill;     vShrinkWrapcount  ^countLogic ifNil: [ origin size ] ifNotNil: [ countLogic cull: origin ]privateRemoveAllBricks  self hasSubbricks ifFalse: [ ^self ].  self subbricks do: [:arg1 |  arg1 brickDoubleLink: nil.        arg1 owner: nil ].  self subbricks removeAllselectedIndex: arg1  | tmp1 |  self selectedIndex == arg1 ifTrue: [ ^self ].  tmp1 := self selectedIndex.  selectedIndex := arg1 min: self tabs size.  self updateTabs.  self changed: #selectedIndex with: tmp1testUpdateOnPortsUpdate  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := OrderedCollection with: 1 with: 2.  tmp2 := GLMPane named: 'test'.  tmp3 := GLMListPresentation new.  tmp4 := Announcer new.  tmp2 addPresentation: tmp3.  tmp3 updateOn: GLMTestAnnouncement from: [ tmp4 ].  tmp3 entity: tmp1.  tmp3 shouldValidate: true.  tmp3 registerAnnouncements.  tmp3 selection: 2.  self assert: tmp3 selection equals: 2.  tmp1 removeLast.  tmp4 announce: GLMTestAnnouncement.  self assert: tmp3 selection isNiltestPortInitializationDoesNotAffectTransmissionPort  | tmp1 tmp2 |  tmp2 := 0.  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     fromOutsidePort: #entity;     to: #one port: #entity;     andShow: [:arg1 :arg2 |  arg1 list initialize: [:arg3 |  tmp2 := tmp2 + 1.              arg3 entity: (1 to: 10) ] ].  self assert: (tmp1 panes first port: #entity) value equals: nil.  tmp1 startOn: (1 to: 42).  self assert: (tmp1 panes first port: #entity) value equals: (1 to: 42).  self assert: tmp2 equals: 1.  (tmp1 pane port: #entity) value: (1 to: 43).  self assert: (tmp1 panes first port: #entity) value equals: (1 to: 43).  self assert: tmp2 equals: 2testTwoPanesMultipleSelectionWithChange  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two;     column: #three.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list display: [:arg2 |  1 to: arg2 ] ].  tmp1 transmit     to: #two;     from: #one;     andShow: [:arg1 |  arg1 list           beMultiple;           display: [:arg2 |  arg2 * 10 to: arg2 * 10 + 4 ] ].  tmp1 transmit     to: #three;     from: #two;     andShow: [:arg1 |  arg1 text ].  window := tmp1 openOn: 4.  tmp2 := (window submorphs last submorphs at: 3) submorphs first submorphs first.  tmp3 := tmp2 scroller submorphs second.  self send: tmp2 mouseUpOnItem: tmp3.  tmp4 := (window submorphs last submorphs at: 4) submorphs first submorphs first.  tmp3 := tmp4 scroller submorphs first.  self send: tmp4 mouseUpOnItem: tmp3.  tmp3 := tmp4 scroller submorphs second.  self send: tmp4 mouseUpWithShift: true onItem: tmp3.  self assert: ((tmp1 paneNamed: #two) port: #selection) value asOrderedCollection equals: #(20 21) asOrderedCollection.  tmp2 := (window submorphs last submorphs at: 3) submorphs first submorphs first.  tmp3 := tmp2 scroller submorphs last.  self send: tmp2 mouseUpOnItem: tmp3.  tmp4 := (window submorphs last submorphs at: 4) submorphs first submorphs first.  self assert: (tmp4 model roots collect: #item) equals: #(40 41 42 43 44) asOrderedCollection.  tmp3 := tmp4 scroller submorphs first.  self send: tmp4 mouseUpOnItem: tmp3.  tmp3 := tmp4 scroller submorphs second.  self send: tmp4 mouseUpWithShift: true onItem: tmp3.  self assert: ((tmp1 paneNamed: #two) port: #selection) value asOrderedCollection equals: #(40 41) asOrderedCollectionfirstTransmission  ^firstTransmission ifNil: [ firstTransmission := GLMTransmission new ensureReplacePresentationsStrategy ]when: arg1  self condition: arg1oldPage: arg1  oldPage := arg1asGlamourOriginIdentifier  self portName ifNil: [ self portName: self class defaultOriginPortName ].  ^selfact: arg1 entitled: arg2 categorized: arg3  self addAction: (GLMGenericAction new           action: arg1;           title: arg2;           category: arg3;           yourself)printOn: arg1  super printOn: arg1.  arg1 nextPutAll: ' (pane = ' , self pane printString , ')'vAlign  ^self layout vAlignvSpaceFill  self vSpaceFill: 100newToggleButtonFor: arg1  ^GLMActionButtonBrick new     icon: GLMUIThemeExtraIcons glamorousRight;     checkedImage: GLMUIThemeExtraIcons glamorousDown;     height: [:arg2 |  arg2 icon height * 1.2 ];     width: [:arg2 |  arg2 icon width * 1.2 ];     action: [:arg2 |  arg1 toggle.        arg1 isExpanded ifTrue: [ arg2 check ] ifFalse: [ arg2 uncheck ] ]testSpawnTabulator  | tmp1 |  tmp1 := GLMTabulator new.  window := tmp1 openOn: ($a to: $d).  self assert: window model identicalTo: tmp1.  self waitUntilUIRedrawed.  self assert: window submorphs last submorphs last submorphs last submorphs last class equals: GLMPaginatedMorphTreeMorphtestChangeInnerSelection  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMExplicitBrowser new.  tmp2 := GLMExplicitBrowser new.  tmp3 := GLMListPresentation new.  tmp4 := GLMListPresentation new.  tmp1 addNewPane.  tmp1 addNewPane.  tmp2 addNewPane.  tmp1 panes first addPresentation: tmp3.  tmp1 panes last addPresentation: tmp2.  tmp2 panes first addPresentation: tmp4.  tmp1 addTransmission: (GLMTransmission new           addActiveOrigin: (tmp1 panes first port: #selection);           destination: (tmp1 panes last port: #innerSelection);           yourself).  tmp2 addTransmission: (GLMTransmission new           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: tmp2;                 name: #innerSelection;                 yourself);           destination: (tmp2 panes first port: #selection);           yourself).  tmp3 entity: #(1 2 3).  tmp4 entity: #(1 2 3).  tmp3 selection: 1.  self assert: tmp4 selection equals: 1.  tmp3 selection: 2.  self assert: tmp4 selection equals: 2isCategorized  ^self category notNilmaxWidth: arg1  maxWidth := arg1rowMorphForColumn: arg1 item: arg2 withIndex: arg3  | tmp1 |  tmp1 := OrderedCollection new.  self table columns first == arg1 ifTrue: [ self rowMorphElementsForFirstColumn: arg1 item: arg2 in: tmp1 ].  tmp1 addAll: (self rowMorphElementsForColumn: arg1 glamourColumn node: (self dataFromPresentationItem: arg2) withIndex: arg3).  ^Smalltalk ui theme newRowIn: self currentWorld for: tmp1popAndReplacePane: arg1  self pagerModel popAndReplacePane: arg1layoutSubbricks: arg1  arg1 ifNil: [ ^self ].  arg1 isBrick ifFalse: [ ^self ].  (self isClean: arg1) & (self isOppositeClean: arg1) ifFalse: [ ^self ].  (self isLayoutClean: arg1) ifTrue: [ ^self ].  (arg1 subbricks allSatisfy: [:arg2 |  arg2 isBrick ifTrue: [ (self isClean: arg2) & (self isOppositeClean: arg2) ] ifFalse: [ false ] ]) ifFalse: [ ^self ].  arg1 invalidateLayout.  self markLayoutClean: arg1.  arg1 onChildrenLayoutedbuttonPressedColor  ^self backgroundColor whitershouldAllExpand: arg1  allExpanded := arg1initialize  super initialize.  self composetextBrick: arg1  textBrick := arg1.  self textBrick     margin: #(0 3 3 3);     vShrinkWrap.  self addBrickBack: self textBrickclick: arg1  clickAction ifNil: [ ^false ].  clickAction brickValue: self withEnoughArguments: {arg1}.  ^trueopenInExternalWindowWith: arg1  ^arg1 openInExternalWindow: selftestMinAndMaxHeightTwoParentDependencies  | tmp1 tmp2 tmp3 tmp4 tmp5 |  tmp4 := 60.  tmp5 := 20.  tmp1 := self newBrickWithStaticExtent.  tmp1 useVerticalLinearLayout.  tmp2 := self newBrickWithFullFill.  tmp2 vSpaceFill: 50.  tmp2 minHeight: tmp4.  tmp3 := self newBrickWithFullFill.  tmp3 maxHeight: tmp5.  tmp1 addAllBricks: {tmp2 .         tmp3}.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 extent equals: self staticExtent.  self assert: tmp2 extent equals: self staticWidth @ tmp4.  self assert: tmp3 extent equals: self staticWidth @ tmp5displayText  ^(UITheme current newTextIn: self currentWorld text: (self containerTree glamourPresentation formatedDisplayValueOf: self item))     backgroundColor: self textBackgroundColor;     yourselfregisterEventsForPresentation: arg1  super registerEventsForPresentation: arg1.  arg1 when: GLMSelectCurrentLine send: #selectLine to: self.  arg1 when: GLMEvaluateSelection send: #actOnEvaluateSelection: to: self.  arg1 when: GLMHighlightAndEvaluate send: #actOnHighlightAndEvaluate: to: self.  arg1 when: GLMCompileText send: #actOnCompileText: to: self.  arg1 when: GLMDebugSelection send: #debugHighlightedText to: self.  arg1 when: GLMProfileSelection send: #profileHighlightedText to: self.  arg1 when: GLMPrintSelection send: #evaluateAndPopPrintHighlight to: self.  arg1 when: GLMFormatCode send: #formatSourceCode to: selftestSelectToRight  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel scrollTo: 0.0 smooth: false.  self assert: pagerModel numberOfVisiblePages equals: 2.  self assert: pagerModel selectedPageIndex equals: 1.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 2.  pagerModel selectToRight.  self assert: pagerModel selectedPageIndex equals: 2.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 2.  pagerModel selectToRight.  self assert: pagerModel selectedPageIndex equals: 3.  self assert: pagerModel firstVisiblePageIndex equals: 2.  self assert: pagerModel lastVisiblePageIndex equals: 3.  pagerModel selectToRight.  self assert: pagerModel selectedPageIndex equals: 4.  self assert: pagerModel firstVisiblePageIndex equals: 3.  self assert: pagerModel lastVisiblePageIndex equals: 4.  pagerModel selectToRight.  self assert: pagerModel selectedPageIndex equals: 5.  self assert: pagerModel firstVisiblePageIndex equals: 4.  self assert: pagerModel lastVisiblePageIndex equals: 5.  pagerModel selectToRight.  self assert: pagerModel selectedPageIndex equals: 6.  self assert: pagerModel firstVisiblePageIndex equals: 5.  self assert: pagerModel lastVisiblePageIndex equals: 6doSearchOrFilter  inputText isEmptyOrNil ifTrue: [ self resetInput ] ifFalse: [ self glamourPresentation allowsFilter ifTrue: [ self executeFilter ] ifFalse: [ self executeSearch ] ]handlesMouseWheel: arg1  ^truevelocity  ^velocity ifNil: [ velocity := self class defaultScrollVelocity ]registerAnnouncementsFor: arg1  arg1 when: GLMPaneRemoved send: #actOnPaneRemoved: to: self.  arg1 when: GLMPaneAdded send: #actOnPaneAdded: to: self.  arg1 when: GLMPaneReplaced send: #actOnPaneReplaced: to: self.  arg1 when: GLMBrowserClosed send: #actOnBrowserClosed: to: selfapproximateWidth  ^self textSize x + self hMargin + self hPaddingshouldStopStepping  ^stopStepping ifNil: [ false ]testMarkerOneStaticInParentWidth  | tmp1 tmp2 |  tmp1 := self newBrickWithFullFill.  tmp2 := self newBrickWithStaticExtent.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthDirty.  self assert: tmp2 wrappedBounds isHeightClean.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightCleanisOnChildren  ^trueisBottomOverscrolled  self isLastVisible ifFalse: [ ^false ].  self band brickBounds bottom < self height ifTrue: [ ^true ].  ^self band lastSubbrick brickBounds bottom + self band brickBounds top < self heightlabelMorph  ^labelMorphcanAnnouncePresentationsChanged: arg1  self can: arg1 announce: GLMPresentationsChangedtextSecondaryColor  ^Color whitesmalltalkClass: arg1  highlightSmalltalkContext := arg1includesPort: arg1  ^self ports includes: arg1align: arg1  position := arg1arguments: arg1  arguments := arg1testTwoShrinkInShrinkChange  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self newBrickWithFullDependsOnChildren.  tmp2 := self newBrickWithFullDependsOnChildren.  tmp3 := self newBrickWithSmallStaticExtent.  tmp4 := self newBrickWithSmallStaticExtent.  tmp2 useVerticalLinearLayout.  tmp1 addBrickBack: tmp2.  tmp2 addBrickBack: tmp3.  tmp2 addBrickBack: tmp4.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 brickBounds equals: (0 @ 0 extent: self staticSmallWidth @ (2 * self staticSmallHeight)).  self assert: tmp2 brickBounds equals: (0 @ 0 extent: self staticSmallWidth @ (2 * self staticSmallHeight)).  self assert: tmp3 brickBounds equals: (0 @ 0 extent: self staticSmallExtent).  self assert: tmp4 brickBounds equals: (0 @ self staticSmallHeight extent: self staticSmallExtent).  tmp3     width: self staticWidth;     height: self staticHeight.  self assert: tmp1 brickBounds equals: (0 @ 0 extent: self staticWidth @ (self staticHeight + self staticSmallHeight)).  self assert: tmp2 brickBounds equals: (0 @ 0 extent: self staticWidth @ (self staticHeight + self staticSmallHeight)).  self assert: tmp3 brickBounds equals: (0 @ 0 extent: self staticExtent).  self assert: tmp4 brickBounds equals: (0 @ self staticHeight extent: self staticSmallExtent)shadowColor  ^self valueOfProperty: #brickShadowColor ifAbsentPut: [ Color transparent ]announcer  ^announcer ifNil: [ announcer := GLMAnnouncer new ]paddingRight  ^self wrappedBounds paddingRightdefaultBindingsStrategy  ^[:arg1 :arg2 |  arg1 associationAt: arg2 ifAbsent: [ nil ] ]transformedDraggedItem: arg1  ^self transformDraggedItemBlock ifNotNil: [:arg2 |  arg2 glamourValue: (GLMMultiValue with: arg1 with: self) ] ifNil: [ arg1 ]scrollpaneBackgroundColor  ^self contentBackgroundColortagsFilter: arg1  tagsFilterBlock := arg1sourceContext  ^sourceLinkoffset  < return: #Point>  ^self direction * self lengthspawn: arg1 icon: arg2 entitled: arg3  self addAction: (GLMSpawnBrowserAction new           action: arg1;           icon: arg2;           title: arg3;           yourself)dragTransferType  ^#GlamourmeasureSelectionTime  ^self measureSelectionTimeForSize: 1000hasBrowser  ^self browser isNil notisEntityPort  ^self port isEntityPortsizeOf: arg1  ^(self font widthOfString: arg1) @ self font heighttagsBlock: arg1  tagsBlock := arg1testChildren  | tmp1 |  tmp1 := GLMTreePresentation new.  tmp1 transformation: [:arg1 |  (1 to: arg1) collect: #printString ].  tmp1 children: [:arg2 |  self assert: (arg2 isKindOf: String) ].  tmp1 entity: 42from: arg1 port: arg2 transformed: arg3  ^(self from: (GLMPortIdentifier pane: arg1 port: arg2)) transformation: arg3setPotentialBackgroundColorFor: arg1  arg1 colorValue ifNotNil: [ window borderColor: arg1 colorValue ]basicItems  ^self glamourPresentation displayValuepageIndex: arg1  pageIndex := arg1postCopy  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  super postCopy.  tmp3 := Dictionary new.  tmp2 := OrderedCollection new.  self panes do: [:arg1 |  tmp1 := arg1 copy.        tmp1 browser: self.        tmp2 addLast: tmp1.        tmp3 at: arg1 put: tmp1 ].  tmp5 := self pane.  tmp6 := self watcherPane.  watcherPane := nil.  pane := nil.  tmp3 at: tmp5 ifAbsentPut: [ self pane ].  tmp3 at: tmp6 ifAbsentPut: [ self watcherPane ].  self flag: 'we should also copy the values of ports from pane and watcherPane'.  transmissions := self transmissions collect: [:arg1 |  tmp4 := arg1 copy.        tmp4 changePortsAccordingToPaneMapping: tmp3 fromOldBrowser: nil toNewBrowser: self.        tmp4 ].  panes := tmp2withoutBorder  self rubricBorderWidth: 0.  self rubricBorderColor: Color transparentmorphicFont  ^self font ifNil: [ StandardFonts defaultFont ] ifNotNil: [:arg1 |  arg1 glamourValue: self entity ]hasChildren: arg1  ^self glamourPresentation hasChildrenBlock ifNil: [ arg1 children isNotEmpty ] ifNotNil: [:arg2 |  arg2 cull: arg1 data ]cellOrRow  ^cell ifNil: [ cell := GLMCustomRow new browser: self ]transmitIn: arg1  (self transmission destination hasPane and: [ self transmission destination pane presentations isEmpty ]) ifTrue: [ self transmission destination pane notingPresentationChangeDo: [ self transmission destination pane clearIn: arg1.              self transmission destination pane presentations: self presentations copy ] ]brick: arg1  brick := arg1renderWithTree: arg1  | tmp1 tmp2 |  tmp2 := GLMExpanderTreeMorphModel new glamourExpander: arg1.  tmp1 := MorphTreeMorph new.  tmp1     makeLastColumnUnbounded;     getMenuSelector: #menu:shifted:;     keystrokeActionSelector: #keyStroke:from:;     cornerStyle: tmp1 preferredCornerStyle;     borderStyle: (BorderStyle inset width: 1);     hResizing: #spaceFill;     vResizing: #spaceFill;     layoutFrame: LayoutFrame identity;     preferedPaneColor: Color white;     model: tmp2;     columns: (OrderedCollection with: (MorphTreeColumn new rowMorphGetSelector: #elementColumn)).  tmp1 vShowScrollBar.  arg1 when: GLMBrowserClosed send: #actOnBrowserClosed: to: self.  ^tmp1 buildContentsinitializeIn: arg1  self initializeNamed: self defaultName in: arg1valueOfProperty: arg1 ifAbsentPut: arg2  ^super valueOfProperty: arg1 ifAbsentPut: arg2originReferences  ^origins ifNil: [ origins := OrderedCollection new ]tree  hasStatusbar  ^statusPane notNilarguments  ^arguments ifNil: [ arguments := {} ]testCreateFinder  | tmp1 |  tmp1 := GLMCompositePresentation new.  tmp1 finder with: [:arg1 |  arg1 show: [:arg2 |  arg2 text ] ].  self assert: tmp1 size equals: 1.  self assert: (tmp1 first isKindOf: GLMFinder).  tmp1 startOn: 42.  self assert: tmp1 first panes size equals: 1.  self assert: (tmp1 first panes first port: #entity) value equals: 42matchingTag: arg1  | tmp1 |  tmp1 := self glamourPresentation tagsFor: arg1 data to: #filter.  ((arg1 children collect: [:arg2 |  self matchingTag: arg2 ]) reject: #isNil) ifNotEmpty: [:arg3 |  ^(self newStaticItemFrom: arg1)           children: arg3 asArray;           yourself ].  ^(self tagsToFilterBy allSatisfy: [:arg4 |  tmp1 includes: arg4 ]) ifFalse: [ nil ] ifTrue: [ self newStaticItemFrom: arg1 ]widthDependencies  ^widthDependencies ifNil: [ widthDependencies := OrderedCollection new ]enableElementIndex  self parameters at: 'withRowIndex' put: trueamountToShow  ^(amountToShowBlock ifNil: [ [ self defaultAmountToShow ] ]) glamourValue: self entitycustomDependencies: arg1  ^self subclassResponsibilitychangePortsAccordingToPaneMapping: arg1  self destination: ((arg1 at: self destination pane) port: self destination name)selectedColor: arg1  selectedColor := arg1tree  ^self custom: GLMTreePresentation newstrongSelection  ^(self pane port: #strongSelection) valueminimumPageNumberForScrollbar: arg1  minimumPageNumberForScrollbar := arg1actionName  ^self parameters at: 'actionName' ifAbsent: 'Validate'rowMorphElementsForColumn: arg1 node: arg2 withIndex: arg3  | tmp1 tmp2 tmp3 |  tmp2 := arg1 modifiedBlock ifNotNil: [ self editRowMorphForColumn: arg1 node: arg2 withIndex: arg3 ] ifNil: [ self viewRowMorphForColumn: arg1 node: arg2 withIndex: arg3 ].  tmp1 := OrderedCollection new     add: tmp2;     yourself.  tmp3 := self tagMorphsFrom: arg1 for: arg2.  tmp3 ifNotEmpty: [ tmp1 addAll: tmp3 ].  ^tmp1send: arg1 mouseUpOnItem: arg2  ^self send: arg1 mouseUpWithShift: false onItem: arg2isMorphBrick  ^trueselectionAct: arg1 iconName: arg2 on: arg3 entitled: arg4  self selectionAct: arg1 icon: (self iconNamed: arg2) on: arg3 entitled: arg4initializeOn: arg1 previouslyValued: arg2  self initializeOn: arg1 previouslyValued: arg2 in: OrderedCollection newrightShadowOf: arg1 on: arg2  | tmp1 tmp2 tmp3 |  tmp2 := arg1 shadowWidth.  tmp3 := arg1 brickBounds topRight + (tmp2 negated @ tmp2 / 2.0) + arg1 shadowOffset.  tmp1 := (self shadowGradientFor: arg1)     origin: tmp3;     direction: tmp2 @ 0;     yourself.  arg2 fillRectangle: (tmp3 extent: tmp2 @ (arg1 height - tmp2)) fillStyle: tmp1colorBottom  ^self color at: BottomtestAddAndUpdateBrowserManually  entity add: 4.  self assert: unupdatedListMorph model roots size equals: 3.  browser update.  self assert: unupdatedListMorph model roots size equals: 4.  entity add: 5.  browser panes first presentations update.  self assert: unupdatedListMorph model roots size equals: 5newContentBrick  ^GLMBandBrick new     hShrinkWrap;     vShrinkWrap;     yourselfscrollDown: arg1  band brickBounds corner x <= self width ifTrue: [ ^self ].  band brickBounds: (band brickBounds translateBy: (arg1 @ 0) negated).  band brickBounds corner x < self width ifTrue: [ band brickBounds: (band brickBounds translateBy: (self width - band brickBounds corner x) @ 0) ]forbiddenAnnouncements  ^forbiddenAnnouncements ifNil: [ forbiddenAnnouncements := IdentityDictionary new ]initialize  super initialize.  vResizing := #spaceFill.  hResizing := #spaceFill.  self     beTransparent;     brickRoot: GLMBrick newrow: arg1 span: arg2  ^self addRow: arg1 span: arg2validate: arg1  ^truereceive: arg1  self seenTransmissions addLast: arg1.  ^super receive: arg1testIsPaneVisible  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self assert: pagerModel numberOfVisiblePages equals: 2.  self assert: (pagerModel isPaneVisible: 1) equals: false.  self assert: (pagerModel isPaneVisible: 2) equals: false.  self assert: (pagerModel isPaneVisible: 3) equals: false.  self assert: (pagerModel isPaneVisible: 4) equals: false.  self assert: (pagerModel isPaneVisible: 5) equals: true.  self assert: (pagerModel isPaneVisible: 6) equals: truetestSymbolAsOriginIdentifier  self assert: (#pane asGlamourOriginIdentifier isKindOf: GLMPortIdentifier).  self assert: #pane asGlamourOriginIdentifier paneName equals: #pane.  self assert: #pane asGlamourOriginIdentifier portName equals: #selectionbePassive  active := falseinitialize  super initialize.  self fillStyle: (Color lightBlue alpha: 0.2)oldPane: arg1  oldPane := arg1testDynamicActionsAreUpdated  < expectedFailure>  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := 0.  tmp1 := GLMTabulator new.  tmp1 addStatusbar.  tmp1 row: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list           title: 'List 1';           dynamicActions: [:arg2 |  | tmp5 |              tmp3 := true.              tmp5 := OrderedCollection new.              tmp5 add: (GLMGenericAction new                       action: [:arg3 :arg4 |  tmp1 update ];                       icon: GLMUIThemeExtraIcons glamorousAdd;                       title: tmp4 asString;                       yourself).              tmp5 ] ].  window := tmp1 openOn: (1 to: 10).  tmp3 := false.  tmp4 := 1.  tmp1 update.  self assert: tmp3.  tmp2 := self findLast: ToolDockingBarMorph in: window.  self assert: tmp2 submorphs first model title equals: '1'origins  ^self originReferences collect: [:arg1 |  arg1 port ]addColumn: arg1  | tmp1 tmp2 |  tmp2 := arg1 isSymbol ifTrue: [ self browser addNewPaneNamed: arg1.        GLMCustomColumn new           id: arg1;           browser: self browser ] ifFalse: [ tmp1 := GLMCustomColumn new browser: self browser.        arg1 value: tmp1.        tmp1 ].  self children addLast: tmp2.  ^tmp2intercellSpacing: arg1  self parameters at: 'intercellSpacing' put: arg1buttonModel  ^buttonModelcheckbox  ^self addBrickBack: self newCheckboxhandleMouseOver: arg1  super handleMouseOver: arg1.  isResizing | (self isLeftResizingZone: arg1) | (self isRightResizingZone: arg1) ifTrue: [ self setCursorToResizing: arg1 ] ifFalse: [ self setCursorToNormal: arg1 ]task  ^task ifNil: [ task := [  ] ]contentBackgroundColor  ^Color transparentfindLastSatisfying: arg1 in: arg2  | tmp1 |  tmp1 := nil.  arg2 allMorphsDo: [:arg3 |  (arg1 value: arg3) ifTrue: [ tmp1 := arg3 ] ].  ^tmp1 ifNil: [ self fail ]oldMatchingPresentations  ^oldMatchingPresentationsscrollPane  ^scrollPanecalculateTextPosition  self textPosition = #leftCenter ifTrue: [ ^(self brickBounds origin + self textPositionVerticalCenter) truncated ].  self textPosition = #center ifTrue: [ ^(self brickBounds origin + self textPositionVerticalCenter + self textPositionHorizontalCenter) floor ].  self textPosition = #leftTop ifTrue: [ ^self brickBounds origin ].  self textPosition = #rightCenter ifTrue: [ ^(self brickBounds topRight + self textPositionVerticalCenter - (self textSize x @ 0) max: self brickBounds origin) floor ].  ^self brickBounds originsorted  sortBlock := [:arg1 :arg2 |  arg1 < arg2 ]renderGlamorouslyOn: arg1  ^arg1 renderTabulator: selfinitialize  super initialize.  transmissionStrategy := GLMNoStrategy new.  condition := truescrollbarPosition  ^self valueOfProperty: #brickScrollbarPosition ifAbsent: [ self themer scrollbarPosition ]layout  ^self layoutPropertiessize  ^self presentations sizepresentations: arg1  self notingPresentationChangeDo: [ presentations pane: nil.        presentations resetAnnouncer.        arg1 pane: self.        presentations := arg1.        presentations initializePresentation ]renderGlamorouslyOn: arg1  self registerAnnouncements.  ^self arrangement renderGlamorouslyOn: arg1testThreePanesTransmissions  | tmp1 tmp2 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two;     column: #three.  tmp1 transmit     to: #three;     from: #one;     passivelyFrom: #two;     andShow: [:arg1 |  arg1 text display: [:arg2 :arg3 |  tmp2 := arg3 ] ].  self assert: tmp1 transmissions size equals: 1.  self assert: tmp1 transmissions first passiveOrigins size equals: 1.  self assert: tmp1 transmissions first activeOrigins size equals: 1.  ((tmp1 paneNamed: #two) port: #selection) value: 15.  self assert: ((tmp1 paneNamed: #two) port: #selection) value equals: 15.  self assert: ((tmp1 paneNamed: #three) port: #entity) value isNil.  ((tmp1 paneNamed: #one) port: #selection) value: 20.  self assert: ((tmp1 paneNamed: #one) port: #selection) value equals: 20.  self assert: ((tmp1 paneNamed: #three) port: #entity) value first equals: 20.  self assert: ((tmp1 paneNamed: #three) port: #entity) value last equals: 15testCreation  self deny: GLMNoBrowser new isNil.  self assert: GLMNoBrowser new identicalTo: GLMNoBrowser newprimarySelectionInterval  ^primarySelectionIntervalremoveLastPane  self panes last unregisterFromAllAnnouncements.  ^self panes removeLasthighlightedText  ^highlightedString ifNil: [ highlightedString := '' ]testPrivateRecomputeIndexesAfterScrollAt  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 1.  pagerModel privateRecomputeIndexesAfterScrollAt: 1.0.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 1.  pagerModel privateRecomputeIndexesAfterScrollAt: 0.0.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 1.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel privateRecomputeIndexesAfterScrollAt: 0.0.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 2.  pagerModel privateRecomputeIndexesAfterScrollAt: 0.85.  self assert: pagerModel firstVisiblePageIndex equals: 4.  self assert: pagerModel lastVisiblePageIndex equals: 5.  pagerModel privateRecomputeIndexesAfterScrollAt: 0.9.  self assert: pagerModel firstVisiblePageIndex equals: 5.  self assert: pagerModel lastVisiblePageIndex equals: 6.  pagerModel privateRecomputeIndexesAfterScrollAt: 0.875.  self assert: pagerModel firstVisiblePageIndex equals: 5.  self assert: pagerModel lastVisiblePageIndex equals: 6.  pagerModel privateRecomputeIndexesAfterScrollAt: 1.0.  self assert: pagerModel firstVisiblePageIndex equals: 5.  self assert: pagerModel lastVisiblePageIndex equals: 6textColor  ^self color whitenminWidth: arg1  minWidth := arg1margin  ^self wrappedBounds margintestPanePushAnnouncement  | tmp1 tmp2 tmp3 |  tmp1 := 0.  tmp3 := self createSimplePaneMorph.  pagerModel announcer when: GLMPagePushed do: [:arg1 |  tmp1 := tmp1 + 1.        tmp2 := arg1 ].  pagerModel pushPane: tmp3 smooth: false.  self assert: tmp1 equals: 1.  self assert: tmp2 morph equals: tmp3.  tmp3 := self createSimplePaneMorph.  pagerModel pushPane: tmp3 smooth: false.  self assert: tmp1 equals: 2.  self assert: tmp2 morph equals: tmp3.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self assert: tmp1 equals: 4normalStyleFor: arg1  arg1 fillStyle: (self normalBackgroundStyleFor: arg1).  arg1 borderStyle: (self normalBorderStyleFor: arg1)align: arg1 in: arg2 anchorPoint: arg3 inContext: arg4  ^self subclassResponsibilitytranslateX: arg1  self wrappedBounds translateX: arg1testStatusbar  | tmp1 tmp2 |  tmp1 := GLMTabulator new.  tmp1 addStatusbar.  tmp1 row: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 list display: #(1 2 3) ].  window := tmp1 openOn: 42.  ((tmp1 paneNamed: #one) port: #status) value: 2.  self waitUntilUIRedrawed.  tmp2 := (window submorphs last: 2) first submorphs first.  self assert: (tmp2 isKindOf: LabelMorph)scrollbarPosition: arg1  self setProperty: #brickScrollbarPosition toValue: arg1.  self updateStyle* arg1  ^self direction * arg1ports  ^ports ifNil: [ ports := OrderedCollection new ]initialize  super initialize.  hState := GLMBrickLayoutDummState new.  vState := GLMBrickLayoutDummState newglamourValueWithArgs: arg1  ^arg1 allSatisfy: [:arg2 |  arg2 isNil ]hasPane  ^self pane notNilcheckedFocusedIcon: arg1  checkedFocusedIcon := arg1notify: arg1 at: arg2 in: arg3  | tmp1 |  tmp1 := self editor selectionInterval notEmpty ifTrue: [ self editor startIndex + arg2 - 1 ] ifFalse: [ arg2 ].  self editor selectFrom: tmp1 to: tmp1.  GLMErrorPopper installAlarm: #popupError: for: self withArguments: {arg1}updateDimension: arg1  ^self subclassResponsibilityhMargin  ^self marginLeft + self marginRightrenderDynamicPresentation: arg1  ^GLMMorphicDynamicRenderer render: arg1 from: selfhighlightSmalltalk  ^highlightSmalltalk ifNil: [ highlightSmalltalk := false ]owner  ^ownertagsBlock  ^tagsBlockisInsideOfTriggerBrick: arg1  self triggerBrick ifNil: [ ^false ] ifNotNil: [:arg2 |  arg1 withHandPositionDo: [:arg3 |  ^arg2 globalBounds containsPoint: arg3 ] ]valueFor: arg1 withIndex: arg2 in: arg3  ^self cacheAt: arg3 title for: arg1 ifAbsentPut: [ self glamourPresentation column: arg3 valueFor: (self glamourPresentation isWithElementIndex ifTrue: [ arg1 asGlamorousMultiValue , arg2 asGlamorousMultiValue ] ifFalse: [ arg1 ]) ]check: arg1  arg1 ifTrue: [ self check ] ifFalse: [ self uncheck ]renderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderFastListPresentation: selffrom: arg1  self lastTransmission addActiveOrigin: (self resolveOriginPort: arg1)terminate  process ifNotNil: [ process terminate.        process := nil ]testUnregisterAnnouncementsWhenUpdatingPane  | tmp1 tmp2 |  tmp1 := Announcer new.  tmp2 := GLMTabulator new.  tmp2 row: #one.  tmp2 transmit     to: #one;     andShow: [:arg1 |  arg1 list           updateOn: GLMTestAnnouncement from: [ tmp1 ];           display: [:arg2 |  arg2 to: 10 ] ].  tmp2 startOn: 1.  tmp2 panes first presentations first registerAnnouncements.  tmp2 unregisterFromAllAnnouncements.  self assert: tmp1 numberOfSubscriptions equals: 0dropOnItemBlock  ^dropOnItemBlockevaluateAndPopPrintHighlight  GLMPrintPopper installAlarm: #popupPrint for: selftestTreeMultipleSelectionWithCancellation  | tmp1 tmp2 tmp3 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 tree beMultiple allowDeselection ].  window := tmp1 openOn: ($a to: $d).  tmp2 := self treeVisibleItems first.  tmp3 := self treeVisibleItems last.  self send: self tree mouseUpOnItem: tmp2.  self send: self tree mouseUpWithShift: true onItem: tmp3.  self send: self tree mouseUpOnItem: tmp2.  self send: self tree mouseUpOnItem: tmp2.  self assert: (tmp1 panes first port: #selection) value isNillayoutChanged  super layoutChanged.  self morph ifNil: [ ^self ].  self isShrinking ifFalse: [ ^self ].  isLayouting ifTrue: [ ^self ].  isLayouting := true.  self changed.  self isHShrinking ifTrue: [ self width: [ self shrinkingWidth + self hPadding ] ].  self isVShrinking ifTrue: [ self height: [ self shrinkingHeight + self vPadding ] ].  self invalidateMorphBounds: true.  isLayouting := falseasFormValue  ^nilactOnKeyStroke: arg1 event: arg2 from: arg3  arg2 commandKeyPressed ifFalse: [ ^self ].  (self allKeyboardActionsFor: arg1) detect: [:arg4 |  arg4 shortcut = arg2 keyCharacter ] ifFound: [:arg5 |  arg5 actOn: arg1 ]checkboxHeight  ^18testBundleTransmissionWithTransformation  | tmp1 |  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 text ].  tmp1 transmit     from: #one transformed: [:arg2 |  arg2 + 1 ];     to: #two;     andShow: [:arg1 |  arg1 text ].  tmp1 startOn: 1.  ((tmp1 paneNamed: #one) port: #selection) value: 41.  self assert: ((tmp1 paneNamed: #two) port: #entity) value equals: 42modelFor: arg1  ^(super modelFor: arg1)     bindingsStrategy: self methodBindingsStrategy;     appendVariableBinding: arg1 variableBindings;     yourselfdimensionPolicy: arg1  ^(self stateOf: arg1) layoutPolicy: arg1 on: selfmorphicAct: arg1 icon: arg2 entitled: arg3  self addAction: (GLMMorphicAction new           action: arg1;           title: arg3;           icon: arg2;           yourself)renderBackgroundColorOf: arg1 on: arg2 in: arg3  arg2 fillRectangle: arg3 color: arg1 color.  arg1 fillStyle = Color transparent ifFalse: [ arg2 fillRectangle: arg3 fillStyle: arg1 fillStyle borderStyle: arg1 borderStyle ]isEmpty  ^self presentations isEmptyinitialize  super initialize.  self initializeInspectButton.  self initializeTextMorphseparator  ^GLMMorphic emptyMorphcolor  ^color ifNil: [ color := Array braceWith: Color transparent with: Color transparent with: Color transparent with: Color transparent ]pane: arg1  pane := arg1primarySelectionInterval  ^primarySelectionIntervalinitialize  super initialize.  anchorBrick := Morph new extent: 1 @ 1.  popupLayout := self defaultPopupLayout.  closer := self defaultCloser.  inset := self themer popupThemer inset asMargin.  spacing := self themer popupThemer spacing.  self     initializeListeners;     useVerticalLinearLayout;     vShrinkWrap;     hShrinkWrap;     enable;     initializeLayouttestMinHeightOneStatic  | tmp1 |  tmp1 := self newBrickWithSmallStaticExtent.  tmp1 minHeight: self staticHeight.  tmp1 doLayoutForce.  self assertAllSubbricksAreClean: tmp1.  self assert: tmp1 brickBounds equals: (0 @ 0 extent: self staticSmallWidth @ self staticHeight)render: arg1  | tmp1 |  tmp1 := (DiffMorph from: arg1 displayValue first to: arg1 displayValue last contextClass: arg1 contextClassValue)     layoutFrame: LayoutFrame identity;     vResizing: #spaceFill;     hResizing: #spaceFill;     yourself.  ^tmp1newLabelBrick  ^GLMLabelBrick newtext  ^self custom: GLMPhlowTextBrick newnewScrollPane  | tmp1 |  tmp1 := GLMRubTextScrollPane new.  tmp1 scrollTarget: self defaultScrollTarget.  ^tmp1isVSpaceFill  ^self vState isOnParentrubricBackgroundColor  ^self contentBackgroundColorwithSeparators  self parameters at: 'withSeparators' put: trueprivateSubbricks: arg1  submorphs := arg1addAction: arg1  self actions addLast: arg1brickBounds  ^self wrappedBounds brickBoundsmenuMorph  ^menuMorphtestDynamic  | tmp1 tmp2 |  tmp2 := GLMFinder new.  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 custom: (GLMDynamicPresentation new display: [ tmp2 ]) ].  tmp1 startOn: 42.  self assert: tmp1 panes first presentations first currentPresentation first identicalTo: tmp2.  self assert: tmp2 pane identicalTo: tmp1 panes firstwithHeight: arg1  self wrappedBounds height: arg1testTreeMultipleSelection  | tmp1 tmp2 tmp3 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 tree beMultiple ].  window := tmp1 openOn: ($a to: $d).  tmp2 := self treeVisibleItems first.  tmp3 := self treeVisibleItems last.  self send: self tree mouseUpOnItem: tmp2.  self send: self tree mouseUpWithShift: true onItem: tmp3.  self assert: (tmp1 panes first port: #selection) value notNil.  self assert: (tmp1 panes first port: #selection) value asSet equals: ($a to: $d) asSetupdateVisibleTop: arg1  | tmp1 |  tmp1 := self band hasSubbricks not ifFalse: [ self band firstSubbrick ] ifTrue: [ self addBrickBackNoLayout: (self getMorphAt: self visibleIndex recycled: (self getAndRemoveInvisibleMorph: arg1)) ].  [ tmp1 isNotNil and: [ (self isPartiallyVisible: tmp1) and: [ (self getIndex: tmp1) > 1 ] ] ] whileTrue: [ tmp1 := self addItemMorph: (self getMorphAt: (self getIndex: tmp1) - 1 recycled: (self getAndRemoveInvisibleMorph: arg1)) before: tmp1 ]brickRoot  ^brickRootselectionAct: arg1 icon: arg2 on: arg3 entitled: arg4  self addSelectionAction: (GLMGenericAction new           action: arg1;           icon: arg2;           shortcut: arg3;           title: arg4;           yourself)checkedIcon  ^checkedIconsouth  direction := Southrenderer: arg1  renderer := arg1initializeTextMorph  textMorph := RubScrolledTextMorph new.  textMorph     beReadOnly;     beWrapped;     textFont: self theme textFont;     textColor: self theme textColor;     backgroundColor: BalloonMorph balloonColor.  self     vResizing: #spaceFill;     hResizing: #spaceFill;     addMorph: textMorph fullFrame: LayoutFrame identityvalidate: arg1 on: arg2  self shouldValidate ifFalse: [ ^true ].  ^self doValidate: arg1 on: arg2beHelp  self beMode: #beHelpindex  ^indexbeUpward  self popupLayout: GLMPopupBrickUpwardLayout newactOnHighlightAndEvaluate: arg1  UIManager default defer: [ textMorph textArea handleEdit: [ textMorph textArea editor highlightEvaluateAndDo: arg1 action.              textMorph shoutStyler style: textMorph text ] ]staticExtent  ^self staticWidth @ self staticHeighthasMinDimensionRestriction: arg1  ^arg1 layout hasMinHeightpresentation: arg1  presentation := arg1text: arg1  text := arg1printOn: arg1  super printOn: arg1.  arg1     nextPut: Character space;     nextPutAll: self identityHash printString;     nextPutAll: ' ('.  port printOn: arg1.  arg1 nextPut: $)testSelectionChangeAfterPopOfLastPage  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  pagerModel pushPane: self createSimplePaneMorph smooth: false.  self assert: pagerModel selectedPageIndex equals: 1.  pagerModel selectedPageIndex: 5.  self assert: pagerModel selectedPageIndex equals: 5.  pagerModel popPane.  self assert: pagerModel selectedPageIndex equals: 4.  self assert: pagerModel size equals: 4.  self assert: pagerModel firstVisiblePageIndex equals: 3.  self assert: pagerModel lastVisiblePageIndex equals: 4.  self assert: pagerModel numberOfVisiblePages equals: 2.  pagerModel popPane.  self assert: pagerModel selectedPageIndex equals: 3.  self assert: pagerModel size equals: 3.  self assert: pagerModel firstVisiblePageIndex equals: 2.  self assert: pagerModel lastVisiblePageIndex equals: 3.  self assert: pagerModel numberOfVisiblePages equals: 2.  pagerModel popPane.  self assert: pagerModel selectedPageIndex equals: 2.  self assert: pagerModel size equals: 2.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 2.  self assert: pagerModel numberOfVisiblePages equals: 2.  pagerModel popPane.  self assert: pagerModel selectedPageIndex equals: 1.  self assert: pagerModel size equals: 1.  self assert: pagerModel firstVisiblePageIndex equals: 1.  self assert: pagerModel lastVisiblePageIndex equals: 1.  self assert: pagerModel numberOfVisiblePages equals: 2formatedDisplayValueOf: arg1  ^self cacheAt: #formatedDisplayValue for: arg1 ifAbsentPut: [ self glamourPresentation formatedDisplayValueOf: arg1 ]initialize  super initialize.  self     useVerticalLinearLayout;     titleBrick: self newTitleBrick;     hSpaceFill;     vSpaceFillhintText: arg1  hintText := arg1.  self hintBrick ifNotNil: [ self hintBrick text: self hintText ]addPresentations: arg1  arg1 do: [:arg2 |  self addPresentation: arg2 ]renderTablePresentation: arg1  ^GLMMorphicTableRenderer render: arg1 from: selftestOneFixedSizePane  | tmp1 |  tmp1 := GLMFinder new fixedSizePanes: 1.  window := tmp1 openOn: 40.  self assert: window submorphs last submorphs first submorphs first width equals: window submorphs last width.  (tmp1 panes first port: #selection) value: 42.  self assert: window submorphs last submorphs last submorphs size equals: 3.  self assert: window submorphs last submorphs last submorphs first extent equals: window submorphs last submorphs last submorphs last extent.  self assert: window submorphs last submorphs last submorphs first width equals: window submorphs last widthaddColumn: arg1 span: arg2  ^(self addColumn: arg1)     span: arg2;     size: 0testNestedBrowsersWithMultipleOrigins  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := GLMTabulator new.  tmp2 row: #inner.  tmp2 transmit     to: #inner;     andShow: [:arg1 |  arg1 text ].  tmp1 := GLMTabulator new.  tmp1     column: #one;     column: #two;     column: #three.  tmp1 transmit     to: #three;     from: #one;     from: #two;     andShow: [:arg1 |  arg1 custom: (tmp2 display: [:arg2 :arg3 |  tmp3 := arg2.                    tmp4 := arg3 ]) ].  tmp1 startOn: 1.  ((tmp1 paneNamed: #one) port: #selection) value: 1.  ((tmp1 paneNamed: #two) port: #selection) value: 2.  self assert: tmp3 equals: 1.  self assert: tmp4 equals: 2computeTagsFor: arg1 from: arg2  | tmp1 |  arg2 ifNil: [ ^OrderedCollection new ].  tmp1 := arg2 glamourValue: arg1.  ^tmp1 isString ifTrue: [ OrderedCollection with: tmp1 ] ifFalse: [ tmp1 asOrderedCollection ]hasTags  ^self tagsBlock notNilrender: arg1  | tmp1 |  tmp1 := super render: arg1.  arg1 shouldRootsExpand ifTrue: [ treeMorph expandRoots.        treeMorph makeLastColumnBounded ].  ^tmp1allowSeparators  ^self parameters at: 'withSeparators' ifAbsent: [ false ]executeFilter  self updateRootstearDown  GLMLogger reset.  super tearDowntestMarkerOneChildrenInChildrenHeight  | tmp1 tmp2 |  tmp1 := self newBrickWithFullDependsOnChildren.  tmp2 := self newBrickWithFullDependsOnChildren.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthClean.  self assert: tmp2 wrappedBounds isHeightDirty.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightDirtystart: arg1  start := arg1action  ^actionisFirstVisible  self band hasSubbricks ifFalse: [ ^true ].  ^self isVisible: self band firstSubbrickmatchingPresentations  ^cachedMatchingPresentations := presentations matchingPresentationsunregisterFromAllAnnouncements  super unregisterFromAllAnnouncements.  self presentations do: [:arg1 |  arg1 unregisterFromAllAnnouncements ]renderPane: arg1  ^GLMMorphicPaneRenderer render: arg1 from: selfinitialize  super initialize.  self     useVerticalLinearLayout;     vShrinkWraptext  ^textleft  ^GLMWestDirection uniqueInstancepane  ^panerenderGlamorouslyOn: arg1  self registerAnnouncements.  ^arg1 renderDropDownListPresentation: selfallKeyboardActionsFor: arg1  ^arg1 allActions , arg1 allSelectionActions select: [:arg2 |  arg2 hasShortcut ]scrollpane  ^scrollpanepresentation  ^GLMCompositePresentation new with: [:arg1 |  | tmp1 |        tmp1 := arg1 text.        tmp1 withLineNumbers: true.        tmp1 withAnnotation: true.        tmp1 wrapped: true.        tmp1 tabWidth: 40.        tmp1 withColumns: true ]testNoOverrideStrategy  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := GLMPane named: 'pane1'.  tmp2 := GLMPane named: 'pane2'.  tmp3 := GLMTransmission new.  tmp3 ensurePresentIfNoneStrategy.  tmp3 addActiveOrigin: (tmp1 port: #port1).  tmp3 destination: (tmp2 port: #port2).  tmp3 addPresentation: GLMPresentation new.  self assert: tmp3 presentations size equals: 1.  self assert: tmp3 destination pane identicalTo: tmp2.  self assert: tmp3 transmissionStrategy transmission identicalTo: tmp3.  (tmp1 port: #port1) value: 1.  tmp3 transmit.  self assert: tmp2 presentations size equals: 1.  tmp4 := tmp2 presentations first.  self assert: tmp3 destination pane identicalTo: tmp2.  (tmp1 port: #port1) value: 2.  tmp3 transmit.  self assert: tmp2 presentations first rootPrototype equals: tmp4 rootPrototype.  self assert: tmp2 presentations first identicalTo: tmp4inset  ^self borderWidthaddLazyPage: arg1 label: arg2 toolbar: arg3 collapsable: arg4  | tmp1 tmp2 |  tmp1 := LazyTabPage new.  tmp1     lazyPageMorphCreation: arg1;     labelMorph: arg2;     toolbar: arg3.  tmp2 := self buildLabelFrom: arg2 withAction: (arg4 ifTrue: [ GLMActionButtonBrick new                 action: [ self removePage: tmp1 ];                 icon: self theme windowCloseForm ] ifFalse: [ nil ]).  self addPage: tmp1 label: tmp2elementOrZeroAt: arg1  ^arg1 = 0 ifTrue: [ 0 ] ifFalse: [ self elementAt: arg1 ]color  ^colorisColorSet  ^self hasProperty: #brickBackgroundColorisCompleted  ^isCompleted ifNil: [ isCompleted := false ]rowHeight  ^self rowHeightBlock glamourValue: self asGlamorousMultiValue , self entity asGlamorousMultiValuepanes: arg1  ^arg1 do: [:arg2 |  self aPane: arg2 ]passivelyFrom: arg1  ^self addPassiveOrigin: (self browser resolveOriginPort: arg1)fontSize: arg1  < brickBuilderProperty: #Text name: 'Font size' as: #asInteger getter: #fontSize model: #GLMUIBuilderTextFieldProperty>  self label fontSize: arg1.  self dotsBrick fontSize: arg1dimension  ^dimensiontextMorphForModel: arg1  | tmp1 |  tmp1 := RubPluggableTextMorph new.  tmp1 styler workspace: arg1.  tmp1     on: arg1 text: #text accept: #accept:notifying: readSelection: #selection menu: #menu:shifted:;     changedAction: [:arg2 |  arg2 asString trimBoth ifNotEmpty: [ arg1 text: arg2 ] ];     onKeyStrokeSend: #keystroke:from: to: arg1;     layoutFrame: LayoutFrame identity;     vResizing: #spaceFill;     hResizing: #spaceFill;     color: self theme backgroundColor;     font: StandardFonts codeFont;     yourself.  ^tmp1testEntityPropogation  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp1 := GLMExplicitBrowser new.  tmp2 := GLMExplicitBrowser new.  tmp3 := GLMPresentation new.  tmp1 title: 'browser1'.  tmp2 title: 'browser2'.  tmp1 addNewPane name: 'pane1'.  tmp2 addNewPane name: 'innerpane 1'.  tmp5 := GLMTransmission new ensureReplacePresentationsStrategy.  tmp5 transmissionStrategy addPresentation: tmp2.  tmp1 addTransmission: (tmp5           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: tmp1;                 name: #entity;                 yourself);           destination: (tmp1 panes first port: #entity);           yourself).  tmp6 := GLMTransmission new ensureReplacePresentationsStrategy.  tmp6 transmissionStrategy addPresentation: tmp3.  tmp2 addTransmission: (tmp6           addActiveOrigin: (GLMPresentationBoundPort new                 presentation: tmp2;                 name: #entity;                 yourself);           destination: (tmp2 panes first port: #entity);           yourself).  self assert: (tmp1 pane port: #entity) value isNil.  self assert: tmp1 panes size equals: 1.  self assert: (tmp1 panes first port: #entity) value isNil.  self assertEmpty: tmp1 panes first presentations.  self assert: tmp2 panes size equals: 1.  self assert: (tmp2 panes first port: #entity) value isNil.  self assertEmpty: tmp2 panes first presentations.  (tmp1 pane port: #entity) value: 42.  self assert: (tmp1 pane port: #entity) value equals: 42.  self assert: tmp1 panes size equals: 1.  self assert: (tmp1 panes first port: #entity) value equals: 42.  self assert: tmp1 panes first presentations size equals: 1.  tmp4 := tmp1 panes first presentations first.  self assert: tmp4 rootPrototype equals: tmp2.  self assert: tmp4 pane identicalTo: tmp1 panes first.  self assert: tmp4 panes size equals: 1.  self assert: (tmp4 panes first port: #entity) value equals: 42.  self assert: tmp4 panes first presentations size equals: 1.  self assert: tmp4 panes first presentations first rootPrototype equals: tmp3lastActivePresentation: arg1  lastActivePresentation := arg1bindingThemer  ^self registerModule: GTPlayBindingDarkThemer new to: GLMActionBrickDarkThemer newrender: arg1  ^self subclassResponsibilitybeRegular  self font     forceNotBold;     forceNotItalictestUpdateBrowserTitle  browser title: 'something'.  browser update.  self assert: window label equals: 'something'noTitleIcon  titleIcon := nilexpandLevel  ^expandLevelvalue  ^valueremovePageIndex: arg1  self removePage: (self pages at: arg1)highlightSmalltalk: arg1  highlightSmalltalk := arg1layoutIn: arg1  self     markDependent: arg1;     layout: arg1toOutsidePort: arg1  ^self to: #outer -> arg1openHintPopup: arg1  self closePopup.  hintBrick := GLMPopupBrick new     beUpward;     hintText: self hintText;     titleText: self hintTitle;     perform: arg1 withEnoughArguments: {};     openOn: selftestExplicitAcceptDoesNotAffectTextPort  | tmp1 tmp2 |  tmp1 := GLMCompositePresentation new with: [:arg1 |  arg1 text display: '123' ].  window := tmp1 openOn: 4.  window position: 0 @ 0.  window extent > Display extent ifTrue: [ ^self ].  tmp2 := self find: RubScrolledTextMorph in: window.  self simulateOnlyOneClickOn: tmp2.  self simulateKeyStrokes: '4'.  self assert: (tmp1 pane port: #text) value equals: '1234'.  self simulateKeyStroke: $s meta.  self simulateKeyStrokes: '56'.  self assert: (tmp1 pane port: #text) value equals: '123456'setBoundsOf: arg1 before: arg2  | tmp1 tmp2 |  arg1 withWidth: self band width.  tmp2 := arg2 brickBounds topRight.  tmp1 := arg2 brickBounds topLeft - (0 @ arg1 height).  arg1 brickBounds: (tmp1 corner: tmp2)sendUsageData  ^self class environment at: #Privacy ifPresent: [:arg1 |  arg1 sendDiagnosticsAndUsageData ] ifAbsent: [ false ]onChildrenLayouted  self doNotUpdateDuring: [ self update ]act: arg1 on: arg2 entitled: arg3 categorized: arg4  self addAction: (GLMGenericAction new           action: arg1;           shortcut: arg2;           title: arg3;           category: arg4;           yourself)withAllPanesAndPresentationsDo: arg1  super withAllPanesAndPresentationsDo: arg1.  self panes do: [:arg2 |  arg2 withAllPanesAndPresentationsDo: arg1 ]bindingThemer  ^self registerModule: GTPlayBindingThemer new to: GLMActionBrickThemer newincludes: arg1  ^self presentations includes: arg1brickThemerChanged  self brickRoot themerChangedrowHeight  ^self rowHeightBlock glamourValue: self asGlamorousMultiValue , self entity asGlamorousMultiValuehasChildrenBlock  ^self parameters at: 'hasChildrenBlock' ifAbsent: [ nil ]isAvailableOn: arg1  ^self condition glamourValueWithArgs: (Array with: arg1 withAll: arg1 entity asGlamorousArray)toggle  self isChecked ifTrue: [ self uncheck ] ifFalse: [ self check ]initialize  super initialize.  panes := OrderedCollection new.  transmissions := OrderedCollection newfontSize  ^fontSizetextBrick: arg1  super textBrick: arg1.  self textBrick beForSmalltalkCode beReadOnlycolumn: arg1 evaluated: arg2 tags: arg3 filtered: arg4  self addColumn: (GLMTableColumn new           title: arg1;           computation: arg2;           tagsBlock: arg3;           tagsFilter: arg4)openCenteredInBrickWindow  self openCenteredInBrickWindowLabeled: selfwith: arg1  self presentationTransformation: arg1addPassiveOrigin: arg1  ^self originReferences add: (GLMOriginPortReference new           port: arg1;           bePassive;           yourself)populate: arg1 icon: arg2 on: arg3 entitled: arg4 with: arg5  self addAction: (GLMGenericAction new           action: (GLMPortUpdater new                 portSymbol: arg1;                 valueBlock: arg5;                 yourself);           shortcut: arg3;           icon: arg2;           title: arg4;           yourself)backgroundColor  ^Color r: 251 g: 201 b: 193 range: 255doNotNotifyDuring: arg1  | tmp1 |  tmp1 := self isNotificationsAllowed.  isNotificationsAllowed := false.  arg1 cull: self.  tmp1 ifTrue: [ isNotificationsAllowed := true ]testCreationWithTransmissionContext  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := OrderedCollection new.  tmp3 := GLMSimplePort new     name: #portOne;     value: 1.  tmp4 := GLMSimplePort new     name: #portTwo;     value: 2.  tmp1 := GLMPortEvent on: tmp3 previouslyValued: tmp4 in: tmp2.  self assert: tmp1 port equals: tmp3.  self assert: tmp1 oldValue equals: tmp4.  self assert: tmp1 transmissionContext equals: tmp2testInfinity  window := GLMScrollListBrick exampleInfinity.  self assert: window isSystemWindowcomposite: arg1  | tmp1 |  tmp1 := GLMCompositePresentation new.  arg1 value: tmp1.  ^self custom: tmp1isHFilling  ^hResizing = #spaceFillwhiten  ^Color brickColorRegistry at: #brickWhiten ifAbsentPut: [ Color r: 241 g: 241 b: 241 range: 255 ]testMarkerOneParentHeight  | tmp1 |  tmp1 := self newBrickWithFullFill.  self markFullyClean: tmp1.  tmp1 wrappedBounds markHeightDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp1 brickApi.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightDirtyscrollTo: arg1 smooth: arg2 callback: arg3  self privateRecomputeIndexesAfterScrollAt: arg1.  self notifyScrollPositionChanged: arg2 callback: arg3doItReceiver: arg1  doItReceiver := arg1fontSize: arg1  fontSize := arg1.  self updateFontshouldUseCache: arg1  ^self parameters at: 'shouldUseCache' put: arg1selectedImage  ^selectedImageonThemerChanged  super onThemerChanged.  self updateStylehasTags  ^self tagsBlock notNilselectionTransformation  ^self selectionTransmission transformation ifNil: [ #yourself ]newDataSourceMatching: arg1  ^(super newDataSourceMatching: arg1)     glamourPresentation: self glamourPresentation;     yourselfwidthParentDependency: arg1  | tmp1 |  arg1 owner ifNil: [ Exception signal: 'My width depends on parent, but it is nil' ].  tmp1 := arg1 owner subbricks inject: arg1 owner innerBounds width into: [:arg2 :arg3 |  arg3 isWidthClean ifTrue: [ (arg3 layout hState isOnParent not or: [ self hasWidthRestrictions: arg3 ]) ifTrue: [ arg3 layout hasMaxWidth ifFalse: [ arg2 - arg3 outerBounds width ] ifTrue: [ arg2 ] ] ifFalse: [ arg2 ] ] ifFalse: [ arg2 ] ].  ^(tmp1 * arg1 layout hPercent / 100) ceilinginteractionModel  ^selfwith: arg1  arg1 cull: selfonDrawAthensCanvas: arg1  | tmp1 |  super onDrawAthensCanvas: arg1.  tmp1 := AthensCanvasWrapper on: arg1.  self highlightedText isEmpty ifFalse: [ self calculateHighlightingBounds do: [:arg2 |  self highlightingLogic ifNil: [ tmp1 line: arg2 bottomLeft to: arg2 bottomRight width: 1 color: self textColor ] ifNotNil: [ self highlightingLogic cull: tmp1 cull: arg2 ] ] ].  arg1 pathTransform restoreAfter: [ arg1 pathTransform translateBy: self calculateTextPosition - self brickBounds origin.        arg1 pathTransform translateX: 0 Y: font getPreciseAscent.        arg1 pathTransform scaleBy: 1.0000001 @ 1.0000001.        arg1 setPaint: self textColor.        arg1 setFont: self font.        arg1 drawString: self text from: 1 to: self text size ].  tmp1 drawString: self text at: self calculateTextPosition - self brickBounds origin font: self font color: self textColortestMarkerOneStaticInStaticWidth  | tmp1 tmp2 |  tmp1 := self newBrickWithStaticExtent.  tmp2 := self newBrickWithStaticExtent.  tmp1 addBrickBack: tmp2.  self markFullyClean: tmp1.  tmp2 wrappedBounds markWidthDirty.  GLMBrickLayouter uniqueInstance markDependent: tmp2 brickApi.  self assert: tmp2 wrappedBounds isWidthDirty.  self assert: tmp2 wrappedBounds isHeightClean.  self assert: tmp1 wrappedBounds isWidthClean.  self assert: tmp1 wrappedBounds isHeightCleanannouncement  ^announcementtestTextPortIsPopulatedByDefault  < expectedFailure>  | tmp1 |  tmp1 := (GLMCompositePresentation new with: [:arg1 |  arg1 text ]) startOn: '42'.  self assert: tmp1 presentations first text equals: '42'actOnEvaluateSelection: arg1  arg1 isSyncronous ifTrue: [ textMorph textArea editor evaluateSelectionAndDo: arg1 action.        ^self ].  UIManager default defer: [ textMorph textArea editor evaluateSelectionAndDo: arg1 action ]matchingPresentations  ^self pane matchingPresentationstestMultiplePresentationsValidation  | tmp1 |  tmp1 := GLMFinder new.  tmp1 show: [:arg1 |  arg1 list.        arg1 text ].  window := tmp1 openOn: ($a to: $d).  (tmp1 panes first port: #selection) value: $z.  self assert: (tmp1 panes first port: #selection) value equals: $ztestCopy  | tmp1 tmp2 |  tmp1 := GLMTransmissionContext new.  tmp1 addPort: GLMSimplePort new.  tmp2 := tmp1 copy.  self assert: tmp2 ~~ tmp1.  self assert: tmp2 ports equals: tmp1 ports.  self assert: tmp2 ports ~~ tmp1 portsfloating  ^floating ifNil: [ floating := #none ]filterStrategy  ^filterBlockcheckedColor  ^checkedColorpopupLayout  < return: #GLMPopupBrickLayout>  self assert: [ popupLayout isNotNil ] description: [ 'Popup layout can not be nil' ].  ^popupLayouthintText  ^hintText ifNil: [ hintText := 'Need help?' ]renderExpander: arg1  ^GLMMorphicExpanderRenderer render: arg1 from: selftestStackedVerticallyWithTitle  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 column: #one.  tmp1 transmit     to: #one;     andShow: [:arg1 |  arg1 stackedVerticallyArrangement.        arg1 title: 'title'.        arg1 list title: 'list'.        arg1 text title: 'text' ].  window := tmp1 openOn: 42.  self assert: self compositeTabGroup submorphs notEmpty.  self assert: self compositeTabGroup submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph class equals: GLMPanelMorph.  self assert: self compositeTabGroup contentMorph submorphs size equals: 1.  self assert: self compositeTabGroup contentMorph submorphs first class equals: GLMPanelMorph.  self assert: self compositeTabGroup contentMorph submorphs first submorphs size equals: 2.  self assert: self compositeTabGroup contentMorph submorphs first submorphs first class equals: LazyTabGroupMorphdiminishToRight  self actualNumberOfVisiblePages = 1 ifTrue: [ ^self ].  self virtualFirstVisiblePageIndex: self firstVisiblePageIndex + 1.  self recomputeStatesetUp  super setUp.  GLMLogger instance: GLMMemoryLogger newtestOneSimpleColumnAndOneNested  | tmp1 |  tmp1 := GLMTabulator new.  tmp1 addColumn: [:arg1 |  arg1 addRow: #second.        arg1 addRow: #third.        arg1 addRow: #fourth ].  tmp1 addColumn: #first.  self assert: tmp1 cell children size equals: 2.  self assert: tmp1 cell children first children size equals: 3currentColor  ^self colorrowMorphForElement: arg1  | tmp1 |  tmp1 := OrderedCollection new.  (self iconFor: arg1) ifNotNil: [:arg2 |  tmp1 add: arg2 asMorph ].  tmp1     add: (self formatedDisplayValueOf: arg1) asMorph;     addAll: (self tagMorphsFrom: self glamourPresentation for: arg1).  ^self theme newRowIn: self currentWorld for: tmp1render: arg1  container := GLMPaneScroller new     name: 'scroller';     vResizing: #spaceFill;     hResizing: #spaceFill;     yourself.  container maxPanes: arg1 fixedSizePanes.  self registerAnnouncementsFor: arg1.  arg1 panes do: [:arg2 |  container pushPane: (self renderObject: arg2) ].  ^containeronFocusedPageChanged  self     updateButtonsFocus;     updateButtonsduration  ^duration ifNil: [ duration := 0 ]notingPresentationChangeDo: arg1  self pane notingPresentationChangeDo: arg1defaultCloser  < return: #GLMPopupBrickCloser>  ^GLMPopupBrickCloser new     predicate: GLMPopupBrickUnhoverPredicate new;     yourselfbasicElements  ^self glamourPresentation displayValuevariableBindings  ^(variableBindingsBlock glamourValue: self entity) ifNil: [ OrderedCollection new ]modified: arg1 with: arg2  arg1 modifiedBlock cull: arg2 cull: self item cull: self containerTree glamourPresentationcolorLeft: arg1  self color at: Left put: arg1executeMenuAction: arg1  self announcer announce: (GLMMenuItemSelected action: arg1)testHasTitle  | tmp1 |  tmp1 := GLMPresentation new.  self assert: tmp1 hasTitle not.  tmp1 title: 'something'.  self assert: tmp1 hasTitletitle: arg1  arg1 cull: self titletestSimpleTransmission  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp1 := GLMExplicitBrowser new.  tmp4 := GLMPresentation new.  tmp5 := GLMPresentation new.  tmp2 := tmp1 addNewPane.  tmp3 := tmp1 addNewPane.  tmp2 addPresentation: tmp4.  tmp3 addPresentation: tmp5.  tmp6 := GLMMockSimpleTransmission new     addActiveOrigin: (tmp2 port: #selection);     destination: (tmp3 port: #entity);     yourself.  tmp1 addTransmission: tmp6.  tmp7 := nil.  tmp5 when: GLMContextChanged do: [:arg1 |  tmp7 := arg1 ].  tmp4 selection: 'foo'.  self assert: tmp6 wasTransmited.  self assert: (tmp2 port: #selection) value equals: 'foo'.  self assert: (tmp3 port: #entity) value equals: 'foo'.  self assert: tmp7 notNilhState  ^GLMBrickLayoutDummState newunsubscribeDataSource: arg1  arg1 announcer unsubscribe: self.  tableMorph announcer unsubscribe: arg1disable  isEnabled := falsecurrentImage  ^self state pressed: self isPressed selected: self isSelected checked: self isChecked of: selfsend: arg1 as: arg2  (self rawSelectionTransmissionFor: arg2 ifNone: [ self addRawSelectionTransmissionTo: arg2 ]) transformation: arg1testFixedSize  window := GLMFinder new openOn: 123.  self assert: window submorphs last class equals: GLMPaneScrollershiftMenu  ^nilhasOwner  ^self owner isNotNilselectedTextBlock  ^selectedTextBlock ifNil: [ [ '' ] ]testStatusbarTransmissions  | tmp1 tmp2 |  tmp1 := GLMBrowser new.  tmp1 addStatusbar.  tmp2 := GLMPane new.  tmp1 addPane: tmp2.  self assert: tmp1 transmissions size equals: 1.  self assert: tmp1 transmissions first origins size equals: 1.  self assert: tmp1 transmissions first origins first equals: (tmp2 port: #status).  self assert: tmp1 transmissions first destination equals: (tmp1 panes first port: #entity).  self assert: (tmp1 transmissions first presentations first isKindOf: GLMLabelPresentation)owner  ^self brick owner ifNotNil: #brickApirenderCornerShadow: arg1 vector: arg2 origin: arg3 on: arg4  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 tmp7 |  tmp2 := arg1 shadowOffset.  tmp3 := arg1 shadowWidth.  (arg2 rightAngle: arg2 next) ifTrue: [ tmp6 := self shadowGradientReverseFor: arg1.        tmp4 := arg2 + arg3 + (arg2 next * tmp3) + (arg2 next left * tmp3).        tmp5 := arg2 + arg3.        tmp7 := (arg2 similar: tmp3) origin: tmp4 breadth: tmp3 ] ifFalse: [ tmp6 := self shadowGradientFor: arg1.        tmp4 := arg2 + arg3.        tmp5 := arg2 + arg3 + (arg2 left * tmp3) + (arg2 * tmp3).        tmp7 := (arg2 left similar: tmp3) origin: arg2 + arg3 breadth: tmp3 ].  tmp1 := (tmp5 - tmp4) sign * arg1 shadowInset.  (arg2 rightAngle: arg2 next) ifTrue: [ tmp4 := tmp4 - tmp1.        tmp7 := tmp7 translateBy: tmp1 negated ] ifFalse: [ tmp4 := tmp4 + tmp1.        tmp7 := tmp7 translateBy: tmp1 ].  tmp4 := tmp4 + tmp2.  tmp7 := tmp7 translateBy: tmp2.  tmp6     origin: tmp4;     direction: arg2 * tmp3;     radial: true;     yourself.  arg4 fillRectangle: tmp7 fillStyle: tmp6asGlamorousArray  ^self asArraynewRubricMorph  ^RubScrolledTextMorph newrenderFastTablePresentation: arg1  ^GLMMorphicFastTableRenderer render: arg1 from: selfposition  ^positionhasTagsFilter  ^self columns anySatisfy: [:arg1 |  arg1 hasTagsFilter ]hShrinkWrap  self hResizing: #rigid.  self width: #approximateWidthfilterBlock  ^self parameters at: 'filterBlock'testToPort  browser transmit to: #one port: #port.  self assert: browser transmissions first destination pane equals: browser panes first.  self assert: browser transmissions first destination name equals: #portselectionInterval  ^(self pane port: #selectionInterval) valuefastTree  ^self custom: GLMFastTreePresentation newallowsDeselection  ^allowsDeselection ifNil: [ allowsDeselection := false ]