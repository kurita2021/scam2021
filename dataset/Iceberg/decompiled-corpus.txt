parent  ^parentnotEmpty  ^childrenDictionary notEmptyfromText: arg1  fromText := arg1printOn: arg1  super printOn: arg1.  arg1 nextPut: $(.  self realObject printOn: arg1.  arg1 nextPut: $)titleLabel  ^titleLabelnewProjectFromCommit: arg1  self subclassResponsibilityrejectButton  ^rejectButtoninitializeRepository: arg1  repository := arg1.  self initializepushBranchToRemote: arg1 gitRemote: arg2 progress: arg3  arg2 pushWithRefSpec: (LGitRefSpec new           source: self fullname;           destination: self fullname;           yourself) pushOptions: (LGitPushOptions defaults           callbacks: ((LGitRemoteCallbacks withProvider: (IceCredentialsProvider defaultForRemote: arg1))                 pushTransferProgress: arg3;                 yourself);           yourself)initializeWidgets  super initializeWidgets.  self focusOrder add: self projectLocationrepository  ^repositorycheckoutBranchPanelsOnModel: arg1  ^#()ancestorShortIdOrOrigin  ^self entity ancestors ifNotEmpty: [ self ancestorShortId ] ifEmpty: [ 'Origin' ]repository  ^repositorypullRequest  ^pullRequestconfirmSelection  acceptBlock ifNotNil: [ acceptBlock value: selectedItems ].  self window deletedescription  ^definition nameprojectPath  | tmp1 |  tmp1 := OrderedCollection withAll: self path.  self owner ifNotNil: [ tmp1 add: self owner ].  tmp1 add: self projectName.  ^(RelativePath withAll: tmp1) pathStringacceptButton: arg1  acceptButton := arg1readParametersFromContext: arg1  super readParametersFromContext: arg1.  item := arg1 item.  tool := arg1 toolcommitId  ^[ self entity headCommit id ] on: Error do: [ nil ]obtainBaseRemote  | tmp1 |  tmp1 := self gitBase.  ^IceGitRemote url: ((tmp1 at: #git_url) copyReplaceAll: 'git://' with: 'https://')end  Job jobAnnouncer announce: (JobEnd on: self)flushForScriptGet  newNoCommit  self subclassResponsibilitybasicExecute  UIManager default informUser: self message during: actionBlock.  successAnnounceBlock ifNotNil: [ Iceberg announcer announce: successAnnounceBlock value ]createRepository  ^[ self validate.  self isCloning ifTrue: [ self cloneRepository ] ifFalse: [ self addLocalRepository ] ] on: IceDuplicatedRepository do: [:arg1 |  arg1 signal ]visitNonConflictingOperation: arg1  arg1 chosenOperation accept: selflookupCommit: arg1  ^self lookupCommit: arg1 ifAbsent: [ IceUnknownCommit new           repository: self;           id: arg1;           yourself ]headSHA  ^(self jsonAt: #head) at: #shareferenceCommit  ^referenceCommitbranchName  ^branchNamecommonAncestorWithCommit: arg1  ^self referenceCommit commonAncestorWithCommit: arg1defaultMenuItemName  ^'Convert repository sources to tonel'initialExtent  ^(600 @ 400) scaledByDisplayScaleFactoruseRemote: arg1  remote := arg1 entityaddBindingsToTable  self table bindKeyCombination: Character space toAction: [ self toggleSelectionOf: self selectedItem ]parseUrl  | tmp1 tmp2 |  (self isSSHUrl: url) ifTrue: [ ^super parseUrl ].  (self isAlternateSSHUrl: url) ifFalse: [ IceWrongUrl signal: 'Remote repository scheme not supported: ' , url ].  tmp1 := url readStream.  user := tmp1 upTo: $@.  host := (tmp1 upTo: $:) ifEmpty: [ nil ].  tmp2 := tmp1 upToEnd substrings: '/'.  path := tmp2 size >= 2 ifTrue: [ tmp2 allButLast: 2 ] ifFalse: [ #() ].  owner := tmp2 size > 1 ifTrue: [ tmp2 at: tmp2 size - 1 ] ifFalse: [ nil ].  tmp2 isEmpty ifTrue: [ IceWrongUrl signal: 'Remote repository scheme not supported: ' , url ].  projectName := self stripPossibleExtension: tmp2 lastinstall  self leftDefinition installfindOrCreatePath: arg1 on: arg2  | tmp1 tmp2 |  tmp1 := arg1 first.  tmp2 := arg2 children detect: [:arg3 |  arg3 data = tmp1 data ] ifNone: [ arg2 addChild: tmp1 toStaticItem ].  ^arg1 allButFirst ifNotEmpty: [:arg4 |  self findOrCreatePath: arg4 on: tmp2 ] ifEmpty: [ tmp2 ]titlePanel  ^titlePanelunload  self workingCopy unloadsetUpstream: arg1  self subclassResponsibilityacceptError: arg1  arg1 visitCheckoutConflict: selfreadParametersFromContext: arg1  super readParametersFromContext: arg1.  item := arg1 item.  announcer := IceTipWeakValueHolder contents: arg1 toolAnnouncerinitializeWidgets  commitTabPanel := self newTabManager.  self initializeCommitPanel.  self focusOrder add: commitTabPaneldiffPanel  ^diffPanelauthor: arg1  author := arg1modifyingPackage  ^modifyingPackagerightPanel: arg1  rightPanel := arg1first: arg1  first := arg1.  (arg1 ~= #none and: [ self last = arg1 ]) ifTrue: [ self last: #none ]initialize  super initialize.  modifiedFilePaths := Set newclassName: arg1  className := arg1initializeRepositoryList  repositoryList widget     beResizable;     addColumn: (IceTipTableColumn new           id: 'Name';           action: #descriptionWithDecoration;           width: 200;           yourself);     addColumn: (IceTipTableColumn new           id: 'Status';           action: #status;           width: 150;           yourself);     addColumn: (IceTipTableColumn new           id: 'Branch';           action: #branchName;           yourself);     dataSource: self newRepositoriesDataSource;     selectIndex: 1;     enableFilter: IceTipRepositoryFilter;     explicitFunctionisExported  ^repository isPackageExported: selfproject  self flag: #todo.  ^[ IceProjectReader readProjectFrom: self ] on: NotFound do: [ self repository fetch.        IceProjectReader readProjectFrom: self ]key  ^namecredentials: arg1  credentials := arg1.  usernameInput text: credentials username.  passphraseInput text: credentials keyPassphrase.  passphraseInput encrypted: false.  privateKeyInput location: credentials privateKey.  publicKeyInput location: credentials publicKeyinitialize  selectedItems := Set new.  super initializeloadAllPackages  self loadPackagesNamed: repository head packageNamesunloadPackageNamed: arg1  self unloadPackage: (IcePackage named: arg1 repository: repository)urlLabel: arg1  urlLabel := arg1isDirty  ^self repository workingCopy referenceCommit project ~= self readOnlyVersionpackagesList: arg1  packagesList := arg1confirmLabel: arg1  confirmLabel := arg1version: arg1  version := arg1name  ^'Empty node'removeFromPatcher: arg1  arg1 removeDefinition: self asMCDefinition= arg1  ^super = arg1 and: [ self className = arg1 className and: [ self classIsMeta = arg1 classIsMeta ] ]isCurrent  ^self == CurrentStorehasToShowWarning  ^model repository workingCopy packages isNotEmptystoreFile: arg1  storeFile := arg1history  ^historywhenTextChanged: arg1  self locationInput whenTextChanged: arg1name: arg1  name := arg1model: arg1  model ifNotNil: [ arg1 removeDependent: self ].  arg1 ifNotNil: [ arg1 addDependent: self ].  model := arg1.  self patchMorph model: arg1mergeHistoryFromAncestor: arg1  ^(IceTipCommitRangeModel repositoryModel: self repositoryModel on: arg1)     toCommit: self entity parent;     beCachedaddToPatcher: arg1  arg1 addDefinition: (MCOrganizationDefinition categories: categories)announcer  ^announcer ifNotNil: #contentsisRootDefinition  ^falsecypressMethodName: arg1  ^(MCFileTreeStCypressWriter fileNameForSelector: arg1 selector asString) , '.st'author  ^'No PR selected'removeFile: arg1  newValue: arg1  ^IceTipReadOnlyTextMorph new     hResizing: #spaceFill;     vResizing: #spaceFill;     contentsWrapped: arg1;     asSpecAdapterexecute  credential editModelClass new     credentials: credential;     credentialStore: store;     tool: tool;     openNonModalconfirmLabel  ^confirmLabelissueNumberText  ^issueNumberTextputFocusOrder  self focusOrder     add: usernameInput;     add: passwordInput;     add: storeCheckboxtitle  ^titlepatcher: arg1  patcher := arg1requestGitRepositoryInfo  | tmp1 |  tmp1 := self headRemote.  ^IceGitHubAPI new     credentials: self credentials;     getRepository: tmp1 owner project: tmp1 projectBasenamebaseBranchList  ^baseBranchListinitializeWidgets  nameLabel := self newLabel label: 'user.name'.  nameInput := self newTextInput     ghostText: 'e.g., John Doe';     autoAccept: true.  emailLabel := self newLabel label: 'user.email'.  emailInput := self newTextInput     ghostText: 'e.g., johndoe@mail.net';     autoAccept: true.  globalCheckbox := self newCheckBox     label: 'Save properties as global?';     state: false.  self focusOrder     add: nameInput;     add: emailInput;     add: globalCheckboxmarkAllPackagesAsClean  self markAsCleanPackagesThat: [:arg1 |  true ]showWidget  addButton  ^addButtonoptionB  ^optionBisPushing  ^self pushCheckbox stateisCodeSubdirectory: arg1  | tmp1 tmp2 |  tmp1 := self repository location resolve: arg1 path.  tmp2 := self repository subdirectoryReference.  ^tmp1 pathString = tmp2 pathStringremotePanel: arg1  remotePanel := arg1canRevertChanges  ^iceCommit canRevertChangesgtInspectorItemsIn: arg1  < gtInspectorPresentationOrder: 0>  ^arg1 fastTable     title: 'Packages';     display: [ self workingCopy packages ];     column: 'Name' evaluated: [:arg2 |  arg2 name ] width: 400 * World displayScaleFactor;     column: 'Status' evaluated: [:arg2 |  arg2 asString ] width: 400 * World displayScaleFactorheadCommit  ^repository headCommitdrawOn: arg1  super drawOn: arg1.  self hasBadge ifTrue: [ self drawBadgeOn: arg1 ]hasBadge  ^self badge notNilnewActionButton  ^self newButton     label: 'Merge';     icon: (self iconNamed: #merge);     help: ('Merges {1} with your image''s version.' format: {self model targetName});     action: [ self doMerge ];     yourselfisNewerThan: arg1  ^self info timeStamp > arg1 info timeStampcalculateDiff  ^commitish entity diffTo: self repository workingCopyremoveFileSystemCheckbox  ^removeFileSystemCheckboxdiff: arg1  diff := arg1pushTo: arg1  commitish  ^commitish entityisSuspended  ^suspendAllsubdirectory  ^subdirectory ifNil: [ self class defaultSubdirectory ]nameText: arg1  nameText := arg1cancelAction  accepted := true.  self window close.  LGitNoCredentialsProvided signalbasicLocation: arg1  locationInput text: arg1 pathStringreferenceCommit  ^repository head commitgetIssue: arg1 project: arg2 number: arg3  ^self get: 'repos/' , arg1 , '/' , arg2 , '/issues/' , arg3 asStringcommitsInPackageCache: arg1  commitsInPackageCache := arg1newNoCommit  ^IceNoCommit repository: selfcommits  commits ifNil: [ self lookupCommits ].  ^commitscheckoutBranch: arg1  (self branchNamed: arg1 ifAbsent: [ self createBranch: arg1 ]) checkoutdiffFor: arg1  self subclassResponsibilityrefresh  self rebuildToolbar.  self sidebarTree widget     in: [:arg1 |  arg1 selectRowIndexes: #().        arg1 dataSource           rootForItems: self model repositoryModelsByGroup;           expandRoots ];     refreshdiffFromFirstAncestor  | tmp1 tmp2 |  tmp2 := self entity ancestors ifNotEmpty: #first ifEmpty: [ IceNoCommit new ].  tmp1 := self calculateDiff: [ tmp2 diffTo: self entity ].  ^IceTipCommitDiffModel repositoryModel: self repositoryModel on: tmp1itemNameWithoutBranches  self subclassResponsibilitydelete  self repository removeTag: selfchangesFromCommit: arg1  ^self commit changesFromCommit: arg1refreshDiffLabel  diffTab label: ('{1} to {2}' format: {((self model commitModelAfter: selectedModel) ifNotNil: #shortId ifNil: [ 'origin' ]) .               selectedModel shortId})lookupCommit: arg1 ifAbsent: arg2  self subclassResponsibilitysubdirectoryLabel  ^subdirectoryLabelremoveFileDefinition: arg1  (repository location resolve: arg1 path) ensureDelete.  self addPath: arg1 pathtitle  ^'Please log in to ' , remoteHostnameisDetached  ^self subclassResponsibilitygetConfigurationGlobal: arg1  self handleLibgitError: [ | tmp1 |        tmp1 := self repositoryHandle config.        ^arg1 ifTrue: [ tmp1 openGlobal ] ifFalse: [ tmp1 ] ]initialize  super initialize.  success := falsecopyCommitIDToClipboard  < noCache>  self copyToClipboardId: self commitIdauthor  ^(self jsonAt: 'user') at: 'login'execute  ^IceGitHubViewPullRequestAction new     repository: self repository;     remote: self remote;     executeauthor  ^self info authorspacePanel: arg1  spacePanel := arg1isHead  ^self repository head = selfpath  ^pathrepositoryVersionString  ^self repository workingCopy referenceCommit idremote  ^remoteinitialize  super initialize.  fetched := falsechosenOperation  self subclassResponsibilityincludesKey: arg1  ^childrenDictionary includesKey: arg1directoryForPackage: arg1  | tmp1 |  tmp1 := self packageNamed: arg1 name.  ^self subdirectory isEmptyOrNil ifTrue: [ self directoryNameForPackage: tmp1 ] ifFalse: [ self subdirectory , '/' , (self directoryNameForPackage: tmp1) ]iceVersion  ^iceVersionnewStatusBarItemOn: arg1  self model shortCommitId ifNil: [ ^self model branchName asMorph ].  ^PanelMorph new     addMorph: self branchNameMorph;     addMorph: self shortIdMorph;     changeTableLayout;     listDirection: #rightToLeft;     hResizing: #shrinkWrap;     vResizing: #spaceFill;     yourselfcanBeBrowsed  ^self leftDefinition canBeBrowsedincomingCommitsFromBranch: arg1  ^arg1 newCommitWalk     uptoCommit: self commit;     commitsmergeablePanel: arg1  mergeablePanel := arg1hasIncomingCommitsFrom: arg1  | tmp1 tmp2 |  self tracksRemoteBranch ifFalse: [ ^false ].  tmp1 := self commits.  tmp2 := self trackedBranch commits.  ^tmp2 anySatisfy: [:arg2 |  (tmp1 includes: arg2) not ]resetToCommit: arg1  self commit: arg1chooseReference  ^(UIManager default chooseFullFileName: self chooseTitle extensions: nil path: self location preview: nil) ifNotNil: [:arg1 |  arg1 asFileReference ]addDirectory  | tmp1 tmp2 |  tmp1 := UIManager default textEntry: 'Enter the new Directory name' title: 'Create a directory'.  tmp1 ifNil: [ ^self ].  tmp2 := selectedDirectoryPath / tmp1 asResolvedBy: self model fileSystem.  tmp2 exists ifFalse: [ tmp2 createDirectory ].  sourceDirectoryTree widget dataSource updateData.  sourceDirectoryTree widget dataSource expandAll.  sourceDirectoryTree widget selectIndex: (sourceDirectoryTree widget dataSource indexOfElement: (selectedDirectoryPath asResolvedBy: self model fileSystem))createNewRepositoryNamed: arg1  | tmp1 |  self validate.  tmp1 := self locationToUse.  (tmp1 exists and: [ tmp1 hasChildren ]) ifTrue: [ IceError signal: ('{1} is not empty.' format: {tmp1 fullName}) ].  tmp1 ensureCreateDirectory.  self subdirectory ifNotEmpty: [ (tmp1 resolve: self subdirectory) ensureCreateDirectory ].  repository := IceLibgitRepository new     name: arg1;     location: tmp1;     init;     yourself.  self addProjectFileTo: repository.  self addPropertiesFileTo: repository.  repository workingCopy refreshProject.  ^repositorybranches  ^self localRepository remoteTrackedBranches select: [:arg1 |  arg1 remoteName = self name ]visitNonConflictingOperation: arg1  ^arg1 chosenOperation accept: selfsourceDirectoryLabel  ^sourceDirectoryLabelmodel  ^modelbranchModelFor: arg1  ^(IceTipBranchModel repositoryModel: self on: arg1) beCachedworkingCopy  ^workingCopyicon  ^icontoCommit: arg1  toCommit := arg1isInMerge  ^trueinitialize  super initializesetModelBeforeInitialization: arg1  self model: (IceTipWorkingCopyModel on: arg1)numberOfIncomingCommits  ^self incomingCommits sizefetch  IceRemoteNotFoundError new     remoteName: name;     signal: 'Please configure a pull remote for pulling.'toolbarName  ^self commandClass defaultToolbarItemNameinitializeCommitList  commitList widget     beResizable;     addColumn: (IceTipTableColumn new           id: 'Timestamp';           action: [:arg1 |  arg1 timeStamp asLocalStringYMDHM ];           width: 110 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Commit';           action: #shortId;           width: 60 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Author';           action: #author;           width: 150 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Description';           action: #descriptionWithDecoration;           yourself);     dataSource: self newCommitsDataSource;     selectRowIndex: 1newCommitWalk  ^repository newCommitWalk fromTag: selfincludesCommit: arg1  ^self newCommitWalk includesCommit: arg1branchesList: arg1  branchesList := arg1properties  ^Dictionary newuptoBranches: arg1  ^arg1 do: [:arg2 |  self uptoBranch: arg2 ]= arg1  ^self species = arg1 species and: [ self repository = arg1 repository and: [ self name = arg1 name ] ]projectFileReference  ^self projectFileIn: commitishselectedItems  ^selectedItemshasUnbornProject  ^self repositoryModel hasUnbornProjecticon  ^self iconNamed: #bookcollectWithPath: arg1  ^selftool  ^toolactionWidth: arg1  actionWidth := arg1setModelBeforeInitialization: arg1  model := arg1checkoutStrategyList  ^checkoutStrategyListiceLabelWidth  ^labelWidth ifNil: [ self class defaultLabelWidth ]messageText  ^messageTextnewPullRequestsDataSource  ^IceTipDataSource new     tool: self;     elements: #();     yourselfselectionChanged: arg1  commitInfoTabs selectedModel: (arg1 newSelectedRowIndexes ifNotEmpty: [:arg2 |  self commitList widget dataSource elementAt: arg2 first ] ifEmpty: [ nil ])mouseUp: arg1  ((dataSource canDisplayChildrenOf: item) and: [ item children isNotEmpty ]) ifTrue: [ item toggle ].  super mouseUp: arg1repositoryModel  ^commitish repositoryModelinitializePresenter  | tmp1 tmp2 |  super initializePresenter.  self formatList     items: self formats;     displayBlock: [:arg1 |  arg1 description ];     setSelectedItem: model repositoryProperties fileFormat.  tmp1 := (RelativePath with: model sourceDirectory) segments asOrderedCollection.  tmp2 := self sourceDirectoryTree widget dataSource rootItem children first.  tmp2 expand.  [ tmp1 isEmpty ] whileFalse: [ | tmp3 |        tmp3 := tmp1 removeFirst.        tmp2 := tmp2 children detect: [:arg2 |  (arg2 data basename ifEmpty: [ '/' ]) = tmp3 ] ifFound: [:arg3 |  arg3 expand.              arg3 ] ifNone: [ nil ] ].  tmp2 ifNotNil: [ | tmp4 |        tmp4 := self sourceDirectoryTree widget dataSource indexOfElementMatching: [:arg4 |  arg4 = tmp2 data ].        self sourceDirectoryTree widget selectIndex: tmp4 ]visitRemoteAlreadyExistError: arg1  UIManager default inform: ('Remote "{1}" already exists.' format: {arg1 remoteName})repository  ^repositoryaccept  self validate.  self doAccept.  acceptBlock ifNotNil: [ acceptBlock cull: self ]removeFromPatcher: arg1  model: arg1  model := arg1.  self refreshchangesFromCommit: arg1  ^arg1 changesFromNoCommit: selfactionColumn: arg1  arg1 id = #target_url ifTrue: [ ^self ].  ^super actionColumn: arg1setModelBeforeInitialization: arg1  model := arg1fromLabel  ^fromLabelhasConflicts  self calculateChanges.  ^mergeTree anySatisfy: [:arg1 |  arg1 isConflict ]hasIncomingCommits  ^self branch hasIncomingCommitsmodel  ^modelallPackages  ^RPackageOrganizer default packages asOrderedCollection sort: [:arg1 :arg2 |  arg1 name < arg2 name ]sourceDirectoryPath  ^RelativePath withAll: (RelativePath canonicalizeElements: ($/ split: self sourceDirectory))commitishName: arg1  branchName := arg1readParametersFromContext: arg1  super readParametersFromContext: arg1.  announcer := IceTipWeakValueHolder contents: arg1 toolAnnouncereventKeyStrokesForPreviousFocus  ^{Character tab shift asKeyCombination}visitCypressPropertiesChange: arg1  version properties addToChangeBuilder: selfremoveRemote: arg1  (self hasRemoteNamed: arg1 name) ifFalse: [ IceRemoteNotFoundError new           remoteName: arg1 name;           signal ].  self doRemoveRemote: arg1extent  ^45 @ 25getBranch: arg1 project: arg2 name: arg3  ^self get: 'repos/' , arg1 , '/' , arg2 , '/branches/' , arg3execute  (IceTipWorkingCopyBrowser on: self repositoryModel) openWithSpecisUnborn  ^falseaddComment: arg1 project: arg2 number: arg3 data: arg4  ^self post: 'repos/' , arg1 , '/' , arg2 , '/issues/' , arg3 asString , '/comments' with: [:arg5 |  arg5           entity: (ZnEntity text: (STON toJsonString: arg4));           contentType: ZnMimeType applicationJson ]repository  ^self iceVersion repositorybaseBranchName  ^baseBranchNamevalidateMakePullRequestOn: arg1  | tmp1 |  tmp1 := OrderedCollection new: 2.  arg1 isModified ifTrue: [ tmp1 add: 'Uncommited changes' ].  (arg1 outgoingCommitsTo: remote) ifNotEmpty: [:arg2 |  '{1} not published' format: {arg2 size} ].  tmp1 ifEmpty: [ ^true ].  ^UIManager default confirm: ('{1} has ongoing modifications ({2}). Do you want to continue anyway?' format: {arg1 name .               tmp1 asCommaString})firstNodeSuchThat: arg1  ^self firstNodeSuchThat: arg1 ifNone: [ NotFound signalFor: arg1 ]directory  ^selfremoveFromPatcher: arg1  arg1 removeDefinition: (MCOrganizationDefinition categories: categories)pushTo: arg1  self branch pushTo: arg1isParentOf: arg1  ^false= arg1  | tmp1 |  tmp1 := arg1 iceSemanticVersion.  ^self asInteger = tmp1 asIntegerhash  ^self contents hashsetModelBeforeInitialization: arg1  self exception: arg1defaultLocation  ^IceLibgitRepository repositoriesLocation pathStringlocation: arg1  location := arg1repository  ^commitish repositoryvisitRemoteDesynchronizedError: arg1  | tmp1 tmp2 |  tmp1 := UIManager default confirm: ('Your repository is out of sync with remote {1}. You need to pull remote changes before continue and push your changes.' format: {arg1 remote}) label: 'Remote repository out of sync!' trueChoice: 'Pull' falseChoice: 'Cancel' cancelChoice: nil default: false.  (tmp1 isNil or: [ tmp1 not ]) ifTrue: [ ^self ].  tmp2 := IcePullRemoteCommand new     repository: self repository;     remote: arg1 remote;     yourself.  [ tmp2 execute ] on: IceMergeAborted , IceShouldCommitBeforePull do: [:arg2 |  self flag: #todo.        (arg2 isKindOf: IceShouldCommitBeforePull) ifTrue: [ arg2 resume ] ifFalse: [ arg2 acceptError: self ] ].  tmp2 isSuccess ifFalse: [ ^self ].  arg1 isResumable ifTrue: [ ^arg1 resume ].  arg1 retryincludesPackageNamed: arg1  ^falsemcDefinition: arg1  mcDefinition := arg1commitList  ^commitListdiffFor: arg1  ^arg1 diffToHeadreadParametersFromContext: arg1  super readParametersFromContext: arg1.  selectedCommit := arg1 itementryRemoved: arg1  self refreshbeForCloneOfRepository: arg1  self withoutNewRepository.  self withoutLocalRepository.  repository := arg1fetchIfNeeded: arg1  (arg1 lookupCommit: SystemVersion current commitHash) isUnknownCommit ifFalse: [ ^self ].  UIManager default informUser: 'Fetching incoming commits' during: [ arg1 remotes detect: [:arg2 |  arg2 projectName = 'pharo-project' ] ifFound: [:arg2 |  arg2 fetch ] ]refreshDiffFromHead  headTabContainer updateContentsOn: selectedModelrepository: arg1  repository := arg1statusCellColumn: arg1 rowIndex: arg2  | tmp1 |  tmp1 := (self elementAt: arg2) at: arg1 id.  ^FTCellMorph new     cellInset: 5;     addMorphBack: (self iconForStatus: tmp1) asMorph;     addMorphBack: tmp1 asStringMorph;     yourselfchoosen  ^choosenicon  ^self iconNamed: #emptyPackageincludesPackageNamed: arg1  ^self includesInWorkingCopyPackageNamed: arg1initializeWidgets  super initializeWidgets.  remotePanel label: 'Push to remote:'model  ^modeltonelClassOrTraitName: arg1  ^arg1 name , (self tonelClassExtension: arg1) , '.st'subscribeToAnnouncements  model  ^modelexecute  self packageModel browseRepositoryVersionremoveBranch: arg1  | tmp1 |  tmp1 := arg1 at: 'name'.  IceGitHubAPI new     credentials: self credentials;     deleteBranch: self remote owner project: self remote projectBasename name: tmp1.  UIManager default inform: ('Branch {1} removed.' format: {tmp1})uptoVersion: arg1  arg1 hideYourselfFromCommitWalk: selfrepositoryModel: arg1  repositoryModel := arg1diff  ^diffrejectMessage: arg1  arg1 trimBoth ifNotEmpty: [ self addComment: arg1 ].  IceGitHubAPI new updatePullRequest: self owner project: self projectName number: self number data: {(#state -> #closed)} asDictionarynewActionButton  ^self newButton     label: 'Pull';     icon: (self iconNamed: #down);     help: ('Pull new commits from {1}' format: {self model remoteName});     action: [ self doPull ];     yourselfindex: arg1  index := arg1eventKeyStrokesForNextFocus  ^{Character tab asKeyCombination}toggleSelectionOf: arg1  (self isSelected: arg1) ifTrue: [ self remove: arg1 ] ifFalse: [ self add: arg1 ].  self tableRefreshexecute  (IceTipCheckoutBranchDialog on: self repositoryModel)     withTypes: (IceGitHubPlugin new checkoutBranchPanelsOnModel: self repositoryModel);     openDialogWithSpecinitializeWidgets  super initializeWidgets.  remotePanel label: 'Pull from remote:'allCredentials  self loadFromStore.  self defaultSSHCredential.  ^plainCredentials values , sshCredentials valueshost: arg1  host := arg1allSatisfy: arg1  (arg1 value: self value) ifFalse: [ ^false ].  self childrenDo: [:arg2 |  (arg2 allSatisfy: arg1) ifFalse: [ ^false ] ].  ^truecolorNotLoaded  ^Smalltalk ui theme disabledTextColorrepositoryModel  ^repositoryModelisMethodDefinition  ^falserepository: arg1  repository := arg1branchInputText: arg1  branchInputText := arg1currentCommit  ^repository workingCopy referenceCommitfillContextMenu: arg1 using: arg2  | tmp1 tmp2 tmp3 |  tmp3 := MenuMorph new.  self repository remotes do: [:arg3 |  tmp1 := self copy           remote: arg3;           yourself.        tmp2 := arg2 newForCommand: tmp1.        tmp3 add: tmp2 menuItemName target: tmp2 selector: #executeCommand ].  arg1 add: self defaultMenuItemName subMenu: tmp3isDetached  ^self workingCopyState isDetachedremoteName: arg1  remoteName := arg1label: arg1  self remoteLabel label: arg1item: arg1  item := arg1checkoutOn: arg1  arg1 loadChangesInWorkingCopy: self diff.  self repository setHead: committish.  arg1 referenceCommit: committish commit.  arg1 markAllPackagesAsCleaninitialize  items := OrderedDictionary new.  super initializepassphraseLabel  ^passphraseLabelinitializeObject: arg1  realObject := arg1.  cache := IceTipCache proxy: self.  self initializeinitializeStatusBar  statusBar     addItem: (IceTipBranchWithCommitStatusBarItem new           model: self model;           yourself);     addItem: (IceTipStatusBarTargetItem new           bePositionRight;           target: self model;           contents: #status;           yourself)repository: arg1  repository := arg1displayBlock: arg1  self listPanel displayBlock: arg1initialExtent  ^(600 @ 300) scaledByDisplayScaleFactorchangeList  ^changeListcommitCache  ^commitCache ifNil: [ commitCache := LRUCache new maximumWeight: 30 ]deselectAllChildrenOf: arg1  (self withAllChildrenOf: arg1) do: [:arg2 |  selectedItems remove: arg2 data ifAbsent: [  ] ].  self tableRefreshunregister  ^MCRepositoryGroup default removeRepository: selfbranchNamed: arg1 ifAbsent: arg2  ^self branchNamed: arg1 ifPresent: [:arg3 |  arg3 ] ifAbsent: arg2createNewBranch: arg1  self createBranch: arg1 inCommit: self headCommitexecute  self repositoryModel editreplacePanelWith: arg1  | tmp1 tmp2 |  tmp1 := self contentPanel morph.  tmp1 removeAllMorphs.  arg1 ifNil: [ ^self ].  tmp2 := arg1 buildWithSpec.  tmp1 addMorph: tmp2 fullFrame: LayoutFrame identity.  self eventKeyStrokesForNextFocus do: [:arg2 |  arg1 bindKeyCombination: arg2 toAction: [ self giveFocusToNextFrom: tmp2 ] ].  self eventKeyStrokesForPreviousFocus do: [:arg2 |  arg1 bindKeyCombination: arg2 toAction: [ self giveFocusToPreviousFrom: tmp2 ] ].  self refreshFocusOrdercloseAction  accepted ifFalse: [ self cancelAction ]url  ^urlavailableRemotes  ^availableRemotes ifNil: [ availableRemotes := self obtainAvailableRemotes ]isEmpty  ^truerefreshDiff  selectedModel ifNil: [ ^self ].  diffTab contents: (self newDiffPanelLeft: ((self model commitModelAfter: selectedModel) ifNotNil: #source ifNil: [ '' ]) right: selectedModel source)description  ^self origin url , '[' , self head description , ']'execute  | tmp1 |  mergeCommit validateCanMerge.  self isAlreadyMerged ifTrue: [ ^self ].  self resolveConflicts.  tmp1 := self updateHead.  self updateWorkingCopy.  ^tmp1description  ^leftOperation descriptionupdateDiskWorkingCopy: arg1  self subclassResponsibilitynewContext  ^self contextClass for: selfloadDefinitions  | tmp1 tmp2 tmp3 tmp4 |  definitions := OrderedCollection new.  tmp2 := (self fileName substrings: '/') allButLast asOrderedCollection.  tmp4 := tmp2 removeLast = 'class'.  tmp3 := tmp2 last copyUpToLast: $..  tmp1 := packageDirectory entryByPath: (self fileName allButFirst: packageDirectory filename size) ifAbsent: [ ^nil ].  tmp1 readStreamDo: [:arg1 |  | tmp5 tmp6 tmp7 tmp8 |        tmp5 := arg1 nextLine.        tmp6 := arg1 upToEnd.        tmp8 := self methodSelectorFor: tmp6.        tmp7 := stream author name , ' ' , stream time asDateAndTime asStringYMDHM.        definitions add: (MCMethodDefinition className: tmp3 classIsMeta: tmp4 selector: tmp8 category: tmp5 timeStamp: tmp7 source: tmp6) ]newPanelMorph  ^PanelMorph new     changeTableLayout;     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #spaceFill;     cellInset: self class defaultItemSeparation @ 0;     color: self color;     yourselfmcVersionFor: arg1  [ | tmp1 |  tmp1 := arg1 commit libgitCommit.  ^(arg1 commit readerClass on: tmp1 iceVersion: arg1) version ] on: IceMissingRepositoryEntry , LGit_GIT_ENOTFOUND do: [ IceVersionDoesNotExist new           version: arg1;           signal ]guessRegisteredRepository  ^IceRepository registry detect: [:arg1 |  arg1 name = self projectName ] ifNone: [ nil ]validate  self assert: self userName isNotEmpty description: 'You must enter a GitHub username.'.  self assert: self projectName isNotEmpty description: 'You must enter a GitHub project.'.  super validateselectedDirectoryPath  ^selectedDirectoryPathtargetVersion  ^self leftCommitreadParametersFromContext: arg1  super readParametersFromContext: arg1.  selectedCommitish := arg1 itemiceCommit: arg1  iceCommit := arg1splitRootAndSubdirectoryFromLocation  | tmp1 tmp2 |  (self location beginsWith: self class type , '://') ifFalse: [ self error: 'Invalid URL (It should be ' , self class type , '://...)' ].  tmp1 := (self location allButFirst: self class type size + 3) asFileReference.  tmp2 := #().  [ tmp1 isRoot or: [ self isGitRoot: tmp1 ] ] whileFalse: [ tmp1 asAbsolute = FileSystem workingDirectory ifFalse: [ tmp2 := tmp2 copyWithFirst: tmp1 basename ].        tmp1 := tmp1 parent ].  tmp1 isRoot ifTrue: [ self error: 'I can''t find a .git/config file.' ].  ^{tmp1 .   (String streamContents: [:arg1 |  tmp2 asStringOn: arg1 delimiter: '/' ])}isOkEnabled  self subclassResponsibilityrepository  ^repositorytitle  ^'Pushing...'repositoryHandle  < repositoryHandleAccessor>  ^localRepository repositoryHandlewithResultDo: arg1  callback := arg1gitBase  | tmp1 |  ^(tmp1 := self gitRepositoryInfo) at: #parent ifAbsent: [ tmp1 ]getRaw: arg1  ^self responseWithValidationDo: [ (self newRequestTo: arg1)           get;           response ]newDataSourceMatching: arg1  ^arg1 executeOn: selfaddPackage: arg1  self basicAddPackage: arg1.  arg1 beDirtycollectVersionsFrom: arg1 method: arg2 path: arg3  | tmp1 tmp2 tmp3 |  tmp2 := self basepathOf: arg3.  tmp1 := MCMethodDefinition new.  tmp3 := OrderedCollection new.  arg1 reverseDo: [:arg4 |  | tmp4 |        tmp4 := self definitionFor: arg2 path: tmp2 commit: arg4.        tmp1 = tmp4 ifFalse: [ tmp3 add: (IceLogVersion commit: (self repository commitFromGitCommit: arg4) definition: tmp4 asRingDefinition).              tmp1 := tmp4 ] ].  ^tmp3 reversedremoteInputText: arg1  remoteInputText := arg1baseBranches  ^baseBranches ifNil: [ baseBranches := self requestBaseBranches ]doAccept  | tmp1 |  self selectedType validate.  self isEditing ifTrue: [ self selectedType repository: repository ].  tmp1 := self selectedType newRepository.  self isEditing ifFalse: [ tmp1 register ].  acceptBlock ifNotNil: [ acceptBlock cull: self ]isMatching: arg1  ^(dataSource toString: arg1 data) beginsWith: patternnameText  ^nameTextcommitishNamed: arg1  ^self branchNamed: arg1 ifAbsent: [ self remotes size = 1 ifTrue: [ self remotes anyOne remoteBranchNamed: arg1 ifPresent: [:arg2 |  ^arg2 ] ifAbsent: [  ] ].        self revparse: arg1 ]isUndefined  ^falseerrorLabel  ^errorLabelindex: arg1  index := arg1readParametersFromContext: arg1  super readParametersFromContext: arg1.  location := arg1 item locationnewContextWithSelection: arg1  ^self newContextisPresent  ^self username isEmpty not and: [ self password isEmpty not ]rightPanel  ^rightPanelbranchName  ^branchNameuserName  ^user ifNil: [ '' ]initialExtent  ^(800 @ 600) scaledByDisplayScaleFactorbranchNamed: arg1  ^self branchNamed: arg1 ifPresent: [:arg2 |  ^arg2 ] ifAbsent: [ IceBranchNotFound new           branchName: arg1;           signal ]contents  mcDefinition ifNil: [ ^'' ].  ^self isMeta ifFalse: [ mcDefinition fullDefinitionString ] ifTrue: [ mcDefinition classDefinitionString ]previewMerge: arg1  < noCache>  (IceTipMergePreviewBrowser onBranch: self)     mergeType: arg1;     openWithSpecblock  ^[:arg1 :arg2 |  | tmp1 |  tmp1 := LGitTransferProgress fromHandle: arg1.  job ensureStarted.  job min: 0.  job max: tmp1 prim_total_objects.  job current: tmp1 prim_received_objects.  job title: ('Fetching Git objects... ({1}/{2})' format: {tmp1 prim_received_objects .               tmp1 prim_total_objects}).  job changed.  0 ]initializeProjectLocation  projectLocation := self instantiate: IceTipDirectoryPresenter.  projectLocation     label: 'Local directory';     chooseTitle: 'Choose local repository';     location: self defaultLocationexistingTagsList  ^existingTagsListdiff: arg1  diff := arg1setUpstream: arg1  repository handleLibgitError: [ | tmp1 |        tmp1 := self repositoryHandle lookupLocalBranch: self name.        tmp1 setUpstream: arg1 gitRef ]commitInfoTabs: arg1  commitInfoTabs := arg1isClean  ^self isDirty notisResolved  ^chosen notNilgtDisplayString  | tmp1 tmp2 |  tmp2 := 1000.  tmp1 := String streamContents: [:arg1 |  self gtDisplayOn: arg1 ] limitedTo: tmp2.  tmp1 size < tmp2 ifTrue: [ ^tmp1 ].  ^tmp1 , ' ...'initializeCommitPanel  commitTabPanel     addTab: (infoTab := self newInfoTab);     addTab: (headTab := self newDiffTab           label: 'Diff from HEAD';           whenTabSelected: [ self refreshDiffFromHead ];           yourself);     addTab: (ancestorTab := self newDiffTab           label: 'Diff from ancestor';           whenTabSelected: [ self refreshDiffFromAncestor ];           yourself).  headTabContainer tab: headTab.  ancestorTabContainer tab: ancestorTabdescription  ^self referenceCommit descriptionhost  ^self subclassResponsibilityname  ^nameleftContents  ^leftOperation leftContentspackages  self repository handleLibgitError: [ | tmp1 tmp2 |        tmp1 := self writerClass.        tmp2 := commitish fileSystem resolve: self sourceDirectoryPath.        tmp2 exists ifFalse: [ ^#() ].        ^tmp2 children select: [:arg1 |  tmp1 isValidPackage: arg1 ] thenCollect: [:arg1 |  | tmp3 |              tmp3 := tmp1 packageNameFromDirectory: arg1.              IcePackage named: tmp3 repository: self repository ] ]isConflict  self subclassResponsibilitynewIndex  self subclassResponsibilitynewActionButton  self subclassResponsibilityhasUpstream  ^self subclassResponsibilityisPresent  ^self username notEmpty and: [ self publicKey notEmpty and: [ self privateKey notEmpty ] ]isLoadable  ^falsebranchName  ^'{1}-{2}' format: {issueNumberText text trim .         issueText text trim}acceptError: arg1  arg1 visitMergeAborted: selfsaveIntoStore  | tmp1 |  self flag: #implementAnEncryptedVersion.  storeFile ifNotNil: [ storeFile parent ensureCreateDirectory.        storeFile resolve binaryWriteStreamDo: [:arg1 |  tmp1 := FLSerializer on: arg1.              tmp1 serialize: {plainCredentials .                     sshCredentials} ] ]baseForkList  ^baseForkListbranchModels  ^self model branchModelsaddToPatcher: arg1  self subclassResponsibilityloadedVersion: arg1  loadedVersion := arg1cypressMethodSideName: arg1  ^arg1 origin isClassSide ifTrue: [ 'class' ] ifFalse: [ 'instance' ]hash  ^self description hashprojectName  ^properties at: #projectName ifAbsent: [ self repository name ]descriptionWithDecoration  | tmp1 |  tmp1 := (', ' join: self entity tagNames) asText allBold makeAllColor: Color gray.  tmp1 ifNotEmpty: [ tmp1 := tmp1 , ' ' ].  tmp1 append: self entity comment asText.  ^tmp1pushThen: arg1  IceTipStandardAction new     repository: self entity;     message: ('Pushing to {1}' format: {self remote name});     onSuccessRepositoryModified;     onSuccess: arg1;     execute: [ self entity pushTo: self remote ]major  ^majorinitializeToolbar  addLocalRepositoryAndCheckout  | tmp1 |  tmp1 := self addLocalRepository.  tmp1 remotes detect: [:arg1 |  arg1 referencesSameRemoteLocationAs: self remoteToUse ] ifFound: [:arg2 |  tmp1 fetchFrom: arg2 ].  tmp1 switchToCommitishNamed: self commitishName.  ^tmp1isCloning  ^self remoteToUse notNilcanBeBrowsed  ^trueid  ^idcontext  ^contextnewInfoTab  ^self newTab     label: 'Info';     icon: (self iconNamed: #smallQuestion);     closeable: false;     yourselfokAction  self credentials     username: self username;     publicKey: self publicKey;     privateKey: self privateKey;     keyPassphrase: self passphrase.  credentialStore storeCredential: self credentials.  tool ifNotNil: #refresh.  accepted := true.  ^self credentialsremoveFromRepositoryCheckbox  ^removeFromRepositoryCheckboxbasicExecute  self fetchAllRemotes.  (IceTipMergeBranchDialog on: self repositoryModel)     beSwitchAndMerge;     openDialogWithSpecselectedCommit  ^self itemfinishSuccess  super finishSuccess.  Iceberg announcer announce: (IceRepositoryModified for: self repository)/ arg1  ^childrenDictionary at: arg1hash  ^self fullname hashpasswordLabel  ^passwordLabeldescription  self subclassResponsibilitycommits  | tmp1 |  tmp1 := OrderedCollection new.  self commitsDo: [:arg1 |  tmp1 add: arg1 ].  ^tmp1commits  ^self branch commitsbranchName: arg1  branchName := arg1path: arg1  path := arg1iconPanel: arg1  iconPanel := arg1subdirectoryPath  ^RelativePath withAll: (RelativePath canonicalizeElements: ($/ split: self subdirectory))selectMatching: arg1 from: arg2  arg1 = #modified ifTrue: [ ^arg2 select: #isModified ].  arg1 = #notLoaded ifTrue: [ ^arg2 reject: #isLoaded ].  self error: 'This sorting is not accepted: ' , arg1cellColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp1 := self elementAt: arg2.  tmp2 := FTCellMorph new     cellInset: 5;     yourself.  tmp2 addMorphBack: (self newSelectionMorphFor: tmp1).  (arg1 readIcon: tmp1) ifNotNil: [:arg3 |  tmp2 addMorphBack: arg3 asMorph ].  tmp2 addMorphBack: (arg1 read: tmp1) asMorph asReadOnlyMorph.  ^tmp2switchAndMergeWorkingCopy  self switch.  self flag: #todo.  self repository workingCopy referenceCommit merge.  self commit mergevisitEmptyNode: arg1  action  ^actionreset  self repositoryModel resetrepositoryDirectory  ^repositoryDirectorylookup: arg1 in: arg2 ifAbsent: arg3  self loadFromStore.  ^arg2 at: arg1 ifAbsent: arg3fromCommit: arg1  self subclassResponsibilityloadVersionInfo  ^info := self iceVersion inforemoveDirectoryButton  ^removeDirectoryButtonselectedFileFormat  ^formatList selectedItemprepareItemToAdd: arg1  ^arg1     vResizing: #spaceFill;     yourselfcolumnTitleFor: arg1  ^arg1 id capitalizedmaxNumber: arg1  maxNumber := arg1selectAll  self elements do: [:arg1 |  selectedItems add: arg1 ].  self tableRefreshformatLabel: arg1  formatLabel := arg1shortId  ^self commit shortIdrightContents  self subclassResponsibilitymergeWithLeftModification: arg1  self shouldNotImplementisResumable  ^truebadge: arg1  badge := arg1= arg1  ^(self basicEqualsTo: arg1) and: [ self children asSet = arg1 children asSet ]visitEEOF: arg1  arg1 messageText trimmed = 'ERROR: Repository not found.' ifTrue: [ IceCloneRemoteNotFound signalFor: context url ].  ^self visitGenericError: arg1mcWorkingCopy  ^self isLoaded ifTrue: [ self mcPackage workingCopy ]removePackage: arg1  repository workingCopy unloadPackageNamed: arg1 namecheckoutStrategyList: arg1  checkoutStrategyList := arg1newCommitsDataSource  ^IceTipDataSource new     tool: self;     elements: #();     yourselfmessageText  ^'Tag {1} already exists' format: {tagName}wrappedException: arg1  wrappedException := arg1datetime  ^self entity datetimeappliesToRepository: arg1  ^falsename  ^nameprojectName  ^projectNamecontentPanel  ^contentPanelinitialize  super initializeinitialExtent  ^(350 @ (self class inputTextHeight * 7 + self class buttonHeight)) scaledByDisplayScaleFactorrepositoryWasCreated: arg1  ^self plugins do: [:arg2 |  arg2 repositoryWasCreated: arg1 ]contextClass  ^IceTipVersionHistoryContextlast  ^lastbranchNamed: arg1 ifPresent: arg2 ifAbsent: arg3  self subclassResponsibilityremovePlainTextCredential: arg1  plainCredentials removeKey: arg1 hostowner: arg1  owner := arg1execute  self packageModel reload.  Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity)sourceDirectory: arg1  properties at: 'srcDirectory' put: arg1inverse  ^selfitem  ^itemisDetached  ^falsevisitImageChange: arg1  | tmp1 |  tmp1 := IceMCPackageImporter new     package: arg1 package;     version: version;     yourself.  ^tmp1 importOn: (self ensureSourceCodeParentNodeIn: parentNode)recordChoiceProject: arg1 optionA: arg2 optionB: arg3 ifAbsentAnswer: arg4  ^choices detect: [:arg5 |  arg5 projectName = arg1 and: [ arg5 isChoiceBetween: arg2 and: arg3 ] ] ifFound: [:arg6 |  arg6 choosen ] ifNone: [ | tmp1 |        tmp1 := arg4 value.        tmp1 ifNotNil: [ self recordChoice: (IceMetacelloLoadChoice new                       projectName: arg1;                       optionA: arg2;                       optionB: arg3;                       choosen: tmp1;                       yourself) ].        tmp1 ]beSuccess  success := truepullRequest: arg1  pullRequest := arg1.  urlText text: self pullRequest url.  authorText text: self pullRequest author.  fromText text: self pullRequest headLabel.  toText text: self pullRequest baseLabel.  bodyText text: self pullRequest body.  self retrieveStatuses.  self retrieveDetailmodel  ^modelinitializeWidgets  self initializeWidgetsContents.  self initializeFocusOrderdescriptionWithDecoration  ^self entity nameshortIdMorph  ^(IceTipURLLabelMorph contents: model shortCommitId)     setBalloonText: 'Copy the commit ID to the clipboard';     onClick: [ self model copyCommitIDToClipboard ];     yourselfinitializeTypeList  typeList widget     addColumn: (IceTipTableColumn newAction: #title icon: #icon);     dataSource: self newTypeListDataSource;     onAnnouncement: FTSelectionChanged send: #selectionChanged: to: selfmodel  ^modelrefresh  self refreshCommitsdescription  ^'{1} at {2}' format: {self author .         self datetime asLocalStringYMDHM}removeFrom: arg1  arg1 removeFile: selfmergeAction  ^mergeAction ifNil: [ mergeAction := IceMerge new           repository: self repositoryModel entity;           mergeCommit: commitish entity commit;           yourself ]localBranchNames  ^self localBranches collect: #namehasElements  ^self elements notEmptykey  ^definition keycomment  ^commentbranchName  ^branchNamemodel: arg1  super model: arg1.  self refreshchooseReference  ^UIManager default chooseDirectory: self chooseTitle path: self locationisMergeCommit  ^self ancestors size > 1diffToWorkingCopyForPackage: arg1  ^self diffToWorkingCopyForPackages: {arg1}repository  ^source repositoryisFileDefinition  ^falseerrorToString: arg1  (arg1 at: #code) = 'custom' ifTrue: [ ^self customError: arg1 ].  (arg1 at: #code) = 'invalid' ifTrue: [ ^self invalidError: arg1 ].  ^self unknownError: arg1icon  ^self iconNamed: #changeUpdateexecute  item ifNil: [ ^self ].  item value definition browsenewPackagesDataSource  ^IceTipDataSource new     tool: self;     elements: self model packageModels;     yourselfgitRef  ^self idnewPackagesListDataSource  | tmp1 |  ^(tmp1 := IceTipSelectingDataSource new)     tool: self;     elements: self allPackagesNotRegistered;     onSelectionChangedBlock: [:arg1 :arg2 |  arg2 ifTrue: [ acceptButton enable ] ifFalse: [ tmp1 selectedItems ifEmpty: [ acceptButton disable ] ] ];     yourselfpackage: arg1  package := arg1isAncestorOf: arg1  ^arg1 isParentOf: selfexecute  (IceTipCreateTagPanel on: selectedCommitish) openDialogWithSpeccollect: arg1  | tmp1 |  tmp1 := self class value: (arg1 value: self value).  self nodesDo: [:arg2 |  tmp1 addNode: (arg2 collect: arg1) ].  ^tmp1doEnsureProject  ensureProjectFile ifFalse: [ ^self ].  self repository project isUnborn ifFalse: [ ^self ].  self repository workingCopy project: (IceBasicProject onRepository: self repository withSourceDirectory: self subdirectory).  self repository workingCopy refreshRepositoryProperties.  self repository workingCopy properties properties at: #format ifAbsent: [ self repository workingCopy properties fileFormat: (TIceRepositoryWriter users detect: #isLegacyDefault ifNone: [ Smalltalk at: #IceLibgitFiletreeWriter ]) ].  self repository workingCopy refreshPackagesdefaultMenuItemName  ^remote ifNotNil: [ remote name , ' (' , remote url , ')' ] ifNil: [ self itemNameWithoutBranches ]commitish  ^commitishavailableRepairOptions  < noCache>  ^IceTipRepairAction allAvailableFor: self entitytimeStamp  ^self commit timeStampreadParametersFromContext: arg1  super readParametersFromContext: arg1.  tagModel := arg1 itemheadRemote: arg1  headRemote := arg1get: arg1  ^self jsonContentsWithValidationDo: [ (self newRequestTo: arg1)           get;           response ]lookupCommits  | tmp1 tmp2 |  tmp1 := Dictionary new.  tmp2 := OrderedCollection new.  commitish commitsDo: [:arg1 |  | tmp3 |        tmp3 := IceHistoryCommit commit: arg1 history: self.        tmp2 add: tmp3.        tmp1 at: arg1 id put: tmp3 ].  commitDictionary := tmp1.  commits := tmp2host  ^hostinitializeList: arg1 item: arg2  list := arg1.  item := arg2.  self initializedoAccept  self subclassResponsibilityrefreshWhenRepository: arg1  (self model isModelOf: arg1 repository) ifFalse: [ ^self ].  self model reset.  self refreshinitializeRepositoryModel: arg1  repositoryModel := arg1.  self initializegetPullRequests: arg1 project: arg2  ^self getPaginated: 'repos/' , arg1 , '/' , arg2 , '/pulls'createPullRequest  ^IceGitHubPullRequestDefinition new     credentials: self credentials;     title: self titlePanel text trim;     headRemote: self headForkList selectedItem;     headBranchName: self headBranchList selectedItem;     baseRemote: self baseForkList selectedItem;     baseBranchName: self baseBranchList selectedItem;     body: self bodyPanel text asString trim;     yourselfonAccept: arg1  acceptCallback := arg1loadVersionInfo  ^info := self iceVersion infochooseRemote  ^item value selectLeftchooseReference  self subclassResponsibilityselectFirst  typeList widget selectIndex: 1.  self basicSelectionChanged: self allTypes firstbodyLabel  ^bodyLabeldefaultSSHCredential  ^sshCredentials at: #* ifAbsentPut: [ IceSshCredentials new           host: #*;           yourself ]initializeWidgets  self initializeProjectLocation.  self initializeSpacePanel.  userNameLabel := self newLabel label: 'Owner name'.  userNameInputText := self newTextInput     autoAccept: true;     ghostText: 'e.g., JohnDoe'.  projectNameLabel := self newLabel label: 'Project name'.  projectNameInputText := self newTextInput     autoAccept: true;     ghostText: 'e.g., MyProject'.  protocolLabel := self newLabel label: 'Protocol'.  protocolDropList := self newDropList.  userNameInputText whenTextChanged: [:arg1 |  projectLocation appendPath: self projectAsPathToAppend ].  projectNameInputText whenTextChanged: [:arg1 |  projectLocation appendPath: self projectAsPathToAppend ].  protocolDropList     items: IceUrlProtocol allSubclasses;     displayBlock: [:arg2 |  arg2 description ];     setSelectedItem: IceUrlProtocol defaultProtocol.  self focusOrder     add: self userNameInputText;     add: self projectNameInputText;     add: self projectLocation;     add: self protocolDropListcancelAction  path: arg1  path := arg1commentPanel  ^commentPanelinitializeCommitList  commitList widget     beResizable;     addColumn: (IceTipTableColumn new           id: 'Timestamp';           action: [:arg1 |  arg1 timeStamp asLocalStringYMDHM ];           width: 110 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Commit';           action: #shortId;           width: 60 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Author';           action: #author;           width: 150 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Description';           action: #descriptionWithDecoration;           yourself);     dataSource: self newCommitsDataSource;     selectIndex: 1packageModel: arg1  packageModel := arg1hash  ^self id hashstrongSelection: arg1  self viewPullRequest: (self pullRequests widget dataSource elementAt: arg1 selectedRowIndex)fillContextMenu: arg1 using: arg2  arg1 addLineposition: arg1  position := arg1projectFilePath  ^RelativePath with: '.project'loadedPackages  ^self packages select: #isLoadedisNoCommit  ^falseprintOn: arg1  arg1     nextPutAll: self class name;     nextPut: $(.  self printPathOn: arg1.  arg1 nextPut: $)checkout: arg1  arg1 checkoutOn: selftitle  ^'Add new Plain Text Credential'setModelBeforeInitialization: arg1  repositoryModel := arg1initializeFocusOrder  self focusOrder add: self branchInputTextreset  cache resetfetchBranch: arg1  self subclassResponsibilityaddBindingsToTable  self table bindKeyCombination: Character space toAction: [ self toggleSelectionOf: self selectedItem ]onChoose  ^chooseBlockname  ^self entity nameremovalColor  ^super additionColorswitch  self checkout: IceCheckoutDoNotLoadPackages newremove: arg1  self selectedItems remove: arg1.  self onSelectionChangedBlock ifNotNil: [:arg2 |  arg2 cull: arg1 cull: false ]isRepositoryDetached  ^repositoryDetachedisCommitMerged: arg1  ^arg1 isAncestorOf: self referenceCommitmessageLabel  ^messageLabelpluginManager  ^IcePluginManager managerFor: selfsubdirectoryPath  self subclassResponsibilitymessageText  ^messageText ifNil: [ self defaultMessageText format: {super messageText} ]readParametersFromContext: arg1  super readParametersFromContext: arg1.  item := arg1 itemexecute  useAllIncomingVersion  self model mergeTree do: [:arg1 |  arg1 isConflict ifTrue: [ arg1 selectRight ] ].  self changed: #changes.  self updateSourceextractProjectName: arg1  ^(IceGitRemote url: arg1) projectNameinitialExtent  ^(500 @ 250) scaledByDisplayScaleFactorinitializeDiffPanel  diffPanel showOptions: falseupstreamForBranch: arg1 backend: arg2  ^nilhasOutgoingCommits  ^falserepositoryModel: arg1  repositoryModel := arg1delete: arg1  ^self contentsWithValidationDo: [ (self newRequestTo: arg1)           delete;           response ]newWidgetLabel: arg1 value: arg2 do: arg3  | tmp1 tmp2 tmp3 |  tmp1 := items indexOfKey: arg1.  tmp2 := ('label_' , tmp1 asString) asSymbol.  tmp3 := ('value_' , tmp1 asString) asSymbol.  widgets at: tmp2 put: (self newLabel: arg1).  widgets at: tmp3 put: (self newValue: arg2).  arg3 value: tmp2 value: tmp3value: arg1  value := arg1acceptMessage: arg1 type: arg2  IceGitHubAPI new acceptPullRequest: self owner project: self projectName number: self number data: {(#commit_title -> (arg1 lines ifNotEmpty: [:arg3 |  arg3 first trimBoth ] ifEmpty: [ '' ])) .         (#commit_message -> (arg1 lines ifNotEmpty: [:arg4 |  (arg4 allButFirst joinUsing: String lf) trimBoth ] ifEmpty: [ '' ])) .         (#sha -> self headSHA) .         (#merge_method -> arg2)} asDictionarypackage: arg1  package := arg1sshCredentialsClass  ^self class sshCredentialsClassexecute  (IceTipRepositoryBrowser on: self repositoryModel) openWithSpecinitialize  super initialize.  started := falseworkingCopies  ^self loadedPackages collect: #workingCopyid  ^idnewDiffTab  ^self newTab     label: 'Diff';     icon: (self iconNamed: #diff);     closeable: false;     yourselftextField: arg1  textField := arg1.  textField whenTextChanged: [:arg2 |  self textUpdated: arg2 ]addAction: arg1  actions add: arg1.  self refreshcanBeBrowsed  ^RPackage organizer includesPackageNamed: nameexecute  (IceGitHubOpenOnGithubAction organisation: self remote owner projectName: self remote projectName) executefromPackage: arg1 message: arg2  name := '{1}-{2}.{3}' format: {arg1 name .         Author fullName .         'unknown'}.  package := arg1.  message := arg2.  id := UUID newconfirmLabel  ^confirmLabelmcRepositoryClass  ^MCGitRemoteRepositoryallTypes  ^self subclassResponsibilitycomposeUrlWithHost: arg1 repositoryPath: arg2  ^'git@{1}:{2}.git' format: {arg1 .         arg2}toggleSelectionOf: arg1  (self isSelected: arg1 data) ifTrue: [ self deselectAllChildrenOf: arg1 ] ifFalse: [ self selectAllChildrenOf: arg1 ].  self tableRefreshrepositoryHandle  < repositoryHandleAccessor>  ^repository repositoryHandledefaultAction  ^self useIncomingiceVersion  ^iceVersionisEmpty  ^childrenDictionary isEmptyremoteBranchNamed: arg1 ifPresent: arg2 ifAbsent: arg3  self subclassResponsibilitytoString: arg1  ^self format ifNotNil: [ self format value: arg1 ] ifNil: [ arg1 ]newDirectoryDataSource  ^IceTipDirectoryDataSource new     tool: self;     directory: self model fileSystem;     yourselfcommitButton  ^commitButtonisCodeMissing  ^self subdirectory isEmptyOrNil ifTrue: [ self isMissing ] ifFalse: [ (self repositoryDirectory / self subdirectory) exists not ]storeInto: arg1 forHostname: arg2  host := arg2.  arg1 storeSshCredential: self forHostname: arg2removeCredential: arg1  arg1 removeFrom: self.  self saveIntoStoreusername  ^usernameInput textisChoiceBetween: arg1 and: arg2  ^self optionA = arg1 and: [ self optionB = arg2 ]remoteName  ^(self fullname substrings: '/') thirdfirstNodeSuchThat: arg1  ^self firstNodeSuchThat: arg1 ifNone: [ NotFound signalFor: arg1 ]execute  self packageModel load.  Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity)inverse  ^IceAddition definition: definitionaction  ^actioncanBeLoaded: arg1  ^(super canBeLoaded: arg1) and: [ arg1 filename = self fileName ]commit  repository handleLibgitError: [ | tmp1 tmp2 |        tmp2 := (self repositoryHandle lookupRemoteBranch: self name) targetId.        tmp1 := LGitCommit of: self repositoryHandle fromId: tmp2.        ^self repository commitFromGitCommit: tmp1 ]canBrowseReferences  ^falseclear  commentText text: ''newContextWithSelection: arg1  ^self newContextsourceDirectoryReference  ^commitish fileSystem resolve: self sourceDirectoryPathspacePanel: arg1  spacePanel := arg1unknownError: arg1  ^String streamContents: [:arg2 |  (arg1 associations sorted: [:arg3 :arg4 |  arg3 key < arg4 key ]) do: [:arg5 |  arg2 << arg5 key << ': ' << arg5 value ] separatedBy: [ arg2 << ', ' ] ]toolbar: arg1  toolbar := arg1initialize  super initialize.  loader := MCPackageLoader newreferenceCommits  ^self workingCopy referenceCommitreaderClass  ^self commit readerClasskeepCurrentVersion  self selectedChangeWrapper chooseLocal.  self changed: #changes.  self updateSourceisModified  ^self project isDirty or: [ self loadedPackages anySatisfy: [:arg1 |  arg1 isDirty ] ]model: arg1  model := arg1notEmpty  ^falsehost  ^hostcheckoutAllPackages  self branch checkoutAllPackagesmergeOn: arg1 then: arg2  ^arg1 mergeThen: arg2repository: arg1  repository := arg1mergeWithLeftAddition: arg1  self shouldNotImplementsetHead: arg1  self subclassResponsibilityspacePanel  ^spacePanelbaseRemote  ^baseRemote ifNil: [ baseRemote := self obtainBaseRemote ]handlesMouseOver: arg1  ^trueprojectName  ^(self location substrings: '/') third copyUpTo: $:newEmptyTab  ^self newTab     label: 'Info';     icon: (self iconNamed: #smallQuestion);     closeable: false;     contents: '(No commit selected)' asMorph;     yourselfavailableBranchNames  ^availableBranchNames ifNil: [ availableBranchNames := self obtainAvailableBranchNames ]tableRefresh  self table ifNil: [ ^self ].  ^super tableRefreshrefresh  | tmp1 |  tmp1 := self model commitModels.  commitList widget     in: [:arg1 |  arg1 dataSource elements: tmp1 ];     refresh.  commitInfoTabs selectedModel: (tmp1 ifNotEmpty: #first ifEmpty: [ nil ])visitAddition: arg1  arg1 definition accept: selfonAccept: arg1  acceptBlock := arg1execute  self repositoryModel discardChangesvisitNoModification: arg1  arg1 definition addToPatcher: patcher.  self visitChildrenOf: currentNodecommitChanges: arg1 withMessage: arg2  ^self workingCopy commitChanges: arg1 withMessage: arg2diff: arg1  diff := arg1initializeDialogWindow: arg1  super initializeDialogWindow: arg1.  acceptButton label: 'Debug'.  cancelButton label: 'Ignore'commentPanel: arg1  commentPanel := arg1isTrait: arg1  | tmp1 |  tmp1 := snapshot classDefinitionNamed: arg1 ifAbsent: [ ^false ].  ^tmp1 isTraitDefinitionbranchName  ^branchName ifNil: [ branchName := self obtainBranchName ]ensurePackageFromDirectory: arg1 inParentNode: arg2  | tmp1 tmp2 tmp3 |  tmp2 := version writerClass packageNameFromDirectory: arg1.  (arg2 includesKey: tmp2) ifTrue: [ ^self ].  tmp3 := IcePackage named: tmp2 repository: self repository.  tmp1 := IceMCPackageImporter new     package: tmp3;     version: version;     yourself.  ^tmp1 importOn: arg2firstNodeSuchThat: arg1 ifNone: arg2  (arg1 value: self) ifTrue: [ ^self ].  self nextNodeSuchThat: arg1 ifFound: [:arg3 |  ^arg3 ].  ^self parent ifNil: arg2 ifNotNil: [ self parent nextChildNodeStartingFrom: self suchThat: arg1 ifNone: arg2 ]iconName: arg1  self icon: ((self iconNamed: arg1) scaledToSize: 32 @ 32)mergeWithLeftNoOperation: arg1  ^IceNonConflictingOperation operation: arg1basicExecute  self subclassResponsibilityinitialize  super initialize.  checkoutStrategies := (IceCheckoutStrategy allSubclasses sorted: [:arg1 :arg2 |  arg1 order < arg2 order ]) collect: #new.  checkoutStrategy := checkoutStrategies firstvisitRootDefinition: arg1  self visitChildrenOf: currentNodepackage: arg1  package := arg1displayingProgressString  ^'Comparing image changes of ' , self package namecanHandleType: arg1  ^Iceberg enableMetacelloIntegration and: [ IceMetacelloRepositoryType canHandleType: arg1 ]refresh  widgets removeAll.  self layout: self newLayout.  self layout newColumn: [:arg1 |  self addWidgetsTo: arg1 ]selectButton  ^selectButtonreadOnlyVersion  ^selfbackend  ^backendchosenOperation  ^chosen ifNil: [ operation ] ifNotNil: [ chosen ]initializeWidgets  leftPanel := self newPanelMorph.  rightPanel := self newPanelMorph     listDirection: #rightToLeft;     hResizing: #spaceFill.  panel := PanelMorph new     changeTableLayout;     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #spaceFill;     color: self color;     asSpecAdapter.  panel widget     addMorphBack: leftPanel;     addMorphBack: rightPanelmergeWith: arg1 onMerge: arg2  ^self mergeWith: arg1 onLeft: [:arg3 |  arg3 ] onRight: [:arg3 |  arg3 ] onMerge: arg2browse  | tmp1 |  tmp1 := Smalltalk globals at: name.  tmp1 isMeta ifTrue: [ tmp1 classSide ].  tmp1 browseasInteger  ^self major * 10000 + (self minor * 100) + self patchreadParametersFromContext: arg1  super readParametersFromContext: arg1.  announcer := IceTipWeakValueHolder contents: arg1 toolAnnouncernewCellFor: arg1  | tmp1 |  tmp1 := FTIndentedCellMorph new.  tmp1 indentBy: (self cellIndentFor: arg1).  tmp1 addMorphBack: (self buttonFor: arg1).  (self iconFor: arg1 data) ifNotNil: [:arg2 |  tmp1 addMorphBack: arg2 asMorph ].  tmp1 addMorphBack: (self toString: arg1 data) asMorph asReadOnlyMorph.  ^tmp1mergeTree  self calculateChanges.  ^mergeTreedirectoryNameForPackage: arg1  ^(self writerClass directoryNameFor: arg1) asStringpackageNamed: arg1  ^self workingCopy packageNamed: arg1repository  ^diff repositoryproject  ^repository newUnbornProjectowner  ^(((self jsonAt: #base) at: #repo) at: #owner) at: #loginadditionColor  ^super removalColornewSidebarTreeDataSource  ^IceTipTreeOutlineDataSource new     tool: self;     rootForItems: self model repositoryModelsByGroup;     childrenBlock: [:arg1 |  arg1 children ];     icon: [:arg1 |  arg1 icon ];     format: #descriptionWithDecoration;     yourselfresolve: arg1 ifPresent: arg2 ifAbsent: arg3  | tmp1 tmp2 |  tmp1 := arg1 segments.  tmp1 ifEmpty: [ ^arg2 value: self value ].  tmp2 := childrenDictionary at: tmp1 first ifAbsent: [ ^arg3 value ].  ^tmp2 resolve: (RelativePath withAll: tmp1 allButFirst) ifPresent: arg2 ifAbsent: arg3remote: arg1  remote := arg1tagNames  ^self commit tagNamesisNewBranch  ^trueaddItem: arg1  items add: arg1.  self refreshinitializeWidgets  panel := self newIcePanel.  panel widget addMorphBack: (actionMorphPanel := PanelMorph new           changeTableLayout;           listDirection: #rightToLeft;           hResizing: #shrinkWrap;           vResizing: #spaceFill;           yourself)execute  IceTipAddSSHCredentialsModel new     credentialStore: store;     tool: tool;     openNonModalcommit  ^IceNoCommit repository: repositoryensureMCVersionWithClassOrganisation: arg1  ^arg1 snapshot definitions detect: [:arg2 |  arg2 isClassDefinition ] ifFound: [:arg2 |  arg1 ] ifNone: [ MCVersion package: arg1 package info: arg1 info snapshot: (MCSnapshot fromDefinitions: {(MCOrganizationDefinition categories: {arg1 package name})} , arg1 snapshot definitions) ]rootFileReference  ^repository locationheaderColumn: arg1  arg1 id ifNil: [ ^nil ].  ^arg1 newHeader     target: self;     actionSelector: #actionColumn:;     arguments: {arg1};     yourselfresponse: arg1  response := arg1first  ^firstisInMerge  ^self workingCopyState isInMergeshowInfoTabs  (commitTabPanel tabs includes: infoTab) ifFalse: [ self removeAllCommitPanelTabs.        commitTabPanel           addTab: infoTab;           addTab: headTabContainer tab;           addTab: ancestorTabContainer tab ].  self refreshCommitInfo.  self refreshDiffFromHeadLabel.  self refreshDiffFromAncestorLabel.  commitTabPanel selectedTab ifNotNil: #tabSelectedisSelected: arg1  ^selectedItems includes: arg1isResumable  ^truenameLabel: arg1  nameLabel := arg1packageNames  ^self packagesDictionary keysread: arg1  ^self action value: arg1labelFor: arg1  ^'{1} to HEAD' format: {(arg1 ifNotNil: #shortId)}reload  self loadbodyText: arg1  bodyText := arg1acceptError: arg1  arg1 visitRemoteAlreadyExistError: selfvisitOrganizationDefinition: arg1  packageNode value categories: arg1 categoriespattern: arg1  pattern := arg1referenceCommits  ^{self referenceCommit}currentCommits  ^repository workingCopy referenceCommitsdefaultMenuItemName  ^'View Pull Requests'sourceVersion  ^sourcedelete  < noCache>  IceTipStandardAction new     repository: self entity;     message: ('Deleting {1}' format: {self name});     execute: [ self entity delete ]addProjectFileTo: arg1  | tmp1 |  tmp1 := IceBasicProject onRepository: arg1.  tmp1 sourceDirectory: self subdirectory.  arg1 workingCopy basicSetProject: tmp1commonAncestorWith: arg1  ^arg1 commonAncestorWithCommit: selfisValidPackage: arg1  ^self writerClass isValidPackage: arg1doPull  self model pullThen: [ self window delete ]updateText: arg1  issueText text: arg1.  fetched := trueaddTo: arg1  onSelectionChangedBlock: arg1  onSelectionChangedBlock := arg1repositoryModel  ^selfpeelTag: arg1  self handleLibgitError: [ | tmp1 |        tmp1 := self repositoryHandle lookup: 'refs/tags/' , arg1 name.        ^self lookupCommit: tmp1 targetId hexString ]store  ^storechildren  ^children ifNil: [ children := Dictionary new ]initializeWidgets  changeList := self newIceTable.  diffPanel := self instantiate: DiffPresenter.  self initializeChangeList.  self initializeDiffPanel.  changeList widget onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self.  self whenBuiltDo: [:arg1 |  self addShortcutsTo: arg1 widget ].  self focusOrder     add: changeList;     add: diffPanelcommit  ^streamhttpsUrl  ^'https://{1}/{2}.git' format: {self host .         self projectPath}fileUtils  ^IceLibgitTonelFileUtilsexecute: arg1  self action: arg1.  self executeicon  ^self iconNamed: #addchooseConflictPolicyProject: arg1 optionA: arg2 optionB: arg3  ^UIManager default chooseFrom: {('Use INCOMING version {1}' format: {arg2}) .         ('Use LOADED version {1}' format: {arg3})} values: {#useIncoming .         #useLoaded} message: ('There are conflicting versions of project "{1}".' format: {arg1}) title: 'Conflicting project versions'composeUrlWithHost: arg1 repositoryPath: arg2  ^'https://{1}/{2}.git' format: {arg1 .         arg2}title  ^title ifNil: [ self model name ]accept: arg1  ^arg1 visitNonConflictingOperation: selfextent  ^800 @ 175formatLabel  ^formatLabelinitializeWidgets  super initializeWidgets.  sidebarTree := self newIceOutline.  historyPanel := self instantiate: IceTipHistoryBrowser on: self model headModel.  historyPanel beForMerge.  self initializeSidebarTree.  sidebarTree widget onAnnouncement: FTSelectionChanged send: #commitishSelected: to: self.  self focusOrder     add: historyPanel;     add: sidebarTreeinitialExtent  ^self hasToShowWarning ifTrue: [ (475 @ 500) scaledByDisplayScaleFactor ] ifFalse: [ (475 @ (200 + (self class inputTextHeight * 3) + self class buttonHeight + 50)) scaledByDisplayScaleFactor ]storeOnFileReference: arg1  arg1     ensureDelete;     writeStreamDo: [:arg2 |  (STONWriter on: arg2)           prettyPrint: true;           newLine: OSPlatform current lineEnding;           nextPut: self properties ]addTo: arg1  initializeWidgets  super initializeWidgets.  diffPanel leftLabel: 'Working Copy'.  diffPanel rightLabel: 'Merge with ' , model targetNameprojectName  ^path basenametags  self handleLibgitError: [ ^self repositoryHandle tags collect: [:arg1 |  IceTag named: arg1 inRepository: self ] ]newPatchMorph  ^IceTipMergePatchMorph new     borderWidth: 0;     addDependent: self;     yourselfbaseDefaultBranchName  ^self gitBase at: #default_branchextractTypeFromDescription: arg1  (arg1 beginsWith: 'ftp://') ifTrue: [ ^'ftp' ].  IceMetacelloRepositoryType allTypes detect: [:arg2 |  arg2 isSuitableForLocation: arg1 ] ifFound: [:arg3 |  ^arg3 type ].  ^super extractTypeFromDescription: arg1isModified  ^self workingCopy isModifiedmessageBody  | tmp1 |  tmp1 := self jsonContents at: #errors ifAbsent: [ ^'' ].  ^String streamContents: [:arg1 |  tmp1 do: [:arg2 |  arg1 << (self errorToString: arg2) ] separatedBy: [ arg1 cr ] ]newBaselineDefaultCommand: arg1  ^IceTipMetacelloInstallBaselineDefaultCommand new     repositoryModel: self repositoryModel;     package: arg1;     yourselfhasOutgoingCommitsTo: arg1  | tmp1 tmp2 |  self tracksRemoteBranch ifFalse: [ ^false ].  tmp1 := self commits.  tmp2 := self trackedBranch commits.  ^tmp1 anySatisfy: [:arg2 |  (tmp2 includes: arg2) not ]createTag: arg1  self subclassResponsibilitytargetUrlCellColumn: arg1 rowIndex: arg2  | tmp1 |  tmp1 := (self elementAt: arg2) at: arg1 id.  ^FTCellMorph new     addMorphBack: (IconicButton new           target: self;           actionSelector: #copyToClipboard:;           arguments: {tmp1};           labelGraphic: ((self iconNamed: #smallCopy) scaledToSize: 12 @ 12);           color: Color transparent;           helpText: ('Copy url {1} to clipboard' format: {tmp1});           borderWidth: 0;           yourself);     yourselfunload  self loadedPackages do: [:arg1 |  self unloadPackage: arg1 ]drawBadgeOn: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp1 := self badge asString.  tmp4 := self badgeFont widthOfString: tmp1.  tmp5 := self badgeFont height.  tmp6 := 14 max: tmp4 + 2.  tmp2 := (bounds right - tmp6 - 2) @ (bounds top + 2) extent: tmp6 @ 14.  arg1 fillOval: tmp2 fillStyle: self badgeColor.  tmp3 := tmp2 center - (tmp4 @ tmp5 / 2.0) + (1 @ 0) extent: tmp4 @ tmp5.  arg1 drawString: tmp1 in: tmp3 font: self badgeFont color: self badgeTextColorremote  ^remotevalidate  self assert: self projectNameInputText text isNotEmpty description: 'You must enter a project name (it will be used also as part of the path).'.  self assert: self projectLocation location notNil description: 'Project location must be defined (if it does not exists, it will be created).'repository  ^repositoryhandleKeystroke: arg1  arg1 wasHandled ifTrue: [ ^self ].  self allowsKeymapping ifTrue: [ self dispatchKeystrokeForEvent: arg1 ]mergeHistoryFromSecondAncestor  < noCache>  ^self mergeHistoryFromAncestor: self entity ancestors seconddescription  ^'User: ' , usernameleftContents  ^''subdirectory  ^self entity subdirectorynewRepositoriesDataSource  ^IceTipDataSource new     tool: self;     elements: self model repositories;     yourselfresetToCommit: arg1  entity resetToCommit: arg1 entitydo: arg1  self action: arg1.  self executewarningMessage  ^'Be careful. You should choose the actual format of the current repository.Changing the format in here will not migrate your code to another format.If you want to migrate your code from Filetree to Tonel, use the migration option in the context menu (Extra >> Convert repository sources to Tonel).'diffTo: arg1  ^IceDiff from: self to: arg1 commitinitializeWidgets  reasonPanel := self newIcePanel.  optionsList := self newIceTable.  detailPanel := self newIcePanel.  self initializeReasonPanel.  self initializeOptionsList.  self focusOrder add: self optionsListtracksRemoteBranch  ^self hasUpstreamrepository  ^repositorydiff: arg1  diff := arg1addRemote: arg1  self remote: (IceGitRemote url: arg1)readParametersFromContext: arg1  super readParametersFromContext: arg1.  branchModel := arg1 itemsubdirectory  ^self project sourceDirectoryinitialize  super initialize.  choices := Set newobtainPlaintextCredentials: arg1  LGitNoCredentialsProvided signaldoCommit  self doCommit: diffPanel selectedItems message: commentPanel message pushing: commentPanel isPushingmenuColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp1 := self elementAt: arg2.  tmp2 := self menuSelectionContextWithSelection: tmp1 data.  ^CmdContextMenuActivation buildContextMenuFor: self table inContext: tmp2initializeWidgets  super initializeWidgets.  usernameLabel := self newLabel label: 'Username: '.  usernameInput := self newTextInput     text: 'git';     autoAccept: true;     whenTextChanged: [ self updateOkButton ];     yourself.  passphraseLabel := self newLabel label: 'Key Passphrase: '.  passphraseInput := self newTextInput     beEncrypted;     autoAccept: true;     whenTextChanged: [ self updateOkButton ];     yourself.  privateKeyInput := IceTipFilePresenter new     label: 'Private Key';     onChoose: [ self updateOkButton ];     chooseTitle: 'Select Private Key';     whenTextChanged: [ self updateOkButton ];     yourself.  publicKeyInput := IceTipFilePresenter new     label: 'Public Key';     onChoose: [ self updateOkButton ];     chooseTitle: 'Select Public Key';     whenTextChanged: [ self updateOkButton ];     yourselfaction: arg1  action := arg1selector  ^nameokAction  credentialStore storeCredential: self credentials forHostname: self host.  tool refreshaccept: arg1  ^arg1 visitDirectoryDefinition: selftagName: arg1  tagName := arg1github  ^IceGitHubAPI new     credentials: self credentials;     yourselfcommitDictionary  commitDictionary ifNil: [ self lookupCommits ].  ^commitDictionarybadgeColor  ^Smalltalk ui theme badgeColorusername  ^self nameInput text trimBothinitialize  super initialize.  self childrenBlock: [:arg1 |  arg1 isDirectory ifTrue: [ self childrenToShowFrom: arg1 ] ifFalse: [ #() ] ]setModelBeforeInitialization: arg1  model := arg1color  ^color ifNil: [ Color transparent ]allChildrenDo: arg1  self childrenDo: [:arg2 |  arg1 value: arg2.        arg2 allChildrenDo: arg1 ]remoteLabel: arg1  remoteLabel := arg1message  ^messagespacePanel  ^spacePanelisEmpty  ^mergeTree isEmptymessagePanel  ^messagePanelrepository: arg1  repository := arg1readParametersFromContext: arg1  repositoryModel := arg1 repositoryModelsourceDirectory  ^self subclassResponsibilitypackage  ^packageget: arg1 parameters: arg2  ^self jsonContentsWithValidationDo: [ (self newRequestTo: arg1 , (String streamContents: [:arg3 |  arg3 << '?'.                          arg2 associations do: [:arg4 |  arg3 << arg4 key << '=' << arg4 value ] separatedBy: [ arg3 << '&' ] ]))           get;           response ]host  ^hostfetch  localRepository handleLibgitError: [ [ (LGitRemote of: self repositoryHandle named: self name)           lookup;           fetchWithCredentials: (IceCredentialsProvider defaultForRemote: self) andProgressCallback: IceGitTransferProgress new ] on: LGitAbstractError do: [:arg1 |  arg1 acceptError: (IceLibgitErrorVisitor onContext: self) ].        localRepository postFetch ]addShortcutsTo: arg1  self enableCommanderShortcutsIn: arg1isUndefined  ^truebrowse  | tmp1 |  tmp1 := Smalltalk globals at: self className.  self classIsMeta ifTrue: [ tmp1 := tmp1 classSide ].  (tmp1 >> name) browseinfo  ^{('Commit:' -> ('[' , self shortId , '] ' , self id)) .   ('Parents:' -> (self entity ancestors collect: #shortId) asCommaString) .   ('Author:' -> self entity author) .   ('Date:' -> self entity timeStamp asStringYMDHM) .   ('Tags:' -> self entity tagNames asCommaString) .   ('Comment:' -> self entity comment)}cellIndentFor: arg1  ^(arg1 depth - 1) * 16 + 3canBeBrowsed  ^Smalltalk globals includesKey: nameurlText  ^urlTextremoteName  ^remoteNamecommonAncestorWith: arg1  ^self referenceCommit commonAncestorWith: arg1newActionButton  ^self newButton     label: 'Push';     icon: (self iconNamed: #up);     help: ('Push new commits to {1}' format: {self model remoteName});     action: [ self doPush ];     yourselfreplaceBy: arg1  parent replace: self with: arg1asMCDefinition  ^MCMethodDefinition className: self className classIsMeta: self classIsMeta selector: self name category: self protocol timeStamp: '' source: sourceCodeloadPackageNamed: arg1 fromCommit: arg2  self loadPackagesNamed: {arg1} fromCommit: arg2execute  self action cull: self= arg1  ^self species = arg1 species and: [ properties = arg1 properties ]obtainBranchName  | tmp1 tmp2 tmp3 |  tmp3 := 0.  tmp1 := self class branchBaseName.  tmp2 := ''.  [ true ] whileTrue: [ self repository branchNamed: tmp1 , tmp2 ifAbsent: [ ^tmp1 , tmp2 ].        tmp3 := tmp3 + 1.        tmp2 := '-' , tmp3 asString ]basicExecute  | tmp1 |  tmp1 := IceTipLocalRepositoryPanel new     location: (self repository location ifNil: [ self defaultLocation ]);     yourself.  tmp1 openDialogWithSpec okAction: [ tmp1 validate.        self repositoryModel updateLocation: tmp1 location.        true ]descriptionWithDecoration  ^self namefileFormat: arg1  self fileFormatId: arg1 idwriterClass  ^self project writerClasssubscribeToAnnouncements  Iceberg announcer weak when: IceAnnouncement send: #refresh to: selfmergeablePanel  ^mergeablePanelbadge  ^nilcommitList  ^commitListgetRepository: arg1 project: arg2  ^self get: 'repos/' , arg1 , '/' , arg2addPropertiesFileTo: arg1  arg1 properties fileFormat: self formatToUseacceptCallback  ^acceptCallbackacceptError: arg1  arg1 visitRemoteDesynchronizedError: selfnewDiffPanelLeft: arg1 right: arg2  ^(self instantiate: DiffPresenter)     leftText: arg1;     rightText: arg2;     showOptions: false;     buildWithSpecurlText  ^urlTextaddItemLeft: arg1  self leftPanel addMorphBack: (self prepareItemToAdd: arg1)name  ^definition namepath  ^RelativePath withAll: self allPathSegmentscomment  ^iceCommit commentincomingCommitsFrom: arg1  | tmp1 |  tmp1 := arg1 remoteBranchNamed: self name ifAbsent: [ ^#() ].  ^tmp1 newCommitWalk     uptoCommit: self commit;     commitsaccept: arg1  arg1 visitCypressPropertiesChange: selficonPanel: arg1  iconPanel := arg1hash  ^self name hashurl: arg1  url := arg1outgoingCommits  ^self branch outgoingCommitsrepositoryModel  ^repositoryModelcontextClass  ^IceTipCredentialsStoreContextjsonContentsWithValidationDo: arg1  ^STON fromString: (self contentsWithValidationDo: arg1)hasUpstream  ^entity hasUpstreamtool: arg1  tool := arg1validateCanCommit  self workingCopy referenceCommit first = repository head commit ifFalse: [ IceWorkingCopyDesyncronized signal ]username  ^usernameInput textupdated  ^selfbasicInstallBaseline: arg1 groups: arg2  | tmp1 tmp2 tmp3 |  tmp3 := arg1 repository project sourceDirectory.  tmp3 ifEmpty: [ tmp3 := '.' ].  tmp1 := (arg1 repository location / tmp3) fullName.  tmp2 := arg1 name allButFirst: self class baselinePrefix size.  Metacello new     repository: 'gitlocal://' , tmp1;     baseline: tmp2;     onUpgrade: [:arg3 |  | tmp4 |        tmp4 := self chooseUpgradePolicyFor: arg3.        tmp4 ifNotNil: [ arg3 perform: tmp4 ] ];     onConflict: [:arg3 |  | tmp4 |        tmp4 := self chooseConflictPolicyFor: arg3.        tmp4 ifNotNil: [ arg3 perform: tmp4 ] ];     load: arg2initializeOptionsList  optionsList widget     addColumn: (IceTipTableColumn newAction: #title icon: #icon);     dataSource: self newOptionsListDataSource;     bindKeyCombination: Character cr toAction: [ self accept ];     onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self;     onAnnouncement: FTStrongSelectionChanged send: #accept to: selfcontextSelection  ^self changeSelectedensureMethodOwnerNamed: arg1 isMeta: arg2 isTrait: arg3 isExtension: arg4  | tmp1 |  tmp1 := arg4 ifTrue: [ IceExtensionDefinition named: arg1 isMeta: arg2 ] ifFalse: [ arg3 ifFalse: [ IceClassDefinition named: arg1 isMeta: arg2 ] ifTrue: [ IceTraitDefinition named: arg1 isMeta: arg2 ] ].  ^packageNode childAt: tmp1 key ifAbsentPut: [ tmp1 ]execute  (IceTipRemovePackageDialog on: self packageModel) openDialogWithSpecmodel: arg1  model := arg1.  self refreshupdateContentsOn: arg1  arg1 ifNil: [ ^self ].  self tab contents: (self newDiffPanelFor: (self diffFor: arg1)) buildWithSpecvisitERROR: arg1  arg1 object = LGitErrorTypeEnum giterr_ssh ifTrue: [ arg1 resignalAs: IceAuthenticationError new ].  arg1 object value = LGitReturnCodeEnum git_euser value ifTrue: [ self visitEUSER: arg1 ].  arg1 messageText trimmed = 'Unexpected HTTP status code: 404' ifTrue: [ IceCloneRemoteNotFound signalFor: context url ].  self visitGenericError: arg1checkoutAllPackages  repository checkout: (IceCheckoutAllPackages new           committish: self;           yourself)credentials  ^credentials ifNil: [ credentials := self obtainCredentials ]visitENOTFOUND: arg1  NotFound signal: arg1 messageTextdescriptionWithDecoration  ^self subclassResponsibilityinitializePresenter  super initializePresenter.  self putFocusOrderindex  ^indexfillDefaultMenu: arg1 using: arg2 baseline: arg3  | tmp1 |  tmp1 := self newBaselineDefaultCommand: arg3.  self fillMenu: arg1 title: ('Install baseline of {1} (default)' format: {(self nameOfBaseline: arg3)}) command: tmp1 activator: arg2 baseline: arg3username  ^username ifNil: [ username := self class defaultUsername ]userNameLabel  ^userNameLabelreferenceCommits  ^{referenceCommit}iconFor: arg1  ^self iconNamed: #emptyPackagenewTypeListDataSource  ^IceTipDataSource new     tool: self;     elements: self allTypes;     yourselflistPanel  ^listPanelstate  ^self jsonAt: #statefileUtils  ^IceLibgitFiletreeFileUtilsremoteBranchNamed: arg1 ifAbsent: arg2  ^self branchNamed: arg1 ifPresent: [:arg3 |  arg3 ] ifAbsent: arg2leftContents  ^operation leftContentshead  ^self lookupHeadprojectName: arg1  projectName := arg1createCommandContext  ^self newContextWithSelection: self contextSelectioninitializeMessagePanel  self hasToShowWarning ifTrue: [ messagePanel := self instantiate: IceTipReadOnlyTextMorphWithIcon.        messagePanel iconName: #warning.        messagePanel text: self warningMessage ] ifFalse: [ messagePanel := self newIcePanel.        messagePanel widget height: 1 ]iconForStatus: arg1  ^self iconNamed: (self iconNameForStatus: arg1)className  ^classNamefileName: arg1  fileName := arg1okAction  ^self subclassResponsibilityrepository  ^repositoryiconName  ^#githubreaderClass  ^self properties readerClassbranchNamePrefix  ^'refs/heads/'latestTagParts  ^self latestTagPartsIn: (commitishToTag tagModels collect: #name)initializeBranchesList  | tmp1 |  branchesList widget     addColumn: (IceTipTableColumn newAction: #shortDescriptionWithDecoration);     dataSource: (tmp1 := self newBranchListDataSource);     bindKeyCombination: Character cr toAction: [ self accept ];     onAnnouncement: FTStrongSelectionChanged do: [ self accept ].  self model branchModels detect: #isHead ifFound: [:arg1 |  branchesList widget selectIndex: (tmp1 elements indexOf: arg1) ] ifNone: [ self model hasBranches ifTrue: [ branchesList widget selectFirstVisibleRow ] ]hash  ^(super hash << 10) + package hashshowWidget  contextSelection  ^typeisLoaded  ^repository workingCopy isLoadedPackageNamed: self packageNamecommitIdFor: arg1 ifFound: arg2  self flag: #todoremoveFile: arg1  (repository location resolvePath: arg1 path) ensureDeletecreateCommandContext  ^self newContextreadParametersFromContext: arg1  store := arg1 store.  tool := arg1 toolselectedItem  ^self table selectedRowIndexes ifNotEmpty: [:arg1 |  self elementAt: arg1 first ] ifEmpty: [ nil ]notAllConflictsResolved  ^self model mergeTree anySatisfy: [:arg1 |  arg1 isConflict and: [ arg1 isResolved not ] ]gitRef  ^self nameiconNamed: arg1  ^Smalltalk ui icons iconNamed: arg1fetchPackageNames  | tmp1 tmp2 |  tmp1 := self writerClass.  tmp2 := self fileSystem resolve: self project sourceDirectory.  tmp2 exists ifFalse: [ ^#() ].  ^tmp2 children select: [:arg1 |  tmp1 isValidPackage: arg1 ] thenCollect: [:arg1 |  tmp1 packageNameFromDirectory: arg1 ]toFileName: arg1  ^self fileNameForMethod: arg1defaultMenuItemName  ^'New Pull Request'icon: arg1  icon := arg1passwordInput  ^passwordInputaccept: arg1  ^arg1 visitFileNode: selfaccept: arg1  ^arg1 visitGitChange: selfinitialExtent  ^(700 @ 700) scaledByDisplayScaleFactormergeOn: arg1 then: arg2  ^arg1 switchAndMergeThen: arg2resetDataSource: arg1  ^arg1     rootForItems: self model treeRoots;     expandAllpackageLocationFor: arg1  | tmp1 tmp2 |  tmp1 := self location.  self subdirectory ifNotEmpty: [ tmp1 := tmp1 / self subdirectory ].  tmp2 := self writerClass directoryNameFor: arg1.  tmp1 := tmp1 / tmp2.  ^tmp1hasBranches  ^self branches isNotEmptystatus  (self repository workingCopy referenceCommits includes: self) ifTrue: [ 'Current' ].  (self repository workingCopy referenceCommits anySatisfy: [:arg1 |  arg1 isNoCommit not and: [ self isAncestorOf: arg1 ] ]) ifTrue: [ ^'Loaded' ].  (self repository branch newCommitWalk includesCommit: self) ifTrue: [ ^'Not loaded' ].  ^'Not merged'suspendAllWhile: arg1  | tmp1 |  tmp1 := suspendAll.  suspendAll := true.  arg1 ensure: [ suspendAll := tmp1 ]recordChoice: arg1  ^choices add: arg1ensureProjectFile  ensureProjectFile := trueinverse  self subclassResponsibilityhelp: arg1  help := arg1bodyPanel: arg1  bodyPanel := arg1defaultLocation  ^IceLibgitRepository repositoriesLocationtracksRemoteBranch  ^falsereadProjectFromCommitish: arg1  ^IceUnbornProject onCommitish: arg1childrenToShowFrom: arg1  ^(arg1 children select: [:arg2 |  arg2 isDirectory and: [ (arg2 basename beginsWith: '.') not ] ]) sort: [:arg3 :arg4 |  arg3 basename < arg4 basename ]leftOperation: arg1  leftOperation := arg1minorButton  ^minorButtonproject  ^project ifNil: [ self refreshProjectFromRepository ]mcRepository  self subclassResponsibilityexecute  (IceTipHistoryBrowser on: commitModel mergeHistoryFromSecondAncestor) openWithSpecaddToChangeBuilder: arg1  arg1 addFileNamed: self propertiesFilePath segments last path: self propertiesFilePath contents: self contentsStringrepository: arg1  repository := arg1accept  IceTipStandardAction new     repository: model repository;     message: 'Setting up project';     onSuccessRepositoryModified;     execute: [ model sourceDirectory: self selectedDirectoryPath pathString.        model fileFormat: self selectedFileFormat.        self assert: model repositoryProperties fileFormat = self selectedFileFormat.        model repository workingCopy project: model ].  self window delete.  acceptCallback ifNotNil: [ acceptCallback value ]mergeWithLeftRemoval: arg1  self shouldNotImplementpublicKey  ^publicKeyInput location ifNil: [ '' ] ifNotNil: [:arg1 |  arg1 pathString ]remote  ^remote ifNil: [ | tmp1 |        tmp1 := self repositoryModel entity head.        remote := (tmp1 isBranch and: [ tmp1 hasUpstream ]) ifTrue: [ tmp1 upstream remote ] ifFalse: [ self remoteModels first entity ] ]commitish: arg1  commitish := arg1beHttps  protocol := IceHttpsProtocol newoutgoingCommits  ^#()hideYourselfFromCommitWalk: arg1  arg1 uptoCommit: self commitmouseLeave: arg1  self flag: #bad.  ^self eventHandler ifNotNil: [ self eventHandler mouseLeave: arg1 fromMorph: self ]repository  ^repositorycancelAction  committish: arg1  committish := arg1initialize  super initialize.  date := Date today.  time := Time nowrefreshWhenRepository: arg1  (self model isModelOf: arg1 repository) ifFalse: [ ^self ].  self model reset.  self refreshbranches  self subclassResponsibilitytrackedBranch  | tmp1 |  tmp1 := self upstream.  tmp1 ifNil: [ tmp1 := self setUpstream: (self lookupRemoteBranch: '/origin/' , self name) ].  ^tmp1commitTabPanel: arg1  commitTabPanel := arg1checkoutStrategies  ^IceCheckoutStrategy allStrategiespattern  ^patternpatch  ^patchbranchesList  ^branchesListaddTo: arg1  arg1 addNode: selfbeSsh  protocol := IceSSHProtocol newwriterClass  ^self properties at: 'format' ifPresent: [:arg1 |  TIceRepositoryWriter users detect: [:arg2 |  arg2 id = arg1 ] ] ifAbsent: [ commitish project isInvalid ifFalse: [ IceLibgitRepository defaultFileFormat ] ifTrue: [ TIceRepositoryWriter users detect: #isLegacyDefault ifNone: [ Smalltalk at: #IceLibgitFiletreeWriter ] ] ]hasUpstream  self upstreamIfNone: [ ^false ].  ^trueaddModification: arg1 toPatcher: arg2  (self isMeta and: [ mcDefinition isNil ]) ifTrue: [ ^self ].  arg2 modifyDefinition: arg1 rightDefinition asMCDefinition to: arg1 leftDefinition asMCDefinitionremote: arg1  remote := arg1contextClass  ^IceTipDiffContextvalidateIssue: arg1  | tmp1 tmp2 |  fetched := false.  arg1 trimmed isEmpty ifTrue: [ ^self ].  arg1 isAllDigits ifFalse: [ ^self ].  tmp1 := arg1 asNumber.  (issue isNil or: [ (issue at: 'number') ~= tmp1 ]) ifFalse: [ ^self ].  tmp2 := self selectRemoteModel remote.  self wait: 500 milliSeconds thenDo: [ [ issue := IceGitHubAPI new           beAnonymous;           getIssue: tmp2 owner project: tmp2 projectName number: tmp1.        UIManager default defer: [ self updateText: (self sanitizeTitle: (issue at: 'title')) ] ] on: IceGitHubError do: [:arg2 |  arg2 messageText = 'Not Found' ifFalse: [ arg2 pass ].              UIManager default defer: [ self updateText: self class unknownTitle ] ] ]visitNoModification: arg1  arg1 definition accept: selfsetUpstreamRemote: arg1  self setUpstream: (arg1 remoteBranchNamed: self name)items  ^itemssshCredentialForHostname: arg1  ^self lookup: arg1 in: sshCredentials ifAbsent: [ self defaultSSHCredential ]hash  ^self leftDefinition hashvisitNoRemote: arg1  self visitGenericError: arg1icon: arg1  iconWidget widget     removeAllMorphs;     addMorphBack: arg1 asMorphdiscardChanges: arg1  self loadChangesInWorkingCopy: (arg1 collect: [:arg2 |  arg2 inverse ]).  self refreshDirtyPackagescommit  ^commit ifNil: [ commit := self repository peelTag: self ]contextClass  ^nilload  loader loadinitialize  super initialize.  job := IceExternalJob new     title: self title;     yourself.  self initializeBlockdisplayMode: arg1  displayMode := arg1removeFrom: arg1  arg1 remoteFileReferenceInPath: self pathtoolbar  ^toolbarvalidate  ^self subclassResponsibilityexecute  (IceTipCheckoutBranchDialog on: self repositoryModel) openDialogWithSpeconSelectionChangedBlock  ^onSelectionChangedBlockcheckoutStrategyLabel  ^checkoutStrategyLabelexecute  tool collapseAllhasIncomingCommitsFrom: arg1  ^self branch hasIncomingCommitsFrom: arg1accept: arg1  self subclassResponsibilitytitle  ^'Browsing pull request: #{1} {2}' format: {self pullRequest number .         self pullRequest title}providePlaintextCredentialsTo: arg1  tries := tries + 1.  tries >= 3 ifTrue: [ Transcript           show: 'aborting';           cr.        LGitNoCredentialsProvided signal: 'There where already three failed attempts, aborting' ].  tries = 1 & self plaintextCredentials isPresent ifTrue: [ arg1 readFrom: self plaintextCredentials ] ifFalse: [ self obtainPlaintextCredentials: arg1 ]onCommit: arg1  commitButton action: [ arg1 cull: self message cull: self isPushing ]defaultSubdirectory  ^IceLibgitRepository defaultCodeSubdirectorymodel: arg1  super model: arg1.  self refreshhasUnbornProject  ^self entity workingCopy project isUnborntoLabel: arg1  toLabel := arg1remoteBranches  ^branches ifNil: [ branches := self requestRemoteBranches ]at: arg1 put: arg2  ^objects at: arg1 put: arg2addRow: arg1 value: arg2 isLast: arg3 to: arg4  arg3 ifTrue: [ arg4 newRow: [:arg5 |  arg5                 newColumn: arg1 width: self iceLabelWidth;                 newColumn: arg2 ] ] ifFalse: [ arg4 newRow: [:arg5 |  arg5                 newColumn: arg1 width: self iceLabelWidth;                 newColumn: arg2 ] height: self rowHeight ]accept  self validate.  self doAccept.  acceptBlock ifNotNil: [ acceptBlock cull: self ]name: arg1  name := arg1refreshProject  repository commitsInPackageCache: nil.  self refreshPackagesrepositoryDirectory  ^self locationremoteList: arg1  remoteList := arg1hasIncomingCommits  self hasUpstream ifFalse: [ ^false ].  ^self hasIncomingCommitsFrom: self upstream remotename  ^commitish namescpUrl  ^'{1}@{2}/{3}.git' format: {self user .         self host .         self path}initialize  super initialize.  datetime := DateAndTime nowinitializePackagesList  | tmp1 |  tmp1 := self newPackagesListDataSource.  packagesList widget     addColumn: (IceTipTableColumn newAction: #name icon: [:arg1 |  self iconNamed: #package ]);     dataSource: tmp1;     useFunction: IceTipLinkFilterFunction do: [:arg2 |  arg2           filterClass: IceTipPackageFilter;           textField: self packageNameText ];     bindKeyCombination: Character cr toAction: [ self accept ];     onAnnouncement: FTStrongSelectionChanged do: [ self accept ]uptoCommits: arg1  arg1 do: [:arg2 |  self uptoCommit: arg2 ]info  ^info ifNil: [ info := IceMCVersionInfo new fromCommit: self commit package: package ]askRemote: arg1  ^arg1 remotes anyOneinverse  ^IceRemoval definition: definitionhasChanges  ^value hasChanges or: [ self children anySatisfy: [:arg1 |  arg1 hasChanges ] ]allTypes  ^types ifNil: [ types := IceTipRepositoryTypePanel allTypes ]accept: arg1  arg1 visitProjectChange: selfswitchToCommitishNamed: arg1  ^(self commitishNamed: arg1)     switch;     yourselfasMCDefinition  ^mcDefinitionvisitGenericError: arg1  IceGenericError new     messageText: arg1 messageText;     wrappedException: arg1;     signalapi: arg1  api := arg1code  ^self response statuscontextClass  ^IceTipWorkingCopyContextactualClass  ^self item value actualClassorigin  ^self remoteNamed: 'origin' ifAbsent: [ IceUndefinedRemote new           name: 'origin';           yourself ]visitAuthenticationError: arg1  self visitGenericError: arg1pullRequest: arg1  pullRequest := arg1addPath: arg1  modifiedFilePaths add: arg1repositoryModel: arg1  repositoryModel := arg1changesFromNoCommit: arg1  ^self packages collect: [:arg2 |  IceImageChange package: arg2 ]fileName: arg1  fileName := arg1hasOutgoingCommitsTo: arg1  ^falseinitializeDialogWindow: arg1  acceptButton := arg1 toolbar okButton.  cancelButton := arg1 toolbar cancelButtonfirstCommit  ^self commitsDo: [:arg1 |  ^arg1 ]isLocalRepository  ^falseworkingCopyState  referenceCommit isCollection ifTrue: [ ^IceInMergeWorkingCopy repository: repository ].  referenceCommit isUnknownCommit ifTrue: [ ^IceUnknownVersionWorkingCopy repository: repository ].  referenceCommit isNoCommit ifTrue: [ ^IceEmptyWorkingCopy repository: repository ].  ^IceAttachedSingleVersionWorkingCopy repository: repositorytreeRoots  ^self tree childrenprintOn: arg1  arg1     nextPutAll: self class name;     nextPutAll: '(';     nextPutAll: self id asString;     nextPutAll: ')'commitsPanel  ^commitsPanelinitializeNextTagPanel  | tmp1 tmp2 tmp3 tmp4 tmp5 tmp6 |  tmp1 := self latestTagParts.  tmp2 := tmp1 first.  tmp1 := tmp1 allButFirst.  tmp6 := [:arg1 |  (arg1 collect: #asString) joinUsing: '.' ].  tmp3 := tmp2 , (tmp6 value: (Array with: tmp1 first + 1 with: 0 with: 0)).  tmp4 := tmp2 , (tmp6 value: (Array with: tmp1 first with: tmp1 second + 1 with: 0)).  tmp5 := tmp2 , (tmp6 value: (Array with: tmp1 first with: tmp1 second with: tmp1 third + 1)).  majorButton := self newButton     label: 'major (' , tmp3 , ')';     action: [ tagNameInputText text: tmp3 ].  minorButton := self newButton     label: 'minor (' , tmp4 , ')';     action: [ tagNameInputText text: tmp4 ].  patchButton := self newButton     label: 'patch (' , tmp5 , ')';     action: [ tagNameInputText text: tmp5 ]resetDataSource: arg1  super resetDataSource: arg1.  arg1 selectAllannounce: arg1  (self isAnnouncementSuspended: arg1) ifTrue: [ ^arg1 asAnnouncement ].  ^super announce: arg1authorText: arg1  authorText := arg1addItem: arg1 into: arg2  arg2 addItemRight: arg1icon  ^self iconNamed: #traitsetModelBeforeInitialization: arg1  repository := arg1actionPanel: arg1  actionPanel := arg1initialize  super initialize.  plainCredentials := Dictionary new.  sshCredentials := Dictionary newhasRemoteNamed: arg1  self remoteNamed: arg1 ifAbsent: [ ^false ].  ^truecommonAncestorWith: arg1  ^self commit commonAncestorWith: arg1defaultBranchSelection  ^self branchModels detect: #isHead ifNone: [ self hasBranches ifTrue: [ self branchModels ifNotEmpty: #anyOne ] ]packageModel  ^packageModelverifyNeedsRefreshOrClose  self model reset.  diffPanel model reset.  diffPanel model isEmpty ifTrue: [ ^self window close ].  self commentPanel clear.  diffPanel basicRefreshaction: arg1  actionBlock := arg1menuSelectionContext  ^self tool newContextaddToPatcher: arg1  (self isMeta and: [ mcDefinition isNil ]) ifTrue: [ ^self ].  arg1 addDefinition: self asMCDefinitiontags  ^self repository tags select: [:arg1 |  arg1 commit = self ]upstreamIfNone: arg1  repository handleLibgitError: [ | tmp1 tmp2 |        tmp1 := self repositoryHandle lookupLocalBranch: self name.        tmp2 := tmp1 upstream.        tmp2 ifNil: [ ^arg1 value ].        ^IceGitRemoteBranch named: tmp2 name inRepository: repository ]fileFormatId: arg1  self properties at: #format put: arg1descriptionWithDecoration  ^self addDecorationTo: (self entity isRemote ifTrue: [ self entity shortName ] ifFalse: [ self name ])selectedItems: arg1  selectedItems := arg1 asSet.  self tableRefreshhasRemoteBranchNamed: arg1  self remoteBranchNamed: arg1 ifPresent: [:arg2 |  ^true ] ifAbsent: [ ^false ]title  ^'Pull requests on {1} ({2})' format: {self remote name .         self remote url}visitMergeAborted: arg1  UIManager default alert: (arg1 messageText ifNil: [ 'Automatic (fast-forward) merge is not possible. Please perform the merge manually, then proceed with your previous operation.WARNING: If you have external files, you may need to verify the conflicts there.' ]) title: 'Automatic merge failed'execute  | tmp1 tmp2 |  tmp1 := self repository branch.  self migrateSources.  tmp2 := self repository branch.  self isMergeWithCurrentBranch ifTrue: [ tmp1 checkout: IceCheckoutDoNotLoadPackages new.        tmp2 merge ]accept: arg1  ^arg1 visitTreeNode: selfreadParametersFromContext: arg1  super readParametersFromContext: arg1.  selectedCommit := arg1 selectedCommitcreateBranch: arg1  ^self createBranch: arg1 inCommit: self headCommitkey  ^operation keyancestors  ^self entity ancestorsbranchName  ^entity branchNameat: arg1 ifAbsentPut: arg2  ^objects at: arg1 ifAbsentPut: arg2versionFor: arg1  ^self commit versionFor: arg1removeFrom: arg1  cacheAllBranches  self remoteBranches do: [:arg1 |  | tmp1 |        tmp1 := arg1 at: 'name'.        branchesByName at: tmp1 ifAbsentPut: [ self remoteBranch: tmp1 ] ]menuSelectionContextWithSelection: arg1  ^self tool newContextWithSelection: arg1menuColumn: arg1 row: arg2  | tmp1 tmp2 |  arg2 = 0 ifTrue: [ ^nil ].  tmp1 := self elementAt: arg2.  tmp2 := self menuSelectionContextWithSelection: tmp1.  ^CmdContextMenuActivation buildContextMenuFor: self table inContext: tmp2acceptError: arg1  arg1 visitCloneLocationAlreadyExists: selftarget: arg1  target := arg1ancestorShortId  ^self entity ancestors first shortIdremoteUrl  | tmp1 |  tmp1 := IceUrlBuilder new     protocol: self selectedProtocol new;     username: self userName project: self projectName.  self configureBuilder: tmp1.  ^tmp1 buildUrlnormalFillStyle  ^Color transparentcanBrowseReferences  ^falseposition  ^position ifNil: [ IceTipItemPosition default ]refresh  changes  ^model ifNotNil: [ model mergeTree children collect: [:arg1 |  IceMergeListWrapper with: arg1 model: model ] ]basicRefresh  self resetDiffContents.  changeList widget     in: [:arg1 |  arg1 selectIndexes: #().        self resetDataSource: arg1 dataSource ];     refreshvalidateCanPushTo: arg1  | tmp1 |  arg1 fetch.  tmp1 := self branch incomingCommitsFrom: arg1.  tmp1 ifEmpty: [ ^self ].  IceRemoteDesynchronized new     asResumable;     remote: arg1;     signaladdFilesToIndex: arg1  self handleLibgitError: [ | tmp1 |        tmp1 := self repositoryHandle index.        tmp1 addAll: (arg1 collect: [:arg2 |  self assert: arg2 asFileReference isRelative.                    arg2 asFileReference path pathString ] as: Array).        tmp1           writeToDisk;           free ]repositoryName  ^self repositoryModel nameisCloneOfUrl: arg1  ^self isMissing not and: [ super isCloneOfUrl: arg1 ]mergeWithLeftNoOperation: arg1  self shouldNotImplementname  ^self entity descriptionbeForMerge  self commitInfoTabs beForMergeicon  self subclassResponsibilityactualClass  ^operation definition actualClasschangesToWorkingCopyTree  self calculateChanges.  ^changesToWorkingCopyTreehasChanges  ^trueunloadFromImageCheckbox: arg1  unloadFromImageCheckbox := arg1protocol  ^protocolchooseButton: arg1  chooseButton := arg1fileSystem  ^FileSystem memory rootaccept: arg1  ^arg1 visitPackage: selfhasTagNamed: arg1  ^self tagNames includes: arg1checkoutOn: arg1  committish commit adopt.  self repository setHead: committishproject  self subclassResponsibilitysearchText: arg1  ^IceTipTreeSearchStrategy searchWith: arg1 dataSource: selfname: arg1  name := arg1sourceDescription  ^'Working Copy version: ' , self repository workingCopy descriptionreferenceCommit  ^repository workingCopy referenceCommitreferenceCommits  ^{self referenceCommit}selectionChanged: arg1  selectedOption := arg1 newSelectedIndexes ifNotEmpty: [:arg2 |  self optionsList widget dataSource elementAt: arg2 first ] ifEmpty: [ nil ].  self refreshDetailPanelhelp  ^super help ifNotNil: [:arg1 |  self target perform: arg1 ]hasOutgoingCommits  self hasUpstream ifFalse: [ ^false ].  ^self hasOutgoingCommitsTo: self upstream remote= arg1  ^super = arg1 and: [ contents = arg1 basicContents ]subscribeToAnnouncements  self announcer when: IceTipDiffEntryRemoved send: #entryRemoved: to: selfdetailPanel: arg1  detailPanel := arg1packageNameText: arg1  packageNameText := arg1status  ^self repositoryModel statuscreateCommandContext  ^self newContextWithSelection: self repositorySelectedisModification  ^falsemigrateSources  | tmp1 |  self repository createBranch: self branchName.  tmp1 := self repository branch commit.  self repository workingCopy packages do: [:arg1 |  self migratePackage: arg1 commit: tmp1 ].  (self repository workingCopy fileSystem resolve: self repository properties propertiesFilePath)     ensureDelete;     binaryWriteStreamDo: [:arg2 |  arg2 nextPutAll: (self repository properties                 fileFormatId: self format;                 contentsString) ].  self repository addFileToIndex: self repository properties propertiesFilePath.  self format = #filetree ifFalse: [ self removeFiletreeRemnants ].  self repository commitIndexWithMessage: 'sources migrated' andParents: {tmp1}readParametersFromContext: arg1  super readParametersFromContext: arg1.  tagModel := arg1 itempackage  ^packagecolorModified  ^Smalltalk ui theme successTextColornextPath  ^IceGitChangeImporter new     path: (RelativePath withAll: path segments allButFirst);     diff: diff;     version: version;     yourselfcheckout: arg1  self workingCopy checkout: arg1path: arg1  path := arg1visitNonConflictingOperation: arg1  ^arg1 chosenOperation accept: selfvalidateLocation  (self location isNil and: [ self remoteToUse isNil ]) ifTrue: [ IceError signal: 'No location/url or remote defined.' ]repository: arg1  repository := arg1changedPackagesToCommitInfo: arg1  ^arg1 packagesshortname  ^self namereducedOutgoingCommitsWhenNoRemote  ^self newCommitWalk     maxNumber: 20;     commitsexecuteWith: arg1  self repositoryModel: arg1.  self executehistoryPanel  ^historyPanelexecute  self packageModel browsePackagerootForItems: arg1  selectedItems := Set new.  self rootItem: (FTRootItem new           data: arg1;           yourself)selectedItems  ^changeList widget dataSource selectedItemsdiscardChanges  self workingCopy discardChangesretrieveStatuses  self statusPanel widget addMorphBack: 'Loading...' asMorph.  [ | tmp1 tmp2 tmp3 |  [ tmp1 := self pullRequest status.  tmp2 := tmp1 at: 'state'.  tmp3 := tmp1 at: 'statuses' ] on: Error do: [:arg1 |  tmp2 := 'Unknown'.        tmp3 := #() ].  UIManager default defer: [ self statusPanel widget           removeAllMorphs;           addMorphBack: (self iconForStatus: tmp2) asMorph;           addMorphBack: tmp2 asMorph.        self checksTable widget dataSource: (IceGitHubPullRequestDataSource elements: tmp3) ] ] forkremoveFrom: arg1  self subclassResponsibility= arg1  ^arg1 species = self species and: [ arg1 description = self description ]execute  self repositoryModel fetchrejectPullRequest  IceGitHubRejectPullRequestModel new     onAccept: [:arg1 |  IceGitHubAPI ensureCredentials.        self pullRequest rejectMessage: arg1 message ];     openWithSpecupdateHead  | tmp1 |  tmp1 := self isFastForward ifTrue: [ repository workingCopy adoptCommit: mergeCommit.        mergeCommit ] ifFalse: [ repository workingCopy setMergeStateBetweenCommits: {self leftCommit .               mergeCommit}.        repository workingCopy commitChanges: self withMessage: 'Merge ' , mergeCommit id asString force: true ].  repository branch commit: tmp1execute  tagModel previewCheckoutnewHeader  ^SimpleButtonMorph new     layoutPolicy: RowLayout new;     listDirection: #leftToRight;     wrapCentering: #center;     hResizing: #spaceFill;     vResizing: #spaceFill;     cellInset: 5 @ 0;     layoutInset: 5 @ 0;     label: self id;     yourselfselectionChanged: arg1  selectedModel := arg1 newSelectedRowIndexes ifNotEmpty: [:arg2 |  self commitList widget dataSource elementAt: arg2 first ] ifEmpty: [ nil ].  self refreshCommitTabPanelrefresh  self leftPanel removeAllMorphs.  self rightPanel removeAllMorphs.  items do: [:arg1 |  arg1 position addItem: (arg1 newToolbarButtonOn: self) into: self ]isSameAs: arg1  ^self subclassResponsibilityexecute  (IceTipMergeBranchDialog on: self repositoryModel) openDialogWithSpecrightDefinition: arg1  oldNode := arg1execute  self repository branch pullFrom: self remote.  self beSuccessmergeStateWith: arg1  ^arg1 mergeWithEmptyWorkingCopyState: selfmodel  ^modelversionFor: arg1  self subclassResponsibilitycredentials  ^credentials ifNil: [ credentials := self class obtainCredentials ]branchesForMerge: arg1  ^self allBranches reject: [:arg2 |  arg2 includesCommit: arg1 ]packageNames  ^#()commitish: arg1  branchCommitish := arg1messageText  ^messageTextbadge  badgeSelector ifNil: [ ^nil ].  ^self model perform: badgeSelectorchosenOperation  ^chosencredentials: arg1  credentials := arg1plaintextCredentials  ^self credentialStore plaintextCredentialForHostname: remote hostrefreshCommitInfo  infoTab contents: (selectedModel info ifNotNil: [ (IceTipReadOnlyForm items: selectedModel info) buildWithSpec ])tracksRemoteBranch  ^self subclassResponsibilitylastCommit  ^self repository backend revparseCommit: self nametype  ^'SSH Keys'visitNoCommitMessage: arg1  self visitGenericError: arg1giveFocusToNextFrom: arg1  super giveFocusToNextFrom: arg1newSelectionMorphFor: arg1  ^CheckboxButtonMorph new     selected: (self isSelected: arg1);     target: [ self toggleSelectionOf: arg1 ];     actionSelector: #value;     yourselfforwardMessage: arg1  ^realObject perform: arg1 selector withArguments: arg1 argumentsremovalHighlightColor  ^super additionHighlightColoriceCommit  ^iceCommitcheckout  checkoutStrategy     committish: self commitish;     diff: diffModel entity.  self commitish checkout: checkoutStrategypackages  ^self commit packagesisConflict  ^item value isConflictaccept: arg1  ^arg1 visitConflictingOperation: selfmergeStateWith: arg1  self subclassResponsibilityloadedVersion  ^self repository workingCopy versionFor: selfisModification  ^trueparseUrl  ^self subclassResponsibilityvisitNoCommitMessage: arg1  | tmp1 |  tmp1 := UIManager default confirm: arg1 messageText label: 'Warning!' trueChoice: 'Commit' falseChoice: 'Cancel' cancelChoice: nil default: false.  tmp1 ifNil: [ ^self ].  tmp1 ifTrue: [ arg1 resume ]fillGroupMenu: arg1 using: arg2 baseline: arg3  | tmp1 |  tmp1 := self newBaselineGroupCommand: arg3.  self fillMenu: arg1 title: ('Install baseline of {1}...' format: {(self nameOfBaseline: arg3)}) command: tmp1 activator: arg2 baseline: arg3visitCloneRemoteNotFound: arg1  UIManager default alert: ('The clone remote {1} could not been found' format: {arg1 remoteUrl}) title: 'Clone action failed'fillContextMenu: arg1 using: arg2  super fillContextMenu: arg1 using: arg2.  remote := arg2 context item model entityiconFor: arg1  ^iconBlock ifNotNil: [ iconBlock value: arg1 ] ifNil: [ nil ]title  ^'Preview checkout of {1}/{2}' format: {self model repositoryName .         self model targetName}initializeWidgets  super initializeWidgets.  diffPanel := self instantiate: IceTipDiffSelectingPanel on: self model workingCopyDiff.  diffPanel leftLabel: 'Repository'.  diffPanel rightLabel: 'Working Copy'.  commentPanel := self instantiate: IceTipCommentPanel on: self model.  commentPanel onCommit: [ self doCommit ].  commentPanel commentText whenBuiltDo: [:arg1 |  self addShortcutsTo: arg1 widget textArea ].  self whenBuiltDo: [:arg1 |  self addShortcutsTo: arg1 widget ].  self focusOrder     add: commentPanel;     add: diffPaneldefaultFormat  ^defaultFormatremotes  self subclassResponsibilitymessage  ^self messageText text asStringallTypes  ^types ifNil: [ types := self createMergeBranchTypes ]newOptionsListDataSource  ^IceTipDataSource new     tool: self;     elements: self model availableRepairOptions;     yourselfrepositoryWillBeCreated: arg1  ^self plugins do: [:arg2 |  arg2 repositoryWillBeCreated: arg1 ]resolve: arg1  ^self resolve: arg1 ifAbsent: [ NotFound signalFor: arg1 ]verifyDirectoryStructureIfMissing: arg1  self entity isMissing ifTrue: [ ^arg1 value: (self toErrorMessage: 'Local repository missing') ]operationIcon  ^operation icondiffTo: arg1  ^IceDiff from: self to: arg1repository  ^repositoryaddProjectFileToChangeBuilder: arg1  | tmp1 |  self isUnborn ifTrue: [ ^self ].  self assert: self projectFilePath size = 1.  tmp1 := self projectFilePath segments first.  arg1 addFileNamed: tmp1 path: self projectFilePath contents: self contentsStringmergeTree  ^IceEmptyNode newvisitMetaclassDefinition: arg1  validateIsBranch  IceNotInBranch signalstatusWithDecoration  | tmp1 |  tmp1 := self status asText.  self entity isLoaded ifFalse: [ tmp1 := tmp1 makeAllColor: self colorNotLoaded ].  ^tmp1repository: arg1  repository := arg1removeBranches: arg1  [ arg1 do: [:arg2 |  self removeBranch: arg2 ] ] on: IceGitHubError do: [:arg3 |  self reportError: arg3 ]projectAsPathToAppend  (self userName isEmpty and: [ self projectName isEmpty ]) ifTrue: [ ^'' ].  ^(self userName ifEmpty: [ '?' ]) , '/' , self projectNameremoveAllCommitPanelTabs  commitTabPanel tabs copy do: [:arg1 |  commitTabPanel removeTab: arg1 ]repository: arg1  repository := arg1formats  ^formatsapi  ^apiinitialize  super initialize.  resumable := falsename: arg1  name := arg1projectFileIn: arg1  ^arg1 fileSystem resolve: self projectFilePathbePositionLeft  self position: IceTipItemPosition leftprivateKeyInput  ^privateKeyInputdelete  repository handleLibgitError: [ | tmp1 |        tmp1 := self repositoryHandle lookupRemoteBranch: self name ifAbsent: [ nil ].        self repositoryHandle deleteBranch: tmp1 ]repository  ^repositorydiffToParent  ^iceCommit diffToParentsetUpstreamIfMissing: arg1  self hasUpstream ifTrue: [ ^self ].  self setUpstream: (arg1 remoteBranchNamed: self gitRef)rightLabel: arg1  (diffPanel respondsTo: #leftLabel:) ifFalse: [ ^self ].  diffPanel rightLabel: arg1removeFrom: arg1  arg1 removePackage: selftextUpdated: arg1  self filterWith: self textField getTextname  self subclassResponsibilityinitializeWidgets  pushCheckbox := self newCheckBox.  self repositoryModel branchModel hasUpstream ifTrue: [ pushCheckbox label: ('Push changes to {1}' format: {self repositoryRemoteName}) ] ifFalse: [ pushCheckbox           label: 'Cannot push new branch automatically. Use the `Push` option';           enabled: false ].  commentText := self newText     autoAccept: true;     whenBuiltDo: [:arg1 |  arg1 widget withGhostText: 'A comment for your commit' ].  actionPanel := self newIceActionPanel.  actionPanel addAction: (commitButton := self newButton           label: 'Commit';           icon: (self iconNamed: #smallOk);           help: ('Commit your changes to {1}' format: {self repositoryName});           yourself).  self focusOrder     add: commentText;     add: commitButton;     add: pushCheckboxhostLabel  ^hostLabelname  ^self fullname withoutPrefix: self prefixkey  ^value keyposition  ^position ifNil: [ IceTipItemPosition perform: self commandClass defaultPosition ]calculateDiff: arg1  | tmp1 |  UIManager default informUser: 'Calculating diff' during: [ tmp1 := arg1 value.        tmp1 build ].  ^tmp1leftContents  self subclassResponsibilityparseLocation: arg1  (#('http:' 'https:') anySatisfy: [:arg2 |  arg1 beginsWith: arg2 ]) ifTrue: [ self parseHTTPLocation: arg1 ] ifFalse: [ self parseSSHLocation: arg1 ]anySatisfy: arg1  (arg1 value: self value) ifTrue: [ ^true ].  self childrenDo: [:arg2 |  (arg2 anySatisfy: arg1) ifTrue: [ ^true ] ].  ^falseaddModification: arg1 toPatcher: arg2  (self isMeta and: [ mcDefinition isNil ]) ifTrue: [ ^self ].  arg2 modifyDefinition: arg1 rightDefinition asMCDefinition to: arg1 leftDefinition asMCDefinitionvalue  ^valuefromTag: arg1  self revwalk.  ^self fromLGitId: (lgitRepository revparse: arg1 name) idprogress  ^min >= max ifTrue: [ 1 ] ifFalse: [ (current - min) / (max - min) ]refresh  self model reset.  self basicRefreshappliesToRepository: arg1  ^self repository = arg1fillMenu: arg1 title: arg2 command: arg3 activator: arg4 baseline: arg5  | tmp1 tmp2 |  tmp1 := arg4 newForCommand: arg3.  tmp2 := arg1 add: arg2 target: tmp1 selector: #executeCommand.  arg3 setUpIconForMenuItem: tmp2.  arg3 description ifNotNil: [:arg6 |  tmp2 setBalloonText: arg6 ]resetDiff  diff := nilport  ^port ifNil: [ self class defaultPort ]switchAndMergeThen: arg1  < noCache>  IceTipStandardAction new     repository: self entity repository;     message: ('Merging branch {1} from {2}' format: {self name .               self repositoryName});     onSuccessRepositoryModified;     onSuccess: arg1;     execute: [ self entity switchAndMergeWorkingCopy ]initializeWidgets  super initializeWidgets.  commitsPanel := self instantiate: IceTipHistoryBrowser on: self model.  actionPanel := self newIceActionPanel.  actionPanel addAction: (button := self newActionButton).  self whenBuiltDo: [:arg1 |  self addShortcutsTo: arg1 widget ]isRemote  ^falsechangedFilesBetween: arg1 and: arg2  self handleLibgitError: [ | tmp1 tmp2 tmp3 |        tmp1 := (LGitCommit of: self repositoryHandle fromHexString: arg1 id) tree.        tmp2 := (LGitCommit of: self repositoryHandle fromHexString: arg2 id) tree.        tmp3 := tmp1 diffTo: tmp2.        ^tmp3 files ]title  ^'Preview merge of {1}/{2}' format: {self model repositoryName .         self model targetName}position: arg1  position := arg1propertyFileExtension  ^MCFileTreeRepository defaultPropertyFileExtensionicon  ^self iconNamed: #openprojectNameInputText  ^projectNameInputText= arg1  ^arg1 isNoCommitfindVersionInfo  | tmp1 tmp2 tmp3 |  (self class lastCommitFound notNil and: [ self class lastCommitFound id = commitId ]) ifTrue: [ tmp3 := self class lastCommitFound.        tmp1 := tmp3 repository ] ifFalse: [ tmp2 := IceGitRemote url: remoteUrl.        tmp1 := IceRepository registry detect: [:arg1 |  arg1 remotes anySatisfy: [:arg2 |  arg2 referencesSameRemoteLocationAs: tmp2 ] ] ifNone: [ ^nil ].        tmp3 := tmp1 lookupCommit: commitId.        tmp3 ifNil: [ IceError signal: ('Your repository seems to be out of sync.!Please fetch from "{1}" and try again.' format: {tmp2}) ].        self class lastCommitFound: tmp3 ].  ^IceMCVersionInfo new fromCommit: tmp3 package: (IcePackage named: packageName repository: tmp1)initializeToolbar  toolbar := self newIceToolbar.  self rebuildToolbarvalidate  self assert: self remoteName notEmpty description: 'You need to specify a remote name.'.  self assert: self remoteUrl notEmpty description: 'You need to specify a remote url.'commitTabPanel  ^commitTabPanelpassword  ^password ifNil: [ password := '' ]branchModels  ^self branches collect: [:arg1 |  (IceTipBranchModel repositoryModel: self repositoryModel on: arg1) beCached ]locationIfPresent: arg1  ^self locationIfPresent: arg1 ifAbsent: [ self ]imageCommit  ^imageCommit ifNil: [ imageCommit := repository workingCopy referenceCommit ]credentials: arg1  credentials := arg1changed  current >= max ifTrue: [ ^Job jobAnnouncer announce: (JobEnd on: self) ].  Job jobAnnouncer announce: (JobChange on: self)availablePluginsFor: arg1  ^(IcePlugin allAvailableFor: arg1) collect: #new as: ArraycanActivateCommand: arg1  ^arg1 actsOnRemote: selfdescription  ^'Metacello install operations'hasConflicts  ^self model mergeTree anySatisfy: [:arg1 |  arg1 isConflict ]addPlugin: arg1  plugins := plugins copyWith: arg1headLabel: arg1  headLabel := arg1adopt  self repository workingCopy adoptCommit: selfheadDescription  ^[ super headDescription ] on: Error do: [ 'Bad location' ]remotePanel  ^remotePanel= arg1  ^self species = arg1 species and: [ self name = arg1 name ]initialExtent  ^(700 @ 500) scaledByDisplayScaleFactordoAccept  self subclassResponsibilitykey  self subclassResponsibilityisEmpty  ^tree isEmptyrepository: arg1  repository := arg1colorWarning  ^Smalltalk ui theme warningTextColornewInfoTab  ^self newTab     label: 'Info';     icon: (self iconNamed: #smallQuestion);     closeable: false;     yourselfcommitId  ^self entity commit idmessageBody  ^'Credentials provided are wrong'merge  self mcVersion mergeid: arg1  id := arg1isDirty  ^self isLoaded and: [ isDirty ifNil: [ isDirty := false ] ]fetchAllRemotes  | tmp1 |  tmp1 := self repository remotes.  UIManager default informUserDuring: [:arg1 |  arg1 label: 'Fetching incoming commits'.        arg1 max: tmp1 size.        arg1 value: 1.        tmp1 withIndexDo: [:arg2 :arg3 |  arg1 label: ('Fetching incoming commits of {1}' format: {arg2 name}).              arg1 value: arg3 + 1.              self repository fetchFrom: arg2 ] ]confirmLabel: arg1  confirmLabel := arg1delete  super delete.  handle := nil.  self locationIfPresent: [:arg1 |  arg1 ensureDeleteAll ]backwardsCompatibleFormat  ^TIceRepositoryWriter users detect: #isLegacyDefault ifNone: [ Smalltalk at: #IceLibgitFiletreeWriter ]diff  ^diff ifNil: [ diff := committish diffTo: self workingCopy ]format  ^formatBlockreferencesSameRemoteLocationAs: arg1  ^(self url withoutSuffix: '.git') sameAs: (arg1 url withoutSuffix: '.git')fileSystem  ^(FileSystem onGitCommit: self libgitCommit) rootreset  properties: arg1  properties := arg1name  ^self entity namechangedPackagesToWorkingCopy: arg1  | tmp1 tmp2 tmp3 tmp4 |  self flag: #refactor.  tmp1 := arg1 packageNames.  tmp2 := self packageNames.  tmp3 := tmp1 \ tmp2 collect: [:arg2 |  IcePackage named: arg2 repository: self repository ].  tmp4 := tmp2 \ tmp1 reject: [:arg2 |  self packageNames includes: arg2 ] thenCollect: [:arg2 |  IcePackage named: arg2 repository: self repository ].  ^tmp3 , ((arg1 modifiedPackages reject: [:arg3 |  tmp1 \ tmp2 includes: arg3 name ]) collect: [:arg4 |  IcePackage named: arg4 name repository: repository ] as: Array) , tmp4initializeDirectoryTree  | tmp1 |  tmp1 := self newDirectoryDataSource.  sourceDirectoryTree widget     addColumn: (IceTipTableColumn newAction: #name icon: [:arg1 |  self iconNamed: #package ]);     dataSource: tmp1;     onAnnouncement: FTSelectionChanged do: [:arg2 |  self sourceDirectorySelectionChanged: arg2 newSelectedIndexes ]proxy: arg1  proxy := arg1newCommitWalk  self subclassResponsibilitycheckoutNewBranchNamed: arg1 inCommit: arg2 thenDo: arg3  < noCache>  IceTipStandardAction new     repository: self entity;     message: ('Checking out new branch {1}' format: {arg1});     onSuccessRepositoryModified;     execute: [ | tmp1 |        tmp1 := self entity createBranch: arg1 inCommit: arg2.        arg3 value: tmp1 ]initializeWidgetsContents  self initializeCurrentBranchLabel.  branchLabel := self newLabel label: 'New branch'.  branchInputText := self newTextInput     autoAccept: true;     ghostText: 'e.g., feature/what'.  spacePanel := PanelMorph new asSpecAdaptervisitClassDefinition: arg1  | tmp1 tmp2 |  tmp1 := self ensureMethodOwnerNamed: arg1 className isMeta: false isTrait: false isExtension: false.  tmp1 value mcDefinition: arg1.  tmp2 := self ensureMethodOwnerNamed: arg1 className isMeta: true isTrait: false isExtension: false.  tmp2 value mcDefinition: arg1.  ^tmp1item  ^self repositoryModelnewRepository  ^self subclassResponsibilityinitializeSpacePanel  spacePanel := self newIcePanelrepository: arg1  repository := arg1printOn: arg1  arg1 << self class name << '(' << packageName << ')'categories  ^categorieschangesTo: arg1  ^arg1 changesFromNoCommit: selfbeForMerge  headTabContainer := IceTipHistoryDiffToHead tab: headTab.  ancestorTabContainer := IceTipHistoryDiffToAncestor tab: ancestorTabprojectNameInputText: arg1  projectNameInputText := arg1acceptButton: arg1  acceptButton := arg1doMerge  self model executeMergeActionAndThen: [ self window delete ]commitIndexWithMessage: arg1 andParents: arg2  | tmp1 |  tmp1 := index commitWithMessage: arg1 andParents: arg2.  index := self newIndex.  self workingCopy referenceCommit: tmp1.  self workingCopy refreshDirtyPackages.  ^tmp1mergeStateWith: arg1  ^arg1 mergeWithSingleVersionWorkingCopyState: selfremoteUrl: arg1 packageName: arg2 commitId: arg3 stub: arg4  remoteUrl := arg1.  packageName := arg2.  commitId := arg3.  stubVersionInfo := arg4configureBuilder: arg1  self subclassResponsibilitysnapshot  ^self mcSnapshotoutgoingCommits  ^self repository branch outgoingCommits: [:arg1 |  arg1 modifyingPackage: self ]contextClass  ^IceTipPushContextentryByPath: arg1  repository handleLibgitError: [ ^(LGitCommit of: self repositoryHandle fromHexString: self id) entryByPath: arg1 ]revwalk  repository handleLibgitError: [ ^revwalk ifNil: [ lgitRepository := self repositoryHandle.              revwalk := LGitRevwalk of: self repositoryHandle ] ]initializeRepository: arg1  self initialize.  plugins := self availablePluginsFor: arg1retrieveHistory  self repositoryModel checkMissing.  UIManager default informUser: ('Retrieving history of {1}' format: {self entity printString}) during: [ ^self repositoryModel entity log historyOfMethod: self entity ]isDirty  ^repository workingCopy referenceCommit properties ~= selftree  ^self diff treeToShowcancelAction  ^self subclassResponsibilityinitialize  actions := OrderedCollection new.  super initializetimeSinceLastCommit: arg1  | tmp1 tmp2 tmp3 |  tmp1 := arg1 at: 'name'.  tmp2 := branchesByName at: tmp1.  tmp3 := ((((tmp2 at: 'commit') at: 'commit') at: 'author') at: 'date') asDateAndTime.  ^'{1} days' format: {(Date today - tmp3) days}author  ^self subclassResponsibilityfetchBranch: arg1  localRepository handleLibgitError: [ [ | tmp1 tmp2 |        tmp1 := LGitRefSpec fromString: ('{2}:refs/remotes/{1}/{2}' format: {self name .                     arg1 name}).        (tmp2 := LGitRemote of: self repositoryHandle named: self name)           lookup;           fetchWithCredentials: (IceCredentialsProvider defaultForRemote: self) refSpec: tmp1 ] on: LGitAbstractError do: [:arg2 |  arg2 acceptError: (IceLibgitErrorVisitor onContext: self) ] ]isSame: arg1  ^(self referencesSameRemoteLocationAs: arg1) and: [ self name = arg1 name ]repositoryHandle  < repositoryHandleAccessor>  (handle isNil or: [ handle isNull ]) ifTrue: [ handle := (LGitRepository on: self location) open ].  ^handleaddItem: arg1 into: arg2  self subclassResponsibilityaddItemRight: arg1  self rightPanel addMorphBack: arg1initialize  super initialize.  repositoryDetached := falseplaintextCredentialForHostname: arg1  ^self lookup: arg1 in: plainCredentials ifAbsent: [ IcePlaintextCredentials new ]packageName  ^self package nameheadBranchList: arg1  headBranchList := arg1parseMorePages: arg1  arg1 ifNil: [ ^false ].  ^(arg1 substrings: ',') anySatisfy: [:arg2 |  arg2 includesSubstring: 'rel="next"' ]versions  ^self repository branch versionsFor: selfbasicExecute  UIManager default informUser: 'Pushing...' during: [ self repository push ].  Iceberg announcer announce: (IceRepositoryModified for: self repository)diffFromHead  ^self repository headCommit diffTo: selfensureDirectoryNamed: arg1 inNode: arg2  arg2 childAt: arg1 ifPresent: [:arg3 |  self assert: arg3 value isDirectoryDefinition.        ^arg3 ].  ^arg2 addChild: (IceDirectoryDefinition named: arg1)repositoryWasCreated: arg1  credentials  ^IcePlaintextCredentials new     username: self username;     password: self password;     yourselfchooseTitle: arg1  chooseTitle := arg1icon  ^self iconNamed: #changeAddexpandAll  changeList widget dataSource     rootForItems: self model treeRoots;     expandAll;     selectAllstatusPanel: arg1  statusPanel := arg1showEmptyTab  emptyTab ifNil: [ emptyTab := self newEmptyTab ].  self removeAllCommitPanelTabs.  commitTabPanel addTab: emptyTabpriority  ^1initialExtent  ^(500 @ (self class inputTextHeight * 2 + self class buttonHeight + 50)) scaledByDisplayScaleFactorcredentials  ^credentialexecute  self repositoryModel reset.  self announcer announce: (IceTipDiffRefreshed for: self repositoryModel entity)branch  self head validateIsBranch.  ^self headinitializeLocation: arg1  location := arg1.  self initializerepository  ^committish repositoryexecute  | tmp1 tmp2 tmp3 |  tmp1 := SettingBrowser new     changePackageSet: {#Iceberg asPackage .         #'Iceberg-Libgit' asPackage};     yourself.  tmp2 := tmp1 open.  tmp3 := (tmp2 submorphs detect: [:arg1 |  arg1 isKindOf: MorphTreeMorph ]) nodeList.  tmp1 expandNodePath: tmp3 first contents first contents first pathcommitModels  | tmp1 |  tmp1 := OrderedCollection new.  self entity commitsDo: [:arg1 |  tmp1 add: (IceTipCommitModel repositoryModel: self repositoryModel on: arg1) beCached ].  ^tmp1beCached  ^IceTipCachedModel for: selfleftDefinition  ^definitiontree  ^self mergeTreesubPackageFileDirectoryFor: arg1  ^self packageFileDirectory entryByPath: arg1workingCopyDiff  ^self workingCopy diffToReferenceCommitrepository: arg1  repository := arg1action  ^actionBlockmouseLeave: arg1  self currentHand showTemporaryCursor: nilconfigureBuilder: arg1  arg1 beGitLabhost: arg1  host := arg1visitGenericError: arg1  (IceTipErrorDialog on: arg1) openDialogWithSpecisEmptyNode  ^falseactionPanel: arg1  actionPanel := arg1readParametersFromContext: arg1  super readParametersFromContext: arg1.  remoteModel := arg1 itemtargetVersion: arg1  target := arg1remoteInputText  ^remoteInputTextinternalStoreVersion: arg1  self writerClass forInternalStoreFileOut: arg1 on: selfsetModelBeforeInitialization: arg1  model := arg1printOn: arg1  arg1 << self major asString << '.' << self minor asString << '.' << self patch asStringurl: arg1  url := arg1hasOutgoingCommits  ^self branch hasOutgoingCommitsiconWidget  ^iconWidgetexecute  self subclassResponsibilitymcPackage  ^MCPackage named: self packageNamesubdirectory: arg1  subdirectory := arg1onAccept: arg1  acceptCallback := arg1initializeWidgets  self initializeToolbar.  self whenBuiltDo: [:arg1 |  self addShortcutsTo: arg1 widget ]traversingDo: arg1  ^self traversingDo: arg1 parents: #()execute  (IceTipRemoveRepositoryDialog on: self repositoryModel) openDialogWithSpeccommitModelFor: arg1  ^(IceTipCommitModel repositoryModel: self on: arg1) beCachedmetacelloAdapter: arg1  ^IceMetacelloRepositoryAdapter for: self withVersion: arg1remove  < noCache>  IceTipStandardAction new     repository: self entity repository;     message: ('Removing package {1}' format: {self entity name});     onSuccessRepositoryModified;     execute: [ Iceberg announcer suspendAllForRepository: self entity repository while: [ self entity remove ] ]versionFrom: arg1  | tmp1 tmp2 tmp3 |  tmp1 := (MCFileTreeRepository parseName: arg1) first.  tmp2 := self repository packageNamed: tmp1.  tmp3 := tmp2 latestVersion.  tmp3 info name = arg1 ifFalse: [ tmp3 := tmp2 versions detect: [:arg2 |  arg2 info name = arg1 ] ].  ^tmp3 mcVersioninitialize  self model: IceTipRepositoriesModel new.  super initializeincludesCommit: arg1  self commitsDo: [:arg2 |  arg2 id = arg1 id ifTrue: [ ^true ] ].  ^falseitem  ^IceTipEntityModel on: credentialvisitRemoteAlreadyExistError: arg1  self visitGenericError: arg1buildTree  self children keysAndValuesDo: [:arg1 :arg2 |  arg2 hasChanges ifTrue: [ self builder addEntry: arg2 buildTree filename: arg1 ] ].  ^self builder newTreeacceptPullRequest  IceGitHubAcceptPullRequestModel new     onAccept: [:arg1 |  IceGitHubAPI ensureCredentials.        self pullRequest acceptMessage: arg1 message type: arg1 type ];     openWithSpecicon  ^iconexecute  | tmp1 |  tmp1 := IceTipTreeGroup new.  self dataSource rootItem children do: [:arg1 |  arg1 data traversingDo: [:arg2 |  arg2 isLeaf ifTrue: [ (self matches: arg2) ifTrue: [ (tmp1 ensurePath: arg2 path allButLast) addChild: arg2 ] ] ] ].  tmp1 children do: [:arg2 |  arg2 parent: nil ].  ^self dataSource copy     rootForItems: tmp1 children;     yourselfvisitTraitDefinition: arg1  | tmp1 |  tmp1 := self ensureMethodOwnerNamed: arg1 className isMeta: false isTrait: true isExtension: false.  tmp1 value mcDefinition: arg1.  ^tmp1packagesFrom: arg1  self repository handleLibgitError: [ | tmp1 tmp2 |        tmp1 := self writerClass.        tmp2 := arg1 fileSystem resolve: self sourceDirectory.        tmp2 exists ifFalse: [ ^#() ].        ^tmp2 children select: [:arg2 |  tmp1 isValidPackage: arg2 ] thenCollect: [:arg2 |  | tmp3 |              tmp3 := tmp1 packageNameFromDirectory: arg2 basename.              IcePackage named: tmp3 repository: self repository ] ]accept  self removeFileSystemCheckbox state ifTrue: [ self model delete ] ifFalse: [ self model forget ]visitGenericError: arg1  arg1 passorganizer  ^'local'items: arg1  items := arg1repositoryHandle  < repositoryHandleAccessor>  ^repository repositoryHandleisMerged  ^self repository workingCopy isCommitMerged: selfshortname  ^self name withoutPrefix: self remoteName , '/'passphraseInput  ^passphraseInputpackages  ^self packagesDictionary valuesinitWithContents: arg1 font: arg2 emphasis: arg3  super initWithContents: arg1 font: arg2 emphasis: arg3.  self     addEmphasis: TextEmphasis underlined;     on: #click send: #execute to: self;     on: #mouseEnter send: #mouseEnter: to: self;     on: #mouseLeave send: #mouseLeave: to: selfconfigureButton: arg1 item: arg2  arg1 on: arg2 getState: nil action: #execute label: #label icon: nil menu: nilrawResultsDo: arg1  self revwalk select: [:arg2 |  self shouldInclude: arg2 ] thenDo: arg1refreshFocusOrder  self focusOrder     removeAll;     add: self typeList;     add: self selectedType;     add: acceptButton;     add: cancelButtonpackageName  ^self package nameisTraitDefinition  ^falsecellIndentFor: arg1  ^arg1 depth * 16mouseLeave: arg1  self currentHand showTemporaryCursor: nil.  super mouseLeave: arg1accept: arg1  ^arg1 visitTraitDefinition: selfcanReadProjectFromCommitish: arg1  ^(arg1 fileSystem / '.project') existscredentials  ^IceSshCredentials new     username: self username;     publicKey: self publicKey;     privateKey: self privateKey;     keyPassphrase: self passphrase;     yourselfdrawKeyboardFocusOn: arg1  getGitHubRepository  [ ^IceGitHubAPI new     beAnonymous;     getRepository: self userName project: self projectName ] on: LGitNoCredentialsProvided do: [ ^nil ]spacePanel  ^spacePanelmodel: arg1  model := arg1.  self refreshaddPackageNamed: arg1  self addPackage: (IcePackage named: arg1 asSymbol repository: repository) beDirtymcSnapshotInRepository  ^self repository branch snapshotFor: selfnewLabel: arg1  ^self newPanelMorph     listDirection: #rightToLeft;     cellPositioning: #center;     addMorph: ((LabelMorph newLabel: arg1)           color: self labelColor;           yourself);     asSpecAdapterlog  ^self logClass for: selfnewCommitWalk  ^IceLibgitCommitWalk forRepository: selftoCommit  ^toCommitinitializeWidgets  super initializeWidgets.  credentialsList := self newIceTable.  self initializeCredentialsList.  self focusOrder add: credentialsListexception  ^exceptionnameLabel: arg1  nameLabel := arg1title  ^self model ifNotNil: [ 'Versions of {1}' format: {self model name} ] ifNil: [ 'Versions' ]remoteLabel  ^remoteLabelrootNode  ^self parent rootNodebaseBranchName: arg1  baseBranchName := arg1loadedPackages  ^self workingCopy loadedPackagesrepository  ^self repositoryModel entitybasepathOf: arg1  ^arg1 copyAfterLast: $/fromHead  self revwalk pushHeaddoesNotUnderstand: arg1  self flag: #todo.  self model ifNil: [ ^super doesNotUnderstand: arg1 ].  ^arg1 sendTo: self modelremote: arg1  remote := arg1priority  ^100000updateLocation: arg1  self entity location: arg1.  self entity postFetch.  Iceberg announcer announce: (IceRepositoryModified for: self entity)location: arg1  location := arg1snapshotWriterClass  ^IceMetadatalessStCypressWriterviewPullRequest: arg1  UIManager default informUser: ('Opening pull request {1} {2}' format: {arg1 number .               arg1 title}) during: [ (IceGitHubTipPullRequestBrowser on: self model pullRequest: arg1) openWithSpec ]start  started := true.  Job jobAnnouncer announce: (JobStart on: self)remoteBranchNames  ^self remoteTrackedBranches collect: #nameapplyDefinition: arg1 inNode: arg2  | tmp1 |  (arg1 isFileDefinition or: [ arg1 isDirectoryDefinition ]) ifTrue: [ ^self ].  tmp1 := MCPackageLoader new.  tmp1 addDefinition: arg1 asMCDefinition.  tmp1 loadallPackagesNotRegistered  | tmp1 |  tmp1 := self model packages collect: #packageName.  ^self allPackages reject: [:arg1 |  tmp1 includes: arg1 name ]execute  (IceTipAddRemoteDialog on: self repositoryModel) openDialogWithSpecpullRequest  ^pullRequesthelp  ^helphostDescription  ^hostinitializeWidgets  titleLabel := self newLabel.  titlePanel := self newTextInput autoAccept: true.  headLabel := self newLabel.  headForkList := self newDropList.  headBranchList := self newDropList.  baseLabel := self newLabel.  baseForkList := self newDropList.  baseBranchList := self newDropList.  bodyLabel := self newLabel.  bodyPanel := self newText autoAccept: true.  addButton := self newButton.  titleLabel label: 'Title'.  headLabel label: 'From (Head)'.  baseLabel label: 'To (Base)'.  bodyLabel label: 'Comment'.  addButton label: 'Create pull request'.  addButton action: [ self accept ].  self focusOrder     add: titlePanel;     add: headForkList;     add: headBranchList;     add: baseForkList;     add: baseBranchList;     add: bodyPanel;     add: addButtondefaultHeadBranchName  ^self branch shortnameobtainRepositoryName  ^self location basenamemergeWithLeftAddition: arg1  arg1 definition = self definition ifTrue: [ ^IceNonConflictingOperation operation: arg1 ].  ^IceConflictingOperation left: arg1 right: self= arg1  ^super = arg1 and: [ self contents = arg1 contents ]unresolvedConflictCount  ^mergeTree count: [:arg1 |  arg1 isConflict and: [ arg1 isResolved not ] ]project  ^repository newUnbornProjectinitializeWidgets  contentPanel := self emptyPanel asSpecAdapter.  typeList := self newIceTable.  self initializeTypeList.  self whenBuiltDo: [:arg1 |  self addShortcutsTo: arg1 widget.        self selectFirst ].  self eventKeyStrokesForNextFocus do: [:arg2 |  typeList widget bindKeyCombination: arg2 toAction: [ self giveFocusToNextFrom: typeList ] ].  self eventKeyStrokesForPreviousFocus do: [:arg2 |  typeList widget bindKeyCombination: arg2 toAction: [ self giveFocusToPreviousFrom: typeList ] ].  self refreshFocusOrderremoteBranch: arg1  ^self requestRemoteBranch: arg1diffPanel: arg1  diffPanel := arg1leftDefinition: arg1  definition := arg1switchToBranchNamed: arg1  ^(self branchNamed: arg1)     switch;     yourselfbasicContents: arg1  contents := arg1execute  version installtype  ^'Plain Text'remote  ^remotefileSystem  ^repository location ifNil: [ FileSystem memory root ]item: arg1  item := arg1datetime: arg1  datetime := arg1newActionButton  ^self newButton     label: 'Checkout';     icon: (self iconNamed: #branch);     help: ('Checks out {1} into your image.' format: {self model targetName});     action: [ self doCheckout ];     yourselfparseUrl  | tmp1 |  tmp1 := ZnUrl fromString: url defaultScheme: 'file'.  path := tmp1 asFileReference.  projectName := path basenameinstall  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Installing {1} - {2}' format: {self entity definition .               self name});     onSuccessRepositoryModified;     execute: [ self basicInstall ]newDiffPanelFor: arg1  ^IceTipDiffPanel on: arg1branchInputText  ^branchInputTextrepository  ^repositorydelete  repository handleLibgitError: [ | tmp1 |        tmp1 := self repositoryHandle lookupLocalBranch: self name ifAbsent: [ nil ].        self repositoryHandle deleteBranch: tmp1 ]cancelAction  accepted := true.  self window close.  LGitNoCredentialsProvided signallatestVersion  ^self versionFor: self repository head commitmatches: arg1  ^falseaccept: arg1  ^arg1 visitAddition: selfhasLocalBranchNamed: arg1  ^self branchNamed: arg1 ifPresent: [:arg2 |  true ] ifAbsent: [ false ]checksTable: arg1  checksTable := arg1addItemRight: arg1  self rightPanel addMorphBack: (self prepareItemToAdd: arg1)detailPanel  ^detailPanelcreateBranch: arg1 inCommit: arg2  self subclassResponsibilityselectedCommit  ^self item commitallBranches  ^self localBranches , self remoteTrackedBranchesbranches  ^self entity branchesmessageLabel: arg1  messageLabel := arg1acceptError: arg1  arg1 visitCloneRemoteNotFound: selfhasNoLoadConflicts: arg1  (arg1 isKindOf: self class) ifFalse: [ ^false ].  ^self projectPath = arg1 projectPath and: [ self repoPath = arg1 repoPath and: [ self projectVersion = arg1 projectVersion ] ]isExtension: arg1  snapshot classDefinitionNamed: arg1 ifAbsent: [ ^true ].  ^falseeditModelClass  ^IceTipEditSSHCredentialsModelisSameAs: arg1  ^arg1 species = self species and: [ self model = arg1 model ]selectLeft  chosen := leftOperationisLoadable  ^self contextClass notNilrefresh  repositoryList widget     in: [:arg1 |  arg1 dataSource elements: self model repositories ];     refreshicon  ^self iconNamed: #groupleftLabel: arg1  (diffPanel respondsTo: #leftLabel:) ifFalse: [ ^self ].  diffPanel leftLabel: arg1proxy  ^proxynewRequestTo: arg1  ^ZnClient new     in: [:arg2 |  isAnonymous ifFalse: [ arg2 username: self credentials username password: self credentials password ] ];     headerAt: 'Accept' put: 'application/vnd.github.v3+json';     url: 'https://api.github.com/' , (arg1 first = $/ ifTrue: [ arg1 allButFirst ] ifFalse: [ arg1 ]);     yourselfacceptButton  ^acceptButtonaccept  self window delete.  exception debugchangesTo: arg1  ^self commit changesTo: arg1isUnborn  ^falsestorePlaintextCredential: arg1 forHostname: arg2  plainCredentials at: arg2 put: arg1beGithub  self host: 'github.com'ensurePath: arg1  | tmp1 tmp2 |  tmp1 := arg1 first.  tmp2 := self children detect: [:arg2 |  arg2 isSameAs: tmp1 ] ifNone: [ self addChild: (tmp1 copy children: OrderedCollection new) ].  ^arg1 allButFirst ifNotEmpty: [:arg3 |  tmp2 ensurePath: arg3 ] ifEmpty: [ tmp2 ]snapshot: arg1  snapshot := arg1hasUpstream  ^falseexecute  selectedBranch resetToCommit: selectedCommitish.  Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity)initializeRemoteURL  remoteLabel := self newLabel label: 'Remote URL'.  remoteInputText := self newTextInput     ghostText: 'e.g., git@github.com:user/MyProject.git';     autoAccept: truecommitModelAfter: arg1  ^self commitModels after: arg1 ifAbsent: [ nil ]initialize  super initialize.  accepted := falsesubscribeToAnnouncements  Iceberg announcer weak when: IceRepositoryAnnouncement send: #refreshWhenRepository: to: selfdoAccept  self validate.  self model checkoutNewBranchNamed: self branchName inCommit: (branchCommitish ifNil: [ self model entity workingCopy referenceCommit ]) thenDo: [:arg1 |  callback ifNotNil: [ callback value: arg1 ] ]statusLabel: arg1  statusLabel := arg1trackedBranch  self subclassResponsibilityisRoot  ^self parent isNildetail  ^detail ifNil: [ detail := IceGitHubAPI new get: ((self jsonAt: #url) allButFirst: 23) ]readParametersFromContext: arg1  super readParametersFromContext: arg1.  version := arg1 versionupdateWorkingCopy  repository workingCopy loadChangesInWorkingCopy: self changesToWorkingCopyTree.  repository workingCopy refreshDirtyPackagesnewRepository  | tmp1 |  tmp1 := super newRepository.  UIManager default informUser: 'Configuring Remotes...' during: [ | tmp2 |        tmp2 := self getGitHubRepository.        tmp2 ifNil: [ ^tmp1 ].        (tmp2 at: #fork) ifTrue: [ | tmp3 tmp4 |              tmp3 := tmp2 at: #parent.              tmp4 := IceGitRemote name: ((tmp3 at: #owner) at: #login) url: (tmp3 at: self selectedProtocol githubRequestUrlKey).              tmp1 addRemote: tmp4.              tmp4 fetch ] ].  ^tmp1remoteList  ^remoteListimportOn: arg1  | tmp1 tmp2 tmp3 |  (version includesPackageNamed: self packageName) ifFalse: [ ^self ].  tmp3 := IcePackageDefinition named: self packageName.  tmp1 := arg1 addChild: tmp3.  tmp3 path: tmp1 path.  tmp2 := self snapshot.  tmp2 definitions do: [:arg2 |  arg2 accept: (IceMCDefinitionImporter new                 packageNode: tmp1;                 snapshot: tmp2;                 yourself) ].  ^tmp1newMergeablePanel  ^PanelMorph new     color: Color transparent;     layoutPolicy: TableLayout new;     listDirection: #leftToRight;     cellInset: 5;     vResizing: #spaceFill;     hResizing: #spaceFill;     asSpecAdaptertraversingDo: arg1 parents: arg2  arg1 cull: self cull: arg2requestBaseBranches  ^IceGitHubAPI new     credentials: self credentials;     getBranches: self baseRemote owner project: self baseRemote projectBasenamewithoutLocalRepository  types := self allTypes reject: #isLocalRepository.  typeList widget dataSource elements: types.  typeList widget refreshdiffToWorkingCopyForPackages: arg1  ^IceDiff new     sourceVersion: self;     targetVersion: self repository workingCopy;     buildForPackages: arg1addPackages: arg1  IceTipStandardAction new     repository: self entity;     message: 'Adding packages';     onSuccessRepositoryModified;     execute: [ arg1 do: [:arg2 |  self entity workingCopy addPackageNamed: arg2 name ] ]isTraitDefinition  ^trueemail  ^self emailInput text trimBothcommentText  ^commentTexthelp: arg1  help := arg1iconPanel  ^iconPanelreadProjectFromCommitish: arg1  | tmp1 tmp2 |  tmp2 := arg1 fileSystem / '.project'.  tmp1 := tmp2 binaryReadStreamDo: [:arg2 |  STON fromStream: (ZnCharacterReadStream on: arg2 encoding: 'utf8') ].  ^IceBasicProject onProperties: tmp1 commitish: arg1isNoCommit  ^falseaccept  button performActionlookupCommit: arg1 ifAbsent: arg2  ^[ self revparse: arg1 ] on: NotFound do: arg2originMethod  ^(Smalltalk at: self definition methodClass name) >> self definition selectorinitialize  super initialize.  url := 'No remote url'.  projectName := 'No name'.  name := 'No remote'remotePanel  ^remotePanelcommitish  ^commitishisAddition  ^falsereadFrom: arg1  self username: arg1 username.  self password: arg1 passwordhandlesMouseDown: arg1  ^truepath  ^path ifNil: [ path := OrderedCollection new ]selectedPullRequest  | tmp1 |  tmp1 := self pullRequests widget.  ^tmp1 dataSource elementAt: tmp1 selectedRowIndexrepositoryRemoteName  ^self repositoryModel pushRemoteNameinit  (LGitRepository on: self location) inituserNameLabel: arg1  userNameLabel := arg1tool: arg1  tool := arg1checkoutWithStrategy: arg1 then: arg2  < noCache>  IceTipStandardAction new     repository: self entity repository;     message: ('Checking out branch {1} from {2}' format: {self name .               self repositoryName});     onSuccessRepositoryModified;     onSuccess: arg2;     execute: [ self entity checkoutWithStrategy: arg1 ]description  ^self commit descriptionitemNameWithoutBranches  ^'Open on github'headBranchName  ^headBranchNamedescription  self subclassResponsibilitycredentialStore  ^IceCredentialStore currentunloadPackage: arg1  arg1 mcWorkingCopy ifNotNil: #unloadrightContents  ^rightOperation leftContentscommitsInPackageCache  ^commitsInPackageCache ifNil: [ commitsInPackageCache := LRUCache new maximumWeight: 30 ]isHead  ^self entity isHeadvisitRootDefinition: arg1  self visitChildrenOf: currentNoderepositoryModelsByGroup  | tmp1 tmp2 |  tmp1 := self allBranchModels.  tmp2 := self tagModels.  ^{((IceTipTreeRepositoryGroup on: self)     name: 'Branches';     icon: (self iconNamed: #branch);     children: (tmp1 select: [:arg1 |  arg1 entity isLocal ] thenCollect: [:arg1 |  IceTipTreeBranch on: arg1 ]);     yourself) .   ((IceTipTreeRepositoryGroup on: self)     name: 'Remotes';     icon: (self iconNamed: #remote);     children: (self entity remotes collect: [:arg2 |  | tmp3 |              tmp3 := (IceTipRemoteModel repositoryModel: self on: arg2) beCached.              (IceTipTreeRemote on: tmp3)                 name: tmp3 name;                 children: (tmp1 select: [:arg1 |  arg1 entity isRemote and: [ arg1 entity remoteName = arg2 name ] ] thenCollect: [:arg1 |  IceTipTreeBranch on: arg1 ]);                 yourself ]);     yourself) .   ((IceTipTreeRepositoryGroup on: self)     name: 'Tags';     icon: (self iconNamed: #glamorousBookmark);     children: (tmp2 collect: [:arg1 |  IceTipTreeTag on: arg1 ]);     yourself)}loadedVersion  ^loadedVersionusernameLabel  ^usernameLabelkeyPassphrase  ^keyPassphrase ifNil: [ keyPassphrase := '' ]package  ^packagebasicSelectionChanged: arg1  type := arg1.  arg1 ifNotNil: [ self title: type title.        self replacePanelWith: type ] ifNil: [ self removeAllPanels.        self title: self class title ]diff: arg1  diff := arg1doRemoveRemote: arg1  self handleLibgitError: [ (LGitRemote of: self repositoryHandle named: arg1 name)           lookup;           delete ]listPanel: arg1  listPanel := arg1labelColor: arg1  ^labelColor := arg1refresh  selectedModel ifNotNil: [ self showInfoTabs ] ifNil: [ self showEmptyTab ]isGroup  ^truepackageList  ^packageListusername: arg1  username := arg1accept  self removeFromRepositoryCheckbox state ifTrue: [ self model remove ].  self unloadFromImageCheckbox state ifTrue: [ self model unload ]repository  ^repositoryisConflict  ^falsevisitCheckoutConflict: arg1  UIManager default alert: arg1 messageText title: 'Iceberg conflicts while checking out'doRemoveRemote: arg1  self subclassResponsibilitycontextClass  ^IceTipRepositoryListContextprojectNameLabel: arg1  projectNameLabel := arg1branchLabel: arg1  branchLabel := arg1commitish: arg1  commitish := arg1entry: arg1  entry := arg1isDefault  ^host = #*urlText: arg1  urlText := arg1commitModels  ^(self entity outgoingCommitsTo: self remote) collect: [:arg1 |  (IceTipCommitModel repositoryModel: self repositoryModel on: arg1) beCached ]gitRef  ^self nameisGroup  ^falsecollectCommitsFor: arg1 path: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := self repository headCommit.  tmp2 := LGitPathSpec withAll: {arg2}.  tmp3 := LGitDiffOptions defaults.  tmp3 pathspec: (LGitStringArray withAll: {arg2}).  tmp4 := OrderedCollection new.  self repository newCommitWalk     fromCommit: tmp1;     rawResultsDo: [:arg3 |  | tmp5 tmp6 |        tmp5 := arg3 numberOfParents.        tmp6 := arg3 tree.        tmp5 = 0 ifTrue: [ (tmp6 matchesPathSpec: tmp2) ifTrue: [ tmp4 add: arg3 ] ] ifFalse: [ arg3 parents do: [:arg4 |  | tmp7 |                    tmp7 := tmp6 diffTo: arg4 tree options: tmp3.                    tmp7 numberOfDeltas > 0 ifTrue: [ tmp4 add: arg3 ] ] ] ].  ^tmp4acceptButton  ^acceptButtonchildAt: arg1 ifAbsentPut: arg2  ^childrenDictionary at: arg1 ifAbsent: [ self addChild: arg2 value ]remoteUrl  ^self urlText text trimmedstatus  [ | tmp1 tmp2 tmp3 |  self verifyDirectoryStructureIfMissing: [:arg1 |  ^arg1 ].  entity workingCopy workingCopyState isUnknownCommitState ifTrue: [ ^self toErrorMessage: entity workingCopy workingCopyState description ].  entity workingCopy isDetached ifTrue: [ ^self toErrorMessage: 'Detached Working Copy' ].  (entity head isDetached and: [ entity head tags notEmpty ]) ifTrue: [ ^self toWarningMessage: 'Detached HEAD' ].  entity head isDetached ifTrue: [ ^self toErrorMessage: 'Detached HEAD' ].  entity workingCopy project isUnborn ifTrue: [ ^self toErrorMessage: 'No Project Found' ].  self isLoaded ifFalse: [ ^'Not loaded' ].  tmp1 := OrderedCollection new.  entity isModified ifTrue: [ tmp1 add: 'Uncommited changes' ].  tmp2 := self incomingCommits size.  tmp2 > 0 ifTrue: [ tmp1 add: ('{1} incoming' format: {tmp2}) ].  tmp3 := self outgoingCommits size.  tmp3 > 0 ifTrue: [ tmp1 add: ('{1} not published' format: {tmp3}) ].  tmp1 ifEmpty: [ tmp1 add: 'Up to date' ].  ^', ' join: tmp1 ] on: Error do: [:arg2 |  ^self toErrorMessage: arg2 description ]initialExtent  ^(700 @ 700) scaledByDisplayScaleFactorsnapshotFor: arg1  ^self commit snapshotFor: arg1newStatusPanel  ^PanelMorph new     color: Color transparent;     layoutPolicy: TableLayout new;     listDirection: #leftToRight;     cellInset: 5;     vResizing: #spaceFill;     hResizing: #spaceFill;     asSpecAdaptertonelPackageName: arg1  ^arg1 namedescription  ^operation descriptiontreeToShow  ^self treeisCodeMissing  ^entity isCodeMissingforget  self class unregisterRepository: self ifAbsent: [ ^nil ].  Iceberg announcer announce: (IceRepositoryForgotten repository: self)repositoryModel  ^repositoryModelbrowse  (RPackageOrganizer default packageNamed: self name) browsechildren  ^children ifNil: [ #() ]minor  ^minorallBaselines  ^(self repositoryModel entity workingCopy packages select: [:arg1 |  arg1 name beginsWith: 'BaselineOf' ]) sorted: [:arg2 :arg3 |  arg2 name < arg3 name ]newRepository  | tmp1 tmp2 tmp3 |  tmp1 := self projectNameInputText text trimmed.  tmp2 := self projectLocation location.  tmp3 := self subdirectoryInputText text asString trimmed.  UIManager default informUser: ('Cloning repository {1} at {2}' format: {tmp1 .               tmp2 fullName}) during: [ ^IceRepositoryCreator new           repository: repository;           location: tmp2;           subdirectory: tmp3;           createNewRepositoryNamed: tmp1 ]postFetch  | tmp1 |  self workingCopy referenceCommit isUnknownCommit ifFalse: [ ^self ].  tmp1 := self lookupCommit: self workingCopy referenceCommit id.  tmp1 isUnknownCommit ifFalse: [ tmp1 adopt ]codeSubdirectoryNode  ^self repository subdirectory ifNotEmpty: [ tree firstNodeSuchThat: [:arg1 |  self isCodeSubdirectory: arg1 ] ] ifEmpty: [ tree ]jsonContents  ^jsonContents ifNil: [ jsonContents := STON fromString: self contents ]message: arg1  message := arg1setModelBeforeInitialization: arg1  model := arg1urlText: arg1  urlText := arg1writerClass  ^writerClass ifNil: [ writerClass := self repository writerClass ]rowHeight  ^rowHeight ifNil: [ rowHeight := self class defaultRowHeight ]retrieveDetail  self mergeablePanel widget addMorphBack: 'Loading...' asMorph.  [ | tmp1 tmp2 |  [ tmp1 := self pullRequest detail.  tmp2 := tmp1 at: #mergeable ] on: Error do: [:arg1 |  tmp2 := nil ].  UIManager default defer: [ self mergeablePanel widget           removeAllMorphs;           addMorphBack: (self iconForMergeable: tmp2) asMorph;           addMorphBack: (self textForMergeable: tmp2) asMorph ] ] forknewContext  ^super newContext     repositoryModel: self model repositoryModel;     yourselficeVersion: arg1  | tmp1 tmp2 |  iceVersion := arg1.  tmp1 := iceVersion commit repository.  package := iceVersion package.  tmp2 := iceVersion commit writerClass directoryNameFor: package.  self packageDirectory: (tmp1 subdirectoryPath / tmp2) pathStringexecute  ^IceGitHubNewPullRequestAction new     repository: self repository;     executedirectoryName  ^self repository directoryNameForPackage: selfobtainLastCommitMessage  ^self branch commit commentremoveAllCommitPanelTabs  commitTabPanel tabs copy do: [:arg1 |  commitTabPanel removeTab: arg1 ]showInfoTabs  (commitTabPanel tabs includes: infoTab) ifFalse: [ self removeAllCommitPanelTabs.        commitTabPanel           addTab: infoTab;           addTab: diffTab ].  self refreshCommitInfo.  self refreshDiffLabel.  commitTabPanel selectedTab ifNotNil: #tabSelectedputFocusOrder  ^self subclassResponsibilityshortCommitId  ^repositoryModel shortCommitIdpushTo: arg1  self subclassResponsibility= arg1  self species = arg1 species ifFalse: [ ^false ].  ^self commit = arg1 commitparent  ^self ancestors firstchangesTo: arg1  arg1 = self ifTrue: [ ^#() ].  ^arg1 changesFromNoCommit: selfexception: arg1  exception := arg1 freezerepositorySelected  | tmp1 |  self flag: #todo.  tmp1 := repositoryList widget selectedIndex.  tmp1 = 0 ifTrue: [ ^nil ].  ^repositoryList widget dataSource elementAt: tmp1 ifAbsent: [ nil ]text: arg1  textWidget widget contentsWrapped: arg1readerClass  ^self properties readerClassfileFormat: arg1  self fileFormatId: arg1 idcontextCellColumn: arg1 rowIndex: arg2  | tmp1 |  tmp1 := (self elementAt: arg2) at: arg1 id.  (tmp1 includesSubstring: 'travis-ci') ifTrue: [ tmp1 := 'travis-ci' ].  ^FTCellMorph new     addMorphBack: tmp1 asMorph;     yourselfinitializeCheckoutStrategyList  | tmp1 |  tmp1 := self model checkoutStrategies.  checkoutStrategyList     items: tmp1;     displayBlock: [:arg1 |  arg1 description ].  checkoutStrategyList whenSelectedItemChanged: [:arg2 |  self model checkoutStrategy: arg2 ]conflictsDo: arg1  mergeTree do: [:arg2 |  arg2 isConflict ifTrue: [ arg1 value: arg2 value ] ]initializeCurrentBranchLabel  currentBranchLabel := self newLabel label: 'Current branch: ' , self model branchNameincomingCommits  ^#()author  ^authorinitialExtent  ^(500 @ 250) scaledByDisplayScaleFactormodel  ^modelmodel  ^modelmcPackageSnapshotsOfPackages: arg1  self flag: #todo.  ^arg1 select: #isLoaded thenCollect: [:arg2 |  [ (self repository mcVersionFor: (IceSavedPackageVersion fromCommit: self package: arg2 mcPackage)) snapshot ] on: IceVersionDoesNotExist do: [:arg3 |  MCSnapshot empty ] ]defaultBaseBranchName  self hasParent ifFalse: [ ^self baseDefaultBranchName ].  ^self baseBranchNames detect: [:arg1 |  arg1 = self branch shortname ] ifNone: [ self baseDefaultBranchName ]setModelBeforeInitialization: arg1  self repositoryModel: arg1beDirty  isDirty := truebasicExecute  self fetchAllRemotesprotocol: arg1  protocol := arg1isInverseMerge  ^self imageCommit = mergeCommiticonPanel  ^iconPanelcheckoutOn: arg1  self subclassResponsibilityvisitMergeAborted: arg1  self visitGenericError: arg1newCellFor: arg1  | tmp1 |  tmp1 := FTIndentedCellMorph new.  tmp1 indentBy: arg1 depth * 16.  tmp1 addMorphBack: (self buttonFor: arg1).  (self iconFor: arg1 data) ifNotNil: [:arg2 |  tmp1 addMorphBack: arg2 asMorph ].  tmp1 addMorphBack: (self toString: arg1 data) asMorph.  ^tmp1toolAnnouncer  ^self tool announcerchildren  ^childrenDictionary values sorted: [:arg1 :arg2 |  arg1 key < arg2 key ]printOn: arg1  arg1     nextPutAll: 'gitChange(';     nextPutAll: filePathString asString;     nextPutAll: ')'iconPanel  ^iconPanelcommit  self subclassResponsibilityincludesCommit: arg1  self lookupCommit: arg1 id ifAbsent: [ ^false ].  ^truedescriptionWithDecoration  | tmp1 |  tmp1 := self displayString asText.  self entity isModified ifTrue: [ tmp1 := ('*' , tmp1) asText makeAllColor: self colorModified ].  ^tmp1collectWithPath: arg1  | tmp1 |  tmp1 := self class value: (arg1 value: self value value: self path).  self nodesDo: [:arg2 |  tmp1 addNode: (arg2 collectWithPath: arg1) ].  ^tmp1diffToWorkingCopy  | tmp1 |  tmp1 := IceTipCommitModel on: self entity commit.  ^tmp1 diffToWorkingCopyheadForkList  ^headForkListcommits  self shouldBeImplementedgetPaginated: arg1  ^IceGitHubAPIPaginatedResult api: self request: arg1pushCheckbox  ^pushCheckboxinitializeCurrentBranchLabel  currentCommitishLabel := self newLabel label: 'Current commit: ' , commitishToTag commit shortIdrepositoryName  ^self repositoryModel nameexecute  | tmp1 |  tmp1 := self repository headCommit.  tmp1 merge.  self repository workingCopy referenceCommit = tmp1 ifTrue: [ self beSuccess ]branchModel  ^(IceTipBranchModel repositoryModel: self on: self entity branch) beCachedcontextClass  ^IceTipBranchContextisAlreadyMerged  ^mergeCommit isAncestorOf: self leftCommitparseUrl  | tmp1 |  tmp1 := ZnUrl fromString: url.  user := tmp1 username.  host := tmp1 host.  port := tmp1 port ifNil: [ self class defaultPort ].  path := tmp1 segments allButLast: 2.  tmp1 segments size >= 2 ifTrue: [ owner := (tmp1 segments last: 2) first ].  tmp1 segments isEmpty ifTrue: [ IceWrongUrl signal: 'Remote repository scheme not supported: ' , url ].  projectName := self stripPossibleExtension: tmp1 segments lastdescription  ^[ super description ] on: Error do: [ self location isNil ifTrue: [ 'Not specified location' ] ifFalse: [ 'Bad location: ' , self location path pathString ] ]newIcePanel  ^super newIcePanel     in: [:arg1 |  arg1 widget listDirection: #rightToLeft ];     yourselfinitializeWidgets  locationLabel := self newLabel label: self label.  locationInput := self newTextInput autoAccept: true.  chooseButton := self newButton icon: self icon.  locationInput whenBuiltDo: [:arg1 |  arg1 widget wrapFlag: false ].  chooseButton action: [ self choose ].  self focusOrder add: locationInputcredentialSelected  | tmp1 tmp2 |  tmp1 := credentialsList widget selectedRowIndex.  tmp1 = 0 ifTrue: [ ^nil ].  tmp2 := credentialsList widget dataSource.  tmp2 hasElements ifFalse: [ ^nil ].  ^tmp2 elementAt: tmp1discardChanges  < noCache>  IceTipStandardAction new     repository: self entity;     message: 'Discarding changes';     onSuccessRepositoryModified;     execute: [ Iceberg announcer suspendAllWhile: [ self entity discardChanges ] ]title  ^'Working copy of ' , self model repositoryNamemenuSelectionContextWithSelection: arg1  ^self tool newContextWithSelection: arg1initialExtent  ^(600 @ 400) scaledByDisplayScaleFactoricon  ^definition iconinitializePackageNameText  self packageNameText whenBuiltDo: [:arg1 |  arg1 widget           bindKeyCombination: Character enter asKeyCombination toAction: [ self accept ];           bindKeyCombination: Character arrowUp asKeyCombination toAction: [ self packagesList takeKeyboardFocus.              self packagesList widget selectLastVisibleRow ];           bindKeyCombination: Character arrowDown asKeyCombination toAction: [ self packagesList takeKeyboardFocus.              self packagesList widget selectFirstVisibleRow ] ]initialize  super initialize.  self subscribeToAnnouncementsmergeButton: arg1  mergeButton := arg1username  ^self nameInput text trimBothremoteBranchNamed: arg1  ^self remoteBranchNamed: arg1 ifPresent: [:arg2 |  ^arg2 ] ifAbsent: [ IceBranchNotFound new           branchName: arg1;           signal ]merge  mergeType mergeOn: commitish then: [  ]execute  iconNameForStatus: arg1  arg1 = 'success' ifTrue: [ ^#testGreen ].  arg1 = 'failure' ifTrue: [ ^#testRed ].  arg1 = 'pending' ifTrue: [ ^#testYellow ].  ^#testNotRunmcVersionFor: arg1  | tmp1 tmp2 |  tmp1 := arg1 mcPackage.  tmp2 := tmp1 workingCopy.  ^MCVersion new setPackage: arg1 mcPackage info: tmp2 versionInfo snapshot: tmp2 snapshot dependencies: #()storeFileDefinition: arg1  (repository location resolve: arg1 path)     ensureDelete;     binaryWriteStreamDo: [:arg2 |  arg2 nextPutAll: arg1 binaryContents ].  self addPath: arg1 pathrepositoryHandle  < repositoryHandleAccessor>  ^repository repositoryHandlenameLabel  ^nameLabelensureStarted  started ifFalse: [ self start ]repository: arg1  repository := arg1commitButton: arg1  ^commitButton := arg1commitId  ^repositoryModel commitIdactualClass  self subclassResponsibilitycypressMethodClassExtension: arg1  arg1 isExtension ifTrue: [ ^'.extension' ].  arg1 origin isTrait ifTrue: [ ^'.trait' ].  ^'.class'location  ^self projectLocation locationvisitWorkingCopyDesynchronizedError: arg1  | tmp1 tmp2 |  tmp1 := UIManager default chooseFrom: #('Create new branch and commit' 'Merge local copy into image and commit') values: {IceCreateBranchCommand .         IceMergeWorkingCopyCommand} message: 'Your loaded code is not synchronized with the local sources in your repository. You need to solve this problem before you continue, please choose one of the strategies below.' title: 'Loaded code out of sync!'.  tmp1 ifNil: [ ^self ].  (tmp2 := tmp1 new)     repository: self repository;     execute.  tmp2 isSuccess ifTrue: [ arg1 retry ]withMetacelloLoadSessionDo: arg1  | tmp1 |  tmp1 := IceMetacelloLoadSessionContext value ifNil: [ IceMetacelloLoadSession new ].  IceMetacelloLoadSessionContext value: tmp1 during: arg1acceptPullRequest: arg1 project: arg2 number: arg3 data: arg4  ^self put: 'repos/' , arg1 , '/' , arg2 , '/pulls/' , arg3 asString , '/merge' with: [:arg5 |  arg5           entity: (ZnEntity text: (STON toJsonString: arg4));           contentType: ZnMimeType applicationJson ]readParametersFromContext: arg1  super readParametersFromContext: arg1.  branchModel := arg1 itemrepository  ^repositorynumberOfOutgoingCommits  ^[ | tmp1 |  self entity branch hasUpstream ifFalse: [ ^'*' ].  tmp1 := self outgoingCommits size.  tmp1 > 100 ifTrue: [ '99+' ] ifFalse: [ tmp1 ] ] on: IceNotInBranch do: [:arg1 |  0 ]isSuccess  ^successtype  ^self typeList selectedItemincomingCommits  self head isDetached ifTrue: [ ^#() ].  ^self branch incomingCommitsmessageText: arg1  messageText := arg1branchLabel  ^branchLabelacceptButton: arg1  acceptButton := arg1contextClass  ^self subclassResponsibilitynewUnbornProject  ^IceUnbornProject onRepository: selfmergeWithOperation: arg1  ^arg1 mergeWithLeftRemoval: selfpathFrom: arg1  ^(arg1 endsWith: '.git') ifTrue: [ arg1 allButLast: 4 ] ifFalse: [ arg1 ]initialize  super initialize.  hasChanges := falsereadParametersFromContext: arg1  credential := arg1 credential.  store := arg1 store.  tool := arg1 toolresponseWithValidationDo: arg1  | tmp1 |  tmp1 := arg1 value.  self handleUnauthorized: tmp1.  tmp1 isSuccess ifFalse: [ IceGitHubError signalFor: tmp1 ].  ^tmp1name  ^'Github'visitModification: arg1  arg1 definition accept: selfvisitNothingToCommitError: arg1  self visitGenericError: arg1remoteBranchNamed: arg1 ifAbsent: arg2  ^self remoteBranchNamed: arg1 ifPresent: [:arg3 |  ^arg3 ] ifAbsent: [ ^arg2 value ]visitEUSER: arg1  arg1 messageText = 'No ssh-agent suitable credentials found.' ifTrue: [ arg1 resignalAs: IceAuthenticationError new ].  self visitGenericError: arg1pull  self pullFrom: self upstream remotediffFromHead  ^iceCommit diffFromHeadreadContextParametersFromModel: arg1  store := arg1obtainAvailableBranchNames  ^((self repository allBranches collect: #shortname as: Set)     addAll: self baseBranchNames;     asArray) sortcreateCommandContextForSelection: arg1  ^self newContextWithSelection: arg1icon  ^icon ifNil: [ super icon ]removeAllPanels  | tmp1 |  tmp1 := self contentPanel morph.  tmp1 removeAllMorphsaccept: arg1  ^self subclassResponsibilityfilePathString: arg1  filePathString := arg1owner  ^ownerinitializeDiff  diff beForMerge.  diff selectedModel: self commits widget dataSource elements anyOneentry: arg1  entry := arg1.  entry repository: self repositoryobtainCredentials  ^IceGitHubAPI obtainCredentialsstatus  ^status ifNil: [ status := IceGitHubAPI new get: 'repos/' , self owner , '/' , self projectName , '/commits/' , self headSHA , '/status' ]iceVersion: arg1  iceVersion := arg1.  self packageDirectory: (iceVersion commit project sourceDirectoryPath / (IcePackage named: iceVersion package name repository: iceVersion commit repository) directoryName) pathStringcommit  ^streamrefreshCommits  commitsPanel refreshremoveFrom: arg1  arg1 removePlainTextCredential: selftargetDescription  ^'Merging commit: ' , self sourceVersion descriptionrepositoryWillBeCreated: arg1  SystemVersion current major < 7 ifTrue: [ ^self ].  self fetchIfNeeded: arg1.  (arg1 lookupCommit: SystemVersion current commitHash) adoptdoEdit: arg1  repository     location: arg1 location;     subdirectory: arg1 subdirectorymergeWithLeftAddition: arg1  self shouldNotImplementat: arg1 ifAbsent: arg2  ^objects at: arg1 ifAbsent: arg2author  ^self entity authorvisitGitChange: arg1  | tmp1 |  tmp1 := IceGitChangeImporter new     path: arg1 path;     diff: diff;     version: version;     yourself.  tmp1 importOn: parentNodeinitializeFocusOrder  self focusOrder     add: remotePanel;     add: issueNumberText;     add: issueTextacceptError: arg1  arg1 visitWorkingCopyDesynchronizedError: selfobtainPlaintextCredentials: arg1  | tmp1 |  tmp1 := IceTipAskForPlaintextCredentialsModel new     credentialStore: self credentialStore;     remoteHostname: remote host;     open.  arg1 readFrom: tmp1reasonPanel: arg1  reasonPanel := arg1visitNoModification: arg1  arg1 definition accept: selfrepository  ^repositoryvalidate  | tmp1 |  tmp1 := self remoteUrl.  self assert: tmp1 isNotEmpty description: 'You must enter your project url.'.  self assert: (IceGitRemote isValidUrl: tmp1) description: 'The url is incorrect.'.  self assert: self projectLocation location notNil description: 'Project location must be defined (if it does not exists, it will be created).'initializeWidgets  iconPanel := self newIcePanel.  iconPanel widget addMorph: (self iconNamed: #question) asMorph.  confirmLabel := self newLabel label: (self class confirmMessage format: {self model name}).  unloadFromImageCheckbox := self newCheckBox     label: 'Unload from image';     state: true.  removeFromRepositoryCheckbox := self newCheckBox     label: 'Remove from repository';     state: true.  self focusOrder     add: unloadFromImageCheckbox;     add: removeFromRepositoryCheckboxresetDiffContents  self diffContentsLeft: '' right: ''objects  ^objectsisLoaded  ^self entity isLoadedtoolbarItemFont  ^toolbarItemFont ifNil: [ toolbarItemFont := self newToolbarItemFont ]acceptError: arg1  arg1 visitNothingToCommitError: selfpanel  ^panelfetch  self subclassResponsibilityhttpsUrl  ^'https://{1}{2}/{3}.git' format: {self host .         (self port ifNotNil: [ ':' , self port asString ] ifNil: [ '' ]) .         self path}icon  ^self iconNamed: #changeUpdateunload  < noCache>  IceTipStandardAction new     repository: self entity repository;     message: ('Unloading package {1}' format: {self entity name});     onSuccessRepositoryModified;     execute: [ Iceberg announcer suspendAllForRepository: self entity repository while: [ self entity unload ] ]selectedModel: arg1  selectedModel := arg1.  self refreshbasicInstall  | tmp1 |  tmp1 := self entity definition.  tmp1 realClass compile: tmp1 sourceCode classified: tmp1 categorysetModelBeforeInitialization: arg1  model := arg1addTo: arg1  diff: arg1 with: arg2  | tmp1 |  tmp1 := arg1 mergeWith: arg2 onLeft: [:arg3 |  IceAddition definition: arg3 ] onRight: [:arg3 |  IceRemoval definition: arg3 ] onMerge: [:arg4 :arg5 |  arg4 = arg5 ifTrue: [ IceNoModification definition: arg4 ] ifFalse: [ IceModification left: arg4 right: arg5 ] ].  ^tmp1 select: [:arg6 |  arg6 hasChanges ]jsonAt: arg1  ^self json at: arg1help  ^helpdescriptionWithDecoration  ^'{1} <{2}>' format: {self name .         self entity url}removeTag: arg1  self handleLibgitError: [ self repositoryHandle git_tag_delete: arg1 name ]author  ^iceCommit authorisInvalid  ^truefileSystem  ^commitish fileSystemcreateCommandContext  ^self newContextWithSelection: self packageSelectedpushTagsToRemote: arg1 gitRemote: arg2 progress: arg3  self tags do: [:arg4 |  self pushTag: arg4 toRemote: arg1 gitRemote: arg2 progress: arg3 ]addFileNamed: arg1 path: arg2 contents: arg3  | tmp1 |  tmp1 := parentNode.  arg2 segments allButLastDo: [:arg4 |  tmp1 := (tmp1 includesKey: arg4) ifTrue: [ tmp1 / arg4 ] ifFalse: [ tmp1 addChild: (IceDirectoryDefinition named: arg4) ].        self assert: tmp1 value isDirectoryDefinition ].  tmp1 addChild: (IceFileDefinition named: arg1 path: arg2 contents: arg3)position  ^position ifNil: [ IceTipItemPosition default ]forget  < noCache>  IceTipStandardAction new     repository: self entity;     message: ('Forgeting {1}' format: {self name});     execute: [ self entity forget ]newContextWithSelection: arg1  ^IceTipCredentialContext new     store: model;     credential: arg1;     tool: self;     yourselfinitializeWithParent: arg1 entryName: arg2  | tmp1 |  parent := arg1.  entryName := arg2.  tmp1 := parent builder getEntryNamed: entryName.  tmp1 isReady ifTrue: [ initialTree := tmp1 tree ] ifFalse: [ hasChanges := true ]panel: arg1  panel := arg1sort: arg1  | tmp1 tmp2 tmp3 |  tmp2 := arg1.  tmp1 := OrderedCollection new.  self first = #none ifFalse: [ tmp1 addAll: (self sortByName: (self selectMatching: self first from: tmp2)) ].  tmp2 := tmp2 copyWithoutAll: tmp1.  tmp3 := self last = #none ifTrue: [ {} ] ifFalse: [ self selectMatching: self last from: tmp2 ].  tmp2 := tmp2 copyWithoutAll: tmp3.  tmp1 addAll: (self sortByName: tmp2).  tmp1 addAll: (self sortByName: tmp3).  ^tmp1validateCanCommit  self subclassResponsibilityid  ^iceCommit iddefaultBranchSelection  ^self branchModels detect: #isHead ifNone: [ self hasBranches ifTrue: [ self branchModels ifNotEmpty: #anyOne ] ]initialize  super initialize.  branchesByName := OrderedDictionary newcanBrowseReferences  ^falsenewCommitsDataSource  | tmp1 |  tmp1 := self pullRequest commits collect: [:arg1 |  (IceTipCommitModel repositoryModel: self repositoryModel on: arg1) beCached ].  ^IceTipDataSource new     tool: self;     elements: tmp1;     yourselfmergeType: arg1  mergeType := arg1printOn: arg1  arg1 nextPutAll: self class name.  self printDescriptionOn: arg1commitModels  ^commitModels ifNil: [ commitModels := self retrieveHistory collect: [:arg1 |  (IceTipVersionModel repositoryModel: self repositoryModel on: arg1) beCached ] ]createTag: arg1  self repository handleLibgitError: [ self repositoryHandle createTag: arg1 targetId: self libgitCommit id force: false.        ^IceTag named: arg1 inRepository: self repository ]toolbarItemSize  ^self class defaultItemSizecommit  ^selfvalidate  chooseConflictPolicyFor: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := IceMetacelloLoadSessionContext value.  tmp1 := arg1 projectName.  tmp2 := arg1 newProjectRegistration printString.  tmp3 := arg1 existingProjectRegistration printString.  ^tmp4 recordChoiceProject: tmp1 optionA: tmp2 optionB: tmp3 ifAbsentAnswer: [ self chooseConflictPolicyProject: tmp1 optionA: tmp2 optionB: tmp3 ]baseLabel  ^(self jsonAt: #base) at: #labelaccept: arg1  ^arg1 visitRootDefinition: selfincomingCommits  self hasUpstream ifFalse: [ ^#() ].  ^self incomingCommitsFrom: self upstream remoterefresh  diffPanel refreshmin: arg1  min := arg1useLoaded  ^self resume: self builder addLocalRepositoryresetDiff  storeOnDirectory: arg1 root: arg2  | tmp1 tmp2 |  tmp1 := arg1 / self class propertiesFileName.  tmp2 := tmp1 relativeTo: arg2.  tmp1 resolve     ensureDelete;     writeStreamDo: [:arg3 |  (STONWriter on: arg3)           prettyPrint: true;           newLine: OSPlatform current lineEnding;           nextPut: self properties ]asResumable  resumable := truecommitFromGitCommit: arg1  ^self commitCache at: arg1 id hexString ifAbsentPut: [ IceGitCommit new           id: arg1 id hexString;           author: arg1 author name asByteArray utf8Decoded;           datetime: arg1 time asDateAndTime;           ancestorIds: (arg1 parents collect: [:arg2 |  arg2 id hexString ]);           comment: arg1 message;           repository: self;           yourself ]hostDescription  ^host = #* ifTrue: [ 'Default' ] ifFalse: [ host ]messageText  ^self namepackageSelected  | tmp1 tmp2 |  self flag: #todo.  tmp1 := packageList widget selectedIndex.  tmp1 = 0 ifTrue: [ ^nil ].  tmp2 := packageList widget dataSource.  tmp2 hasElements ifFalse: [ ^nil ].  ^tmp2 elementAt: tmp1badgeTextColor  ^Smalltalk ui theme badgeTextColorcommitWithMessage: arg1 andParents: arg2  | tmp1 |  repository handleLibgitError: [ | tmp2 tmp3 tmp4 |        self addToGitIndex.        [ tmp2 := self repositoryHandle defaultSignature ] on: LGit_GIT_ENOTFOUND , LGit_GIT_ERROR do: [:arg3 |  IceGitUsernameOrEmailNotFound guessKind: arg3 ifNot: [ arg3 pass ] ].        tmp1 := self repositoryHandle index.        tmp4 := tmp1 writeTreeAndReturnOid.        tmp1 free.        tmp3 := (LGitCommitBuilder of: self repositoryHandle)           tree: (LGitTree of: self repositoryHandle fromId: tmp4);           message: arg1 withUnixLineEndings utf8Encoded asString;           parents: (self repositoryHandle isUnborn ifTrue: [ #() ] ifFalse: [ self libGitCommitsFrom: self repositoryHandle for: arg2 ]);           updateReference: ([ self repositoryHandle head name ] on: LGit_GIT_EUNBORNBRANCH do: [ repository branch gitRef ]);           author: tmp2;           committer: tmp2;           writeCommit;           commitId.        ^repository commitFromGitCommit: (LGitCommit of: self repositoryHandle fromId: tmp3) ]traversingDo: arg1 parents: arg2  arg1 cull: self cull: arg2.  self children do: [:arg3 |  arg3 traversingDo: arg1 parents: (arg2 copyWith: self) ]hasMultipleAncestors  ^self entity hasMultipleAncestorsmessageText  ^messageText ifNil: [ self class defaultMessageText ]traversingDo: arg1 parents: arg2  self subclassResponsibilityhasBranches  ^self branches isNotEmptyselectRight  chosen := rightOperationbuilder: arg1  builder := arg1doAccept  self selectedType doAcceptcurrentBranchLabel  ^currentBranchLabelparent  ^parentisUnknownCommit  ^falsevalidateCanMerge  | tmp1 tmp2 tmp3 |  self repository isModified ifTrue: [ Warning signal: 'Experimental Feature: merge when there is a dirty working copy. Could cause a loss of your local changes. Please commit before merge.' ].  tmp1 := self repository workingCopy referenceCommit.  tmp2 := self repository headCommit.  tmp3 := self commit.  {tmp3 .   tmp1 .   tmp2} asSet size > 2 ifTrue: [ IceMergeAborted signal: ('Cannot perform a tri-merge. You are trying to merge {1} into {2}, but the image is in {3}. Please, procceed to load either {1} or {2} in your image to merge.' format: {tmp3 description .                     self repository head description .                     tmp1 description}) ]isUnbornBranch  ^falsedeleteAll  self builder clearhasChanges  ^self chosenOperation hasChangesvisitNothingToCommitError: arg1  UIManager default inform: 'There is nothing to commit.'fileFormat  ^self writerClassprojectName  ^((self jsonAt: #base) at: #repo) at: #nameitem  ^itemcurrent: arg1  current := arg1repositoryModel  ^repositoryModeldetailedInfo  ^{('Origin' -> path pathString)}includesPackageNamed: arg1  ^self workingCopy includesPackageNamed: arg1printOn: arg1  arg1     nextPutAll: 'IceNode(';     nextPutAll: self key asString;     nextPutAll: ')'isUnknownCommitState  ^falsedefinition  ^leftOperation definitionaccept  ^[ self doAccept.  true ] on: IceError , IceWarning do: [:arg1 |  arg1 acceptError: IceTipInteractiveErrorVisitor new.        false ]selectedItem  ^self table selectedRowIndexes ifNotEmpty: [:arg1 |  self elementAt: arg1 first ] ifEmpty: [ nil ]markAsCleanPackagesNotInDiff: arg1  self markAsCleanPackagesThat: [:arg2 |  (arg1 includesPackageNamed: arg2 name) not ]copyToClipboard: arg1  Clipboard clipboardText: arg1 informing: ('Url {1} copied to clipboard' format: {arg1})pullRequests: arg1  pullRequests := arg1remoteAt: arg1 put: arg2  self subclassResponsibilityhasChanges  ^falseinitializeDialogWindow: arg1  super initializeDialogWindow: arg1.  arg1 title: self title.  self updateOkButton.  arg1 centeredhasIncomingCommits  ^self hasIncomingCommitsFrom: self repository originhostLabel  ^hostLabelremoteLabel  ^remoteLabelprojectNameInputText  ^projectNameInputTextcollapseAll  changeList widget dataSource     rootForItems: self model treeRoots;     selectAllcopyWithOnly: arg1  ^self diff copyWithOnly: arg1checkoutBranchPanelsOnModel: arg1  ^{(IceGitHubNewBranchFromIssuePanel on: arg1)}description  ^'No code loaded'initializeWidgets  branchesList := self newIceTable.  self initializeBranchesList.  self focusOrder add: self branchesListrequestRemoteBranch: arg1  ^IceGitHubAPI new getBranch: self remote owner project: self remote projectBasename name: arg1descriptionWithDecoration  ^self subclassResponsibilitycontents  mcDefinition ifNil: [ ^'' ].  ^self isMeta ifFalse: [ mcDefinition definitionString ] ifTrue: [ mcDefinition classDefinitionString ]message  ^self messageText text asStringreportError: arg1  | tmp1 |  tmp1 := arg1 messageBody.  tmp1 = 'Invalid field: head' ifTrue: [ tmp1 := 'Branch does not exist on github. Please commit and push your changes.' ].  UIManager default alert: tmp1 title: 'Error creating pull request: ' , arg1 messageTexttitleLabel: arg1  titleLabel := arg1publicKey: arg1  publicKey := arg1.  self storeIfDefaultdefinitionFor: arg1 path: arg2 commit: arg3  self subclassResponsibilitypullFrom: arg1  self branch pullFrom: arg1readOnlyVersion  ^IceInvalidProject onCommitish: commitishvisitModification: arg1  ^arg1 leftDefinition accept: selfinitialize  super initialize.  workingCopy := IceWorkingCopy basicNew.  workingCopy repository: self.  workingCopy initialize.  index := self newIndexexecute  | tmp1 |  (UIManager default confirm: 'This operation can take some times depending on the size and number of your repositories. Are you sure you want to fetch all repositories?' label: 'Proceed?') ifFalse: [ ^self ].  tmp1 := IceRepository registry.  UIManager default informUserDuring: [:arg1 |  arg1 max: tmp1 size.        arg1 value: 1.        tmp1 withIndexDo: [:arg2 :arg3 |  arg1 label: ('Fetching incoming commits of {1}' format: {arg2 name}).              arg1 value: arg3 + 1.              arg2 fetch ] ].  Iceberg announcer announce: IceRepositoryModified newmarkAsDirtyPackageNamed: arg1  (self packageNamed: arg1) beDirtybecomeForward: arg1 copyHash: arg2  (Array with: self) elementsForwardIdentityTo: (Array with: arg1) copyHash: arg2name  ^self gitRef withoutPrefix: self branchNamePrefixhistoryOfMethod: arg1  | tmp1 tmp2 |  tmp1 := self toFileName: arg1.  tmp2 := self collectCommitsFor: arg1 path: tmp1.  ^self collectVersionsFrom: tmp2 method: arg1 path: tmp1remote: arg1  remote := arg1initialExtent  ^(350 @ (self class inputTextHeight * 5 + self class buttonHeight)) scaledByDisplayScaleFactordiffTree: arg1  tree := arg1repositoryDescription  ^self repository descriptionaddDecorationTo: arg1  | tmp1 |  tmp1 := arg1 asText.  [ self entity isHead ifTrue: [ tmp1 := tmp1 allBold ] ] on: IceNotInBranch do: [:arg2 |   ].  ^tmp1elementAt: arg1 ifAbsent: arg2  ^self elements at: arg1 ifAbsent: arg2location  ^locationreadParametersFromContext: arg1  super readParametersFromContext: arg1.  browser := arg1 toolnewRepository  UIManager default informUser: ('Importing repository from {1}' format: {self location fullName}) during: [ ^IceRepositoryCreator new           repository: repository;           location: self location;           createRepository ]project: arg1  self basicSetProject: arg1.  self refreshProjectprojectNameInputText: arg1  projectNameInputText := arg1initialize  super initialize.  job := IceExternalJob new     title: 'Checking out...';     yourself.  self initializeBlockhash  ^self contents hashshortId  ^self id first: 7useRemote: arg1  self selectRemoteModel useRemote: arg1value: arg1  arg1 ifTrue: [ self addItem ] ifFalse: [ self removeItem ]panel  ^paneltitle  ^'Repository of ' , self model nameaddToGitIndex  repository addFilesToIndex: modifiedFilePathscontents  ^String streamContents: [:arg1 |  arg1 nextPutAll: 'Package tags: '.        categories do: [:arg2 |  arg1                 nextPutAll: String crlf;                 nextPutAll: String tab;                 nextPutAll: arg2 ] ]addItem  (list includes: item) ifTrue: [ ^self ].  list add: itemstubVersionInfo  ^stubVersionInfo ifNil: [ stubVersionInfo := MCVersionInfo name: packageName id: UUID new message: 'fabricated from a proxy repository' date: nil time: nil author: '' ancestors: #() ]packageName  ^self entity packageNamemodifiedPackages  ^self loadedPackages select: [:arg1 |  arg1 isDirty ]contextSelection  ^self selectedPackagemaxNumber  ^maxNumberitems: arg1  self listPanel items: arg1initializeWidgets  super initializeWidgets.  hostLabel := self newLabel label: 'Host: '.  hostInput := self newTextInput     autoAccept: true;     whenTextChanged: [ self updateOkButton ];     yourselfowner  ^ownermcPackage  ^package mcPackageprintOn: arg1  arg1     nextPutAll: self class name;     nextPut: $(;     nextPutAll: name asString;     nextPut: $)height  ^self extent yinitializeWidgets  super initializeWidgets.  usernameLabel := self newLabel label: 'Username: '.  usernameInput := self newTextInput     autoAccept: true;     whenTextChanged: [ self updateOkButton ];     yourself.  passwordLabel := self newLabel label: 'Password: '.  passwordInput := self newTextInput     beEncrypted;     autoAccept: true;     whenTextChanged: [ self updateOkButton ];     yourselfmorphicOpen: arg1  | tmp1 |  tmp1 := UIManager default confirm: ('{1} belongs to {2} and cannot be browsed here. Do you want to open the Iceberg Browser instead?' format: {arg1 packageName .               self repository name}) label: 'Browsing an iceberg repository' trueChoice: 'Open' falseChoice: 'Cancel' cancelChoice: nil default: true.  tmp1 ifFalse: [ ^self ].  IceTipRepositoriesBrowser new openWithSpecrefresh  packagesList widget     in: [:arg1 |  arg1 selectRowIndexes: #().        arg1 dataSource           rootForItems: self model repositoryModelsByGroup;           expandAll ];     refreshusernameLabel  ^usernameLabelvisitDirectoryDefinition: arg1  self visitChildrenOf: currentNodechooseUpgradePolicyFor: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp4 := IceMetacelloLoadSessionContext value.  tmp1 := arg1 projectName.  tmp2 := arg1 newProjectRegistration printString.  tmp3 := arg1 existingProjectRegistration printString.  ^tmp4 recordChoiceProject: tmp1 optionA: tmp2 optionB: tmp3 ifAbsentAnswer: [ self chooseUpgradePolicyProject: tmp1 optionA: tmp2 optionB: tmp3 ]mergeCommit: arg1  self subclassResponsibilitywithoutHead  self branchesList widget dataSource elements: (self branchModels reject: #isHead).  self branchesList widget selectFirstVisibleRowdirectory: arg1  rootItem := (self class rootItemFor: {arg1})     dataSource: self;     yourself.  self rootItem: rootItemreferencesSameRemoteLocationAs: arg1  ^self url sameAs: arg1 urlprojectNameLabel: arg1  projectNameLabel := arg1packageNamed: arg1  ^self packagesDictionary at: arg1visitFileNode: arg1  index addPath: arg1 pathpackageNameFromDirectory: arg1  ^self writerClass packageNameFromDirectory: arg1projectLocation: arg1  projectLocation := arg1codeDirectoryWithDelim  ^self repository subdirectory isEmptyOrNil ifTrue: [ '' ] ifFalse: [ self repository subdirectory , '/' ]diff: arg1  diff := arg1checkoutStrategy: arg1  checkoutStrategy := arg1acceptError: arg1  arg1 visitMissingCredentialsError: selfinitializeWidgets  super initializeWidgets.  self initializeSourceDirectory.  projectNameLabel := self newLabel label: 'Project name'.  projectNameInputText := self newTextInput     ghostText: 'e.g., MyProject';     autoAccept: true.  projectNameInputText whenTextChanged: [:arg1 |  projectLocation appendPath: arg1 ].  self focusOrder     add: self projectNameInputText;     add: self projectLocation;     add: self subdirectoryInputText;     add: self remoteInputTextallPathSegments  self isRoot ifTrue: [ ^#() ].  self parent isRoot ifTrue: [ ^{self key} ].  ^self parent allPathSegments copyWith: self keygtDisplayOn: arg1  ^self printOn: arg1repositories  ^IceRepository registry collect: [:arg1 |  (IceTipRepositoryModel on: arg1) beCached ]newContext  ^IceTipPullRequestsContext for: selforganisation  ^organisationname: arg1  name := arg1tool: arg1  tool := arg1fileName  ^fileNameprojectPath  ^self pathdescription  ^'Nothing loaded'replace: arg1 with: arg2  self assert: arg1 name = arg2 name.  childrenDictionary at: arg1 name put: arg2icon  ^self class iconbaseRemote: arg1  baseRemote := arg1commit  ^self entity workingCopy referenceCommithasMultipleAncestors  | tmp1 |  tmp1 := self ancestors.  ^tmp1 notNil and: [ tmp1 size > 1 ]initialize  super initialize.  job := IceExternalJob new     title: 'Fetching Git objects...';     yourself.  self initializeBlockcheckoutStrategyLabel: arg1  checkoutStrategyLabel := arg1hasChanges  ^falsevisitClassDefinition: arg1  repository workingCopy applyDefinition: arg1 inNode: currentNode.  self visitChildrenOf: currentNodeinstallBaseline: arg1  ^self installBaseline: arg1 groups: #()removeFromRepositoryCheckbox: arg1  removeFromRepositoryCheckbox := arg1= arg1  self subclassResponsibilitysubdirectoryReference  ^self location resolve: self subdirectoryPathvalidate  self assert: self selectedPackage isNotNil description: 'Please select a branch to checkout.'outgoingCommits  ^#()isResolved  ^falseignoreNotificationsDuring: arg1  | tmp1 |  tmp1 := shouldIgnoreNotifications.  shouldIgnoreNotifications := true.  arg1 ensure: [ shouldIgnoreNotifications := tmp1 ]headBranchList  ^headBranchListcanBeBrowsed  ^Smalltalk globals at: className ifPresent: [:arg1 |  arg1 includesSelector: name ] ifAbsent: [ false ]visitRootDefinition: arg1  self visitChildrenOf: currentNodefullname  ^nameworkingCopy: arg1  workingCopy := arg1.  workingCopy repository: selfmigratePackage: arg1 commit: arg2  | tmp1 tmp2 tmp3 tmp4 |  tmp2 := self codeDirectory.  tmp3 := self codeDirectoryWithDelim.  tmp4 := (arg2 versionFor: arg1) mcVersion.  tmp4 := self ensureMCVersionWithClassOrganisation: tmp4.  self writerClass forInternalStoreFileOut: tmp4 on: repository.  tmp1 := arg2 writerClass directoryNameFor: arg1.  (tmp2 / tmp1) ensureDeleteAll.  self repository addFilesToIndex: {(tmp3 , (IceLibgitTonelWriter directoryNameFor: arg1)) .         (tmp3 , (IceLibgitFiletreeWriter directoryNameFor: arg1))}name  ^self fullname withoutPrefix: self branchNamePrefixtonelMethodClassExtension: arg1  arg1 isExtension ifTrue: [ ^'.extension' ].  arg1 origin isTrait ifTrue: [ ^'.trait' ].  ^'.class'model: arg1  model := arg1isModified  ^self isMissing not and: [ super isModified ]addPackage: arg1  self subclassResponsibilityvisitMissingCredentialsError: arg1  self visitGenericError: arg1username  ^username ifNil: [ username := '' ]name: arg1  name := arg1newToolbarItemFont  | tmp1 |  tmp1 := Smalltalk ui theme buttonFont.  ^LogicalFont familyName: tmp1 familyName pointSize: tmp1 pointSize - 3doAccept  self validate.  self selectedBranch previewCheckoutinitializeBlock  self signature: self class fnSpec block: self blockpackages  ^self packageNames collect: [:arg1 |  IcePackage named: arg1 repository: self repository ]visitConflictingOperation: arg1  arg1 isResolved ifFalse: [ self error: 'Cannot apply a non resolved conflict' ].  ^arg1 chosenOperation accept: selfnextVersionName  ^'{1}-{2}.{3}' format: {self package packageName .         self author .         (self info versionNumber + 1)}isHead  ^truefileName  ^fileNamebePositionRight  self position: IceTipItemPosition rightpath: arg1  path := arg1initialize  super initialize.  self color: Color transparentstubVersionInfo: arg1  stubVersionInfo := arg1newCommitWalk  ^IceNullCommitWalk newpackageNames  ^self subclassResponsibilityisBranch  ^falserefreshCommitTabPanel  selectedModel ifNotNil: [ self showInfoTabs ] ifNil: [ self showEmptyTab ]browse  ^self leftDefinition browsemergeWithLeftAddition: arg1  self shouldNotImplementcanReadProjectFromCommitish: arg1  ^arg1 isWorkingCopy and: [ (arg1 fileSystem / '.project') exists not ]diffPanel  ^diffPanelemailLabel: arg1  emailLabel := arg1execute  ^IceGitHubRemoveBranchesAction new     repository: self repository;     remote: self remote;     executeexecute  self withErrorHandlingDo: [ [ [ self basicExecute ] on: IceAuthenticationError do: [:arg1 |  retries = 0 ifTrue: [ arg1 pass ].              retries := retries - 1.              ^self execute ] ] on: LGitNoCredentialsProvided do: [ ^self ].        self finishSuccess ]toolbarItemFont: arg1  toolbarItemFont := arg1actionColumn: arg1  elements := elements sorted: [:arg2 :arg3 |  (arg2 at: arg1 id) < (arg3 at: arg1 id) ]subdirectoryLabel: arg1  subdirectoryLabel := arg1isRepositoryDetached  ^self entity workingCopy isDetached or: [ self entity head isDetached ]accept  | tmp1 |  self window delete.  tmp1 := self packagesList widget dataSource selectedItems.  tmp1 ifEmpty: [ UIManager default inform: 'No packages selected.'.        ^self ].  self model addPackages: tmp1typeLabel: arg1  typeLabel := arg1unloadFromImageCheckbox  ^unloadFromImageCheckboxoperationIcon  self subclassResponsibilityisParentOf: arg1  ^falsevisitEEXISTS: arg1  (arg1 messageText beginsWith: 'Failed to write reference ''refs/tags') ifTrue: [ | tmp1 tmp2 |        tmp2 := arg1 messageText readStream.        tmp1 := tmp2           upTo: $/;           upTo: $/;           upTo: $'.        IceTagAlreadyExists new           tagName: tmp1;           signal ].  self visitGenericError: arg1printOn: arg1  arg1     nextPutAll: self class name;     nextPutAll: ': ';     print: self namelocation  ^locationcontextClass  ^IceTipHistoryContextpreferredColor  ^self isResolved ifTrue: [ Color gray ] ifFalse: [ nil ]addNode: arg1  self at: arg1 key put: arg1.  ^arg1updateIndex: arg1  arg1 tree accept: (IceIndexUpdateVisitor new           index: self;           diff: arg1)icon  ^iconimportOn: arg1  | tmp1 tmp2 tmp3 |  tmp1 := path segments first.  tmp3 := arg1 path / tmp1.  tmp2 := version fileSystem resolve: tmp3.  tmp2 exists ifFalse: [ ^self ].  ((diff isCodeSubdirectory: arg1) and: [ version writerClass isValidPackage: tmp2 ]) ifTrue: [ ^self ensurePackageFromDirectory: tmp2 inParentNode: arg1 ].  path size = 1 ifTrue: [ tmp2 exists ifTrue: [ ^arg1 addChild: (IceFileDefinition named: tmp1 path: tmp3 fileReference: tmp2) ] ].  path size > 1 ifTrue: [ | tmp4 tmp5 |        tmp5 := arg1 path / tmp1.        tmp4 := version fileSystem resolve: tmp5.        tmp4 exists ifTrue: [ self nextPath importOn: (self ensureDirectory: tmp2 inParentNode: arg1) ] ]tool  ^toolrepository: arg1  repository := arg1parentNode: arg1  parentNode := arg1repository  ^repositorylocation  ^entity locationdescriptionWithDecoration  | tmp1 |  tmp1 := self displayString asText.  self entity isLoaded ifFalse: [ tmp1 := tmp1 makeAllColor: self colorNotLoaded ].  self entity isModified ifTrue: [ tmp1 := ('*' , tmp1) asText makeAllColor: self colorModified ].  ^tmp1packageNames  ^#()issueNumberText: arg1  issueNumberText := arg1formatList  ^formatListrepository: arg1  repository := arg1isBranch  ^trueinitialize  super initialize.  suspendAll := false.  suspendedConditions := OrderedCollection new: 5isLoaded  ^self entity loadedPackages notEmptytoText  ^toTextcontentsString  ^ByteArray streamContents: [:arg1 |  (STONWriter on: (ZnCharacterWriteStream on: arg1))           prettyPrint: true;           newLine: OSPlatform current lineEnding;           nextPut: self properties ]beClean  isDirty := falseisDefault  ^falseparent: arg1  parent := arg1storeVersion: arg1  self subclassResponsibilitycomment  ^self commit commentorganisation: arg1  organisation := arg1description  ^'Unknown {1}' format: {self shortId}visitFileNode: arg1  updateLabelOn: arg1  self tab label: (self labelFor: arg1)commitList: arg1  commitList := arg1repository  ^repositoryinstallBaseline: arg1 groups: arg2  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Installing baseline {1} of {2}' format: {(arg1 name allButFirst: self class baselinePrefix size) .               self repositoryModel name});     onSuccessRepositoryModified;     execute: [ Iceberg announcer suspendAllForRepository: self repositoryModel entity while: [ self basicInstallBaseline: arg1 groups: arg2 ] ]isMissing  ^self entity isMissinglocationInput  ^locationInputvisitModification: arg1  ^arg1 leftDefinition accept: selfinitializeWidgets  iconWidget := self newIcePanel.  textWidget := self newIceReadOnlyTexttab: arg1  tab := arg1configureBuilder: arg1  arg1 beBitbucketrefreshProjectFromRepository  | tmp1 tmp2 |  tmp1 := referenceCommit isCollection ifTrue: [ referenceCommit first ] ifFalse: [ referenceCommit ].  tmp2 := tmp1 project.  tmp2 isInvalid ifFalse: [ self basicSetProject: tmp2 ].  properties := tmp1 properties asBornProperties.  self refreshProject.  ^projectproperties  ^IceRepositoryProperties fromFileReferenceDirectory: self project sourceDirectoryReference commitish: selfisRemote  ^falseformatList: arg1  formatList := arg1addModification: arg1 toPatcher: arg2  url: arg1  self basicUrl: arg1.  self parseUrlincludesPackageNamed: arg1  ^self commit includesPackageNamed: arg1mergeType: arg1  mergeType := arg1initialExtent  ^(600 @ 400) scaledByDisplayScaleFactorstoreCredential: arg1  self loadFromStore.  arg1 storeInto: self forHostname: arg1 host.  self saveIntoStorevisitPackage: arg1  (self repository packageNamed: arg1 name) isLoaded ifFalse: [ ^self ].  currentNode accept: (IceMCSnapshotPatchVisitor new           patcher: loader;           yourself)branchModel  ^branchModelclassIsMeta  ^classIsMetacommits  ^self newCommitWalk commitsuptoCommit: arg1  self revwalk hideCommit: (LGitId fromHexString: arg1 id)branchName  ^self branchInputText text asString trimBothremote  ^remote ifNil: [ remote := self askRemote ]removeFiletreeRemnants  | tmp1 |  tmp1 := self codeDirectory allChildrenMatching: '.filetree'.  tmp1 do: #ensureDelete.  self repository addFilesToIndex: (tmp1 collect: [:arg1 |  (arg1 relativeTo: self codeDirectory) printWithDelimiter: $/ ])initializeWidgetsContents  self initializeCurrentBranchLabel.  tagNameLabel := self newLabel label: 'New tag'.  tagNameInputText := self newTextInput     autoAccept: true;     ghostText: 'e.g., v[X].[Y].[Z]'.  self initializeNextTagPanel.  self initializeExistingTagsList.  spacePanel := PanelMorph new asSpecAdaptermessageLabel  ^messageLabelitem  ^itemvalidate  self selectedBranch ifNil: [ IceError signal: 'Please select a branch to checkout.' ]removeFileSystemCheckbox: arg1  removeFileSystemCheckbox := arg1locationLabel  ^locationLabelinitializeWidgets  messageLabel := self newLabel.  messageText := self newText autoAccept: true.  acceptButton := self newButton.  messageLabel label: 'Comment'.  messageText whenBuiltDo: [:arg1 |  arg1 widget withGhostText: self class messageGhostText ].  acceptButton label: 'Reject pull request'.  acceptButton action: [ self accept ].  self focusOrder     add: messageText;     add: acceptButtonsetModelBeforeInitialization: arg1  model := arg1at: arg1  ^self properties at: arg1localBranches  self subclassResponsibilitycommit  ^commitbodyText  ^bodyTexttitle  ^'Add SSH credential'leftCommit  ^self isInverseMerge ifTrue: [ self headCommit ] ifFalse: [ self imageCommit ]visitProjectChange: arg1  version project addToChangeBuilder: selfexecute  selectedCommitish adopt.  Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity)projectPath  ^self repository origin projectPathname  ^'Metacello'visitECONFLICT: arg1  arg1 object = LGitErrorTypeEnum giterr_checkout ifTrue: [ ^arg1 resignalAs: IceCheckoutConflictError new ].  self visitGenericError: arg1defaultLocation  | tmp1 |  tmp1 := self remoteToUse.  ^IceLibgitRepository repositoriesLocation / tmp1 organizer / tmp1 projectNamevisitRemoteDesynchronizedError: arg1  self visitGenericError: arg1execute  branchModel previewCheckoutexecute  onClickBlock ifNotNil: [ onClickBlock cull: self ]initializePackageList  packageList widget     beResizable;     addColumn: (IceTipTableColumn new           id: 'Name';           action: #descriptionWithDecoration;           yourself);     addColumn: (IceTipTableColumn new           id: 'Status';           action: #statusWithDecoration;           yourself);     dataSource: self newPackagesDataSource;     selectIndex: 1;     enableFilter: IceTipPackageFilter;     explicitFunctionversionFor: arg1  ^arg1 commit versionFor: selfexecute  ^IceGitHubViewPullRequestAction new     repository: self repository;     remote: self remote;     executerepositoryModel  ^repositoryModeldoPush  self model pushThen: [ self window delete ]basicRemovePackage: arg1  self packagesDictionary removeKey: arg1 name ifAbsent: [  ]remoteHostname: arg1  remoteHostname := arg1log  ^self subclassResponsibilityput: arg1 with: arg2  ^self jsonContentsWithValidationDo: [ (self newRequestTo: arg1)           in: arg2;           put;           response ]finishSuccess  successBlock ifNotNil: [ successBlock value ]acceptButton  ^acceptButtoncanUpgradeTo: arg1  (arg1 isKindOf: self class) ifFalse: [ ^false ].  ^self projectPath = arg1 projectPath and: [ self repoPath = arg1 repoPath and: [ self projectVersion = arg1 projectVersion ] ]validateCanCommit  self validateMessageNotEmptylabel: arg1  label := arg1.  self locationLabel label: arg1newChangeTreeDataSource  ^IceTipTreeDataSource new     tool: self;     rootForItems: self model treeRoots;     childrenBlock: [:arg1 |  arg1 children ];     icon: [:arg2 |  arg2 value icon ];     format: #description;     yourselfopenDialogWithSpec  ^super openDialogWithSpec     okAction: [ self accept ];     yourselfaddShortcutsTo: arg1  super addShortcutsTo: arg1.  arg1 bindKeyCombination: Character cr asKeyCombination toAction: [ self accept ]userNameInputText: arg1  userNameInputText := arg1addToChangeBuilder: arg1  newCommitsDataSource  ^IceTipDataSource new     tool: self;     elements: #();     yourselfdefinitionFor: arg1 path: arg2 commit: arg3  ^((IceLibgitTonelLogReader fileName: arg2 on: arg3)     package: arg1 package mcPackage;     packageDirectory: (self repository directoryPathStringForPackage: arg1 package);     definitions) detect: [:arg4 |  arg4 isMethodDefinition and: [ arg4 selector = arg1 selector ] ] ifNone: [ MCMethodDefinition className: arg1 origin name selector: arg1 selector category: #'' timeStamp: nil source: '' ]validate  self assert: self branchName isNotEmpty description: 'Please enter your new branch name.'.  self assert: (self branchName noneSatisfy: #isSeparator) description: 'You can''t have spaces in your branch name.'removeItem  (list includes: item) ifFalse: [ ^self ].  list remove: itemlocationInput: arg1  locationInput := arg1mergeWithOperation: arg1  self subclassResponsibilitycommitList: arg1  commitList := arg1repository: arg1  repository := arg1formatToUse  ^IceLibgitRepository defaultFileFormatrepositoryProperties  ^self repository propertiesnewCommitWalk  ^repository newCommitWalk fromCommit: selfcommitish: arg1  commitish := arg1execute  self packageModel unloadpackages  ^#()onAccept: arg1  acceptBlock := arg1readParametersFromContext: arg1  super readParametersFromContext: arg1.  item := arg1 itementryByPath: arg1  ^arg1 = '.' ifTrue: [ self ] ifFalse: [ (($/ split: arg1) reject: #isEmpty) inject: self into: [:arg2 :arg3 |  arg2 entryByName: arg3 ] ]anySatisfy: arg1  ^falsedescription  ^target descriptiondescription  ^'User: ' , self username , ' Public: ' , self publicKey , ' Private: ' , self privateKey= arg1  ^self item = arg1 itemvisitNoModification: arg1  arg1 definition accept: selfrowHeight: arg1  rowHeight := arg1sourceDirectoryTree  ^sourceDirectoryTreevisitShouldCommitBeforePullError: arg1  | tmp1 |  tmp1 := UIManager default confirm: 'Your repository has uncommited changes. Merging incoming commits will changeyour current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.' label: 'You might loose your current changes!' trueChoice: 'Proceed anyway' falseChoice: 'Cancel' cancelChoice: nil default: false.  tmp1 ifFalse: [ ^self ].  arg1 resumeensureDirectory: arg1 inParentNode: arg2  arg2 childAt: arg1 basename ifPresent: [:arg3 |  self assert: arg3 value isDirectoryDefinition.        ^arg3 ].  ^arg2 addChild: (IceDirectoryDefinition named: arg1 basename)location: arg1  location := arg1.  self resetHandlefileUtils  ^IceLibgitFiletreeFileUtilsaccept: arg1  ^arg1 visitEmptyNode: selfchangeSelected  | tmp1 |  self flag: #todo.  tmp1 := changeList widget selectedIndex.  tmp1 = 0 ifTrue: [ ^nil ].  ^changeList widget dataSource realElementAt: tmp1tagNameInputText: arg1  tagNameInputText := arg1setModelBeforeInitialization: arg1  model := arg1mergeWithLeftModification: arg1  ^IceNonConflictingOperation operation: arg1newBadgeFont  | tmp1 |  tmp1 := StandardFonts codeFont.  ^(LogicalFont familyName: tmp1 familyName pointSize: tmp1 pointSize - 3) weightValue: 700includes: arg1  ^self commitDictionary includesKey: arg1 idpackage  ^packageexecute  tool viewPullRequest: itemisSameAs: arg1  ^arg1 species = self species and: [ self name = arg1 name and: [ arg1 name notNil ] ]initializeWidgets  commitLabel := self newLabel.  commits := self newIceTable.  diff := self instantiate: IceTipCommitInfoPresenter.  mergeButton := self newButton.  acceptButton := self newButton.  rejectButton := self newButton.  commitLabel label: 'Commits'.  self initializeCommitsTable.  self initializeDiff.  mergeButton label: 'Merge into image'.  acceptButton label: 'Accept pull request'.  rejectButton label: 'Reject pull request'.  self focusOrder     add: commits;     add: diff;     add: mergeButton;     add: acceptButton;     add: rejectButtonsetModelBeforeInitialization: arg1  model := arg1initializeCredentialsList  credentialsList widget     beResizable;     addColumn: (IceTipTableColumn new           id: 'Host';           action: #hostDescription;           width: 100 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Type';           action: #type;           width: 75 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Description';           action: #description;           yourself);     dataSource: self newCredentialsDataSource;     selectRowIndex: 1;     enableFilter: IceTipRepositoryFilter;     explicitFunctiontextField  ^textFieldisFileDefinition  ^trueinitializeWidgets  super initializeWidgets.  pullRequests := self newIceTable.  details := self instantiate: IceGitHubPullRequestDetailModel.  self initializePullRequestsTable.  self focusOrder     add: pullRequests;     add: detailsfromTag: arg1  self subclassResponsibilityerrorLabel: arg1  errorLabel := arg1visitPackage: arg1  index addPackage: arg1package: arg1  package := arg1markAsConflict  self selectedChangeWrapper item value clearSelection.  self changed: #changes.  self updateSourcenewDiffTab  ^self newTab     label: 'Diff';     icon: (self iconNamed: #diff);     closeable: false;     yourselfcommit: arg1 then: arg2  arg1     repository: self entity;     onSuccess: arg2;     executeaddButton  ^addButtonlast: arg1  last := arg1.  (arg1 ~= #none and: [ self first = arg1 ]) ifTrue: [ self first: #none ]statusBar: arg1  statusBar := arg1addItemLeft: arg1  self leftPanel addMorphBack: arg1usernameInput  ^usernameInputpackage: arg1  package := arg1visitShouldCommitBeforePullError: arg1  self visitGenericError: arg1defaultMenuItemName  ^'Reset ' , selectedBranch name , ' to commit ' , selectedCommitish shortIdrepository: arg1  repository := arg1configureBuilder: arg1  arg1 beGithubpath  ^RelativePath newcommit  repository handleLibgitError: [ | tmp1 tmp2 |        tmp2 := (self repositoryHandle lookupLocalBranch: self name) targetId.        tmp1 := LGitCommit of: self repositoryHandle fromId: tmp2.        ^self repository commitFromGitCommit: tmp1 ]checkoutBranchPanelsOnModel: arg1  ^self plugins inject: #() into: [:arg2 :arg3 |  arg2 , (arg3 checkoutBranchPanelsOnModel: arg1) ]writerClass  ^self repository properties writerClasscommitish: arg1  commitishToTag := arg1packageNames  ^self repository commitsInPackageCache at: self ifAbsentPut: [ self fetchPackageNames ]privateKey  ^privateKeyInput location ifNil: [ '' ] ifNotNil: [:arg1 |  arg1 pathString ]mcCommit  ^MCVersion newversion  ^self itemfileNameForMethod: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self repository subdirectory ifNotEmpty: [:arg2 |  tmp1 add: arg2 ].  tmp1     add: (self cypressPackageName: arg1 package);     add: (self cypressClassOrTraitName: arg1);     add: (self cypressMethodSideName: arg1);     add: (self cypressMethodName: arg1).  ^String streamContents: [:arg3 |  tmp1 asStringOn: arg3 delimiter: '/' ]mergeStateWith: arg1  ^arg1 mergeWithInMergeWorkingCopyState: selfinitialize  super initialize.  first := #modified.  last := #notLoadedbasicExecute  self fetchAllRemotes.  (IceTipCheckoutBranchDialog on: self repositoryModel)     withOnlyNewBranch;     openDialogWithSpecrepository: arg1  repository := arg1loadPackageNamed: arg1  self repository workingCopy loadPackageNamed: arg1 fromCommit: selfcontents  ^item children collect: [:arg1 |  IceMergeListWrapper with: arg1 model: model ]emailLabel  ^emailLabelprojectName  ^builder locationToUse basenameexecute  self withErrorHandlingDo: [ self validateRemotesPresent.        (IceTipPushBrowser onRepositoryModel: self repositoryModel) openWithSpec ]execute  IceTipAddPlaintextCredentialsModel new     credentialStore: store;     tool: tool;     openNonModalcontextSelection  ^nilisBinary  [ contents utf8Decoded ] on: ZnInvalidUTF8 do: [ ^true ].  ^falseicon  ^self iconNamed: #dirtyMonticelloPackageinitializeWidgets  iconPanel := self newIcePanel.  iconPanel widget addMorph: (self iconNamed: #question) asMorph.  confirmLabel := self newIceReadOnlyText.  confirmLabel widget contentsWrapped: (self class confirmMessage format: {self repository name .               self branchName}).  mergeWithMasterCheckbox := self newCheckBox     label: ('Merge with branch {1}' format: {self repository branchName});     state: true.  self focusOrder add: mergeWithMasterCheckboxdefinitionFor: arg1 path: arg2 commit: arg3  ^((IceLibgitFiletreeLogReader fileName: arg2 on: arg3)     package: arg1 package mcPackage;     packageDirectory: (self repository directoryPathStringForPackage: arg1 package);     definitions) detect: [:arg4 |  arg4 isMethodDefinition and: [ arg4 selector = arg1 selector ] ] ifNone: [ MCMethodDefinition className: arg1 origin name selector: arg1 selector category: #'' timeStamp: nil source: '' ]removeDirectory  | tmp1 |  tmp1 := selectedDirectoryPath asResolvedBy: self model fileSystem.  tmp1 exists ifTrue: [ (UIManager default questionWithoutCancel: ('Are you sure to delete ''{1}''?' format: {tmp1 basename}) title: 'Remove directory') ifFalse: [ ^self ].        tmp1 ensureDelete ].  sourceDirectoryTree widget dataSource updateData.  sourceDirectoryTree widget dataSource expandAll.  sourceDirectoryTree widget selectIndex: (sourceDirectoryTree widget dataSource indexOfElement: tmp1 parent)readParametersFromContext: arg1  super readParametersFromContext: arg1.  package := self packageModel entitygetBranches: arg1 project: arg2  ^self get: 'repos/' , arg1 , '/' , arg2 , '/branches'addRemote  (IceTipAddRemoteDialog on: self model repositoryModel)     onAccept: [:arg1 |  self model reset.        self refresh.        self selectRemoteNamed: arg1 ];     openDialogWithSpecentry  ^entrypushTag: arg1 toRemote: arg2 gitRemote: arg3 progress: arg4  arg3 pushWithRefSpec: (LGitRefSpec new           source: 'refs/tags/' , arg1 name;           destination: 'refs/tags/' , arg1 name;           yourself) pushOptions: (LGitPushOptions defaults           callbacks: ((LGitRemoteCallbacks withProvider: (IceCredentialsProvider defaultForRemote: arg2))                 pushTransferProgress: arg4;                 yourself);           yourself)newDataSourceMatching: arg1  ^arg1 executeOn: selfmodifyingPackage: arg1  modifyingPackage := arg1addChild: arg1  children ifNil: [ children := OrderedCollection new ].  children add: arg1.  arg1 parent: self.  ^arg1path  ^self parent ifNotNil: [:arg1 |  arg1 path , {self} ] ifNil: [ {self} ]model  ^modeltypeLabel  ^typeLabelreadParametersFromContext: arg1  super readParametersFromContext: arg1.  (self repositoryModel isNotNil and: [ self repositoryModel isMissing not ]) ifTrue: [ self badge: self repositoryModel numberOfOutgoingCommits ]baseSHA  ^(self jsonAt: #base) at: #shabasicSetProject: arg1  project := arg1branchNameMorph  ^('{1} at ' format: {model branchName}) asMorphadditionHighlightColor  ^super removalHighlightColordefaultMessageText  ^'There was an authentication error while trying to execute the operation: {1}. This happens usually because you didn''t provide a valid set of credentials. You may fix this problem in different ways: 1. adding your keys to ssh-agent, executing ssh-add ~/.ssh/id_rsa in your command line.2. adding your keys in settings (open settings browser search for "Use custom SSH keys" andadd your public and private keys).3. using HTTPS instead SSH (Just use an url in the form HTTPS://etc.git)'name  ^name , (isMeta ifTrue: [ ' class' ] ifFalse: [ '' ])messageLabel: arg1  messageLabel := arg1hasParent  ^self gitRepositoryInfo includesKey: #parentmoveToRemote: arg1  arg1 ifNil: [ ^self ].  self model useRemote: arg1.  self model reset.  self refreshCommits.  self updateTitlehasNext  ^result isNil or: [ self parseMorePages: (result headers at: 'Link' ifAbsent: [ nil ]) ]compatibleUsername  ^'CompatibleUserName'commitishNamed: arg1  ^self subclassResponsibilityhash  ^self name hashdataSource: arg1  dataSource := arg1allBranches  self subclassResponsibilitytool: arg1  tool := arg1title  ^'Push {1}/{2} to {3}' format: {self model repositoryName .         self model branchName .         self model remoteName}diffToFirstAncestor  | tmp1 tmp2 |  tmp2 := self entity ancestors ifNotEmpty: #first ifEmpty: [ IceNoCommit new ].  tmp1 := self calculateDiff: [ self entity diffTo: tmp2 ].  ^IceTipCommitDiffModel repositoryModel: self repositoryModel on: tmp1canReadProjectFromCommitish: arg1  ^arg1 isWorkingCopy not and: [ (arg1 fileSystem / '.project') exists not ]refreshRepositoryProperties  properties := self referenceCommit properties asBornPropertiesaddDirectoryButton  ^addDirectoryButtonvalidateRemotesPresent  self repositoryModel hasRemotes ifFalse: [ IceNoRemote signal ]contentsString  ^ByteArray streamContents: [:arg1 |  (STONWriter on: (ZnCharacterWriteStream on: arg1))           prettyPrint: true;           newLine: OSPlatform current lineEnding;           nextPut: self properties ]visitAddition: arg1  arg1 definition accept: selfnewActionButton  ^self subclassResponsibilitycommitsPanel: arg1  commitsPanel := arg1isUnborn  ^truewriteVersion: arg1  (self repositoryDirectory / arg1 package name) ensureDeleteAll.  self writeSnapshot: arg1 snapshotrightOperation: arg1  rightOperation := arg1description  ^'Fetch required. ' , self referenceCommit descriptionwithoutNewRepository  types := self allTypes reject: #isNewRepository.  typeList widget dataSource elements: types.  typeList widget refreshsourceDirectorySelectionChanged: arg1  | tmp1 tmp2 |  arg1 ifEmpty: [ selectedDirectoryPath := RelativePath new.        self sourceDirectoryTree widget selectRowIndex: 1.        tmp2 := self sourceDirectoryTree widget dataSource rootItem children first.        tmp1 := self sourceDirectoryTree widget dataSource rootItem children first data ] ifNotEmpty: [ [ tmp2 := self sourceDirectoryTree widget dataSource elementAt: arg1 first ] on: SubscriptOutOfBounds do: [ ^self ] ].  tmp1 := tmp2 data.  selectedDirectoryPath := tmp1 relativeTo: self model fileSystem.  formatList setSelectedItem: (self guessFormatFromDirectory: tmp1).  self updateRemoveAndAddButtonid  ^self commit idprojectNameLabel  ^projectNameLabelrepository: arg1  repository := arg1initializeWidgets  super initializeWidgets.  self initializeRemoteURL.  self remoteInputText ghostText: 'e.g., ssh://[user@]host.xz[:port]/path/to/repo.git'.  self remoteInputText whenTextChanged: [:arg1 |  self projectLocation appendPath: (self extractProjectName: arg1) ].  self focusOrder add: self remoteInputTextnewLayout  ^SpecLayout composed newColumn: [:arg1 |   ]source  ^String streamContents: [:arg1 |  arg1 << '"protocol: ' << self definition category           << '"';           cr;           << self definition sourceCode ]leftContents  ^definition contentscanRevertChanges  ^truemcRepositoryClass  ^MCGitBasedNetworkRepository allSubclasses detect: [:arg1 |  arg1 basicDescription = self class type ]select: arg1  | tmp1 tmp2 |  tmp1 := self children collect: [:arg2 |  arg2 select: arg1 ].  ((tmp1 anySatisfy: [:arg3 |  arg3 isEmptyNode not ]) or: [ arg1 value: self value ]) ifFalse: [ ^IceEmptyNode new ].  tmp2 := self class value: self value.  tmp1 do: [:arg4 |  arg4 addTo: tmp2 ].  ^tmp2credentials  ^credentialsreadParametersFromContext: arg1  super readParametersFromContext: arg1.  tool := arg1 tooltextField: arg1  textField := arg1.  textField whenTextChanged: [:arg2 |  self textUpdated: arg2 ]subdirectoryInputText  ^subdirectoryInputTextmodel: arg1  model := arg1accept  IceTipStandardAction new     repository: self repository;     message: ('Migrating {1} sources to tonel' format: {self repository name});     onSuccessRepositoryModified;     onSuccess: [ UIManager default inform: 'Sources migrated!' ];     execute: [ self doAccept ]leftContents  self subclassResponsibilityedit  < noCache>  (IceTipEditProjectDialog on: self entity project) openDialogWithSpecauthorText  ^authorTexthasBranches  ^self branches isNotEmptyemailInput: arg1  emailInput := arg1fromLGitId: arg1  self revwalk pushCommit: arg1repository  ^repositorymessageText: arg1  messageText := arg1properties  ^propertiesbasicPushTo: arg1  | tmp1 |  tmp1 := (LGitRemote of: self repositoryHandle named: arg1 name) lookup.  [ | tmp2 |  tmp2 := IcePushTransferProgress new.  self pushBranchToRemote: arg1 gitRemote: tmp1 progress: tmp2.  self pushTagsToRemote: arg1 gitRemote: tmp1 progress: tmp2.  self setUpstreamIfMissing: arg1 ] on: LGit_GIT_ENONFASTFORWARD do: [:arg2 |  arg2 resignalAs: (IceRemoteDesynchronized new                 remote: arg1;                 yourself) ]sourceVersion  ^mergeCommitpath  ^Path from: filePathStringnewContextWithSelection: arg1  ^self newContext     packageModel: arg1;     yourselfbrowseRepositoryVersion  < noCache>  | tmp1 |  tmp1 := self entity mcSnapshotInRepository.  (MCSnapshotBrowser forSnapshot: tmp1) showLabelled: 'Snapshot for ' , self entity namebranchName  ^self repositoryModel branchNamefromBranch: arg1  [ self revwalk pushReference: (lgitRepository lookupBranch: (arg1 isRemote ifTrue: [ arg1 fullname ] ifFalse: [ arg1 shortname ]) remote: arg1 isRemote) ] on: LGit_GIT_EINVALIDSPEC do: [ self fromLGitId: (lgitRepository revparse: arg1 name) id ]do: arg1  arg1 value: self value.  self childrenDo: [:arg2 |  arg2 do: arg1 ]isRemote  ^falsecommitsDo: arg1  self newCommitWalk commitsDo: arg1matches: arg1  ^self entity name matchesRegexIgnoringCase: arg1owner  ^nilstoreSshCredential: arg1 forHostname: arg2  sshCredentials at: arg2 put: arg1isLoadedPackageNamed: arg1  ^RPackageOrganizer default includesPackageNamed: arg1definition: arg1  definition := arg1info: arg1  info := arg1hash  ^self class hashnormalBorderStyle  ^BorderStyle simple     width: 0;     baseColor: Color transparenticon  ^self class iconmergeWith: arg1 onLeft: arg2 onRight: arg3 onMerge: arg4  | tmp1 tmp2 |  tmp1 := arg4 value: self value value: arg1 value.  tmp2 := self class value: tmp1.  self keysDo: [:arg5 |  (arg1 includesKey: arg5) ifTrue: [ | tmp3 |              tmp3 := self / arg5 mergeWith: arg1 / arg5 onLeft: arg2 onRight: arg3 onMerge: arg4.              tmp3 addTo: tmp2 ] ifFalse: [ tmp2 addNode: (self / arg5 collect: arg2) ] ].  arg1 keysDo: [:arg5 |  (self includesKey: arg5) ifFalse: [ tmp2 addNode: (arg1 / arg5 collect: arg3) ] ].  ^tmp2lookupSnapshot  ^commit snapshotForPackage: self packagecontents: arg1  self basicAt: 1 put: arg1items: arg1  items removeAll.  items addAll: arg1.  self refreshinitialExtent  ^(500 @ (self class inputTextHeight * 2 + self class buttonHeight + 50)) scaledByDisplayScaleFactornodesDo: arg1  childrenDictionary valuesDo: arg1isLeftChosen  ^chosen = operationinitializeWidgets  self initializeWidgetsContents.  self initializeFocusOrderisCloneOfUrl: arg1  ^self origin url = arg1initializeFocusOrder  self focusOrder add: self tagNameInputTextfileReference: arg1  fileReference := arg1contents  ^'"' , self protocol , '"' , sourceCodeupdateDiskWorkingCopy: arg1  arg1 tree accept: (IceGitWorkingCopyUpdateVisitor new           repository: repository;           index: self;           diff: arg1)loadPackagesNamed: arg1  self loadPackagesNamed: arg1 fromCommit: self repository head committagName  ^self tagNameInputText text asString trimBothputFocusOrder  self focusOrder     add: usernameInput;     add: publicKeyInput locationInput;     add: privateKeyInput locationInput;     add: passphraseInput;     add: storeCheckboxvalidateCanPull  self isModified ifTrue: [ IceShouldCommitBeforePull signal ]all  | tmp1 |  tmp1 := Array new writeStream.  [ self hasNext ] whileTrue: [ tmp1 << self next ].  ^tmp1 contentsdefaultAction  | tmp1 tmp2 |  tmp2 := IceTipMergeMorph forMerger: merge.  tmp2     fromDescription: merge sourceDescription;     toDescription: merge targetDescription.  tmp1 := tmp2 newWindow     title: 'Merge';     yourself.  UIManager default openModal: tmp1.  ^tmp2 mergedcommit: arg1  self subclassResponsibilitytool: arg1  tool := arg1execute  self flag: #pharo8.  self class environment at: #ManifestNativeBrowser ifPresent: [:arg1 |  location openInNativeBrowser ] ifAbsent: [ self inform: 'This action needs the Native-Browser project loaded in the image to work.' ]emailInput  ^emailInputchooseButton  ^chooseButtoninitialize  super initialize.  ensureProjectFile := falserepository  ^index repositorykey  ^leftOperation keyrepositoryName  ^self repositoryModel nameinitialExtent  ^(1000 @ 700) scaledByDisplayScaleFactorupdateSource  | tmp1 |  tmp1 := self selectedChange.  self diffMorph allowJoinClicks: false.  tmp1 isNil ifTrue: [ self diffMorph from: '' to: '' ] ifFalse: [ self diffMorph from: tmp1 rightContents asText to: tmp1 leftContents asText contextClass: tmp1 contextClass ].  (tmp1 isNil or: [ tmp1 isConflict not ]) ifTrue: [ ^self ].  tmp1 isLeftChosen ifTrue: [ self diffMorph indicateDst ] ifFalse: [ self diffMorph indicateSrc ]defaultColor  ^self theme backgroundColor negated alpha: 0.05fileSystem  ^self commit fileSystemmergeWithOperation: arg1  ^arg1 mergeWithLeftModification: selfhostInput  ^hostInputaccept: arg1  ^arg1 visitRemoval: selfinitializeWidgets  super initializeWidgets.  passwordInput encrypted: falsereadContextParametersFromModel: arg1  super readContextParametersFromModel: arg1.  selectedBranch := arg1initialize  super initialize.  self bindKeyCombination: PharoShortcuts current copySelectionShortcut toAction: [:arg1 |  arg1 editor copySelection ].  self bindKeyCombination: PharoShortcuts current selectAllShortcut toAction: [:arg1 |  arg1 handleEdit: [ arg1 selectAll ] ]visitDirectoryDefinition: arg1  self visitChildrenOf: currentNodeaddToPatcher: arg1  (self isMeta and: [ mcDefinition isNil ]) ifTrue: [ ^self ].  arg1 addDefinition: self asMCDefinitionensureDirectoryAtPath: arg1 inNode: arg2  | tmp1 |  arg1 ifEmpty: [ ^arg2 ].  tmp1 := self ensureDirectoryNamed: arg1 first inNode: arg2.  ^self ensureDirectoryAtPath: arg1 allButFirst inNode: tmp1commitsDo: arg1  self newCommitWalk commitsDo: arg1packageList: arg1  packageList := arg1addItem: arg1 into: arg2  arg2 addItemLeft: arg1model: arg1  model := arg1repository  ^repositoryisConflict  ^falsediscardChanges  self discardChanges: self diffToReferenceCommit treecontextClass  ^operation contextClassnewSelectionMorphFor: arg1  ^CheckboxButtonMorph new     selected: (self isSelected: arg1 data);     target: [ self toggleSelectionOf: arg1 ];     actionSelector: #value;     yourselffirstNodeSuchThat: arg1 ifNone: arg2  (arg1 value: self) ifTrue: [ ^self ].  ^arg2 valuerevparse: arg1  self handleLibgitError: [ | tmp1 tmp2 |        tmp2 := (self repositoryHandle revparse: arg1) object id.        tmp1 := LGitCommit of: self repositoryHandle fromId: tmp2.        ^self commitFromGitCommit: tmp1 ]children  ^#()sourceVersion: arg1  source := arg1initialize  tries := 0checksTable  ^checksTableoldDefinition  ^oldNodedeleteBranch: arg1 project: arg2 name: arg3  ^self delete: 'repos/' , arg1 , '/' , arg2 , '/git/refs/heads/' , arg3patch: arg1 with: arg2  ^self jsonContentsWithValidationDo: [ (self newRequestTo: arg1)           in: arg2;           patch;           response ]< arg1  | tmp1 |  tmp1 := arg1 iceSemanticVersion.  ^self asInteger < tmp1 asIntegerremoveFrom: arg1  self subclassResponsibilityhistory: arg1  history := arg1colorError  ^Smalltalk ui theme dangerTextColorinitialExtent  ^(700 @ 500) scaledByDisplayScaleFactorsnapshotForPackage: arg1  ^[ (self mcVersionFor: (self versionFor: arg1)) snapshot ] on: IceVersionDoesNotExist do: [ MCSnapshot empty ]labelWidth: arg1  ^labelWidth := arg1hasIncomingCommitsFrom: arg1  arg1 fetch.  ^arg1 hasRemoteBranchNamed: self namestoreCredentials  ^storeCheckbox stateisCommitMerged: arg1  self subclassResponsibilityputFocusOrder  self focusOrder     add: hostInput;     add: usernameInput;     add: passwordInput;     add: storeCheckboxexecuteOn: arg1  self dataSource: arg1.  ^self executeconfirmLabel  ^confirmLabelnext  nextPage ifNil: [ nextPage := 1 ].  [ result := self api getRaw: (self request asUrl ? (#page -> nextPage asString)) asString ] ensure: [ nextPage := nextPage + 1 ].  ^STON fromString: result contentsobtainSshCredentials: arg1  | tmp1 |  tmp1 := IceTipAskSSHCredentialsModel new     credentials: self sshCredentials;     credentialStore: self credentialStore;     open.  arg1 readFrom: tmp1canActivateCommand: arg1  ^arg1 actsOnBranch: selfmodifiedPackages  ^self workingCopy modifiedPackagessnapshotFor: arg1  ^[ (self repository mcVersionFor: (self versionFor: arg1)) snapshot ] on: IceVersionDoesNotExist do: [:arg2 |  MCSnapshot empty ]mergeCommit: arg1  mergeCommit := arg1optionA: arg1  optionA := arg1initializeSidebarTree  sidebarTree widget dataSource: self newSidebarTreeDataSource.  self selectCurrentBranchcontents  self subclassResponsibilityfileSystem  ^self commit fileSystemrepositoryModel: arg1  repositoryModel := arg1selectedProtocol  ^self protocolDropList selectedItembuildWidget  ^SwappedColorDiffMorph new     on: self;     from: self leftText to: self rightText contextClass: self contextClass;     hResizing: #spaceFill;     vResizing: #spaceFill;     setBalloonText: self help;     showOptions: self showOptions;     showOnlyDestination: self showOnlyDestination;     yourselfincludesPackageNamed: arg1  ^self isEmpty not and: [ self codeSubdirectoryNode includesKey: arg1 ]beSwitchAndMerge  self allTypes do: #beSwitchAndMergeinitializeWidgets  super initializeWidgets.  diffPanel leftLabel: 'Working Copy'.  diffPanel rightLabel: 'Checkout ' , model targetName.  checkoutStrategyLabel := self newLabel label: 'How to checkout:'.  checkoutStrategyList := self newDropList.  self initializeCheckoutStrategyList.  self focusOrder     removeAll;     add: self actionPanel;     add: self checkoutStrategyList;     add: self diffPanelcheckoutWithStrategy: arg1  self repository localBranches detect: [:arg2 |  arg2 name = self shortName ] ifFound: [:arg2 |  ^arg2 checkout ].  self repository createBranch: self shortName inCommit: self commit.  ^super checkoutWithStrategy: arg1title  ^'Edit credential for ' , credential host= arg1  ^arg1 isRemote and: [ self name = arg1 name ]matches: arg1  ^arg1 name asLowercase includesSubstring: self pattern asLowercaseacceptError: arg1  arg1 visitAuthenticationError: selfaccept: arg1  ^tree accept: arg1diff  ^diff ifNil: [ diff := self newDiff ]nameInput: arg1  nameInput := arg1userName  ^self userNameInputText text asString trimmedauthor  ^self commit authorvalidate  self assert: self location notNil description: 'Project location must exist!'.  self assert: self location exists description: 'Project location must exist!'.  self assert: (IceRepositoryCreator isGitRoot: self location) description: 'Project location does not seems to be a valid git repository.'contextClass  ^IceTipContextmergeWithLeftRemoval: arg1  ^IceConflictingOperation left: arg1 right: selfownerName  ^classNameisDetached  ^truemergeWithLeftAddition: arg1  self subclassResponsibilitydelete  self subclassResponsibilityisDetached  ^self referenceCommits first ~= self repository headCommitcopyCommitIDToClipboard  < noCache>  self copyToClipboardId: self commitIddiffPanel: arg1  diffPanel := arg1user  ^userbasicExecute  self repositoryModel edittimeStamp  self subclassResponsibilitycreateBranch: arg1  | tmp1 |  self handleLibgitError: [ [ self repositoryHandle isUnborn ifTrue: [ self location / '.git'                 / 'HEAD' ensureDelete;                 writeStreamDo: [:arg2 |  arg2                       nextPutAll: 'ref: refs/heads/';                       nextPutAll: arg1 ] ] ifFalse: [ tmp1 := self repositoryHandle createBranch: arg1 target: self repositoryHandle head.              self repositoryHandle setHead: tmp1 ] ] on: LGit_GIT_EEXISTS do: [:arg3 |  IceBranchAlreadyExists new                 branchName: arg1;                 signal ].        ^self head ]credentialStore: arg1  credentialStore := arg1defaultHelp  ^self class defaultHelpstoreInto: arg1 forHostname: arg2  host := arg2.  arg1 storePlaintextCredential: self forHostname: arg2displayMode  ^displayMode ifNil: [ displayMode := IceTipToolbarDisplayMode default ]readProjectFromCommitish: arg1  ^IceInvalidProject onCommitish: arg1iconPanel: arg1  iconPanel := arg1chooseLocal  ^item value selectRightdiffToHead  | tmp1 tmp2 |  tmp1 := self repositoryModel entity headCommit.  tmp2 := self calculateDiff: [ self entity diffTo: tmp1 ].  ^IceTipCommitDiffModel repositoryModel: self repositoryModel on: tmp2typeList  ^typeListcheckout  self checkout: (IceCheckoutAlreadyLoadedPackages new           committish: self;           yourself)executeCheckoutActionAndThen: arg1  < noCache>  IceTipStandardAction new     repository: self repository;     message: ('Checking out {1} from {2}' format: {self targetName .               self repositoryName});     onSuccessRepositoryModified;     onSuccess: arg1;     execute: [ self checkout ]sortByName: arg1  ^arg1 sorted: #packageName ascendingisMerged  ^history headHistory includes: iceCommitbeAnonymous  isAnonymous := truelocked  ^falsestoreVersion: arg1  repository internalStoreVersion: arg1resolve: arg1 ifPresent: arg2 ifAbsent: arg3  ^arg3 valueallBaselines  ^(self workingCopy packages select: [:arg1 |  arg1 name beginsWith: self class baselinePrefix ]) sorted: [:arg2 :arg3 |  arg2 name < arg3 name ]remoteBranchNamed: arg1 ifPresent: arg2  ^self branchNamed: arg1 ifPresent: arg2 ifAbsent: [ self ]updateRemoveAndAddButton  addDirectoryButton enabled: selectedDirectoryPath isNotNil.  removeDirectoryButton enabled: selectedDirectoryPath isWorkingDirectory notorganizer  ^self ownerinternalStoreVersion: arg1  self subclassResponsibilityrootForItems: arg1  self rootItem: (FTRootItem new           data: arg1;           yourself)newCommitWalk  self subclassResponsibilitydiff  ^self subclassResponsibilityremoveClassNamed: arg1  (Smalltalk globals at: arg1 ifAbsent: [ ^self ]) removeFromSystemonAccept: arg1  acceptBlock := arg1isDirectoryDefinition  ^falserequest  ^requestdirectory  ^self backend codeDirectoryresolveConflicts  self hasConflicts ifTrue: [ | tmp1 |        tmp1 := IceMergeResolutionRequest new           merger: self;           signal: 'Merging ' , mergeCommit description , ' into ' , self leftCommit description.        tmp1 ifFalse: [ IceMergeAborted signal ] ]updateOn: arg1  self updateLabelOn: arg1.  self updateContentsOn: arg1name  ^namesetMergeStateBetweenCommits: arg1  self referenceCommit: arg1shortId  ^self entity shortIditem: arg1  item := arg1validateIsBranch  newIndex  ^IceGitIndex on: selfchanges  ^changes ifNil: [ changes := OrderedCollection new ]cancelAction  icon  self isRightChosen ifTrue: [ ^self iconNamed: #changeBlock ].  self isLeftChosen ifTrue: [ ^self iconNamed: #forward ].  ^self operationIconisUnbornBranch  ^truetitlePanel: arg1  titlePanel := arg1addComment: arg1  IceGitHubAPI new addComment: self owner project: self projectName number: self number data: {(#body -> arg1)} asDictionaryheadLabel  ^(self jsonAt: #head) at: #labelcommit  ^commitselectLabel: arg1  self selectButton label: arg1isRightChosen  self subclassResponsibilityisEmpty  self subclassResponsibilityinitialize  super initialize.  isDirty := falselabel  ^label ifNil: [ self class defaultLabel ]storeCredential: arg1 forHostname: arg2  self loadFromStore.  arg1 storeInto: self forHostname: arg2.  self saveIntoStorechangesFromNoCommit: arg1  ^#()isHead  ^commitish = repository headtimeStamp  ^self entity timeStamploadAncestorsAndStepChildren  self shouldBeImplementedlocation  ^locationbasicContents  ^contentsisRepositoryMissing  ^self repositoryModel isMissing or: [ self repositoryModel isCodeMissing ]mergeWithLeftModification: arg1  ^self subclassResponsibilitypreferredColor  ^nildiffFor: arg1  ^arg1 diffFromHeadonChoose: arg1  chooseBlock := arg1initializePresenter  super initializePresenter.  self typeList     items: self class availableTypes;     displayBlock: [:arg1 |  arg1 ];     setSelectedItem: self class defaultTypeicon  ^icontoFileName: arg1  ^self subclassResponsibilityremoteBranchNamed: arg1 ifPresent: arg2 ifAbsent: arg3  self handleLibgitError: [ | tmp1 |        tmp1 := self repositoryHandle lookupRemoteBranch: arg1 ifAbsent: [ ^arg3 value ].        arg2 value: (self basicNewRemoteBranchNamed: tmp1 name) ]model  ^modelinitialExtent  ^(500 @ (self class inputTextHeight * 2 + self class buttonHeight + 50)) scaledByDisplayScaleFactorisUnborn  ^truerefreshToolbar  toolbar refreshaccept: arg1  ^arg1 visitModification: selfputFocusOrder  self focusOrder     add: hostInput;     add: usernameInput;     add: publicKeyInput locationInput;     add: privateKeyInput locationInput;     add: passphraseInput;     add: storeCheckboxprotocolDropList  ^protocolDropListpanel: arg1  panel := arg1branchModel: arg1  branchModel := arg1gtInspectorItemsIn: arg1  < gtInspectorPresentationOrder: 0>  ^arg1 fastTable     title: 'Items';     display: [ self children ];     column: 'Key' evaluated: [:arg2 |  arg2 key ] width: 200 * World displayScaleFactor;     column: 'Value' evaluated: [:arg2 |  arg2 value ] width: 400 * World displayScaleFactorprintOn: arg1  arg1 << (self name ifNil: [ 'noname' ]) << ' (' << self url << ')'versionsFor: arg1  self modifyingPackage: arg1.  ^self commits collect: [:arg2 |  arg2 versionFor: arg1 ]urlLabel: arg1  urlLabel := arg1newContextWithSelection: arg1  ^self newContext     repositoryModel: arg1;     yourselfallTypes  ^types ifNil: [ types := self createCheckoutBranchTypes ]visitChildrenOf: arg1  arg1 childrenDo: [:arg2 |  arg2 accept: self ]location: arg1  location := arg1branchNamePrefix  ^'refs/heads/'protocol: arg1  protocol := arg1setModelBeforeInitialization: arg1  model := arg1nameInput  ^nameInputvalidateCanCommit  order  ^SmallInteger maxVal - 1500versionName  ^'{1}-{2}.{3}' format: {self packageNameFromPackageDirectory .         self commit compatibleUsername .         self versionNumber}packages  ^#()selectedPackage  | tmp1 |  self flag: #todo.  tmp1 := packagesList widget selectedRowIndex.  tmp1 = 0 ifTrue: [ ^nil ].  ^packagesList widget dataSource elementAt: tmp1markAllAsConflict  self model mergeTree do: [:arg1 |  arg1 isConflict ifTrue: [ arg1 clearSelection ] ].  self changed: #changes.  self updateSourcelocation  ^locationexecute  self installBaseline: self packageincludesKey: arg1  ^falsecommitTabPanel: arg1  commitTabPanel := arg1rightContents  ^oldNode contentsremoteBranchNamed: arg1 ifPresent: arg2 ifAbsent: arg3  localRepository handleLibgitError: [ | tmp1 |        tmp1 := self repositoryHandle lookupRemoteBranch: self name , '/' , arg1 ifAbsent: [ nil ].        ^tmp1 ifNil: arg3 ifNotNil: [ ^arg2 value: (localRepository basicNewRemoteBranchNamed: tmp1 name) ] ]initialExtent  ^self class defaultExtentkey  ^super key , (self isMeta ifTrue: [ ' class' ] ifFalse: [ '' ])hash  ^self key hashshouldIgnoreNotifications  ^shouldIgnoreNotifications = trueaccept: arg1  ^arg1 visitImageChange: selfcheckMissing  self isMissing ifTrue: [ IceError signal: ('You have no repository atttached to project "{1}"' format: {self name}) ]uptadeSelectedPullRequest: arg1  self details pullRequest: (arg1 newSelectedRowIndexes ifNotEmpty: [:arg2 |  self pullRequests widget dataSource elementAt: arg2 first ] ifEmpty: [ IceGitHubNilPullRequest new ])project  self subclassResponsibilitycanRevertChanges  ^falseversion: arg1  version := arg1initialize  selectedItems := Set new.  super initializeokAction  | tmp1 |  tmp1 := self credentials.  self storeCredentials ifTrue: [ credentialStore storeCredential: tmp1 forHostname: remoteHostname ].  accepted := true.  ^tmp1icon  ^iconBlockchoose  self chooseReference ifNotNil: [:arg1 |  self location: arg1.        self onChoose ifNotNil: #value ]plugins  ^pluginsreadParametersFromContext: arg1  super readParametersFromContext: arg1.  branchModel := arg1 itemexecute  | tmp1 |  tmp1 := UIManager default request: 'Groups to install (a comma separated string)' initialAnswer: '' title: 'Enter groups to install'.  tmp1 ifNil: [ ^self ].  self installBaseline: self package groups: ((tmp1 substrings: ',') collect: #trimmed as: Array)contentPanel: arg1  contentPanel := arg1mcRepository  | tmp1 |  self guessRegisteredRepository ifNotNil: [:arg1 |  arg1 isValid ifTrue: [ ^arg1 metacelloAdapter: self projectVersion ].        arg1 forget ].  tmp1 := self mcRepositoryClass location: self location.  ^(Iceberg icebergRepositoriesURLs includes: tmp1 scpUrl) ifTrue: [ tmp1 ] ifFalse: [ tmp1 getOrCreateIcebergRepository metacelloAdapter: self projectVersion ]rightContents  ^definition contentsexecute  (IceTipAddPackagesDialog on: self repositoryModel) openDialogWithSpecdetect: arg1  ^(self firstNodeSuchThat: arg1) valueexecute  remoteModel fetchtitle  ^'Select branch to merge into ' , self model branchNamenewContextWithSelection: arg1  ^self newContext     item: arg1;     yourselfmatches: arg1  ^arg1 model name asLowercase includesSubstring: self patternaccept  acceptBlock ifNotNil: [ acceptBlock cull: self ].  self window deleteitem  ^itemwithResultDo: arg1  callback := arg1rejectButton: arg1  rejectButton := arg1initializeWidgets  iconPanel := self newIcePanel.  iconPanel widget addMorph: (self iconNamed: #question) asMorph.  confirmLabel := self newLabel label: (self class confirmMessage format: {self model name}).  removeFileSystemCheckbox := self newCheckBox label: self class removeMessage.  self focusOrder add: self removeFileSystemCheckboxcommitIdFrom: arg1  ^arg1 id hexStringisMergeWithCurrentBranch  ^mergeWithCurrentBranchleftPanel: arg1  leftPanel := arg1textUpdated: arg1  self filterWith: self textField getText= arg1  self species = arg1 species ifFalse: [ ^false ].  properties = arg1 properties ifFalse: [ ^false ].  self repository = arg1 repository ifFalse: [ ^false ].  ^truerepository  ^commitish repositoryModel entityhttpsUrl  ^'https://{1}/{2}.git' format: {self host .         self projectPath}isSingleCommitState  ^truefromLabel: arg1  fromLabel := arg1tagName: arg1  tagName := arg1reload  < noCache>  IceTipStandardAction new     repository: self entity repository;     message: ('Reloading package {1}' format: {self entity name});     onSuccessRepositoryModified;     execute: [ Iceberg announcer suspendAllForRepository: self entity repository while: [ self entity reload ] ]addRemote: arg1  (self hasRemoteNamed: arg1 name) ifTrue: [ IceRemoteAlreadyExistsError new           remoteName: arg1 name;           signal ].  self remoteAt: arg1 name put: arg1.  arg1 localRepository: selfcreateSourceDirectory  (location / self subdirectory) ensureCreateDirectory.  self properties     fileFormat: self class defaultFileFormat;     storehash  ^properties hashrepository: arg1  repository := arg1suspendAllMatching: arg1 while: arg2  suspendedConditions add: arg1.  arg2 ensure: [ suspendedConditions remove: arg1 ]repositoryModel  ^nilsourceDirectoryTree: arg1  sourceDirectoryTree := arg1diffToWorkingCopy  | tmp1 |  tmp1 := self calculateDiff: [ self entity diffToWorkingCopy ].  ^IceTipCommitDiffModel repositoryModel: self repositoryModel on: tmp1actionPanel  ^actionPanelhost  ^nilremote  ^remoteappendPath: arg1  keptLocation ifNil: [ keptLocation := self location ].  self basicLocation: (arg1 ifNotEmpty: [ (keptLocation ifNil: [ '.' asFileReference ]) / arg1 ] ifEmpty: [ keptLocation ])name  ^'Commits from {1} to {2}' format: {self fromCommit shortId .         self toCommit shortId}credentials: arg1  credentials := arg1optionsList: arg1  optionsList := arg1message  ^messagebaseRemote  ^baseRemoterightContents  ^operation rightContentsjson  ^jsonasBornProperties  ^selfheadModel  | tmp1 |  tmp1 := self entity head.  ^tmp1 isBranch ifTrue: [ self branchModelFor: tmp1 ] ifFalse: [ self commitModelFor: tmp1 ]isNewRepository  ^falsesourceDirectory  ^''initializeWidgets  super initializeWidgets.  hostLabel := self newLabel label: 'Host: '.  hostInput := self newTextInput     autoAccept: true;     whenTextChanged: [ self updateOkButton ];     yourselflibGitCommitsFrom: arg1 for: arg2  ^arg2 collect: [:arg3 |  LGitCommit of: arg1 fromId: (LGitId fromHexString: arg3 id) ]contextClass  ^definition contextClassaddToChangeBuilder: arg1  ^selftonelMethodClassOrTraitName: arg1  ^arg1 origin instanceSide name , (self tonelMethodClassExtension: arg1) , '.st'title  ^'Edit SSH keys for ' , self credentials hostDescriptionmcVersion  ^commit mcVersionFor: selfupstream  ^self subclassResponsibilityload  < noCache>  IceTipStandardAction new     repository: self entity repository;     message: ('Loading package {1}' format: {self entity name});     onSuccessRepositoryModified;     execute: [ Iceberg announcer suspendAllForRepository: self entity repository while: [ self entity load ] ]packageModel  ^packageModelversion  ^versionremoteAt: arg1 put: arg2  self handleLibgitError: [ self repositoryHandle addRemote: arg2 name url: arg2 url ]defaultMenuItemName  ^'Adopt commit ' , selectedCommitish shortId= arg1  ^arg1 isUnbornBranchrefresh  self rebuildToolbar.  packageList widget     in: [:arg1 |  arg1 dataSource elements: self model packageModels ];     refresh.  statusBar refreshinitializeWidgets  nameLabel := self newLabel label: 'Project Name'.  nameInput := self newLabel label: self model name.  sourceDirectoryLabel := self newLabel     label: 'Code directory';     yourself.  sourceDirectoryTree := self newIceTreeTable.  formatLabel := self newLabel label: 'Format'.  formatList := self newDropList.  addDirectoryButton := self newButton     label: '';     help: 'Create a new directory under the selected one';     iconName: #add;     enabled: false;     action: [ self addDirectory ];     yourself.  removeDirectoryButton := self newButton     label: '';     help: 'Removes the selected directory';     iconName: #remove;     enabled: false;     action: [ self removeDirectory ];     yourself.  self initializeMessagePanel.  self initializeDirectoryTree.  self focusOrder     add: nameInput;     add: sourceDirectoryTree;     add: formatListupto: arg1  self uptoCommit: arg1 commitcodeDirectory  ^self repository codeDirectoryleftContents  ^definition contentsiceCommitFrom: arg1  ^self commitFromGitCommit: arg1number  ^self jsonAt: #numberdefaultPosition  ^self class defaultPositionisGlobal  ^self globalCheckbox statecolumnTitleFor: arg1  arg1 id = #target_url ifTrue: [ ^'' ].  ^super columnTitleFor: arg1configureButton: arg1 item: arg2  arg1 on: arg2 getState: nil action: #execute label: nil icon: #icon menu: nil.  arg1 badgeSelector: #badgeheadLabel  ^'No PR selected'visitCheckoutConflict: arg1  self visitGenericError: arg1nameLabel  ^nameLabelisSSHUrl: arg1  ^self class isSSHUrl: arg1bePositionLeft  self position: IceTipItemPosition lefttitle  ^'Commit on {1} branch {2}' format: {self model name .         self model branchName}treeToShow  ^self changesToWorkingCopyTreesubdirectoryInputText: arg1  subdirectoryInputText := arg1definition: arg1  definition := arg1sidebarTree  ^sidebarTreeselectLeft  self subclassResponsibilityportName  ^self port asStringvalidate  self assert: (issueNumberText text asString notEmpty and: [ issueNumberText text isAllDigits ]) description: 'Please enter a valid issue number'.  self assert: fetched description: 'Please fetch a valid issue number'hasRemotes  ^self entity remotes notEmptylabel  ^labeldiffFor: arg1  ^arg1 diffToFirstAncestorheadBranchName: arg1  headBranchName := arg1fetch  self remotes do: [:arg1 |  arg1 fetch ] displayingProgress: [:arg1 |  'Remote: ' , arg1 name asString ]sidebarTree: arg1  sidebarTree := arg1incomingCommitsFrom: arg1  | tmp1 |  tmp1 := arg1 remoteBranchNamed: self name ifAbsent: [ ^#() ].  ^tmp1 newCommitWalk     uptoCommit: self commit;     commitsincludesPackageNamed: arg1  ^self packageNames includes: arg1removeFrom: arg1  arg1 removeMethod: selfcopyCommitIDToClipboard  < noCache>  repositoryModel copyCommitIDToClipboardnewContextWithSelection: arg1  ^self newContext     item: arg1;     yourselficeSemanticVersion  ^selfprintOn: arg1  super printOn: arg1.  arg1     nextPut: $[;     nextPutAll: self name;     nextPut: $]initialExtent  ^(500 @ (self class inputTextHeight * 2 + self class buttonHeight + 50)) scaledByDisplayScaleFactordiffPanel: arg1  diffPanel := arg1remote  ^remoteeditModelClass  ^IceTipEditPlaintextCredentialsModelopenDialogWithSpec  ^super openDialogWithSpec     okAction: [ self accept ];     yourselfcanActivateCommand: arg1  ^arg1 actsOnTag: selfcommit: arg1  commit := arg1visitMethodNode: arg1  repository workingCopy applyDefinition: arg1 inNode: currentNoderepositoryHandle  < repositoryHandleAccessor>  ^repository repositoryHandleaccept  basicExecute  credentials := IceGitHubAPI ensureCredentials.  UIManager default informUser: ('Retrieving branch information from {1}' format: {self remote url}) during: [ self cacheAllBranches ].  IceGitHubSelectListModel new     setModal: true;     title: ('Select branches to remove on remote {1}' format: {self remote name});     selectLabel: 'Remove branches';     items: self remoteBranches;     displayBlock: [:arg1 |  '{1} ({2})' format: {(arg1 at: 'name') .               (self timeSinceLastCommit: arg1)} ];     onAccept: [:arg2 |  self removeBranches: arg2 ];     openWithSpecloadChangesInWorkingCopy: arg1  | tmp1 |  tmp1 := IceWorkingCopyPatcherVisitor on: self repository.  arg1 accept: tmp1.  self ignoreNotificationsDuring: [ tmp1 load ]copyToClipboardId: arg1  Clipboard clipboardText: arg1 informing: ('Commitish ID copied to clipboard ({1})' format: {arg1})delete  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Removing tag {1}' format: {self name});     onSuccessRepositoryModified;     do: [ self repositoryModel entity removeTag: self entity ]readParametersFromContext: arg1  super readParametersFromContext: arg1.  packageModel := arg1 packageModellocalRepository  ^localRepositoryacceptError: arg1  arg1 visitGenericError: selfwithErrorHandlingDo: arg1  arg1 on: IceError , IceWarning do: [:arg2 |  arg2 acceptError: (IceTipInteractiveErrorVisitor on: self repository) ]newChecksTable  ^FTTableMorph new     addColumn: ((FTColumn id: #target_url) width: 18 * World displayScaleFactor);     addColumn: ((FTColumn id: #state) width: 65 * World displayScaleFactor);     addColumn: ((FTColumn id: #context) width: 100 * World displayScaleFactor);     addColumn: (FTColumn id: #description);     cellInset: 5 * World displayScaleFactor;     beResizable;     vResizing: #spaceFill;     hResizing: #spaceFill;     asSpecAdaptericon: arg1  icon := arg1diffToParent  ^self diffTo: (self ancestors ifNotEmpty: #first ifEmpty: [ nil ])remotePanel: arg1  remotePanel := arg1requestRemoteBranches  ^IceGitHubAPI new getBranches: self remote owner project: self remote projectBasenameselectAllChildrenOf: arg1  (self withAllChildrenOf: arg1) do: [:arg2 |  selectedItems add: arg2 data ]refreshWhenRepository: arg1  (self model repositoryModel isModelOf: arg1 repository) ifFalse: [ ^self ].  self model reset.  self refreshinitializeBlock  self signature: self class fnSpec block: self blockname  ^packagemergedTree  self shouldBeImplementedkeyPassphrase: arg1  keyPassphrase := arg1.  self storeIfDefaultaddString: arg1 at: arg2 encodedTo: arg3  | tmp1 tmp2 tmp3 |  tmp1 := arg2 lastIndexOf: $/.  tmp2 := arg2 first: tmp1.  tmp3 := arg2 copyFrom: tmp1 + 1.  (self packageFileDirectory entryByPath: tmp2) addEntryNamed: tmp3 withContents: arg1mergeCommit: arg1  ^IceMerge new     repository: self repository;     mergeCommit: arg1;     executebasicExecute  credentials := IceGitHubAPI ensureCredentials.  remote ifNil: [ remote := self repository branch hasUpstream ifTrue: [ self repository branch upstream remote ] ifFalse: [ self askRemote: self repository ] ].  (self validateMakePullRequestOn: self repository) ifFalse: [ ^#() ].  (IceGitHubCreatePullRequestModel repository: self repository credentials: self credentials headRemote: remote)     setModal: true;     onAccept: [:arg1 |  [ | tmp1 tmp2 |        tmp1 := arg1 send.        tmp2 := tmp1 at: 'html_url'.        UIManager default inform: 'Pull request created. Click to view on Github.' actionOnClick: [ self class environment at: #WebBrowser ifPresent: [:arg2 |  arg2 openOn: tmp2 ] ifAbsent: [ self inform: ('Cannot open "{1}" because the project WebBrowser is not present by default in Pharo 6.' format: {tmp2}) ] ] ] on: IceGitHubError do: [:arg3 |  self reportError: arg3 ] ];     openWithSpecdefaultMenuItemName  ^'Remove Remote Branches'isAncestorOf: arg1  ^falsewithTypes: arg1  types := arg1.  typeList widget dataSource elements: types.  typeList widget refresh= arg1  ^super = arg1 and: [ package name = arg1 package name ]categories: arg1  categories := arg1writerClass  ^self referenceCommit writerClasspath  ^pathcommitLabel  ^commitLabelname  self flag: #pharo6.  ^self realObject namecommitChanges: arg1 withMessage: arg2 force: arg3  | tmp1 |  self validateCanCommit.  self repository index     updateDiskWorkingCopy: arg1;     updateIndex: arg1.  (arg3 not and: [ repository index isEmpty ]) ifTrue: [ IceNothingToCommit signal ].  tmp1 := self repository commitIndexWithMessage: arg2 andParents: (self workingCopyState referenceCommits reject: [:arg4 |  arg4 isNoCommit ]).  ^tmp1labelFor: arg1  ^'{1} to {2}' format: {arg1 shortId .         arg1 ancestorShortIdOrOrigin}pull  self branch pullcollect: arg1  ^selfincludesCommit: arg1  ^self referenceCommit = arg1repository: arg1  repository := arg1validate  self assert: self tagName isNotEmpty description: 'Please enter your new branch name.'.  self assert: (self tagName noneSatisfy: #isSeparator) description: 'You can''t have spaces in your branch name.'openDialogWithSpec  ^super openDialogWithSpec     okAction: [ self accept ];     yourselfwriteVersion: arg1  | tmp1 |  directory := (tmp1 := MCFileTreeRepository parseName: arg1 info name) last.  self deleteExistingPackageStructureFor: tmp1.  self fileUtils ensureDirectoryExists: self packageFileDirectory.  self initializePackageFileDirectoryCache.  self writeFormat.  self writePackage: arg1 package.  self writeDefinitions: arg1.  arg1 dependencies do: [:arg2 |  self writeVersionDependency: arg2 ]title  ^self class titleactionWidth  ^actionWidth ifNil: [ self class defaultActionWidth ]createCheckoutBranchTypes  | tmp1 |  tmp1 := {(IceTipCheckoutNewBranchPanel on: self model) .   ((IceTipCheckoutBranchPanel on: self model)     title: 'Local';     icon: (self iconNamed: #branch);     yourself)} , (self model remoteModels collect: [:arg1 |  (IceTipCheckoutBranchPanel on: arg1)                 title: arg1 name;                 icon: (self iconNamed: #remote);                 yourself ]) , (self model entity pluginManager checkoutBranchPanelsOnModel: self model).  tmp1 do: [:arg1 |  arg1 onAccept: [ self window delete ] ].  ^tmp1remote  ^remoteincludesInWorkingCopyPackageNamed: arg1  ^(self packagesDictionary includesKey: arg1) and: [ (self packageNamed: arg1) isLoaded ]newContextWithSelection: arg1  ^self newContext     item: arg1;     yourselfprojectName  ^self projectNameInputText text asString trimmedwait: arg1 thenDo: arg2  currentWaitingProcess ifNotNil: [ currentWaitingProcess terminate ].  currentWaitingProcess := [ arg1 wait.  arg2 value ] forkNamed: 'GitHub issue tracker'targetVersion  ^targetbranch  ^self repository branchdataSource: arg1  super dataSource: arg1.  arg1 expandRootsisClassDefinition  ^trueisGitRoot: arg1  ^IceRepositoryCreator isGitRoot: arg1snapshotFor: arg1  ^MCSnapshot emptyisNewBranch  ^truecomment: arg1  comment := arg1repository  ^repositoryisEmptyNode  ^truenewProjectFromCommit: arg1  ^IceProjectReader readProjectFrom: selfrepositoryModel  ^repositoryModelhost  ^self hostInput texttags  ^self commit tagsmergeableLabel  ^mergeableLabelisInvalid  ^falserefresh  actionMorphPanel removeAllMorphs.  actions do: [:arg1 |  actionMorphPanel addMorphBack: (arg1 buildWithSpec                 hResizing: #rigid;                 width: self actionWidth;                 yourself) ]contextClass  ^IceTipPullRequestsListContextpullThen: arg1  IceTipStandardAction new     repository: self entity;     message: ('Pulling from {1}' format: {self remote name});     onSuccessRepositoryModified;     onSuccess: arg1;     execute: [ self entity pullFrom: self remote ]acceptError: arg1  self subclassResponsibilityformat: arg1  formatBlock := arg1cypressPackageName: arg1  ^arg1 name , '.package'packageNames  ^self subclassResponsibilitylabel: arg1  label := arg1= arg1  ^super = arg1 and: [ self rightDefinition = arg1 rightDefinition ]conflictCount  ^(self model ifNil: [ ^0 ]) unresolvedConflictCountselectedItems  ^selectedItemssource  ^self entity sourcebadge  ^badgehost  ^self hostInput texttable: arg1  super table: arg1.  self addBindingsToTableisPackageExported: arg1  | tmp1 |  tmp1 := self packageLocationFor: arg1.  ^tmp1 exists and: [ tmp1 hasChildren ]statusBar  ^statusBarchangesTo: arg1  ^arg1 changesFromCommit: selfbuildUrl  ^protocol composeUrlWithHost: host repositoryPath: patholdNode  ^oldNodeselectLeft  chosen := operationcheckoutStrategies  ^checkoutStrategiesprojectLocation  ^projectLocationadoptCommit: arg1  | tmp1 |  self referenceCommit = arg1 ifTrue: [ ^self ].  tmp1 := self referenceCommit.  self referenceCommit: arg1.  (tmp1 isNoCommit not and: [ tmp1 id = arg1 id ]) ifFalse: [ self forceCalculateDirtyPackages ]initialTree  ^initialTreemessage: arg1  message := arg1repositoryModel  ^self explicitRequirementbeBitbucket  self host: 'bitbucket.org'visitClassTraitDefinition: arg1  | tmp1 |  tmp1 := self ensureMethodOwnerNamed: arg1 className isMeta: true isTrait: true isExtension: false.  tmp1 value mcDefinition: arg1.  ^tmp1status  [ self entity repository isMissing ifTrue: [ ^self toErrorMessage: 'Local repository missing' ].  self entity isLoaded ifFalse: [ ^'Not loaded' ].  self entity isModified ifTrue: [ ^'Uncommited changes' ].  ^'Up to date' ] on: Error do: [:arg1 |  ^self toErrorMessage: arg1 description ]hasAnyNonKeptConflicts  ^self model mergeTree anySatisfy: [:arg1 |  arg1 isConflict and: [ arg1 isResolved not or: [ arg1 isRightChosen ] ] ]initializeReasonPanel  reasonPanel widget addMorphBack: (IceTipReadOnlyTextMorph new           hResizing: #spaceFill;           vResizing: #spaceFill;           contentsWrapped: self model longStatus;           yourself)newChangeTreeDataSource  ^IceTipTreeSelectingDataSource new     tool: self;     rootForItems: self model treeRoots;     childrenBlock: [:arg1 |  arg1 children ];     icon: [:arg2 |  arg2 value icon ];     format: #description;     selectAll;     yourselfbuilder  ^builder ifNil: [ builder := LGitTreeBuilder of: self repository fromTree: self initialTree ]currentBranchLabel: arg1  currentBranchLabel := arg1newContext  ^(self contextClass for: self)     readContextParametersFromModel: self model;     yourselfcurrentCommitishLabel: arg1  currentCommitishLabel := arg1issueText: arg1  issueText := arg1packagesDictionary  ^packagesdisplayString  ^'{1}: {2}' format: {self name .         self url}isCommitMerged: arg1  ^self workingCopyState isCommitMerged: arg1beGitLab  self host: 'gitlab.com'commit  self shouldBeImplementedtoFileName: arg1  ^self fileNameForMethod: arg1guessFormatFromDirectory: arg1  | tmp1 |  tmp1 := arg1 children detect: [:arg2 |  arg2 isDirectory ] ifNone: [ ^defaultFormat ].  ((formats includes: IceLibgitFiletreeWriter) and: [ IceLibgitFiletreeWriter isValidPackage: tmp1 ]) ifTrue: [ ^IceLibgitFiletreeWriter ].  ^formats detect: [:arg3 |  arg3 isValidPackage: tmp1 ] ifNone: [ ^defaultFormat ]nameLabel  ^nameLabelinitializePackagesFromRepository  | tmp1 |  tmp1 := referenceCommit isNoCommit ifTrue: [ self repository headCommit ] ifFalse: [ referenceCommit ].  self adoptCommit: tmp1ancestorIds  ^ancestorIdsrefreshDiffFromAncestorLabel  ancestorTabContainer updateLabelOn: selectedModeladdButton: arg1  addButton := arg1initializeWidgets  storeCheckbox := self newCheckBox     label: 'Do you want this credentials to be stored for future use?';     help: 'Please note that storing your credentials is handy but unsafe';     state: true.  self whenWindowChanged: [ self updateOkButton ]changesTo: arg1  | tmp1 tmp2 |  tmp2 := Set new.  tmp2 addAll: (arg1 changesFromCommit: self referenceCommit).  tmp1 := arg1 packages \ self packages.  tmp2 addAll: (self modifiedPackages , tmp1 collect: [:arg2 |  IceImageChange package: arg2 ]).  self project isDirty ifTrue: [ tmp2 add: IceProjectChange new ].  self repositoryProperties isDirty ifTrue: [ tmp2 add: IceCypressPropertiesChange new ].  ^tmp2contents: arg1  contents := arg1shortId  ^iceCommit shortIdbaseBranchNames  ^self baseBranches collect: [:arg1 |  arg1 at: #name ]selectionIsRemoteChosen  self selectedChange ifNil: [ ^false ].  ^self selectedChange isConflict and: [ self selectedChange isRightChosen ]sourceDirectory  ^properties at: 'srcDirectory' ifAbsent: [ 'src' ]nameInput: arg1  nameInput := arg1initialize  selectedDirectoryPath := RelativePath new.  formats := TIceRepositoryWriter users sorted: [:arg1 :arg2 |  arg1 description < arg2 description ].  defaultFormat := IceLibgitRepository defaultFileFormat.  super initializewithOthers: arg1  self first = arg1 ifTrue: [ self first: nil ].  self last = arg1 ifTrue: [ self last: nil ]clearSelection  chosen := nilleftPanel  ^leftPanelisValid  ^truedescription  ^', ' join: (self referenceCommits collect: #description)id  ^self entity idrepository  ^parent ifNotNil: [ self parent repository ] ifNil: [ self initialTree owner ]visitFileNode: arg1  | tmp1 |  tmp1 := repository location resolve: arg1 path.  tmp1 parent ensureCreateDirectory.  tmp1     ensureDelete;     binaryWriteStreamDo: [:arg2 |  arg2 nextPutAll: arg1 basicContents ]descriptionWithDecoration  ^self nameheaderColumn: arg1  arg1 id ifNil: [ ^nil ].  ^SimpleButtonMorph new     layoutPolicy: RowLayout new;     listDirection: #leftToRight;     wrapCentering: #center;     cellInset: 5 @ 0;     layoutInset: 5 @ 0;     label: (self columnTitleFor: arg1);     target: self;     actionSelector: #actionColumn:;     arguments: {arg1};     yourselfselectedType  ^typecommitChanges: arg1 withMessage: arg2  ^self commitChanges: arg1 withMessage: arg2 force: falsepullRequests  ^pullRequests= arg1  ^self species = arg1 species and: [ self name = arg1 name ]addItemsFromContext: arg1  | tmp1 |  tmp1 := CmdMenu activatedBy: IceTipToolbarActivation.  tmp1 buildInContext: arg1.  tmp1 buildIceToolbarOn: selfremote  | tmp1 |  tmp1 := IceGitRemote name: self author url: (((self jsonAt: #head) at: #repo) at: #ssh_url).  ^self repository remotes detect: [:arg1 |  arg1 = tmp1 ] ifFound: [:arg1 |  arg1 ] ifNone: [ self repository addRemote: tmp1.        tmp1 ]upstream  ^self upstreamIfNone: [ IceUpstreamNotConfigured signal ]createTag: arg1  ^self workingCopy referenceCommit createTag: arg1fetch  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Fetching remote {1}' format: {self name});     onSuccessRepositoryModified;     do: [ self entity fetch ]repository  ^repositoryModel entityat: arg1 put: arg2  self properties at: arg1 put: arg2validateIsBranch  globalCheckbox  ^globalCheckboxexecute  ^IceGitHubNewPullRequestAction new     repository: self repository;     remote: self remote;     executeunload  repository workingCopy unloadPackage: selfdescription  ^self repository origin url , '[' , projectVersion , ']'description  ^value descriptionuptoBranch: arg1  self uptoCommit: arg1 lastCommitnewPanelMorph  ^PanelMorph new     changeTableLayout;     hResizing: #spaceFill;     vResizing: #spaceFill;     yourselfname  ^name ifNil: [ name := self obtainRepositoryName ]mergePullRequestIntoImage  (UIManager default confirm: ('I will create a new local branch named {1}. Should I continue?' format: {self pullRequest branchName})) ifFalse: [ ^self ].  IceGitHubAPI ensureCredentials.  self pullRequest mergeIntoWorkingCopynewStatusBarItemOn: arg1  ^self contents asMorph asReadOnlyMorphdatetime  self subclassResponsibilitystoreCheckbox  ^storeCheckboxaction: arg1  action := arg1store: arg1  store := arg1isLocalRepository  ^trueprojectName  ^projectNamevisitMissingCredentialsError: arg1  ((IceTipGitUsernameAndEmailDialog on: self repository)     onAccept: [ arg1 resume ];     openDialogWithSpec) modalRelativeTo: WorldloadPackagesNamed: arg1 fromCommit: arg2  self ignoreNotificationsDuring: [ | tmp1 |        tmp1 := MCVersionLoader new.        arg1 do: [:arg3 |  | tmp2 tmp3 |              tmp2 := self packageNamed: arg3.              tmp3 := (IceSavedPackageVersion fromCommit: arg2 package: tmp2) mcVersion.              tmp1 addVersion: tmp3.              tmp2 beClean ].        tmp1 load ]refresh  credentialsList widget     dataSource: self newCredentialsDataSource;     refreshurlLabel  ^urlLabelbasicEqualsTo: arg1  ^self value = arg1 valuemarkAsCleanPackagesThat: arg1  self modifiedPackages do: [:arg2 |  (arg1 value: arg2) ifTrue: [ arg2 beClean ] ]basicExecute  self fetchAllRemotes.  (IceTipCheckoutBranchDialog on: self repositoryModel)     withoutNewBranch;     openDialogWithSpecnewCommitWalk  ^repository newCommitWalk fromBranch: selfprintString  ^String streamContents: [:arg1 |  self printOn: arg1 ]operation: arg1  operation := arg1user  ^userinitialExtent  ^(800 @ 600) scaledByDisplayScaleFactorbody: arg1  body := arg1tagNames  ^self tags collect: #namecommitInfoTabs  ^commitInfoTabsremoveTag: arg1  self subclassResponsibilitycommitModels  ^(self fromCommit newCommitWalk uptoCommit: self toCommit) commits collect: [:arg1 |  (IceTipCommitModel repositoryModel: self repositoryModel on: arg1) beCached ]color: arg1  color := arg1writeSnapshot: arg1  (TonelWriter on: self repositoryDirectory) writeSnapshot: arg1fromCommit: arg1  self fromCommitId: arg1 iditem: arg1  item := arg1realObject  ^realObjectaddToPatcher: arg1  removeFromPatcher: arg1  self isMeta ifTrue: [ ^self ].  arg1 removeDefinition: self asMCDefinitionprojectVersion: arg1  projectVersion := arg1execute  branchModel deletehandleLibgitError: arg1  < libgitErrorHandler>  arg1 on: LGitCallReturnHandler do: [:arg2 |  arg2 acceptError: (IceLibgitErrorVisitor onContext: self) ]initialExtent  ^(500 @ (self class inputTextHeight * 2 + self class buttonHeight + 50)) scaledByDisplayScaleFactornewDiff  ^self entity workingCopyDiffcommitishToTag  ^commitishToTagwriterClass  ^self properties writerClasslocation  | tmp1 tmp2 |  tmp1 := locationInput text trim ifNotEmpty: [:arg1 |  arg1 asFileReference ] ifEmpty: [ ^nil ].  (tmp1 isContainedBy: IceLibgitRepository localRepositoriesLocation) ifFalse: [ ^tmp1 ].  tmp2 := IceLibgitRepository localRepositoriesLocation makeRelative: locationInput text trim asFileReference.  ^IceLibgitRepository localRepositoriesLocation resolvePath: tmp2rightContents  ^''addLocalRepository  self repository location: self locationToUse.  self repository pluginManager repositoryWillBeCreated: self repository.  self repository workingCopy initializePackagesFromRepository.  self doEnsureProject.  self repository pluginManager repositoryWasCreated: self repository.  ^self repositoryicon: arg1  iconBlock := arg1setHead: arg1  | tmp1 |  tmp1 := IceGitCheckoutProgress new.  self handleLibgitError: [ self repositoryHandle checkout: arg1 gitRef options: (LGitCheckoutOptions defaults                 checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force;                 progressCallback: tmp1;                 yourself) ]title  ^self jsonAt: #titlerepositoryWasCreated: arg1  accept: arg1  self subclassResponsibilitytitle: arg1  title := arg1canPush  ^self head isDetached not and: [ self branch tracksRemoteBranch ]confirmLabel: arg1  confirmLabel := arg1repository: arg1  repository := arg1key  ^definition keyrefresh  commitList widget     in: [:arg1 |  arg1 dataSource elements: self model commitModels ];     refresh.  selectedModel := self model commitModels ifNotEmpty: #first ifEmpty: [ nil ].  self refreshCommitTabPanelrepository: arg1  repository := arg1= arg1  ^self species = arg1 species and: [ self referencesSameRemoteLocationAs: arg1 ]model: arg1  model := arg1install  self asMCDefinition loaddescription  ^self namecommitish: arg1  committish := arg1priority  ^100000isOkEnabled  ^super isOkEnabled and: [ self host isNotEmpty ]repository  ^self package repositoryicon: arg1  icon := arg1commitishName  ^branchNamecredential: arg1  credential := arg1item: arg1  item := arg1repositoryStrongSelection: arg1  | tmp1 tmp2 |  tmp1 := repositoryList widget dataSource elementAt: arg1 selectedIndex.  tmp2 := self newContextWithSelection: tmp1.  IceTipCommandStrongSelectionActivation activateAllInContext: tmp2 by: [:arg2 |  arg2 executeCommand ]addWidgetsTo: arg1  | tmp1 |  tmp1 := items associations last.  items associationsDo: [:arg2 |  | tmp2 tmp3 |        tmp2 := arg2 key.        tmp3 := arg2 value.        self newWidgetLabel: tmp2 value: tmp3 do: [:arg3 :arg4 |  self addRow: arg3 value: arg4 isLast: tmp1 = arg2 to: arg1 ] ]fileFormatId: arg1  self repositoryProperties fileFormatId: arg1commitWithMessage: arg1  ^self commitChanges: self repository workingCopyDiff withMessage: arg1isAlternateSSHUrl: arg1  ^self class isAlternateSSHUrl: arg1items: arg1  items := arg1 asOrderedCollection.  self refreshrefreshDetailPanel  detailPanel widget removeAllMorphs.  selectedOption ifNotNil: [ detailPanel widget addMorphBack: (IceTipReadOnlyTextMorph new                 hResizing: #spaceFill;                 vResizing: #spaceFill;                 contentsWrapped: selectedOption help;                 yourself) ]initialExtent  ^(350 @ (self class inputTextHeight * 4 + self class buttonHeight)) scaledByDisplayScaleFactorchildren: arg1  children := arg1.  children do: [:arg2 |  arg2 parent: self ]acceptError: arg1  arg1 visitNoCommitMessage: selfinitializeWidgets  urlLabel := self newLabel label: 'Url'.  authorLabel := self newLabel label: 'Author'.  fromLabel := self newLabel label: 'From'.  toLabel := self newLabel label: 'Into'.  mergeableLabel := self newLabel label: 'Mergeable'.  statusLabel := self newLabel label: 'Status'.  urlText := self newTextInput enabled: false.  authorText := self newTextInput enabled: false.  fromText := self newTextInput enabled: false.  toText := self newTextInput enabled: false.  mergeablePanel := self newMergeablePanel.  statusPanel := self newStatusPanel.  checksTable := self newChecksTable.  bodyText := self newText enabled: falseremoteNamed: arg1 ifAbsent: arg2  self subclassResponsibilitypackage  ^packagemergeWithMasterCheckbox  ^mergeWithMasterCheckboxproviderName  ^self class providerNameremote: arg1  remote := arg1isOkEnabled  ^self username isNotEmpty and: [ self publicKey isNotEmpty and: [ self privateKey isNotEmpty ] ]url  ^self jsonAt: #urlcontents: arg1  contents := arg1execute  (IceGitHubOpenOnGithubAction organisation: self remote owner projectName: self remote projectName) executeshouldInclude: arg1  ^self modifyingPackage ifNil: [ true ] ifNotNil: [:arg2 |  arg1 changesFileNamed: arg2 directoryPathString ]selectCurrentBranch  | tmp1 tmp2 |  tmp2 := self model headModel.  tmp1 := sidebarTree widget dataSource indexOfElementMatching: [:arg1 |  arg1 isLeaf and: [ arg1 model name = tmp2 name ] ].  sidebarTree widget selectIndex: tmp1initialExtent  ^(350 @ (self class inputTextHeight * 6 + self class buttonHeight)) scaledByDisplayScaleFactorfileSystem  ^FileSystem memory rootfileReference  ^fileReferenceremoveClass: arg1  repository workingCopy removeClassNamed: arg1 namevalidateCanCommit  self repository validateCanCommit.  self workingCopyState validateCanCommithash  ^((self species hash bitXor: self major) bitXor: self minor) bitXor: self patchcommitLabel: arg1  commitLabel := arg1doesNotUnderstand: arg1  ^arg1 sendTo: (self findVersionInfo ifNotNil: [:arg2 |  self becomeForward: arg2 copyHash: false ] ifNil: [ self stubVersionInfo ])newRepository  UIManager default informUser: ('Cloning repository {1}' format: {self remoteUrl}) during: [ ^IceRepositoryCreator new           repository: repository;           remote: (IceGitRemote url: self remoteUrl);           location: self projectLocation location;           createRepository ]newContextWithSelection: arg1  ^self newContext     item: arg1;     yourselfancestors  ^ancestorIds collect: [:arg1 |  repository lookupCommit: arg1 ]adopt  self entity adoptisMissing  ^self repositoryDirectory isNil or: [ self repositoryDirectory exists not ]gitRepositoryInfo  ^gitRepositoryInfo ifNil: [ gitRepositoryInfo := self requestGitRepositoryInfo ]isMeta: arg1  isMeta := arg1fromCommitId: arg1  self fromLGitId: (LGitId fromHexString: arg1)password  ^passwordInput textvisitCloneLocationAlreadyExists: arg1  UIManager default alert: ('The clone location {1} already exists' format: {arg1 location}) title: 'Clone action failed'hasMultipleAncestors  | tmp1 |  tmp1 := self ancestorIds.  ^tmp1 notNil and: [ tmp1 size > 1 ]accept  self window delete.  selectedOption executeWith: self modelbaseBranchList: arg1  baseBranchList := arg1remoteModel  ^repositoryModel remoteModels detect: [:arg1 |  arg1 entity = self remote ]outgoingCommitsTo: arg1  | tmp1 tmp2 |  tmp1 := arg1 remoteBranchNamed: self name ifAbsent: [ ^self reducedOutgoingCommitsWhenNoRemote ].  tmp2 := self newCommitWalk.  tmp1 ifNotNil: [ tmp2 uptoCommit: tmp1 commit ].  ^tmp2 commitsitemNameWithoutBranches  ^'View Pull Request...'contents  ^self response contentsrepository: arg1  repository := arg1execute  (IceTipCommitBrowser on: self repositoryModel) openWithSpecbasicCodeDirectory  ^self subdirectory isEmptyOrNil ifTrue: [ self repositoryDirectory ] ifFalse: [ self repositoryDirectory / self subdirectory ]name: arg1  name := arg1merge  ^mergevisitAddition: arg1  repository workingCopy applyDefinition: arg1 definition inNode: currentNodeselectRight  chosen := operation inversechangesFromCommit: arg1  | tmp1 |  tmp1 := self repository changedFilesBetween: arg1 and: self.  ^tmp1 collect: [:arg2 |  IceGitChange on: arg2 ]remoteNamed: arg1  ^self remoteNamed: arg1 ifAbsent: [ IceRemoteNotFoundError new           remoteName: arg1;           signal ]shortCommitId  ^[ self entity headCommit shortId ] on: Error do: [ nil ]initialExtent  ^(500 @ 300) scaledByDisplayScaleFactorlocationLabel: arg1  locationLabel := arg1readParametersFromContext: arg1  super readParametersFromContext: arg1.  item := arg1 itemaccept: arg1  ^arg1 visitExtensionDefinition: selfremoteLabel: arg1  remoteLabel := arg1configureButton: arg1 item: arg2  arg1 on: arg2 getState: nil action: #execute label: #label icon: #icon menu: nil.  arg1 badgeSelector: #badgecontents  ^''refresh  leftPanel removeAllMorphs.  rightPanel removeAllMorphs.  items do: [:arg1 |  arg1 position addItem: (arg1 newStatusBarItemOn: self) into: self ]remoteBranchNamed: arg1 ifPresent: arg2 ifAbsent: arg3  ^arg3 valuemodel  ^modelmergeCommit: arg1  ^self workingCopyState mergeCommit: arg1toWarningMessage: arg1  ^arg1 asText allBold makeAllColor: self colorWarninginspect  ^Smalltalk tools inspector inspect: selfproject  ^self workingCopy projectoutgoingCommits  self hasUpstream ifFalse: [ ^#() ].  ^self outgoingCommitsTo: self upstream remoteexecute  tagModel deletewriteClassDefinition: arg1 to: arg2  self writeInDirectoryName: arg2 fileName: 'README' extension: '.md' visit: [ self writeClassComment: arg1 ].  self writeInDirectoryName: arg2 fileName: 'properties' extension: self propertyFileExtension visit: [ self writeClassDefinition: arg1 ]refreshDiffFromAncestor  ancestorTabContainer updateContentsOn: selectedModelcomment  ^''visitWorkingCopyDesynchronizedError: arg1  self visitGenericError: arg1host  ^'local filesystem'loadPackageNamed: arg1  self loadPackagesNamed: {arg1}name: arg1  name := arg1mergeWithLeftNoOperation: arg1  ^self subclassResponsibilityadopt  self repository workingCopy adoptCommit: selfoperationIcon  ^self iconNamed: #changeUpdateinitializeWidgets  nameLabel := self newLabel label: 'Remote name'.  nameText := self newTextInput     ghostText: 'e.g., user-remote';     autoAccept: true.  urlLabel := self newLabel label: 'Remote URL'.  urlText := self newTextInput     ghostText: 'e.g., git@github.com:user/project.git';     autoAccept: true.  self focusOrder     add: nameText;     add: urlTextexecute  item ifNil: [ ^self ].  IceTipStandardAction new     repository: item entity;     message: 'Recalculating Dirty Packages';     onSuccessRepositoryModified;     execute: [ item entity workingCopy forceCalculateDirtyPackages ]checkout: arg1  | tmp1 |  self repository branchNamed: self shortName ifPresent: [:arg2 |  IceError signal: ('Branch {1} already exists' format: {self shortName}) ].  tmp1 := self repository createBranch: self shortName inCommit: self commit.  arg1 committish: tmp1.  ^tmp1 checkout: arg1remoteUrl  ^remoteUrlrebuildToolbar  toolbar items: #().  toolbar addItemsFromContext: self newContexttargetName  ^commitish namesetModelBeforeInitialization: arg1  self commitish: arg1entity  ^entitysourceDirectoryLabel: arg1  sourceDirectoryLabel := arg1mergeableLabel: arg1  mergeableLabel := arg1spacePanel: arg1  spacePanel := arg1message  ^self commentText text asStringcommit  ^commitsnapshotForPackage: arg1  ^arg1 isLoaded ifTrue: [ (MCPackage named: arg1 name) basicSnapshot ] ifFalse: [ self referenceCommit snapshotForPackage: arg1 ]initializeWidgets  super initializeWidgets.  remotePanel := self instantiate: IceTipSelectRemotePresenter on: self model.  remotePanel remoteList whenSelectedItemChanged: [:arg1 |  self moveToRemote: arg1 ].  self focusOrder     add: self commitsPanel;     add: self actionPanel;     add: self remotePanelchildAt: arg1 ifPresent: arg2  ^childrenDictionary at: arg1 ifPresent: arg2execute  (IceTipCheckoutPreviewBrowser onBranch: selectedCommit) openWithSpecprojectVersion  ^(location substrings: '/') third copyAfter: $:withErrorHandlingDo: arg1  arg1 on: IceError do: [:arg2 |  arg2 acceptError: (IceTipInteractiveErrorVisitor on: self repositoryModel entity) ]bePositionRight  self position: IceTipItemPosition rightid  self subclassResponsibilitysourceDirectoryPath  ^RelativePath withAll: (RelativePath canonicalizeElements: ($/ split: self sourceDirectory))mcSnapshot  ^self mcVersion snapshotformat: arg1  format := arg1origin  self subclassResponsibilitytextWidget  ^textWidgetrefreshPullRequests  | tmp1 |  tmp1 := self pullRequests widget.  tmp1 dataSource elements: self fetchPullRequests.  (tmp1 hasSelection not and: [ tmp1 dataSource hasElements ]) ifTrue: [ tmp1 selectRowIndex: 1 ]branch  fetched ifFalse: [ self fetch ].  ^branch ifNil: [ branch := (self repository remoteNamed: self remote name) remoteBranchNamed: ((self jsonAt: #head) at: #ref) ]initialExtent  ^(400 @ (self class inputTextHeight * 3 + self class buttonHeight + 50)) scaledByDisplayScaleFactorisResumable  ^resumableprojectBasename  ^self projectName withoutSuffix: '.git'newBranchListDataSource  ^IceTipDataSource new     tool: self;     elements: self branchModels;     yourselfrightDefinition  ^oldNodeisBranch  ^trueinitialize  super initialize.  self subscribeToAnnouncementsremoteName  ^remoteNameexecute  (IceTipCheckoutNewBranchPanel on: self repositoryModel)     commitish: selectedCommit entity;     withResultDo: [:arg1 |  arg1 checkout ];     openDialogWithSpecisModelOf: arg1  ^self entity = arg1branchesFrom: arg1  ^arg1 branches select: [:arg2 |  arg2 isRemote and: [ arg2 remoteName = self name ] ]isExtensionDefinition  ^falseinitializeWidgets  packagesList := self newIceTreeTable.  packageNameText := self newTextInput     autoAccept: true;     ghostText: 'e.g., Collections'.  self initializePackagesList.  self initializePackageNameText.  self focusOrder     add: self packagesList;     add: self packageNameTextcellColumn: arg1 row: arg2  arg1 id = #target_url ifTrue: [ ^self targetUrlCellColumn: arg1 rowIndex: arg2 ].  arg1 id = #state ifTrue: [ ^self statusCellColumn: arg1 rowIndex: arg2 ].  arg1 id = #context ifTrue: [ ^self contextCellColumn: arg1 rowIndex: arg2 ].  ^super cellColumn: arg1 row: arg2createTag: arg1 thenDo: arg2  < noCache>  IceTipStandardAction new     repository: self entity;     message: ('Creating tag {1} on commit {2}' format: {arg1 .               self commit shortId});     onSuccessRepositoryModified;     execute: [ | tmp1 |        tmp1 := self commit createTag: arg1.        arg2 value: tmp1 ]readerClass  ^TIceRepositoryReader users detect: [:arg1 |  arg1 id = self fileFormat id ]datetime  ^datetimebodyPanel  ^bodyPanelcommits: arg1  commits := arg1selectedBranch  ^selectedBranchinitializeToolbar  isModified  ^self isDirtysnapshotWriterClass  ^IceLibgitFiletreeSnapshotWriterlatestTagPartsIn: arg1  | tmp1 tmp2 |  tmp2 := #('v' 0 0 0).  tmp1 := 'v'.  (arg1 select: [:arg2 |  'v?[0-9]' asRegex matchesPrefix: arg2 ]) ifNotEmpty: [:arg3 |  | tmp3 |        tmp3 := arg3 sorted last.        tmp2 := ((tmp3 beginsWith: tmp1) ifTrue: [ #('v') ] ifFalse: [ #('') ]) , ((((tmp3 withoutPrefix: tmp1) copyUpTo: $-) splitOn: '.') collect: [:arg2 |  NumberParser parse: arg2 onError: [ 0 ] ]).        tmp2 := tmp2 , (#(0 0 0) first: 4 - tmp2 size) ].  ^tmp2icon  ^self iconNamed: #class= arg1  self species = arg1 species ifFalse: [ ^false ].  self repository = arg1 repository ifFalse: [ ^false ].  self properties = arg1 properties ifFalse: [ ^false ].  ^truepreferredColor  ^self isResolved ifTrue: [ Color gray ] ifFalse: [ Color red ]doCheckout  self model executeCheckoutActionAndThen: [ self window delete ]isNewRepository  ^truesortingStrategy  ^sortingStrategy ifNil: [ sortingStrategy := IceSortingStrategy new first: #modified ]filter  pattern ifNil: [ ^self ].  table dataSource: (pattern ifNotEmpty: [ initialDataSource newDataSourceMatching: (filterClass pattern: pattern) ] ifEmpty: [ initialDataSource ]).  table selectRowIndexes: #().  table dataSource expandAll.  self isExplicite ifTrue: [ self resizeWidget ]ensureBranch: arg1  (self hasLocalBranchNamed: arg1) ifFalse: [ self createBranch: arg1 ]tagNamed: arg1  (self hasTagNamed: arg1) ifFalse: [ IceTagNotFound new           tagName: arg1;           signal ].  ^IceTag named: arg1 inRepository: selfbaseLabel: arg1  baseLabel := arg1repositoryList: arg1  repositoryList := arg1mergeOn: arg1 then: arg2  self subclassResponsibilitycredentials  ^self subclassResponsibilitytree  ^treeisEmpty  ^self diff isEmptysanitizeTitle: arg1  | tmp1 tmp2 |  arg1 isEmptyOrNil ifTrue: [ ^self class unknownTitle ].  tmp2 := $-.  tmp1 := {Character space .   Character tab .   $_ .   tmp2}.  ^String streamContents: [:arg2 |  arg1 do: [:arg3 |  (tmp1 includes: arg3) ifTrue: [ arg2 nextPut: tmp2 ].              arg3 isAlphaNumeric ifTrue: [ arg2 nextPut: arg3 ] ] ]fullWorkingCopyDiff  ^IceDiff new     source: self workingCopy;     target: self head;     buildFull;     yourselfname  ^nameaddFileToIndex: arg1  self addFilesToIndex: {arg1}descriptionWithDecoration  ^self model descriptionWithDecorationpull  self pullFrom: repository origincontextClass  ^IceTipRepositoryContextdoAccept  self validate.  IceTipStandardAction new     repository: self model entity;     message: ('Verifying merge from {1}' format: {self selectedBranch name});     onSuccess: [ self selectedBranch previewMerge: self mergeType ];     execute: [ self validate ]sourceCode  ^sourceCodeaccept: arg1  ^arg1 visitClassDefinition: selfselectRight  self subclassResponsibilityasMCDefinition  ^MCOrganizationDefinition categories: categoriessetModelBeforeInitialization: arg1  model := arg1changesFromCommit: arg1  ^self subclassResponsibilityinitialize  super initialize.  fetched := falsetypeList  ^typeListfinishSuccess  super finishSuccess.  Iceberg announcer announce: (IceRepositoryModified for: self repository)isSingleCommitState  ^falseisDetached  ^self referenceCommit ~= repository head commitmergeWith: arg1  self subclassResponsibilitybasicExecute  (IceTipCheckoutPreviewBrowser onBranch: self repositoryModel branchModel) openWithSpecchangesFromNoCommit: arg1  ^self packages collect: [:arg2 |  IceImageChange package: arg2 ]printPathOn: arg1  parent ifNil: [ arg1 nextPutAll: initialTree repository workingDirectoryName ] ifNotNil: [ parent printPathOn: arg1.        arg1           nextPut: $/;           nextPutAll: entryName ]name  ^namedoAccept  self selectedType doAcceptsubscribeToAnnouncements  self announcer when: IceTipDiffRefreshed send: #refreshWhenRepository: to: self.  Iceberg announcer weak when: IceRepositoryAnnouncement send: #refreshWhenRepository: to: selfwriteVersion: arg1  directory := arg1 package name , '.package'.  packageFileDirectory := stream / directory.  self packageFileDirectory ensureDeleteAll.  self writeFormat.  self writePackage: arg1 package.  self writeDefinitions: arg1.  arg1 dependencies do: [:arg2 |  self writeVersionDependency: arg2 ]remote: arg1  ^remote := arg1branchName  ^self branch nameancestors  ^self subclassResponsibilityisPackageDefinition  ^falseversionName  ^'{1}-{2}.{3}' format: {self packageNameFromPackageDirectory .         self commit compatibleUsername .         self versionNumber}protocolLabel  ^protocolLabelremoteTrackedBranches  self handleLibgitError: [ ^OrderedCollection new: 10 streamContents: [:arg1 |  self repositoryHandle remoteBranchesDo: [:arg2 :arg3 |  self assert: arg3 not.                    arg1 nextPut: (self basicNewRemoteBranchNamed: arg2 name) ] ] ]initialize  selectedItems := Set new.  super initialize.  self title: self class titlevisitModification: arg1  arg1 leftDefinition addModification: arg1 toPatcher: patcher.  self visitChildrenOf: currentNodeaccept  self validate.  self model addRemoteNamed: self remoteName url: self remoteUrl.  ^acceptBlock ifNotNil: [ acceptBlock cull: self remoteName ]executeMergeActionAndThen: arg1  < noCache>  IceTipStandardAction new     repository: self repository;     message: ('Merging {1} into {2}' format: {self targetName .               self repositoryName});     onSuccessRepositoryModified;     onSuccess: arg1;     execute: [ self merge ]model: arg1  model := arg1.  self allTypes do: [:arg2 |  arg2 model: arg1 ]fromCommit  ^self entitybasicExecute  (IceTipEditProjectDialog on: (IceBasicProject onRepository: self repositoryModel entity)) openDialogWithSpecremoteToUse  self remote ifNotNil: [ ^self remote ].  self url ifNotNil: [ ^IceGitRemote url: self url ].  ^nilfileSystem  ^self commit fileSystemtitle  ^'Repositories'isSelected: arg1  ^selectedItems includes: arg1isMerged  ^self entity isMergedtypeList: arg1  typeList := arg1= arg1  (arg1 isKindOf: self species) ifFalse: [ ^false ].  ^self id = arg1 idexecute  branchModel deleteexecute  (IceTipRepairRepositoryDialog on: self repositoryModel) openDialogWithSpecstoreIfDefault  self isDefault ifFalse: [ ^self ].  IceCredentialStore current storeCredential: selfmodel: arg1  model := arg1initializeWithTree: arg1  initialTree := arg1tagName  ^tagNameselectButton: arg1  selectButton := arg1issueText  ^issueTextmessageText  ^self jsonContents at: #messageisAncestorOfCommitId: arg1  ^self commit isAncestorOf: (self repository lookupCommit: arg1)extent  ^45 @ 40libgitCommit  repository handleLibgitError: [ ^LGitCommit of: self repositoryHandle fromHexString: self id ]packageNode: arg1  packageNode := arg1versionsFor: arg1 detect: arg2 ifNone: arg3  self modifyingPackage: arg1.  self commitsDo: [:arg4 |  | tmp1 |        tmp1 := arg4 versionFor: arg1.        (arg2 value: tmp1) ifTrue: [ ^tmp1 ] ].  ^arg3 valueremote  ^repository remoteNamed: self remoteNameheadRemote  ^headRemote ifNil: [ self repository head upstream remote ]lookupHead  self handleLibgitError: [ | tmp1 |        self repositoryHandle isUnborn ifTrue: [ ^IceGitUnbornBranch inRepository: self ].        tmp1 := self repositoryHandle head.        ^tmp1 isBranch ifTrue: [ self basicNewBranchNamed: tmp1 name ] ifFalse: [ tmp1 object asIcebergObjectInRepository: self ] ]branches  ^self entity localBrancheschooseTitle  ^chooseTitle ifNil: [ self class defaultChooseDialogTitle ]goferPriority  ^8badge  ^badgenewEmptyTab  ^self newTab     label: 'Info';     icon: (self iconNamed: #smallQuestion);     closeable: false;     contents: '(No commit selected)' asMorph;     yourselfsuspendAllForRepository: arg1 while: arg2  ^self suspendAllMatching: [:arg3 |  arg3 appliesToRepository: arg1 ] while: arg2canBrowseReferences  ^falsemergeWithLeftNoOperation: arg1  ^IceConflictingOperation left: arg1 right: selfstripPossibleExtension: arg1  ^(arg1 endsWith: '.git') ifTrue: [ arg1 allButLast: 4 ] ifFalse: [ arg1 ]readParametersFromContext: arg1  super readParametersFromContext: arg1.  commitModel := arg1 itemiconPanel  ^iconPanelaccept  acceptBlock ifNotNil: [ acceptBlock cull: self ].  self window deleteupdatePullRequest: arg1 project: arg2 number: arg3 data: arg4  ^self patch: 'repos/' , arg1 , '/' , arg2 , '/pulls/' , arg3 asString with: [:arg5 |  arg5           entity: (ZnEntity text: (STON toJsonString: arg4));           contentType: ZnMimeType applicationJson ]body  ^bodyversionFor: arg1  ^IceSavedPackageVersion fromCommit: self package: arg1name  ^nameitemNameWithoutBranches  ^'Remove Branches...'basicExecute  [ | tmp1 |  tmp1 := (self github getRepository: self organisation project: self projectName) at: 'html_url'.  self class environment at: #WebBrowser ifPresent: [:arg1 |  arg1 openOn: tmp1 ] ifAbsent: [ self inform: ('Cannot open "{1}" because the project WebBrowser is not present by default in Pharo 6.' format: {tmp1}) ] ] on: IceGitHubError do: [ self inform: ('Invalid Github repository. No project named "{1}" found for the owner "{2}"' format: {self projectName .                     self organisation}) ]description  self tags ifNotEmpty: [:arg1 |  ^', ' join: (arg1 collect: [:arg2 |  arg2 name ]) ].  ^'Detached at {1}' format: {self shortId}remoteUrl  ^self remoteInputText text asString trimmed