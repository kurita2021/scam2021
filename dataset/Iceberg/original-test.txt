format  ^format-======-load  self repository workingCopy loadPackageNamed: self name-======-obtainAvailableRemotes  | remotes |  remotes := self repository remotes.  (remotes includes: self baseRemote) ifFalse: [ remotes := remotes copyWith: self baseRemote ].  ^remotes-======-mergeBaseBetween: aCommitId and: anotherCommitId  self handleLibgitError: [ ^(self repositoryHandle mergeBaseBetween: (LGitId fromHexString: aCommitId) and: (LGitId fromHexString: anotherCommitId)) hexString ]-======-timeStamp  ^self datetime-======-baseLabel  ^'No PR selected'-======-projectName  ^projectName-======-isFastForward  ^self headCommit isAncestorOf: mergeCommit-======-basicExecute  self fetchAllRemotes.  (IceTipPullBrowser onRepositoryModel: self repositoryModel) openWithSpec-======-sortingStrategyFirst: aSymbol  self sortingStrategy first: aSymbol-======-initializeChangeList  | dataSource |  dataSource := self newChangeTreeDataSource.  changeList widget dataSource: dataSource.  dataSource expandAll-======-changesFromCommit: anIceNoCommit  ^anIceNoCommit changesFromNoCommit: self-======-remoteFileReferenceInPath: anUndefinedObject  -======-issueLabel: anObject  issueLabel := anObject-======-initializeWidgets  self initializeProjectLocation.  self initializeSpacePanel-======-workingCopy  ^repository workingCopy-======-createCommandContextForSelection: selectedItems  ^self newContextWithSelection: selectedItems-======-fetchFrom: aRemote  aRemote fetch-======-position: anObject  position := anObject-======-allBranchModels  ^self entity allBranches collect: [:each |  (IceTipBranchModel repositoryModel: self on: each) beCached ]-======-tags  ^self commit tags-======-datetime  ^datetime-======-repositoryName  ^self repositoryModel name-======-customError: aDictionary  ^aDictionary at: #message-======-removeFrom: aStore  aStore removeSSHCredential: self-======-packageModels  ^self sortingStrategy sort: (self repositoryModel entity workingCopy packages collect: [:each |  (IceTipPackageModel repositoryModel: self repositoryModel on: each) beCached ])-======-remote: anObject  remote := anObject-======-privateKey: anObject  privateKey := anObject.  self storeIfDefault-======-fileNameForMethod: aMethod  | path |  path := OrderedCollection new.  self repository subdirectory ifNotEmpty: [:subDir |  path add: subDir ].  path add: (self tonelPackageName: aMethod package).  path add: (self tonelMethodClassOrTraitName: aMethod).  ^String streamContents: [:stream |  path asStringOn: stream delimiter: '/' ]-======-longStatus  (entity isMissing and: [ entity location isNil ]) ifTrue: [ ^'Iceberg does not find a git repository. Please clone the repository or change the repository location to an existing Git repository' ].  entity isMissing ifTrue: [ ^'Iceberg does not find a git repository at {1}. Please clone the repository again or change the repository location to an existing Git repository' format: {entity location} ].  entity workingCopy workingCopyState isUnknownCommitState ifTrue: [ ^'This image has a loaded version of the code from commit {1}, but Iceberg does not find the commit in your local Git repository. You may fetch the correct commit from a remote repository or discard the code of your image and load the version that is in the repository.' format: {entity workingCopy referenceCommit shortId} ].  entity workingCopy isDetached ifTrue: [ ^'The loaded code in the image starts from commit {1}. This commit does not correspond with the commit in the head of the current branch of the repository (Commit {2}). You need to synchronize them to continue. You need to discard your image changes or change the HEAD of the repository to point to the commit.' format: {entity workingCopy referenceCommit shortId .               entity headCommit shortId} ].  entity head isDetached ifTrue: [ ^'The repository and the image are in the same commit {1}. However, the commit is not in an active branch. It is not possible to commit in a Git detached HEAD state. Create a new branch (by checkouting) or checkout an existing one.' format: {entity headCommit shortId} ].  entity workingCopy project isUnborn ifTrue: [ ^'Cannot find a project (meta-data and source directory) in your repository. Please edit your repository meta-data to indicate the source code directory or change the location to a valid iceberg repository' ].  ^'Your repository seems ok. Please report a ticket in Iceberg''s issue tracker. If you can, please send us a backup of your image in this state for debugging.'-======-keysDo: aBlockClosure  childrenDictionary keysDo: aBlockClosure-======-issueLabel  ^issueLabel-======-execute  self packageModel remove-======-headCommit  ^self head commit-======-push  -======-snapshotFor: package  ^(self versionFor: package) snapshot-======-asBornProperties  ^IceRepositoryProperties fromDictionary: properties commitish: commitish-======-selectedChange  ^(self selectedChangeWrapper ifNil: [ ^nil ]) item value-======-request: anObject  request := anObject-======-diffToReferenceCommit  ^self diffTo: self referenceCommit-======-url  ^url-======-selectRemoteNamed: aString  remoteList setSelectedItem: (self model remoteModels detect: [:each |  each name = aString ])-======-table: aTable  super table: aTable.  self addBindingsToTable-======-selectNextConflict  | next |  next := self nextConflict ifNil: [ ^self ].  self changed: {#openPath} , next item path segments-======-item  ^self packageModel-======-descriptionWithDecoration  ^self name asText-======-isLocal  ^self entity isLocal-======-cellColumn: column row: rowIndex  ^self newCellFor: (self elementAt: rowIndex)-======-refreshWhenRepository: ann  (ann repository isNil or: [ self model repositoryModel isModelOf: ann repository ]) ifFalse: [ ^self ].  self model reset.  self refresh-======-visitPackage: anIcePackageDefinition  | mcPackage snapshot patcher version |  mcPackage := MCPackage named: anIcePackageDefinition name.  snapshot := [ diff targetVersion snapshotFor: anIcePackageDefinition ] on: NotFound do: [ MCSnapshot empty ].  patcher := MCPatcher snapshot: snapshot.  currentNode accept: (IceMCSnapshotPatchVisitor new           patcher: patcher;           yourself).  version := MCVersion new setPackage: mcPackage info: (IceMCVersionInfo package: mcPackage message: 'Internal...') snapshot: patcher patchedSnapshot dependencies: #().  index storeVersion: version-======-child  ^IceGitChange on: (RelativePath withAll: self path segments allButFirst) pathString-======-defaultMenuItemName  ^'Open on github'-======-versionsFor: package  ^self commit versionsFor: package-======-newContextWithSelection: anObject  ^self newContext     item: anObject;     yourself-======-refreshDirtyPackages  self markAsCleanPackagesNotInDiff: self repository workingCopyDiff-======-remotes  self handleLibgitError: [ | gitRemotes |        self isValid ifFalse: [ ^#() ].        gitRemotes := self repositoryHandle allRemotes.        ^gitRemotes collect: [:each |  (IceGitRemote name: each remoteName url: each url)                 localRepository: self;                 yourself ] ]-======-commit  ^self-======-isClassDefinition  ^false-======-execute  self subclassResponsibility-======-repositoryList  ^repositoryList-======-mergeWithBranch: aBranch  self subclassResponsibility-======-entryName  ^entryName-======-response  ^response-======-actualClass  ^self contextClass-======-value  ^list includes: item-======-typeList: anObject  typeList := anObject-======-repository  ^commitish repository-======-packages  tree isEmpty ifTrue: [ ^#() ].  ^self codeSubdirectoryNode children-======-select: aBlockClosure  ^self-======-basicNewRemoteBranchNamed: aString  ^IceGitRemoteBranch named: aString inRepository: self-======-gitRef  ^((repository location / '.git' / 'HEAD') contents withoutPrefix: 'ref: ') trimBoth-======-initializeWidgets  super initializeWidgets.  repositoryList := self newIceTable.  repositoryList widget onAnnouncement: FTStrongSelectionChanged send: #repositoryStrongSelection: to: self.  self initializeRepositoryList.  self focusOrder add: repositoryList-======-push  self branch push-======-optionsList  ^optionsList-======-nameLabel: anObject  nameLabel := anObject-======-id: anObject  id := anObject-======-invalidError: aDictionary  ^'Invalid field: ' , (aDictionary at: #field)-======-children  ^#()-======-classIsMeta: anObject  classIsMeta := anObject-======-changesFromCommit: anIceNoCommit  self assert: anIceNoCommit isNoCommit.  ^#()-======-sourceDirectory  ^self repository project sourceDirectory-======-packageNameFromPackageDirectory  ^iceVersion packageName-======-toText: anObject  toText := anObject-======-tags  self subclassResponsibility-======-contextClass  ^IceTipBranchContext-======-fetchPullRequests  ^(IceGitHubAPI new getPullRequests: self remote owner project: self remote projectName) all collect: [:each |  (IceGitHubPullRequest fromJSON: each)           repository: self repository entity;           yourself ]-======-messageText  ^'There is no version for package: {1} in  commit {2}' format: {self version packageName .         self version commit id}-======-shortName  ^self name copyAfter: $/-======-remoteUrl: anObject  remoteUrl := anObject-======-visitNonConflictingOperation: anIceNonConflictingOperation  anIceNonConflictingOperation chosenOperation accept: self-======-withoutNewBranch  types := self allTypes reject: #isNewBranch.  typeList widget dataSource elements: types.  typeList widget refresh-======-hasSingleCommit  ^self workingCopyState isSingleCommitState-======-repositoryProperties  ^properties-======-repository  ^repository-======-initialize  super initialize.  childrenDictionary := Dictionary new-======-mergeThen: aBlock  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Merging branch {1} from {2}' format: {self name .               self repositoryName});     onSuccessRepositoryModified;     onSuccess: aBlock;     execute: [ self entity merge ]-======-includesPackageNamed: aName  ^false-======-acceptError: anObject  anObject visitShouldCommitBeforePullError: self-======-reset  UIManager default informUser: 'Refreshing changes' during: [ self resetDiff.        self diff ]-======-initializeExistingTagsList  existingTagsList := self newList.  existingTagsList     items: commitishToTag tagModels;     displayBlock: #name;     sortingBlock: #name descending-======-canBrowseReferences  ^self canBeBrowsed-======-help  ^self commandClass defaultHelp-======-printOn: aStream  aStream     nextPutAll: self class name;     nextPutAll: '(';     nextPutAll: self name;     nextPutAll: ')'-======-package  ^package-======-model: anObject  model := anObject.  self allTypes do: [:each |  each model: anObject ]-======-mergeIntoWorkingCopy  self repository     ensureBranch: self branchName;     checkoutBranch: self branchName.  self branch merge-======-visitAuthenticationError: anError  UIManager default alert: anError messageText title: 'Iceberg authentication Error'-======-initializeWidgets  iconPanel := self newIcePanel.  iconPanel widget addMorph: ((self iconNamed: #error) scaledToSize: 32 @ 32) asMorph.  errorLabel := self newIceReadOnlyText.  errorLabel widget contentsWrapped: exception messageText.  errorLabel widget     hResizing: #spaceFill;     vResizing: #spaceFill-======-createCheckboxFor: anObject  ^CheckboxMorph on: (IceGitHubSelectItem list: selectedItems item: anObject) selected: #value changeSelected: #value:-======-subscribeToAnnouncements  Iceberg announcer weak when: IceRepositoryAnnouncement send: #refreshWhenRepository: to: self-======-ensureDefaultProperties  properties at: #format ifAbsentPut: [ self writerClass id ]-======-labelFor: aCommitModel  ^'HEAD to {1}' format: {(aCommitModel ifNotNil: #shortId)}-======-changeList: anObject  changeList := anObject-======-checkoutWithStrategy: aCheckoutStrategy  repository checkout: (aCheckoutStrategy commitish: self)-======-hash  ^self commit hash-======-contentsWithValidationDo: aBlock  ^(self responseWithValidationDo: aBlock) contents-======-icon  ^self iconNamed: #changeRemove-======-nextNodeSuchThat: conditionBlock ifNone: noneBlock  self children do: [:each |  (conditionBlock value: each) ifTrue: [ ^each ].        each nextNodeSuchThat: conditionBlock ifFound: [:found |  ^found ] ].  ^self parent nextChildNodeStartingFrom: self suchThat: conditionBlock ifNone: noneBlock-======-selectRemoteModel  ^selectRemoteModel ifNil: [ selectRemoteModel := IceTipRemoteActionModel repositoryModel: self model on: self model entity ]-======-contents  ^self basicAt: 1-======-basicExecute  IceTipRegisterRepositoryDialog new     beForCloneOfRepository: self repositoryModel entity;     onAccept: [ Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity) ];     openDialogWithSpec-======-onSuccessAnnounce: aValuable  successAnnounceBlock := aValuable-======-repository  ^repository-======-fileUtils  ^IceLibgitFiletreeFileUtils-======-comment  ^self entity comment-======-mergeWithLeftRemoval: anIceRemoval  ^IceConflictingOperation left: anIceRemoval right: self-======-keys  ^childrenDictionary keys-======-definition  ^operation definition-======-onAccept: aBlock  acceptBlock := aBlock-======-sourceCode: aString  sourceCode := aString-======-hasAnyNonConflictConflicts  ^self model mergeTree anySatisfy: [:conflict |  conflict isConflict and: [ conflict isResolved ] ]-======-model  ^model-======-delete  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Removing remote {1}' format: {self name});     onSuccessRepositoryModified;     do: [ self repositoryModel entity removeRemote: self entity ]-======-credentials: aPlainTextCredential  credential := aPlainTextCredential.  self usernameInput text: credential username.  self passwordInput text: credential password-======-writerClass  ^self commit writerClass-======-badgeSelector: aSymbol  badgeSelector := aSymbol-======-free  (handle isNil or: [ handle isNull ]) ifFalse: [ handle free.        handle := nil ]-======-referencesSameRemoteLocationAs: aRemote  ^(super referencesSameRemoteLocationAs: aRemote) or: [ (self url withoutSuffix: '.git') sameAs: (aRemote httpsUrl withoutSuffix: '.git') ]-======-readProjectFromCommitish: aCommitish  self subclassResponsibility-======-cellColumn: column row: rowIndex  | item |  item := self elementAt: rowIndex.  ^item depth = 0 ifTrue: [ self newRootCellFor: item ] ifFalse: [ self newCellFor: item ]-======-execute  item copyCommitIDToClipboard-======-upstreamForBranch: aBranch backend: backend  ^backend lookupBranchNamed: aBranch name inRemote: self remoteName-======-hash  ^self name hash-======-contextClass  ^leftOperation contextClass-======-basepathOf: aPath  self subclassResponsibility-======-initializeBlock  self signature: self class fnSpec block: self block-======-repositoryModel: anObject  repositoryModel := anObject-======-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  item := aToolContext item-======-menuSelectionContext  ^self tool newContext-======-initializePresenter  super initializePresenter.  self commits widget onAnnouncement: FTSelectionChanged send: #uptadeSelectedCommit: to: self.  mergeButton action: [ self mergePullRequestIntoImage ].  acceptButton action: [ self acceptPullRequest ].  rejectButton action: [ self rejectPullRequest ]-======-version: aVersion  version := aVersion-======-description  ^self class description-======-diff  ^diff-======-statusPanel  ^statusPanel-======-initializeEntity: anObject  entity := anObject.  self initialize-======-validateCanCommit  self isDetached ifTrue: [ IceWorkingCopyDesyncronized signal ]-======-fromCommit: aCommit package: aPackage  commit := aCommit.  package := aPackage.  date := commit datetime asDate.  time := commit datetime asTime.  name := '{1}-{2}.{3}' format: {package name .         commit compatibleUsername .         commit datetime asUnixTime}.  id := self class uuidFromCommit: aCommit package: aPackage.  message := commit comment.  author := commit compatibleUsername-======-location: aReferenceOrString  ^self projectLocation location: aReferenceOrString-======-commitModels  | commits |  commits := OrderedCollection new.  self entity commitsDo: [:each |  commits add: (IceTipCommitModel repositoryModel: self repositoryModel on: each) beCached ].  ^commits-======-repositoryName  ^self repository name-======-actionPanel  ^actionPanel-======-tagNameInputText  ^tagNameInputText-======-name  ^name-======-initializeDialogWindow: aWindow  super initializeDialogWindow: aWindow.  acceptButton     disable;     label: 'Add'-======-leftContents  ^definition contents-======-execute  self withErrorHandlingDo: [ self basicExecute.        self finishSuccess ]-======-newCredentialsDataSource  ^IceTipDataSource new     tool: self;     elements: self model allCredentials;     yourself-======-password: anObject  password := anObject-======-toLabel  ^toLabel-======-item  ^item-======-visitRemoval: anIceRemoval  anIceRemoval definition removeFromPatcher: patcher.  self visitChildrenOf: currentNode-======-projectVersion  ^projectVersion-======-validateAlreadyPresentAndNotGit  (self remoteToUse isNil and: [ self location notNil and: [ self location exists and: [ (self class isGitRoot: self location) not ] ] ]) ifTrue: [ IceError signal: ('"{1}" is not a git directory' format: {self location fullName}) ]-======-initializeWidgets  super initializeWidgets.  commitList := self newIceTable.  commitTabPanel := self newTabManager.  self initializeCommitList.  self initializeCommitPanel.  commitList widget onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self.  self focusOrder     add: commitList;     add: commitTabPanel.  self refresh-======-refresh  self model reset.  self resetDiffContents.  changeList widget     in: [:this |  this basicSelectIndexes: #().        this dataSource           rootForItems: self model treeRoots;           selectAll;           expandAll ];     refresh-======-merge: changeTree into: currentTree  ^changeTree collectWithPath: [:operation :path |  currentTree resolve: path ifPresent: [:currentOperation |  operation mergeWithOperation: currentOperation ] ifAbsent: [ IceNonConflictingOperation operation: operation ] ]-======-execute  store removeCredential: credential.  tool refresh-======-isParentOf: aCommit  ^self newCommitWalk includesCommit: aCommit-======-open  self openNonModal modalRelativeTo: World.  ^self credentials-======-title: aString  title := aString-======-currentCommitishLabel  ^currentCommitishLabel-======-refresh  commitButton help: ('Commit your changes to {1}' format: {self repositoryName}).  pushCheckbox label: ('Push changes to {1}' format: {self repositoryRemoteName})-======-sshCredentials  ^IceCredentialStore current sshCredentialForHostname: remote host-======-= aBranch  ^self fullname = aBranch fullname-======-ancestors  ^self commit ancestors-======-packageNameText  ^packageNameText-======-announcer  ^announcer ifNotNil: #contents-======-initialExtent  ^(500 @ (self class inputTextHeight * 5 + self class buttonHeight + 50)) scaledByDisplayScaleFactor-======-icon  self subclassResponsibility-======-peelTag: anIceTag  self subclassResponsibility-======-contents  ^self isBinary ifTrue: [ String streamContents: [:stream |  contents hexDumpOn: stream max: Float infinity ] ] ifFalse: [ contents utf8Decoded ]-======-writeMethodProperties: classMethodDefinitions  self shouldNotImplement-======-credential  ^credential-======-remove  repository workingCopy basicRemovePackage: self-======-projectNameLabel  ^projectNameLabel-======-initializeWidgets  super initializeWidgets.  packageList := self newIceTable.  statusBar := self instantiate: IceTipStatusBar.  self initializePackageList.  self initializeStatusBar.  self focusOrder add: packageList-======-checkoutOn: anIceWorkingCopy  anIceWorkingCopy loadPackagesNamed: committish packageNames fromCommit: committish commit.  self repository setHead: committish.  anIceWorkingCopy referenceCommit: committish commit.  anIceWorkingCopy markAllPackagesAsClean-======-outgoingCommits  ^self entity outgoingCommits-======-isConflict  ^true-======-description  ^self name-======-mergeInto: anIceClassNode  -======-previewCheckout  < noCache>  (IceTipCheckoutPreviewBrowser onBranch: self) openWithSpec-======-oldNode: aNode  oldNode := aNode-======-resolve: aRelativePath ifAbsent: aBlock  ^self resolve: aRelativePath ifPresent: [:each |  each ] ifAbsent: aBlock-======-hash  ^self item hash-======-commit: anIceCommit  commit := anIceCommit-======-selectedBranch  | index |  index := self branchesList widget selectedIndex.  ^index ~= 0 ifTrue: [ self branchesList widget dataSource elementAt: index ] ifFalse: [ nil ]-======-initializePullRequestsTable  pullRequests widget     beResizable;     addColumn: (IceTipTableColumn new           id: '#';           action: [:pullRequest |  pullRequest number asString ];           width: 50 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'State';           action: #state;           width: 50 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Author';           action: #author;           width: 120 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Title';           action: #title;           yourself);     dataSource: self newPullRequestsDataSource-======-datetime  ^self commit datetime-======-copyToClipboardId: id  Clipboard clipboardText: id informing: ('Commitish ID copied to clipboard ({1})' format: {id})-======-contents  ^contents-======-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  (self repositoryModel isNotNil and: [ self repositoryModel isMissing not ]) ifTrue: [ self badge: self repositoryModel numberOfIncomingCommits ]-======-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  selectedCommitish := aToolContext item.  selectedBranch := aToolContext selectedBranch-======-tonelClassExtension: aClass  aClass isTrait ifTrue: [ ^'.trait' ].  ^'.class'-======-isOkEnabled  ^self username isNotEmpty and: [ self password isNotEmpty ]-======-onAccept: aBlock  acceptBlock := aBlock-======-remoteName  ^self remote name , '/' , self entity branch name-======-commitWithMessage: message  ^self workingCopy commitWithMessage: message-======-logClass  ^IceLog allSubclasses detect: [:each |  each isAvailableFor: self ]-======-protocolDropList: anObject  protocolDropList := anObject-======-commits  ^commits-======-diffToWorkingCopy  ^self diffTo: self repository workingCopy-======-validateChangeListNotEmpty  items ifEmpty: [ IceNothingToCommit signal ]-======-version: aString  version := aString-======-isRemoval  ^false-======-hasAnyNonIncomingConflicts  ^self model mergeTree anySatisfy: [:conflict |  conflict isConflict and: [ conflict isResolved not or: [ conflict isLeftChosen ] ] ]-======-forceCalculateDirtyPackages  | diff |  diff := IceDiff new     sourceVersion: self;     targetVersion: self referenceCommit;     buildFull.  self loadedPackages do: [:each |  each beDirty: (diff includesPackageNamed: each name) ]-======-initialize  super initialize.  categories := #()-======-workingCopy  ^self repository workingCopy-======-nextNodeSuchThat: conditionBlock ifFound: foundBlock  self children do: [:each |  (conditionBlock value: each) ifTrue: [ ^foundBlock value: each ].        each nextNodeSuchThat: conditionBlock ifFound: [:found |  ^foundBlock value: found ] ]-======-mergeWithOperation: anOperation  ^anOperation mergeWithLeftAddition: self-======-extent  ^self subclassResponsibility-======-title  ^'New tag of ' , commitishToTag name-======-matches: aPackageModel  ^aPackageModel name asLowercase includesSubstring: self pattern asLowercase-======-commitModels  | commits |  commits := OrderedCollection new.  self entity commitsDo: [:each |  commits add: (IceTipCommitModel repositoryModel: self repositoryModel on: each) beCached ].  ^commits-======-selectionChanged: ann  | element |  (ann newSelectedIndexes reject: [:each |  each = 0 ]) ifNotEmpty: [:indexes |  element := changeList widget dataSource realElementAt: indexes first.        self diffContentsLeft: element value rightContents right: element value leftContents ] ifEmpty: [ self resetDiffContents ]-======-initializeMajor: majorNumber minor: minorNumber patch: patchNumber  major := majorNumber.  minor := minorNumber.  patch := patchNumber-======-details  ^details-======-inverse  ^IceModification left: self rightDefinition right: self leftDefinition-======-doesNotUnderstand: aMessage  aMessage selector isUnary ifTrue: [ cache at: aMessage selector ifPresent: [:value |  ^value ].        (self realObject class lookupSelector: aMessage selector) ifNotNil: [:method |  (method hasPragmaNamed: #noCache) ifFalse: [ ^cache at: aMessage selector put: (self forwardMessage: aMessage) ] ] ].  ^self forwardMessage: aMessage-======-url  ^url-======-fetch  [ ^self remote fetch ] ensure: [ fetched := true ]-======-repository  ^iceCommit repository-======-doCommit: aCollection message: aString pushing: aBoolean  self model commit: (IceTipCommitAction new           diff: self model workingCopyDiff;           items: aCollection;           message: aString;           yourself) then: [ self verifyNeedsRefreshOrClose.        aBoolean ifTrue: [ (IceTipPushAction new repository: self model entity) execute ] ]-======-isRepositoryDetached  ^self repositoryModel isNil or: [ self repositoryModel isDetached ]-======-hash  ^commitish hash-======-writerClass  ^self properties writerClass-======-displayString  ^self entity name-======-textForMergeable: mergeable  mergeable = true ifTrue: [ ^'Yes' ].  mergeable = false ifTrue: [ ^'There are conflicts' ].  ^mergeable asString-======-ensureSourceCodeParentNodeIn: aNode  ^self ensureDirectoryAtPath: diff repository subdirectoryPath segments inNode: aNode-======-visitNoRemote: anError  UIManager default alert: 'There are no remotes defined for this repository. Add one before continue.' title: 'Remote action failed'-======-checkoutStrategy  ^checkoutStrategy-======-execute  | repo cloneOptions checkoutOptions callbacks |  location exists ifTrue: [ IceCloneLocationAlreadyExists signalFor: location ].  [ location ensureCreateDirectory.  repo := LGitRepository on: location.  cloneOptions := LGitCloneOptions withCredentialsProvider: (IceCredentialsProvider defaultForRemoteUrl: url).  checkoutOptions := cloneOptions checkoutOptions.  callbacks := cloneOptions fetchOptions callbacks.  callbacks transferProgress: IceGitTransferProgress new.  checkoutOptions checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force.  checkoutOptions progressCallback: IceGitCheckoutProgress new.  repo clone: url options: cloneOptions.  (LGitRemote of: repo named: 'origin')     lookup;     setUrl: url ] on: LGitCallReturnHandler , IceWrongUrl do: [:error |  location exists ifTrue: [ location ensureDeleteAll ].        error acceptError: (IceLibgitErrorVisitor onContext: self) ]-======-branchName: aString  branchName := aString-======-execute  | selection |  selection := UIManager default request: 'Please provide the name of the new branch to be created' initialAnswer: '' title: 'Create new branch'.  selection isEmptyOrNil ifTrue: [ ^self ].  self repository createBranch: selection.  self beSuccess-======-username: anObject  username := anObject-======-iceVersion  ^commit versionFor: package-======-location: aReferenceOrString  | ref |  ref := aReferenceOrString asFileReference.  keptLocation ifNotNil: [ | newRef |        newRef := (self location pathString copyReplaceAll: keptLocation pathString with: ref pathString) asFileReference.        keptLocation := ref.        ref := newRef ].  self basicLocation: ref-======-username: aUsername project: aProject  path := aUsername , '/' , aProject-======-choosen: anObject  choosen := anObject-======-handlesMouseDown: evt  ^false-======-isNewBranch  ^false-======-model  ^model-======-baseLabel  ^baseLabel-======-showFilterFieldFromKeystrokeEvent: anEvent  | text |  text := anEvent keyCharacter asString.  self textField takeKeyboardFocus.  self textField text: self textField text , text.  self flag: #hack.  self textField textArea cursorEnd: anEvent-======-isExtensionDefinition  ^true-======-title  ^model isCurrent ifTrue: [ 'Current Iceberg credentials' ] ifFalse: [ 'Credentials of ' , model printString ]-======-cancelAction  -======-basicUrl: aString  url := aString-======-package  ^package-======-visitRemoval: anIceRemoval  anIceRemoval definition removeFrom: self-======-publicKeyInput  ^publicKeyInput-======-okAction  credentialStore storeCredential: self credentials forHostname: self host.  tool refresh-======-initializeSourceDirectory  subdirectoryLabel := self newLabel label: 'Source directory'.  subdirectoryInputText := self newTextInput     ghostText: 'e.g., src';     autoAccept: true.  subdirectoryInputText text: self defaultSubdirectory-======-packageName  ^package-======-printOn: aStream  aStream nextPutAll: version asString-======-isModified  ^self entity isModified-======-remoteModels  ^self entity remotes collect: [:each |  (IceTipRemoteModel repositoryModel: self on: each) beCached ]-======-hasLocalBraches  ^self localBranches isNotEmpty-======-changesFromCommit: anIceCommit  ^(self modifiedPackages collect: [:each |  IceImageChange package: each ]) asArray , (self referenceCommit changesFromCommit: anIceCommit) asArray-======-selectionHasActualClass  ^self selectedChangeWrapper ifNil: [ false ] ifNotNil: [:w |  w item value contextClass notNil ]-======-showEmptyTab  emptyTab ifNil: [ emptyTab := self newEmptyTab ].  self removeAllCommitPanelTabs.  commitTabPanel addTab: emptyTab-======-textField  ^textField-======-versionLike: selectBlock ifNone: ifNoneBlock  ^self repository branch versionsFor: self detect: selectBlock ifNone: ifNoneBlock-======-diff: anIceDiff  diff := anIceDiff-======-includes: aRelativePath  ^modifiedFilePaths includes: aRelativePath-======-initialize  super initialize.  isAnonymous := false-======-isRemoval  ^true-======-commit: anIceGitCommit  repository handleLibgitError: [ | localBranch gitcommit |        localBranch := self repositoryHandle lookupLocalBranch: self name.        gitcommit := self repositoryHandle revparse: anIceGitCommit id.        localBranch setTargetId: gitcommit id.        self = repository head ifTrue: [ self repositoryHandle checkout_treeish: gitcommit opts: (LGitCheckoutOptions defaults                       checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force;                       yourself) ] ]-======-isMerged  ^mergeTree allSatisfy: [:operation |  operation isConflict not or: [ operation isResolved ] ]-======-tree  ^self mergeTree-======-definition  ^definition-======-remoteBranchNamed: aString  ^self remoteBranchNamed: aString ifPresent: [:branch |  ^branch ] ifAbsent: [ IceBranchNotFound new           branchName: aString;           signal ]-======-add: item  self selectedItems add: item.  self onSelectionChangedBlock ifNotNil: [:block |  block cull: item cull: true ]-======-versionFor: anIcePackage  ^self commit versionFor: anIcePackage-======-authorLabel  ^authorLabel-======-execute  item ifNil: [ ^self ].  item entity inspect-======-contextClass  ^IceTipCommitContext-======-execute  self withErrorHandlingDo: [ self validateRemotesPresent.        (IceTipPullBrowser onRepositoryModel: self repositoryModel) openWithSpec ]-======-remotes  ^entity remotes-======-fetch  < noCache>  IceTipStandardAction new     repository: self entity;     message: ('Fetching incoming commits of {1}' format: {self name});     onSuccessRepositoryModified;     execute: [ self entity fetch ]-======-actionPanel  ^actionPanel-======-execute  browser accept-======-addShortcutsTo: aWidget  self enableCommanderShortcutsIn: aWidget-======-commitModels  ^(self entity branch incomingCommitsFrom: self remote) collect: [:each |  (IceTipCommitModel repositoryModel: self repositoryModel on: each) beCached ]-======-isRootDefinition  ^true-======-mouseEnter: evt  self flag: #bad.  ^self eventHandler ifNotNil: [ self eventHandler mouseEnter: evt fromMorph: self ]-======-definition  ^definition-======-badge: aNumber  badge := aNumber = 0 ifTrue: [ nil ] ifFalse: [ aNumber ]-======-repositoryWillBeCreated: aRepository  -======-onClick: aBlock  onClickBlock := aBlock-======-icon  ^item value icon-======-repoPath  ^self repository subdirectory-======-initialize  super initialize.  name := ''-======-subscribeToAnnouncements  self announcer when: IceTipDiffRefreshed send: #refreshWhenRepository: to: self-======-copyWithOnly: aCollection  | treeCopy selectedOperations |  selectedOperations := aCollection collect: #value.  treeCopy := tree select: [:node |  selectedOperations includes: node ].  ^self class new     sourceVersion: source;     targetVersion: target;     diffTree: treeCopy;     yourself-======-execute  UIManager default informUser: 'Refreshing pull request list' during: [ tool refreshPullRequests ]-======-uptadeSelectedCommit: anEvent  self diff selectedModel: (anEvent newSelectedRowIndexes ifNotEmpty: [:indexes |  self commits widget dataSource elementAt: indexes first ] ifEmpty: [ nil ])-======-announcer  ^announcer ifNotNil: #contents-======-validateMessageNotEmpty  self message ifEmpty: [ IceNoCommitMessage signal ]-======-execute  UIManager default informUser: 'Reverting change...' during: [ self repositoryModel entity workingCopy discardChanges: item ].  self announcer announce: (IceTipDiffEntryRemoved entry: item).  Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity)-======-removeFrom: aPatcher  aPatcher removeClass: self-======-parent  ^parent-======-accept  ^self doCommit-======-snapshotFor: anIceSavedPackage  ^MCSnapshot empty-======-tagNameLabel  ^tagNameLabel-======-accept: aVisitor  ^aVisitor visitMethodNode: self-======-isWorkingCopy  ^false-======-remoteName: aString  remoteName := aString-======-iconNamed: aSymbol  ^self class iconNamed: aSymbol-======-mergeWith: anotherNode onLeft: leftBlock onRight: rightBlock onMerge: mergeBlock  ^anotherNode collect: rightBlock-======-visitTreeNode: anIceNode  self withNode: anIceNode do: [ anIceNode value accept: self ]-======-commit  ^self entity-======-rootItem: anItem  super rootItem: anItem.  self addSourceToRootItem-======-nameInput  ^nameInput-======-createBranch: aString inCommit: anIceGitCommit  self handleLibgitError: [ (self repositoryHandle isUnborn and: [ anIceGitCommit isNoCommit ]) ifTrue: [ ^self createBranch: aString ].        self repositoryHandle createBranch: aString targetId: (LGitId fromHexString: anIceGitCommit gitRef) force: false.        ^(self branchNamed: aString)           switch;           yourself ]-======-incomingCommits  ^#()-======-mergeWithMasterCheckbox: anObject  mergeWithMasterCheckbox := anObject-======-iconNamed: aSymbol  ^Smalltalk ui icons iconNamed: aSymbol-======-execute  ^IceGitHubRemoveBranchesAction new     repository: self repository;     remote: self remote;     execute-======-removeFromPatcher: aMCPatcher  self subclassResponsibility-======-version: anObject  version := anObject-======-backend: anObject  backend := anObject-======-title: anObject  title := anObject-======-iconForMergeable: mergeable  mergeable = true ifTrue: [ ^self iconNamed: #smallOk ].  ^self iconNamed: #smallCancel-======-checkForRegistryConflicts  self subclassResponsibility-======-newRootCellFor: item  | cell |  cell := IceTipOutlineHeaderCellMorph dataSource: self item: item.  (self iconFor: item data) ifNotNil: [:icon |  cell addMorphBack: icon asMorph ].  cell addMorphBack: (self toString: item data) asMorph asReadOnlyMorph.  cell addMorphBack: (AlignmentMorph newSpacer: Color transparent).  cell addMorphBack: item children size asMorph asReadOnlyMorph.  cell addMorphBack: (Morph newBounds: (0 @ 0 corner: 20 @ 0) color: Color transparent) asReadOnlyMorph.  ^cell-======-doAccept  self validate.  commitishToTag createTag: self tagName thenDo: [:newBranch |  callback ifNotNil: [ callback value: newBranch ] ]-======-initializeCommitsTable  | textStylingBlock |  textStylingBlock := [:string :commit |  commit isMerged ifTrue: [ string asText ] ifFalse: [ string asText allBold ] ].  commits widget     beResizable;     addColumn: (IceTipTableColumn id: 'Date & time' action: [:commit |  textStylingBlock value: commit datetime asLocalStringYMDHM value: commit ] width: 120 * World displayScaleFactor);     addColumn: (IceTipTableColumn id: 'Id' action: [:commit |  textStylingBlock value: commit shortId value: commit ] width: 50 * World displayScaleFactor);     addColumn: (IceTipTableColumn id: 'Author' action: [:commit |  textStylingBlock value: commit author value: commit ] width: 120 * World displayScaleFactor);     addColumn: (IceTipTableColumn id: 'Comment' action: [:commit |  textStylingBlock value: commit comment value: commit ] width: 300 * World displayScaleFactor);     dataSource: self newCommitsDataSource;     selectRowIndex: 1-======-delete  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Removing branch {1}' format: {self name});     onSuccessRepositoryModified;     execute: [ self entity delete ]-======-visitRemoval: anIceRemoval  anIceRemoval definition removeFrom: self.  self visitChildrenOf: currentNode-======-nextChildNodeStartingFrom: anIceNode suchThat: conditionBlock ifNone: noneBlock  | aCollection |  aCollection := self children.  (aCollection indexOf: anIceNode) + 1 to: aCollection size do: [:index |  | item |        item := aCollection at: index.        (conditionBlock value: item) ifTrue: [ ^item ].        item nextNodeSuchThat: conditionBlock ifFound: [:found |  ^found ] ].  self parent ifNil: [ ^noneBlock value ].  ^self parent nextChildNodeStartingFrom: self suchThat: conditionBlock ifNone: noneBlock-======-checkout: aCheckoutStrategy  aCheckoutStrategy committish: self.  ^repository checkout: aCheckoutStrategy-======-actionPanel: anObject  actionPanel := anObject-======-contents  ^''-======-addRemoteNamed: aName url: anUrl  IceTipStandardAction new     repository: self entity;     message: 'Adding remote';     onSuccessRepositoryModified;     execute: [ | remote |        remote := IceGitRemote name: aName url: anUrl.        self entity addRemote: remote.        remote fetch ]-======-publicKey  ^publicKey ifNil: [ publicKey := self class defaultPublicKey ]-======-referencesSameRemoteLocationAs: aRemote  ^(super referencesSameRemoteLocationAs: aRemote) or: [ self httpsUrl = aRemote httpsUrl ]-======-properties  ^properties ifNil: [ properties := Dictionary new ]-======-cellColumn: column row: rowIndex  ^FTCellMorph new     addMorphBack: ((self elementAt: rowIndex) at: column id) asStringMorph;     yourself-======-hasUnknownCommit  ^self workingCopyState isUnknownCommitState-======-mergeWithLeftModification: anIceModification  ^IceConflictingOperation left: anIceModification right: self-======-readContextParametersFromModel: aModel  self repositoryModel: aModel repositoryModel-======-codeDirectory  self repositoryDirectory exists ifTrue: [ ^self basicCodeDirectory ] ifFalse: [ IceLocalRepositoryMissing signalFor: self ]-======-addLabel: aString value: anObject  items at: aString put: anObject.  self refresh-======-initializeWithJSON: aDictionary  json := aDictionary.  self initialize-======-title  ^'Pull {1}/{2} from {3}' format: {self model repositoryName .         self model branchName .         self model remoteName}-======-hasTagNamed: aString  self subclassResponsibility-======-okAction  self credentials     username: self username;     password: self password.  credentialStore storeCredential: self credentials.  tool refresh-======-packageNameFromPackageDirectory  ^iceVersion packageName-======-pullFrom: aRemote  | remoteBranch |  repository fetch.  remoteBranch := aRemote remoteBranchNamed: self name ifAbsent: [ ^self ].  repository createBranch: self name inCommit: remoteBranch commit-======-isNoCommit  ^true-======-createRepository: aRepositorySpec  (self canHandleType: aRepositorySpec type) ifTrue: [ ^Iceberg mcRepositoryFor: aRepositorySpec description ].  ^super createRepository: aRepositorySpec-======-writeInDirectoryName: directoryNameOrPath fileName: fileName extension: ext visit: visitBlock  | directory |  directory := self directoryForDirectoryNamed: directoryNameOrPath.  self fileUtils writeStreamFor: fileName , ext in: directory do: [:fs |  self setFileStream: fs.        visitBlock value ]-======-max: anInteger  max := anInteger-======-isRightChosen  ^chosen = operation inverse-======-shortDescriptionWithDecoration  ^self addDecorationTo: (self entity isRemote ifTrue: [ self name copyAfter: $/ ] ifFalse: [ self name ])-======-initializeCommitPanel  commitTabPanel     addTab: (infoTab := self newInfoTab);     addTab: (diffTab := self newDiffTab           label: 'Diff from ancestor';           whenTabSelected: [ self refreshDiff ];           yourself)-======-iceCommitFrom: aLGitCommit  ^self repository iceCommitFrom: aLGitCommit-======-printOn: aStream  aStream     print: self class;     nextPut: $(;     nextPutAll: self package name.  aStream nextPut: $)-======-passphrase  ^passphraseInput text-======-block  ^[:path :completed :total :payload |  job ensureStarted.  job min: 0.  job max: total.  job current: completed.  job title: ('Checking out... ({1}/{2})' format: {completed .               total}).  job changed ]-======-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  tool := aToolContext tool-======-