format  ^format-=JUAMPI=-load  self repository workingCopy loadPackageNamed: self name-=JUAMPI=-obtainAvailableRemotes  | remotes |  remotes := self repository remotes.  (remotes includes: self baseRemote) ifFalse: [ remotes := remotes copyWith: self baseRemote ].  ^remotes-=JUAMPI=-mergeBaseBetween: aCommitId and: anotherCommitId  self handleLibgitError: [ ^(self repositoryHandle mergeBaseBetween: (LGitId fromHexString: aCommitId) and: (LGitId fromHexString: anotherCommitId)) hexString ]-=JUAMPI=-timeStamp  ^self datetime-=JUAMPI=-baseLabel  ^'No PR selected'-=JUAMPI=-projectName  ^projectName-=JUAMPI=-isFastForward  ^self headCommit isAncestorOf: mergeCommit-=JUAMPI=-basicExecute  self fetchAllRemotes.  (IceTipPullBrowser onRepositoryModel: self repositoryModel) openWithSpec-=JUAMPI=-sortingStrategyFirst: aSymbol  self sortingStrategy first: aSymbol-=JUAMPI=-initializeChangeList  | dataSource |  dataSource := self newChangeTreeDataSource.  changeList widget dataSource: dataSource.  dataSource expandAll-=JUAMPI=-changesFromCommit: anIceNoCommit  ^anIceNoCommit changesFromNoCommit: self-=JUAMPI=-remoteFileReferenceInPath: anUndefinedObject  -=JUAMPI=-issueLabel: anObject  issueLabel := anObject-=JUAMPI=-initializeWidgets  self initializeProjectLocation.  self initializeSpacePanel-=JUAMPI=-workingCopy  ^repository workingCopy-=JUAMPI=-createCommandContextForSelection: selectedItems  ^self newContextWithSelection: selectedItems-=JUAMPI=-fetchFrom: aRemote  aRemote fetch-=JUAMPI=-position: anObject  position := anObject-=JUAMPI=-allBranchModels  ^self entity allBranches collect: [:each |  (IceTipBranchModel repositoryModel: self on: each) beCached ]-=JUAMPI=-tags  ^self commit tags-=JUAMPI=-datetime  ^datetime-=JUAMPI=-repositoryName  ^self repositoryModel name-=JUAMPI=-customError: aDictionary  ^aDictionary at: #message-=JUAMPI=-removeFrom: aStore  aStore removeSSHCredential: self-=JUAMPI=-packageModels  ^self sortingStrategy sort: (self repositoryModel entity workingCopy packages collect: [:each |  (IceTipPackageModel repositoryModel: self repositoryModel on: each) beCached ])-=JUAMPI=-remote: anObject  remote := anObject-=JUAMPI=-privateKey: anObject  privateKey := anObject.  self storeIfDefault-=JUAMPI=-fileNameForMethod: aMethod  | path |  path := OrderedCollection new.  self repository subdirectory ifNotEmpty: [:subDir |  path add: subDir ].  path add: (self tonelPackageName: aMethod package).  path add: (self tonelMethodClassOrTraitName: aMethod).  ^String streamContents: [:stream |  path asStringOn: stream delimiter: '/' ]-=JUAMPI=-longStatus  (entity isMissing and: [ entity location isNil ]) ifTrue: [ ^'Iceberg does not find a git repository. Please clone the repository or change the repository location to an existing Git repository' ].  entity isMissing ifTrue: [ ^'Iceberg does not find a git repository at {1}. Please clone the repository again or change the repository location to an existing Git repository' format: {entity location} ].  entity workingCopy workingCopyState isUnknownCommitState ifTrue: [ ^'This image has a loaded version of the code from commit {1}, but Iceberg does not find the commit in your local Git repository. You may fetch the correct commit from a remote repository or discard the code of your image and load the version that is in the repository.' format: {entity workingCopy referenceCommit shortId} ].  entity workingCopy isDetached ifTrue: [ ^'The loaded code in the image starts from commit {1}. This commit does not correspond with the commit in the head of the current branch of the repository (Commit {2}). You need to synchronize them to continue. You need to discard your image changes or change the HEAD of the repository to point to the commit.' format: {entity workingCopy referenceCommit shortId .               entity headCommit shortId} ].  entity head isDetached ifTrue: [ ^'The repository and the image are in the same commit {1}. However, the commit is not in an active branch. It is not possible to commit in a Git detached HEAD state. Create a new branch (by checkouting) or checkout an existing one.' format: {entity headCommit shortId} ].  entity workingCopy project isUnborn ifTrue: [ ^'Cannot find a project (meta-data and source directory) in your repository. Please edit your repository meta-data to indicate the source code directory or change the location to a valid iceberg repository' ].  ^'Your repository seems ok. Please report a ticket in Iceberg''s issue tracker. If you can, please send us a backup of your image in this state for debugging.'-=JUAMPI=-keysDo: aBlockClosure  childrenDictionary keysDo: aBlockClosure-=JUAMPI=-issueLabel  ^issueLabel-=JUAMPI=-execute  self packageModel remove-=JUAMPI=-headCommit  ^self head commit-=JUAMPI=-push  -=JUAMPI=-snapshotFor: package  ^(self versionFor: package) snapshot-=JUAMPI=-asBornProperties  ^IceRepositoryProperties fromDictionary: properties commitish: commitish-=JUAMPI=-selectedChange  ^(self selectedChangeWrapper ifNil: [ ^nil ]) item value-=JUAMPI=-request: anObject  request := anObject-=JUAMPI=-diffToReferenceCommit  ^self diffTo: self referenceCommit-=JUAMPI=-url  ^url-=JUAMPI=-selectRemoteNamed: aString  remoteList setSelectedItem: (self model remoteModels detect: [:each |  each name = aString ])-=JUAMPI=-table: aTable  super table: aTable.  self addBindingsToTable-=JUAMPI=-selectNextConflict  | next |  next := self nextConflict ifNil: [ ^self ].  self changed: {#openPath} , next item path segments-=JUAMPI=-item  ^self packageModel-=JUAMPI=-descriptionWithDecoration  ^self name asText-=JUAMPI=-isLocal  ^self entity isLocal-=JUAMPI=-cellColumn: column row: rowIndex  ^self newCellFor: (self elementAt: rowIndex)-=JUAMPI=-refreshWhenRepository: ann  (ann repository isNil or: [ self model repositoryModel isModelOf: ann repository ]) ifFalse: [ ^self ].  self model reset.  self refresh-=JUAMPI=-visitPackage: anIcePackageDefinition  | mcPackage snapshot patcher version |  mcPackage := MCPackage named: anIcePackageDefinition name.  snapshot := [ diff targetVersion snapshotFor: anIcePackageDefinition ] on: NotFound do: [ MCSnapshot empty ].  patcher := MCPatcher snapshot: snapshot.  currentNode accept: (IceMCSnapshotPatchVisitor new           patcher: patcher;           yourself).  version := MCVersion new setPackage: mcPackage info: (IceMCVersionInfo package: mcPackage message: 'Internal...') snapshot: patcher patchedSnapshot dependencies: #().  index storeVersion: version-=JUAMPI=-child  ^IceGitChange on: (RelativePath withAll: self path segments allButFirst) pathString-=JUAMPI=-defaultMenuItemName  ^'Open on github'-=JUAMPI=-versionsFor: package  ^self commit versionsFor: package-=JUAMPI=-newContextWithSelection: anObject  ^self newContext     item: anObject;     yourself-=JUAMPI=-refreshDirtyPackages  self markAsCleanPackagesNotInDiff: self repository workingCopyDiff-=JUAMPI=-remotes  self handleLibgitError: [ | gitRemotes |        self isValid ifFalse: [ ^#() ].        gitRemotes := self repositoryHandle allRemotes.        ^gitRemotes collect: [:each |  (IceGitRemote name: each remoteName url: each url)                 localRepository: self;                 yourself ] ]-=JUAMPI=-commit  ^self-=JUAMPI=-isClassDefinition  ^false-=JUAMPI=-execute  self subclassResponsibility-=JUAMPI=-repositoryList  ^repositoryList-=JUAMPI=-mergeWithBranch: aBranch  self subclassResponsibility-=JUAMPI=-entryName  ^entryName-=JUAMPI=-response  ^response-=JUAMPI=-actualClass  ^self contextClass-=JUAMPI=-value  ^list includes: item-=JUAMPI=-typeList: anObject  typeList := anObject-=JUAMPI=-repository  ^commitish repository-=JUAMPI=-packages  tree isEmpty ifTrue: [ ^#() ].  ^self codeSubdirectoryNode children-=JUAMPI=-select: aBlockClosure  ^self-=JUAMPI=-basicNewRemoteBranchNamed: aString  ^IceGitRemoteBranch named: aString inRepository: self-=JUAMPI=-gitRef  ^((repository location / '.git' / 'HEAD') contents withoutPrefix: 'ref: ') trimBoth-=JUAMPI=-initializeWidgets  super initializeWidgets.  repositoryList := self newIceTable.  repositoryList widget onAnnouncement: FTStrongSelectionChanged send: #repositoryStrongSelection: to: self.  self initializeRepositoryList.  self focusOrder add: repositoryList-=JUAMPI=-push  self branch push-=JUAMPI=-optionsList  ^optionsList-=JUAMPI=-nameLabel: anObject  nameLabel := anObject-=JUAMPI=-id: anObject  id := anObject-=JUAMPI=-invalidError: aDictionary  ^'Invalid field: ' , (aDictionary at: #field)-=JUAMPI=-children  ^#()-=JUAMPI=-classIsMeta: anObject  classIsMeta := anObject-=JUAMPI=-changesFromCommit: anIceNoCommit  self assert: anIceNoCommit isNoCommit.  ^#()-=JUAMPI=-sourceDirectory  ^self repository project sourceDirectory-=JUAMPI=-packageNameFromPackageDirectory  ^iceVersion packageName-=JUAMPI=-toText: anObject  toText := anObject-=JUAMPI=-tags  self subclassResponsibility-=JUAMPI=-contextClass  ^IceTipBranchContext-=JUAMPI=-fetchPullRequests  ^(IceGitHubAPI new getPullRequests: self remote owner project: self remote projectName) all collect: [:each |  (IceGitHubPullRequest fromJSON: each)           repository: self repository entity;           yourself ]-=JUAMPI=-messageText  ^'There is no version for package: {1} in  commit {2}' format: {self version packageName .         self version commit id}-=JUAMPI=-shortName  ^self name copyAfter: $/-=JUAMPI=-remoteUrl: anObject  remoteUrl := anObject-=JUAMPI=-visitNonConflictingOperation: anIceNonConflictingOperation  anIceNonConflictingOperation chosenOperation accept: self-=JUAMPI=-withoutNewBranch  types := self allTypes reject: #isNewBranch.  typeList widget dataSource elements: types.  typeList widget refresh-=JUAMPI=-hasSingleCommit  ^self workingCopyState isSingleCommitState-=JUAMPI=-repositoryProperties  ^properties-=JUAMPI=-repository  ^repository-=JUAMPI=-initialize  super initialize.  childrenDictionary := Dictionary new-=JUAMPI=-mergeThen: aBlock  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Merging branch {1} from {2}' format: {self name .               self repositoryName});     onSuccessRepositoryModified;     onSuccess: aBlock;     execute: [ self entity merge ]-=JUAMPI=-includesPackageNamed: aName  ^false-=JUAMPI=-acceptError: anObject  anObject visitShouldCommitBeforePullError: self-=JUAMPI=-reset  UIManager default informUser: 'Refreshing changes' during: [ self resetDiff.        self diff ]-=JUAMPI=-initializeExistingTagsList  existingTagsList := self newList.  existingTagsList     items: commitishToTag tagModels;     displayBlock: #name;     sortingBlock: #name descending-=JUAMPI=-canBrowseReferences  ^self canBeBrowsed-=JUAMPI=-help  ^self commandClass defaultHelp-=JUAMPI=-printOn: aStream  aStream     nextPutAll: self class name;     nextPutAll: '(';     nextPutAll: self name;     nextPutAll: ')'-=JUAMPI=-package  ^package-=JUAMPI=-model: anObject  model := anObject.  self allTypes do: [:each |  each model: anObject ]-=JUAMPI=-mergeIntoWorkingCopy  self repository     ensureBranch: self branchName;     checkoutBranch: self branchName.  self branch merge-=JUAMPI=-visitAuthenticationError: anError  UIManager default alert: anError messageText title: 'Iceberg authentication Error'-=JUAMPI=-initializeWidgets  iconPanel := self newIcePanel.  iconPanel widget addMorph: ((self iconNamed: #error) scaledToSize: 32 @ 32) asMorph.  errorLabel := self newIceReadOnlyText.  errorLabel widget contentsWrapped: exception messageText.  errorLabel widget     hResizing: #spaceFill;     vResizing: #spaceFill-=JUAMPI=-createCheckboxFor: anObject  ^CheckboxMorph on: (IceGitHubSelectItem list: selectedItems item: anObject) selected: #value changeSelected: #value:-=JUAMPI=-subscribeToAnnouncements  Iceberg announcer weak when: IceRepositoryAnnouncement send: #refreshWhenRepository: to: self-=JUAMPI=-ensureDefaultProperties  properties at: #format ifAbsentPut: [ self writerClass id ]-=JUAMPI=-labelFor: aCommitModel  ^'HEAD to {1}' format: {(aCommitModel ifNotNil: #shortId)}-=JUAMPI=-changeList: anObject  changeList := anObject-=JUAMPI=-checkoutWithStrategy: aCheckoutStrategy  repository checkout: (aCheckoutStrategy commitish: self)-=JUAMPI=-hash  ^self commit hash-=JUAMPI=-contentsWithValidationDo: aBlock  ^(self responseWithValidationDo: aBlock) contents-=JUAMPI=-icon  ^self iconNamed: #changeRemove-=JUAMPI=-nextNodeSuchThat: conditionBlock ifNone: noneBlock  self children do: [:each |  (conditionBlock value: each) ifTrue: [ ^each ].        each nextNodeSuchThat: conditionBlock ifFound: [:found |  ^found ] ].  ^self parent nextChildNodeStartingFrom: self suchThat: conditionBlock ifNone: noneBlock-=JUAMPI=-selectRemoteModel  ^selectRemoteModel ifNil: [ selectRemoteModel := IceTipRemoteActionModel repositoryModel: self model on: self model entity ]-=JUAMPI=-contents  ^self basicAt: 1-=JUAMPI=-basicExecute  IceTipRegisterRepositoryDialog new     beForCloneOfRepository: self repositoryModel entity;     onAccept: [ Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity) ];     openDialogWithSpec-=JUAMPI=-onSuccessAnnounce: aValuable  successAnnounceBlock := aValuable-=JUAMPI=-repository  ^repository-=JUAMPI=-fileUtils  ^IceLibgitFiletreeFileUtils-=JUAMPI=-comment  ^self entity comment-=JUAMPI=-mergeWithLeftRemoval: anIceRemoval  ^IceConflictingOperation left: anIceRemoval right: self-=JUAMPI=-keys  ^childrenDictionary keys-=JUAMPI=-definition  ^operation definition-=JUAMPI=-onAccept: aBlock  acceptBlock := aBlock-=JUAMPI=-sourceCode: aString  sourceCode := aString-=JUAMPI=-hasAnyNonConflictConflicts  ^self model mergeTree anySatisfy: [:conflict |  conflict isConflict and: [ conflict isResolved ] ]-=JUAMPI=-model  ^model-=JUAMPI=-delete  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Removing remote {1}' format: {self name});     onSuccessRepositoryModified;     do: [ self repositoryModel entity removeRemote: self entity ]-=JUAMPI=-credentials: aPlainTextCredential  credential := aPlainTextCredential.  self usernameInput text: credential username.  self passwordInput text: credential password-=JUAMPI=-writerClass  ^self commit writerClass-=JUAMPI=-badgeSelector: aSymbol  badgeSelector := aSymbol-=JUAMPI=-free  (handle isNil or: [ handle isNull ]) ifFalse: [ handle free.        handle := nil ]-=JUAMPI=-referencesSameRemoteLocationAs: aRemote  ^(super referencesSameRemoteLocationAs: aRemote) or: [ (self url withoutSuffix: '.git') sameAs: (aRemote httpsUrl withoutSuffix: '.git') ]-=JUAMPI=-readProjectFromCommitish: aCommitish  self subclassResponsibility-=JUAMPI=-cellColumn: column row: rowIndex  | item |  item := self elementAt: rowIndex.  ^item depth = 0 ifTrue: [ self newRootCellFor: item ] ifFalse: [ self newCellFor: item ]-=JUAMPI=-execute  item copyCommitIDToClipboard-=JUAMPI=-upstreamForBranch: aBranch backend: backend  ^backend lookupBranchNamed: aBranch name inRemote: self remoteName-=JUAMPI=-hash  ^self name hash-=JUAMPI=-contextClass  ^leftOperation contextClass-=JUAMPI=-basepathOf: aPath  self subclassResponsibility-=JUAMPI=-initializeBlock  self signature: self class fnSpec block: self block-=JUAMPI=-repositoryModel: anObject  repositoryModel := anObject-=JUAMPI=-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  item := aToolContext item-=JUAMPI=-menuSelectionContext  ^self tool newContext-=JUAMPI=-initializePresenter  super initializePresenter.  self commits widget onAnnouncement: FTSelectionChanged send: #uptadeSelectedCommit: to: self.  mergeButton action: [ self mergePullRequestIntoImage ].  acceptButton action: [ self acceptPullRequest ].  rejectButton action: [ self rejectPullRequest ]-=JUAMPI=-version: aVersion  version := aVersion-=JUAMPI=-description  ^self class description-=JUAMPI=-diff  ^diff-=JUAMPI=-statusPanel  ^statusPanel-=JUAMPI=-initializeEntity: anObject  entity := anObject.  self initialize-=JUAMPI=-validateCanCommit  self isDetached ifTrue: [ IceWorkingCopyDesyncronized signal ]-=JUAMPI=-fromCommit: aCommit package: aPackage  commit := aCommit.  package := aPackage.  date := commit datetime asDate.  time := commit datetime asTime.  name := '{1}-{2}.{3}' format: {package name .         commit compatibleUsername .         commit datetime asUnixTime}.  id := self class uuidFromCommit: aCommit package: aPackage.  message := commit comment.  author := commit compatibleUsername-=JUAMPI=-location: aReferenceOrString  ^self projectLocation location: aReferenceOrString-=JUAMPI=-commitModels  | commits |  commits := OrderedCollection new.  self entity commitsDo: [:each |  commits add: (IceTipCommitModel repositoryModel: self repositoryModel on: each) beCached ].  ^commits-=JUAMPI=-repositoryName  ^self repository name-=JUAMPI=-actionPanel  ^actionPanel-=JUAMPI=-tagNameInputText  ^tagNameInputText-=JUAMPI=-name  ^name-=JUAMPI=-initializeDialogWindow: aWindow  super initializeDialogWindow: aWindow.  acceptButton     disable;     label: 'Add'-=JUAMPI=-leftContents  ^definition contents-=JUAMPI=-execute  self withErrorHandlingDo: [ self basicExecute.        self finishSuccess ]-=JUAMPI=-newCredentialsDataSource  ^IceTipDataSource new     tool: self;     elements: self model allCredentials;     yourself-=JUAMPI=-password: anObject  password := anObject-=JUAMPI=-toLabel  ^toLabel-=JUAMPI=-item  ^item-=JUAMPI=-visitRemoval: anIceRemoval  anIceRemoval definition removeFromPatcher: patcher.  self visitChildrenOf: currentNode-=JUAMPI=-projectVersion  ^projectVersion-=JUAMPI=-validateAlreadyPresentAndNotGit  (self remoteToUse isNil and: [ self location notNil and: [ self location exists and: [ (self class isGitRoot: self location) not ] ] ]) ifTrue: [ IceError signal: ('"{1}" is not a git directory' format: {self location fullName}) ]-=JUAMPI=-initializeWidgets  super initializeWidgets.  commitList := self newIceTable.  commitTabPanel := self newTabManager.  self initializeCommitList.  self initializeCommitPanel.  commitList widget onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self.  self focusOrder     add: commitList;     add: commitTabPanel.  self refresh-=JUAMPI=-refresh  self model reset.  self resetDiffContents.  changeList widget     in: [:this |  this basicSelectIndexes: #().        this dataSource           rootForItems: self model treeRoots;           selectAll;           expandAll ];     refresh-=JUAMPI=-merge: changeTree into: currentTree  ^changeTree collectWithPath: [:operation :path |  currentTree resolve: path ifPresent: [:currentOperation |  operation mergeWithOperation: currentOperation ] ifAbsent: [ IceNonConflictingOperation operation: operation ] ]-=JUAMPI=-execute  store removeCredential: credential.  tool refresh-=JUAMPI=-isParentOf: aCommit  ^self newCommitWalk includesCommit: aCommit-=JUAMPI=-open  self openNonModal modalRelativeTo: World.  ^self credentials-=JUAMPI=-title: aString  title := aString-=JUAMPI=-currentCommitishLabel  ^currentCommitishLabel-=JUAMPI=-refresh  commitButton help: ('Commit your changes to {1}' format: {self repositoryName}).  pushCheckbox label: ('Push changes to {1}' format: {self repositoryRemoteName})-=JUAMPI=-sshCredentials  ^IceCredentialStore current sshCredentialForHostname: remote host-=JUAMPI=-= aBranch  ^self fullname = aBranch fullname-=JUAMPI=-ancestors  ^self commit ancestors-=JUAMPI=-packageNameText  ^packageNameText-=JUAMPI=-announcer  ^announcer ifNotNil: #contents-=JUAMPI=-initialExtent  ^(500 @ (self class inputTextHeight * 5 + self class buttonHeight + 50)) scaledByDisplayScaleFactor-=JUAMPI=-icon  self subclassResponsibility-=JUAMPI=-peelTag: anIceTag  self subclassResponsibility-=JUAMPI=-contents  ^self isBinary ifTrue: [ String streamContents: [:stream |  contents hexDumpOn: stream max: Float infinity ] ] ifFalse: [ contents utf8Decoded ]-=JUAMPI=-writeMethodProperties: classMethodDefinitions  self shouldNotImplement-=JUAMPI=-credential  ^credential-=JUAMPI=-remove  repository workingCopy basicRemovePackage: self-=JUAMPI=-projectNameLabel  ^projectNameLabel-=JUAMPI=-initializeWidgets  super initializeWidgets.  packageList := self newIceTable.  statusBar := self instantiate: IceTipStatusBar.  self initializePackageList.  self initializeStatusBar.  self focusOrder add: packageList-=JUAMPI=-checkoutOn: anIceWorkingCopy  anIceWorkingCopy loadPackagesNamed: committish packageNames fromCommit: committish commit.  self repository setHead: committish.  anIceWorkingCopy referenceCommit: committish commit.  anIceWorkingCopy markAllPackagesAsClean-=JUAMPI=-outgoingCommits  ^self entity outgoingCommits-=JUAMPI=-isConflict  ^true-=JUAMPI=-description  ^self name-=JUAMPI=-mergeInto: anIceClassNode  -=JUAMPI=-previewCheckout  < noCache>  (IceTipCheckoutPreviewBrowser onBranch: self) openWithSpec-=JUAMPI=-oldNode: aNode  oldNode := aNode-=JUAMPI=-resolve: aRelativePath ifAbsent: aBlock  ^self resolve: aRelativePath ifPresent: [:each |  each ] ifAbsent: aBlock-=JUAMPI=-hash  ^self item hash-=JUAMPI=-commit: anIceCommit  commit := anIceCommit-=JUAMPI=-selectedBranch  | index |  index := self branchesList widget selectedIndex.  ^index ~= 0 ifTrue: [ self branchesList widget dataSource elementAt: index ] ifFalse: [ nil ]-=JUAMPI=-initializePullRequestsTable  pullRequests widget     beResizable;     addColumn: (IceTipTableColumn new           id: '#';           action: [:pullRequest |  pullRequest number asString ];           width: 50 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'State';           action: #state;           width: 50 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Author';           action: #author;           width: 120 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Title';           action: #title;           yourself);     dataSource: self newPullRequestsDataSource-=JUAMPI=-datetime  ^self commit datetime-=JUAMPI=-copyToClipboardId: id  Clipboard clipboardText: id informing: ('Commitish ID copied to clipboard ({1})' format: {id})-=JUAMPI=-contents  ^contents-=JUAMPI=-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  (self repositoryModel isNotNil and: [ self repositoryModel isMissing not ]) ifTrue: [ self badge: self repositoryModel numberOfIncomingCommits ]-=JUAMPI=-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  selectedCommitish := aToolContext item.  selectedBranch := aToolContext selectedBranch-=JUAMPI=-tonelClassExtension: aClass  aClass isTrait ifTrue: [ ^'.trait' ].  ^'.class'-=JUAMPI=-isOkEnabled  ^self username isNotEmpty and: [ self password isNotEmpty ]-=JUAMPI=-onAccept: aBlock  acceptBlock := aBlock-=JUAMPI=-remoteName  ^self remote name , '/' , self entity branch name-=JUAMPI=-commitWithMessage: message  ^self workingCopy commitWithMessage: message-=JUAMPI=-logClass  ^IceLog allSubclasses detect: [:each |  each isAvailableFor: self ]-=JUAMPI=-protocolDropList: anObject  protocolDropList := anObject-=JUAMPI=-commits  ^commits-=JUAMPI=-diffToWorkingCopy  ^self diffTo: self repository workingCopy-=JUAMPI=-validateChangeListNotEmpty  items ifEmpty: [ IceNothingToCommit signal ]-=JUAMPI=-version: aString  version := aString-=JUAMPI=-isRemoval  ^false-=JUAMPI=-hasAnyNonIncomingConflicts  ^self model mergeTree anySatisfy: [:conflict |  conflict isConflict and: [ conflict isResolved not or: [ conflict isLeftChosen ] ] ]-=JUAMPI=-forceCalculateDirtyPackages  | diff |  diff := IceDiff new     sourceVersion: self;     targetVersion: self referenceCommit;     buildFull.  self loadedPackages do: [:each |  each beDirty: (diff includesPackageNamed: each name) ]-=JUAMPI=-initialize  super initialize.  categories := #()-=JUAMPI=-workingCopy  ^self repository workingCopy-=JUAMPI=-nextNodeSuchThat: conditionBlock ifFound: foundBlock  self children do: [:each |  (conditionBlock value: each) ifTrue: [ ^foundBlock value: each ].        each nextNodeSuchThat: conditionBlock ifFound: [:found |  ^foundBlock value: found ] ]-=JUAMPI=-mergeWithOperation: anOperation  ^anOperation mergeWithLeftAddition: self-=JUAMPI=-extent  ^self subclassResponsibility-=JUAMPI=-title  ^'New tag of ' , commitishToTag name-=JUAMPI=-matches: aPackageModel  ^aPackageModel name asLowercase includesSubstring: self pattern asLowercase-=JUAMPI=-commitModels  | commits |  commits := OrderedCollection new.  self entity commitsDo: [:each |  commits add: (IceTipCommitModel repositoryModel: self repositoryModel on: each) beCached ].  ^commits-=JUAMPI=-selectionChanged: ann  | element |  (ann newSelectedIndexes reject: [:each |  each = 0 ]) ifNotEmpty: [:indexes |  element := changeList widget dataSource realElementAt: indexes first.        self diffContentsLeft: element value rightContents right: element value leftContents ] ifEmpty: [ self resetDiffContents ]-=JUAMPI=-initializeMajor: majorNumber minor: minorNumber patch: patchNumber  major := majorNumber.  minor := minorNumber.  patch := patchNumber-=JUAMPI=-details  ^details-=JUAMPI=-inverse  ^IceModification left: self rightDefinition right: self leftDefinition-=JUAMPI=-doesNotUnderstand: aMessage  aMessage selector isUnary ifTrue: [ cache at: aMessage selector ifPresent: [:value |  ^value ].        (self realObject class lookupSelector: aMessage selector) ifNotNil: [:method |  (method hasPragmaNamed: #noCache) ifFalse: [ ^cache at: aMessage selector put: (self forwardMessage: aMessage) ] ] ].  ^self forwardMessage: aMessage-=JUAMPI=-url  ^url-=JUAMPI=-fetch  [ ^self remote fetch ] ensure: [ fetched := true ]-=JUAMPI=-repository  ^iceCommit repository-=JUAMPI=-doCommit: aCollection message: aString pushing: aBoolean  self model commit: (IceTipCommitAction new           diff: self model workingCopyDiff;           items: aCollection;           message: aString;           yourself) then: [ self verifyNeedsRefreshOrClose.        aBoolean ifTrue: [ (IceTipPushAction new repository: self model entity) execute ] ]-=JUAMPI=-isRepositoryDetached  ^self repositoryModel isNil or: [ self repositoryModel isDetached ]-=JUAMPI=-hash  ^commitish hash-=JUAMPI=-writerClass  ^self properties writerClass-=JUAMPI=-displayString  ^self entity name-=JUAMPI=-textForMergeable: mergeable  mergeable = true ifTrue: [ ^'Yes' ].  mergeable = false ifTrue: [ ^'There are conflicts' ].  ^mergeable asString-=JUAMPI=-ensureSourceCodeParentNodeIn: aNode  ^self ensureDirectoryAtPath: diff repository subdirectoryPath segments inNode: aNode-=JUAMPI=-visitNoRemote: anError  UIManager default alert: 'There are no remotes defined for this repository. Add one before continue.' title: 'Remote action failed'-=JUAMPI=-checkoutStrategy  ^checkoutStrategy-=JUAMPI=-execute  | repo cloneOptions checkoutOptions callbacks |  location exists ifTrue: [ IceCloneLocationAlreadyExists signalFor: location ].  [ location ensureCreateDirectory.  repo := LGitRepository on: location.  cloneOptions := LGitCloneOptions withCredentialsProvider: (IceCredentialsProvider defaultForRemoteUrl: url).  checkoutOptions := cloneOptions checkoutOptions.  callbacks := cloneOptions fetchOptions callbacks.  callbacks transferProgress: IceGitTransferProgress new.  checkoutOptions checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force.  checkoutOptions progressCallback: IceGitCheckoutProgress new.  repo clone: url options: cloneOptions.  (LGitRemote of: repo named: 'origin')     lookup;     setUrl: url ] on: LGitCallReturnHandler , IceWrongUrl do: [:error |  location exists ifTrue: [ location ensureDeleteAll ].        error acceptError: (IceLibgitErrorVisitor onContext: self) ]-=JUAMPI=-branchName: aString  branchName := aString-=JUAMPI=-execute  | selection |  selection := UIManager default request: 'Please provide the name of the new branch to be created' initialAnswer: '' title: 'Create new branch'.  selection isEmptyOrNil ifTrue: [ ^self ].  self repository createBranch: selection.  self beSuccess-=JUAMPI=-username: anObject  username := anObject-=JUAMPI=-iceVersion  ^commit versionFor: package-=JUAMPI=-location: aReferenceOrString  | ref |  ref := aReferenceOrString asFileReference.  keptLocation ifNotNil: [ | newRef |        newRef := (self location pathString copyReplaceAll: keptLocation pathString with: ref pathString) asFileReference.        keptLocation := ref.        ref := newRef ].  self basicLocation: ref-=JUAMPI=-username: aUsername project: aProject  path := aUsername , '/' , aProject-=JUAMPI=-choosen: anObject  choosen := anObject-=JUAMPI=-handlesMouseDown: evt  ^false-=JUAMPI=-isNewBranch  ^false-=JUAMPI=-model  ^model-=JUAMPI=-baseLabel  ^baseLabel-=JUAMPI=-showFilterFieldFromKeystrokeEvent: anEvent  | text |  text := anEvent keyCharacter asString.  self textField takeKeyboardFocus.  self textField text: self textField text , text.  self flag: #hack.  self textField textArea cursorEnd: anEvent-=JUAMPI=-isExtensionDefinition  ^true-=JUAMPI=-title  ^model isCurrent ifTrue: [ 'Current Iceberg credentials' ] ifFalse: [ 'Credentials of ' , model printString ]-=JUAMPI=-cancelAction  -=JUAMPI=-basicUrl: aString  url := aString-=JUAMPI=-package  ^package-=JUAMPI=-visitRemoval: anIceRemoval  anIceRemoval definition removeFrom: self-=JUAMPI=-publicKeyInput  ^publicKeyInput-=JUAMPI=-okAction  credentialStore storeCredential: self credentials forHostname: self host.  tool refresh-=JUAMPI=-initializeSourceDirectory  subdirectoryLabel := self newLabel label: 'Source directory'.  subdirectoryInputText := self newTextInput     ghostText: 'e.g., src';     autoAccept: true.  subdirectoryInputText text: self defaultSubdirectory-=JUAMPI=-packageName  ^package-=JUAMPI=-printOn: aStream  aStream nextPutAll: version asString-=JUAMPI=-isModified  ^self entity isModified-=JUAMPI=-remoteModels  ^self entity remotes collect: [:each |  (IceTipRemoteModel repositoryModel: self on: each) beCached ]-=JUAMPI=-hasLocalBraches  ^self localBranches isNotEmpty-=JUAMPI=-changesFromCommit: anIceCommit  ^(self modifiedPackages collect: [:each |  IceImageChange package: each ]) asArray , (self referenceCommit changesFromCommit: anIceCommit) asArray-=JUAMPI=-selectionHasActualClass  ^self selectedChangeWrapper ifNil: [ false ] ifNotNil: [:w |  w item value contextClass notNil ]-=JUAMPI=-showEmptyTab  emptyTab ifNil: [ emptyTab := self newEmptyTab ].  self removeAllCommitPanelTabs.  commitTabPanel addTab: emptyTab-=JUAMPI=-textField  ^textField-=JUAMPI=-versionLike: selectBlock ifNone: ifNoneBlock  ^self repository branch versionsFor: self detect: selectBlock ifNone: ifNoneBlock-=JUAMPI=-diff: anIceDiff  diff := anIceDiff-=JUAMPI=-includes: aRelativePath  ^modifiedFilePaths includes: aRelativePath-=JUAMPI=-initialize  super initialize.  isAnonymous := false-=JUAMPI=-isRemoval  ^true-=JUAMPI=-commit: anIceGitCommit  repository handleLibgitError: [ | localBranch gitcommit |        localBranch := self repositoryHandle lookupLocalBranch: self name.        gitcommit := self repositoryHandle revparse: anIceGitCommit id.        localBranch setTargetId: gitcommit id.        self = repository head ifTrue: [ self repositoryHandle checkout_treeish: gitcommit opts: (LGitCheckoutOptions defaults                       checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force;                       yourself) ] ]-=JUAMPI=-isMerged  ^mergeTree allSatisfy: [:operation |  operation isConflict not or: [ operation isResolved ] ]-=JUAMPI=-tree  ^self mergeTree-=JUAMPI=-definition  ^definition-=JUAMPI=-remoteBranchNamed: aString  ^self remoteBranchNamed: aString ifPresent: [:branch |  ^branch ] ifAbsent: [ IceBranchNotFound new           branchName: aString;           signal ]-=JUAMPI=-add: item  self selectedItems add: item.  self onSelectionChangedBlock ifNotNil: [:block |  block cull: item cull: true ]-=JUAMPI=-versionFor: anIcePackage  ^self commit versionFor: anIcePackage-=JUAMPI=-authorLabel  ^authorLabel-=JUAMPI=-execute  item ifNil: [ ^self ].  item entity inspect-=JUAMPI=-contextClass  ^IceTipCommitContext-=JUAMPI=-execute  self withErrorHandlingDo: [ self validateRemotesPresent.        (IceTipPullBrowser onRepositoryModel: self repositoryModel) openWithSpec ]-=JUAMPI=-remotes  ^entity remotes-=JUAMPI=-fetch  < noCache>  IceTipStandardAction new     repository: self entity;     message: ('Fetching incoming commits of {1}' format: {self name});     onSuccessRepositoryModified;     execute: [ self entity fetch ]-=JUAMPI=-actionPanel  ^actionPanel-=JUAMPI=-execute  browser accept-=JUAMPI=-addShortcutsTo: aWidget  self enableCommanderShortcutsIn: aWidget-=JUAMPI=-commitModels  ^(self entity branch incomingCommitsFrom: self remote) collect: [:each |  (IceTipCommitModel repositoryModel: self repositoryModel on: each) beCached ]-=JUAMPI=-isRootDefinition  ^true-=JUAMPI=-mouseEnter: evt  self flag: #bad.  ^self eventHandler ifNotNil: [ self eventHandler mouseEnter: evt fromMorph: self ]-=JUAMPI=-definition  ^definition-=JUAMPI=-badge: aNumber  badge := aNumber = 0 ifTrue: [ nil ] ifFalse: [ aNumber ]-=JUAMPI=-repositoryWillBeCreated: aRepository  -=JUAMPI=-onClick: aBlock  onClickBlock := aBlock-=JUAMPI=-icon  ^item value icon-=JUAMPI=-repoPath  ^self repository subdirectory-=JUAMPI=-initialize  super initialize.  name := ''-=JUAMPI=-subscribeToAnnouncements  self announcer when: IceTipDiffRefreshed send: #refreshWhenRepository: to: self-=JUAMPI=-copyWithOnly: aCollection  | treeCopy selectedOperations |  selectedOperations := aCollection collect: #value.  treeCopy := tree select: [:node |  selectedOperations includes: node ].  ^self class new     sourceVersion: source;     targetVersion: target;     diffTree: treeCopy;     yourself-=JUAMPI=-execute  UIManager default informUser: 'Refreshing pull request list' during: [ tool refreshPullRequests ]-=JUAMPI=-uptadeSelectedCommit: anEvent  self diff selectedModel: (anEvent newSelectedRowIndexes ifNotEmpty: [:indexes |  self commits widget dataSource elementAt: indexes first ] ifEmpty: [ nil ])-=JUAMPI=-announcer  ^announcer ifNotNil: #contents-=JUAMPI=-validateMessageNotEmpty  self message ifEmpty: [ IceNoCommitMessage signal ]-=JUAMPI=-execute  UIManager default informUser: 'Reverting change...' during: [ self repositoryModel entity workingCopy discardChanges: item ].  self announcer announce: (IceTipDiffEntryRemoved entry: item).  Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity)-=JUAMPI=-removeFrom: aPatcher  aPatcher removeClass: self-=JUAMPI=-parent  ^parent-=JUAMPI=-accept  ^self doCommit-=JUAMPI=-snapshotFor: anIceSavedPackage  ^MCSnapshot empty-=JUAMPI=-tagNameLabel  ^tagNameLabel-=JUAMPI=-accept: aVisitor  ^aVisitor visitMethodNode: self-=JUAMPI=-isWorkingCopy  ^false-=JUAMPI=-remoteName: aString  remoteName := aString-=JUAMPI=-iconNamed: aSymbol  ^self class iconNamed: aSymbol-=JUAMPI=-mergeWith: anotherNode onLeft: leftBlock onRight: rightBlock onMerge: mergeBlock  ^anotherNode collect: rightBlock-=JUAMPI=-visitTreeNode: anIceNode  self withNode: anIceNode do: [ anIceNode value accept: self ]-=JUAMPI=-commit  ^self entity-=JUAMPI=-rootItem: anItem  super rootItem: anItem.  self addSourceToRootItem-=JUAMPI=-nameInput  ^nameInput-=JUAMPI=-createBranch: aString inCommit: anIceGitCommit  self handleLibgitError: [ (self repositoryHandle isUnborn and: [ anIceGitCommit isNoCommit ]) ifTrue: [ ^self createBranch: aString ].        self repositoryHandle createBranch: aString targetId: (LGitId fromHexString: anIceGitCommit gitRef) force: false.        ^(self branchNamed: aString)           switch;           yourself ]-=JUAMPI=-incomingCommits  ^#()-=JUAMPI=-mergeWithMasterCheckbox: anObject  mergeWithMasterCheckbox := anObject-=JUAMPI=-iconNamed: aSymbol  ^Smalltalk ui icons iconNamed: aSymbol-=JUAMPI=-execute  ^IceGitHubRemoveBranchesAction new     repository: self repository;     remote: self remote;     execute-=JUAMPI=-removeFromPatcher: aMCPatcher  self subclassResponsibility-=JUAMPI=-version: anObject  version := anObject-=JUAMPI=-backend: anObject  backend := anObject-=JUAMPI=-title: anObject  title := anObject-=JUAMPI=-iconForMergeable: mergeable  mergeable = true ifTrue: [ ^self iconNamed: #smallOk ].  ^self iconNamed: #smallCancel-=JUAMPI=-checkForRegistryConflicts  self subclassResponsibility-=JUAMPI=-newRootCellFor: item  | cell |  cell := IceTipOutlineHeaderCellMorph dataSource: self item: item.  (self iconFor: item data) ifNotNil: [:icon |  cell addMorphBack: icon asMorph ].  cell addMorphBack: (self toString: item data) asMorph asReadOnlyMorph.  cell addMorphBack: (AlignmentMorph newSpacer: Color transparent).  cell addMorphBack: item children size asMorph asReadOnlyMorph.  cell addMorphBack: (Morph newBounds: (0 @ 0 corner: 20 @ 0) color: Color transparent) asReadOnlyMorph.  ^cell-=JUAMPI=-doAccept  self validate.  commitishToTag createTag: self tagName thenDo: [:newBranch |  callback ifNotNil: [ callback value: newBranch ] ]-=JUAMPI=-initializeCommitsTable  | textStylingBlock |  textStylingBlock := [:string :commit |  commit isMerged ifTrue: [ string asText ] ifFalse: [ string asText allBold ] ].  commits widget     beResizable;     addColumn: (IceTipTableColumn id: 'Date & time' action: [:commit |  textStylingBlock value: commit datetime asLocalStringYMDHM value: commit ] width: 120 * World displayScaleFactor);     addColumn: (IceTipTableColumn id: 'Id' action: [:commit |  textStylingBlock value: commit shortId value: commit ] width: 50 * World displayScaleFactor);     addColumn: (IceTipTableColumn id: 'Author' action: [:commit |  textStylingBlock value: commit author value: commit ] width: 120 * World displayScaleFactor);     addColumn: (IceTipTableColumn id: 'Comment' action: [:commit |  textStylingBlock value: commit comment value: commit ] width: 300 * World displayScaleFactor);     dataSource: self newCommitsDataSource;     selectRowIndex: 1-=JUAMPI=-delete  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Removing branch {1}' format: {self name});     onSuccessRepositoryModified;     execute: [ self entity delete ]-=JUAMPI=-visitRemoval: anIceRemoval  anIceRemoval definition removeFrom: self.  self visitChildrenOf: currentNode-=JUAMPI=-nextChildNodeStartingFrom: anIceNode suchThat: conditionBlock ifNone: noneBlock  | aCollection |  aCollection := self children.  (aCollection indexOf: anIceNode) + 1 to: aCollection size do: [:index |  | item |        item := aCollection at: index.        (conditionBlock value: item) ifTrue: [ ^item ].        item nextNodeSuchThat: conditionBlock ifFound: [:found |  ^found ] ].  self parent ifNil: [ ^noneBlock value ].  ^self parent nextChildNodeStartingFrom: self suchThat: conditionBlock ifNone: noneBlock-=JUAMPI=-checkout: aCheckoutStrategy  aCheckoutStrategy committish: self.  ^repository checkout: aCheckoutStrategy-=JUAMPI=-actionPanel: anObject  actionPanel := anObject-=JUAMPI=-contents  ^''-=JUAMPI=-addRemoteNamed: aName url: anUrl  IceTipStandardAction new     repository: self entity;     message: 'Adding remote';     onSuccessRepositoryModified;     execute: [ | remote |        remote := IceGitRemote name: aName url: anUrl.        self entity addRemote: remote.        remote fetch ]-=JUAMPI=-publicKey  ^publicKey ifNil: [ publicKey := self class defaultPublicKey ]-=JUAMPI=-referencesSameRemoteLocationAs: aRemote  ^(super referencesSameRemoteLocationAs: aRemote) or: [ self httpsUrl = aRemote httpsUrl ]-=JUAMPI=-properties  ^properties ifNil: [ properties := Dictionary new ]-=JUAMPI=-cellColumn: column row: rowIndex  ^FTCellMorph new     addMorphBack: ((self elementAt: rowIndex) at: column id) asStringMorph;     yourself-=JUAMPI=-hasUnknownCommit  ^self workingCopyState isUnknownCommitState-=JUAMPI=-mergeWithLeftModification: anIceModification  ^IceConflictingOperation left: anIceModification right: self-=JUAMPI=-readContextParametersFromModel: aModel  self repositoryModel: aModel repositoryModel-=JUAMPI=-codeDirectory  self repositoryDirectory exists ifTrue: [ ^self basicCodeDirectory ] ifFalse: [ IceLocalRepositoryMissing signalFor: self ]-=JUAMPI=-addLabel: aString value: anObject  items at: aString put: anObject.  self refresh-=JUAMPI=-initializeWithJSON: aDictionary  json := aDictionary.  self initialize-=JUAMPI=-title  ^'Pull {1}/{2} from {3}' format: {self model repositoryName .         self model branchName .         self model remoteName}-=JUAMPI=-hasTagNamed: aString  self subclassResponsibility-=JUAMPI=-okAction  self credentials     username: self username;     password: self password.  credentialStore storeCredential: self credentials.  tool refresh-=JUAMPI=-packageNameFromPackageDirectory  ^iceVersion packageName-=JUAMPI=-pullFrom: aRemote  | remoteBranch |  repository fetch.  remoteBranch := aRemote remoteBranchNamed: self name ifAbsent: [ ^self ].  repository createBranch: self name inCommit: remoteBranch commit-=JUAMPI=-isNoCommit  ^true-=JUAMPI=-createRepository: aRepositorySpec  (self canHandleType: aRepositorySpec type) ifTrue: [ ^Iceberg mcRepositoryFor: aRepositorySpec description ].  ^super createRepository: aRepositorySpec-=JUAMPI=-writeInDirectoryName: directoryNameOrPath fileName: fileName extension: ext visit: visitBlock  | directory |  directory := self directoryForDirectoryNamed: directoryNameOrPath.  self fileUtils writeStreamFor: fileName , ext in: directory do: [:fs |  self setFileStream: fs.        visitBlock value ]-=JUAMPI=-max: anInteger  max := anInteger-=JUAMPI=-isRightChosen  ^chosen = operation inverse-=JUAMPI=-shortDescriptionWithDecoration  ^self addDecorationTo: (self entity isRemote ifTrue: [ self name copyAfter: $/ ] ifFalse: [ self name ])-=JUAMPI=-initializeCommitPanel  commitTabPanel     addTab: (infoTab := self newInfoTab);     addTab: (diffTab := self newDiffTab           label: 'Diff from ancestor';           whenTabSelected: [ self refreshDiff ];           yourself)-=JUAMPI=-iceCommitFrom: aLGitCommit  ^self repository iceCommitFrom: aLGitCommit-=JUAMPI=-printOn: aStream  aStream     print: self class;     nextPut: $(;     nextPutAll: self package name.  aStream nextPut: $)-=JUAMPI=-passphrase  ^passphraseInput text-=JUAMPI=-block  ^[:path :completed :total :payload |  job ensureStarted.  job min: 0.  job max: total.  job current: completed.  job title: ('Checking out... ({1}/{2})' format: {completed .               total}).  job changed ]-=JUAMPI=-readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  tool := aToolContext tool-=JUAMPI=-