format  ^format-=JUAMPI=-load  self repository workingCopy loadPackageNamed: self name-=JUAMPI=-obtainAvailableRemotes  | tmp1 |  tmp1 := self repository remotes.  (tmp1 includes: self baseRemote) ifFalse: [ tmp1 := tmp1 copyWith: self baseRemote ].  ^tmp1-=JUAMPI=-mergeBaseBetween: arg1 and: arg2  self handleLibgitError: [ ^(self repositoryHandle mergeBaseBetween: (LGitId fromHexString: arg1) and: (LGitId fromHexString: arg2)) hexString ]-=JUAMPI=-timeStamp  ^self datetime-=JUAMPI=-baseLabel  ^'No PR selected'-=JUAMPI=-projectName  ^projectName-=JUAMPI=-isFastForward  ^self headCommit isAncestorOf: mergeCommit-=JUAMPI=-basicExecute  self fetchAllRemotes.  (IceTipPullBrowser onRepositoryModel: self repositoryModel) openWithSpec-=JUAMPI=-sortingStrategyFirst: arg1  self sortingStrategy first: arg1-=JUAMPI=-initializeChangeList  | tmp1 |  tmp1 := self newChangeTreeDataSource.  changeList widget dataSource: tmp1.  tmp1 expandAll-=JUAMPI=-changesFromCommit: arg1  ^arg1 changesFromNoCommit: self-=JUAMPI=-remoteFileReferenceInPath: arg1  -=JUAMPI=-issueLabel: arg1  issueLabel := arg1-=JUAMPI=-initializeWidgets  self initializeProjectLocation.  self initializeSpacePanel-=JUAMPI=-workingCopy  ^repository workingCopy-=JUAMPI=-createCommandContextForSelection: arg1  ^self newContextWithSelection: arg1-=JUAMPI=-fetchFrom: arg1  arg1 fetch-=JUAMPI=-position: arg1  position := arg1-=JUAMPI=-allBranchModels  ^self entity allBranches collect: [:arg1 |  (IceTipBranchModel repositoryModel: self on: arg1) beCached ]-=JUAMPI=-tags  ^self commit tags-=JUAMPI=-datetime  ^datetime-=JUAMPI=-repositoryName  ^self repositoryModel name-=JUAMPI=-customError: arg1  ^arg1 at: #message-=JUAMPI=-removeFrom: arg1  arg1 removeSSHCredential: self-=JUAMPI=-packageModels  ^self sortingStrategy sort: (self repositoryModel entity workingCopy packages collect: [:arg1 |  (IceTipPackageModel repositoryModel: self repositoryModel on: arg1) beCached ])-=JUAMPI=-remote: arg1  remote := arg1-=JUAMPI=-privateKey: arg1  privateKey := arg1.  self storeIfDefault-=JUAMPI=-fileNameForMethod: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self repository subdirectory ifNotEmpty: [:arg2 |  tmp1 add: arg2 ].  tmp1 add: (self tonelPackageName: arg1 package).  tmp1 add: (self tonelMethodClassOrTraitName: arg1).  ^String streamContents: [:arg3 |  tmp1 asStringOn: arg3 delimiter: '/' ]-=JUAMPI=-longStatus  (entity isMissing and: [ entity location isNil ]) ifTrue: [ ^'Iceberg does not find a git repository. Please clone the repository or change the repository location to an existing Git repository' ].  entity isMissing ifTrue: [ ^'Iceberg does not find a git repository at {1}. Please clone the repository again or change the repository location to an existing Git repository' format: {entity location} ].  entity workingCopy workingCopyState isUnknownCommitState ifTrue: [ ^'This image has a loaded version of the code from commit {1}, but Iceberg does not find the commit in your local Git repository. You may fetch the correct commit from a remote repository or discard the code of your image and load the version that is in the repository.' format: {entity workingCopy referenceCommit shortId} ].  entity workingCopy isDetached ifTrue: [ ^'The loaded code in the image starts from commit {1}. This commit does not correspond with the commit in the head of the current branch of the repository (Commit {2}). You need to synchronize them to continue. You need to discard your image changes or change the HEAD of the repository to point to the commit.' format: {entity workingCopy referenceCommit shortId .               entity headCommit shortId} ].  entity head isDetached ifTrue: [ ^'The repository and the image are in the same commit {1}. However, the commit is not in an active branch. It is not possible to commit in a Git detached HEAD state. Create a new branch (by checkouting) or checkout an existing one.' format: {entity headCommit shortId} ].  entity workingCopy project isUnborn ifTrue: [ ^'Cannot find a project (meta-data and source directory) in your repository. Please edit your repository meta-data to indicate the source code directory or change the location to a valid iceberg repository' ].  ^'Your repository seems ok. Please report a ticket in Iceberg''s issue tracker. If you can, please send us a backup of your image in this state for debugging.'-=JUAMPI=-keysDo: arg1  childrenDictionary keysDo: arg1-=JUAMPI=-issueLabel  ^issueLabel-=JUAMPI=-execute  self packageModel remove-=JUAMPI=-headCommit  ^self head commit-=JUAMPI=-push  -=JUAMPI=-snapshotFor: arg1  ^(self versionFor: arg1) snapshot-=JUAMPI=-asBornProperties  ^IceRepositoryProperties fromDictionary: properties commitish: commitish-=JUAMPI=-selectedChange  ^(self selectedChangeWrapper ifNil: [ ^nil ]) item value-=JUAMPI=-request: arg1  request := arg1-=JUAMPI=-diffToReferenceCommit  ^self diffTo: self referenceCommit-=JUAMPI=-url  ^url-=JUAMPI=-selectRemoteNamed: arg1  remoteList setSelectedItem: (self model remoteModels detect: [:arg2 |  arg2 name = arg1 ])-=JUAMPI=-table: arg1  super table: arg1.  self addBindingsToTable-=JUAMPI=-selectNextConflict  | tmp1 |  tmp1 := self nextConflict ifNil: [ ^self ].  self changed: {#openPath} , tmp1 item path segments-=JUAMPI=-item  ^self packageModel-=JUAMPI=-descriptionWithDecoration  ^self name asText-=JUAMPI=-isLocal  ^self entity isLocal-=JUAMPI=-cellColumn: arg1 row: arg2  ^self newCellFor: (self elementAt: arg2)-=JUAMPI=-refreshWhenRepository: arg1  (arg1 repository isNil or: [ self model repositoryModel isModelOf: arg1 repository ]) ifFalse: [ ^self ].  self model reset.  self refresh-=JUAMPI=-visitPackage: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := MCPackage named: arg1 name.  tmp2 := [ diff targetVersion snapshotFor: arg1 ] on: NotFound do: [ MCSnapshot empty ].  tmp3 := MCPatcher snapshot: tmp2.  currentNode accept: (IceMCSnapshotPatchVisitor new           patcher: tmp3;           yourself).  tmp4 := MCVersion new setPackage: tmp1 info: (IceMCVersionInfo package: tmp1 message: 'Internal...') snapshot: tmp3 patchedSnapshot dependencies: #().  index storeVersion: tmp4-=JUAMPI=-child  ^IceGitChange on: (RelativePath withAll: self path segments allButFirst) pathString-=JUAMPI=-defaultMenuItemName  ^'Open on github'-=JUAMPI=-versionsFor: arg1  ^self commit versionsFor: arg1-=JUAMPI=-newContextWithSelection: arg1  ^self newContext     item: arg1;     yourself-=JUAMPI=-refreshDirtyPackages  self markAsCleanPackagesNotInDiff: self repository workingCopyDiff-=JUAMPI=-remotes  self handleLibgitError: [ | tmp1 |        self isValid ifFalse: [ ^#() ].        tmp1 := self repositoryHandle allRemotes.        ^tmp1 collect: [:arg1 |  (IceGitRemote name: arg1 remoteName url: arg1 url)                 localRepository: self;                 yourself ] ]-=JUAMPI=-commit  ^self-=JUAMPI=-isClassDefinition  ^false-=JUAMPI=-execute  self subclassResponsibility-=JUAMPI=-repositoryList  ^repositoryList-=JUAMPI=-mergeWithBranch: arg1  self subclassResponsibility-=JUAMPI=-entryName  ^entryName-=JUAMPI=-response  ^response-=JUAMPI=-actualClass  ^self contextClass-=JUAMPI=-value  ^list includes: item-=JUAMPI=-typeList: arg1  typeList := arg1-=JUAMPI=-repository  ^commitish repository-=JUAMPI=-packages  tree isEmpty ifTrue: [ ^#() ].  ^self codeSubdirectoryNode children-=JUAMPI=-select: arg1  ^self-=JUAMPI=-basicNewRemoteBranchNamed: arg1  ^IceGitRemoteBranch named: arg1 inRepository: self-=JUAMPI=-gitRef  ^((repository location / '.git' / 'HEAD') contents withoutPrefix: 'ref: ') trimBoth-=JUAMPI=-initializeWidgets  super initializeWidgets.  repositoryList := self newIceTable.  repositoryList widget onAnnouncement: FTStrongSelectionChanged send: #repositoryStrongSelection: to: self.  self initializeRepositoryList.  self focusOrder add: repositoryList-=JUAMPI=-push  self branch push-=JUAMPI=-optionsList  ^optionsList-=JUAMPI=-nameLabel: arg1  nameLabel := arg1-=JUAMPI=-id: arg1  id := arg1-=JUAMPI=-invalidError: arg1  ^'Invalid field: ' , (arg1 at: #field)-=JUAMPI=-children  ^#()-=JUAMPI=-classIsMeta: arg1  classIsMeta := arg1-=JUAMPI=-changesFromCommit: arg1  self assert: arg1 isNoCommit.  ^#()-=JUAMPI=-sourceDirectory  ^self repository project sourceDirectory-=JUAMPI=-packageNameFromPackageDirectory  ^iceVersion packageName-=JUAMPI=-toText: arg1  toText := arg1-=JUAMPI=-tags  self subclassResponsibility-=JUAMPI=-contextClass  ^IceTipBranchContext-=JUAMPI=-fetchPullRequests  ^(IceGitHubAPI new getPullRequests: self remote owner project: self remote projectName) all collect: [:arg1 |  (IceGitHubPullRequest fromJSON: arg1)           repository: self repository entity;           yourself ]-=JUAMPI=-messageText  ^'There is no version for package: {1} in  commit {2}' format: {self version packageName .         self version commit id}-=JUAMPI=-shortName  ^self name copyAfter: $/-=JUAMPI=-remoteUrl: arg1  remoteUrl := arg1-=JUAMPI=-visitNonConflictingOperation: arg1  arg1 chosenOperation accept: self-=JUAMPI=-withoutNewBranch  types := self allTypes reject: #isNewBranch.  typeList widget dataSource elements: types.  typeList widget refresh-=JUAMPI=-hasSingleCommit  ^self workingCopyState isSingleCommitState-=JUAMPI=-repositoryProperties  ^properties-=JUAMPI=-repository  ^repository-=JUAMPI=-initialize  super initialize.  childrenDictionary := Dictionary new-=JUAMPI=-mergeThen: arg1  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Merging branch {1} from {2}' format: {self name .               self repositoryName});     onSuccessRepositoryModified;     onSuccess: arg1;     execute: [ self entity merge ]-=JUAMPI=-includesPackageNamed: arg1  ^false-=JUAMPI=-acceptError: arg1  arg1 visitShouldCommitBeforePullError: self-=JUAMPI=-reset  UIManager default informUser: 'Refreshing changes' during: [ self resetDiff.        self diff ]-=JUAMPI=-initializeExistingTagsList  existingTagsList := self newList.  existingTagsList     items: commitishToTag tagModels;     displayBlock: #name;     sortingBlock: #name descending-=JUAMPI=-canBrowseReferences  ^self canBeBrowsed-=JUAMPI=-help  ^self commandClass defaultHelp-=JUAMPI=-printOn: arg1  arg1     nextPutAll: self class name;     nextPutAll: '(';     nextPutAll: self name;     nextPutAll: ')'-=JUAMPI=-package  ^package-=JUAMPI=-model: arg1  model := arg1.  self allTypes do: [:arg2 |  arg2 model: arg1 ]-=JUAMPI=-mergeIntoWorkingCopy  self repository     ensureBranch: self branchName;     checkoutBranch: self branchName.  self branch merge-=JUAMPI=-visitAuthenticationError: arg1  UIManager default alert: arg1 messageText title: 'Iceberg authentication Error'-=JUAMPI=-initializeWidgets  iconPanel := self newIcePanel.  iconPanel widget addMorph: ((self iconNamed: #error) scaledToSize: 32 @ 32) asMorph.  errorLabel := self newIceReadOnlyText.  errorLabel widget contentsWrapped: exception messageText.  errorLabel widget     hResizing: #spaceFill;     vResizing: #spaceFill-=JUAMPI=-createCheckboxFor: arg1  ^CheckboxMorph on: (IceGitHubSelectItem list: selectedItems item: arg1) selected: #value changeSelected: #value:-=JUAMPI=-subscribeToAnnouncements  Iceberg announcer weak when: IceRepositoryAnnouncement send: #refreshWhenRepository: to: self-=JUAMPI=-ensureDefaultProperties  properties at: #format ifAbsentPut: [ self writerClass id ]-=JUAMPI=-labelFor: arg1  ^'HEAD to {1}' format: {(arg1 ifNotNil: #shortId)}-=JUAMPI=-changeList: arg1  changeList := arg1-=JUAMPI=-checkoutWithStrategy: arg1  repository checkout: (arg1 commitish: self)-=JUAMPI=-hash  ^self commit hash-=JUAMPI=-contentsWithValidationDo: arg1  ^(self responseWithValidationDo: arg1) contents-=JUAMPI=-icon  ^self iconNamed: #changeRemove-=JUAMPI=-nextNodeSuchThat: arg1 ifNone: arg2  self children do: [:arg3 |  (arg1 value: arg3) ifTrue: [ ^arg3 ].        arg3 nextNodeSuchThat: arg1 ifFound: [:arg4 |  ^arg4 ] ].  ^self parent nextChildNodeStartingFrom: self suchThat: arg1 ifNone: arg2-=JUAMPI=-selectRemoteModel  ^selectRemoteModel ifNil: [ selectRemoteModel := IceTipRemoteActionModel repositoryModel: self model on: self model entity ]-=JUAMPI=-contents  ^self basicAt: 1-=JUAMPI=-basicExecute  IceTipRegisterRepositoryDialog new     beForCloneOfRepository: self repositoryModel entity;     onAccept: [ Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity) ];     openDialogWithSpec-=JUAMPI=-onSuccessAnnounce: arg1  successAnnounceBlock := arg1-=JUAMPI=-repository  ^repository-=JUAMPI=-fileUtils  ^IceLibgitFiletreeFileUtils-=JUAMPI=-comment  ^self entity comment-=JUAMPI=-mergeWithLeftRemoval: arg1  ^IceConflictingOperation left: arg1 right: self-=JUAMPI=-keys  ^childrenDictionary keys-=JUAMPI=-definition  ^operation definition-=JUAMPI=-onAccept: arg1  acceptBlock := arg1-=JUAMPI=-sourceCode: arg1  sourceCode := arg1-=JUAMPI=-hasAnyNonConflictConflicts  ^self model mergeTree anySatisfy: [:arg1 |  arg1 isConflict and: [ arg1 isResolved ] ]-=JUAMPI=-model  ^model-=JUAMPI=-delete  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Removing remote {1}' format: {self name});     onSuccessRepositoryModified;     do: [ self repositoryModel entity removeRemote: self entity ]-=JUAMPI=-credentials: arg1  credential := arg1.  self usernameInput text: credential username.  self passwordInput text: credential password-=JUAMPI=-writerClass  ^self commit writerClass-=JUAMPI=-badgeSelector: arg1  badgeSelector := arg1-=JUAMPI=-free  (handle isNil or: [ handle isNull ]) ifFalse: [ handle free.        handle := nil ]-=JUAMPI=-referencesSameRemoteLocationAs: arg1  ^(super referencesSameRemoteLocationAs: arg1) or: [ (self url withoutSuffix: '.git') sameAs: (arg1 httpsUrl withoutSuffix: '.git') ]-=JUAMPI=-readProjectFromCommitish: arg1  self subclassResponsibility-=JUAMPI=-cellColumn: arg1 row: arg2  | tmp1 |  tmp1 := self elementAt: arg2.  ^tmp1 depth = 0 ifTrue: [ self newRootCellFor: tmp1 ] ifFalse: [ self newCellFor: tmp1 ]-=JUAMPI=-execute  item copyCommitIDToClipboard-=JUAMPI=-upstreamForBranch: arg1 backend: arg2  ^arg2 lookupBranchNamed: arg1 name inRemote: self remoteName-=JUAMPI=-hash  ^self name hash-=JUAMPI=-contextClass  ^leftOperation contextClass-=JUAMPI=-basepathOf: arg1  self subclassResponsibility-=JUAMPI=-initializeBlock  self signature: self class fnSpec block: self block-=JUAMPI=-repositoryModel: arg1  repositoryModel := arg1-=JUAMPI=-readParametersFromContext: arg1  super readParametersFromContext: arg1.  item := arg1 item-=JUAMPI=-menuSelectionContext  ^self tool newContext-=JUAMPI=-initializePresenter  super initializePresenter.  self commits widget onAnnouncement: FTSelectionChanged send: #uptadeSelectedCommit: to: self.  mergeButton action: [ self mergePullRequestIntoImage ].  acceptButton action: [ self acceptPullRequest ].  rejectButton action: [ self rejectPullRequest ]-=JUAMPI=-version: arg1  version := arg1-=JUAMPI=-description  ^self class description-=JUAMPI=-diff  ^diff-=JUAMPI=-statusPanel  ^statusPanel-=JUAMPI=-initializeEntity: arg1  entity := arg1.  self initialize-=JUAMPI=-validateCanCommit  self isDetached ifTrue: [ IceWorkingCopyDesyncronized signal ]-=JUAMPI=-fromCommit: arg1 package: arg2  commit := arg1.  package := arg2.  date := commit datetime asDate.  time := commit datetime asTime.  name := '{1}-{2}.{3}' format: {package name .         commit compatibleUsername .         commit datetime asUnixTime}.  id := self class uuidFromCommit: arg1 package: arg2.  message := commit comment.  author := commit compatibleUsername-=JUAMPI=-location: arg1  ^self projectLocation location: arg1-=JUAMPI=-commitModels  | tmp1 |  tmp1 := OrderedCollection new.  self entity commitsDo: [:arg1 |  tmp1 add: (IceTipCommitModel repositoryModel: self repositoryModel on: arg1) beCached ].  ^tmp1-=JUAMPI=-repositoryName  ^self repository name-=JUAMPI=-actionPanel  ^actionPanel-=JUAMPI=-tagNameInputText  ^tagNameInputText-=JUAMPI=-name  ^name-=JUAMPI=-initializeDialogWindow: arg1  super initializeDialogWindow: arg1.  acceptButton     disable;     label: 'Add'-=JUAMPI=-leftContents  ^definition contents-=JUAMPI=-execute  self withErrorHandlingDo: [ self basicExecute.        self finishSuccess ]-=JUAMPI=-newCredentialsDataSource  ^IceTipDataSource new     tool: self;     elements: self model allCredentials;     yourself-=JUAMPI=-password: arg1  password := arg1-=JUAMPI=-toLabel  ^toLabel-=JUAMPI=-item  ^item-=JUAMPI=-visitRemoval: arg1  arg1 definition removeFromPatcher: patcher.  self visitChildrenOf: currentNode-=JUAMPI=-projectVersion  ^projectVersion-=JUAMPI=-validateAlreadyPresentAndNotGit  (self remoteToUse isNil and: [ self location notNil and: [ self location exists and: [ (self class isGitRoot: self location) not ] ] ]) ifTrue: [ IceError signal: ('"{1}" is not a git directory' format: {self location fullName}) ]-=JUAMPI=-initializeWidgets  super initializeWidgets.  commitList := self newIceTable.  commitTabPanel := self newTabManager.  self initializeCommitList.  self initializeCommitPanel.  commitList widget onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self.  self focusOrder     add: commitList;     add: commitTabPanel.  self refresh-=JUAMPI=-refresh  self model reset.  self resetDiffContents.  changeList widget     in: [:arg1 |  arg1 basicSelectIndexes: #().        arg1 dataSource           rootForItems: self model treeRoots;           selectAll;           expandAll ];     refresh-=JUAMPI=-merge: arg1 into: arg2  ^arg1 collectWithPath: [:arg3 :arg4 |  arg2 resolve: arg4 ifPresent: [:arg5 |  arg3 mergeWithOperation: arg5 ] ifAbsent: [ IceNonConflictingOperation operation: arg3 ] ]-=JUAMPI=-execute  store removeCredential: credential.  tool refresh-=JUAMPI=-isParentOf: arg1  ^self newCommitWalk includesCommit: arg1-=JUAMPI=-open  self openNonModal modalRelativeTo: World.  ^self credentials-=JUAMPI=-title: arg1  title := arg1-=JUAMPI=-currentCommitishLabel  ^currentCommitishLabel-=JUAMPI=-refresh  commitButton help: ('Commit your changes to {1}' format: {self repositoryName}).  pushCheckbox label: ('Push changes to {1}' format: {self repositoryRemoteName})-=JUAMPI=-sshCredentials  ^IceCredentialStore current sshCredentialForHostname: remote host-=JUAMPI=-= arg1  ^self fullname = arg1 fullname-=JUAMPI=-ancestors  ^self commit ancestors-=JUAMPI=-packageNameText  ^packageNameText-=JUAMPI=-announcer  ^announcer ifNotNil: #contents-=JUAMPI=-initialExtent  ^(500 @ (self class inputTextHeight * 5 + self class buttonHeight + 50)) scaledByDisplayScaleFactor-=JUAMPI=-icon  self subclassResponsibility-=JUAMPI=-peelTag: arg1  self subclassResponsibility-=JUAMPI=-contents  ^self isBinary ifTrue: [ String streamContents: [:arg1 |  contents hexDumpOn: arg1 max: Float infinity ] ] ifFalse: [ contents utf8Decoded ]-=JUAMPI=-writeMethodProperties: arg1  self shouldNotImplement-=JUAMPI=-credential  ^credential-=JUAMPI=-remove  repository workingCopy basicRemovePackage: self-=JUAMPI=-projectNameLabel  ^projectNameLabel-=JUAMPI=-initializeWidgets  super initializeWidgets.  packageList := self newIceTable.  statusBar := self instantiate: IceTipStatusBar.  self initializePackageList.  self initializeStatusBar.  self focusOrder add: packageList-=JUAMPI=-checkoutOn: arg1  arg1 loadPackagesNamed: committish packageNames fromCommit: committish commit.  self repository setHead: committish.  arg1 referenceCommit: committish commit.  arg1 markAllPackagesAsClean-=JUAMPI=-outgoingCommits  ^self entity outgoingCommits-=JUAMPI=-isConflict  ^true-=JUAMPI=-description  ^self name-=JUAMPI=-mergeInto: arg1  -=JUAMPI=-previewCheckout  < noCache>  (IceTipCheckoutPreviewBrowser onBranch: self) openWithSpec-=JUAMPI=-oldNode: arg1  oldNode := arg1-=JUAMPI=-resolve: arg1 ifAbsent: arg2  ^self resolve: arg1 ifPresent: [:arg3 |  arg3 ] ifAbsent: arg2-=JUAMPI=-hash  ^self item hash-=JUAMPI=-commit: arg1  commit := arg1-=JUAMPI=-selectedBranch  | tmp1 |  tmp1 := self branchesList widget selectedIndex.  ^tmp1 ~= 0 ifTrue: [ self branchesList widget dataSource elementAt: tmp1 ] ifFalse: [ nil ]-=JUAMPI=-initializePullRequestsTable  pullRequests widget     beResizable;     addColumn: (IceTipTableColumn new           id: '#';           action: [:arg1 |  arg1 number asString ];           width: 50 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'State';           action: #state;           width: 50 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Author';           action: #author;           width: 120 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Title';           action: #title;           yourself);     dataSource: self newPullRequestsDataSource-=JUAMPI=-datetime  ^self commit datetime-=JUAMPI=-copyToClipboardId: arg1  Clipboard clipboardText: arg1 informing: ('Commitish ID copied to clipboard ({1})' format: {arg1})-=JUAMPI=-contents  ^contents-=JUAMPI=-readParametersFromContext: arg1  super readParametersFromContext: arg1.  (self repositoryModel isNotNil and: [ self repositoryModel isMissing not ]) ifTrue: [ self badge: self repositoryModel numberOfIncomingCommits ]-=JUAMPI=-readParametersFromContext: arg1  super readParametersFromContext: arg1.  selectedCommitish := arg1 item.  selectedBranch := arg1 selectedBranch-=JUAMPI=-tonelClassExtension: arg1  arg1 isTrait ifTrue: [ ^'.trait' ].  ^'.class'-=JUAMPI=-isOkEnabled  ^self username isNotEmpty and: [ self password isNotEmpty ]-=JUAMPI=-onAccept: arg1  acceptBlock := arg1-=JUAMPI=-remoteName  ^self remote name , '/' , self entity branch name-=JUAMPI=-commitWithMessage: arg1  ^self workingCopy commitWithMessage: arg1-=JUAMPI=-logClass  ^IceLog allSubclasses detect: [:arg1 |  arg1 isAvailableFor: self ]-=JUAMPI=-protocolDropList: arg1  protocolDropList := arg1-=JUAMPI=-commits  ^commits-=JUAMPI=-diffToWorkingCopy  ^self diffTo: self repository workingCopy-=JUAMPI=-validateChangeListNotEmpty  items ifEmpty: [ IceNothingToCommit signal ]-=JUAMPI=-version: arg1  version := arg1-=JUAMPI=-isRemoval  ^false-=JUAMPI=-hasAnyNonIncomingConflicts  ^self model mergeTree anySatisfy: [:arg1 |  arg1 isConflict and: [ arg1 isResolved not or: [ arg1 isLeftChosen ] ] ]-=JUAMPI=-forceCalculateDirtyPackages  | tmp1 |  tmp1 := IceDiff new     sourceVersion: self;     targetVersion: self referenceCommit;     buildFull.  self loadedPackages do: [:arg1 |  arg1 beDirty: (tmp1 includesPackageNamed: arg1 name) ]-=JUAMPI=-initialize  super initialize.  categories := #()-=JUAMPI=-workingCopy  ^self repository workingCopy-=JUAMPI=-nextNodeSuchThat: arg1 ifFound: arg2  self children do: [:arg3 |  (arg1 value: arg3) ifTrue: [ ^arg2 value: arg3 ].        arg3 nextNodeSuchThat: arg1 ifFound: [:arg4 |  ^arg2 value: arg4 ] ]-=JUAMPI=-mergeWithOperation: arg1  ^arg1 mergeWithLeftAddition: self-=JUAMPI=-extent  ^self subclassResponsibility-=JUAMPI=-title  ^'New tag of ' , commitishToTag name-=JUAMPI=-matches: arg1  ^arg1 name asLowercase includesSubstring: self pattern asLowercase-=JUAMPI=-commitModels  | tmp1 |  tmp1 := OrderedCollection new.  self entity commitsDo: [:arg1 |  tmp1 add: (IceTipCommitModel repositoryModel: self repositoryModel on: arg1) beCached ].  ^tmp1-=JUAMPI=-selectionChanged: arg1  | tmp1 |  (arg1 newSelectedIndexes reject: [:arg2 |  arg2 = 0 ]) ifNotEmpty: [:arg3 |  tmp1 := changeList widget dataSource realElementAt: arg3 first.        self diffContentsLeft: tmp1 value rightContents right: tmp1 value leftContents ] ifEmpty: [ self resetDiffContents ]-=JUAMPI=-initializeMajor: arg1 minor: arg2 patch: arg3  major := arg1.  minor := arg2.  patch := arg3-=JUAMPI=-details  ^details-=JUAMPI=-inverse  ^IceModification left: self rightDefinition right: self leftDefinition-=JUAMPI=-doesNotUnderstand: arg1  arg1 selector isUnary ifTrue: [ cache at: arg1 selector ifPresent: [:arg2 |  ^arg2 ].        (self realObject class lookupSelector: arg1 selector) ifNotNil: [:arg3 |  (arg3 hasPragmaNamed: #noCache) ifFalse: [ ^cache at: arg1 selector put: (self forwardMessage: arg1) ] ] ].  ^self forwardMessage: arg1-=JUAMPI=-url  ^url-=JUAMPI=-fetch  [ ^self remote fetch ] ensure: [ fetched := true ]-=JUAMPI=-repository  ^iceCommit repository-=JUAMPI=-doCommit: arg1 message: arg2 pushing: arg3  self model commit: (IceTipCommitAction new           diff: self model workingCopyDiff;           items: arg1;           message: arg2;           yourself) then: [ self verifyNeedsRefreshOrClose.        arg3 ifTrue: [ (IceTipPushAction new repository: self model entity) execute ] ]-=JUAMPI=-isRepositoryDetached  ^self repositoryModel isNil or: [ self repositoryModel isDetached ]-=JUAMPI=-hash  ^commitish hash-=JUAMPI=-writerClass  ^self properties writerClass-=JUAMPI=-displayString  ^self entity name-=JUAMPI=-textForMergeable: arg1  arg1 = true ifTrue: [ ^'Yes' ].  arg1 = false ifTrue: [ ^'There are conflicts' ].  ^arg1 asString-=JUAMPI=-ensureSourceCodeParentNodeIn: arg1  ^self ensureDirectoryAtPath: diff repository subdirectoryPath segments inNode: arg1-=JUAMPI=-visitNoRemote: arg1  UIManager default alert: 'There are no remotes defined for this repository. Add one before continue.' title: 'Remote action failed'-=JUAMPI=-checkoutStrategy  ^checkoutStrategy-=JUAMPI=-execute  | tmp1 tmp2 tmp3 tmp4 |  location exists ifTrue: [ IceCloneLocationAlreadyExists signalFor: location ].  [ location ensureCreateDirectory.  tmp1 := LGitRepository on: location.  tmp2 := LGitCloneOptions withCredentialsProvider: (IceCredentialsProvider defaultForRemoteUrl: url).  tmp3 := tmp2 checkoutOptions.  tmp4 := tmp2 fetchOptions callbacks.  tmp4 transferProgress: IceGitTransferProgress new.  tmp3 checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force.  tmp3 progressCallback: IceGitCheckoutProgress new.  tmp1 clone: url options: tmp2.  (LGitRemote of: tmp1 named: 'origin')     lookup;     setUrl: url ] on: LGitCallReturnHandler , IceWrongUrl do: [:arg1 |  location exists ifTrue: [ location ensureDeleteAll ].        arg1 acceptError: (IceLibgitErrorVisitor onContext: self) ]-=JUAMPI=-branchName: arg1  branchName := arg1-=JUAMPI=-execute  | tmp1 |  tmp1 := UIManager default request: 'Please provide the name of the new branch to be created' initialAnswer: '' title: 'Create new branch'.  tmp1 isEmptyOrNil ifTrue: [ ^self ].  self repository createBranch: tmp1.  self beSuccess-=JUAMPI=-username: arg1  username := arg1-=JUAMPI=-iceVersion  ^commit versionFor: package-=JUAMPI=-location: arg1  | tmp1 |  tmp1 := arg1 asFileReference.  keptLocation ifNotNil: [ | tmp2 |        tmp2 := (self location pathString copyReplaceAll: keptLocation pathString with: tmp1 pathString) asFileReference.        keptLocation := tmp1.        tmp1 := tmp2 ].  self basicLocation: tmp1-=JUAMPI=-username: arg1 project: arg2  path := arg1 , '/' , arg2-=JUAMPI=-choosen: arg1  choosen := arg1-=JUAMPI=-handlesMouseDown: arg1  ^false-=JUAMPI=-isNewBranch  ^false-=JUAMPI=-model  ^model-=JUAMPI=-baseLabel  ^baseLabel-=JUAMPI=-showFilterFieldFromKeystrokeEvent: arg1  | tmp1 |  tmp1 := arg1 keyCharacter asString.  self textField takeKeyboardFocus.  self textField text: self textField text , tmp1.  self flag: #hack.  self textField textArea cursorEnd: arg1-=JUAMPI=-isExtensionDefinition  ^true-=JUAMPI=-title  ^model isCurrent ifTrue: [ 'Current Iceberg credentials' ] ifFalse: [ 'Credentials of ' , model printString ]-=JUAMPI=-cancelAction  -=JUAMPI=-basicUrl: arg1  url := arg1-=JUAMPI=-package  ^package-=JUAMPI=-visitRemoval: arg1  arg1 definition removeFrom: self-=JUAMPI=-publicKeyInput  ^publicKeyInput-=JUAMPI=-okAction  credentialStore storeCredential: self credentials forHostname: self host.  tool refresh-=JUAMPI=-initializeSourceDirectory  subdirectoryLabel := self newLabel label: 'Source directory'.  subdirectoryInputText := self newTextInput     ghostText: 'e.g., src';     autoAccept: true.  subdirectoryInputText text: self defaultSubdirectory-=JUAMPI=-packageName  ^package-=JUAMPI=-printOn: arg1  arg1 nextPutAll: version asString-=JUAMPI=-isModified  ^self entity isModified-=JUAMPI=-remoteModels  ^self entity remotes collect: [:arg1 |  (IceTipRemoteModel repositoryModel: self on: arg1) beCached ]-=JUAMPI=-hasLocalBraches  ^self localBranches isNotEmpty-=JUAMPI=-changesFromCommit: arg1  ^(self modifiedPackages collect: [:arg2 |  IceImageChange package: arg2 ]) asArray , (self referenceCommit changesFromCommit: arg1) asArray-=JUAMPI=-selectionHasActualClass  ^self selectedChangeWrapper ifNil: [ false ] ifNotNil: [:arg1 |  arg1 item value contextClass notNil ]-=JUAMPI=-showEmptyTab  emptyTab ifNil: [ emptyTab := self newEmptyTab ].  self removeAllCommitPanelTabs.  commitTabPanel addTab: emptyTab-=JUAMPI=-textField  ^textField-=JUAMPI=-versionLike: arg1 ifNone: arg2  ^self repository branch versionsFor: self detect: arg1 ifNone: arg2-=JUAMPI=-diff: arg1  diff := arg1-=JUAMPI=-includes: arg1  ^modifiedFilePaths includes: arg1-=JUAMPI=-initialize  super initialize.  isAnonymous := false-=JUAMPI=-isRemoval  ^true-=JUAMPI=-commit: arg1  repository handleLibgitError: [ | tmp1 tmp2 |        tmp1 := self repositoryHandle lookupLocalBranch: self name.        tmp2 := self repositoryHandle revparse: arg1 id.        tmp1 setTargetId: tmp2 id.        self = repository head ifTrue: [ self repositoryHandle checkout_treeish: tmp2 opts: (LGitCheckoutOptions defaults                       checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force;                       yourself) ] ]-=JUAMPI=-isMerged  ^mergeTree allSatisfy: [:arg1 |  arg1 isConflict not or: [ arg1 isResolved ] ]-=JUAMPI=-tree  ^self mergeTree-=JUAMPI=-definition  ^definition-=JUAMPI=-remoteBranchNamed: arg1  ^self remoteBranchNamed: arg1 ifPresent: [:arg2 |  ^arg2 ] ifAbsent: [ IceBranchNotFound new           branchName: arg1;           signal ]-=JUAMPI=-add: arg1  self selectedItems add: arg1.  self onSelectionChangedBlock ifNotNil: [:arg2 |  arg2 cull: arg1 cull: true ]-=JUAMPI=-versionFor: arg1  ^self commit versionFor: arg1-=JUAMPI=-authorLabel  ^authorLabel-=JUAMPI=-execute  item ifNil: [ ^self ].  item entity inspect-=JUAMPI=-contextClass  ^IceTipCommitContext-=JUAMPI=-execute  self withErrorHandlingDo: [ self validateRemotesPresent.        (IceTipPullBrowser onRepositoryModel: self repositoryModel) openWithSpec ]-=JUAMPI=-remotes  ^entity remotes-=JUAMPI=-fetch  < noCache>  IceTipStandardAction new     repository: self entity;     message: ('Fetching incoming commits of {1}' format: {self name});     onSuccessRepositoryModified;     execute: [ self entity fetch ]-=JUAMPI=-actionPanel  ^actionPanel-=JUAMPI=-execute  browser accept-=JUAMPI=-addShortcutsTo: arg1  self enableCommanderShortcutsIn: arg1-=JUAMPI=-commitModels  ^(self entity branch incomingCommitsFrom: self remote) collect: [:arg1 |  (IceTipCommitModel repositoryModel: self repositoryModel on: arg1) beCached ]-=JUAMPI=-isRootDefinition  ^true-=JUAMPI=-mouseEnter: arg1  self flag: #bad.  ^self eventHandler ifNotNil: [ self eventHandler mouseEnter: arg1 fromMorph: self ]-=JUAMPI=-definition  ^definition-=JUAMPI=-badge: arg1  badge := arg1 = 0 ifTrue: [ nil ] ifFalse: [ arg1 ]-=JUAMPI=-repositoryWillBeCreated: arg1  -=JUAMPI=-onClick: arg1  onClickBlock := arg1-=JUAMPI=-icon  ^item value icon-=JUAMPI=-repoPath  ^self repository subdirectory-=JUAMPI=-initialize  super initialize.  name := ''-=JUAMPI=-subscribeToAnnouncements  self announcer when: IceTipDiffRefreshed send: #refreshWhenRepository: to: self-=JUAMPI=-copyWithOnly: arg1  | tmp1 tmp2 |  tmp2 := arg1 collect: #value.  tmp1 := tree select: [:arg2 |  tmp2 includes: arg2 ].  ^self class new     sourceVersion: source;     targetVersion: target;     diffTree: tmp1;     yourself-=JUAMPI=-execute  UIManager default informUser: 'Refreshing pull request list' during: [ tool refreshPullRequests ]-=JUAMPI=-uptadeSelectedCommit: arg1  self diff selectedModel: (arg1 newSelectedRowIndexes ifNotEmpty: [:arg2 |  self commits widget dataSource elementAt: arg2 first ] ifEmpty: [ nil ])-=JUAMPI=-announcer  ^announcer ifNotNil: #contents-=JUAMPI=-validateMessageNotEmpty  self message ifEmpty: [ IceNoCommitMessage signal ]-=JUAMPI=-execute  UIManager default informUser: 'Reverting change...' during: [ self repositoryModel entity workingCopy discardChanges: item ].  self announcer announce: (IceTipDiffEntryRemoved entry: item).  Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity)-=JUAMPI=-removeFrom: arg1  arg1 removeClass: self-=JUAMPI=-parent  ^parent-=JUAMPI=-accept  ^self doCommit-=JUAMPI=-snapshotFor: arg1  ^MCSnapshot empty-=JUAMPI=-tagNameLabel  ^tagNameLabel-=JUAMPI=-accept: arg1  ^arg1 visitMethodNode: self-=JUAMPI=-isWorkingCopy  ^false-=JUAMPI=-remoteName: arg1  remoteName := arg1-=JUAMPI=-iconNamed: arg1  ^self class iconNamed: arg1-=JUAMPI=-mergeWith: arg1 onLeft: arg2 onRight: arg3 onMerge: arg4  ^arg1 collect: arg3-=JUAMPI=-visitTreeNode: arg1  self withNode: arg1 do: [ arg1 value accept: self ]-=JUAMPI=-commit  ^self entity-=JUAMPI=-rootItem: arg1  super rootItem: arg1.  self addSourceToRootItem-=JUAMPI=-nameInput  ^nameInput-=JUAMPI=-createBranch: arg1 inCommit: arg2  self handleLibgitError: [ (self repositoryHandle isUnborn and: [ arg2 isNoCommit ]) ifTrue: [ ^self createBranch: arg1 ].        self repositoryHandle createBranch: arg1 targetId: (LGitId fromHexString: arg2 gitRef) force: false.        ^(self branchNamed: arg1)           switch;           yourself ]-=JUAMPI=-incomingCommits  ^#()-=JUAMPI=-mergeWithMasterCheckbox: arg1  mergeWithMasterCheckbox := arg1-=JUAMPI=-iconNamed: arg1  ^Smalltalk ui icons iconNamed: arg1-=JUAMPI=-execute  ^IceGitHubRemoveBranchesAction new     repository: self repository;     remote: self remote;     execute-=JUAMPI=-removeFromPatcher: arg1  self subclassResponsibility-=JUAMPI=-version: arg1  version := arg1-=JUAMPI=-backend: arg1  backend := arg1-=JUAMPI=-title: arg1  title := arg1-=JUAMPI=-iconForMergeable: arg1  arg1 = true ifTrue: [ ^self iconNamed: #smallOk ].  ^self iconNamed: #smallCancel-=JUAMPI=-checkForRegistryConflicts  self subclassResponsibility-=JUAMPI=-newRootCellFor: arg1  | tmp1 |  tmp1 := IceTipOutlineHeaderCellMorph dataSource: self item: arg1.  (self iconFor: arg1 data) ifNotNil: [:arg2 |  tmp1 addMorphBack: arg2 asMorph ].  tmp1 addMorphBack: (self toString: arg1 data) asMorph asReadOnlyMorph.  tmp1 addMorphBack: (AlignmentMorph newSpacer: Color transparent).  tmp1 addMorphBack: arg1 children size asMorph asReadOnlyMorph.  tmp1 addMorphBack: (Morph newBounds: (0 @ 0 corner: 20 @ 0) color: Color transparent) asReadOnlyMorph.  ^tmp1-=JUAMPI=-doAccept  self validate.  commitishToTag createTag: self tagName thenDo: [:arg1 |  callback ifNotNil: [ callback value: arg1 ] ]-=JUAMPI=-initializeCommitsTable  | tmp1 |  tmp1 := [:arg1 :arg2 |  arg2 isMerged ifTrue: [ arg1 asText ] ifFalse: [ arg1 asText allBold ] ].  commits widget     beResizable;     addColumn: (IceTipTableColumn id: 'Date & time' action: [:arg2 |  tmp1 value: arg2 datetime asLocalStringYMDHM value: arg2 ] width: 120 * World displayScaleFactor);     addColumn: (IceTipTableColumn id: 'Id' action: [:arg2 |  tmp1 value: arg2 shortId value: arg2 ] width: 50 * World displayScaleFactor);     addColumn: (IceTipTableColumn id: 'Author' action: [:arg2 |  tmp1 value: arg2 author value: arg2 ] width: 120 * World displayScaleFactor);     addColumn: (IceTipTableColumn id: 'Comment' action: [:arg2 |  tmp1 value: arg2 comment value: arg2 ] width: 300 * World displayScaleFactor);     dataSource: self newCommitsDataSource;     selectRowIndex: 1-=JUAMPI=-delete  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Removing branch {1}' format: {self name});     onSuccessRepositoryModified;     execute: [ self entity delete ]-=JUAMPI=-visitRemoval: arg1  arg1 definition removeFrom: self.  self visitChildrenOf: currentNode-=JUAMPI=-nextChildNodeStartingFrom: arg1 suchThat: arg2 ifNone: arg3  | tmp1 |  tmp1 := self children.  (tmp1 indexOf: arg1) + 1 to: tmp1 size do: [:arg4 |  | tmp2 |        tmp2 := tmp1 at: arg4.        (arg2 value: tmp2) ifTrue: [ ^tmp2 ].        tmp2 nextNodeSuchThat: arg2 ifFound: [:arg5 |  ^arg5 ] ].  self parent ifNil: [ ^arg3 value ].  ^self parent nextChildNodeStartingFrom: self suchThat: arg2 ifNone: arg3-=JUAMPI=-checkout: arg1  arg1 committish: self.  ^repository checkout: arg1-=JUAMPI=-actionPanel: arg1  actionPanel := arg1-=JUAMPI=-contents  ^''-=JUAMPI=-addRemoteNamed: arg1 url: arg2  IceTipStandardAction new     repository: self entity;     message: 'Adding remote';     onSuccessRepositoryModified;     execute: [ | tmp1 |        tmp1 := IceGitRemote name: arg1 url: arg2.        self entity addRemote: tmp1.        tmp1 fetch ]-=JUAMPI=-publicKey  ^publicKey ifNil: [ publicKey := self class defaultPublicKey ]-=JUAMPI=-referencesSameRemoteLocationAs: arg1  ^(super referencesSameRemoteLocationAs: arg1) or: [ self httpsUrl = arg1 httpsUrl ]-=JUAMPI=-properties  ^properties ifNil: [ properties := Dictionary new ]-=JUAMPI=-cellColumn: arg1 row: arg2  ^FTCellMorph new     addMorphBack: ((self elementAt: arg2) at: arg1 id) asStringMorph;     yourself-=JUAMPI=-hasUnknownCommit  ^self workingCopyState isUnknownCommitState-=JUAMPI=-mergeWithLeftModification: arg1  ^IceConflictingOperation left: arg1 right: self-=JUAMPI=-readContextParametersFromModel: arg1  self repositoryModel: arg1 repositoryModel-=JUAMPI=-codeDirectory  self repositoryDirectory exists ifTrue: [ ^self basicCodeDirectory ] ifFalse: [ IceLocalRepositoryMissing signalFor: self ]-=JUAMPI=-addLabel: arg1 value: arg2  items at: arg1 put: arg2.  self refresh-=JUAMPI=-initializeWithJSON: arg1  json := arg1.  self initialize-=JUAMPI=-title  ^'Pull {1}/{2} from {3}' format: {self model repositoryName .         self model branchName .         self model remoteName}-=JUAMPI=-hasTagNamed: arg1  self subclassResponsibility-=JUAMPI=-okAction  self credentials     username: self username;     password: self password.  credentialStore storeCredential: self credentials.  tool refresh-=JUAMPI=-packageNameFromPackageDirectory  ^iceVersion packageName-=JUAMPI=-pullFrom: arg1  | tmp1 |  repository fetch.  tmp1 := arg1 remoteBranchNamed: self name ifAbsent: [ ^self ].  repository createBranch: self name inCommit: tmp1 commit-=JUAMPI=-isNoCommit  ^true-=JUAMPI=-createRepository: arg1  (self canHandleType: arg1 type) ifTrue: [ ^Iceberg mcRepositoryFor: arg1 description ].  ^super createRepository: arg1-=JUAMPI=-writeInDirectoryName: arg1 fileName: arg2 extension: arg3 visit: arg4  | tmp1 |  tmp1 := self directoryForDirectoryNamed: arg1.  self fileUtils writeStreamFor: arg2 , arg3 in: tmp1 do: [:arg5 |  self setFileStream: arg5.        arg4 value ]-=JUAMPI=-max: arg1  max := arg1-=JUAMPI=-isRightChosen  ^chosen = operation inverse-=JUAMPI=-shortDescriptionWithDecoration  ^self addDecorationTo: (self entity isRemote ifTrue: [ self name copyAfter: $/ ] ifFalse: [ self name ])-=JUAMPI=-initializeCommitPanel  commitTabPanel     addTab: (infoTab := self newInfoTab);     addTab: (diffTab := self newDiffTab           label: 'Diff from ancestor';           whenTabSelected: [ self refreshDiff ];           yourself)-=JUAMPI=-iceCommitFrom: arg1  ^self repository iceCommitFrom: arg1-=JUAMPI=-printOn: arg1  arg1     print: self class;     nextPut: $(;     nextPutAll: self package name.  arg1 nextPut: $)-=JUAMPI=-passphrase  ^passphraseInput text-=JUAMPI=-block  ^[:arg1 :arg2 :arg3 :arg4 |  job ensureStarted.  job min: 0.  job max: arg3.  job current: arg2.  job title: ('Checking out... ({1}/{2})' format: {arg2 .               arg3}).  job changed ]-=JUAMPI=-readParametersFromContext: arg1  super readParametersFromContext: arg1.  tool := arg1 tool-=JUAMPI=-