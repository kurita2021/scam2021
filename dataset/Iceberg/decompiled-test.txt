format  ^format-======-load  self repository workingCopy loadPackageNamed: self name-======-obtainAvailableRemotes  | tmp1 |  tmp1 := self repository remotes.  (tmp1 includes: self baseRemote) ifFalse: [ tmp1 := tmp1 copyWith: self baseRemote ].  ^tmp1-======-mergeBaseBetween: arg1 and: arg2  self handleLibgitError: [ ^(self repositoryHandle mergeBaseBetween: (LGitId fromHexString: arg1) and: (LGitId fromHexString: arg2)) hexString ]-======-timeStamp  ^self datetime-======-baseLabel  ^'No PR selected'-======-projectName  ^projectName-======-isFastForward  ^self headCommit isAncestorOf: mergeCommit-======-basicExecute  self fetchAllRemotes.  (IceTipPullBrowser onRepositoryModel: self repositoryModel) openWithSpec-======-sortingStrategyFirst: arg1  self sortingStrategy first: arg1-======-initializeChangeList  | tmp1 |  tmp1 := self newChangeTreeDataSource.  changeList widget dataSource: tmp1.  tmp1 expandAll-======-changesFromCommit: arg1  ^arg1 changesFromNoCommit: self-======-remoteFileReferenceInPath: arg1  -======-issueLabel: arg1  issueLabel := arg1-======-initializeWidgets  self initializeProjectLocation.  self initializeSpacePanel-======-workingCopy  ^repository workingCopy-======-createCommandContextForSelection: arg1  ^self newContextWithSelection: arg1-======-fetchFrom: arg1  arg1 fetch-======-position: arg1  position := arg1-======-allBranchModels  ^self entity allBranches collect: [:arg1 |  (IceTipBranchModel repositoryModel: self on: arg1) beCached ]-======-tags  ^self commit tags-======-datetime  ^datetime-======-repositoryName  ^self repositoryModel name-======-customError: arg1  ^arg1 at: #message-======-removeFrom: arg1  arg1 removeSSHCredential: self-======-packageModels  ^self sortingStrategy sort: (self repositoryModel entity workingCopy packages collect: [:arg1 |  (IceTipPackageModel repositoryModel: self repositoryModel on: arg1) beCached ])-======-remote: arg1  remote := arg1-======-privateKey: arg1  privateKey := arg1.  self storeIfDefault-======-fileNameForMethod: arg1  | tmp1 |  tmp1 := OrderedCollection new.  self repository subdirectory ifNotEmpty: [:arg2 |  tmp1 add: arg2 ].  tmp1 add: (self tonelPackageName: arg1 package).  tmp1 add: (self tonelMethodClassOrTraitName: arg1).  ^String streamContents: [:arg3 |  tmp1 asStringOn: arg3 delimiter: '/' ]-======-longStatus  (entity isMissing and: [ entity location isNil ]) ifTrue: [ ^'Iceberg does not find a git repository. Please clone the repository or change the repository location to an existing Git repository' ].  entity isMissing ifTrue: [ ^'Iceberg does not find a git repository at {1}. Please clone the repository again or change the repository location to an existing Git repository' format: {entity location} ].  entity workingCopy workingCopyState isUnknownCommitState ifTrue: [ ^'This image has a loaded version of the code from commit {1}, but Iceberg does not find the commit in your local Git repository. You may fetch the correct commit from a remote repository or discard the code of your image and load the version that is in the repository.' format: {entity workingCopy referenceCommit shortId} ].  entity workingCopy isDetached ifTrue: [ ^'The loaded code in the image starts from commit {1}. This commit does not correspond with the commit in the head of the current branch of the repository (Commit {2}). You need to synchronize them to continue. You need to discard your image changes or change the HEAD of the repository to point to the commit.' format: {entity workingCopy referenceCommit shortId .               entity headCommit shortId} ].  entity head isDetached ifTrue: [ ^'The repository and the image are in the same commit {1}. However, the commit is not in an active branch. It is not possible to commit in a Git detached HEAD state. Create a new branch (by checkouting) or checkout an existing one.' format: {entity headCommit shortId} ].  entity workingCopy project isUnborn ifTrue: [ ^'Cannot find a project (meta-data and source directory) in your repository. Please edit your repository meta-data to indicate the source code directory or change the location to a valid iceberg repository' ].  ^'Your repository seems ok. Please report a ticket in Iceberg''s issue tracker. If you can, please send us a backup of your image in this state for debugging.'-======-keysDo: arg1  childrenDictionary keysDo: arg1-======-issueLabel  ^issueLabel-======-execute  self packageModel remove-======-headCommit  ^self head commit-======-push  -======-snapshotFor: arg1  ^(self versionFor: arg1) snapshot-======-asBornProperties  ^IceRepositoryProperties fromDictionary: properties commitish: commitish-======-selectedChange  ^(self selectedChangeWrapper ifNil: [ ^nil ]) item value-======-request: arg1  request := arg1-======-diffToReferenceCommit  ^self diffTo: self referenceCommit-======-url  ^url-======-selectRemoteNamed: arg1  remoteList setSelectedItem: (self model remoteModels detect: [:arg2 |  arg2 name = arg1 ])-======-table: arg1  super table: arg1.  self addBindingsToTable-======-selectNextConflict  | tmp1 |  tmp1 := self nextConflict ifNil: [ ^self ].  self changed: {#openPath} , tmp1 item path segments-======-item  ^self packageModel-======-descriptionWithDecoration  ^self name asText-======-isLocal  ^self entity isLocal-======-cellColumn: arg1 row: arg2  ^self newCellFor: (self elementAt: arg2)-======-refreshWhenRepository: arg1  (arg1 repository isNil or: [ self model repositoryModel isModelOf: arg1 repository ]) ifFalse: [ ^self ].  self model reset.  self refresh-======-visitPackage: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := MCPackage named: arg1 name.  tmp2 := [ diff targetVersion snapshotFor: arg1 ] on: NotFound do: [ MCSnapshot empty ].  tmp3 := MCPatcher snapshot: tmp2.  currentNode accept: (IceMCSnapshotPatchVisitor new           patcher: tmp3;           yourself).  tmp4 := MCVersion new setPackage: tmp1 info: (IceMCVersionInfo package: tmp1 message: 'Internal...') snapshot: tmp3 patchedSnapshot dependencies: #().  index storeVersion: tmp4-======-child  ^IceGitChange on: (RelativePath withAll: self path segments allButFirst) pathString-======-defaultMenuItemName  ^'Open on github'-======-versionsFor: arg1  ^self commit versionsFor: arg1-======-newContextWithSelection: arg1  ^self newContext     item: arg1;     yourself-======-refreshDirtyPackages  self markAsCleanPackagesNotInDiff: self repository workingCopyDiff-======-remotes  self handleLibgitError: [ | tmp1 |        self isValid ifFalse: [ ^#() ].        tmp1 := self repositoryHandle allRemotes.        ^tmp1 collect: [:arg1 |  (IceGitRemote name: arg1 remoteName url: arg1 url)                 localRepository: self;                 yourself ] ]-======-commit  ^self-======-isClassDefinition  ^false-======-execute  self subclassResponsibility-======-repositoryList  ^repositoryList-======-mergeWithBranch: arg1  self subclassResponsibility-======-entryName  ^entryName-======-response  ^response-======-actualClass  ^self contextClass-======-value  ^list includes: item-======-typeList: arg1  typeList := arg1-======-repository  ^commitish repository-======-packages  tree isEmpty ifTrue: [ ^#() ].  ^self codeSubdirectoryNode children-======-select: arg1  ^self-======-basicNewRemoteBranchNamed: arg1  ^IceGitRemoteBranch named: arg1 inRepository: self-======-gitRef  ^((repository location / '.git' / 'HEAD') contents withoutPrefix: 'ref: ') trimBoth-======-initializeWidgets  super initializeWidgets.  repositoryList := self newIceTable.  repositoryList widget onAnnouncement: FTStrongSelectionChanged send: #repositoryStrongSelection: to: self.  self initializeRepositoryList.  self focusOrder add: repositoryList-======-push  self branch push-======-optionsList  ^optionsList-======-nameLabel: arg1  nameLabel := arg1-======-id: arg1  id := arg1-======-invalidError: arg1  ^'Invalid field: ' , (arg1 at: #field)-======-children  ^#()-======-classIsMeta: arg1  classIsMeta := arg1-======-changesFromCommit: arg1  self assert: arg1 isNoCommit.  ^#()-======-sourceDirectory  ^self repository project sourceDirectory-======-packageNameFromPackageDirectory  ^iceVersion packageName-======-toText: arg1  toText := arg1-======-tags  self subclassResponsibility-======-contextClass  ^IceTipBranchContext-======-fetchPullRequests  ^(IceGitHubAPI new getPullRequests: self remote owner project: self remote projectName) all collect: [:arg1 |  (IceGitHubPullRequest fromJSON: arg1)           repository: self repository entity;           yourself ]-======-messageText  ^'There is no version for package: {1} in  commit {2}' format: {self version packageName .         self version commit id}-======-shortName  ^self name copyAfter: $/-======-remoteUrl: arg1  remoteUrl := arg1-======-visitNonConflictingOperation: arg1  arg1 chosenOperation accept: self-======-withoutNewBranch  types := self allTypes reject: #isNewBranch.  typeList widget dataSource elements: types.  typeList widget refresh-======-hasSingleCommit  ^self workingCopyState isSingleCommitState-======-repositoryProperties  ^properties-======-repository  ^repository-======-initialize  super initialize.  childrenDictionary := Dictionary new-======-mergeThen: arg1  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Merging branch {1} from {2}' format: {self name .               self repositoryName});     onSuccessRepositoryModified;     onSuccess: arg1;     execute: [ self entity merge ]-======-includesPackageNamed: arg1  ^false-======-acceptError: arg1  arg1 visitShouldCommitBeforePullError: self-======-reset  UIManager default informUser: 'Refreshing changes' during: [ self resetDiff.        self diff ]-======-initializeExistingTagsList  existingTagsList := self newList.  existingTagsList     items: commitishToTag tagModels;     displayBlock: #name;     sortingBlock: #name descending-======-canBrowseReferences  ^self canBeBrowsed-======-help  ^self commandClass defaultHelp-======-printOn: arg1  arg1     nextPutAll: self class name;     nextPutAll: '(';     nextPutAll: self name;     nextPutAll: ')'-======-package  ^package-======-model: arg1  model := arg1.  self allTypes do: [:arg2 |  arg2 model: arg1 ]-======-mergeIntoWorkingCopy  self repository     ensureBranch: self branchName;     checkoutBranch: self branchName.  self branch merge-======-visitAuthenticationError: arg1  UIManager default alert: arg1 messageText title: 'Iceberg authentication Error'-======-initializeWidgets  iconPanel := self newIcePanel.  iconPanel widget addMorph: ((self iconNamed: #error) scaledToSize: 32 @ 32) asMorph.  errorLabel := self newIceReadOnlyText.  errorLabel widget contentsWrapped: exception messageText.  errorLabel widget     hResizing: #spaceFill;     vResizing: #spaceFill-======-createCheckboxFor: arg1  ^CheckboxMorph on: (IceGitHubSelectItem list: selectedItems item: arg1) selected: #value changeSelected: #value:-======-subscribeToAnnouncements  Iceberg announcer weak when: IceRepositoryAnnouncement send: #refreshWhenRepository: to: self-======-ensureDefaultProperties  properties at: #format ifAbsentPut: [ self writerClass id ]-======-labelFor: arg1  ^'HEAD to {1}' format: {(arg1 ifNotNil: #shortId)}-======-changeList: arg1  changeList := arg1-======-checkoutWithStrategy: arg1  repository checkout: (arg1 commitish: self)-======-hash  ^self commit hash-======-contentsWithValidationDo: arg1  ^(self responseWithValidationDo: arg1) contents-======-icon  ^self iconNamed: #changeRemove-======-nextNodeSuchThat: arg1 ifNone: arg2  self children do: [:arg3 |  (arg1 value: arg3) ifTrue: [ ^arg3 ].        arg3 nextNodeSuchThat: arg1 ifFound: [:arg4 |  ^arg4 ] ].  ^self parent nextChildNodeStartingFrom: self suchThat: arg1 ifNone: arg2-======-selectRemoteModel  ^selectRemoteModel ifNil: [ selectRemoteModel := IceTipRemoteActionModel repositoryModel: self model on: self model entity ]-======-contents  ^self basicAt: 1-======-basicExecute  IceTipRegisterRepositoryDialog new     beForCloneOfRepository: self repositoryModel entity;     onAccept: [ Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity) ];     openDialogWithSpec-======-onSuccessAnnounce: arg1  successAnnounceBlock := arg1-======-repository  ^repository-======-fileUtils  ^IceLibgitFiletreeFileUtils-======-comment  ^self entity comment-======-mergeWithLeftRemoval: arg1  ^IceConflictingOperation left: arg1 right: self-======-keys  ^childrenDictionary keys-======-definition  ^operation definition-======-onAccept: arg1  acceptBlock := arg1-======-sourceCode: arg1  sourceCode := arg1-======-hasAnyNonConflictConflicts  ^self model mergeTree anySatisfy: [:arg1 |  arg1 isConflict and: [ arg1 isResolved ] ]-======-model  ^model-======-delete  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Removing remote {1}' format: {self name});     onSuccessRepositoryModified;     do: [ self repositoryModel entity removeRemote: self entity ]-======-credentials: arg1  credential := arg1.  self usernameInput text: credential username.  self passwordInput text: credential password-======-writerClass  ^self commit writerClass-======-badgeSelector: arg1  badgeSelector := arg1-======-free  (handle isNil or: [ handle isNull ]) ifFalse: [ handle free.        handle := nil ]-======-referencesSameRemoteLocationAs: arg1  ^(super referencesSameRemoteLocationAs: arg1) or: [ (self url withoutSuffix: '.git') sameAs: (arg1 httpsUrl withoutSuffix: '.git') ]-======-readProjectFromCommitish: arg1  self subclassResponsibility-======-cellColumn: arg1 row: arg2  | tmp1 |  tmp1 := self elementAt: arg2.  ^tmp1 depth = 0 ifTrue: [ self newRootCellFor: tmp1 ] ifFalse: [ self newCellFor: tmp1 ]-======-execute  item copyCommitIDToClipboard-======-upstreamForBranch: arg1 backend: arg2  ^arg2 lookupBranchNamed: arg1 name inRemote: self remoteName-======-hash  ^self name hash-======-contextClass  ^leftOperation contextClass-======-basepathOf: arg1  self subclassResponsibility-======-initializeBlock  self signature: self class fnSpec block: self block-======-repositoryModel: arg1  repositoryModel := arg1-======-readParametersFromContext: arg1  super readParametersFromContext: arg1.  item := arg1 item-======-menuSelectionContext  ^self tool newContext-======-initializePresenter  super initializePresenter.  self commits widget onAnnouncement: FTSelectionChanged send: #uptadeSelectedCommit: to: self.  mergeButton action: [ self mergePullRequestIntoImage ].  acceptButton action: [ self acceptPullRequest ].  rejectButton action: [ self rejectPullRequest ]-======-version: arg1  version := arg1-======-description  ^self class description-======-diff  ^diff-======-statusPanel  ^statusPanel-======-initializeEntity: arg1  entity := arg1.  self initialize-======-validateCanCommit  self isDetached ifTrue: [ IceWorkingCopyDesyncronized signal ]-======-fromCommit: arg1 package: arg2  commit := arg1.  package := arg2.  date := commit datetime asDate.  time := commit datetime asTime.  name := '{1}-{2}.{3}' format: {package name .         commit compatibleUsername .         commit datetime asUnixTime}.  id := self class uuidFromCommit: arg1 package: arg2.  message := commit comment.  author := commit compatibleUsername-======-location: arg1  ^self projectLocation location: arg1-======-commitModels  | tmp1 |  tmp1 := OrderedCollection new.  self entity commitsDo: [:arg1 |  tmp1 add: (IceTipCommitModel repositoryModel: self repositoryModel on: arg1) beCached ].  ^tmp1-======-repositoryName  ^self repository name-======-actionPanel  ^actionPanel-======-tagNameInputText  ^tagNameInputText-======-name  ^name-======-initializeDialogWindow: arg1  super initializeDialogWindow: arg1.  acceptButton     disable;     label: 'Add'-======-leftContents  ^definition contents-======-execute  self withErrorHandlingDo: [ self basicExecute.        self finishSuccess ]-======-newCredentialsDataSource  ^IceTipDataSource new     tool: self;     elements: self model allCredentials;     yourself-======-password: arg1  password := arg1-======-toLabel  ^toLabel-======-item  ^item-======-visitRemoval: arg1  arg1 definition removeFromPatcher: patcher.  self visitChildrenOf: currentNode-======-projectVersion  ^projectVersion-======-validateAlreadyPresentAndNotGit  (self remoteToUse isNil and: [ self location notNil and: [ self location exists and: [ (self class isGitRoot: self location) not ] ] ]) ifTrue: [ IceError signal: ('"{1}" is not a git directory' format: {self location fullName}) ]-======-initializeWidgets  super initializeWidgets.  commitList := self newIceTable.  commitTabPanel := self newTabManager.  self initializeCommitList.  self initializeCommitPanel.  commitList widget onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self.  self focusOrder     add: commitList;     add: commitTabPanel.  self refresh-======-refresh  self model reset.  self resetDiffContents.  changeList widget     in: [:arg1 |  arg1 basicSelectIndexes: #().        arg1 dataSource           rootForItems: self model treeRoots;           selectAll;           expandAll ];     refresh-======-merge: arg1 into: arg2  ^arg1 collectWithPath: [:arg3 :arg4 |  arg2 resolve: arg4 ifPresent: [:arg5 |  arg3 mergeWithOperation: arg5 ] ifAbsent: [ IceNonConflictingOperation operation: arg3 ] ]-======-execute  store removeCredential: credential.  tool refresh-======-isParentOf: arg1  ^self newCommitWalk includesCommit: arg1-======-open  self openNonModal modalRelativeTo: World.  ^self credentials-======-title: arg1  title := arg1-======-currentCommitishLabel  ^currentCommitishLabel-======-refresh  commitButton help: ('Commit your changes to {1}' format: {self repositoryName}).  pushCheckbox label: ('Push changes to {1}' format: {self repositoryRemoteName})-======-sshCredentials  ^IceCredentialStore current sshCredentialForHostname: remote host-======-= arg1  ^self fullname = arg1 fullname-======-ancestors  ^self commit ancestors-======-packageNameText  ^packageNameText-======-announcer  ^announcer ifNotNil: #contents-======-initialExtent  ^(500 @ (self class inputTextHeight * 5 + self class buttonHeight + 50)) scaledByDisplayScaleFactor-======-icon  self subclassResponsibility-======-peelTag: arg1  self subclassResponsibility-======-contents  ^self isBinary ifTrue: [ String streamContents: [:arg1 |  contents hexDumpOn: arg1 max: Float infinity ] ] ifFalse: [ contents utf8Decoded ]-======-writeMethodProperties: arg1  self shouldNotImplement-======-credential  ^credential-======-remove  repository workingCopy basicRemovePackage: self-======-projectNameLabel  ^projectNameLabel-======-initializeWidgets  super initializeWidgets.  packageList := self newIceTable.  statusBar := self instantiate: IceTipStatusBar.  self initializePackageList.  self initializeStatusBar.  self focusOrder add: packageList-======-checkoutOn: arg1  arg1 loadPackagesNamed: committish packageNames fromCommit: committish commit.  self repository setHead: committish.  arg1 referenceCommit: committish commit.  arg1 markAllPackagesAsClean-======-outgoingCommits  ^self entity outgoingCommits-======-isConflict  ^true-======-description  ^self name-======-mergeInto: arg1  -======-previewCheckout  < noCache>  (IceTipCheckoutPreviewBrowser onBranch: self) openWithSpec-======-oldNode: arg1  oldNode := arg1-======-resolve: arg1 ifAbsent: arg2  ^self resolve: arg1 ifPresent: [:arg3 |  arg3 ] ifAbsent: arg2-======-hash  ^self item hash-======-commit: arg1  commit := arg1-======-selectedBranch  | tmp1 |  tmp1 := self branchesList widget selectedIndex.  ^tmp1 ~= 0 ifTrue: [ self branchesList widget dataSource elementAt: tmp1 ] ifFalse: [ nil ]-======-initializePullRequestsTable  pullRequests widget     beResizable;     addColumn: (IceTipTableColumn new           id: '#';           action: [:arg1 |  arg1 number asString ];           width: 50 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'State';           action: #state;           width: 50 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Author';           action: #author;           width: 120 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Title';           action: #title;           yourself);     dataSource: self newPullRequestsDataSource-======-datetime  ^self commit datetime-======-copyToClipboardId: arg1  Clipboard clipboardText: arg1 informing: ('Commitish ID copied to clipboard ({1})' format: {arg1})-======-contents  ^contents-======-readParametersFromContext: arg1  super readParametersFromContext: arg1.  (self repositoryModel isNotNil and: [ self repositoryModel isMissing not ]) ifTrue: [ self badge: self repositoryModel numberOfIncomingCommits ]-======-readParametersFromContext: arg1  super readParametersFromContext: arg1.  selectedCommitish := arg1 item.  selectedBranch := arg1 selectedBranch-======-tonelClassExtension: arg1  arg1 isTrait ifTrue: [ ^'.trait' ].  ^'.class'-======-isOkEnabled  ^self username isNotEmpty and: [ self password isNotEmpty ]-======-onAccept: arg1  acceptBlock := arg1-======-remoteName  ^self remote name , '/' , self entity branch name-======-commitWithMessage: arg1  ^self workingCopy commitWithMessage: arg1-======-logClass  ^IceLog allSubclasses detect: [:arg1 |  arg1 isAvailableFor: self ]-======-protocolDropList: arg1  protocolDropList := arg1-======-commits  ^commits-======-diffToWorkingCopy  ^self diffTo: self repository workingCopy-======-validateChangeListNotEmpty  items ifEmpty: [ IceNothingToCommit signal ]-======-version: arg1  version := arg1-======-isRemoval  ^false-======-hasAnyNonIncomingConflicts  ^self model mergeTree anySatisfy: [:arg1 |  arg1 isConflict and: [ arg1 isResolved not or: [ arg1 isLeftChosen ] ] ]-======-forceCalculateDirtyPackages  | tmp1 |  tmp1 := IceDiff new     sourceVersion: self;     targetVersion: self referenceCommit;     buildFull.  self loadedPackages do: [:arg1 |  arg1 beDirty: (tmp1 includesPackageNamed: arg1 name) ]-======-initialize  super initialize.  categories := #()-======-workingCopy  ^self repository workingCopy-======-nextNodeSuchThat: arg1 ifFound: arg2  self children do: [:arg3 |  (arg1 value: arg3) ifTrue: [ ^arg2 value: arg3 ].        arg3 nextNodeSuchThat: arg1 ifFound: [:arg4 |  ^arg2 value: arg4 ] ]-======-mergeWithOperation: arg1  ^arg1 mergeWithLeftAddition: self-======-extent  ^self subclassResponsibility-======-title  ^'New tag of ' , commitishToTag name-======-matches: arg1  ^arg1 name asLowercase includesSubstring: self pattern asLowercase-======-commitModels  | tmp1 |  tmp1 := OrderedCollection new.  self entity commitsDo: [:arg1 |  tmp1 add: (IceTipCommitModel repositoryModel: self repositoryModel on: arg1) beCached ].  ^tmp1-======-selectionChanged: arg1  | tmp1 |  (arg1 newSelectedIndexes reject: [:arg2 |  arg2 = 0 ]) ifNotEmpty: [:arg3 |  tmp1 := changeList widget dataSource realElementAt: arg3 first.        self diffContentsLeft: tmp1 value rightContents right: tmp1 value leftContents ] ifEmpty: [ self resetDiffContents ]-======-initializeMajor: arg1 minor: arg2 patch: arg3  major := arg1.  minor := arg2.  patch := arg3-======-details  ^details-======-inverse  ^IceModification left: self rightDefinition right: self leftDefinition-======-doesNotUnderstand: arg1  arg1 selector isUnary ifTrue: [ cache at: arg1 selector ifPresent: [:arg2 |  ^arg2 ].        (self realObject class lookupSelector: arg1 selector) ifNotNil: [:arg3 |  (arg3 hasPragmaNamed: #noCache) ifFalse: [ ^cache at: arg1 selector put: (self forwardMessage: arg1) ] ] ].  ^self forwardMessage: arg1-======-url  ^url-======-fetch  [ ^self remote fetch ] ensure: [ fetched := true ]-======-repository  ^iceCommit repository-======-doCommit: arg1 message: arg2 pushing: arg3  self model commit: (IceTipCommitAction new           diff: self model workingCopyDiff;           items: arg1;           message: arg2;           yourself) then: [ self verifyNeedsRefreshOrClose.        arg3 ifTrue: [ (IceTipPushAction new repository: self model entity) execute ] ]-======-isRepositoryDetached  ^self repositoryModel isNil or: [ self repositoryModel isDetached ]-======-hash  ^commitish hash-======-writerClass  ^self properties writerClass-======-displayString  ^self entity name-======-textForMergeable: arg1  arg1 = true ifTrue: [ ^'Yes' ].  arg1 = false ifTrue: [ ^'There are conflicts' ].  ^arg1 asString-======-ensureSourceCodeParentNodeIn: arg1  ^self ensureDirectoryAtPath: diff repository subdirectoryPath segments inNode: arg1-======-visitNoRemote: arg1  UIManager default alert: 'There are no remotes defined for this repository. Add one before continue.' title: 'Remote action failed'-======-checkoutStrategy  ^checkoutStrategy-======-execute  | tmp1 tmp2 tmp3 tmp4 |  location exists ifTrue: [ IceCloneLocationAlreadyExists signalFor: location ].  [ location ensureCreateDirectory.  tmp1 := LGitRepository on: location.  tmp2 := LGitCloneOptions withCredentialsProvider: (IceCredentialsProvider defaultForRemoteUrl: url).  tmp3 := tmp2 checkoutOptions.  tmp4 := tmp2 fetchOptions callbacks.  tmp4 transferProgress: IceGitTransferProgress new.  tmp3 checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force.  tmp3 progressCallback: IceGitCheckoutProgress new.  tmp1 clone: url options: tmp2.  (LGitRemote of: tmp1 named: 'origin')     lookup;     setUrl: url ] on: LGitCallReturnHandler , IceWrongUrl do: [:arg1 |  location exists ifTrue: [ location ensureDeleteAll ].        arg1 acceptError: (IceLibgitErrorVisitor onContext: self) ]-======-branchName: arg1  branchName := arg1-======-execute  | tmp1 |  tmp1 := UIManager default request: 'Please provide the name of the new branch to be created' initialAnswer: '' title: 'Create new branch'.  tmp1 isEmptyOrNil ifTrue: [ ^self ].  self repository createBranch: tmp1.  self beSuccess-======-username: arg1  username := arg1-======-iceVersion  ^commit versionFor: package-======-location: arg1  | tmp1 |  tmp1 := arg1 asFileReference.  keptLocation ifNotNil: [ | tmp2 |        tmp2 := (self location pathString copyReplaceAll: keptLocation pathString with: tmp1 pathString) asFileReference.        keptLocation := tmp1.        tmp1 := tmp2 ].  self basicLocation: tmp1-======-username: arg1 project: arg2  path := arg1 , '/' , arg2-======-choosen: arg1  choosen := arg1-======-handlesMouseDown: arg1  ^false-======-isNewBranch  ^false-======-model  ^model-======-baseLabel  ^baseLabel-======-showFilterFieldFromKeystrokeEvent: arg1  | tmp1 |  tmp1 := arg1 keyCharacter asString.  self textField takeKeyboardFocus.  self textField text: self textField text , tmp1.  self flag: #hack.  self textField textArea cursorEnd: arg1-======-isExtensionDefinition  ^true-======-title  ^model isCurrent ifTrue: [ 'Current Iceberg credentials' ] ifFalse: [ 'Credentials of ' , model printString ]-======-cancelAction  -======-basicUrl: arg1  url := arg1-======-package  ^package-======-visitRemoval: arg1  arg1 definition removeFrom: self-======-publicKeyInput  ^publicKeyInput-======-okAction  credentialStore storeCredential: self credentials forHostname: self host.  tool refresh-======-initializeSourceDirectory  subdirectoryLabel := self newLabel label: 'Source directory'.  subdirectoryInputText := self newTextInput     ghostText: 'e.g., src';     autoAccept: true.  subdirectoryInputText text: self defaultSubdirectory-======-packageName  ^package-======-printOn: arg1  arg1 nextPutAll: version asString-======-isModified  ^self entity isModified-======-remoteModels  ^self entity remotes collect: [:arg1 |  (IceTipRemoteModel repositoryModel: self on: arg1) beCached ]-======-hasLocalBraches  ^self localBranches isNotEmpty-======-changesFromCommit: arg1  ^(self modifiedPackages collect: [:arg2 |  IceImageChange package: arg2 ]) asArray , (self referenceCommit changesFromCommit: arg1) asArray-======-selectionHasActualClass  ^self selectedChangeWrapper ifNil: [ false ] ifNotNil: [:arg1 |  arg1 item value contextClass notNil ]-======-showEmptyTab  emptyTab ifNil: [ emptyTab := self newEmptyTab ].  self removeAllCommitPanelTabs.  commitTabPanel addTab: emptyTab-======-textField  ^textField-======-versionLike: arg1 ifNone: arg2  ^self repository branch versionsFor: self detect: arg1 ifNone: arg2-======-diff: arg1  diff := arg1-======-includes: arg1  ^modifiedFilePaths includes: arg1-======-initialize  super initialize.  isAnonymous := false-======-isRemoval  ^true-======-commit: arg1  repository handleLibgitError: [ | tmp1 tmp2 |        tmp1 := self repositoryHandle lookupLocalBranch: self name.        tmp2 := self repositoryHandle revparse: arg1 id.        tmp1 setTargetId: tmp2 id.        self = repository head ifTrue: [ self repositoryHandle checkout_treeish: tmp2 opts: (LGitCheckoutOptions defaults                       checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force;                       yourself) ] ]-======-isMerged  ^mergeTree allSatisfy: [:arg1 |  arg1 isConflict not or: [ arg1 isResolved ] ]-======-tree  ^self mergeTree-======-definition  ^definition-======-remoteBranchNamed: arg1  ^self remoteBranchNamed: arg1 ifPresent: [:arg2 |  ^arg2 ] ifAbsent: [ IceBranchNotFound new           branchName: arg1;           signal ]-======-add: arg1  self selectedItems add: arg1.  self onSelectionChangedBlock ifNotNil: [:arg2 |  arg2 cull: arg1 cull: true ]-======-versionFor: arg1  ^self commit versionFor: arg1-======-authorLabel  ^authorLabel-======-execute  item ifNil: [ ^self ].  item entity inspect-======-contextClass  ^IceTipCommitContext-======-execute  self withErrorHandlingDo: [ self validateRemotesPresent.        (IceTipPullBrowser onRepositoryModel: self repositoryModel) openWithSpec ]-======-remotes  ^entity remotes-======-fetch  < noCache>  IceTipStandardAction new     repository: self entity;     message: ('Fetching incoming commits of {1}' format: {self name});     onSuccessRepositoryModified;     execute: [ self entity fetch ]-======-actionPanel  ^actionPanel-======-execute  browser accept-======-addShortcutsTo: arg1  self enableCommanderShortcutsIn: arg1-======-commitModels  ^(self entity branch incomingCommitsFrom: self remote) collect: [:arg1 |  (IceTipCommitModel repositoryModel: self repositoryModel on: arg1) beCached ]-======-isRootDefinition  ^true-======-mouseEnter: arg1  self flag: #bad.  ^self eventHandler ifNotNil: [ self eventHandler mouseEnter: arg1 fromMorph: self ]-======-definition  ^definition-======-badge: arg1  badge := arg1 = 0 ifTrue: [ nil ] ifFalse: [ arg1 ]-======-repositoryWillBeCreated: arg1  -======-onClick: arg1  onClickBlock := arg1-======-icon  ^item value icon-======-repoPath  ^self repository subdirectory-======-initialize  super initialize.  name := ''-======-subscribeToAnnouncements  self announcer when: IceTipDiffRefreshed send: #refreshWhenRepository: to: self-======-copyWithOnly: arg1  | tmp1 tmp2 |  tmp2 := arg1 collect: #value.  tmp1 := tree select: [:arg2 |  tmp2 includes: arg2 ].  ^self class new     sourceVersion: source;     targetVersion: target;     diffTree: tmp1;     yourself-======-execute  UIManager default informUser: 'Refreshing pull request list' during: [ tool refreshPullRequests ]-======-uptadeSelectedCommit: arg1  self diff selectedModel: (arg1 newSelectedRowIndexes ifNotEmpty: [:arg2 |  self commits widget dataSource elementAt: arg2 first ] ifEmpty: [ nil ])-======-announcer  ^announcer ifNotNil: #contents-======-validateMessageNotEmpty  self message ifEmpty: [ IceNoCommitMessage signal ]-======-execute  UIManager default informUser: 'Reverting change...' during: [ self repositoryModel entity workingCopy discardChanges: item ].  self announcer announce: (IceTipDiffEntryRemoved entry: item).  Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity)-======-removeFrom: arg1  arg1 removeClass: self-======-parent  ^parent-======-accept  ^self doCommit-======-snapshotFor: arg1  ^MCSnapshot empty-======-tagNameLabel  ^tagNameLabel-======-accept: arg1  ^arg1 visitMethodNode: self-======-isWorkingCopy  ^false-======-remoteName: arg1  remoteName := arg1-======-iconNamed: arg1  ^self class iconNamed: arg1-======-mergeWith: arg1 onLeft: arg2 onRight: arg3 onMerge: arg4  ^arg1 collect: arg3-======-visitTreeNode: arg1  self withNode: arg1 do: [ arg1 value accept: self ]-======-commit  ^self entity-======-rootItem: arg1  super rootItem: arg1.  self addSourceToRootItem-======-nameInput  ^nameInput-======-createBranch: arg1 inCommit: arg2  self handleLibgitError: [ (self repositoryHandle isUnborn and: [ arg2 isNoCommit ]) ifTrue: [ ^self createBranch: arg1 ].        self repositoryHandle createBranch: arg1 targetId: (LGitId fromHexString: arg2 gitRef) force: false.        ^(self branchNamed: arg1)           switch;           yourself ]-======-incomingCommits  ^#()-======-mergeWithMasterCheckbox: arg1  mergeWithMasterCheckbox := arg1-======-iconNamed: arg1  ^Smalltalk ui icons iconNamed: arg1-======-execute  ^IceGitHubRemoveBranchesAction new     repository: self repository;     remote: self remote;     execute-======-removeFromPatcher: arg1  self subclassResponsibility-======-version: arg1  version := arg1-======-backend: arg1  backend := arg1-======-title: arg1  title := arg1-======-iconForMergeable: arg1  arg1 = true ifTrue: [ ^self iconNamed: #smallOk ].  ^self iconNamed: #smallCancel-======-checkForRegistryConflicts  self subclassResponsibility-======-newRootCellFor: arg1  | tmp1 |  tmp1 := IceTipOutlineHeaderCellMorph dataSource: self item: arg1.  (self iconFor: arg1 data) ifNotNil: [:arg2 |  tmp1 addMorphBack: arg2 asMorph ].  tmp1 addMorphBack: (self toString: arg1 data) asMorph asReadOnlyMorph.  tmp1 addMorphBack: (AlignmentMorph newSpacer: Color transparent).  tmp1 addMorphBack: arg1 children size asMorph asReadOnlyMorph.  tmp1 addMorphBack: (Morph newBounds: (0 @ 0 corner: 20 @ 0) color: Color transparent) asReadOnlyMorph.  ^tmp1-======-doAccept  self validate.  commitishToTag createTag: self tagName thenDo: [:arg1 |  callback ifNotNil: [ callback value: arg1 ] ]-======-initializeCommitsTable  | tmp1 |  tmp1 := [:arg1 :arg2 |  arg2 isMerged ifTrue: [ arg1 asText ] ifFalse: [ arg1 asText allBold ] ].  commits widget     beResizable;     addColumn: (IceTipTableColumn id: 'Date & time' action: [:arg2 |  tmp1 value: arg2 datetime asLocalStringYMDHM value: arg2 ] width: 120 * World displayScaleFactor);     addColumn: (IceTipTableColumn id: 'Id' action: [:arg2 |  tmp1 value: arg2 shortId value: arg2 ] width: 50 * World displayScaleFactor);     addColumn: (IceTipTableColumn id: 'Author' action: [:arg2 |  tmp1 value: arg2 author value: arg2 ] width: 120 * World displayScaleFactor);     addColumn: (IceTipTableColumn id: 'Comment' action: [:arg2 |  tmp1 value: arg2 comment value: arg2 ] width: 300 * World displayScaleFactor);     dataSource: self newCommitsDataSource;     selectRowIndex: 1-======-delete  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Removing branch {1}' format: {self name});     onSuccessRepositoryModified;     execute: [ self entity delete ]-======-visitRemoval: arg1  arg1 definition removeFrom: self.  self visitChildrenOf: currentNode-======-nextChildNodeStartingFrom: arg1 suchThat: arg2 ifNone: arg3  | tmp1 |  tmp1 := self children.  (tmp1 indexOf: arg1) + 1 to: tmp1 size do: [:arg4 |  | tmp2 |        tmp2 := tmp1 at: arg4.        (arg2 value: tmp2) ifTrue: [ ^tmp2 ].        tmp2 nextNodeSuchThat: arg2 ifFound: [:arg5 |  ^arg5 ] ].  self parent ifNil: [ ^arg3 value ].  ^self parent nextChildNodeStartingFrom: self suchThat: arg2 ifNone: arg3-======-checkout: arg1  arg1 committish: self.  ^repository checkout: arg1-======-actionPanel: arg1  actionPanel := arg1-======-contents  ^''-======-addRemoteNamed: arg1 url: arg2  IceTipStandardAction new     repository: self entity;     message: 'Adding remote';     onSuccessRepositoryModified;     execute: [ | tmp1 |        tmp1 := IceGitRemote name: arg1 url: arg2.        self entity addRemote: tmp1.        tmp1 fetch ]-======-publicKey  ^publicKey ifNil: [ publicKey := self class defaultPublicKey ]-======-referencesSameRemoteLocationAs: arg1  ^(super referencesSameRemoteLocationAs: arg1) or: [ self httpsUrl = arg1 httpsUrl ]-======-properties  ^properties ifNil: [ properties := Dictionary new ]-======-cellColumn: arg1 row: arg2  ^FTCellMorph new     addMorphBack: ((self elementAt: arg2) at: arg1 id) asStringMorph;     yourself-======-hasUnknownCommit  ^self workingCopyState isUnknownCommitState-======-mergeWithLeftModification: arg1  ^IceConflictingOperation left: arg1 right: self-======-readContextParametersFromModel: arg1  self repositoryModel: arg1 repositoryModel-======-codeDirectory  self repositoryDirectory exists ifTrue: [ ^self basicCodeDirectory ] ifFalse: [ IceLocalRepositoryMissing signalFor: self ]-======-addLabel: arg1 value: arg2  items at: arg1 put: arg2.  self refresh-======-initializeWithJSON: arg1  json := arg1.  self initialize-======-title  ^'Pull {1}/{2} from {3}' format: {self model repositoryName .         self model branchName .         self model remoteName}-======-hasTagNamed: arg1  self subclassResponsibility-======-okAction  self credentials     username: self username;     password: self password.  credentialStore storeCredential: self credentials.  tool refresh-======-packageNameFromPackageDirectory  ^iceVersion packageName-======-pullFrom: arg1  | tmp1 |  repository fetch.  tmp1 := arg1 remoteBranchNamed: self name ifAbsent: [ ^self ].  repository createBranch: self name inCommit: tmp1 commit-======-isNoCommit  ^true-======-createRepository: arg1  (self canHandleType: arg1 type) ifTrue: [ ^Iceberg mcRepositoryFor: arg1 description ].  ^super createRepository: arg1-======-writeInDirectoryName: arg1 fileName: arg2 extension: arg3 visit: arg4  | tmp1 |  tmp1 := self directoryForDirectoryNamed: arg1.  self fileUtils writeStreamFor: arg2 , arg3 in: tmp1 do: [:arg5 |  self setFileStream: arg5.        arg4 value ]-======-max: arg1  max := arg1-======-isRightChosen  ^chosen = operation inverse-======-shortDescriptionWithDecoration  ^self addDecorationTo: (self entity isRemote ifTrue: [ self name copyAfter: $/ ] ifFalse: [ self name ])-======-initializeCommitPanel  commitTabPanel     addTab: (infoTab := self newInfoTab);     addTab: (diffTab := self newDiffTab           label: 'Diff from ancestor';           whenTabSelected: [ self refreshDiff ];           yourself)-======-iceCommitFrom: arg1  ^self repository iceCommitFrom: arg1-======-printOn: arg1  arg1     print: self class;     nextPut: $(;     nextPutAll: self package name.  arg1 nextPut: $)-======-passphrase  ^passphraseInput text-======-block  ^[:arg1 :arg2 :arg3 :arg4 |  job ensureStarted.  job min: 0.  job max: arg3.  job current: arg2.  job title: ('Checking out... ({1}/{2})' format: {arg2 .               arg3}).  job changed ]-======-readParametersFromContext: arg1  super readParametersFromContext: arg1.  tool := arg1 tool-======-