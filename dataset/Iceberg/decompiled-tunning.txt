nameOfBaseline: arg1  ^arg1 name allButFirst: self class baselinePrefix sizeonSuccessRepositoryModified  ^self onSuccessAnnounce: [ IceRepositoryModified for: self repository ]name  ^self iddataSource: arg1  dataSource := arg1addButton: arg1  addButton := arg1removeSSHCredential: arg1  sshCredentials removeKey: arg1 hostobtainPlaintextCredentials: arg1  self subclassResponsibilitycontextClass  | tmp1 |  tmp1 := Smalltalk globals at: self className ifAbsent: [ ^nil ].  self classIsMeta ifTrue: [ tmp1 := tmp1 classSide ].  ^tmp1selectionChanged: arg1  self basicSelectionChanged: (arg1 newSelectedIndexes ifNotEmpty: [:arg2 |  self typeList widget dataSource realElementAt: arg2 first ] ifEmpty: [ nil ])diff  ^diffModel ifNil: [ | tmp1 |        UIManager default informUser: 'Calculating diff' during: [ tmp1 := self calculateDiff ].        diffModel := IceTipCommitDiffModel repositoryModel: self repositoryModel on: tmp1 ]initialize  self beForCommit.  super initializebuilder  ^buildercontext: arg1  context := arg1globalCheckbox: arg1  globalCheckbox := arg1isDirectoryDefinition  ^trueoutgoingCommitsTo: arg1  ^self branch outgoingCommitsTo: arg1host: arg1  host := arg1target  ^targetvisitAddition: arg1  arg1 definition addToPatcher: patcher.  self visitChildrenOf: currentNodeinitialize  super initialize.  items := OrderedCollection newchildrenDo: arg1  self children do: arg1repositoryHandle  < repositoryHandleAccessor>  ^repository repositoryHandlename  ^self repository nameheadRemote  ^headRemoteorder  ^SmallInteger maxVal - 1000cellColumn: arg1 row: arg2  | tmp1 tmp2 |  tmp1 := self elementAt: arg2.  tmp2 := FTCellMorph new     cellInset: 5;     yourself.  (arg1 readIcon: tmp1) ifNotNil: [:arg3 |  tmp2 addMorphBack: arg3 asMorph ].  tmp2 addMorphBack: (IceTipLabelMorph new contentsAsIs: (arg1 read: tmp1)).  ^tmp2mergeWithLeftNoOperation: arg1  ^IceNonConflictingOperation operation: selfpackage: arg1  package := arg1url  ^'No PR selected'diffPanel  ^diffPaneladdPackage: arg1  | tmp1 |  tmp1 := repository subdirectoryPath segments asOrderedCollection.  tmp1 add: (repository writerClass directoryNameFor: arg1).  self addPath: (RelativePath withAll: tmp1)chooseUpgradePolicyProject: arg1 optionA: arg2 optionB: arg3  ^UIManager default chooseFrom: {('Use INCOMING version {1}' format: {arg2}) .         ('Use LOADED version {1}' format: {arg3})} values: {#useIncoming .         #useLoaded} message: ('There is already a project "{1}" in this installation.' format: {arg1}) title: 'Duplicated project!'defaultToolbarItemName  ^self class defaultToolbarItemNameresetHandle  handle := nilindexOfElementMatching: arg1  1 to: self numberOfRows do: [:arg2 |  (arg1 value: (self realElementAt: arg2)) ifTrue: [ ^arg2 ] ].  ^0commonAncestorWithCommit: arg1  repository handleLibgitError: [ | tmp1 |        tmp1 := [ (self repositoryHandle mergeBaseBetween: (LGitId fromHexString: self id) and: (LGitId fromHexString: arg1 id)) hexString ] on: LGit_GIT_ENOTFOUND do: [ nil ].        ^tmp1 ifNotNil: [ self repository lookupCommit: tmp1 ] ]withAllChildrenOf: arg1  ^arg1 children inject: {arg1} into: [:arg2 :arg3 |  arg2 , (self withAllChildrenOf: arg3) ]iconPanel: arg1  iconPanel := arg1addToChangeBuilder: arg1  self addProjectFileToChangeBuilder: arg1addModification: arg1 toPatcher: arg2  arg2 modifyDefinition: arg1 rightDefinition asMCDefinition to: arg1 leftDefinition asMCDefinitionisRightChosen  ^chosen = rightOperationinfo  ^{('Branch' -> self entity branch name) .   ('Location' -> self entity location pathString) .   ('Upstream' -> self entity upstream asString)}putFocusOrder  self focusOrder     add: usernameInput;     add: passwordInputname  ^self entity namevisitMethodDefinition: arg1  | tmp1 tmp2 tmp3 tmp4 |  tmp1 := arg1 className.  tmp2 := arg1 classIsMeta.  tmp3 := self isTrait: arg1 className.  tmp4 := self ensureMethodOwnerNamed: tmp1 isMeta: tmp2 isTrait: tmp3 isExtension: (self isExtension: arg1 className).  ^tmp4 addChild: (IceMethodDefinition className: arg1 className classIsMeta: arg1 classIsMeta protocol: arg1 protocol name: arg1 selector sourceCode: arg1 source)repository  ^repositorypackagesList  ^packagesListreasonPanel  ^reasonPanellazy  ^selfport  ^porttoErrorMessage: arg1  ^arg1 asText allBold makeAllColor: self colorErrorstore  ^storegitRef  ^self namecommitsDo: arg1  self rawResultsDo: [:arg2 |  arg1 value: (self commitFrom: arg2) ]prefix  ^'refs/remotes/'mergeWithLeftRemoval: arg1  self subclassResponsibilitynotifyPackageModified: arg1  ^self workingCopy notifyPackageModified: arg1initialize  super initialize.  messageText := '' asTexttab  ^tabbasicExecute  credentials := IceGitHubAPI ensureCredentials.  UIManager default informUser: ('Retrieving pull requests from {1}' format: {self remote}) during: [ (IceTipGitHubPullRequestListBrowser onRepository: self repository)           remote: self remote;           refreshPullRequests;           openWithSpec ]setModelBeforeInitialization: arg1  model := arg1initializeWidgets  super initializeWidgets.  commitList := self newIceTable.  commitInfoTabs := self instantiate: IceTipCommitInfoPresenter.  self initializeCommitList.  commitList widget onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self.  self focusOrder     add: commitList;     add: commitInfoTabs.  self refreshonAccept: arg1  acceptBlock := arg1optionB: arg1  optionB := arg1initializeWidgets  isAddition  ^truerefresh  remoteList items: self model remoteModelsname  ^'{1}>>{2}' format: {self entity origin name .         self entity selector}branchNamed: arg1 ifPresent: arg2 ifAbsent: arg3  self handleLibgitError: [ | tmp1 |        tmp1 := self repositoryHandle lookupLocalBranch: arg1 ifAbsent: [ nil ].        ^tmp1 ifNil: arg3 ifNotNil: [ arg2 value: (self basicNewBranchNamed: tmp1 name) ] ]mcRepository  | tmp1 |  self guessRegisteredRepository ifNotNil: [:arg1 |  arg1 isValid ifTrue: [ ^arg1 metacelloAdapter: self projectVersion ].        arg1 forget ].  tmp1 := self mcRepositoryClass location: self location.  ^tmp1 getOrCreateIcebergRepository metacelloAdapter: self projectVersionrepository  ^modelsnapshot  ^version snapshotForPackage: self packageisRemote  ^trueisCache  ^falsestoreMCVersion: arg1  | tmp1 |  repository internalStoreVersion: arg1.  tmp1 := OrderedCollection new.  repository subdirectory ifNotEmpty: [:arg2 |  tmp1 add: arg2 ].  tmp1 add: (repository writerClass directoryNameFor: arg1 package).  self addPath: (RelativePath withAll: tmp1)addPackages: arg1  arg1 keysDo: [:arg2 |  self addPackageNamed: arg2 ]printDescriptionOn: arg1  arg1     nextPut: $(;     nextPutAll: package;     nextPutAll: ', ';     nextPutAll: (self isLoaded ifTrue: 'loaded' ifFalse: 'not loaded');     nextPut: $)canActivateCommand: arg1  ^falseaddToPatcher: arg1  arg1 addDefinition: self asMCDefinitioncommitModels  self subclassResponsibilitytagNames  ^self tags collect: #namecypressClassOrTraitName: arg1  ^arg1 origin instanceSide name , (self cypressMethodClassExtension: arg1)isEmpty  ^modifiedFilePaths isEmptyisTag  ^trueicon  ^self class iconbranchName  ^self branch namepackage  ^packagebeForCommit  headTabContainer := IceTipHistoryDiffFromHead tab: headTab.  ancestorTabContainer := IceTipHistoryDiffToAncestor tab: ancestorTabisWorkingCopy  ^trueloadFromStore  | tmp1 |  self flag: #implementAnEncryptedVersion.  storeFile ifNil: [ ^self ].  storeFile exists ifFalse: [ ^self ].  tmp1 := FLMaterializer materializeFromFileNamed: storeFile resolve pathString.  plainCredentials := tmp1 at: 1.  sshCredentials := tmp1 at: 2doAccept  IceConvertFormatAction new     repository: self repository;     branchName: self branchName;     format: #tonel;     mergeWithCurrentBranch: self mergeWithMasterCheckbox state;     executeregister  self checkForRegistryConflicts.  self class registerRepository: self.  Iceberg announcer announce: (IceRepositoryCreated repository: self).  ^selfentryByName: arg1  ^self children at: arg1 ifAbsentPut: [ self class new initializeWithParent: self entryName: arg1 ]iconForStatus: arg1  arg1 = 'success' ifTrue: [ ^self iconNamed: #testGreen ].  arg1 = 'failure' ifTrue: [ ^self iconNamed: #testRed ].  arg1 = 'pending' ifTrue: [ ^self iconNamed: #testYellow ].  ^self iconNamed: #testNotRunshowFilterFieldFromKeystrokeEvent: arg1  | tmp1 |  tmp1 := arg1 keyCharacter asString.  self textField takeKeyboardFocus.  self textField text: self textField text , tmp1.  self flag: #hack.  self textField textArea cursorEnd: arg1branchName  self entity isMissing ifTrue: [ ^self class unknownBranchLabel ].  ^self entity head descriptioncommitFrom: arg1  ^self repository commitFromGitCommit: arg1keepAllCurrentVersion  self model mergeTree do: [:arg1 |  arg1 isConflict ifTrue: [ arg1 selectLeft ] ].  self changed: #changes.  self updateSourcelabelColor  ^labelColor ifNil: [ labelColor := Smalltalk ui theme textColor ]credentialsList  ^credentialsListisLeaf  ^self isGroup nottitle  ^'Checkout ' , super title asLowercasecommitsDo: arg1  self maxNumber ifNil: [ super commitsDo: arg1 ] ifNotNil: [ | tmp1 |        tmp1 := 0.        super commitsDo: [:arg2 |  arg1 value: arg2.              tmp1 := tmp1 + 1.              tmp1 == self maxNumber ifTrue: [ ^self ] ] ]canRevertChanges  ^source canRevertChangescompatibleUsername  ^'CompatibleUserName'isUnknownCommit  ^falsedisplayingProgressString  ^'Comparing changes of ' , filePathStringheadDescription  ^self head descriptionwithOnlyNewBranch  types := self allTypes select: #isNewBranch.  typeList widget dataSource elements: types.  typeList widget refreshdefinition  self subclassResponsibilityremoteModels  ^self repositoryModel remoteModelsprojectName: arg1  projectName := arg1hasMonticelloMetadata  ^falsebranchNamed: arg1 ifPresent: arg2  ^self branchNamed: arg1 ifPresent: arg2 ifAbsent: [ self ]initialExtent  ^(350 @ (self class inputTextHeight * 5 + self class buttonHeight)) scaledByDisplayScaleFactorrefreshPackages  | tmp1 |  tmp1 := self referenceCommit isCollection ifTrue: [ (self referenceCommit flatCollect: [:arg1 |  arg1 packages ]) asSet ] ifFalse: [ self referenceCommit project packages ].  self packages \ tmp1 do: [:arg1 |  self basicRemovePackage: arg1 ].  tmp1 \ self packages do: [:arg1 |  self basicAddPackage: arg1 ]initialize  super initialize.  shouldIgnoreNotifications := false.  packages := Dictionary new.  referenceCommit := repository newNoCommit.  self basicSetProject: referenceCommit project.  properties := referenceCommit properties asBornPropertiesnewToolbarButtonOn: arg1  | tmp1 |  tmp1 := (IceTipToolbarItemButtonMorph on: self getState: nil action: #execute)     helpText: self help;     font: arg1 toolbarItemFont;     beIconTop;     hResizing: #rigid;     vResizing: #spaceFill;     borderWidth: 0;     borderColor: Color transparent;     cellPositioning: #center;     width: arg1 toolbarItemSize;     yourself.  arg1 displayMode configureButton: tmp1 item: self.  ^tmp1mergeWithCurrentBranch: arg1  mergeWithCurrentBranch := arg1getOrCreateIcebergRepository  ^self repositorybuildForPackages: arg1  | tmp1 tmp2 |  tmp1 := IceNode value: IceRootDefinition new.  tmp2 := IceNode value: IceRootDefinition new.  (arg1 collect: [:arg2 |  IceImageChange package: arg2 ]) do: [:arg3 |  arg3 accept: (IceChangeImporter new                 version: source;                 diff: self;                 parentNode: tmp1;                 yourself).        arg3 accept: (IceChangeImporter new                 version: target;                 diff: self;                 parentNode: tmp2;                 yourself) ].  tree := self diff: tmp1 with: tmp2body  ^''isValid  self flag: #todo.  ^self isMissing notinitializeWidgets  super initializeWidgets.  diffPanel := self instantiate: IceTipDiffPanel on: self model diff.  actionPanel := self newIceActionPanel.  actionPanel addAction: (button := self newActionButton).  self whenBuiltDo: [:arg1 |  self addShortcutsTo: arg1 widget ].  self focusOrder     add: self actionPanel;     add: self diffPanelpullFrom: arg1  | tmp1 |  arg1 fetchBranch: self.  tmp1 := arg1 remoteBranchNamed: self name ifAbsent: [ ^self ].  self repository workingCopy mergeCommit: tmp1 commitisInMerge  ^falseinitializeWidgetsContents  spacePanel := PanelMorph new asSpecAdapter.  self initializeCurrentBranchLabel.  remotePanel := self instantiate: IceTipSelectRemotePresenter on: self selectRemoteModel.  remotePanel remoteList whenSelectedItemChanged: [:arg1 |  self useRemote: arg1 ].  branchLabel := self newLabel label: 'Issue number:'.  issueNumberText := self newTextInput     ghostText: 'e.g., 123';     autoAccept: true.  issueLabel := self newLabel label: 'Title:'.  issueText := self newTextInput     ghostText: 'e.g., 123-github-issue';     autoAccept: true.  issueNumberText whenBuiltDo: [:arg2 |  arg2 widget wrapFlag: false ].  issueText whenBuiltDo: [:arg2 |  arg2 widget wrapFlag: false.        arg2 widget enabled: false ].  issueNumberText textHolder whenChangedDo: [:arg3 |  self validateIssue: arg3 ]imageChanges  ^(source loadedPackages collect: [:arg1 |  IceImageChange package: arg1 ]) asArraysend  | tmp1 |  tmp1 := {('title' -> self title) .   ('head' -> (self headRemote owner , ':' , self headBranchName)) .   ('base' -> self baseBranchName) .   ('body' -> self body)} asDictionary.  ^IceGitHubAPI new     credentials: self credentials;     addPullRequest: self baseRemote owner project: self baseRemote projectBasename data: tmp1statusLabel  ^statusLabelvalidate  self validateLocation.  self validateAlreadyPresentAndNotGit.  self validateNotDuplicatedpackage: arg1  package := arg1reset  objects := SmallDictionary newblock  ^[:arg1 :arg2 :arg3 :arg4 |  job ensureStarted.  job min: 0.  job max: arg2.  job current: arg1.  job title: (self title , ' ({1}/{2})' format: {arg1 .               arg2}).  job changed.  0 ]notifyPackageModified: arg1  self flag: #todo.  self shouldIgnoreNotifications ifTrue: [ ^false ].  (self includesInWorkingCopyPackageNamed: arg1) ifTrue: [ | tmp1 |        tmp1 := self packageNamed: arg1.        tmp1 isDirty ifFalse: [ tmp1 beDirty.              ^true ] ].  ^falserepository: arg1  repository := arg1help  ^self class helprepository  ^repositoryisAncestorOf: arg1  ^self commit isAncestorOf: arg1 commitreferencesSameRemoteLocationAs: arg1  ^(super referencesSameRemoteLocationAs: arg1) or: [ self httpsUrl sameAs: arg1 httpsUrl ]commitTabPanel  ^commitTabPanelremoteTrackedBranches  self subclassResponsibilityauthorLabel: arg1  authorLabel := arg1nextConflict  | tmp1 tmp2 |  tmp2 := self selectedChangeWrapper ifNil: [ IceMergeListWrapper with: model mergeTree children first model: model ].  tmp1 := tmp2 item nextNodeSuchThat: [:arg1 |  arg1 value isConflict and: [ arg1 value isResolved not ] ] ifNone: [ ^nil ].  ^IceMergeListWrapper with: tmp1 model: modelfillContextMenu: arg1 using: arg2  self allBaselines do: [:arg3 |  self fillDefaultMenu: arg1 using: arg2 baseline: arg3.        self fillGroupMenu: arg1 using: arg2 baseline: arg3 ]indexOfElement: arg1  1 to: self numberOfRows do: [:arg2 |  (self realElementAt: arg2) = arg1 ifTrue: [ ^arg2 ] ].  ^0readContextParametersFromModel: arg1  super readContextParametersFromModel: arg1.  repositoryDetached := arg1 isRepositoryDetacheddetailedInfo  ^{('Origin' -> self url) .   ('Remote host' -> (self port = self class defaultPort ifTrue: [ self host ] ifFalse: [ self host , ':' , self portName ])) .   ('Repo Owner' -> self owner)}setModelBeforeInitialization: arg1  model := arg1mergeButton  ^mergeButtonprotocolLabel: arg1  protocolLabel := arg1isMethodDefinition  ^truebuild  | tmp1 tmp2 |  tmp1 := IceNode value: IceRootDefinition new.  tmp2 := IceNode value: IceRootDefinition new.  (source changesTo: target) do: [:arg1 |  arg1 accept: (IceChangeImporter new                 version: source;                 diff: self;                 parentNode: tmp1;                 yourself).        arg1 accept: (IceChangeImporter new                 version: target;                 diff: self;                 parentNode: tmp2;                 yourself) ].  tree := self diff: tmp1 with: tmp2repository  ^repositorybeSwitchAndMerge  self mergeType: IceTipMergeType switchAndMergeasString  ^item value descriptionisLeftChosen  self subclassResponsibilitysingleCommit  ^self referenceCommitremoteName  ^self nameText text trimmedpackage  ^MCPackage named: self iceVersion packageNameaccept  | tmp1 |  tmp1 := self titlePanel text trim.  tmp1 ifEmpty: [ UIManager default alert: 'You need to specify a title for the pull request.' title: 'Error'.        ^self ].  acceptBlock ifNotNil: [ acceptBlock cull: self createPullRequest ].  self window deletehandleUnauthorized: arg1  | tmp1 |  arg1 isSuccess ifTrue: [ ^self ].  arg1 status ~= 401 ifTrue: [ ^self ].  tmp1 := IcePlaintextCredentials new.  (IceCredentialsProvider defaultForHost: 'github.com') obtainPlaintextCredentials: tmp1.  IceAuthenticationError signal: 'Retry to use the new credentials'writeDefinitions: arg1  | tmp1 tmp2 tmp3 tmp4 tmp5 |  self writeBasicDefinitions: arg1.  tmp2 := OrderedCollection new.  tmp3 := OrderedCollection new.  tmp5 := self classDefinitions , self traitDefinitions.  self methodDefinitions keysAndValuesDo: [:arg2 :arg3 |  tmp5 at: arg2 ifAbsent: [ tmp2 add: arg2.              tmp3 addAll: arg3 ] ].  tmp2 do: [:arg2 |  self methodDefinitions removeKey: arg2 ].  self writeMethodHolderDefinitions: self traitDefinitions extension: '.trait' to: '' do: [:arg4 :arg5 |  self writeTraitDefinition: arg4 to: arg5 ].  self writeMethodHolderDefinitions: self classDefinitions extension: '.class' to: '' do: [:arg4 :arg5 |  self writeClassDefinition: arg4 to: arg5 ].  tmp1 := '.extension'.  tmp4 := Dictionary new.  tmp3 do: [:arg6 |  | tmp6 |        (tmp4 at: arg6 className ifAbsent: [ tmp4 at: arg6 className put: OrderedCollection new ]) add: arg6.        arg5 := arg6 className , tmp1 , self fileUtils pathNameDelimiter asString.        self writeExtensionClassDefinition: arg6 to: arg5 ].  tmp4 keysAndValuesDo: [:arg2 :arg7 |  | tmp6 tmp7 |        tmp7 := self fileNameMapFor: arg7.        arg7 do: [:arg6 |  | tmp8 tmp9 |              tmp8 := (tmp7 at: arg6 classIsMeta) at: arg6 selector.              arg5 := arg6 className , tmp1 , self fileUtils pathNameDelimiter asString.              tmp9 := arg5 , (arg6 classIsMeta ifTrue: [ 'class' ] ifFalse: [ 'instance' ]) , self fileUtils pathNameDelimiter asString.              self writeMethodDefinition: arg6 to: tmp9 filename: tmp8 ] ]writeTraitDefinition: arg1 to: arg2  self writeInDirectoryName: arg2 fileName: 'README' extension: '.md' visit: [ self writeClassComment: arg1 ].  self writeInDirectoryName: arg2 fileName: 'properties' extension: self propertyFileExtension visit: [ self writeTraitDefinition: arg1 ]push  self pushTo: self upstream remotevisitCloneRemoteNotFound: arg1  self visitGenericError: arg1localRepository: arg1  localRepository := arg1count: arg1  | tmp1 |  tmp1 := 0.  (arg1 value: self value) ifTrue: [ tmp1 := 1 ].  self childrenDo: [:arg2 |  tmp1 := tmp1 + (arg2 count: arg1) ].  ^tmp1calculateChanges  | tmp1 tmp2 tmp3 |  mergeTree ifNotNil: [ ^self ].  tmp1 := (self leftCommit commonAncestorWith: mergeCommit) ifNil: [ IceNoCommit new ].  tmp2 := self sourceVersion diffTo: tmp1.  tmp3 := self targetVersion diffTo: tmp1.  mergeTree := self merge: tmp2 tree into: tmp3 tree.  changesToWorkingCopyTree := self isInverseMerge ifTrue: [ self merge: tmp3 tree into: tmp2 tree ] ifFalse: [ mergeTree ]referenceCommit  ^repository workingCopy referenceCommitwindowIcon  ^self iconNamed: #komitterSmalltalkhubRemotecreateMergeBranchTypes  | tmp1 |  tmp1 := {((IceTipMergeBranchPanel on: self model)     title: 'Local';     withoutHead;     icon: (self iconNamed: #branch);     yourself)} , (self model remoteModels collect: [:arg1 |  (IceTipMergeBranchPanel on: arg1)                 title: arg1 name;                 icon: (self iconNamed: #remote);                 yourself ]).  tmp1 do: [:arg1 |  arg1 onAccept: [ self window delete ] ].  ^tmp1propertyFileExtension  ^MCFileTreeRepository defaultPropertyFileExtensionisAnnouncementSuspended: arg1  suspendAll ifTrue: [ ^true ].  suspendedConditions ifEmpty: [ ^false ].  ^suspendedConditions anySatisfy: [:arg2 |  arg2 value: arg1 ]isTag  ^falseonAccept: arg1  acceptBlock := arg1mergeWithOperation: arg1  ^arg1 mergeWithLeftNoOperation: selfbody  ^self jsonAt: #bodycanReadProjectFromCommitish: arg1  self subclassResponsibilitycommitsDo: arg1  actualClass  ^leftOperation definition actualClasscommonAncestorWith: arg1  ^arg1readIcon: arg1  ^self icon ifNotNil: [ self icon value: arg1 ]fromText  ^fromTexticon: arg1  icon := arg1mcRepository  | tmp1 tmp2 tmp3 |  tmp2 := self splitRootAndSubdirectoryFromLocation.  tmp3 := tmp2 first asFileReference asAbsolute.  tmp1 := IceRepository registry detect: [:arg1 |  arg1 location notNil and: [ arg1 location asAbsolute = tmp3 ] ] ifNone: [ (IceRepositoryCreator new           location: tmp2 first;           subdirectory: tmp2 second;           ensureProjectFile;           createRepository) register ].  ^tmp1 metacelloAdapter: tmp1 head descriptioncomment  self subclassResponsibilityworkingCopyDiff  < noCache>  ^IceTipWorkingCopyDiffModel repositoryModel: self on: self entityvisitRemoval: arg1  self visitAddition: arg1credentials  ^credentialspackages  ^self entity workingCopy packagesversionFor: arg1  ^IceSavedPackageVersion fromCommit: self package: arg1checkout: arg1  basicExecute  self repositoryModel createSourceDirectory.  self repository workingCopy refreshProjectFromRepository.  Iceberg announcer announce: (IceRepositoryModified for: self repository)asSpotterCandidateLink  ^GTSpotterCandidateLink value: selfobtainSshCredentials: arg1  LGitNoCredentialsProvided signalproperties  ^propertiestoString: arg1  ^arg1 basenameconfigureButton: arg1 item: arg2  self subclassResponsibilityrefreshDiffFromHeadLabel  headTabContainer updateLabelOn: selectedModelinitializeWidgets  remoteLabel := self newLabel label: 'Remote:'.  remoteList := self newDropList.  remoteList     items: self model remoteModels;     displayBlock: [:arg1 |  arg1 descriptionWithDecoration ].  addButton := self newButton icon: self icon.  addButton action: [ self addRemote ].  remoteList setSelectedItem: self model remoteModel.  self focusOrder add: remoteListcreateSourceDirectory  < noCache>  entity createSourceDirectoryname  ^self entity namebuildFull  | tmp1 tmp2 |  tmp1 := IceNode value: IceRootDefinition new.  tmp2 := IceNode value: IceRootDefinition new.  self imageChanges , (source referenceCommit changesTo: target) asArray do: [:arg1 |  arg1 accept: (IceChangeImporter new                 version: source;                 diff: self;                 parentNode: tmp1;                 yourself).        arg1 accept: (IceChangeImporter new                 version: target;                 diff: self;                 parentNode: tmp2;                 yourself) ] displayingProgress: [:arg1 |  arg1 displayingProgressString ].  tree := self diff: tmp1 with: tmp2diffFromHead  | tmp1 |  tmp1 := IceTipCommitModel on: self entity commit.  ^tmp1 diffFromHeadpost: arg1 with: arg2  ^self jsonContentsWithValidationDo: [ (self newRequestTo: arg1)           in: arg2;           post;           response ]newProjectRegistration  ^IceMetacelloProjectRegistration new     version: builder commitishName;     yourselfpackageNames  ^self commit packageNamesexecute  (IceTipFiletreeToTonelDialog on: self repositoryModel entity) openDialogWithSpecisUnknownCommit  ^trueopen  self openWithSpecproperties: arg1  properties := arg1at: arg1 put: arg2  arg2 parent: self.  childrenDictionary at: arg1 put: arg2tagModels  ^self entity tags collect: [:arg1 |  (IceTipTagModel repositoryModel: self on: arg1) beCached ]httpsUrl  ^self urlitem: arg1  item := arg1previewCheckout  < noCache>  (IceTipCheckoutPreviewBrowser onBranch: self) openWithSpecbodyLabel: arg1  bodyLabel := arg1newBaselineGroupCommand: arg1  ^IceTipMetacelloInstallBaselineGroupCommand new     repositoryModel: self repositoryModel;     package: arg1;     yourselfexecute  IceTipRegisterRepositoryDialog new openDialogWithSpecrefresh  repository: arg1  repository := arg1refreshCommitInfo  infoTab contents: (selectedModel info ifNotNil: [ (IceTipReadOnlyForm items: selectedModel info) buildWithSpec ])withNode: arg1 do: arg2  | tmp1 |  tmp1 := currentNode.  currentNode := arg1.  arg2 ensure: [ currentNode := tmp1 ]existingProjectRegistration  | tmp1 |  tmp1 := IceLibgitRepository new location: builder locationToUse.  ^IceMetacelloProjectRegistration new     version: tmp1 head description;     yourselfcheckForRegistryConflicts  self location ifNil: [ ^self ].  self class registry detect: [:arg1 |  arg1 location = self location ] ifFound: [:arg1 |  self origin = arg1 origin ifTrue: [ IceDuplicatedRepository signal: ('You already have an Iceberg repository at {1} and with the same origin URL. If you really whant create another one, please locate it in a different directory.' format: {self location pathString}) ] ifFalse: [ IceDuplicatedRepository signal: ('You already have an Iceberg repository at {1} but with a different origin URL.You provided {2} and the original repository''s url is {3}.' format: {self location .                           self origin .                           arg1 origin}) ] ]newCellFor: arg1  | tmp1 |  tmp1 := FTIndentedCellMorph new.  tmp1 indentBy: arg1 depth * 16.  tmp1 addMorphBack: (self buttonFor: arg1).  tmp1 addMorphBack: (self newSelectionMorphFor: arg1).  (self iconFor: arg1 data) ifNotNil: [:arg2 |  tmp1 addMorphBack: arg2 asMorph ].  tmp1 addMorphBack: (self toString: arg1 data) asMorph.  ^tmp1contents  ^self subclassResponsibilityexecute  | tmp1 |  tmp1 := self dataSource elements species new.  self dataSource elements do: [:arg1 |  (self matches: arg1) ifTrue: [ tmp1 add: arg1 ] ].  ^self dataSource copy     elements: tmp1;     yourselfisPackageDefinition  ^truedelete  self forgetisMeta  ^isMetamerge  ^self repository workingCopy mergeCommit: self commitremoveMethod: arg1  arg1 asMCDefinition unloaduseIncoming  ^self resume: self builder addLocalRepositoryAndCheckoutvalidateCanCommit  self head isDetached ifTrue: [ IceWorkingCopyDesyncronized signal ]pushCheckbox: arg1  pushCheckbox := arg1mergeType  ^mergeType ifNil: [ IceTipMergeType default ]project  self subclassResponsibilityinitialize  retries := 3preferredColor  ^self item value preferredColorpatchButton  ^patchButtonparseSSHLocation: arg1  | tmp1 |  tmp1 := arg1 substrings: '@:'.  user := tmp1 first.  host := tmp1 second.  path := self pathFrom: tmp1 thirdremoteNamed: arg1 ifAbsent: arg2  self handleLibgitError: [ | tmp1 |        [ tmp1 := (LGitRemote of: self repositoryHandle named: arg1) lookup.        ^(IceGitRemote name: tmp1 remoteName url: tmp1 url)           localRepository: self;           yourself ] on: LGitObjectNotInitialized do: [ ^arg2 value ] ]properties  ^self commit propertiesname  ^self entity namereadParametersFromContext: arg1  super readParametersFromContext: arg1.  selectedCommitish := arg1 itemuserNameInputText  ^userNameInputTextmergeWithLeftRemoval: arg1  ^IceNonConflictingOperation operation: arg1location  ^locationcontents  ^self target perform: super contentsselectedCheckoutStrategy  ^selectedCheckoutStrategyisLocal  ^truecommits  ^#()mouseEnter: arg1  self currentHand showTemporaryCursor: Cursor webLinkinitializeWidgets  messageLabel := self newLabel.  messageText := self newText autoAccept: true.  typeLabel := self newLabel.  typeList := self newDropList.  acceptButton := self newButton.  messageLabel label: 'Comment'.  messageText whenBuiltDo: [:arg1 |  arg1 widget withGhostText: self class messageGhostText ].  typeLabel label: 'Merge type'.  acceptButton label: 'Accept pull request'.  acceptButton action: [ self accept ].  self focusOrder     add: messageText;     add: typeList;     add: acceptButtoninitialExtent  ^(700 @ 700) scaledByDisplayScaleFactorbeDirty: arg1  isDirty := arg1labelFor: arg1  ^self subclassResponsibilityhasChanges  ^hasChanges or: [ initialTree isNil or: [ self children anySatisfy: #hasChanges ] ]basicAddPackage: arg1  self packagesDictionary at: arg1 name put: arg1at: arg1 ifPresent: arg2  ^objects at: arg1 ifPresent: arg2ancestors  ^iceCommit ancestorIdscommitWithMessage: arg1 andParents: arg2  self subclassResponsibilityurlLabel  ^urlLabelinitialize  super initialize.  self resethash  ^self name hashaccept: arg1  ^arg1 visitNoModification: selfpushTo: arg1  repository handleLibgitError: [ self basicPushTo: arg1 ]description  ^'Github operations'cloneRepository  IceGitClone new     location: self locationToUse;     url: self remoteToUse url;     execute.  self repository location: self locationToUse.  self commitishName ifNotNil: [ self repository switchToCommitishNamed: self commitishName ].  self repository pluginManager repositoryWillBeCreated: self repository.  self doEnsureProject.  self repository workingCopy initializePackagesFromRepository.  self repository pluginManager repositoryWasCreated: self repository.  ^self repositoryactionColumn: arg1  self flag: #todo.  self tableRefreshrepository  ^repository ifNil: [ repository := IceLibgitRepository new ]repositoryModel  ^repositoryModelsubdirectory: arg1  self project sourceDirectory: arg1commit  ^self entity commitdiffContentsLeft: arg1 right: arg2  diffPanel     leftText: '';     rightText: '';     leftText: arg1;     rightText: arg2visitDirectoryDefinition: arg1  self visitChildrenOf: currentNodeisRepositoryOperational  ^self isRepositoryMissing not and: [ self isRepositoryDetached not and: [ self hasUnbornProject not ] ]initializePresenter  super initializePresenter.  self titlePanel text: self branch shortname.  self headForkList     items: self availableRemotes;     displayBlock: [:arg1 |  arg1 owner , '/' , arg1 projectName ];     setSelectedItem: self headRemote.  self headBranchList     items: self availableBranchNames;     displayBlock: [:arg1 |  arg1 ];     setSelectedItem: self defaultHeadBranchName.  self baseForkList     items: self availableRemotes;     displayBlock: [:arg1 |  arg1 owner , '/' , arg1 projectName ];     setSelectedItem: self baseRemote.  self baseBranchList     items: self availableBranchNames;     displayBlock: [:arg1 |  arg1 ];     setSelectedItem: self defaultBaseBranchName.  self bodyPanel text: self obtainLastCommitMessageremoveFromPatcher: arg1  isMeta ifTrue: [ ^true ].  arg1 removeDefinition: self asMCDefinitioninitializePresenter  super initializePresenter.  self pullRequests widget onAnnouncement: FTSelectionChanged send: #uptadeSelectedPullRequest: to: self.  self pullRequests widget onAnnouncement: FTStrongSelectionChanged send: #strongSelection: to: selflocationToUse  ^self location ifNil: [ self defaultLocation ]properties  ^self workingCopy repositoryPropertiesmergeWithBranch: arg1  self shouldBeImplementedprovideSshAgentCredentialsTo: arg1  tries := tries + 1.  tries >= 3 ifTrue: [ Transcript           show: 'aborting';           cr.        LGitNoCredentialsProvided signal: 'No ssh-agent credentials found.' ]contextClass  self subclassResponsibilityhost  ^hostcontextClass  ^IceTipPullContextvalidateNotDuplicated  (self remoteToUse isNotNil and: [ self locationToUse exists and: [ self locationToUse hasChildren ] ]) ifTrue: [ IceDuplicatedRepository signal: ('You already have an Iceberg repository at {1}. If you really want create another one, please locate it in a different directory.' format: {self locationToUse pathString}) ]optionA  ^optionAtitle  ^self model ifNotNil: [ 'History of {1}' format: {self model name} ] ifNil: [ 'History' ]detailedInfo  ^#()addModification: arg1 toPatcher: arg2  arg2 removeDefinition: arg1 rightDefinition asMCDefinition.  ^arg2 addDefinition: arg1 leftDefinition asMCDefinitioncommitAt: arg1  ^self lookupCommit: arg1initializeRepository: arg1 credentials: arg2 headRemote: arg3  repository := arg1.  credentials := arg2.  headRemote := arg3.  self initializepath  ^pathmajorButton  ^majorButtongoferReferences  self repository head description = projectVersion ifFalse: [ (self repository commitishNamed: projectVersion) checkoutWithStrategy: IceCheckoutDoNotLoadPackages new ].  ^self repository workingCopy packages collect: [:arg1 |  GoferResolvedReference name: arg1 latestVersion info name repository: self ]shortId  ^self id first: 7shortCommitId  ^self entity shortIdpushRemoteName  ^self entity branch upstream namepropertiesFilePath  ^repository project sourceDirectoryPath / self class propertiesFileNameaccept  self username isEmptyOrNil ifTrue: [ ^UIManager default alert: 'user.name is required.' ].  self email isEmptyOrNil ifTrue: [ ^UIManager default alert: 'user.email is required.' ].  (model getConfigurationGlobal: self isGlobal)     username: self username;     email: self email.  self window delete.  acceptCallback ifNotNil: [ acceptCallback value ]initialize  model ifNil: [ model := IceCredentialStore current ].  super initializeobtainSshCredentials: arg1  self subclassResponsibilitydescription  ^definition nameisLocal  ^self isRemote notextent  ^25 @ 25= arg1  ^self species = arg1 species and: [ self leftDefinition = arg1 leftDefinition ]browsePackage  < noCache>  self entity browseacceptButton  ^acceptButtoncredentials  ^credentialsaddPullRequest: arg1 project: arg2 data: arg3  ^self post: 'repos/' , arg1 , '/' , arg2 , '/pulls' with: [:arg4 |  arg4           entity: (ZnEntity text: (STON toJsonString: arg3));           contentType: ZnMimeType applicationJson ]provideSshCredentialsTo: arg1  tries := tries + 1.  tries >= 3 ifTrue: [ Transcript           show: 'aborting';           cr.        LGitNoCredentialsProvided signal: 'There where already three failed attempts, aborting' ].  tries = 1 & self sshCredentials isPresent ifTrue: [ arg1 readFrom: self sshCredentials ] ifFalse: [ self obtainSshCredentials: arg1 ]hostInput  ^hostInputancestorIds: arg1  ancestorIds := arg1selectAll  selectedItems := Set new.  self rootItem children do: [:arg1 |  self selectAllChildrenOf: arg1 ].  self tableRefreshbaseForkList: arg1  baseForkList := arg1initializeWidgets  listPanel := self instantiate: FastTablePresenter.  listPanel icons: [:arg1 |  self createCheckboxFor: arg1 ].  selectButton := self newButton.  selectButton     label: self class buttonLabel;     action: [ self confirmSelection ].  self focusOrder     add: listPanel;     add: selectButtonopenNonModal  ^self openDialogWithSpec     okAction: [ self okAction ];     cancelAction: [ self cancelAction ];     whenClosedDo: [ self closeAction ];     centeredmerger: arg1  merge := arg1basicExecute  self validateCanCommit.  UIManager default informUser: 'Commiting...' during: [ self repository commitChanges: (diff copyWithOnly: items) withMessage: message ].  Iceberg announcer announce: (IceRepositoryModified for: self repository)locationIfPresent: arg1 ifAbsent: arg2  self location ifNil: [ ^arg2 value ].  ^self location exists ifTrue: [ arg1 value: location ] ifFalse: [ arg2 value ]headLabel  ^headLabelbranchModels  ^self branches collect: [:arg1 |  (IceTipBranchModel repositoryModel: self repositoryModel on: arg1) beCached ]entry  ^entrydefaultSubdirectory  ^IceLibgitRepository defaultCodeSubdirectoryremovePackage: arg1  (repository location resolvePath: arg1 path) ensureDeleteAllnewContextWithSelection: arg1  ^self newContext     item: arg1;     yourselfupdateOkButton  acceptButton ifNil: [ ^self ].  acceptButton enabled: self isOkEnabledisLeftChosen  ^chosen = leftOperationcommitish: arg1  self assert: arg1 isNotNil.  commitish := arg1description  ^self workingCopyState descriptionlocalBranches  self handleLibgitError: [ self repositoryHandle isUnborn ifTrue: [ ^{self head} ].        ^OrderedCollection new: 10 streamContents: [:arg1 |  self repositoryHandle localBranchesDo: [:arg2 :arg3 |  arg1 nextPut: (self basicNewBranchNamed: arg2 name) ] ] ]incomingCommits  ^self entity incomingCommitsisEditing  ^repository isNil notisUnknownCommitState  ^trueheadHistory  ^headHistory ifNil: [ headHistory := IceHistory on: repository headCommit repository: repository ]mergeWithLeftModification: arg1  arg1 leftDefinition = self leftDefinition ifTrue: [ ^IceNonConflictingOperation operation: arg1 ].  ^IceConflictingOperation left: arg1 right: selfdiffFromHead  | tmp1 tmp2 |  tmp1 := self repositoryModel entity headCommit.  tmp2 := self calculateDiff: [ tmp1 diffTo: self entity ].  ^IceTipCommitDiffModel repositoryModel: self repositoryModel on: tmp2directoryPathStringForPackage: arg1  ^self subdirectory isEmptyOrNil ifTrue: [ self directoryNameForPackage: arg1 ] ifFalse: [ self subdirectory , '/' , (self directoryNameForPackage: arg1) ]addEntryNamed: arg1 withContents: arg2  self builder addEntry: (LGitBlob of: self repository fromString: arg2) filename: arg1.  self changes add: arg1.  hasChanges := truerepositoryDirectory: arg1  repositoryDirectory := arg1datetime  ^iceCommit datetimeisDetached  ^self entity workingCopy isDetached or: [ self entity head isDetached ]badgeFont  ^badgeFont ifNil: [ badgeFont := self newBadgeFont ]onSuccess: arg1  successBlock := arg1addChild: arg1  ^self addNode: (self class value: arg1)mouseEnter: arg1  self currentHand showTemporaryCursor: Cursor webLink.  super mouseEnter: arg1isDetached  ^self isBranch notmcVersionFor: arg1  ^repository mcVersionFor: arg1basicNewBranchNamed: arg1  ^IceGitLocalBranch named: arg1 inRepository: selftitle  ^titleheadForkList: arg1  headForkList := arg1head  self subclassResponsibilitywriterClass  ^format = #tonel ifTrue: [ IceLibgitTonelWriter ] ifFalse: [ IceLibgitFiletreeWriter ]removeMethod: arg1  repository workingCopy removeMethod: arg1tagNameLabel: arg1  tagNameLabel := arg1matches: arg1  self subclassResponsibilitysetModelBeforeInitialization: arg1  model := arg1usernameInput  ^usernameInputrepositoryModel  ^nilinitialExtent  ^(1050 @ 800) scaledByDisplayScaleFactorprivateKey  ^privateKey ifNil: [ privateKey := self class defaultPrivateKey ]referenceCommit: arg1  self referenceCommit = arg1 ifTrue: [ ^self ].  referenceCommit := arg1.  self refreshProjectFromRepositoryemptyPanel  ^PanelMorph new     changeProportionalLayout;     vResizing: #spaceFill;     hResizing: #spaceFill;     yourselfcontextClass  ^IceTipBranchContextparseHTTPLocation: arg1  | tmp1 |  tmp1 := arg1 asUrl.  host := tmp1 host.  port := tmp1 port.  path := self pathFrom: tmp1 pathbasepathOf: arg1  ^arg1repository  ^repositoryparent: arg1  parent := arg1package  ^packagemergeType: arg1  self model mergeType: arg1commentText: arg1  commentText := arg1commitishSelected: arg1  | tmp1 |  arg1 newSelectedRowIndexes ifNotEmpty: [:arg2 |  tmp1 := sidebarTree widget dataSource elementAt: arg2 first.        (tmp1 depth = 0 or: [ tmp1 hasChildren ]) ifTrue: [ ^self ].        historyPanel model: tmp1 data model ]dataSource  ^dataSourcebranchName: arg1  branchName := arg1basicUrl: arg1  url := arg1diff  ^self entityisLoaded  ^falsehistoryPanel: arg1  historyPanel := arg1