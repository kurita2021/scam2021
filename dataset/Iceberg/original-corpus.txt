parent  ^parentnotEmpty  ^childrenDictionary notEmptyfromText: anObject  fromText := anObjectprintOn: aStream  super printOn: aStream.  aStream nextPut: $(.  self realObject printOn: aStream.  aStream nextPut: $)titleLabel  ^titleLabelnewProjectFromCommit: aCommit  self subclassResponsibilityrejectButton  ^rejectButtoninitializeRepository: aRepository  repository := aRepository.  self initializepushBranchToRemote: aRemote gitRemote: gitRemote progress: pushProgress  gitRemote pushWithRefSpec: (LGitRefSpec new           source: self fullname;           destination: self fullname;           yourself) pushOptions: (LGitPushOptions defaults           callbacks: ((LGitRemoteCallbacks withProvider: (IceCredentialsProvider defaultForRemote: aRemote))                 pushTransferProgress: pushProgress;                 yourself);           yourself)initializeWidgets  super initializeWidgets.  self focusOrder add: self projectLocationrepository  ^repositorycheckoutBranchPanelsOnModel: anIceTipCachedModel  ^#()ancestorShortIdOrOrigin  ^self entity ancestors ifNotEmpty: [ self ancestorShortId ] ifEmpty: [ 'Origin' ]repository  ^repositorypullRequest  ^pullRequestconfirmSelection  acceptBlock ifNotNil: [ acceptBlock value: selectedItems ].  self window deletedescription  ^definition nameprojectPath  | projectPath |  projectPath := OrderedCollection withAll: self path.  self owner ifNotNil: [ projectPath add: self owner ].  projectPath add: self projectName.  ^(RelativePath withAll: projectPath) pathStringacceptButton: anObject  acceptButton := anObjectreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  item := aToolContext item.  tool := aToolContext toolcommitId  ^[ self entity headCommit id ] on: Error do: [ nil ]obtainBaseRemote  | base |  base := self gitBase.  ^IceGitRemote url: ((base at: #git_url) copyReplaceAll: 'git://' with: 'https://')end  Job jobAnnouncer announce: (JobEnd on: self)flushForScriptGet  newNoCommit  self subclassResponsibilitybasicExecute  UIManager default informUser: self message during: actionBlock.  successAnnounceBlock ifNotNil: [ Iceberg announcer announce: successAnnounceBlock value ]createRepository  ^[ self validate.  self isCloning ifTrue: [ self cloneRepository ] ifFalse: [ self addLocalRepository ] ] on: IceDuplicatedRepository do: [:e |  e signal ]visitNonConflictingOperation: anIceNonConflictingOperation  anIceNonConflictingOperation chosenOperation accept: selflookupCommit: commitId  ^self lookupCommit: commitId ifAbsent: [ IceUnknownCommit new           repository: self;           id: commitId;           yourself ]headSHA  ^(self jsonAt: #head) at: #shareferenceCommit  ^referenceCommitbranchName  ^branchNamecommonAncestorWithCommit: aCommitish  ^self referenceCommit commonAncestorWithCommit: aCommitishdefaultMenuItemName  ^'Convert repository sources to tonel'initialExtent  ^(600 @ 400) scaledByDisplayScaleFactoruseRemote: aRemoteModel  remote := aRemoteModel entityaddBindingsToTable  self table bindKeyCombination: Character space toAction: [ self toggleSelectionOf: self selectedItem ]parseUrl  | urlStream restSegments |  (self isSSHUrl: url) ifTrue: [ ^super parseUrl ].  (self isAlternateSSHUrl: url) ifFalse: [ IceWrongUrl signal: 'Remote repository scheme not supported: ' , url ].  urlStream := url readStream.  user := urlStream upTo: $@.  host := (urlStream upTo: $:) ifEmpty: [ nil ].  restSegments := urlStream upToEnd substrings: '/'.  path := restSegments size >= 2 ifTrue: [ restSegments allButLast: 2 ] ifFalse: [ #() ].  owner := restSegments size > 1 ifTrue: [ restSegments at: restSegments size - 1 ] ifFalse: [ nil ].  restSegments isEmpty ifTrue: [ IceWrongUrl signal: 'Remote repository scheme not supported: ' , url ].  projectName := self stripPossibleExtension: restSegments lastinstall  self leftDefinition installfindOrCreatePath: parents on: root  | path next |  path := parents first.  next := root children detect: [:each |  each data = path data ] ifNone: [ root addChild: path toStaticItem ].  ^parents allButFirst ifNotEmpty: [:remaining |  self findOrCreatePath: remaining on: next ] ifEmpty: [ next ]titlePanel  ^titlePanelunload  self workingCopy unloadsetUpstream: anUpstreamBranch  self subclassResponsibilityacceptError: aVisitor  aVisitor visitCheckoutConflict: selfreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  item := aToolContext item.  announcer := IceTipWeakValueHolder contents: aToolContext toolAnnouncerinitializeWidgets  commitTabPanel := self newTabManager.  self initializeCommitPanel.  self focusOrder add: commitTabPaneldiffPanel  ^diffPanelauthor: aString  author := aStringmodifyingPackage  ^modifyingPackagerightPanel: anObject  rightPanel := anObjectfirst: anObject  first := anObject.  (anObject ~= #none and: [ self last = anObject ]) ifTrue: [ self last: #none ]initialize  super initialize.  modifiedFilePaths := Set newclassName: anObject  className := anObjectinitializeRepositoryList  repositoryList widget     beResizable;     addColumn: (IceTipTableColumn new           id: 'Name';           action: #descriptionWithDecoration;           width: 200;           yourself);     addColumn: (IceTipTableColumn new           id: 'Status';           action: #status;           width: 150;           yourself);     addColumn: (IceTipTableColumn new           id: 'Branch';           action: #branchName;           yourself);     dataSource: self newRepositoriesDataSource;     selectIndex: 1;     enableFilter: IceTipRepositoryFilter;     explicitFunctionisExported  ^repository isPackageExported: selfproject  self flag: #todo.  ^[ IceProjectReader readProjectFrom: self ] on: NotFound do: [ self repository fetch.        IceProjectReader readProjectFrom: self ]key  ^namecredentials: aValue  credentials := aValue.  usernameInput text: credentials username.  passphraseInput text: credentials keyPassphrase.  passphraseInput encrypted: false.  privateKeyInput location: credentials privateKey.  publicKeyInput location: credentials publicKeyinitialize  selectedItems := Set new.  super initializeloadAllPackages  self loadPackagesNamed: repository head packageNamesunloadPackageNamed: aPackageName  self unloadPackage: (IcePackage named: aPackageName repository: repository)urlLabel: anObject  urlLabel := anObjectisDirty  ^self repository workingCopy referenceCommit project ~= self readOnlyVersionpackagesList: anObject  packagesList := anObjectconfirmLabel: anObject  confirmLabel := anObjectversion: aVersion  version := aVersionname  ^'Empty node'removeFromPatcher: aMCPatcher  aMCPatcher removeDefinition: self asMCDefinition= anotherDefinition  ^super = anotherDefinition and: [ self className = anotherDefinition className and: [ self classIsMeta = anotherDefinition classIsMeta ] ]isCurrent  ^self == CurrentStorehasToShowWarning  ^model repository workingCopy packages isNotEmptystoreFile: aFileLocator  storeFile := aFileLocatorhistory  ^historywhenTextChanged: aBlockClosure  self locationInput whenTextChanged: aBlockClosurename: aString  name := aStringmodel: aMerger  model ifNotNil: [ aMerger removeDependent: self ].  aMerger ifNotNil: [ aMerger addDependent: self ].  model := aMerger.  self patchMorph model: aMergermergeHistoryFromAncestor: anIceGitCommit  ^(IceTipCommitRangeModel repositoryModel: self repositoryModel on: anIceGitCommit)     toCommit: self entity parent;     beCachedaddToPatcher: aPatcher  aPatcher addDefinition: (MCOrganizationDefinition categories: categories)announcer  ^announcer ifNotNil: #contentsisRootDefinition  ^falsecypressMethodName: aMethod  ^(MCFileTreeStCypressWriter fileNameForSelector: aMethod selector asString) , '.st'author  ^'No PR selected'removeFile: anIceFileDefinition  newValue: aStringOrText  ^IceTipReadOnlyTextMorph new     hResizing: #spaceFill;     vResizing: #spaceFill;     contentsWrapped: aStringOrText;     asSpecAdapterexecute  credential editModelClass new     credentials: credential;     credentialStore: store;     tool: tool;     openNonModalconfirmLabel  ^confirmLabelissueNumberText  ^issueNumberTextputFocusOrder  self focusOrder     add: usernameInput;     add: passwordInput;     add: storeCheckboxtitle  ^titlepatcher: aMCPatcher  patcher := aMCPatcherrequestGitRepositoryInfo  | remote |  remote := self headRemote.  ^IceGitHubAPI new     credentials: self credentials;     getRepository: remote owner project: remote projectBasenamebaseBranchList  ^baseBranchListinitializeWidgets  nameLabel := self newLabel label: 'user.name'.  nameInput := self newTextInput     ghostText: 'e.g., John Doe';     autoAccept: true.  emailLabel := self newLabel label: 'user.email'.  emailInput := self newTextInput     ghostText: 'e.g., johndoe@mail.net';     autoAccept: true.  globalCheckbox := self newCheckBox     label: 'Save properties as global?';     state: false.  self focusOrder     add: nameInput;     add: emailInput;     add: globalCheckboxmarkAllPackagesAsClean  self markAsCleanPackagesThat: [:each |  true ]showWidget  addButton  ^addButtonoptionB  ^optionBisPushing  ^self pushCheckbox stateisCodeSubdirectory: aNode  | nodeLocation repositorySubdirectoryLocation |  nodeLocation := self repository location resolve: aNode path.  repositorySubdirectoryLocation := self repository subdirectoryReference.  ^nodeLocation pathString = repositorySubdirectoryLocation pathStringremotePanel: anObject  remotePanel := anObjectcanRevertChanges  ^iceCommit canRevertChangesgtInspectorItemsIn: composite  < gtInspectorPresentationOrder: 0>  ^composite fastTable     title: 'Packages';     display: [ self workingCopy packages ];     column: 'Name' evaluated: [:each |  each name ] width: 400 * World displayScaleFactor;     column: 'Status' evaluated: [:each |  each asString ] width: 400 * World displayScaleFactorheadCommit  ^repository headCommitdrawOn: aCanvas  super drawOn: aCanvas.  self hasBadge ifTrue: [ self drawBadgeOn: aCanvas ]hasBadge  ^self badge notNilnewActionButton  ^self newButton     label: 'Merge';     icon: (self iconNamed: #merge);     help: ('Merges {1} with your image''s version.' format: {self model targetName});     action: [ self doMerge ];     yourselfisNewerThan: another  ^self info timeStamp > another info timeStampcalculateDiff  ^commitish entity diffTo: self repository workingCopyremoveFileSystemCheckbox  ^removeFileSystemCheckboxdiff: anIceDiff  diff := anIceDiffpushTo: aRemote  commitish  ^commitish entityisSuspended  ^suspendAllsubdirectory  ^subdirectory ifNil: [ self class defaultSubdirectory ]nameText: anObject  nameText := anObjectcancelAction  accepted := true.  self window close.  LGitNoCredentialsProvided signalbasicLocation: aReference  locationInput text: aReference pathStringreferenceCommit  ^repository head commitgetIssue: owner project: projectName number: issueNumber  ^self get: 'repos/' , owner , '/' , projectName , '/issues/' , issueNumber asStringcommitsInPackageCache: aCache  commitsInPackageCache := aCachenewNoCommit  ^IceNoCommit repository: selfcommits  commits ifNil: [ self lookupCommits ].  ^commitscheckoutBranch: branchName  (self branchNamed: branchName ifAbsent: [ self createBranch: branchName ]) checkoutdiffFor: aCommitModel  self subclassResponsibilityrefresh  self rebuildToolbar.  self sidebarTree widget     in: [:this |  this selectRowIndexes: #().        this dataSource           rootForItems: self model repositoryModelsByGroup;           expandRoots ];     refreshdiffFromFirstAncestor  | diff ancestorCommit |  ancestorCommit := self entity ancestors ifNotEmpty: #first ifEmpty: [ IceNoCommit new ].  diff := self calculateDiff: [ ancestorCommit diffTo: self entity ].  ^IceTipCommitDiffModel repositoryModel: self repositoryModel on: diffitemNameWithoutBranches  self subclassResponsibilitydelete  self repository removeTag: selfchangesFromCommit: anIceCommit  ^self commit changesFromCommit: anIceCommitrefreshDiffLabel  diffTab label: ('{1} to {2}' format: {((self model commitModelAfter: selectedModel) ifNotNil: #shortId ifNil: [ 'origin' ]) .               selectedModel shortId})lookupCommit: commitId ifAbsent: aBlock  self subclassResponsibilitysubdirectoryLabel  ^subdirectoryLabelremoveFileDefinition: anIceFileDefinition  (repository location resolve: anIceFileDefinition path) ensureDelete.  self addPath: anIceFileDefinition pathtitle  ^'Please log in to ' , remoteHostnameisDetached  ^self subclassResponsibilitygetConfigurationGlobal: aBoolean  self handleLibgitError: [ | config |        config := self repositoryHandle config.        ^aBoolean ifTrue: [ config openGlobal ] ifFalse: [ config ] ]initialize  super initialize.  success := falsecopyCommitIDToClipboard  < noCache>  self copyToClipboardId: self commitIdauthor  ^(self jsonAt: 'user') at: 'login'execute  ^IceGitHubViewPullRequestAction new     repository: self repository;     remote: self remote;     executeauthor  ^self info authorspacePanel: anObject  spacePanel := anObjectisHead  ^self repository head = selfpath  ^pathrepositoryVersionString  ^self repository workingCopy referenceCommit idremote  ^remoteinitialize  super initialize.  fetched := falsechosenOperation  self subclassResponsibilityincludesKey: anObject  ^childrenDictionary includesKey: anObjectdirectoryForPackage: mcPackage  | package |  package := self packageNamed: mcPackage name.  ^self subdirectory isEmptyOrNil ifTrue: [ self directoryNameForPackage: package ] ifFalse: [ self subdirectory , '/' , (self directoryNameForPackage: package) ]iceVersion  ^iceVersionnewStatusBarItemOn: aStatusBar  self model shortCommitId ifNil: [ ^self model branchName asMorph ].  ^PanelMorph new     addMorph: self branchNameMorph;     addMorph: self shortIdMorph;     changeTableLayout;     listDirection: #rightToLeft;     hResizing: #shrinkWrap;     vResizing: #spaceFill;     yourselfcanBeBrowsed  ^self leftDefinition canBeBrowsedincomingCommitsFromBranch: aBranch  ^aBranch newCommitWalk     uptoCommit: self commit;     commitsmergeablePanel: anObject  mergeablePanel := anObjecthasIncomingCommitsFrom: aRemote  | localCommits remoteCommits |  self tracksRemoteBranch ifFalse: [ ^false ].  localCommits := self commits.  remoteCommits := self trackedBranch commits.  ^remoteCommits anySatisfy: [:each |  (localCommits includes: each) not ]resetToCommit: anIceGitCommit  self commit: anIceGitCommitchooseReference  ^(UIManager default chooseFullFileName: self chooseTitle extensions: nil path: self location preview: nil) ifNotNil: [:file |  file asFileReference ]addDirectory  | newDirectoryName newDirectory |  newDirectoryName := UIManager default textEntry: 'Enter the new Directory name' title: 'Create a directory'.  newDirectoryName ifNil: [ ^self ].  newDirectory := selectedDirectoryPath / newDirectoryName asResolvedBy: self model fileSystem.  newDirectory exists ifFalse: [ newDirectory createDirectory ].  sourceDirectoryTree widget dataSource updateData.  sourceDirectoryTree widget dataSource expandAll.  sourceDirectoryTree widget selectIndex: (sourceDirectoryTree widget dataSource indexOfElement: (selectedDirectoryPath asResolvedBy: self model fileSystem))createNewRepositoryNamed: aString  | locationToUse |  self validate.  locationToUse := self locationToUse.  (locationToUse exists and: [ locationToUse hasChildren ]) ifTrue: [ IceError signal: ('{1} is not empty.' format: {locationToUse fullName}) ].  locationToUse ensureCreateDirectory.  self subdirectory ifNotEmpty: [ (locationToUse resolve: self subdirectory) ensureCreateDirectory ].  repository := IceLibgitRepository new     name: aString;     location: locationToUse;     init;     yourself.  self addProjectFileTo: repository.  self addPropertiesFileTo: repository.  repository workingCopy refreshProject.  ^repositorybranches  ^self localRepository remoteTrackedBranches select: [:e |  e remoteName = self name ]visitNonConflictingOperation: anIceNonConflictingOperation  ^anIceNonConflictingOperation chosenOperation accept: selfsourceDirectoryLabel  ^sourceDirectoryLabelmodel  ^modelbranchModelFor: aBranch  ^(IceTipBranchModel repositoryModel: self on: aBranch) beCachedworkingCopy  ^workingCopyicon  ^icontoCommit: anObject  toCommit := anObjectisInMerge  ^trueinitialize  super initializesetModelBeforeInitialization: aRepositoryModel  self model: (IceTipWorkingCopyModel on: aRepositoryModel)numberOfIncomingCommits  ^self incomingCommits sizefetch  IceRemoteNotFoundError new     remoteName: name;     signal: 'Please configure a pull remote for pulling.'toolbarName  ^self commandClass defaultToolbarItemNameinitializeCommitList  commitList widget     beResizable;     addColumn: (IceTipTableColumn new           id: 'Timestamp';           action: [:each |  each timeStamp asLocalStringYMDHM ];           width: 110 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Commit';           action: #shortId;           width: 60 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Author';           action: #author;           width: 150 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Description';           action: #descriptionWithDecoration;           yourself);     dataSource: self newCommitsDataSource;     selectRowIndex: 1newCommitWalk  ^repository newCommitWalk fromTag: selfincludesCommit: aCommit  ^self newCommitWalk includesCommit: aCommitbranchesList: anObject  branchesList := anObjectproperties  ^Dictionary newuptoBranches: branches  ^branches do: [:branch |  self uptoBranch: branch ]= another  ^self species = another species and: [ self repository = another repository and: [ self name = another name ] ]projectFileReference  ^self projectFileIn: commitishselectedItems  ^selectedItemshasUnbornProject  ^self repositoryModel hasUnbornProjecticon  ^self iconNamed: #bookcollectWithPath: aBlockClosure  ^selftool  ^toolactionWidth: aNumber  actionWidth := aNumbersetModelBeforeInitialization: anObject  model := anObjectcheckoutStrategyList  ^checkoutStrategyListiceLabelWidth  ^labelWidth ifNil: [ self class defaultLabelWidth ]messageText  ^messageTextnewPullRequestsDataSource  ^IceTipDataSource new     tool: self;     elements: #();     yourselfselectionChanged: ann  commitInfoTabs selectedModel: (ann newSelectedRowIndexes ifNotEmpty: [:indexes |  self commitList widget dataSource elementAt: indexes first ] ifEmpty: [ nil ])mouseUp: evt  ((dataSource canDisplayChildrenOf: item) and: [ item children isNotEmpty ]) ifTrue: [ item toggle ].  super mouseUp: evtrepositoryModel  ^commitish repositoryModelinitializePresenter  | path currentNode |  super initializePresenter.  self formatList     items: self formats;     displayBlock: [:each |  each description ];     setSelectedItem: model repositoryProperties fileFormat.  path := (RelativePath with: model sourceDirectory) segments asOrderedCollection.  currentNode := self sourceDirectoryTree widget dataSource rootItem children first.  currentNode expand.  [ path isEmpty ] whileFalse: [ | currentSegment |        currentSegment := path removeFirst.        currentNode := currentNode children detect: [:e |  (e data basename ifEmpty: [ '/' ]) = currentSegment ] ifFound: [:node |  node expand.              node ] ifNone: [ nil ] ].  currentNode ifNotNil: [ | index |        index := self sourceDirectoryTree widget dataSource indexOfElementMatching: [:elem |  elem = currentNode data ].        self sourceDirectoryTree widget selectIndex: index ]visitRemoteAlreadyExistError: anError  UIManager default inform: ('Remote "{1}" already exists.' format: {anError remoteName})repository  ^repositoryaccept  self validate.  self doAccept.  acceptBlock ifNotNil: [ acceptBlock cull: self ]removeFromPatcher: aMCPatcher  model: anObject  model := anObject.  self refreshchangesFromCommit: anIceGitCommit  ^anIceGitCommit changesFromNoCommit: selfactionColumn: column  column id = #target_url ifTrue: [ ^self ].  ^super actionColumn: columnsetModelBeforeInitialization: anObject  model := anObjectfromLabel  ^fromLabelhasConflicts  self calculateChanges.  ^mergeTree anySatisfy: [:e |  e isConflict ]hasIncomingCommits  ^self branch hasIncomingCommitsmodel  ^modelallPackages  ^RPackageOrganizer default packages asOrderedCollection sort: [:a :b |  a name < b name ]sourceDirectoryPath  ^RelativePath withAll: (RelativePath canonicalizeElements: ($/ split: self sourceDirectory))commitishName: aName  branchName := aNamereadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  announcer := IceTipWeakValueHolder contents: aToolContext toolAnnouncereventKeyStrokesForPreviousFocus  ^{Character tab shift asKeyCombination}visitCypressPropertiesChange: anIceCypressPropertiesChange  version properties addToChangeBuilder: selfremoveRemote: aRemote  (self hasRemoteNamed: aRemote name) ifFalse: [ IceRemoteNotFoundError new           remoteName: aRemote name;           signal ].  self doRemoveRemote: aRemoteextent  ^45 @ 25getBranch: owner project: projectName name: branchName  ^self get: 'repos/' , owner , '/' , projectName , '/branches/' , branchNameexecute  (IceTipWorkingCopyBrowser on: self repositoryModel) openWithSpecisUnborn  ^falseaddComment: owner project: projectName number: aNumber data: aDictionary  ^self post: 'repos/' , owner , '/' , projectName , '/issues/' , aNumber asString , '/comments' with: [:client |  client           entity: (ZnEntity text: (STON toJsonString: aDictionary));           contentType: ZnMimeType applicationJson ]repository  ^self iceVersion repositorybaseBranchName  ^baseBranchNamevalidateMakePullRequestOn: aRepository  | status |  status := OrderedCollection new: 2.  aRepository isModified ifTrue: [ status add: 'Uncommited changes' ].  (aRepository outgoingCommitsTo: remote) ifNotEmpty: [:commits |  '{1} not published' format: {commits size} ].  status ifEmpty: [ ^true ].  ^UIManager default confirm: ('{1} has ongoing modifications ({2}). Do you want to continue anyway?' format: {aRepository name .               status asCommaString})firstNodeSuchThat: conditionBlock  ^self firstNodeSuchThat: conditionBlock ifNone: [ NotFound signalFor: conditionBlock ]directory  ^selfremoveFromPatcher: aPatcher  aPatcher removeDefinition: (MCOrganizationDefinition categories: categories)pushTo: aRemote  self branch pushTo: aRemoteisParentOf: aCommit  ^false= aMagnitude  | version |  version := aMagnitude iceSemanticVersion.  ^self asInteger = version asIntegerhash  ^self contents hashsetModelBeforeInitialization: aDomainObject  self exception: aDomainObjectdefaultLocation  ^IceLibgitRepository repositoriesLocation pathStringlocation: anObject  location := anObjectrepository  ^commitish repositoryvisitRemoteDesynchronizedError: anError  | continue command |  continue := UIManager default confirm: ('Your repository is out of sync with remote {1}. You need to pull remote changes before continue and push your changes.' format: {anError remote}) label: 'Remote repository out of sync!' trueChoice: 'Pull' falseChoice: 'Cancel' cancelChoice: nil default: false.  (continue isNil or: [ continue not ]) ifTrue: [ ^self ].  command := IcePullRemoteCommand new     repository: self repository;     remote: anError remote;     yourself.  [ command execute ] on: IceMergeAborted , IceShouldCommitBeforePull do: [:e |  self flag: #todo.        (e isKindOf: IceShouldCommitBeforePull) ifTrue: [ e resume ] ifFalse: [ e acceptError: self ] ].  command isSuccess ifFalse: [ ^self ].  anError isResumable ifTrue: [ ^anError resume ].  anError retryincludesPackageNamed: aString  ^falsemcDefinition: aMCDefinition  mcDefinition := aMCDefinitioncommitList  ^commitListdiffFor: aCommitModel  ^aCommitModel diffToHeadreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  selectedCommit := aToolContext itementryRemoved: ann  self refreshbeForCloneOfRepository: aRepository  self withoutNewRepository.  self withoutLocalRepository.  repository := aRepositoryfetchIfNeeded: aRepository  (aRepository lookupCommit: SystemVersion current commitHash) isUnknownCommit ifFalse: [ ^self ].  UIManager default informUser: 'Fetching incoming commits' during: [ aRepository remotes detect: [:each |  each projectName = 'pharo-project' ] ifFound: [:each |  each fetch ] ]refreshDiffFromHead  headTabContainer updateContentsOn: selectedModelrepository: anObject  repository := anObjectstatusCellColumn: column rowIndex: rowIndex  | status |  status := (self elementAt: rowIndex) at: column id.  ^FTCellMorph new     cellInset: 5;     addMorphBack: (self iconForStatus: status) asMorph;     addMorphBack: status asStringMorph;     yourselfchoosen  ^choosenicon  ^self iconNamed: #emptyPackageincludesPackageNamed: aString  ^self includesInWorkingCopyPackageNamed: aStringinitializeWidgets  super initializeWidgets.  remotePanel label: 'Push to remote:'model  ^modeltonelClassOrTraitName: aClass  ^aClass name , (self tonelClassExtension: aClass) , '.st'subscribeToAnnouncements  model  ^modelexecute  self packageModel browseRepositoryVersionremoveBranch: json  | branchName |  branchName := json at: 'name'.  IceGitHubAPI new     credentials: self credentials;     deleteBranch: self remote owner project: self remote projectBasename name: branchName.  UIManager default inform: ('Branch {1} removed.' format: {branchName})uptoVersion: version  version hideYourselfFromCommitWalk: selfrepositoryModel: anObject  repositoryModel := anObjectdiff  ^diffrejectMessage: messageString  messageString trimBoth ifNotEmpty: [ self addComment: messageString ].  IceGitHubAPI new updatePullRequest: self owner project: self projectName number: self number data: {(#state -> #closed)} asDictionarynewActionButton  ^self newButton     label: 'Pull';     icon: (self iconNamed: #down);     help: ('Pull new commits from {1}' format: {self model remoteName});     action: [ self doPull ];     yourselfindex: anIndex  index := anIndexeventKeyStrokesForNextFocus  ^{Character tab asKeyCombination}toggleSelectionOf: item  (self isSelected: item) ifTrue: [ self remove: item ] ifFalse: [ self add: item ].  self tableRefreshexecute  (IceTipCheckoutBranchDialog on: self repositoryModel)     withTypes: (IceGitHubPlugin new checkoutBranchPanelsOnModel: self repositoryModel);     openDialogWithSpecinitializeWidgets  super initializeWidgets.  remotePanel label: 'Pull from remote:'allCredentials  self loadFromStore.  self defaultSSHCredential.  ^plainCredentials values , sshCredentials valueshost: anObject  host := anObjectallSatisfy: aBlockClosure  (aBlockClosure value: self value) ifFalse: [ ^false ].  self childrenDo: [:e |  (e allSatisfy: aBlockClosure) ifFalse: [ ^false ] ].  ^truecolorNotLoaded  ^Smalltalk ui theme disabledTextColorrepositoryModel  ^repositoryModelisMethodDefinition  ^falserepository: anObject  repository := anObjectbranchInputText: anObject  branchInputText := anObjectcurrentCommit  ^repository workingCopy referenceCommitfillContextMenu: aMenu using: aCommandActivator  | concreteScopeCommand switchActivator subMenu |  subMenu := MenuMorph new.  self repository remotes do: [:each |  concreteScopeCommand := self copy           remote: each;           yourself.        switchActivator := aCommandActivator newForCommand: concreteScopeCommand.        subMenu add: switchActivator menuItemName target: switchActivator selector: #executeCommand ].  aMenu add: self defaultMenuItemName subMenu: subMenuisDetached  ^self workingCopyState isDetachedremoteName: aString  remoteName := aStringlabel: aString  self remoteLabel label: aStringitem: anIceTipCachedModel  item := anIceTipCachedModelcheckoutOn: anIceWorkingCopy  anIceWorkingCopy loadChangesInWorkingCopy: self diff.  self repository setHead: committish.  anIceWorkingCopy referenceCommit: committish commit.  anIceWorkingCopy markAllPackagesAsCleaninitialize  items := OrderedDictionary new.  super initializepassphraseLabel  ^passphraseLabelinitializeObject: anObject  realObject := anObject.  cache := IceTipCache proxy: self.  self initializeinitializeStatusBar  statusBar     addItem: (IceTipBranchWithCommitStatusBarItem new           model: self model;           yourself);     addItem: (IceTipStatusBarTargetItem new           bePositionRight;           target: self model;           contents: #status;           yourself)repository: anObject  repository := anObjectdisplayBlock: aBlock  self listPanel displayBlock: aBlockinitialExtent  ^(600 @ 300) scaledByDisplayScaleFactorchangeList  ^changeListcommitCache  ^commitCache ifNil: [ commitCache := LRUCache new maximumWeight: 30 ]deselectAllChildrenOf: item  (self withAllChildrenOf: item) do: [:each |  selectedItems remove: each data ifAbsent: [  ] ].  self tableRefreshunregister  ^MCRepositoryGroup default removeRepository: selfbranchNamed: aName ifAbsent: absentBlock  ^self branchNamed: aName ifPresent: [:branch |  branch ] ifAbsent: absentBlockcreateNewBranch: branchName  self createBranch: branchName inCommit: self headCommitexecute  self repositoryModel editreplacePanelWith: aType  | panelMorph specPanel |  panelMorph := self contentPanel morph.  panelMorph removeAllMorphs.  aType ifNil: [ ^self ].  specPanel := aType buildWithSpec.  panelMorph addMorph: specPanel fullFrame: LayoutFrame identity.  self eventKeyStrokesForNextFocus do: [:each |  aType bindKeyCombination: each toAction: [ self giveFocusToNextFrom: specPanel ] ].  self eventKeyStrokesForPreviousFocus do: [:each |  aType bindKeyCombination: each toAction: [ self giveFocusToPreviousFrom: specPanel ] ].  self refreshFocusOrdercloseAction  accepted ifFalse: [ self cancelAction ]url  ^urlavailableRemotes  ^availableRemotes ifNil: [ availableRemotes := self obtainAvailableRemotes ]isEmpty  ^truerefreshDiff  selectedModel ifNil: [ ^self ].  diffTab contents: (self newDiffPanelLeft: ((self model commitModelAfter: selectedModel) ifNotNil: #source ifNil: [ '' ]) right: selectedModel source)description  ^self origin url , '[' , self head description , ']'execute  | commitToAdvance |  mergeCommit validateCanMerge.  self isAlreadyMerged ifTrue: [ ^self ].  self resolveConflicts.  commitToAdvance := self updateHead.  self updateWorkingCopy.  ^commitToAdvancedescription  ^leftOperation descriptionupdateDiskWorkingCopy: anIceDiff  self subclassResponsibilitynewContext  ^self contextClass for: selfloadDefinitions  | entry segments className classIsMeta |  definitions := OrderedCollection new.  segments := (self fileName substrings: '/') allButLast asOrderedCollection.  classIsMeta := segments removeLast = 'class'.  className := segments last copyUpToLast: $..  entry := packageDirectory entryByPath: (self fileName allButFirst: packageDirectory filename size) ifAbsent: [ ^nil ].  entry readStreamDo: [:fileStream |  | category source timestamp selector |        category := fileStream nextLine.        source := fileStream upToEnd.        selector := self methodSelectorFor: source.        timestamp := stream author name , ' ' , stream time asDateAndTime asStringYMDHM.        definitions add: (MCMethodDefinition className: className classIsMeta: classIsMeta selector: selector category: category timeStamp: timestamp source: source) ]newPanelMorph  ^PanelMorph new     changeTableLayout;     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #spaceFill;     cellInset: self class defaultItemSeparation @ 0;     color: self color;     yourselfmcVersionFor: iceVersion  [ | commit |  commit := iceVersion commit libgitCommit.  ^(iceVersion commit readerClass on: commit iceVersion: iceVersion) version ] on: IceMissingRepositoryEntry , LGit_GIT_ENOTFOUND do: [ IceVersionDoesNotExist new           version: iceVersion;           signal ]guessRegisteredRepository  ^IceRepository registry detect: [:each |  each name = self projectName ] ifNone: [ nil ]validate  self assert: self userName isNotEmpty description: 'You must enter a GitHub username.'.  self assert: self projectName isNotEmpty description: 'You must enter a GitHub project.'.  super validateselectedDirectoryPath  ^selectedDirectoryPathtargetVersion  ^self leftCommitreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  selectedCommitish := aToolContext itemiceCommit: anIceGitCommit  iceCommit := anIceGitCommitsplitRootAndSubdirectoryFromLocation  | root subDir |  (self location beginsWith: self class type , '://') ifFalse: [ self error: 'Invalid URL (It should be ' , self class type , '://...)' ].  root := (self location allButFirst: self class type size + 3) asFileReference.  subDir := #().  [ root isRoot or: [ self isGitRoot: root ] ] whileFalse: [ root asAbsolute = FileSystem workingDirectory ifFalse: [ subDir := subDir copyWithFirst: root basename ].        root := root parent ].  root isRoot ifTrue: [ self error: 'I can''t find a .git/config file.' ].  ^{root .   (String streamContents: [:stream |  subDir asStringOn: stream delimiter: '/' ])}isOkEnabled  self subclassResponsibilityrepository  ^repositorytitle  ^'Pushing...'repositoryHandle  < repositoryHandleAccessor>  ^localRepository repositoryHandlewithResultDo: aBlockClosure  callback := aBlockClosuregitBase  | info |  ^(info := self gitRepositoryInfo) at: #parent ifAbsent: [ info ]getRaw: aString  ^self responseWithValidationDo: [ (self newRequestTo: aString)           get;           response ]newDataSourceMatching: aFilter  ^aFilter executeOn: selfaddPackage: aPackage  self basicAddPackage: aPackage.  aPackage beDirtycollectVersionsFrom: aCollection method: aMethod path: aPath  | lastDefinition basepath history |  basepath := self basepathOf: aPath.  lastDefinition := MCMethodDefinition new.  history := OrderedCollection new.  aCollection reverseDo: [:eachCommit |  | definition |        definition := self definitionFor: aMethod path: basepath commit: eachCommit.        lastDefinition = definition ifFalse: [ history add: (IceLogVersion commit: (self repository commitFromGitCommit: eachCommit) definition: definition asRingDefinition).              lastDefinition := definition ] ].  ^history reversedremoteInputText: anObject  remoteInputText := anObjectbaseBranches  ^baseBranches ifNil: [ baseBranches := self requestBaseBranches ]doAccept  | newRepository |  self selectedType validate.  self isEditing ifTrue: [ self selectedType repository: repository ].  newRepository := self selectedType newRepository.  self isEditing ifFalse: [ newRepository register ].  acceptBlock ifNotNil: [ acceptBlock cull: self ]isMatching: anItem  ^(dataSource toString: anItem data) beginsWith: patternnameText  ^nameTextcommitishNamed: aName  ^self branchNamed: aName ifAbsent: [ self remotes size = 1 ifTrue: [ self remotes anyOne remoteBranchNamed: aName ifPresent: [:found |  ^found ] ifAbsent: [  ] ].        self revparse: aName ]isUndefined  ^falseerrorLabel  ^errorLabelindex: anIndex  index := anIndexreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  location := aToolContext item locationnewContextWithSelection: anObject  ^self newContextisPresent  ^self username isEmpty not and: [ self password isEmpty not ]rightPanel  ^rightPanelbranchName  ^branchNameuserName  ^user ifNil: [ '' ]initialExtent  ^(800 @ 600) scaledByDisplayScaleFactorbranchNamed: aName  ^self branchNamed: aName ifPresent: [:branch |  ^branch ] ifAbsent: [ IceBranchNotFound new           branchName: aName;           signal ]contents  mcDefinition ifNil: [ ^'' ].  ^self isMeta ifFalse: [ mcDefinition fullDefinitionString ] ifTrue: [ mcDefinition classDefinitionString ]previewMerge: aMergeType  < noCache>  (IceTipMergePreviewBrowser onBranch: self)     mergeType: aMergeType;     openWithSpecblock  ^[:stats :payload |  | gitStats |  gitStats := LGitTransferProgress fromHandle: stats.  job ensureStarted.  job min: 0.  job max: gitStats prim_total_objects.  job current: gitStats prim_received_objects.  job title: ('Fetching Git objects... ({1}/{2})' format: {gitStats prim_received_objects .               gitStats prim_total_objects}).  job changed.  0 ]initializeProjectLocation  projectLocation := self instantiate: IceTipDirectoryPresenter.  projectLocation     label: 'Local directory';     chooseTitle: 'Choose local repository';     location: self defaultLocationexistingTagsList  ^existingTagsListdiff: anObject  diff := anObjectsetUpstream: anIceGitRemoteBranch  repository handleLibgitError: [ | localBranch |        localBranch := self repositoryHandle lookupLocalBranch: self name.        localBranch setUpstream: anIceGitRemoteBranch gitRef ]commitInfoTabs: anObject  commitInfoTabs := anObjectisClean  ^self isDirty notisResolved  ^chosen notNilgtDisplayString  | limitedString limit |  limit := 1000.  limitedString := String streamContents: [:s |  self gtDisplayOn: s ] limitedTo: limit.  limitedString size < limit ifTrue: [ ^limitedString ].  ^limitedString , ' ...'initializeCommitPanel  commitTabPanel     addTab: (infoTab := self newInfoTab);     addTab: (headTab := self newDiffTab           label: 'Diff from HEAD';           whenTabSelected: [ self refreshDiffFromHead ];           yourself);     addTab: (ancestorTab := self newDiffTab           label: 'Diff from ancestor';           whenTabSelected: [ self refreshDiffFromAncestor ];           yourself).  headTabContainer tab: headTab.  ancestorTabContainer tab: ancestorTabdescription  ^self referenceCommit descriptionhost  ^self subclassResponsibilityname  ^nameleftContents  ^leftOperation leftContentspackages  self repository handleLibgitError: [ | writerClass sourceFileReference |        writerClass := self writerClass.        sourceFileReference := commitish fileSystem resolve: self sourceDirectoryPath.        sourceFileReference exists ifFalse: [ ^#() ].        ^sourceFileReference children select: [:each |  writerClass isValidPackage: each ] thenCollect: [:each |  | packageName |              packageName := writerClass packageNameFromDirectory: each.              IcePackage named: packageName repository: self repository ] ]isConflict  self subclassResponsibilitynewIndex  self subclassResponsibilitynewActionButton  self subclassResponsibilityhasUpstream  ^self subclassResponsibilityisPresent  ^self username notEmpty and: [ self publicKey notEmpty and: [ self privateKey notEmpty ] ]isLoadable  ^falsebranchName  ^'{1}-{2}' format: {issueNumberText text trim .         issueText text trim}acceptError: aVisitor  aVisitor visitMergeAborted: selfsaveIntoStore  | serializer |  self flag: #implementAnEncryptedVersion.  storeFile ifNotNil: [ storeFile parent ensureCreateDirectory.        storeFile resolve binaryWriteStreamDo: [:stream |  serializer := FLSerializer on: stream.              serializer serialize: {plainCredentials .                     sshCredentials} ] ]baseForkList  ^baseForkListbranchModels  ^self model branchModelsaddToPatcher: aMCPatcher  self subclassResponsibilityloadedVersion: anObject  loadedVersion := anObjectcypressMethodSideName: aMethod  ^aMethod origin isClassSide ifTrue: [ 'class' ] ifFalse: [ 'instance' ]hash  ^self description hashprojectName  ^properties at: #projectName ifAbsent: [ self repository name ]descriptionWithDecoration  | text |  text := (', ' join: self entity tagNames) asText allBold makeAllColor: Color gray.  text ifNotEmpty: [ text := text , ' ' ].  text append: self entity comment asText.  ^textpushThen: aBlock  IceTipStandardAction new     repository: self entity;     message: ('Pushing to {1}' format: {self remote name});     onSuccessRepositoryModified;     onSuccess: aBlock;     execute: [ self entity pushTo: self remote ]major  ^majorinitializeToolbar  addLocalRepositoryAndCheckout  | localRepository |  localRepository := self addLocalRepository.  localRepository remotes detect: [:each |  each referencesSameRemoteLocationAs: self remoteToUse ] ifFound: [:found |  localRepository fetchFrom: found ].  localRepository switchToCommitishNamed: self commitishName.  ^localRepositoryisCloning  ^self remoteToUse notNilcanBeBrowsed  ^trueid  ^idcontext  ^contextnewInfoTab  ^self newTab     label: 'Info';     icon: (self iconNamed: #smallQuestion);     closeable: false;     yourselfokAction  self credentials     username: self username;     publicKey: self publicKey;     privateKey: self privateKey;     keyPassphrase: self passphrase.  credentialStore storeCredential: self credentials.  tool ifNotNil: #refresh.  accepted := true.  ^self credentialsremoveFromRepositoryCheckbox  ^removeFromRepositoryCheckboxbasicExecute  self fetchAllRemotes.  (IceTipMergeBranchDialog on: self repositoryModel)     beSwitchAndMerge;     openDialogWithSpecselectedCommit  ^self itemfinishSuccess  super finishSuccess.  Iceberg announcer announce: (IceRepositoryModified for: self repository)/ aString  ^childrenDictionary at: aStringhash  ^self fullname hashpasswordLabel  ^passwordLabeldescription  self subclassResponsibilitycommits  | commits |  commits := OrderedCollection new.  self commitsDo: [:commit |  commits add: commit ].  ^commitscommits  ^self branch commitsbranchName: anObject  branchName := anObjectpath: aString  path := aStringiconPanel: anObject  iconPanel := anObjectsubdirectoryPath  ^RelativePath withAll: (RelativePath canonicalizeElements: ($/ split: self subdirectory))selectMatching: aSymbol from: aCollection  aSymbol = #modified ifTrue: [ ^aCollection select: #isModified ].  aSymbol = #notLoaded ifTrue: [ ^aCollection reject: #isLoaded ].  self error: 'This sorting is not accepted: ' , aSymbolcellColumn: column row: rowIndex  | item cell |  item := self elementAt: rowIndex.  cell := FTCellMorph new     cellInset: 5;     yourself.  cell addMorphBack: (self newSelectionMorphFor: item).  (column readIcon: item) ifNotNil: [:icon |  cell addMorphBack: icon asMorph ].  cell addMorphBack: (column read: item) asMorph asReadOnlyMorph.  ^cellswitchAndMergeWorkingCopy  self switch.  self flag: #todo.  self repository workingCopy referenceCommit merge.  self commit mergevisitEmptyNode: anIceEmptyNode  action  ^actionreset  self repositoryModel resetrepositoryDirectory  ^repositoryDirectorylookup: aHostName in: dict ifAbsent: aBlock  self loadFromStore.  ^dict at: aHostName ifAbsent: aBlockfromCommit: aCommit  self subclassResponsibilityloadVersionInfo  ^info := self iceVersion inforemoveDirectoryButton  ^removeDirectoryButtonselectedFileFormat  ^formatList selectedItemprepareItemToAdd: aMorph  ^aMorph     vResizing: #spaceFill;     yourselfcolumnTitleFor: column  ^column id capitalizedmaxNumber: anObject  maxNumber := anObjectselectAll  self elements do: [:each |  selectedItems add: each ].  self tableRefreshformatLabel: anObject  formatLabel := anObjectshortId  ^self commit shortIdrightContents  self subclassResponsibilitymergeWithLeftModification: anIceModification  self shouldNotImplementisResumable  ^truebadge: aString  badge := aString= anotherNode  ^(self basicEqualsTo: anotherNode) and: [ self children asSet = anotherNode children asSet ]visitEEOF: aLGit_GIT_EEOF  aLGit_GIT_EEOF messageText trimmed = 'ERROR: Repository not found.' ifTrue: [ IceCloneRemoteNotFound signalFor: context url ].  ^self visitGenericError: aLGit_GIT_EEOFmcWorkingCopy  ^self isLoaded ifTrue: [ self mcPackage workingCopy ]removePackage: anIcePackageDefinition  repository workingCopy unloadPackageNamed: anIcePackageDefinition namecheckoutStrategyList: anObject  checkoutStrategyList := anObjectnewCommitsDataSource  ^IceTipDataSource new     tool: self;     elements: #();     yourselfmessageText  ^'Tag {1} already exists' format: {tagName}wrappedException: anError  wrappedException := anErrordatetime  ^self entity datetimeappliesToRepository: aRepository  ^falsename  ^nameprojectName  ^projectNamecontentPanel  ^contentPanelinitialize  super initializeinitialExtent  ^(350 @ (self class inputTextHeight * 7 + self class buttonHeight)) scaledByDisplayScaleFactorrepositoryWasCreated: aRepository  ^self plugins do: [:each |  each repositoryWasCreated: aRepository ]contextClass  ^IceTipVersionHistoryContextlast  ^lastbranchNamed: aName ifPresent: presentBlock ifAbsent: absentBlock  self subclassResponsibilityremovePlainTextCredential: anIcePlaintextCredentials  plainCredentials removeKey: anIcePlaintextCredentials hostowner: anObject  owner := anObjectexecute  self packageModel reload.  Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity)sourceDirectory: aString  properties at: 'srcDirectory' put: aStringinverse  ^selfitem  ^itemisDetached  ^falsevisitImageChange: anIceImageChange  | importer |  importer := IceMCPackageImporter new     package: anIceImageChange package;     version: version;     yourself.  ^importer importOn: (self ensureSourceCodeParentNodeIn: parentNode)recordChoiceProject: projectName optionA: optionA optionB: optionB ifAbsentAnswer: aBlock  ^choices detect: [:each |  each projectName = projectName and: [ each isChoiceBetween: optionA and: optionB ] ] ifFound: [:choice |  choice choosen ] ifNone: [ | choosen |        choosen := aBlock value.        choosen ifNotNil: [ self recordChoice: (IceMetacelloLoadChoice new                       projectName: projectName;                       optionA: optionA;                       optionB: optionB;                       choosen: choosen;                       yourself) ].        choosen ]beSuccess  success := truepullRequest: aPullRequest  pullRequest := aPullRequest.  urlText text: self pullRequest url.  authorText text: self pullRequest author.  fromText text: self pullRequest headLabel.  toText text: self pullRequest baseLabel.  bodyText text: self pullRequest body.  self retrieveStatuses.  self retrieveDetailmodel  ^modelinitializeWidgets  self initializeWidgetsContents.  self initializeFocusOrderdescriptionWithDecoration  ^self entity nameshortIdMorph  ^(IceTipURLLabelMorph contents: model shortCommitId)     setBalloonText: 'Copy the commit ID to the clipboard';     onClick: [ self model copyCommitIDToClipboard ];     yourselfinitializeTypeList  typeList widget     addColumn: (IceTipTableColumn newAction: #title icon: #icon);     dataSource: self newTypeListDataSource;     onAnnouncement: FTSelectionChanged send: #selectionChanged: to: selfmodel  ^modelrefresh  self refreshCommitsdescription  ^'{1} at {2}' format: {self author .         self datetime asLocalStringYMDHM}removeFrom: aVisitor  aVisitor removeFile: selfmergeAction  ^mergeAction ifNil: [ mergeAction := IceMerge new           repository: self repositoryModel entity;           mergeCommit: commitish entity commit;           yourself ]localBranchNames  ^self localBranches collect: #namehasElements  ^self elements notEmptykey  ^definition keycomment  ^commentbranchName  ^branchNamemodel: anObject  super model: anObject.  self refreshchooseReference  ^UIManager default chooseDirectory: self chooseTitle path: self locationisMergeCommit  ^self ancestors size > 1diffToWorkingCopyForPackage: aPackage  ^self diffToWorkingCopyForPackages: {aPackage}repository  ^source repositoryisFileDefinition  ^falseerrorToString: aDictionary  (aDictionary at: #code) = 'custom' ifTrue: [ ^self customError: aDictionary ].  (aDictionary at: #code) = 'invalid' ifTrue: [ ^self invalidError: aDictionary ].  ^self unknownError: aDictionaryicon  ^self iconNamed: #changeUpdateexecute  item ifNil: [ ^self ].  item value definition browsenewPackagesDataSource  ^IceTipDataSource new     tool: self;     elements: self model packageModels;     yourselfgitRef  ^self idnewPackagesListDataSource  | dataSource |  ^(dataSource := IceTipSelectingDataSource new)     tool: self;     elements: self allPackagesNotRegistered;     onSelectionChangedBlock: [:item :wasSelected |  wasSelected ifTrue: [ acceptButton enable ] ifFalse: [ dataSource selectedItems ifEmpty: [ acceptButton disable ] ] ];     yourselfpackage: aPackage  package := aPackageisAncestorOf: aCommit  ^aCommit isParentOf: selfexecute  (IceTipCreateTagPanel on: selectedCommitish) openDialogWithSpeccollect: aBlock  | newNode |  newNode := self class value: (aBlock value: self value).  self nodesDo: [:e |  newNode addNode: (e collect: aBlock) ].  ^newNodedoEnsureProject  ensureProjectFile ifFalse: [ ^self ].  self repository project isUnborn ifFalse: [ ^self ].  self repository workingCopy project: (IceBasicProject onRepository: self repository withSourceDirectory: self subdirectory).  self repository workingCopy refreshRepositoryProperties.  self repository workingCopy properties properties at: #format ifAbsent: [ self repository workingCopy properties fileFormat: (TIceRepositoryWriter users detect: #isLegacyDefault ifNone: [ Smalltalk at: #IceLibgitFiletreeWriter ]) ].  self repository workingCopy refreshPackagesdefaultMenuItemName  ^remote ifNotNil: [ remote name , ' (' , remote url , ')' ] ifNil: [ self itemNameWithoutBranches ]commitish  ^commitishavailableRepairOptions  < noCache>  ^IceTipRepairAction allAvailableFor: self entitytimeStamp  ^self commit timeStampreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  tagModel := aToolContext itemheadRemote: anObject  headRemote := anObjectget: aString  ^self jsonContentsWithValidationDo: [ (self newRequestTo: aString)           get;           response ]lookupCommits  | newCommitDictionary newCommits |  newCommitDictionary := Dictionary new.  newCommits := OrderedCollection new.  commitish commitsDo: [:each |  | commit |        commit := IceHistoryCommit commit: each history: self.        newCommits add: commit.        newCommitDictionary at: each id put: commit ].  commitDictionary := newCommitDictionary.  commits := newCommitshost  ^hostinitializeList: aCollection item: anObject  list := aCollection.  item := anObject.  self initializedoAccept  self subclassResponsibilityrefreshWhenRepository: ann  (self model isModelOf: ann repository) ifFalse: [ ^self ].  self model reset.  self refreshinitializeRepositoryModel: aRepositoryModel  repositoryModel := aRepositoryModel.  self initializegetPullRequests: owner project: projectName  ^self getPaginated: 'repos/' , owner , '/' , projectName , '/pulls'createPullRequest  ^IceGitHubPullRequestDefinition new     credentials: self credentials;     title: self titlePanel text trim;     headRemote: self headForkList selectedItem;     headBranchName: self headBranchList selectedItem;     baseRemote: self baseForkList selectedItem;     baseBranchName: self baseBranchList selectedItem;     body: self bodyPanel text asString trim;     yourselfonAccept: aBlockClosure  acceptCallback := aBlockClosureloadVersionInfo  ^info := self iceVersion infochooseRemote  ^item value selectLeftchooseReference  self subclassResponsibilityselectFirst  typeList widget selectIndex: 1.  self basicSelectionChanged: self allTypes firstbodyLabel  ^bodyLabeldefaultSSHCredential  ^sshCredentials at: #* ifAbsentPut: [ IceSshCredentials new           host: #*;           yourself ]initializeWidgets  self initializeProjectLocation.  self initializeSpacePanel.  userNameLabel := self newLabel label: 'Owner name'.  userNameInputText := self newTextInput     autoAccept: true;     ghostText: 'e.g., JohnDoe'.  projectNameLabel := self newLabel label: 'Project name'.  projectNameInputText := self newTextInput     autoAccept: true;     ghostText: 'e.g., MyProject'.  protocolLabel := self newLabel label: 'Protocol'.  protocolDropList := self newDropList.  userNameInputText whenTextChanged: [:text |  projectLocation appendPath: self projectAsPathToAppend ].  projectNameInputText whenTextChanged: [:text |  projectLocation appendPath: self projectAsPathToAppend ].  protocolDropList     items: IceUrlProtocol allSubclasses;     displayBlock: [:each |  each description ];     setSelectedItem: IceUrlProtocol defaultProtocol.  self focusOrder     add: self userNameInputText;     add: self projectNameInputText;     add: self projectLocation;     add: self protocolDropListcancelAction  path: anObject  path := anObjectcommentPanel  ^commentPanelinitializeCommitList  commitList widget     beResizable;     addColumn: (IceTipTableColumn new           id: 'Timestamp';           action: [:each |  each timeStamp asLocalStringYMDHM ];           width: 110 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Commit';           action: #shortId;           width: 60 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Author';           action: #author;           width: 150 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Description';           action: #descriptionWithDecoration;           yourself);     dataSource: self newCommitsDataSource;     selectIndex: 1packageModel: anObject  packageModel := anObjecthash  ^self id hashstrongSelection: anEvent  self viewPullRequest: (self pullRequests widget dataSource elementAt: anEvent selectedRowIndex)fillContextMenu: aMenu using: aCommandActivator  aMenu addLineposition: aPosition  position := aPositionprojectFilePath  ^RelativePath with: '.project'loadedPackages  ^self packages select: #isLoadedisNoCommit  ^falseprintOn: aStream  aStream     nextPutAll: self class name;     nextPut: $(.  self printPathOn: aStream.  aStream nextPut: $)checkout: aCheckoutStrategy  aCheckoutStrategy checkoutOn: selftitle  ^'Add new Plain Text Credential'setModelBeforeInitialization: anObject  repositoryModel := anObjectinitializeFocusOrder  self focusOrder add: self branchInputTextreset  cache resetfetchBranch: aRemoteBranch  self subclassResponsibilityaddBindingsToTable  self table bindKeyCombination: Character space toAction: [ self toggleSelectionOf: self selectedItem ]onChoose  ^chooseBlockname  ^self entity nameremovalColor  ^super additionColorswitch  self checkout: IceCheckoutDoNotLoadPackages newremove: item  self selectedItems remove: item.  self onSelectionChangedBlock ifNotNil: [:block |  block cull: item cull: false ]isRepositoryDetached  ^repositoryDetachedisCommitMerged: aCommit  ^aCommit isAncestorOf: self referenceCommitmessageLabel  ^messageLabelpluginManager  ^IcePluginManager managerFor: selfsubdirectoryPath  self subclassResponsibilitymessageText  ^messageText ifNil: [ self defaultMessageText format: {super messageText} ]readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  item := aToolContext itemexecute  useAllIncomingVersion  self model mergeTree do: [:c |  c isConflict ifTrue: [ c selectRight ] ].  self changed: #changes.  self updateSourceextractProjectName: aString  ^(IceGitRemote url: aString) projectNameinitialExtent  ^(500 @ 250) scaledByDisplayScaleFactorinitializeDiffPanel  diffPanel showOptions: falseupstreamForBranch: aBranch backend: backend  ^nilhasOutgoingCommits  ^falserepositoryModel: anObject  repositoryModel := anObjectdelete: aString  ^self contentsWithValidationDo: [ (self newRequestTo: aString)           delete;           response ]newWidgetLabel: labelString value: textOrString do: aBlock  | index labelId valueId |  index := items indexOfKey: labelString.  labelId := ('label_' , index asString) asSymbol.  valueId := ('value_' , index asString) asSymbol.  widgets at: labelId put: (self newLabel: labelString).  widgets at: valueId put: (self newValue: textOrString).  aBlock value: labelId value: valueIdvalue: aValue  value := aValueacceptMessage: messageString type: typeString  IceGitHubAPI new acceptPullRequest: self owner project: self projectName number: self number data: {(#commit_title -> (messageString lines ifNotEmpty: [:each |  each first trimBoth ] ifEmpty: [ '' ])) .         (#commit_message -> (messageString lines ifNotEmpty: [:lines |  (lines allButFirst joinUsing: String lf) trimBoth ] ifEmpty: [ '' ])) .         (#sha -> self headSHA) .         (#merge_method -> typeString)} asDictionarypackage: anIcePackage  package := anIcePackagesshCredentialsClass  ^self class sshCredentialsClassexecute  (IceTipRepositoryBrowser on: self repositoryModel) openWithSpecinitialize  super initialize.  started := falseworkingCopies  ^self loadedPackages collect: #workingCopyid  ^idnewDiffTab  ^self newTab     label: 'Diff';     icon: (self iconNamed: #diff);     closeable: false;     yourselftextField: aTextPresenter  textField := aTextPresenter.  textField whenTextChanged: [:ann |  self textUpdated: ann ]addAction: aPresenter  actions add: aPresenter.  self refreshcanBeBrowsed  ^RPackage organizer includesPackageNamed: nameexecute  (IceGitHubOpenOnGithubAction organisation: self remote owner projectName: self remote projectName) executefromPackage: aPackage message: commitMessage  name := '{1}-{2}.{3}' format: {aPackage name .         Author fullName .         'unknown'}.  package := aPackage.  message := commitMessage.  id := UUID newconfirmLabel  ^confirmLabelmcRepositoryClass  ^MCGitRemoteRepositoryallTypes  ^self subclassResponsibilitycomposeUrlWithHost: host repositoryPath: path  ^'git@{1}:{2}.git' format: {host .         path}toggleSelectionOf: item  (self isSelected: item data) ifTrue: [ self deselectAllChildrenOf: item ] ifFalse: [ self selectAllChildrenOf: item ].  self tableRefreshrepositoryHandle  < repositoryHandleAccessor>  ^repository repositoryHandledefaultAction  ^self useIncomingiceVersion  ^iceVersionisEmpty  ^childrenDictionary isEmptyremoteBranchNamed: aString ifPresent: presentBlock ifAbsent: absentBlock  self subclassResponsibilitytoString: anObject  ^self format ifNotNil: [ self format value: anObject ] ifNil: [ anObject ]newDirectoryDataSource  ^IceTipDirectoryDataSource new     tool: self;     directory: self model fileSystem;     yourselfcommitButton  ^commitButtonisCodeMissing  ^self subdirectory isEmptyOrNil ifTrue: [ self isMissing ] ifFalse: [ (self repositoryDirectory / self subdirectory) exists not ]storeInto: aCredentialStore forHostname: aHost  host := aHost.  aCredentialStore storeSshCredential: self forHostname: aHostremoveCredential: aCredential  aCredential removeFrom: self.  self saveIntoStoreusername  ^usernameInput textisChoiceBetween: firstOption and: secondOption  ^self optionA = firstOption and: [ self optionB = secondOption ]remoteName  ^(self fullname substrings: '/') thirdfirstNodeSuchThat: conditionBlock  ^self firstNodeSuchThat: conditionBlock ifNone: [ NotFound signalFor: conditionBlock ]execute  self packageModel load.  Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity)inverse  ^IceAddition definition: definitionaction  ^actioncanBeLoaded: aFileReference  ^(super canBeLoaded: aFileReference) and: [ aFileReference filename = self fileName ]commit  repository handleLibgitError: [ | gitCommit gitId |        gitId := (self repositoryHandle lookupRemoteBranch: self name) targetId.        gitCommit := LGitCommit of: self repositoryHandle fromId: gitId.        ^self repository commitFromGitCommit: gitCommit ]canBrowseReferences  ^falseclear  commentText text: ''newContextWithSelection: anObject  ^self newContextsourceDirectoryReference  ^commitish fileSystem resolve: self sourceDirectoryPathspacePanel: anObject  spacePanel := anObjectunknownError: aDictionary  ^String streamContents: [:stream |  (aDictionary associations sorted: [:a :b |  a key < b key ]) do: [:each |  stream << each key << ': ' << each value ] separatedBy: [ stream << ', ' ] ]toolbar: anObject  toolbar := anObjectinitialize  super initialize.  loader := MCPackageLoader newreferenceCommits  ^self workingCopy referenceCommitreaderClass  ^self commit readerClasskeepCurrentVersion  self selectedChangeWrapper chooseLocal.  self changed: #changes.  self updateSourceisModified  ^self project isDirty or: [ self loadedPackages anySatisfy: [:e |  e isDirty ] ]model: anObject  model := anObjectnotEmpty  ^falsehost  ^hostcheckoutAllPackages  self branch checkoutAllPackagesmergeOn: aModel then: aBlock  ^aModel mergeThen: aBlockrepository: anObject  repository := anObjectmergeWithLeftAddition: anIceAddition  self shouldNotImplementsetHead: anIceGitBranch  self subclassResponsibilityspacePanel  ^spacePanelbaseRemote  ^baseRemote ifNil: [ baseRemote := self obtainBaseRemote ]handlesMouseOver: evt  ^trueprojectName  ^(self location substrings: '/') third copyUpTo: $:newEmptyTab  ^self newTab     label: 'Info';     icon: (self iconNamed: #smallQuestion);     closeable: false;     contents: '(No commit selected)' asMorph;     yourselfavailableBranchNames  ^availableBranchNames ifNil: [ availableBranchNames := self obtainAvailableBranchNames ]tableRefresh  self table ifNil: [ ^self ].  ^super tableRefreshrefresh  | commitModels |  commitModels := self model commitModels.  commitList widget     in: [:this |  this dataSource elements: commitModels ];     refresh.  commitInfoTabs selectedModel: (commitModels ifNotEmpty: #first ifEmpty: [ nil ])visitAddition: anIceAddition  anIceAddition definition accept: selfonAccept: aBlock  acceptBlock := aBlockexecute  self repositoryModel discardChangesvisitNoModification: anIceNoModification  anIceNoModification definition addToPatcher: patcher.  self visitChildrenOf: currentNodecommitChanges: changes withMessage: message  ^self workingCopy commitChanges: changes withMessage: messagediff: anIceDiff  diff := anIceDiffinitializeDialogWindow: aWindow  super initializeDialogWindow: aWindow.  acceptButton label: 'Debug'.  cancelButton label: 'Ignore'commentPanel: anObject  commentPanel := anObjectisTrait: aName  | definition |  definition := snapshot classDefinitionNamed: aName ifAbsent: [ ^false ].  ^definition isTraitDefinitionbranchName  ^branchName ifNil: [ branchName := self obtainBranchName ]ensurePackageFromDirectory: aFileReference inParentNode: aParentNode  | importer packageName package |  packageName := version writerClass packageNameFromDirectory: aFileReference.  (aParentNode includesKey: packageName) ifTrue: [ ^self ].  package := IcePackage named: packageName repository: self repository.  importer := IceMCPackageImporter new     package: package;     version: version;     yourself.  ^importer importOn: aParentNodefirstNodeSuchThat: conditionBlock ifNone: noneBlock  (conditionBlock value: self) ifTrue: [ ^self ].  self nextNodeSuchThat: conditionBlock ifFound: [:found |  ^found ].  ^self parent ifNil: noneBlock ifNotNil: [ self parent nextChildNodeStartingFrom: self suchThat: conditionBlock ifNone: noneBlock ]iconName: aString  self icon: ((self iconNamed: aString) scaledToSize: 32 @ 32)mergeWithLeftNoOperation: anIceNoModification  ^IceNonConflictingOperation operation: anIceNoModificationbasicExecute  self subclassResponsibilityinitialize  super initialize.  checkoutStrategies := (IceCheckoutStrategy allSubclasses sorted: [:a :b |  a order < b order ]) collect: #new.  checkoutStrategy := checkoutStrategies firstvisitRootDefinition: anIceRootDefinition  self visitChildrenOf: currentNodepackage: aPackage  package := aPackagedisplayingProgressString  ^'Comparing image changes of ' , self package namecanHandleType: type  ^Iceberg enableMetacelloIntegration and: [ IceMetacelloRepositoryType canHandleType: type ]refresh  widgets removeAll.  self layout: self newLayout.  self layout newColumn: [:column |  self addWidgetsTo: column ]selectButton  ^selectButtonreadOnlyVersion  ^selfbackend  ^backendchosenOperation  ^chosen ifNil: [ operation ] ifNotNil: [ chosen ]initializeWidgets  leftPanel := self newPanelMorph.  rightPanel := self newPanelMorph     listDirection: #rightToLeft;     hResizing: #spaceFill.  panel := PanelMorph new     changeTableLayout;     listDirection: #leftToRight;     hResizing: #spaceFill;     vResizing: #spaceFill;     color: self color;     asSpecAdapter.  panel widget     addMorphBack: leftPanel;     addMorphBack: rightPanelmergeWith: anotherTree onMerge: mergeBlock  ^self mergeWith: anotherTree onLeft: [:each |  each ] onRight: [:each |  each ] onMerge: mergeBlockbrowse  | browsed |  browsed := Smalltalk globals at: name.  browsed isMeta ifTrue: [ browsed classSide ].  browsed browseasInteger  ^self major * 10000 + (self minor * 100) + self patchreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  announcer := IceTipWeakValueHolder contents: aToolContext toolAnnouncernewCellFor: item  | cell |  cell := FTIndentedCellMorph new.  cell indentBy: (self cellIndentFor: item).  cell addMorphBack: (self buttonFor: item).  (self iconFor: item data) ifNotNil: [:icon |  cell addMorphBack: icon asMorph ].  cell addMorphBack: (self toString: item data) asMorph asReadOnlyMorph.  ^cellmergeTree  self calculateChanges.  ^mergeTreedirectoryNameForPackage: package  ^(self writerClass directoryNameFor: package) asStringpackageNamed: packageName  ^self workingCopy packageNamed: packageNamerepository  ^diff repositoryproject  ^repository newUnbornProjectowner  ^(((self jsonAt: #base) at: #repo) at: #owner) at: #loginadditionColor  ^super removalColornewSidebarTreeDataSource  ^IceTipTreeOutlineDataSource new     tool: self;     rootForItems: self model repositoryModelsByGroup;     childrenBlock: [:each |  each children ];     icon: [:each |  each icon ];     format: #descriptionWithDecoration;     yourselfresolve: aRelativePath ifPresent: presentBlock ifAbsent: absentBlock  | segments node |  segments := aRelativePath segments.  segments ifEmpty: [ ^presentBlock value: self value ].  node := childrenDictionary at: segments first ifAbsent: [ ^absentBlock value ].  ^node resolve: (RelativePath withAll: segments allButFirst) ifPresent: presentBlock ifAbsent: absentBlockremote: anObject  remote := anObjecttagNames  ^self commit tagNamesisNewBranch  ^trueaddItem: aToolbarItem  items add: aToolbarItem.  self refreshinitializeWidgets  panel := self newIcePanel.  panel widget addMorphBack: (actionMorphPanel := PanelMorph new           changeTableLayout;           listDirection: #rightToLeft;           hResizing: #shrinkWrap;           vResizing: #spaceFill;           yourself)execute  IceTipAddSSHCredentialsModel new     credentialStore: store;     tool: tool;     openNonModalcommit  ^IceNoCommit repository: repositoryensureMCVersionWithClassOrganisation: mcVersion  ^mcVersion snapshot definitions detect: [:each |  each isClassDefinition ] ifFound: [:each |  mcVersion ] ifNone: [ MCVersion package: mcVersion package info: mcVersion info snapshot: (MCSnapshot fromDefinitions: {(MCOrganizationDefinition categories: {mcVersion package name})} , mcVersion snapshot definitions) ]rootFileReference  ^repository locationheaderColumn: column  column id ifNil: [ ^nil ].  ^column newHeader     target: self;     actionSelector: #actionColumn:;     arguments: {column};     yourselfresponse: anObject  response := anObjectfirst  ^firstisInMerge  ^self workingCopyState isInMergeshowInfoTabs  (commitTabPanel tabs includes: infoTab) ifFalse: [ self removeAllCommitPanelTabs.        commitTabPanel           addTab: infoTab;           addTab: headTabContainer tab;           addTab: ancestorTabContainer tab ].  self refreshCommitInfo.  self refreshDiffFromHeadLabel.  self refreshDiffFromAncestorLabel.  commitTabPanel selectedTab ifNotNil: #tabSelectedisSelected: anObject  ^selectedItems includes: anObjectisResumable  ^truenameLabel: anObject  nameLabel := anObjectpackageNames  ^self packagesDictionary keysread: anObject  ^self action value: anObjectlabelFor: aCommitModel  ^'{1} to HEAD' format: {(aCommitModel ifNotNil: #shortId)}reload  self loadbodyText: anObject  bodyText := anObjectacceptError: aVisitor  aVisitor visitRemoteAlreadyExistError: selfvisitOrganizationDefinition: aMCOrganizationDefinition  packageNode value categories: aMCOrganizationDefinition categoriespattern: anObject  pattern := anObjectreferenceCommits  ^{self referenceCommit}currentCommits  ^repository workingCopy referenceCommitsdefaultMenuItemName  ^'View Pull Requests'sourceVersion  ^sourcedelete  < noCache>  IceTipStandardAction new     repository: self entity;     message: ('Deleting {1}' format: {self name});     execute: [ self entity delete ]addProjectFileTo: aRepository  | newProject |  newProject := IceBasicProject onRepository: aRepository.  newProject sourceDirectory: self subdirectory.  aRepository workingCopy basicSetProject: newProjectcommonAncestorWith: aCommitish  ^aCommitish commonAncestorWithCommit: selfisValidPackage: aFileReference  ^self writerClass isValidPackage: aFileReferencedoPull  self model pullThen: [ self window delete ]updateText: aString  issueText text: aString.  fetched := trueaddTo: aMCRepositoryGroup  onSelectionChangedBlock: anObject  onSelectionChangedBlock := anObjectrepositoryModel  ^selfpeelTag: anIceTag  self handleLibgitError: [ | lgitRef |        lgitRef := self repositoryHandle lookup: 'refs/tags/' , anIceTag name.        ^self lookupCommit: lgitRef targetId hexString ]store  ^storechildren  ^children ifNil: [ children := Dictionary new ]initializeWidgets  changeList := self newIceTable.  diffPanel := self instantiate: DiffPresenter.  self initializeChangeList.  self initializeDiffPanel.  changeList widget onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self.  self whenBuiltDo: [:ann |  self addShortcutsTo: ann widget ].  self focusOrder     add: changeList;     add: diffPanelcommit  ^streamhttpsUrl  ^'https://{1}/{2}.git' format: {self host .         self projectPath}fileUtils  ^IceLibgitTonelFileUtilsexecute: aBlock  self action: aBlock.  self executeicon  ^self iconNamed: #addchooseConflictPolicyProject: projectName optionA: optionA optionB: optionB  ^UIManager default chooseFrom: {('Use INCOMING version {1}' format: {optionA}) .         ('Use LOADED version {1}' format: {optionB})} values: {#useIncoming .         #useLoaded} message: ('There are conflicting versions of project "{1}".' format: {projectName}) title: 'Conflicting project versions'composeUrlWithHost: host repositoryPath: path  ^'https://{1}/{2}.git' format: {host .         path}title  ^title ifNil: [ self model name ]accept: aVisitor  ^aVisitor visitNonConflictingOperation: selfextent  ^800 @ 175formatLabel  ^formatLabelinitializeWidgets  super initializeWidgets.  sidebarTree := self newIceOutline.  historyPanel := self instantiate: IceTipHistoryBrowser on: self model headModel.  historyPanel beForMerge.  self initializeSidebarTree.  sidebarTree widget onAnnouncement: FTSelectionChanged send: #commitishSelected: to: self.  self focusOrder     add: historyPanel;     add: sidebarTreeinitialExtent  ^self hasToShowWarning ifTrue: [ (475 @ 500) scaledByDisplayScaleFactor ] ifFalse: [ (475 @ (200 + (self class inputTextHeight * 3) + self class buttonHeight + 50)) scaledByDisplayScaleFactor ]storeOnFileReference: aFileReference  aFileReference     ensureDelete;     writeStreamDo: [:stream |  (STONWriter on: stream)           prettyPrint: true;           newLine: OSPlatform current lineEnding;           nextPut: self properties ]addTo: aMCRepositoryGroup  initializeWidgets  super initializeWidgets.  diffPanel leftLabel: 'Working Copy'.  diffPanel rightLabel: 'Merge with ' , model targetNameprojectName  ^path basenametags  self handleLibgitError: [ ^self repositoryHandle tags collect: [:each |  IceTag named: each inRepository: self ] ]newPatchMorph  ^IceTipMergePatchMorph new     borderWidth: 0;     addDependent: self;     yourselfbaseDefaultBranchName  ^self gitBase at: #default_branchextractTypeFromDescription: description  (description beginsWith: 'ftp://') ifTrue: [ ^'ftp' ].  IceMetacelloRepositoryType allTypes detect: [:each |  each isSuitableForLocation: description ] ifFound: [:class |  ^class type ].  ^super extractTypeFromDescription: descriptionisModified  ^self workingCopy isModifiedmessageBody  | errors |  errors := self jsonContents at: #errors ifAbsent: [ ^'' ].  ^String streamContents: [:stream |  errors do: [:each |  stream << (self errorToString: each) ] separatedBy: [ stream cr ] ]newBaselineDefaultCommand: anIcePackage  ^IceTipMetacelloInstallBaselineDefaultCommand new     repositoryModel: self repositoryModel;     package: anIcePackage;     yourselfhasOutgoingCommitsTo: aRemote  | localCommits remoteCommits |  self tracksRemoteBranch ifFalse: [ ^false ].  localCommits := self commits.  remoteCommits := self trackedBranch commits.  ^localCommits anySatisfy: [:each |  (remoteCommits includes: each) not ]createTag: aString  self subclassResponsibilitytargetUrlCellColumn: column rowIndex: rowIndex  | url |  url := (self elementAt: rowIndex) at: column id.  ^FTCellMorph new     addMorphBack: (IconicButton new           target: self;           actionSelector: #copyToClipboard:;           arguments: {url};           labelGraphic: ((self iconNamed: #smallCopy) scaledToSize: 12 @ 12);           color: Color transparent;           helpText: ('Copy url {1} to clipboard' format: {url});           borderWidth: 0;           yourself);     yourselfunload  self loadedPackages do: [:each |  self unloadPackage: each ]drawBadgeOn: aCanvas  | badgeString badgeBounds textBounds textWidth textHeight width |  badgeString := self badge asString.  textWidth := self badgeFont widthOfString: badgeString.  textHeight := self badgeFont height.  width := 14 max: textWidth + 2.  badgeBounds := (bounds right - width - 2) @ (bounds top + 2) extent: width @ 14.  aCanvas fillOval: badgeBounds fillStyle: self badgeColor.  textBounds := badgeBounds center - (textWidth @ textHeight / 2.0) + (1 @ 0) extent: textWidth @ textHeight.  aCanvas drawString: badgeString in: textBounds font: self badgeFont color: self badgeTextColorremote  ^remotevalidate  self assert: self projectNameInputText text isNotEmpty description: 'You must enter a project name (it will be used also as part of the path).'.  self assert: self projectLocation location notNil description: 'Project location must be defined (if it does not exists, it will be created).'repository  ^repositoryhandleKeystroke: anEvent  anEvent wasHandled ifTrue: [ ^self ].  self allowsKeymapping ifTrue: [ self dispatchKeystrokeForEvent: anEvent ]mergeHistoryFromSecondAncestor  < noCache>  ^self mergeHistoryFromAncestor: self entity ancestors seconddescription  ^'User: ' , usernameleftContents  ^''subdirectory  ^self entity subdirectorynewRepositoriesDataSource  ^IceTipDataSource new     tool: self;     elements: self model repositories;     yourselfresetToCommit: anIceTipCachedModel  entity resetToCommit: anIceTipCachedModel entitydo: aBlock  self action: aBlock.  self executewarningMessage  ^'Be careful. You should choose the actual format of the current repository.Changing the format in here will not migrate your code to another format.If you want to migrate your code from Filetree to Tonel, use the migration option in the context menu (Extra >> Convert repository sources to Tonel).'diffTo: aCommitish  ^IceDiff from: self to: aCommitish commitinitializeWidgets  reasonPanel := self newIcePanel.  optionsList := self newIceTable.  detailPanel := self newIcePanel.  self initializeReasonPanel.  self initializeOptionsList.  self focusOrder add: self optionsListtracksRemoteBranch  ^self hasUpstreamrepository  ^repositorydiff: anIceDiff  diff := anIceDiffaddRemote: aString  self remote: (IceGitRemote url: aString)readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  branchModel := aToolContext itemsubdirectory  ^self project sourceDirectoryinitialize  super initialize.  choices := Set newobtainPlaintextCredentials: response  LGitNoCredentialsProvided signaldoCommit  self doCommit: diffPanel selectedItems message: commentPanel message pushing: commentPanel isPushingmenuColumn: column row: rowIndex  | menuSelection context |  menuSelection := self elementAt: rowIndex.  context := self menuSelectionContextWithSelection: menuSelection data.  ^CmdContextMenuActivation buildContextMenuFor: self table inContext: contextinitializeWidgets  super initializeWidgets.  usernameLabel := self newLabel label: 'Username: '.  usernameInput := self newTextInput     text: 'git';     autoAccept: true;     whenTextChanged: [ self updateOkButton ];     yourself.  passphraseLabel := self newLabel label: 'Key Passphrase: '.  passphraseInput := self newTextInput     beEncrypted;     autoAccept: true;     whenTextChanged: [ self updateOkButton ];     yourself.  privateKeyInput := IceTipFilePresenter new     label: 'Private Key';     onChoose: [ self updateOkButton ];     chooseTitle: 'Select Private Key';     whenTextChanged: [ self updateOkButton ];     yourself.  publicKeyInput := IceTipFilePresenter new     label: 'Public Key';     onChoose: [ self updateOkButton ];     chooseTitle: 'Select Public Key';     whenTextChanged: [ self updateOkButton ];     yourselfaction: anObject  action := anObjectselector  ^nameokAction  credentialStore storeCredential: self credentials forHostname: self host.  tool refreshaccept: aVisitor  ^aVisitor visitDirectoryDefinition: selftagName: aString  tagName := aStringgithub  ^IceGitHubAPI new     credentials: self credentials;     yourselfcommitDictionary  commitDictionary ifNil: [ self lookupCommits ].  ^commitDictionarybadgeColor  ^Smalltalk ui theme badgeColorusername  ^self nameInput text trimBothinitialize  super initialize.  self childrenBlock: [:directory |  directory isDirectory ifTrue: [ self childrenToShowFrom: directory ] ifFalse: [ #() ] ]setModelBeforeInitialization: anObject  model := anObjectcolor  ^color ifNil: [ Color transparent ]allChildrenDo: aBlockClosure  self childrenDo: [:e |  aBlockClosure value: e.        e allChildrenDo: aBlockClosure ]remoteLabel: anObject  remoteLabel := anObjectmessage  ^messagespacePanel  ^spacePanelisEmpty  ^mergeTree isEmptymessagePanel  ^messagePanelrepository: anObject  repository := anObjectreadParametersFromContext: aToolContext  repositoryModel := aToolContext repositoryModelsourceDirectory  ^self subclassResponsibilitypackage  ^packageget: aString parameters: aDictionary  ^self jsonContentsWithValidationDo: [ (self newRequestTo: aString , (String streamContents: [:stream |  stream << '?'.                          aDictionary associations do: [:keyPair |  stream << keyPair key << '=' << keyPair value ] separatedBy: [ stream << '&' ] ]))           get;           response ]host  ^hostfetch  localRepository handleLibgitError: [ [ (LGitRemote of: self repositoryHandle named: self name)           lookup;           fetchWithCredentials: (IceCredentialsProvider defaultForRemote: self) andProgressCallback: IceGitTransferProgress new ] on: LGitAbstractError do: [:e |  e acceptError: (IceLibgitErrorVisitor onContext: self) ].        localRepository postFetch ]addShortcutsTo: aWidget  self enableCommanderShortcutsIn: aWidgetisUndefined  ^truebrowse  | owner |  owner := Smalltalk globals at: self className.  self classIsMeta ifTrue: [ owner := owner classSide ].  (owner >> name) browseinfo  ^{('Commit:' -> ('[' , self shortId , '] ' , self id)) .   ('Parents:' -> (self entity ancestors collect: #shortId) asCommaString) .   ('Author:' -> self entity author) .   ('Date:' -> self entity timeStamp asStringYMDHM) .   ('Tags:' -> self entity tagNames asCommaString) .   ('Comment:' -> self entity comment)}cellIndentFor: item  ^(item depth - 1) * 16 + 3canBeBrowsed  ^Smalltalk globals includesKey: nameurlText  ^urlTextremoteName  ^remoteNamecommonAncestorWith: aCommitish  ^self referenceCommit commonAncestorWith: aCommitishnewActionButton  ^self newButton     label: 'Push';     icon: (self iconNamed: #up);     help: ('Push new commits to {1}' format: {self model remoteName});     action: [ self doPush ];     yourselfreplaceBy: aNode  parent replace: self with: aNodeasMCDefinition  ^MCMethodDefinition className: self className classIsMeta: self classIsMeta selector: self name category: self protocol timeStamp: '' source: sourceCodeloadPackageNamed: aString fromCommit: aCommit  self loadPackagesNamed: {aString} fromCommit: aCommitexecute  self action cull: self= anotherObject  ^self species = anotherObject species and: [ properties = anotherObject properties ]obtainBranchName  | baseName suffix count |  count := 0.  baseName := self class branchBaseName.  suffix := ''.  [ true ] whileTrue: [ self repository branchNamed: baseName , suffix ifAbsent: [ ^baseName , suffix ].        count := count + 1.        suffix := '-' , count asString ]basicExecute  | dialog |  dialog := IceTipLocalRepositoryPanel new     location: (self repository location ifNil: [ self defaultLocation ]);     yourself.  dialog openDialogWithSpec okAction: [ dialog validate.        self repositoryModel updateLocation: dialog location.        true ]descriptionWithDecoration  ^self namefileFormat: aFileFormat  self fileFormatId: aFileFormat idwriterClass  ^self project writerClasssubscribeToAnnouncements  Iceberg announcer weak when: IceAnnouncement send: #refresh to: selfmergeablePanel  ^mergeablePanelbadge  ^nilcommitList  ^commitListgetRepository: owner project: projectName  ^self get: 'repos/' , owner , '/' , projectNameaddPropertiesFileTo: aRepository  aRepository properties fileFormat: self formatToUseacceptCallback  ^acceptCallbackacceptError: aVisitor  aVisitor visitRemoteDesynchronizedError: selfnewDiffPanelLeft: leftString right: rightString  ^(self instantiate: DiffPresenter)     leftText: leftString;     rightText: rightString;     showOptions: false;     buildWithSpecurlText  ^urlTextaddItemLeft: aMorph  self leftPanel addMorphBack: (self prepareItemToAdd: aMorph)name  ^definition namepath  ^RelativePath withAll: self allPathSegmentscomment  ^iceCommit commentincomingCommitsFrom: aRemote  | remoteBranch |  remoteBranch := aRemote remoteBranchNamed: self name ifAbsent: [ ^#() ].  ^remoteBranch newCommitWalk     uptoCommit: self commit;     commitsaccept: anIceChangeImporter  anIceChangeImporter visitCypressPropertiesChange: selficonPanel: anObject  iconPanel := anObjecthash  ^self name hashurl: anObject  url := anObjectoutgoingCommits  ^self branch outgoingCommitsrepositoryModel  ^repositoryModelcontextClass  ^IceTipCredentialsStoreContextjsonContentsWithValidationDo: aBlock  ^STON fromString: (self contentsWithValidationDo: aBlock)hasUpstream  ^entity hasUpstreamtool: aTool  tool := aToolvalidateCanCommit  self workingCopy referenceCommit first = repository head commit ifFalse: [ IceWorkingCopyDesyncronized signal ]username  ^usernameInput textupdated  ^selfbasicInstallBaseline: icePackage groups: anArray  | packageDir baselineName sourceDirectory |  sourceDirectory := icePackage repository project sourceDirectory.  sourceDirectory ifEmpty: [ sourceDirectory := '.' ].  packageDir := (icePackage repository location / sourceDirectory) fullName.  baselineName := icePackage name allButFirst: self class baselinePrefix size.  Metacello new     repository: 'gitlocal://' , packageDir;     baseline: baselineName;     onUpgrade: [:e |  | policy |        policy := self chooseUpgradePolicyFor: e.        policy ifNotNil: [ e perform: policy ] ];     onConflict: [:e |  | policy |        policy := self chooseConflictPolicyFor: e.        policy ifNotNil: [ e perform: policy ] ];     load: anArrayinitializeOptionsList  optionsList widget     addColumn: (IceTipTableColumn newAction: #title icon: #icon);     dataSource: self newOptionsListDataSource;     bindKeyCombination: Character cr toAction: [ self accept ];     onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self;     onAnnouncement: FTStrongSelectionChanged send: #accept to: selfcontextSelection  ^self changeSelectedensureMethodOwnerNamed: ownerName isMeta: isMeta isTrait: isTrait isExtension: isExtension  | newDefinition |  newDefinition := isExtension ifTrue: [ IceExtensionDefinition named: ownerName isMeta: isMeta ] ifFalse: [ isTrait ifFalse: [ IceClassDefinition named: ownerName isMeta: isMeta ] ifTrue: [ IceTraitDefinition named: ownerName isMeta: isMeta ] ].  ^packageNode childAt: newDefinition key ifAbsentPut: [ newDefinition ]execute  (IceTipRemovePackageDialog on: self packageModel) openDialogWithSpecmodel: anObject  model := anObject.  self refreshupdateContentsOn: aCommitModel  aCommitModel ifNil: [ ^self ].  self tab contents: (self newDiffPanelFor: (self diffFor: aCommitModel)) buildWithSpecvisitERROR: anError  anError object = LGitErrorTypeEnum giterr_ssh ifTrue: [ anError resignalAs: IceAuthenticationError new ].  anError object value = LGitReturnCodeEnum git_euser value ifTrue: [ self visitEUSER: anError ].  anError messageText trimmed = 'Unexpected HTTP status code: 404' ifTrue: [ IceCloneRemoteNotFound signalFor: context url ].  self visitGenericError: anErrorcheckoutAllPackages  repository checkout: (IceCheckoutAllPackages new           committish: self;           yourself)credentials  ^credentials ifNil: [ credentials := self obtainCredentials ]visitENOTFOUND: anError  NotFound signal: anError messageTextdescriptionWithDecoration  ^self subclassResponsibilityinitializePresenter  super initializePresenter.  self putFocusOrderindex  ^indexfillDefaultMenu: aMenu using: aCommandActivator baseline: aPackage  | concreteCommand |  concreteCommand := self newBaselineDefaultCommand: aPackage.  self fillMenu: aMenu title: ('Install baseline of {1} (default)' format: {(self nameOfBaseline: aPackage)}) command: concreteCommand activator: aCommandActivator baseline: aPackageusername  ^username ifNil: [ username := self class defaultUsername ]userNameLabel  ^userNameLabelreferenceCommits  ^{referenceCommit}iconFor: aDirectory  ^self iconNamed: #emptyPackagenewTypeListDataSource  ^IceTipDataSource new     tool: self;     elements: self allTypes;     yourselflistPanel  ^listPanelstate  ^self jsonAt: #statefileUtils  ^IceLibgitFiletreeFileUtilsremoteBranchNamed: aName ifAbsent: absentBlock  ^self branchNamed: aName ifPresent: [:branch |  branch ] ifAbsent: absentBlockleftContents  ^operation leftContentshead  ^self lookupHeadprojectName: anObject  projectName := anObjectcreateCommandContext  ^self newContextWithSelection: self contextSelectioninitializeMessagePanel  self hasToShowWarning ifTrue: [ messagePanel := self instantiate: IceTipReadOnlyTextMorphWithIcon.        messagePanel iconName: #warning.        messagePanel text: self warningMessage ] ifFalse: [ messagePanel := self newIcePanel.        messagePanel widget height: 1 ]iconForStatus: status  ^self iconNamed: (self iconNameForStatus: status)className  ^classNamefileName: aString  fileName := aStringokAction  ^self subclassResponsibilityrepository  ^repositoryiconName  ^#githubreaderClass  ^self properties readerClassbranchNamePrefix  ^'refs/heads/'latestTagParts  ^self latestTagPartsIn: (commitishToTag tagModels collect: #name)initializeBranchesList  | dataSource |  branchesList widget     addColumn: (IceTipTableColumn newAction: #shortDescriptionWithDecoration);     dataSource: (dataSource := self newBranchListDataSource);     bindKeyCombination: Character cr toAction: [ self accept ];     onAnnouncement: FTStrongSelectionChanged do: [ self accept ].  self model branchModels detect: #isHead ifFound: [:head |  branchesList widget selectIndex: (dataSource elements indexOf: head) ] ifNone: [ self model hasBranches ifTrue: [ branchesList widget selectFirstVisibleRow ] ]hash  ^(super hash << 10) + package hashshowWidget  contextSelection  ^typeisLoaded  ^repository workingCopy isLoadedPackageNamed: self packageNamecommitIdFor: aWorkingCopy ifFound: aBlock  self flag: #todoremoveFile: anIceFileDefinition  (repository location resolvePath: anIceFileDefinition path) ensureDeletecreateCommandContext  ^self newContextreadParametersFromContext: aToolContext  store := aToolContext store.  tool := aToolContext toolselectedItem  ^self table selectedRowIndexes ifNotEmpty: [:indexes |  self elementAt: indexes first ] ifEmpty: [ nil ]notAllConflictsResolved  ^self model mergeTree anySatisfy: [:item |  item isConflict and: [ item isResolved not ] ]gitRef  ^self nameiconNamed: aSymbol  ^Smalltalk ui icons iconNamed: aSymbolfetchPackageNames  | writerClass dir |  writerClass := self writerClass.  dir := self fileSystem resolve: self project sourceDirectory.  dir exists ifFalse: [ ^#() ].  ^dir children select: [:each |  writerClass isValidPackage: each ] thenCollect: [:each |  writerClass packageNameFromDirectory: each ]toFileName: aMethod  ^self fileNameForMethod: aMethoddefaultMenuItemName  ^'New Pull Request'icon: anIcon  icon := anIconpasswordInput  ^passwordInputaccept: aVisitor  ^aVisitor visitFileNode: selfaccept: aVisitor  ^aVisitor visitGitChange: selfinitialExtent  ^(700 @ 700) scaledByDisplayScaleFactormergeOn: aModel then: aBlock  ^aModel switchAndMergeThen: aBlockresetDataSource: aDataSource  ^aDataSource     rootForItems: self model treeRoots;     expandAllpackageLocationFor: anIceSavedPackage  | packageLocation directoryName |  packageLocation := self location.  self subdirectory ifNotEmpty: [ packageLocation := packageLocation / self subdirectory ].  directoryName := self writerClass directoryNameFor: anIceSavedPackage.  packageLocation := packageLocation / directoryName.  ^packageLocationhasBranches  ^self branches isNotEmptystatus  (self repository workingCopy referenceCommits includes: self) ifTrue: [ 'Current' ].  (self repository workingCopy referenceCommits anySatisfy: [:each |  each isNoCommit not and: [ self isAncestorOf: each ] ]) ifTrue: [ ^'Loaded' ].  (self repository branch newCommitWalk includesCommit: self) ifTrue: [ ^'Not loaded' ].  ^'Not merged'suspendAllWhile: aBlock  | previousSuspensionState |  previousSuspensionState := suspendAll.  suspendAll := true.  aBlock ensure: [ suspendAll := previousSuspensionState ]recordChoice: anIceMetacelloLoadChoice  ^choices add: anIceMetacelloLoadChoiceensureProjectFile  ensureProjectFile := trueinverse  self subclassResponsibilityhelp: anObject  help := anObjectbodyPanel: anObject  bodyPanel := anObjectdefaultLocation  ^IceLibgitRepository repositoriesLocationtracksRemoteBranch  ^falsereadProjectFromCommitish: anIceCommitish  ^IceUnbornProject onCommitish: anIceCommitishchildrenToShowFrom: aDirectory  ^(aDirectory children select: [:each |  each isDirectory and: [ (each basename beginsWith: '.') not ] ]) sort: [:a :b |  a basename < b basename ]leftOperation: anOperation  leftOperation := anOperationminorButton  ^minorButtonproject  ^project ifNil: [ self refreshProjectFromRepository ]mcRepository  self subclassResponsibilityexecute  (IceTipHistoryBrowser on: commitModel mergeHistoryFromSecondAncestor) openWithSpecaddToChangeBuilder: anIceChangeImporter  anIceChangeImporter addFileNamed: self propertiesFilePath segments last path: self propertiesFilePath contents: self contentsStringrepository: anObject  repository := anObjectaccept  IceTipStandardAction new     repository: model repository;     message: 'Setting up project';     onSuccessRepositoryModified;     execute: [ model sourceDirectory: self selectedDirectoryPath pathString.        model fileFormat: self selectedFileFormat.        self assert: model repositoryProperties fileFormat = self selectedFileFormat.        model repository workingCopy project: model ].  self window delete.  acceptCallback ifNotNil: [ acceptCallback value ]mergeWithLeftRemoval: anIceRemoval  self shouldNotImplementpublicKey  ^publicKeyInput location ifNil: [ '' ] ifNotNil: [:x |  x pathString ]remote  ^remote ifNil: [ | head |        head := self repositoryModel entity head.        remote := (head isBranch and: [ head hasUpstream ]) ifTrue: [ head upstream remote ] ifFalse: [ self remoteModels first entity ] ]commitish: aCommitish  commitish := aCommitishbeHttps  protocol := IceHttpsProtocol newoutgoingCommits  ^#()hideYourselfFromCommitWalk: commitWalk  commitWalk uptoCommit: self commitmouseLeave: evt  self flag: #bad.  ^self eventHandler ifNotNil: [ self eventHandler mouseLeave: evt fromMorph: self ]repository  ^repositorycancelAction  committish: aCommittish  committish := aCommittishinitialize  super initialize.  date := Date today.  time := Time nowrefreshWhenRepository: ann  (self model isModelOf: ann repository) ifFalse: [ ^self ].  self model reset.  self refreshbranches  self subclassResponsibilitytrackedBranch  | upstream |  upstream := self upstream.  upstream ifNil: [ upstream := self setUpstream: (self lookupRemoteBranch: '/origin/' , self name) ].  ^upstreamcommitTabPanel: anObject  commitTabPanel := anObjectcheckoutStrategies  ^IceCheckoutStrategy allStrategiespattern  ^patternpatch  ^patchbranchesList  ^branchesListaddTo: aTree  aTree addNode: selfbeSsh  protocol := IceSSHProtocol newwriterClass  ^self properties at: 'format' ifPresent: [:v |  TIceRepositoryWriter users detect: [:each |  each id = v ] ] ifAbsent: [ commitish project isInvalid ifFalse: [ IceLibgitRepository defaultFileFormat ] ifTrue: [ TIceRepositoryWriter users detect: #isLegacyDefault ifNone: [ Smalltalk at: #IceLibgitFiletreeWriter ] ] ]hasUpstream  self upstreamIfNone: [ ^false ].  ^trueaddModification: anIceModification toPatcher: aMCPatcher  (self isMeta and: [ mcDefinition isNil ]) ifTrue: [ ^self ].  aMCPatcher modifyDefinition: anIceModification rightDefinition asMCDefinition to: anIceModification leftDefinition asMCDefinitionremote: anObject  remote := anObjectcontextClass  ^IceTipDiffContextvalidateIssue: aString  | number remote |  fetched := false.  aString trimmed isEmpty ifTrue: [ ^self ].  aString isAllDigits ifFalse: [ ^self ].  number := aString asNumber.  (issue isNil or: [ (issue at: 'number') ~= number ]) ifFalse: [ ^self ].  remote := self selectRemoteModel remote.  self wait: 500 milliSeconds thenDo: [ [ issue := IceGitHubAPI new           beAnonymous;           getIssue: remote owner project: remote projectName number: number.        UIManager default defer: [ self updateText: (self sanitizeTitle: (issue at: 'title')) ] ] on: IceGitHubError do: [:e |  e messageText = 'Not Found' ifFalse: [ e pass ].              UIManager default defer: [ self updateText: self class unknownTitle ] ] ]visitNoModification: anIceNoModification  anIceNoModification definition accept: selfsetUpstreamRemote: aRemote  self setUpstream: (aRemote remoteBranchNamed: self name)items  ^itemssshCredentialForHostname: aHostname  ^self lookup: aHostname in: sshCredentials ifAbsent: [ self defaultSSHCredential ]hash  ^self leftDefinition hashvisitNoRemote: anError  self visitGenericError: anErroricon: anIcon  iconWidget widget     removeAllMorphs;     addMorphBack: anIcon asMorphdiscardChanges: aTree  self loadChangesInWorkingCopy: (aTree collect: [:definition |  definition inverse ]).  self refreshDirtyPackagescommit  ^commit ifNil: [ commit := self repository peelTag: self ]contextClass  ^nilload  loader loadinitialize  super initialize.  job := IceExternalJob new     title: self title;     yourself.  self initializeBlockdisplayMode: anObject  displayMode := anObjectremoveFrom: aVisitor  aVisitor remoteFileReferenceInPath: self pathtoolbar  ^toolbarvalidate  ^self subclassResponsibilityexecute  (IceTipCheckoutBranchDialog on: self repositoryModel) openDialogWithSpeconSelectionChangedBlock  ^onSelectionChangedBlockcheckoutStrategyLabel  ^checkoutStrategyLabelexecute  tool collapseAllhasIncomingCommitsFrom: aRemote  ^self branch hasIncomingCommitsFrom: aRemoteaccept: aVisitor  self subclassResponsibilitytitle  ^'Browsing pull request: #{1} {2}' format: {self pullRequest number .         self pullRequest title}providePlaintextCredentialsTo: credentials  tries := tries + 1.  tries >= 3 ifTrue: [ Transcript           show: 'aborting';           cr.        LGitNoCredentialsProvided signal: 'There where already three failed attempts, aborting' ].  tries = 1 & self plaintextCredentials isPresent ifTrue: [ credentials readFrom: self plaintextCredentials ] ifFalse: [ self obtainPlaintextCredentials: credentials ]onCommit: aBlock  commitButton action: [ aBlock cull: self message cull: self isPushing ]defaultSubdirectory  ^IceLibgitRepository defaultCodeSubdirectorymodel: anObject  super model: anObject.  self refreshhasUnbornProject  ^self entity workingCopy project isUnborntoLabel: anObject  toLabel := anObjectremoteBranches  ^branches ifNil: [ branches := self requestRemoteBranches ]at: aKey put: anObject  ^objects at: aKey put: anObjectaddRow: labelId value: valueId isLast: isLast to: column  isLast ifTrue: [ column newRow: [:row |  row                 newColumn: labelId width: self iceLabelWidth;                 newColumn: valueId ] ] ifFalse: [ column newRow: [:row |  row                 newColumn: labelId width: self iceLabelWidth;                 newColumn: valueId ] height: self rowHeight ]accept  self validate.  self doAccept.  acceptBlock ifNotNil: [ acceptBlock cull: self ]name: anObject  name := anObjectrefreshProject  repository commitsInPackageCache: nil.  self refreshPackagesrepositoryDirectory  ^self locationremoteList: anObject  remoteList := anObjecthasIncomingCommits  self hasUpstream ifFalse: [ ^false ].  ^self hasIncomingCommitsFrom: self upstream remotename  ^commitish namescpUrl  ^'{1}@{2}/{3}.git' format: {self user .         self host .         self path}initialize  super initialize.  datetime := DateAndTime nowinitializePackagesList  | dataSource |  dataSource := self newPackagesListDataSource.  packagesList widget     addColumn: (IceTipTableColumn newAction: #name icon: [:each |  self iconNamed: #package ]);     dataSource: dataSource;     useFunction: IceTipLinkFilterFunction do: [:function |  function           filterClass: IceTipPackageFilter;           textField: self packageNameText ];     bindKeyCombination: Character cr toAction: [ self accept ];     onAnnouncement: FTStrongSelectionChanged do: [ self accept ]uptoCommits: commits  commits do: [:commit |  self uptoCommit: commit ]info  ^info ifNil: [ info := IceMCVersionInfo new fromCommit: self commit package: package ]askRemote: aRepository  ^aRepository remotes anyOneinverse  ^IceRemoval definition: definitionhasChanges  ^value hasChanges or: [ self children anySatisfy: [:child |  child hasChanges ] ]allTypes  ^types ifNil: [ types := IceTipRepositoryTypePanel allTypes ]accept: anIceChangeImporter  anIceChangeImporter visitProjectChange: selfswitchToCommitishNamed: aString  ^(self commitishNamed: aString)     switch;     yourselfasMCDefinition  ^mcDefinitionvisitGenericError: anError  IceGenericError new     messageText: anError messageText;     wrappedException: anError;     signalapi: anObject  api := anObjectcode  ^self response statuscontextClass  ^IceTipWorkingCopyContextactualClass  ^self item value actualClassorigin  ^self remoteNamed: 'origin' ifAbsent: [ IceUndefinedRemote new           name: 'origin';           yourself ]visitAuthenticationError: anError  self visitGenericError: anErrorpullRequest: anObject  pullRequest := anObjectaddPath: aPath  modifiedFilePaths add: aPathrepositoryModel: anObject  repositoryModel := anObjectchangesFromNoCommit: anIceNoCommit  ^self packages collect: [:each |  IceImageChange package: each ]fileName: aString  fileName := aStringhasOutgoingCommitsTo: aRemote  ^falseinitializeDialogWindow: aWindow  acceptButton := aWindow toolbar okButton.  cancelButton := aWindow toolbar cancelButtonfirstCommit  ^self commitsDo: [:commit |  ^commit ]isLocalRepository  ^falseworkingCopyState  referenceCommit isCollection ifTrue: [ ^IceInMergeWorkingCopy repository: repository ].  referenceCommit isUnknownCommit ifTrue: [ ^IceUnknownVersionWorkingCopy repository: repository ].  referenceCommit isNoCommit ifTrue: [ ^IceEmptyWorkingCopy repository: repository ].  ^IceAttachedSingleVersionWorkingCopy repository: repositorytreeRoots  ^self tree childrenprintOn: aStream  aStream     nextPutAll: self class name;     nextPutAll: '(';     nextPutAll: self id asString;     nextPutAll: ')'commitsPanel  ^commitsPanelinitializeNextTagPanel  | parts prefix nextMajor nextMinor nextPatch toString |  parts := self latestTagParts.  prefix := parts first.  parts := parts allButFirst.  toString := [:arr |  (arr collect: #asString) joinUsing: '.' ].  nextMajor := prefix , (toString value: (Array with: parts first + 1 with: 0 with: 0)).  nextMinor := prefix , (toString value: (Array with: parts first with: parts second + 1 with: 0)).  nextPatch := prefix , (toString value: (Array with: parts first with: parts second with: parts third + 1)).  majorButton := self newButton     label: 'major (' , nextMajor , ')';     action: [ tagNameInputText text: nextMajor ].  minorButton := self newButton     label: 'minor (' , nextMinor , ')';     action: [ tagNameInputText text: nextMinor ].  patchButton := self newButton     label: 'patch (' , nextPatch , ')';     action: [ tagNameInputText text: nextPatch ]resetDataSource: aDataSource  super resetDataSource: aDataSource.  aDataSource selectAllannounce: anAnnouncement  (self isAnnouncementSuspended: anAnnouncement) ifTrue: [ ^anAnnouncement asAnnouncement ].  ^super announce: anAnnouncementauthorText: anObject  authorText := anObjectaddItem: anObject into: aToolbar  aToolbar addItemRight: anObjecticon  ^self iconNamed: #traitsetModelBeforeInitialization: anObject  repository := anObjectactionPanel: anObject  actionPanel := anObjectinitialize  super initialize.  plainCredentials := Dictionary new.  sshCredentials := Dictionary newhasRemoteNamed: aString  self remoteNamed: aString ifAbsent: [ ^false ].  ^truecommonAncestorWith: anIceWorkingCopy  ^self commit commonAncestorWith: anIceWorkingCopydefaultBranchSelection  ^self branchModels detect: #isHead ifNone: [ self hasBranches ifTrue: [ self branchModels ifNotEmpty: #anyOne ] ]packageModel  ^packageModelverifyNeedsRefreshOrClose  self model reset.  diffPanel model reset.  diffPanel model isEmpty ifTrue: [ ^self window close ].  self commentPanel clear.  diffPanel basicRefreshaction: aBlock  actionBlock := aBlockmenuSelectionContext  ^self tool newContextaddToPatcher: aMCPatcher  (self isMeta and: [ mcDefinition isNil ]) ifTrue: [ ^self ].  aMCPatcher addDefinition: self asMCDefinitiontags  ^self repository tags select: [:each |  each commit = self ]upstreamIfNone: aBlock  repository handleLibgitError: [ | localBranch gitUpstream |        localBranch := self repositoryHandle lookupLocalBranch: self name.        gitUpstream := localBranch upstream.        gitUpstream ifNil: [ ^aBlock value ].        ^IceGitRemoteBranch named: gitUpstream name inRepository: repository ]fileFormatId: aFileFormatId  self properties at: #format put: aFileFormatIddescriptionWithDecoration  ^self addDecorationTo: (self entity isRemote ifTrue: [ self entity shortName ] ifFalse: [ self name ])selectedItems: aCollection  selectedItems := aCollection asSet.  self tableRefreshhasRemoteBranchNamed: aString  self remoteBranchNamed: aString ifPresent: [:branch |  ^true ] ifAbsent: [ ^false ]title  ^'Pull requests on {1} ({2})' format: {self remote name .         self remote url}visitMergeAborted: anError  UIManager default alert: (anError messageText ifNil: [ 'Automatic (fast-forward) merge is not possible. Please perform the merge manually, then proceed with your previous operation.WARNING: If you have external files, you may need to verify the conflicts there.' ]) title: 'Automatic merge failed'execute  | oldBranch newBranch |  oldBranch := self repository branch.  self migrateSources.  newBranch := self repository branch.  self isMergeWithCurrentBranch ifTrue: [ oldBranch checkout: IceCheckoutDoNotLoadPackages new.        newBranch merge ]accept: aVisitor  ^aVisitor visitTreeNode: selfreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  selectedCommit := aToolContext selectedCommitcreateBranch: branchName  ^self createBranch: branchName inCommit: self headCommitkey  ^operation keyancestors  ^self entity ancestorsbranchName  ^entity branchNameat: aKey ifAbsentPut: anObject  ^objects at: aKey ifAbsentPut: anObjectversionFor: package  ^self commit versionFor: packageremoveFrom: aPatcher  cacheAllBranches  self remoteBranches do: [:each |  | branchName |        branchName := each at: 'name'.        branchesByName at: branchName ifAbsentPut: [ self remoteBranch: branchName ] ]menuSelectionContextWithSelection: anObject  ^self tool newContextWithSelection: anObjectmenuColumn: column row: rowIndex  | menuSelection context |  rowIndex = 0 ifTrue: [ ^nil ].  menuSelection := self elementAt: rowIndex.  context := self menuSelectionContextWithSelection: menuSelection.  ^CmdContextMenuActivation buildContextMenuFor: self table inContext: contextacceptError: aVisitor  aVisitor visitCloneLocationAlreadyExists: selftarget: anObject  target := anObjectancestorShortId  ^self entity ancestors first shortIdremoteUrl  | builder |  builder := IceUrlBuilder new     protocol: self selectedProtocol new;     username: self userName project: self projectName.  self configureBuilder: builder.  ^builder buildUrlnormalFillStyle  ^Color transparentcanBrowseReferences  ^falseposition  ^position ifNil: [ IceTipItemPosition default ]refresh  changes  ^model ifNotNil: [ model mergeTree children collect: [:each |  IceMergeListWrapper with: each model: model ] ]basicRefresh  self resetDiffContents.  changeList widget     in: [:this |  this selectIndexes: #().        self resetDataSource: this dataSource ];     refreshvalidateCanPushTo: aRemote  | commits |  aRemote fetch.  commits := self branch incomingCommitsFrom: aRemote.  commits ifEmpty: [ ^self ].  IceRemoteDesynchronized new     asResumable;     remote: aRemote;     signaladdFilesToIndex: aCollection  self handleLibgitError: [ | gitIndex |        gitIndex := self repositoryHandle index.        gitIndex addAll: (aCollection collect: [:each |  self assert: each asFileReference isRelative.                    each asFileReference path pathString ] as: Array).        gitIndex           writeToDisk;           free ]repositoryName  ^self repositoryModel nameisCloneOfUrl: aString  ^self isMissing not and: [ super isCloneOfUrl: aString ]mergeWithLeftNoOperation: anIceNoModification  self shouldNotImplementname  ^self entity descriptionbeForMerge  self commitInfoTabs beForMergeicon  self subclassResponsibilityactualClass  ^operation definition actualClasschangesToWorkingCopyTree  self calculateChanges.  ^changesToWorkingCopyTreehasChanges  ^trueunloadFromImageCheckbox: anObject  unloadFromImageCheckbox := anObjectprotocol  ^protocolchooseButton: anObject  chooseButton := anObjectfileSystem  ^FileSystem memory rootaccept: aVisitor  ^aVisitor visitPackage: selfhasTagNamed: aString  ^self tagNames includes: aStringcheckoutOn: anIceWorkingCopy  committish commit adopt.  self repository setHead: committishproject  self subclassResponsibilitysearchText: aString  ^IceTipTreeSearchStrategy searchWith: aString dataSource: selfname: aString  name := aStringsourceDescription  ^'Working Copy version: ' , self repository workingCopy descriptionreferenceCommit  ^repository workingCopy referenceCommitreferenceCommits  ^{self referenceCommit}selectionChanged: ann  selectedOption := ann newSelectedIndexes ifNotEmpty: [:indexes |  self optionsList widget dataSource elementAt: indexes first ] ifEmpty: [ nil ].  self refreshDetailPanelhelp  ^super help ifNotNil: [:sel |  self target perform: sel ]hasOutgoingCommits  self hasUpstream ifFalse: [ ^false ].  ^self hasOutgoingCommitsTo: self upstream remote= anotherDefinition  ^super = anotherDefinition and: [ contents = anotherDefinition basicContents ]subscribeToAnnouncements  self announcer when: IceTipDiffEntryRemoved send: #entryRemoved: to: selfdetailPanel: anObject  detailPanel := anObjectpackageNameText: anObject  packageNameText := anObjectstatus  ^self repositoryModel statuscreateCommandContext  ^self newContextWithSelection: self repositorySelectedisModification  ^falsemigrateSources  | commit |  self repository createBranch: self branchName.  commit := self repository branch commit.  self repository workingCopy packages do: [:each |  self migratePackage: each commit: commit ].  (self repository workingCopy fileSystem resolve: self repository properties propertiesFilePath)     ensureDelete;     binaryWriteStreamDo: [:stream |  stream nextPutAll: (self repository properties                 fileFormatId: self format;                 contentsString) ].  self repository addFileToIndex: self repository properties propertiesFilePath.  self format = #filetree ifFalse: [ self removeFiletreeRemnants ].  self repository commitIndexWithMessage: 'sources migrated' andParents: {commit}readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  tagModel := aToolContext itempackage  ^packagecolorModified  ^Smalltalk ui theme successTextColornextPath  ^IceGitChangeImporter new     path: (RelativePath withAll: path segments allButFirst);     diff: diff;     version: version;     yourselfcheckout: aCheckoutStrategy  self workingCopy checkout: aCheckoutStrategypath: aRelativePath  path := aRelativePathvisitNonConflictingOperation: anIceNonConflictingOperation  ^anIceNonConflictingOperation chosenOperation accept: selfvalidateLocation  (self location isNil and: [ self remoteToUse isNil ]) ifTrue: [ IceError signal: 'No location/url or remote defined.' ]repository: anIceLibgitRepository  repository := anIceLibgitRepositorychangedPackagesToCommitInfo: anIceGitCommit  ^anIceGitCommit packagesshortname  ^self namereducedOutgoingCommitsWhenNoRemote  ^self newCommitWalk     maxNumber: 20;     commitsexecuteWith: aRepositoryModel  self repositoryModel: aRepositoryModel.  self executehistoryPanel  ^historyPanelexecute  self packageModel browsePackagerootForItems: aCollection  selectedItems := Set new.  self rootItem: (FTRootItem new           data: aCollection;           yourself)selectedItems  ^changeList widget dataSource selectedItemsdiscardChanges  self workingCopy discardChangesretrieveStatuses  self statusPanel widget addMorphBack: 'Loading...' asMorph.  [ | status generalStatus statuses |  [ status := self pullRequest status.  generalStatus := status at: 'state'.  statuses := status at: 'statuses' ] on: Error do: [:e |  generalStatus := 'Unknown'.        statuses := #() ].  UIManager default defer: [ self statusPanel widget           removeAllMorphs;           addMorphBack: (self iconForStatus: generalStatus) asMorph;           addMorphBack: generalStatus asMorph.        self checksTable widget dataSource: (IceGitHubPullRequestDataSource elements: statuses) ] ] forkremoveFrom: aVisitor  self subclassResponsibility= other  ^other species = self species and: [ other description = self description ]execute  self repositoryModel fetchrejectPullRequest  IceGitHubRejectPullRequestModel new     onAccept: [:model |  IceGitHubAPI ensureCredentials.        self pullRequest rejectMessage: model message ];     openWithSpecupdateHead  | commitToAdvance |  commitToAdvance := self isFastForward ifTrue: [ repository workingCopy adoptCommit: mergeCommit.        mergeCommit ] ifFalse: [ repository workingCopy setMergeStateBetweenCommits: {self leftCommit .               mergeCommit}.        repository workingCopy commitChanges: self withMessage: 'Merge ' , mergeCommit id asString force: true ].  repository branch commit: commitToAdvanceexecute  tagModel previewCheckoutnewHeader  ^SimpleButtonMorph new     layoutPolicy: RowLayout new;     listDirection: #leftToRight;     wrapCentering: #center;     hResizing: #spaceFill;     vResizing: #spaceFill;     cellInset: 5 @ 0;     layoutInset: 5 @ 0;     label: self id;     yourselfselectionChanged: ann  selectedModel := ann newSelectedRowIndexes ifNotEmpty: [:indexes |  self commitList widget dataSource elementAt: indexes first ] ifEmpty: [ nil ].  self refreshCommitTabPanelrefresh  self leftPanel removeAllMorphs.  self rightPanel removeAllMorphs.  items do: [:each |  each position addItem: (each newToolbarButtonOn: self) into: self ]isSameAs: aNode  ^self subclassResponsibilityexecute  (IceTipMergeBranchDialog on: self repositoryModel) openDialogWithSpecrightDefinition: aDefinition  oldNode := aDefinitionexecute  self repository branch pullFrom: self remote.  self beSuccessmergeStateWith: aMergeableState  ^aMergeableState mergeWithEmptyWorkingCopyState: selfmodel  ^modelversionFor: aPackage  self subclassResponsibilitycredentials  ^credentials ifNil: [ credentials := self class obtainCredentials ]branchesForMerge: aCommit  ^self allBranches reject: [:each |  each includesCommit: aCommit ]packageNames  ^#()commitish: anIceTipCachedModel  branchCommitish := anIceTipCachedModelmessageText  ^messageTextbadge  badgeSelector ifNil: [ ^nil ].  ^self model perform: badgeSelectorchosenOperation  ^chosencredentials: aCredentials  credentials := aCredentialsplaintextCredentials  ^self credentialStore plaintextCredentialForHostname: remote hostrefreshCommitInfo  infoTab contents: (selectedModel info ifNotNil: [ (IceTipReadOnlyForm items: selectedModel info) buildWithSpec ])tracksRemoteBranch  ^self subclassResponsibilitylastCommit  ^self repository backend revparseCommit: self nametype  ^'SSH Keys'visitNoCommitMessage: aWarning  self visitGenericError: aWarninggiveFocusToNextFrom: aModel  super giveFocusToNextFrom: aModelnewSelectionMorphFor: item  ^CheckboxButtonMorph new     selected: (self isSelected: item);     target: [ self toggleSelectionOf: item ];     actionSelector: #value;     yourselfforwardMessage: aMessage  ^realObject perform: aMessage selector withArguments: aMessage argumentsremovalHighlightColor  ^super additionHighlightColoriceCommit  ^iceCommitcheckout  checkoutStrategy     committish: self commitish;     diff: diffModel entity.  self commitish checkout: checkoutStrategypackages  ^self commit packagesisConflict  ^item value isConflictaccept: aVisitor  ^aVisitor visitConflictingOperation: selfmergeStateWith: aMergeableState  self subclassResponsibilityloadedVersion  ^self repository workingCopy versionFor: selfisModification  ^trueparseUrl  ^self subclassResponsibilityvisitNoCommitMessage: aWarning  | proceed |  proceed := UIManager default confirm: aWarning messageText label: 'Warning!' trueChoice: 'Commit' falseChoice: 'Cancel' cancelChoice: nil default: false.  proceed ifNil: [ ^self ].  proceed ifTrue: [ aWarning resume ]fillGroupMenu: aMenu using: aCommandActivator baseline: aPackage  | concreteCommand |  concreteCommand := self newBaselineGroupCommand: aPackage.  self fillMenu: aMenu title: ('Install baseline of {1}...' format: {(self nameOfBaseline: aPackage)}) command: concreteCommand activator: aCommandActivator baseline: aPackagevisitCloneRemoteNotFound: anError  UIManager default alert: ('The clone remote {1} could not been found' format: {anError remoteUrl}) title: 'Clone action failed'fillContextMenu: aMenu using: aCommandActivator  super fillContextMenu: aMenu using: aCommandActivator.  remote := aCommandActivator context item model entityiconFor: item  ^iconBlock ifNotNil: [ iconBlock value: item ] ifNil: [ nil ]title  ^'Preview checkout of {1}/{2}' format: {self model repositoryName .         self model targetName}initializeWidgets  super initializeWidgets.  diffPanel := self instantiate: IceTipDiffSelectingPanel on: self model workingCopyDiff.  diffPanel leftLabel: 'Repository'.  diffPanel rightLabel: 'Working Copy'.  commentPanel := self instantiate: IceTipCommentPanel on: self model.  commentPanel onCommit: [ self doCommit ].  commentPanel commentText whenBuiltDo: [:ann |  self addShortcutsTo: ann widget textArea ].  self whenBuiltDo: [:ann |  self addShortcutsTo: ann widget ].  self focusOrder     add: commentPanel;     add: diffPaneldefaultFormat  ^defaultFormatremotes  self subclassResponsibilitymessage  ^self messageText text asStringallTypes  ^types ifNil: [ types := self createMergeBranchTypes ]newOptionsListDataSource  ^IceTipDataSource new     tool: self;     elements: self model availableRepairOptions;     yourselfrepositoryWillBeCreated: aRepository  ^self plugins do: [:each |  each repositoryWillBeCreated: aRepository ]resolve: aRelativePath  ^self resolve: aRelativePath ifAbsent: [ NotFound signalFor: aRelativePath ]verifyDirectoryStructureIfMissing: aBlock  self entity isMissing ifTrue: [ ^aBlock value: (self toErrorMessage: 'Local repository missing') ]operationIcon  ^operation icondiffTo: aCommitish  ^IceDiff from: self to: aCommitishrepository  ^repositoryaddProjectFileToChangeBuilder: anIceChangeImporter  | projectFileName |  self isUnborn ifTrue: [ ^self ].  self assert: self projectFilePath size = 1.  projectFileName := self projectFilePath segments first.  anIceChangeImporter addFileNamed: projectFileName path: self projectFilePath contents: self contentsStringmergeTree  ^IceEmptyNode newvisitMetaclassDefinition: aMCClassDefinition  validateIsBranch  IceNotInBranch signalstatusWithDecoration  | text |  text := self status asText.  self entity isLoaded ifFalse: [ text := text makeAllColor: self colorNotLoaded ].  ^textrepository: aRepository  repository := aRepositoryremoveBranches: aCollection  [ aCollection do: [:each |  self removeBranch: each ] ] on: IceGitHubError do: [:e |  self reportError: e ]projectAsPathToAppend  (self userName isEmpty and: [ self projectName isEmpty ]) ifTrue: [ ^'' ].  ^(self userName ifEmpty: [ '?' ]) , '/' , self projectNameremoveAllCommitPanelTabs  commitTabPanel tabs copy do: [:each |  commitTabPanel removeTab: each ]repository: anIceLibgitRepository  repository := anIceLibgitRepositoryformats  ^formatsapi  ^apiinitialize  super initialize.  resumable := falsename: anObject  name := anObjectprojectFileIn: aCommitish  ^aCommitish fileSystem resolve: self projectFilePathbePositionLeft  self position: IceTipItemPosition leftprivateKeyInput  ^privateKeyInputdelete  repository handleLibgitError: [ | found |        found := self repositoryHandle lookupRemoteBranch: self name ifAbsent: [ nil ].        self repositoryHandle deleteBranch: found ]repository  ^repositorydiffToParent  ^iceCommit diffToParentsetUpstreamIfMissing: aRemote  self hasUpstream ifTrue: [ ^self ].  self setUpstream: (aRemote remoteBranchNamed: self gitRef)rightLabel: aString  (diffPanel respondsTo: #leftLabel:) ifFalse: [ ^self ].  diffPanel rightLabel: aStringremoveFrom: aVisitor  aVisitor removePackage: selftextUpdated: anAnnouncement  self filterWith: self textField getTextname  self subclassResponsibilityinitializeWidgets  pushCheckbox := self newCheckBox.  self repositoryModel branchModel hasUpstream ifTrue: [ pushCheckbox label: ('Push changes to {1}' format: {self repositoryRemoteName}) ] ifFalse: [ pushCheckbox           label: 'Cannot push new branch automatically. Use the `Push` option';           enabled: false ].  commentText := self newText     autoAccept: true;     whenBuiltDo: [:ann |  ann widget withGhostText: 'A comment for your commit' ].  actionPanel := self newIceActionPanel.  actionPanel addAction: (commitButton := self newButton           label: 'Commit';           icon: (self iconNamed: #smallOk);           help: ('Commit your changes to {1}' format: {self repositoryName});           yourself).  self focusOrder     add: commentText;     add: commitButton;     add: pushCheckboxhostLabel  ^hostLabelname  ^self fullname withoutPrefix: self prefixkey  ^value keyposition  ^position ifNil: [ IceTipItemPosition perform: self commandClass defaultPosition ]calculateDiff: aBlock  | diff |  UIManager default informUser: 'Calculating diff' during: [ diff := aBlock value.        diff build ].  ^diffleftContents  self subclassResponsibilityparseLocation: aString  (#('http:' 'https:') anySatisfy: [:each |  aString beginsWith: each ]) ifTrue: [ self parseHTTPLocation: aString ] ifFalse: [ self parseSSHLocation: aString ]anySatisfy: aBlockClosure  (aBlockClosure value: self value) ifTrue: [ ^true ].  self childrenDo: [:e |  (e anySatisfy: aBlockClosure) ifTrue: [ ^true ] ].  ^falseaddModification: anIceModification toPatcher: aMCPatcher  (self isMeta and: [ mcDefinition isNil ]) ifTrue: [ ^self ].  aMCPatcher modifyDefinition: anIceModification rightDefinition asMCDefinition to: anIceModification leftDefinition asMCDefinitionvalue  ^valuefromTag: tag  self revwalk.  ^self fromLGitId: (lgitRepository revparse: tag name) idprogress  ^min >= max ifTrue: [ 1 ] ifFalse: [ (current - min) / (max - min) ]refresh  self model reset.  self basicRefreshappliesToRepository: aRepository  ^self repository = aRepositoryfillMenu: aMenu title: aString command: aCommand activator: aCommandActivator baseline: aPackage  | activator item |  activator := aCommandActivator newForCommand: aCommand.  item := aMenu add: aString target: activator selector: #executeCommand.  aCommand setUpIconForMenuItem: item.  aCommand description ifNotNil: [:d |  item setBalloonText: d ]resetDiff  diff := nilport  ^port ifNil: [ self class defaultPort ]switchAndMergeThen: aBlock  < noCache>  IceTipStandardAction new     repository: self entity repository;     message: ('Merging branch {1} from {2}' format: {self name .               self repositoryName});     onSuccessRepositoryModified;     onSuccess: aBlock;     execute: [ self entity switchAndMergeWorkingCopy ]initializeWidgets  super initializeWidgets.  commitsPanel := self instantiate: IceTipHistoryBrowser on: self model.  actionPanel := self newIceActionPanel.  actionPanel addAction: (button := self newActionButton).  self whenBuiltDo: [:ann |  self addShortcutsTo: ann widget ]isRemote  ^falsechangedFilesBetween: aCommitish and: otherCommitish  self handleLibgitError: [ | fromTree toTree diff |        fromTree := (LGitCommit of: self repositoryHandle fromHexString: aCommitish id) tree.        toTree := (LGitCommit of: self repositoryHandle fromHexString: otherCommitish id) tree.        diff := fromTree diffTo: toTree.        ^diff files ]title  ^'Preview merge of {1}/{2}' format: {self model repositoryName .         self model targetName}position: aPosition  position := aPositionpropertyFileExtension  ^MCFileTreeRepository defaultPropertyFileExtensionicon  ^self iconNamed: #openprojectNameInputText  ^projectNameInputText= aNoCommit  ^aNoCommit isNoCommitfindVersionInfo  | repo remote commit |  (self class lastCommitFound notNil and: [ self class lastCommitFound id = commitId ]) ifTrue: [ commit := self class lastCommitFound.        repo := commit repository ] ifFalse: [ remote := IceGitRemote url: remoteUrl.        repo := IceRepository registry detect: [:eachRepo |  eachRepo remotes anySatisfy: [:each |  each referencesSameRemoteLocationAs: remote ] ] ifNone: [ ^nil ].        commit := repo lookupCommit: commitId.        commit ifNil: [ IceError signal: ('Your repository seems to be out of sync.!Please fetch from "{1}" and try again.' format: {remote}) ].        self class lastCommitFound: commit ].  ^IceMCVersionInfo new fromCommit: commit package: (IcePackage named: packageName repository: repo)initializeToolbar  toolbar := self newIceToolbar.  self rebuildToolbarvalidate  self assert: self remoteName notEmpty description: 'You need to specify a remote name.'.  self assert: self remoteUrl notEmpty description: 'You need to specify a remote url.'commitTabPanel  ^commitTabPanelpassword  ^password ifNil: [ password := '' ]branchModels  ^self branches collect: [:each |  (IceTipBranchModel repositoryModel: self repositoryModel on: each) beCached ]locationIfPresent: aBlock  ^self locationIfPresent: aBlock ifAbsent: [ self ]imageCommit  ^imageCommit ifNil: [ imageCommit := repository workingCopy referenceCommit ]credentials: anObject  credentials := anObjectchanged  current >= max ifTrue: [ ^Job jobAnnouncer announce: (JobEnd on: self) ].  Job jobAnnouncer announce: (JobChange on: self)availablePluginsFor: aRepository  ^(IcePlugin allAvailableFor: aRepository) collect: #new as: ArraycanActivateCommand: aCommandClass  ^aCommandClass actsOnRemote: selfdescription  ^'Metacello install operations'hasConflicts  ^self model mergeTree anySatisfy: [:conflict |  conflict isConflict ]addPlugin: aPlugin  plugins := plugins copyWith: aPluginheadLabel: anObject  headLabel := anObjectadopt  self repository workingCopy adoptCommit: selfheadDescription  ^[ super headDescription ] on: Error do: [ 'Bad location' ]remotePanel  ^remotePanel= anotherDefinition  ^self species = anotherDefinition species and: [ self name = anotherDefinition name ]initialExtent  ^(700 @ 500) scaledByDisplayScaleFactordoAccept  self subclassResponsibilitykey  self subclassResponsibilityisEmpty  ^tree isEmptyrepository: anIceRepository  repository := anIceRepositorycolorWarning  ^Smalltalk ui theme warningTextColornewInfoTab  ^self newTab     label: 'Info';     icon: (self iconNamed: #smallQuestion);     closeable: false;     yourselfcommitId  ^self entity commit idmessageBody  ^'Credentials provided are wrong'merge  self mcVersion mergeid: aString  id := aStringisDirty  ^self isLoaded and: [ isDirty ifNil: [ isDirty := false ] ]fetchAllRemotes  | remotes |  remotes := self repository remotes.  UIManager default informUserDuring: [:bar |  bar label: 'Fetching incoming commits'.        bar max: remotes size.        bar value: 1.        remotes withIndexDo: [:each :index |  bar label: ('Fetching incoming commits of {1}' format: {each name}).              bar value: index + 1.              self repository fetchFrom: each ] ]confirmLabel: anObject  confirmLabel := anObjectdelete  super delete.  handle := nil.  self locationIfPresent: [:aLocation |  aLocation ensureDeleteAll ]backwardsCompatibleFormat  ^TIceRepositoryWriter users detect: #isLegacyDefault ifNone: [ Smalltalk at: #IceLibgitFiletreeWriter ]diff  ^diff ifNil: [ diff := committish diffTo: self workingCopy ]format  ^formatBlockreferencesSameRemoteLocationAs: another  ^(self url withoutSuffix: '.git') sameAs: (another url withoutSuffix: '.git')fileSystem  ^(FileSystem onGitCommit: self libgitCommit) rootreset  properties: aCollection  properties := aCollectionname  ^self entity namechangedPackagesToWorkingCopy: left  | leftPackageNames rightPackageNames added removed |  self flag: #refactor.  leftPackageNames := left packageNames.  rightPackageNames := self packageNames.  added := leftPackageNames \ rightPackageNames collect: [:each |  IcePackage named: each repository: self repository ].  removed := rightPackageNames \ leftPackageNames reject: [:each |  self packageNames includes: each ] thenCollect: [:each |  IcePackage named: each repository: self repository ].  ^added , ((left modifiedPackages reject: [:p |  leftPackageNames \ rightPackageNames includes: p name ]) collect: [:mcPackage |  IcePackage named: mcPackage name repository: repository ] as: Array) , removedinitializeDirectoryTree  | dataSource |  dataSource := self newDirectoryDataSource.  sourceDirectoryTree widget     addColumn: (IceTipTableColumn newAction: #name icon: [:each |  self iconNamed: #package ]);     dataSource: dataSource;     onAnnouncement: FTSelectionChanged do: [:announcement |  self sourceDirectorySelectionChanged: announcement newSelectedIndexes ]proxy: anObject  proxy := anObjectnewCommitWalk  self subclassResponsibilitycheckoutNewBranchNamed: aString inCommit: aCommit thenDo: aBlock  < noCache>  IceTipStandardAction new     repository: self entity;     message: ('Checking out new branch {1}' format: {aString});     onSuccessRepositoryModified;     execute: [ | branch |        branch := self entity createBranch: aString inCommit: aCommit.        aBlock value: branch ]initializeWidgetsContents  self initializeCurrentBranchLabel.  branchLabel := self newLabel label: 'New branch'.  branchInputText := self newTextInput     autoAccept: true;     ghostText: 'e.g., feature/what'.  spacePanel := PanelMorph new asSpecAdaptervisitClassDefinition: aMCClassDefinition  | classDefinitionNode classDefinition |  classDefinitionNode := self ensureMethodOwnerNamed: aMCClassDefinition className isMeta: false isTrait: false isExtension: false.  classDefinitionNode value mcDefinition: aMCClassDefinition.  classDefinition := self ensureMethodOwnerNamed: aMCClassDefinition className isMeta: true isTrait: false isExtension: false.  classDefinition value mcDefinition: aMCClassDefinition.  ^classDefinitionNodeitem  ^self repositoryModelnewRepository  ^self subclassResponsibilityinitializeSpacePanel  spacePanel := self newIcePanelrepository: anObject  repository := anObjectprintOn: aStream  aStream << self class name << '(' << packageName << ')'categories  ^categorieschangesTo: aCommitish  ^aCommitish changesFromNoCommit: selfbeForMerge  headTabContainer := IceTipHistoryDiffToHead tab: headTab.  ancestorTabContainer := IceTipHistoryDiffToAncestor tab: ancestorTabprojectNameInputText: anObject  projectNameInputText := anObjectacceptButton: anObject  acceptButton := anObjectdoMerge  self model executeMergeActionAndThen: [ self window delete ]commitIndexWithMessage: message andParents: parentCommitishList  | newCommit |  newCommit := index commitWithMessage: message andParents: parentCommitishList.  index := self newIndex.  self workingCopy referenceCommit: newCommit.  self workingCopy refreshDirtyPackages.  ^newCommitmergeStateWith: aMergeableState  ^aMergeableState mergeWithSingleVersionWorkingCopyState: selfremoteUrl: urlString packageName: nameString commitId: idString stub: aStub  remoteUrl := urlString.  packageName := nameString.  commitId := idString.  stubVersionInfo := aStubconfigureBuilder: aBuilder  self subclassResponsibilitysnapshot  ^self mcSnapshotoutgoingCommits  ^self repository branch outgoingCommits: [:walk |  walk modifyingPackage: self ]contextClass  ^IceTipPushContextentryByPath: aString  repository handleLibgitError: [ ^(LGitCommit of: self repositoryHandle fromHexString: self id) entryByPath: aString ]revwalk  repository handleLibgitError: [ ^revwalk ifNil: [ lgitRepository := self repositoryHandle.              revwalk := LGitRevwalk of: self repositoryHandle ] ]initializeRepository: aRepository  self initialize.  plugins := self availablePluginsFor: aRepositoryretrieveHistory  self repositoryModel checkMissing.  UIManager default informUser: ('Retrieving history of {1}' format: {self entity printString}) during: [ ^self repositoryModel entity log historyOfMethod: self entity ]isDirty  ^repository workingCopy referenceCommit properties ~= selftree  ^self diff treeToShowcancelAction  ^self subclassResponsibilityinitialize  actions := OrderedCollection new.  super initializetimeSinceLastCommit: json  | branchName branchJson lastCommitDate |  branchName := json at: 'name'.  branchJson := branchesByName at: branchName.  lastCommitDate := ((((branchJson at: 'commit') at: 'commit') at: 'author') at: 'date') asDateAndTime.  ^'{1} days' format: {(Date today - lastCommitDate) days}author  ^self subclassResponsibilityfetchBranch: aBranch  localRepository handleLibgitError: [ [ | refSpec remote |        refSpec := LGitRefSpec fromString: ('{2}:refs/remotes/{1}/{2}' format: {self name .                     aBranch name}).        (remote := LGitRemote of: self repositoryHandle named: self name)           lookup;           fetchWithCredentials: (IceCredentialsProvider defaultForRemote: self) refSpec: refSpec ] on: LGitAbstractError do: [:e |  e acceptError: (IceLibgitErrorVisitor onContext: self) ] ]isSame: aRemote  ^(self referencesSameRemoteLocationAs: aRemote) and: [ self name = aRemote name ]repositoryHandle  < repositoryHandleAccessor>  (handle isNil or: [ handle isNull ]) ifTrue: [ handle := (LGitRepository on: self location) open ].  ^handleaddItem: anObject into: aToolbar  self subclassResponsibilityaddItemRight: aButton  self rightPanel addMorphBack: aButtoninitialize  super initialize.  repositoryDetached := falseplaintextCredentialForHostname: aHostname  ^self lookup: aHostname in: plainCredentials ifAbsent: [ IcePlaintextCredentials new ]packageName  ^self package nameheadBranchList: anObject  headBranchList := anObjectparseMorePages: aString  aString ifNil: [ ^false ].  ^(aString substrings: ',') anySatisfy: [:each |  each includesSubstring: 'rel="next"' ]versions  ^self repository branch versionsFor: selfbasicExecute  UIManager default informUser: 'Pushing...' during: [ self repository push ].  Iceberg announcer announce: (IceRepositoryModified for: self repository)diffFromHead  ^self repository headCommit diffTo: selfensureDirectoryNamed: aName inNode: aNode  aNode childAt: aName ifPresent: [:node |  self assert: node value isDirectoryDefinition.        ^node ].  ^aNode addChild: (IceDirectoryDefinition named: aName)repositoryWasCreated: aRepository  credentials  ^IcePlaintextCredentials new     username: self username;     password: self password;     yourselfchooseTitle: aString  chooseTitle := aStringicon  ^self iconNamed: #changeAddexpandAll  changeList widget dataSource     rootForItems: self model treeRoots;     expandAll;     selectAllstatusPanel: anObject  statusPanel := anObjectshowEmptyTab  emptyTab ifNil: [ emptyTab := self newEmptyTab ].  self removeAllCommitPanelTabs.  commitTabPanel addTab: emptyTabpriority  ^1initialExtent  ^(500 @ (self class inputTextHeight * 2 + self class buttonHeight + 50)) scaledByDisplayScaleFactorcredentials  ^credentialexecute  self repositoryModel reset.  self announcer announce: (IceTipDiffRefreshed for: self repositoryModel entity)branch  self head validateIsBranch.  ^self headinitializeLocation: aString  location := aString.  self initializerepository  ^committish repositoryexecute  | browser window path |  browser := SettingBrowser new     changePackageSet: {#Iceberg asPackage .         #'Iceberg-Libgit' asPackage};     yourself.  window := browser open.  path := (window submorphs detect: [:each |  each isKindOf: MorphTreeMorph ]) nodeList.  browser expandNodePath: path first contents first contents first pathcommitModels  | commits |  commits := OrderedCollection new.  self entity commitsDo: [:each |  commits add: (IceTipCommitModel repositoryModel: self repositoryModel on: each) beCached ].  ^commitsbeCached  ^IceTipCachedModel for: selfleftDefinition  ^definitiontree  ^self mergeTreesubPackageFileDirectoryFor: directoryNameOrPath  ^self packageFileDirectory entryByPath: directoryNameOrPathworkingCopyDiff  ^self workingCopy diffToReferenceCommitrepository: anObject  repository := anObjectaction  ^actionBlockmouseLeave: evt  self currentHand showTemporaryCursor: nilconfigureBuilder: aBuilder  aBuilder beGitLabhost: aString  host := aStringvisitGenericError: anError  (IceTipErrorDialog on: anError) openDialogWithSpecisEmptyNode  ^falseactionPanel: anObject  actionPanel := anObjectreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  remoteModel := aToolContext itemtargetVersion: aCommitish  target := aCommitishremoteInputText  ^remoteInputTextinternalStoreVersion: aMCVersion  self writerClass forInternalStoreFileOut: aMCVersion on: selfsetModelBeforeInitialization: anObject  model := anObjectprintOn: stream  stream << self major asString << '.' << self minor asString << '.' << self patch asStringurl: aString  url := aStringhasOutgoingCommits  ^self branch hasOutgoingCommitsiconWidget  ^iconWidgetexecute  self subclassResponsibilitymcPackage  ^MCPackage named: self packageNamesubdirectory: anObject  subdirectory := anObjectonAccept: aBlockClosure  acceptCallback := aBlockClosureinitializeWidgets  self initializeToolbar.  self whenBuiltDo: [:ann |  self addShortcutsTo: ann widget ]traversingDo: aBlock  ^self traversingDo: aBlock parents: #()execute  (IceTipRemoveRepositoryDialog on: self repositoryModel) openDialogWithSpeccommitModelFor: aCommit  ^(IceTipCommitModel repositoryModel: self on: aCommit) beCachedmetacelloAdapter: version  ^IceMetacelloRepositoryAdapter for: self withVersion: versionremove  < noCache>  IceTipStandardAction new     repository: self entity repository;     message: ('Removing package {1}' format: {self entity name});     onSuccessRepositoryModified;     execute: [ Iceberg announcer suspendAllForRepository: self entity repository while: [ self entity remove ] ]versionFrom: aVersionName  | packageName package version |  packageName := (MCFileTreeRepository parseName: aVersionName) first.  package := self repository packageNamed: packageName.  version := package latestVersion.  version info name = aVersionName ifFalse: [ version := package versions detect: [:ver |  ver info name = aVersionName ] ].  ^version mcVersioninitialize  self model: IceTipRepositoriesModel new.  super initializeincludesCommit: aCommit  self commitsDo: [:commit |  commit id = aCommit id ifTrue: [ ^true ] ].  ^falseitem  ^IceTipEntityModel on: credentialvisitRemoteAlreadyExistError: anError  self visitGenericError: anErrorbuildTree  self children keysAndValuesDo: [:childEntryName :childBuilder |  childBuilder hasChanges ifTrue: [ self builder addEntry: childBuilder buildTree filename: childEntryName ] ].  ^self builder newTreeacceptPullRequest  IceGitHubAcceptPullRequestModel new     onAccept: [:model |  IceGitHubAPI ensureCredentials.        self pullRequest acceptMessage: model message type: model type ];     openWithSpecicon  ^iconexecute  | root |  root := IceTipTreeGroup new.  self dataSource rootItem children do: [:eachRoot |  eachRoot data traversingDo: [:each |  each isLeaf ifTrue: [ (self matches: each) ifTrue: [ (root ensurePath: each path allButLast) addChild: each ] ] ] ].  root children do: [:each |  each parent: nil ].  ^self dataSource copy     rootForItems: root children;     yourselfvisitTraitDefinition: aMCTraitDefinition  | traitDefinitionNode |  traitDefinitionNode := self ensureMethodOwnerNamed: aMCTraitDefinition className isMeta: false isTrait: true isExtension: false.  traitDefinitionNode value mcDefinition: aMCTraitDefinition.  ^traitDefinitionNodepackagesFrom: aCommit  self repository handleLibgitError: [ | writerClass sourceFileReference |        writerClass := self writerClass.        sourceFileReference := aCommit fileSystem resolve: self sourceDirectory.        sourceFileReference exists ifFalse: [ ^#() ].        ^sourceFileReference children select: [:each |  writerClass isValidPackage: each ] thenCollect: [:each |  | packageName |              packageName := writerClass packageNameFromDirectory: each basename.              IcePackage named: packageName repository: self repository ] ]accept  self removeFileSystemCheckbox state ifTrue: [ self model delete ] ifFalse: [ self model forget ]visitGenericError: anError  anError passorganizer  ^'local'items: anObject  items := anObjectrepositoryHandle  < repositoryHandleAccessor>  ^repository repositoryHandleisMerged  ^self repository workingCopy isCommitMerged: selfshortname  ^self name withoutPrefix: self remoteName , '/'passphraseInput  ^passphraseInputpackages  ^self packagesDictionary valuesinitWithContents: aString font: aFont emphasis: textEmphasis  super initWithContents: aString font: aFont emphasis: textEmphasis.  self     addEmphasis: TextEmphasis underlined;     on: #click send: #execute to: self;     on: #mouseEnter send: #mouseEnter: to: self;     on: #mouseLeave send: #mouseLeave: to: selfconfigureButton: aButton item: aToolbarItem  aButton on: aToolbarItem getState: nil action: #execute label: #label icon: nil menu: nilrawResultsDo: aBlockClosure  self revwalk select: [:result |  self shouldInclude: result ] thenDo: aBlockClosurerefreshFocusOrder  self focusOrder     removeAll;     add: self typeList;     add: self selectedType;     add: acceptButton;     add: cancelButtonpackageName  ^self package nameisTraitDefinition  ^falsecellIndentFor: item  ^item depth * 16mouseLeave: evt  self currentHand showTemporaryCursor: nil.  super mouseLeave: evtaccept: aVisitor  ^aVisitor visitTraitDefinition: selfcanReadProjectFromCommitish: aCommitish  ^(aCommitish fileSystem / '.project') existscredentials  ^IceSshCredentials new     username: self username;     publicKey: self publicKey;     privateKey: self privateKey;     keyPassphrase: self passphrase;     yourselfdrawKeyboardFocusOn: canvas  getGitHubRepository  [ ^IceGitHubAPI new     beAnonymous;     getRepository: self userName project: self projectName ] on: LGitNoCredentialsProvided do: [ ^nil ]spacePanel  ^spacePanelmodel: anObject  model := anObject.  self refreshaddPackageNamed: aString  self addPackage: (IcePackage named: aString asSymbol repository: repository) beDirtymcSnapshotInRepository  ^self repository branch snapshotFor: selfnewLabel: aString  ^self newPanelMorph     listDirection: #rightToLeft;     cellPositioning: #center;     addMorph: ((LabelMorph newLabel: aString)           color: self labelColor;           yourself);     asSpecAdapterlog  ^self logClass for: selfnewCommitWalk  ^IceLibgitCommitWalk forRepository: selftoCommit  ^toCommitinitializeWidgets  super initializeWidgets.  credentialsList := self newIceTable.  self initializeCredentialsList.  self focusOrder add: credentialsListexception  ^exceptionnameLabel: anObject  nameLabel := anObjecttitle  ^self model ifNotNil: [ 'Versions of {1}' format: {self model name} ] ifNil: [ 'Versions' ]remoteLabel  ^remoteLabelrootNode  ^self parent rootNodebaseBranchName: anObject  baseBranchName := anObjectloadedPackages  ^self workingCopy loadedPackagesrepository  ^self repositoryModel entitybasepathOf: aPath  ^aPath copyAfterLast: $/fromHead  self revwalk pushHeaddoesNotUnderstand: aMessage  self flag: #todo.  self model ifNil: [ ^super doesNotUnderstand: aMessage ].  ^aMessage sendTo: self modelremote: anObject  remote := anObjectpriority  ^100000updateLocation: aReference  self entity location: aReference.  self entity postFetch.  Iceberg announcer announce: (IceRepositoryModified for: self entity)location: aFileReference  location := aFileReferencesnapshotWriterClass  ^IceMetadatalessStCypressWriterviewPullRequest: aPullRequest  UIManager default informUser: ('Opening pull request {1} {2}' format: {aPullRequest number .               aPullRequest title}) during: [ (IceGitHubTipPullRequestBrowser on: self model pullRequest: aPullRequest) openWithSpec ]start  started := true.  Job jobAnnouncer announce: (JobStart on: self)remoteBranchNames  ^self remoteTrackedBranches collect: #nameapplyDefinition: anIceDefinition inNode: aNode  | loader |  (anIceDefinition isFileDefinition or: [ anIceDefinition isDirectoryDefinition ]) ifTrue: [ ^self ].  loader := MCPackageLoader new.  loader addDefinition: anIceDefinition asMCDefinition.  loader loadallPackagesNotRegistered  | currentPackagesNames |  currentPackagesNames := self model packages collect: #packageName.  ^self allPackages reject: [:rPackage |  currentPackagesNames includes: rPackage name ]execute  (IceTipAddRemoteDialog on: self repositoryModel) openDialogWithSpecpullRequest  ^pullRequesthelp  ^helphostDescription  ^hostinitializeWidgets  titleLabel := self newLabel.  titlePanel := self newTextInput autoAccept: true.  headLabel := self newLabel.  headForkList := self newDropList.  headBranchList := self newDropList.  baseLabel := self newLabel.  baseForkList := self newDropList.  baseBranchList := self newDropList.  bodyLabel := self newLabel.  bodyPanel := self newText autoAccept: true.  addButton := self newButton.  titleLabel label: 'Title'.  headLabel label: 'From (Head)'.  baseLabel label: 'To (Base)'.  bodyLabel label: 'Comment'.  addButton label: 'Create pull request'.  addButton action: [ self accept ].  self focusOrder     add: titlePanel;     add: headForkList;     add: headBranchList;     add: baseForkList;     add: baseBranchList;     add: bodyPanel;     add: addButtondefaultHeadBranchName  ^self branch shortnameobtainRepositoryName  ^self location basenamemergeWithLeftAddition: anIceAddition  anIceAddition definition = self definition ifTrue: [ ^IceNonConflictingOperation operation: anIceAddition ].  ^IceConflictingOperation left: anIceAddition right: self= anotherDefinition  ^super = anotherDefinition and: [ self contents = anotherDefinition contents ]unresolvedConflictCount  ^mergeTree count: [:operation |  operation isConflict and: [ operation isResolved not ] ]project  ^repository newUnbornProjectinitializeWidgets  contentPanel := self emptyPanel asSpecAdapter.  typeList := self newIceTable.  self initializeTypeList.  self whenBuiltDo: [:ann |  self addShortcutsTo: ann widget.        self selectFirst ].  self eventKeyStrokesForNextFocus do: [:each |  typeList widget bindKeyCombination: each toAction: [ self giveFocusToNextFrom: typeList ] ].  self eventKeyStrokesForPreviousFocus do: [:each |  typeList widget bindKeyCombination: each toAction: [ self giveFocusToPreviousFrom: typeList ] ].  self refreshFocusOrderremoteBranch: aName  ^self requestRemoteBranch: aNamediffPanel: anObject  diffPanel := anObjectleftDefinition: aNode  definition := aNodeswitchToBranchNamed: aString  ^(self branchNamed: aString)     switch;     yourselfbasicContents: anObject  contents := anObjectexecute  version installtype  ^'Plain Text'remote  ^remotefileSystem  ^repository location ifNil: [ FileSystem memory root ]item: anObject  item := anObjectdatetime: aDateAndTime  datetime := aDateAndTimenewActionButton  ^self newButton     label: 'Checkout';     icon: (self iconNamed: #branch);     help: ('Checks out {1} into your image.' format: {self model targetName});     action: [ self doCheckout ];     yourselfparseUrl  | znUrl |  znUrl := ZnUrl fromString: url defaultScheme: 'file'.  path := znUrl asFileReference.  projectName := path basenameinstall  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Installing {1} - {2}' format: {self entity definition .               self name});     onSuccessRepositoryModified;     execute: [ self basicInstall ]newDiffPanelFor: aDiffModel  ^IceTipDiffPanel on: aDiffModelbranchInputText  ^branchInputTextrepository  ^repositorydelete  repository handleLibgitError: [ | found |        found := self repositoryHandle lookupLocalBranch: self name ifAbsent: [ nil ].        self repositoryHandle deleteBranch: found ]cancelAction  accepted := true.  self window close.  LGitNoCredentialsProvided signallatestVersion  ^self versionFor: self repository head commitmatches: aString  ^falseaccept: aVisitor  ^aVisitor visitAddition: selfhasLocalBranchNamed: aString  ^self branchNamed: aString ifPresent: [:branch |  true ] ifAbsent: [ false ]checksTable: anObject  checksTable := anObjectaddItemRight: aMorph  self rightPanel addMorphBack: (self prepareItemToAdd: aMorph)detailPanel  ^detailPanelcreateBranch: branchName inCommit: aCommit  self subclassResponsibilityselectedCommit  ^self item commitallBranches  ^self localBranches , self remoteTrackedBranchesbranches  ^self entity branchesmessageLabel: anObject  messageLabel := anObjectacceptError: aVisitor  aVisitor visitCloneRemoteNotFound: selfhasNoLoadConflicts: anMCGitBasedRepository  (anMCGitBasedRepository isKindOf: self class) ifFalse: [ ^false ].  ^self projectPath = anMCGitBasedRepository projectPath and: [ self repoPath = anMCGitBasedRepository repoPath and: [ self projectVersion = anMCGitBasedRepository projectVersion ] ]isExtension: aName  snapshot classDefinitionNamed: aName ifAbsent: [ ^true ].  ^falseeditModelClass  ^IceTipEditSSHCredentialsModelisSameAs: aNode  ^aNode species = self species and: [ self model = aNode model ]selectLeft  chosen := leftOperationisLoadable  ^self contextClass notNilrefresh  repositoryList widget     in: [:this |  this dataSource elements: self model repositories ];     refreshicon  ^self iconNamed: #groupleftLabel: aString  (diffPanel respondsTo: #leftLabel:) ifFalse: [ ^self ].  diffPanel leftLabel: aStringproxy  ^proxynewRequestTo: aString  ^ZnClient new     in: [:this |  isAnonymous ifFalse: [ this username: self credentials username password: self credentials password ] ];     headerAt: 'Accept' put: 'application/vnd.github.v3+json';     url: 'https://api.github.com/' , (aString first = $/ ifTrue: [ aString allButFirst ] ifFalse: [ aString ]);     yourselfacceptButton  ^acceptButtonaccept  self window delete.  exception debugchangesTo: aCommitish  ^self commit changesTo: aCommitishisUnborn  ^falsestorePlaintextCredential: credential forHostname: aHostname  plainCredentials at: aHostname put: credentialbeGithub  self host: 'github.com'ensurePath: aPath  | first next |  first := aPath first.  next := self children detect: [:each |  each isSameAs: first ] ifNone: [ self addChild: (first copy children: OrderedCollection new) ].  ^aPath allButFirst ifNotEmpty: [:remainingPath |  next ensurePath: remainingPath ] ifEmpty: [ next ]snapshot: aMCSnapshot  snapshot := aMCSnapshothasUpstream  ^falseexecute  selectedBranch resetToCommit: selectedCommitish.  Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity)initializeRemoteURL  remoteLabel := self newLabel label: 'Remote URL'.  remoteInputText := self newTextInput     ghostText: 'e.g., git@github.com:user/MyProject.git';     autoAccept: truecommitModelAfter: aModel  ^self commitModels after: aModel ifAbsent: [ nil ]initialize  super initialize.  accepted := falsesubscribeToAnnouncements  Iceberg announcer weak when: IceRepositoryAnnouncement send: #refreshWhenRepository: to: selfdoAccept  self validate.  self model checkoutNewBranchNamed: self branchName inCommit: (branchCommitish ifNil: [ self model entity workingCopy referenceCommit ]) thenDo: [:newBranch |  callback ifNotNil: [ callback value: newBranch ] ]statusLabel: anObject  statusLabel := anObjecttrackedBranch  self subclassResponsibilityisRoot  ^self parent isNildetail  ^detail ifNil: [ detail := IceGitHubAPI new get: ((self jsonAt: #url) allButFirst: 23) ]readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  version := aToolContext versionupdateWorkingCopy  repository workingCopy loadChangesInWorkingCopy: self changesToWorkingCopyTree.  repository workingCopy refreshDirtyPackagesnewRepository  | newRepository |  newRepository := super newRepository.  UIManager default informUser: 'Configuring Remotes...' during: [ | githubRepository |        githubRepository := self getGitHubRepository.        githubRepository ifNil: [ ^newRepository ].        (githubRepository at: #fork) ifTrue: [ | parent remote |              parent := githubRepository at: #parent.              remote := IceGitRemote name: ((parent at: #owner) at: #login) url: (parent at: self selectedProtocol githubRequestUrlKey).              newRepository addRemote: remote.              remote fetch ] ].  ^newRepositoryremoteList  ^remoteListimportOn: aNode  | packageNode snapshot definition |  (version includesPackageNamed: self packageName) ifFalse: [ ^self ].  definition := IcePackageDefinition named: self packageName.  packageNode := aNode addChild: definition.  definition path: packageNode path.  snapshot := self snapshot.  snapshot definitions do: [:e |  e accept: (IceMCDefinitionImporter new                 packageNode: packageNode;                 snapshot: snapshot;                 yourself) ].  ^packageNodenewMergeablePanel  ^PanelMorph new     color: Color transparent;     layoutPolicy: TableLayout new;     listDirection: #leftToRight;     cellInset: 5;     vResizing: #spaceFill;     hResizing: #spaceFill;     asSpecAdaptertraversingDo: aBlock parents: anArray  aBlock cull: self cull: anArrayrequestBaseBranches  ^IceGitHubAPI new     credentials: self credentials;     getBranches: self baseRemote owner project: self baseRemote projectBasenamewithoutLocalRepository  types := self allTypes reject: #isLocalRepository.  typeList widget dataSource elements: types.  typeList widget refreshdiffToWorkingCopyForPackages: aCollection  ^IceDiff new     sourceVersion: self;     targetVersion: self repository workingCopy;     buildForPackages: aCollectionaddPackages: aCollection  IceTipStandardAction new     repository: self entity;     message: 'Adding packages';     onSuccessRepositoryModified;     execute: [ aCollection do: [:each |  self entity workingCopy addPackageNamed: each name ] ]isTraitDefinition  ^trueemail  ^self emailInput text trimBothcommentText  ^commentTexthelp: anObject  help := anObjecticonPanel  ^iconPanelreadProjectFromCommitish: anIceCommitish  | properties projectFileReference |  projectFileReference := anIceCommitish fileSystem / '.project'.  properties := projectFileReference binaryReadStreamDo: [:stream |  STON fromStream: (ZnCharacterReadStream on: stream encoding: 'utf8') ].  ^IceBasicProject onProperties: properties commitish: anIceCommitishisNoCommit  ^falseaccept  button performActionlookupCommit: commitId ifAbsent: aBlock  ^[ self revparse: commitId ] on: NotFound do: aBlockoriginMethod  ^(Smalltalk at: self definition methodClass name) >> self definition selectorinitialize  super initialize.  url := 'No remote url'.  projectName := 'No name'.  name := 'No remote'remotePanel  ^remotePanelcommitish  ^commitishisAddition  ^falsereadFrom: credentials  self username: credentials username.  self password: credentials passwordhandlesMouseDown: evt  ^truepath  ^path ifNil: [ path := OrderedCollection new ]selectedPullRequest  | table |  table := self pullRequests widget.  ^table dataSource elementAt: table selectedRowIndexrepositoryRemoteName  ^self repositoryModel pushRemoteNameinit  (LGitRepository on: self location) inituserNameLabel: anObject  userNameLabel := anObjecttool: anObject  tool := anObjectcheckoutWithStrategy: aCheckoutStrategy then: aBlock  < noCache>  IceTipStandardAction new     repository: self entity repository;     message: ('Checking out branch {1} from {2}' format: {self name .               self repositoryName});     onSuccessRepositoryModified;     onSuccess: aBlock;     execute: [ self entity checkoutWithStrategy: aCheckoutStrategy ]description  ^self commit descriptionitemNameWithoutBranches  ^'Open on github'headBranchName  ^headBranchNamedescription  self subclassResponsibilitycredentialStore  ^IceCredentialStore currentunloadPackage: aPackage  aPackage mcWorkingCopy ifNotNil: #unloadrightContents  ^rightOperation leftContentscommitsInPackageCache  ^commitsInPackageCache ifNil: [ commitsInPackageCache := LRUCache new maximumWeight: 30 ]isHead  ^self entity isHeadvisitRootDefinition: anIceRootDefinition  self visitChildrenOf: currentNoderepositoryModelsByGroup  | branches tags |  branches := self allBranchModels.  tags := self tagModels.  ^{((IceTipTreeRepositoryGroup on: self)     name: 'Branches';     icon: (self iconNamed: #branch);     children: (branches select: [:each |  each entity isLocal ] thenCollect: [:each |  IceTipTreeBranch on: each ]);     yourself) .   ((IceTipTreeRepositoryGroup on: self)     name: 'Remotes';     icon: (self iconNamed: #remote);     children: (self entity remotes collect: [:eachRemote |  | remoteModel |              remoteModel := (IceTipRemoteModel repositoryModel: self on: eachRemote) beCached.              (IceTipTreeRemote on: remoteModel)                 name: remoteModel name;                 children: (branches select: [:each |  each entity isRemote and: [ each entity remoteName = eachRemote name ] ] thenCollect: [:each |  IceTipTreeBranch on: each ]);                 yourself ]);     yourself) .   ((IceTipTreeRepositoryGroup on: self)     name: 'Tags';     icon: (self iconNamed: #glamorousBookmark);     children: (tags collect: [:each |  IceTipTreeTag on: each ]);     yourself)}loadedVersion  ^loadedVersionusernameLabel  ^usernameLabelkeyPassphrase  ^keyPassphrase ifNil: [ keyPassphrase := '' ]package  ^packagebasicSelectionChanged: aType  type := aType.  aType ifNotNil: [ self title: type title.        self replacePanelWith: type ] ifNil: [ self removeAllPanels.        self title: self class title ]diff: anObject  diff := anObjectdoRemoveRemote: aRemote  self handleLibgitError: [ (LGitRemote of: self repositoryHandle named: aRemote name)           lookup;           delete ]listPanel: anObject  listPanel := anObjectlabelColor: aColor  ^labelColor := aColorrefresh  selectedModel ifNotNil: [ self showInfoTabs ] ifNil: [ self showEmptyTab ]isGroup  ^truepackageList  ^packageListusername: anObject  username := anObjectaccept  self removeFromRepositoryCheckbox state ifTrue: [ self model remove ].  self unloadFromImageCheckbox state ifTrue: [ self model unload ]repository  ^repositoryisConflict  ^falsevisitCheckoutConflict: anError  UIManager default alert: anError messageText title: 'Iceberg conflicts while checking out'doRemoveRemote: aRemote  self subclassResponsibilitycontextClass  ^IceTipRepositoryListContextprojectNameLabel: anObject  projectNameLabel := anObjectbranchLabel: anObject  branchLabel := anObjectcommitish: anIceCommitish  commitish := anIceCommitishentry: anObject  entry := anObjectisDefault  ^host = #*urlText: anObject  urlText := anObjectcommitModels  ^(self entity outgoingCommitsTo: self remote) collect: [:each |  (IceTipCommitModel repositoryModel: self repositoryModel on: each) beCached ]gitRef  ^self nameisGroup  ^falsecollectCommitsFor: aMethod path: aPath  | commit pathSpec options commits |  commit := self repository headCommit.  pathSpec := LGitPathSpec withAll: {aPath}.  options := LGitDiffOptions defaults.  options pathspec: (LGitStringArray withAll: {aPath}).  commits := OrderedCollection new.  self repository newCommitWalk     fromCommit: commit;     rawResultsDo: [:eachCommit |  | parents tree |        parents := eachCommit numberOfParents.        tree := eachCommit tree.        parents = 0 ifTrue: [ (tree matchesPathSpec: pathSpec) ifTrue: [ commits add: eachCommit ] ] ifFalse: [ eachCommit parents do: [:eachParent |  | diff |                    diff := tree diffTo: eachParent tree options: options.                    diff numberOfDeltas > 0 ifTrue: [ commits add: eachCommit ] ] ] ].  ^commitsacceptButton  ^acceptButtonchildAt: aString ifAbsentPut: aBlock  ^childrenDictionary at: aString ifAbsent: [ self addChild: aBlock value ]remoteUrl  ^self urlText text trimmedstatus  [ | status incoming outgoing |  self verifyDirectoryStructureIfMissing: [:message |  ^message ].  entity workingCopy workingCopyState isUnknownCommitState ifTrue: [ ^self toErrorMessage: entity workingCopy workingCopyState description ].  entity workingCopy isDetached ifTrue: [ ^self toErrorMessage: 'Detached Working Copy' ].  (entity head isDetached and: [ entity head tags notEmpty ]) ifTrue: [ ^self toWarningMessage: 'Detached HEAD' ].  entity head isDetached ifTrue: [ ^self toErrorMessage: 'Detached HEAD' ].  entity workingCopy project isUnborn ifTrue: [ ^self toErrorMessage: 'No Project Found' ].  self isLoaded ifFalse: [ ^'Not loaded' ].  status := OrderedCollection new.  entity isModified ifTrue: [ status add: 'Uncommited changes' ].  incoming := self incomingCommits size.  incoming > 0 ifTrue: [ status add: ('{1} incoming' format: {incoming}) ].  outgoing := self outgoingCommits size.  outgoing > 0 ifTrue: [ status add: ('{1} not published' format: {outgoing}) ].  status ifEmpty: [ status add: 'Up to date' ].  ^', ' join: status ] on: Error do: [:error |  ^self toErrorMessage: error description ]initialExtent  ^(700 @ 700) scaledByDisplayScaleFactorsnapshotFor: anIceSavedPackage  ^self commit snapshotFor: anIceSavedPackagenewStatusPanel  ^PanelMorph new     color: Color transparent;     layoutPolicy: TableLayout new;     listDirection: #leftToRight;     cellInset: 5;     vResizing: #spaceFill;     hResizing: #spaceFill;     asSpecAdaptertonelPackageName: aPackage  ^aPackage namedescription  ^operation descriptiontreeToShow  ^self treeisCodeMissing  ^entity isCodeMissingforget  self class unregisterRepository: self ifAbsent: [ ^nil ].  Iceberg announcer announce: (IceRepositoryForgotten repository: self)repositoryModel  ^repositoryModelbrowse  (RPackageOrganizer default packageNamed: self name) browsechildren  ^children ifNil: [ #() ]minor  ^minorallBaselines  ^(self repositoryModel entity workingCopy packages select: [:each |  each name beginsWith: 'BaselineOf' ]) sorted: [:a :b |  a name < b name ]newRepository  | repositoryName location subdirectory |  repositoryName := self projectNameInputText text trimmed.  location := self projectLocation location.  subdirectory := self subdirectoryInputText text asString trimmed.  UIManager default informUser: ('Cloning repository {1} at {2}' format: {repositoryName .               location fullName}) during: [ ^IceRepositoryCreator new           repository: repository;           location: location;           subdirectory: subdirectory;           createNewRepositoryNamed: repositoryName ]postFetch  | maybeGoodCommit |  self workingCopy referenceCommit isUnknownCommit ifFalse: [ ^self ].  maybeGoodCommit := self lookupCommit: self workingCopy referenceCommit id.  maybeGoodCommit isUnknownCommit ifFalse: [ maybeGoodCommit adopt ]codeSubdirectoryNode  ^self repository subdirectory ifNotEmpty: [ tree firstNodeSuchThat: [:definition |  self isCodeSubdirectory: definition ] ] ifEmpty: [ tree ]jsonContents  ^jsonContents ifNil: [ jsonContents := STON fromString: self contents ]message: anObject  message := anObjectsetModelBeforeInitialization: anObject  model := anObjecturlText: anObject  urlText := anObjectwriterClass  ^writerClass ifNil: [ writerClass := self repository writerClass ]rowHeight  ^rowHeight ifNil: [ rowHeight := self class defaultRowHeight ]retrieveDetail  self mergeablePanel widget addMorphBack: 'Loading...' asMorph.  [ | detail mergeable |  [ detail := self pullRequest detail.  mergeable := detail at: #mergeable ] on: Error do: [:e |  mergeable := nil ].  UIManager default defer: [ self mergeablePanel widget           removeAllMorphs;           addMorphBack: (self iconForMergeable: mergeable) asMorph;           addMorphBack: (self textForMergeable: mergeable) asMorph ] ] forknewContext  ^super newContext     repositoryModel: self model repositoryModel;     yourselficeVersion: anObject  | repository packageDirectoryName |  iceVersion := anObject.  repository := iceVersion commit repository.  package := iceVersion package.  packageDirectoryName := iceVersion commit writerClass directoryNameFor: package.  self packageDirectory: (repository subdirectoryPath / packageDirectoryName) pathStringexecute  ^IceGitHubNewPullRequestAction new     repository: self repository;     executedirectoryName  ^self repository directoryNameForPackage: selfobtainLastCommitMessage  ^self branch commit commentremoveAllCommitPanelTabs  commitTabPanel tabs copy do: [:each |  commitTabPanel removeTab: each ]showInfoTabs  (commitTabPanel tabs includes: infoTab) ifFalse: [ self removeAllCommitPanelTabs.        commitTabPanel           addTab: infoTab;           addTab: diffTab ].  self refreshCommitInfo.  self refreshDiffLabel.  commitTabPanel selectedTab ifNotNil: #tabSelectedputFocusOrder  ^self subclassResponsibilityshortCommitId  ^repositoryModel shortCommitIdpushTo: aRemote  self subclassResponsibility= another  self species = another species ifFalse: [ ^false ].  ^self commit = another commitparent  ^self ancestors firstchangesTo: aCommitish  aCommitish = self ifTrue: [ ^#() ].  ^aCommitish changesFromNoCommit: selfexception: anException  exception := anException freezerepositorySelected  | selectedIndex |  self flag: #todo.  selectedIndex := repositoryList widget selectedIndex.  selectedIndex = 0 ifTrue: [ ^nil ].  ^repositoryList widget dataSource elementAt: selectedIndex ifAbsent: [ nil ]text: aString  textWidget widget contentsWrapped: aStringreaderClass  ^self properties readerClassfileFormat: aClass  self fileFormatId: aClass idcontextCellColumn: column rowIndex: rowIndex  | context |  context := (self elementAt: rowIndex) at: column id.  (context includesSubstring: 'travis-ci') ifTrue: [ context := 'travis-ci' ].  ^FTCellMorph new     addMorphBack: context asMorph;     yourselfinitializeCheckoutStrategyList  | checkoutStrategies |  checkoutStrategies := self model checkoutStrategies.  checkoutStrategyList     items: checkoutStrategies;     displayBlock: [:each |  each description ].  checkoutStrategyList whenSelectedItemChanged: [:aStrategy |  self model checkoutStrategy: aStrategy ]conflictsDo: aBlockClosure  mergeTree do: [:each |  each isConflict ifTrue: [ aBlockClosure value: each value ] ]initializeCurrentBranchLabel  currentBranchLabel := self newLabel label: 'Current branch: ' , self model branchNameincomingCommits  ^#()author  ^authorinitialExtent  ^(500 @ 250) scaledByDisplayScaleFactormodel  ^modelmodel  ^modelmcPackageSnapshotsOfPackages: aCollection  self flag: #todo.  ^aCollection select: #isLoaded thenCollect: [:package |  [ (self repository mcVersionFor: (IceSavedPackageVersion fromCommit: self package: package mcPackage)) snapshot ] on: IceVersionDoesNotExist do: [:e |  MCSnapshot empty ] ]defaultBaseBranchName  self hasParent ifFalse: [ ^self baseDefaultBranchName ].  ^self baseBranchNames detect: [:each |  each = self branch shortname ] ifNone: [ self baseDefaultBranchName ]setModelBeforeInitialization: aModel  self repositoryModel: aModelbeDirty  isDirty := truebasicExecute  self fetchAllRemotesprotocol: anObject  protocol := anObjectisInverseMerge  ^self imageCommit = mergeCommiticonPanel  ^iconPanelcheckoutOn: anIceWorkingCopy  self subclassResponsibilityvisitMergeAborted: anError  self visitGenericError: anErrornewCellFor: item  | cell |  cell := FTIndentedCellMorph new.  cell indentBy: item depth * 16.  cell addMorphBack: (self buttonFor: item).  (self iconFor: item data) ifNotNil: [:icon |  cell addMorphBack: icon asMorph ].  cell addMorphBack: (self toString: item data) asMorph.  ^celltoolAnnouncer  ^self tool announcerchildren  ^childrenDictionary values sorted: [:a :b |  a key < b key ]printOn: aStream  aStream     nextPutAll: 'gitChange(';     nextPutAll: filePathString asString;     nextPutAll: ')'iconPanel  ^iconPanelcommit  self subclassResponsibilityincludesCommit: anIceCommit  self lookupCommit: anIceCommit id ifAbsent: [ ^false ].  ^truedescriptionWithDecoration  | text |  text := self displayString asText.  self entity isModified ifTrue: [ text := ('*' , text) asText makeAllColor: self colorModified ].  ^textcollectWithPath: aBlock  | newNode |  newNode := self class value: (aBlock value: self value value: self path).  self nodesDo: [:e |  newNode addNode: (e collectWithPath: aBlock) ].  ^newNodediffToWorkingCopy  | commitModel |  commitModel := IceTipCommitModel on: self entity commit.  ^commitModel diffToWorkingCopyheadForkList  ^headForkListcommits  self shouldBeImplementedgetPaginated: aString  ^IceGitHubAPIPaginatedResult api: self request: aStringpushCheckbox  ^pushCheckboxinitializeCurrentBranchLabel  currentCommitishLabel := self newLabel label: 'Current commit: ' , commitishToTag commit shortIdrepositoryName  ^self repositoryModel nameexecute  | commit |  commit := self repository headCommit.  commit merge.  self repository workingCopy referenceCommit = commit ifTrue: [ self beSuccess ]branchModel  ^(IceTipBranchModel repositoryModel: self on: self entity branch) beCachedcontextClass  ^IceTipBranchContextisAlreadyMerged  ^mergeCommit isAncestorOf: self leftCommitparseUrl  | znUrl |  znUrl := ZnUrl fromString: url.  user := znUrl username.  host := znUrl host.  port := znUrl port ifNil: [ self class defaultPort ].  path := znUrl segments allButLast: 2.  znUrl segments size >= 2 ifTrue: [ owner := (znUrl segments last: 2) first ].  znUrl segments isEmpty ifTrue: [ IceWrongUrl signal: 'Remote repository scheme not supported: ' , url ].  projectName := self stripPossibleExtension: znUrl segments lastdescription  ^[ super description ] on: Error do: [ self location isNil ifTrue: [ 'Not specified location' ] ifFalse: [ 'Bad location: ' , self location path pathString ] ]newIcePanel  ^super newIcePanel     in: [:this |  this widget listDirection: #rightToLeft ];     yourselfinitializeWidgets  locationLabel := self newLabel label: self label.  locationInput := self newTextInput autoAccept: true.  chooseButton := self newButton icon: self icon.  locationInput whenBuiltDo: [:w |  w widget wrapFlag: false ].  chooseButton action: [ self choose ].  self focusOrder add: locationInputcredentialSelected  | index dataSource |  index := credentialsList widget selectedRowIndex.  index = 0 ifTrue: [ ^nil ].  dataSource := credentialsList widget dataSource.  dataSource hasElements ifFalse: [ ^nil ].  ^dataSource elementAt: indexdiscardChanges  < noCache>  IceTipStandardAction new     repository: self entity;     message: 'Discarding changes';     onSuccessRepositoryModified;     execute: [ Iceberg announcer suspendAllWhile: [ self entity discardChanges ] ]title  ^'Working copy of ' , self model repositoryNamemenuSelectionContextWithSelection: anObject  ^self tool newContextWithSelection: anObjectinitialExtent  ^(600 @ 400) scaledByDisplayScaleFactoricon  ^definition iconinitializePackageNameText  self packageNameText whenBuiltDo: [:ann |  ann widget           bindKeyCombination: Character enter asKeyCombination toAction: [ self accept ];           bindKeyCombination: Character arrowUp asKeyCombination toAction: [ self packagesList takeKeyboardFocus.              self packagesList widget selectLastVisibleRow ];           bindKeyCombination: Character arrowDown asKeyCombination toAction: [ self packagesList takeKeyboardFocus.              self packagesList widget selectFirstVisibleRow ] ]initialize  super initialize.  self subscribeToAnnouncementsmergeButton: anObject  mergeButton := anObjectusername  ^self nameInput text trimBothremoteBranchNamed: aString  ^self remoteBranchNamed: aString ifPresent: [:branch |  ^branch ] ifAbsent: [ IceBranchNotFound new           branchName: aString;           signal ]merge  mergeType mergeOn: commitish then: [  ]execute  iconNameForStatus: status  status = 'success' ifTrue: [ ^#testGreen ].  status = 'failure' ifTrue: [ ^#testRed ].  status = 'pending' ifTrue: [ ^#testYellow ].  ^#testNotRunmcVersionFor: anIceSavedPackageVersion  | mcPackage mcWorkingCopy |  mcPackage := anIceSavedPackageVersion mcPackage.  mcWorkingCopy := mcPackage workingCopy.  ^MCVersion new setPackage: anIceSavedPackageVersion mcPackage info: mcWorkingCopy versionInfo snapshot: mcWorkingCopy snapshot dependencies: #()storeFileDefinition: anIceFileDefinition  (repository location resolve: anIceFileDefinition path)     ensureDelete;     binaryWriteStreamDo: [:writeStream |  writeStream nextPutAll: anIceFileDefinition binaryContents ].  self addPath: anIceFileDefinition pathrepositoryHandle  < repositoryHandleAccessor>  ^repository repositoryHandlenameLabel  ^nameLabelensureStarted  started ifFalse: [ self start ]repository: anObject  repository := anObjectcommitButton: anObject  ^commitButton := anObjectcommitId  ^repositoryModel commitIdactualClass  self subclassResponsibilitycypressMethodClassExtension: aMethod  aMethod isExtension ifTrue: [ ^'.extension' ].  aMethod origin isTrait ifTrue: [ ^'.trait' ].  ^'.class'location  ^self projectLocation locationvisitWorkingCopyDesynchronizedError: anError  | solveStrategy command |  solveStrategy := UIManager default chooseFrom: #('Create new branch and commit' 'Merge local copy into image and commit') values: {IceCreateBranchCommand .         IceMergeWorkingCopyCommand} message: 'Your loaded code is not synchronized with the local sources in your repository. You need to solve this problem before you continue, please choose one of the strategies below.' title: 'Loaded code out of sync!'.  solveStrategy ifNil: [ ^self ].  (command := solveStrategy new)     repository: self repository;     execute.  command isSuccess ifTrue: [ anError retry ]withMetacelloLoadSessionDo: aBlock  | context |  context := IceMetacelloLoadSessionContext value ifNil: [ IceMetacelloLoadSession new ].  IceMetacelloLoadSessionContext value: context during: aBlockacceptPullRequest: owner project: projectName number: aNumber data: aDictionary  ^self put: 'repos/' , owner , '/' , projectName , '/pulls/' , aNumber asString , '/merge' with: [:client |  client           entity: (ZnEntity text: (STON toJsonString: aDictionary));           contentType: ZnMimeType applicationJson ]readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  branchModel := aToolContext itemrepository  ^repositorynumberOfOutgoingCommits  ^[ | size |  self entity branch hasUpstream ifFalse: [ ^'*' ].  size := self outgoingCommits size.  size > 100 ifTrue: [ '99+' ] ifFalse: [ size ] ] on: IceNotInBranch do: [:e |  0 ]isSuccess  ^successtype  ^self typeList selectedItemincomingCommits  self head isDetached ifTrue: [ ^#() ].  ^self branch incomingCommitsmessageText: anObject  messageText := anObjectbranchLabel  ^branchLabelacceptButton: anObject  acceptButton := anObjectcontextClass  ^self subclassResponsibilitynewUnbornProject  ^IceUnbornProject onRepository: selfmergeWithOperation: anOperation  ^anOperation mergeWithLeftRemoval: selfpathFrom: aString  ^(aString endsWith: '.git') ifTrue: [ aString allButLast: 4 ] ifFalse: [ aString ]initialize  super initialize.  hasChanges := falsereadParametersFromContext: aToolContext  credential := aToolContext credential.  store := aToolContext store.  tool := aToolContext toolresponseWithValidationDo: aBlock  | response |  response := aBlock value.  self handleUnauthorized: response.  response isSuccess ifFalse: [ IceGitHubError signalFor: response ].  ^responsename  ^'Github'visitModification: anIceModification  anIceModification definition accept: selfvisitNothingToCommitError: anError  self visitGenericError: anErrorremoteBranchNamed: aString ifAbsent: aBlock  ^self remoteBranchNamed: aString ifPresent: [:branch |  ^branch ] ifAbsent: [ ^aBlock value ]visitEUSER: anError  anError messageText = 'No ssh-agent suitable credentials found.' ifTrue: [ anError resignalAs: IceAuthenticationError new ].  self visitGenericError: anErrorpull  self pullFrom: self upstream remotediffFromHead  ^iceCommit diffFromHeadreadContextParametersFromModel: aStore  store := aStoreobtainAvailableBranchNames  ^((self repository allBranches collect: #shortname as: Set)     addAll: self baseBranchNames;     asArray) sortcreateCommandContextForSelection: selectedItems  ^self newContextWithSelection: selectedItemsicon  ^icon ifNil: [ super icon ]removeAllPanels  | panelMorph |  panelMorph := self contentPanel morph.  panelMorph removeAllMorphsaccept: aVisitor  ^self subclassResponsibilityfilePathString: aString  filePathString := aStringowner  ^ownerinitializeDiff  diff beForMerge.  diff selectedModel: self commits widget dataSource elements anyOneentry: anObject  entry := anObject.  entry repository: self repositoryobtainCredentials  ^IceGitHubAPI obtainCredentialsstatus  ^status ifNil: [ status := IceGitHubAPI new get: 'repos/' , self owner , '/' , self projectName , '/commits/' , self headSHA , '/status' ]iceVersion: anObject  iceVersion := anObject.  self packageDirectory: (iceVersion commit project sourceDirectoryPath / (IcePackage named: iceVersion package name repository: iceVersion commit repository) directoryName) pathStringcommit  ^streamrefreshCommits  commitsPanel refreshremoveFrom: aStore  aStore removePlainTextCredential: selftargetDescription  ^'Merging commit: ' , self sourceVersion descriptionrepositoryWillBeCreated: aRepository  SystemVersion current major < 7 ifTrue: [ ^self ].  self fetchIfNeeded: aRepository.  (aRepository lookupCommit: SystemVersion current commitHash) adoptdoEdit: aRepository  repository     location: aRepository location;     subdirectory: aRepository subdirectorymergeWithLeftAddition: anIceAddition  self shouldNotImplementat: aKey ifAbsent: anObject  ^objects at: aKey ifAbsent: anObjectauthor  ^self entity authorvisitGitChange: anIceGitChange  | importer |  importer := IceGitChangeImporter new     path: anIceGitChange path;     diff: diff;     version: version;     yourself.  importer importOn: parentNodeinitializeFocusOrder  self focusOrder     add: remotePanel;     add: issueNumberText;     add: issueTextacceptError: anObject  anObject visitWorkingCopyDesynchronizedError: selfobtainPlaintextCredentials: credentialsToReturn  | returnedCred |  returnedCred := IceTipAskForPlaintextCredentialsModel new     credentialStore: self credentialStore;     remoteHostname: remote host;     open.  credentialsToReturn readFrom: returnedCredreasonPanel: anObject  reasonPanel := anObjectvisitNoModification: anIceNoModification  anIceNoModification definition accept: selfrepository  ^repositoryvalidate  | remoteString |  remoteString := self remoteUrl.  self assert: remoteString isNotEmpty description: 'You must enter your project url.'.  self assert: (IceGitRemote isValidUrl: remoteString) description: 'The url is incorrect.'.  self assert: self projectLocation location notNil description: 'Project location must be defined (if it does not exists, it will be created).'initializeWidgets  iconPanel := self newIcePanel.  iconPanel widget addMorph: (self iconNamed: #question) asMorph.  confirmLabel := self newLabel label: (self class confirmMessage format: {self model name}).  unloadFromImageCheckbox := self newCheckBox     label: 'Unload from image';     state: true.  removeFromRepositoryCheckbox := self newCheckBox     label: 'Remove from repository';     state: true.  self focusOrder     add: unloadFromImageCheckbox;     add: removeFromRepositoryCheckboxresetDiffContents  self diffContentsLeft: '' right: ''objects  ^objectsisLoaded  ^self entity isLoadedtoolbarItemFont  ^toolbarItemFont ifNil: [ toolbarItemFont := self newToolbarItemFont ]acceptError: anObject  anObject visitNothingToCommitError: selfpanel  ^panelfetch  self subclassResponsibilityhttpsUrl  ^'https://{1}{2}/{3}.git' format: {self host .         (self port ifNotNil: [ ':' , self port asString ] ifNil: [ '' ]) .         self path}icon  ^self iconNamed: #changeUpdateunload  < noCache>  IceTipStandardAction new     repository: self entity repository;     message: ('Unloading package {1}' format: {self entity name});     onSuccessRepositoryModified;     execute: [ Iceberg announcer suspendAllForRepository: self entity repository while: [ self entity unload ] ]selectedModel: aModel  selectedModel := aModel.  self refreshbasicInstall  | definition |  definition := self entity definition.  definition realClass compile: definition sourceCode classified: definition categorysetModelBeforeInitialization: anObject  model := anObjectaddTo: aTree  diff: leftTree with: rightTree  | mergedTree |  mergedTree := leftTree mergeWith: rightTree onLeft: [:definition |  IceAddition definition: definition ] onRight: [:definition |  IceRemoval definition: definition ] onMerge: [:left :right |  left = right ifTrue: [ IceNoModification definition: left ] ifFalse: [ IceModification left: left right: right ] ].  ^mergedTree select: [:operation |  operation hasChanges ]jsonAt: aKey  ^self json at: aKeyhelp  ^helpdescriptionWithDecoration  ^'{1} <{2}>' format: {self name .         self entity url}removeTag: anIceTag  self handleLibgitError: [ self repositoryHandle git_tag_delete: anIceTag name ]author  ^iceCommit authorisInvalid  ^truefileSystem  ^commitish fileSystemcreateCommandContext  ^self newContextWithSelection: self packageSelectedpushTagsToRemote: aRemote gitRemote: gitRemote progress: pushProgress  self tags do: [:tag |  self pushTag: tag toRemote: aRemote gitRemote: gitRemote progress: pushProgress ]addFileNamed: aString path: aRelativePath contents: aByteArray  | fileParentNode |  fileParentNode := parentNode.  aRelativePath segments allButLastDo: [:each |  fileParentNode := (fileParentNode includesKey: each) ifTrue: [ fileParentNode / each ] ifFalse: [ fileParentNode addChild: (IceDirectoryDefinition named: each) ].        self assert: fileParentNode value isDirectoryDefinition ].  fileParentNode addChild: (IceFileDefinition named: aString path: aRelativePath contents: aByteArray)position  ^position ifNil: [ IceTipItemPosition default ]forget  < noCache>  IceTipStandardAction new     repository: self entity;     message: ('Forgeting {1}' format: {self name});     execute: [ self entity forget ]newContextWithSelection: anObject  ^IceTipCredentialContext new     store: model;     credential: anObject;     tool: self;     yourselfinitializeWithParent: anIceTreeBuilder entryName: aString  | treeEntry |  parent := anIceTreeBuilder.  entryName := aString.  treeEntry := parent builder getEntryNamed: entryName.  treeEntry isReady ifTrue: [ initialTree := treeEntry tree ] ifFalse: [ hasChanges := true ]panel: anObject  panel := anObjectsort: aListOfPackages  | result packages lasts |  packages := aListOfPackages.  result := OrderedCollection new.  self first = #none ifFalse: [ result addAll: (self sortByName: (self selectMatching: self first from: packages)) ].  packages := packages copyWithoutAll: result.  lasts := self last = #none ifTrue: [ {} ] ifFalse: [ self selectMatching: self last from: packages ].  packages := packages copyWithoutAll: lasts.  result addAll: (self sortByName: packages).  result addAll: (self sortByName: lasts).  ^resultvalidateCanCommit  self subclassResponsibilityid  ^iceCommit iddefaultBranchSelection  ^self branchModels detect: #isHead ifNone: [ self hasBranches ifTrue: [ self branchModels ifNotEmpty: #anyOne ] ]initialize  super initialize.  branchesByName := OrderedDictionary newcanBrowseReferences  ^falsenewCommitsDataSource  | commitModels |  commitModels := self pullRequest commits collect: [:each |  (IceTipCommitModel repositoryModel: self repositoryModel on: each) beCached ].  ^IceTipDataSource new     tool: self;     elements: commitModels;     yourselfmergeType: aMergeType  mergeType := aMergeTypeprintOn: aStream  aStream nextPutAll: self class name.  self printDescriptionOn: aStreamcommitModels  ^commitModels ifNil: [ commitModels := self retrieveHistory collect: [:each |  (IceTipVersionModel repositoryModel: self repositoryModel on: each) beCached ] ]createTag: aString  self repository handleLibgitError: [ self repositoryHandle createTag: aString targetId: self libgitCommit id force: false.        ^IceTag named: aString inRepository: self repository ]toolbarItemSize  ^self class defaultItemSizecommit  ^selfvalidate  chooseConflictPolicyFor: aMetacelloUpgradeRequest  | projectName optionA optionB context |  context := IceMetacelloLoadSessionContext value.  projectName := aMetacelloUpgradeRequest projectName.  optionA := aMetacelloUpgradeRequest newProjectRegistration printString.  optionB := aMetacelloUpgradeRequest existingProjectRegistration printString.  ^context recordChoiceProject: projectName optionA: optionA optionB: optionB ifAbsentAnswer: [ self chooseConflictPolicyProject: projectName optionA: optionA optionB: optionB ]baseLabel  ^(self jsonAt: #base) at: #labelaccept: aVisitor  ^aVisitor visitRootDefinition: selfincomingCommits  self hasUpstream ifFalse: [ ^#() ].  ^self incomingCommitsFrom: self upstream remoterefresh  diffPanel refreshmin: anInteger  min := anIntegeruseLoaded  ^self resume: self builder addLocalRepositoryresetDiff  storeOnDirectory: aFileLocator root: rootDirectory  | propertiesFileReference relativePath |  propertiesFileReference := aFileLocator / self class propertiesFileName.  relativePath := propertiesFileReference relativeTo: rootDirectory.  propertiesFileReference resolve     ensureDelete;     writeStreamDo: [:stream |  (STONWriter on: stream)           prettyPrint: true;           newLine: OSPlatform current lineEnding;           nextPut: self properties ]asResumable  resumable := truecommitFromGitCommit: aLGitCommit  ^self commitCache at: aLGitCommit id hexString ifAbsentPut: [ IceGitCommit new           id: aLGitCommit id hexString;           author: aLGitCommit author name asByteArray utf8Decoded;           datetime: aLGitCommit time asDateAndTime;           ancestorIds: (aLGitCommit parents collect: [:parent |  parent id hexString ]);           comment: aLGitCommit message;           repository: self;           yourself ]hostDescription  ^host = #* ifTrue: [ 'Default' ] ifFalse: [ host ]messageText  ^self namepackageSelected  | index dataSource |  self flag: #todo.  index := packageList widget selectedIndex.  index = 0 ifTrue: [ ^nil ].  dataSource := packageList widget dataSource.  dataSource hasElements ifFalse: [ ^nil ].  ^dataSource elementAt: indexbadgeTextColor  ^Smalltalk ui theme badgeTextColorcommitWithMessage: message andParents: parentCommits  | index |  repository handleLibgitError: [ | signature commitId indexTreeId |        self addToGitIndex.        [ signature := self repositoryHandle defaultSignature ] on: LGit_GIT_ENOTFOUND , LGit_GIT_ERROR do: [:e |  IceGitUsernameOrEmailNotFound guessKind: e ifNot: [ e pass ] ].        index := self repositoryHandle index.        indexTreeId := index writeTreeAndReturnOid.        index free.        commitId := (LGitCommitBuilder of: self repositoryHandle)           tree: (LGitTree of: self repositoryHandle fromId: indexTreeId);           message: message withUnixLineEndings utf8Encoded asString;           parents: (self repositoryHandle isUnborn ifTrue: [ #() ] ifFalse: [ self libGitCommitsFrom: self repositoryHandle for: parentCommits ]);           updateReference: ([ self repositoryHandle head name ] on: LGit_GIT_EUNBORNBRANCH do: [ repository branch gitRef ]);           author: signature;           committer: signature;           writeCommit;           commitId.        ^repository commitFromGitCommit: (LGitCommit of: self repositoryHandle fromId: commitId) ]traversingDo: aBlock parents: anArray  aBlock cull: self cull: anArray.  self children do: [:each |  each traversingDo: aBlock parents: (anArray copyWith: self) ]hasMultipleAncestors  ^self entity hasMultipleAncestorsmessageText  ^messageText ifNil: [ self class defaultMessageText ]traversingDo: aBlock parents: anArray  self subclassResponsibilityhasBranches  ^self branches isNotEmptyselectRight  chosen := rightOperationbuilder: anObject  builder := anObjectdoAccept  self selectedType doAcceptcurrentBranchLabel  ^currentBranchLabelparent  ^parentisUnknownCommit  ^falsevalidateCanMerge  | imageCommit headCommit mergeCommit |  self repository isModified ifTrue: [ Warning signal: 'Experimental Feature: merge when there is a dirty working copy. Could cause a loss of your local changes. Please commit before merge.' ].  imageCommit := self repository workingCopy referenceCommit.  headCommit := self repository headCommit.  mergeCommit := self commit.  {mergeCommit .   imageCommit .   headCommit} asSet size > 2 ifTrue: [ IceMergeAborted signal: ('Cannot perform a tri-merge. You are trying to merge {1} into {2}, but the image is in {3}. Please, procceed to load either {1} or {2} in your image to merge.' format: {mergeCommit description .                     self repository head description .                     imageCommit description}) ]isUnbornBranch  ^falsedeleteAll  self builder clearhasChanges  ^self chosenOperation hasChangesvisitNothingToCommitError: anError  UIManager default inform: 'There is nothing to commit.'fileFormat  ^self writerClassprojectName  ^((self jsonAt: #base) at: #repo) at: #nameitem  ^itemcurrent: anInteger  current := anIntegerrepositoryModel  ^repositoryModeldetailedInfo  ^{('Origin' -> path pathString)}includesPackageNamed: aString  ^self workingCopy includesPackageNamed: aStringprintOn: aStream  aStream     nextPutAll: 'IceNode(';     nextPutAll: self key asString;     nextPutAll: ')'isUnknownCommitState  ^falsedefinition  ^leftOperation definitionaccept  ^[ self doAccept.  true ] on: IceError , IceWarning do: [:e |  e acceptError: IceTipInteractiveErrorVisitor new.        false ]selectedItem  ^self table selectedRowIndexes ifNotEmpty: [:indexes |  self elementAt: indexes first ] ifEmpty: [ nil ]markAsCleanPackagesNotInDiff: aDiff  self markAsCleanPackagesThat: [:each |  (aDiff includesPackageNamed: each name) not ]copyToClipboard: url  Clipboard clipboardText: url informing: ('Url {1} copied to clipboard' format: {url})pullRequests: anObject  pullRequests := anObjectremoteAt: aString put: aRemote  self subclassResponsibilityhasChanges  ^falseinitializeDialogWindow: aWindow  super initializeDialogWindow: aWindow.  aWindow title: self title.  self updateOkButton.  aWindow centeredhasIncomingCommits  ^self hasIncomingCommitsFrom: self repository originhostLabel  ^hostLabelremoteLabel  ^remoteLabelprojectNameInputText  ^projectNameInputTextcollapseAll  changeList widget dataSource     rootForItems: self model treeRoots;     selectAllcopyWithOnly: aCollection  ^self diff copyWithOnly: aCollectioncheckoutBranchPanelsOnModel: aRepositoryModel  ^{(IceGitHubNewBranchFromIssuePanel on: aRepositoryModel)}description  ^'No code loaded'initializeWidgets  branchesList := self newIceTable.  self initializeBranchesList.  self focusOrder add: self branchesListrequestRemoteBranch: aName  ^IceGitHubAPI new getBranch: self remote owner project: self remote projectBasename name: aNamedescriptionWithDecoration  ^self subclassResponsibilitycontents  mcDefinition ifNil: [ ^'' ].  ^self isMeta ifFalse: [ mcDefinition definitionString ] ifTrue: [ mcDefinition classDefinitionString ]message  ^self messageText text asStringreportError: error  | message |  message := error messageBody.  message = 'Invalid field: head' ifTrue: [ message := 'Branch does not exist on github. Please commit and push your changes.' ].  UIManager default alert: message title: 'Error creating pull request: ' , error messageTexttitleLabel: anObject  titleLabel := anObjectpublicKey: anObject  publicKey := anObject.  self storeIfDefaultdefinitionFor: aMethod path: aPath commit: aCommit  self subclassResponsibilitypullFrom: aRemote  self branch pullFrom: aRemotereadOnlyVersion  ^IceInvalidProject onCommitish: commitishvisitModification: anIceModification  ^anIceModification leftDefinition accept: selfinitialize  super initialize.  workingCopy := IceWorkingCopy basicNew.  workingCopy repository: self.  workingCopy initialize.  index := self newIndexexecute  | repositories |  (UIManager default confirm: 'This operation can take some times depending on the size and number of your repositories. Are you sure you want to fetch all repositories?' label: 'Proceed?') ifFalse: [ ^self ].  repositories := IceRepository registry.  UIManager default informUserDuring: [:bar |  bar max: repositories size.        bar value: 1.        repositories withIndexDo: [:each :index |  bar label: ('Fetching incoming commits of {1}' format: {each name}).              bar value: index + 1.              each fetch ] ].  Iceberg announcer announce: IceRepositoryModified newmarkAsDirtyPackageNamed: aPackageName  (self packageNamed: aPackageName) beDirtybecomeForward: otherObject copyHash: copyHash  (Array with: self) elementsForwardIdentityTo: (Array with: otherObject) copyHash: copyHashname  ^self gitRef withoutPrefix: self branchNamePrefixhistoryOfMethod: aMethod  | path commits |  path := self toFileName: aMethod.  commits := self collectCommitsFor: aMethod path: path.  ^self collectVersionsFrom: commits method: aMethod path: pathremote: anObject  remote := anObjectinitialExtent  ^(350 @ (self class inputTextHeight * 5 + self class buttonHeight)) scaledByDisplayScaleFactordiffTree: anIceTreeDiff  tree := anIceTreeDiffrepositoryDescription  ^self repository descriptionaddDecorationTo: aString  | text |  text := aString asText.  [ self entity isHead ifTrue: [ text := text allBold ] ] on: IceNotInBranch do: [:e |   ].  ^textelementAt: aNumber ifAbsent: aBlock  ^self elements at: aNumber ifAbsent: aBlocklocation  ^locationreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  browser := aToolContext toolnewRepository  UIManager default informUser: ('Importing repository from {1}' format: {self location fullName}) during: [ ^IceRepositoryCreator new           repository: repository;           location: self location;           createRepository ]project: anIceProject  self basicSetProject: anIceProject.  self refreshProjectprojectNameInputText: anObject  projectNameInputText := anObjectinitialize  super initialize.  job := IceExternalJob new     title: 'Checking out...';     yourself.  self initializeBlockhash  ^self contents hashshortId  ^self id first: 7useRemote: aRemoteModel  self selectRemoteModel useRemote: aRemoteModelvalue: aBoolean  aBoolean ifTrue: [ self addItem ] ifFalse: [ self removeItem ]panel  ^paneltitle  ^'Repository of ' , self model nameaddToGitIndex  repository addFilesToIndex: modifiedFilePathscontents  ^String streamContents: [:stream |  stream nextPutAll: 'Package tags: '.        categories do: [:elem |  stream                 nextPutAll: String crlf;                 nextPutAll: String tab;                 nextPutAll: elem ] ]addItem  (list includes: item) ifTrue: [ ^self ].  list add: itemstubVersionInfo  ^stubVersionInfo ifNil: [ stubVersionInfo := MCVersionInfo name: packageName id: UUID new message: 'fabricated from a proxy repository' date: nil time: nil author: '' ancestors: #() ]packageName  ^self entity packageNamemodifiedPackages  ^self loadedPackages select: [:e |  e isDirty ]contextSelection  ^self selectedPackagemaxNumber  ^maxNumberitems: aCollection  self listPanel items: aCollectioninitializeWidgets  super initializeWidgets.  hostLabel := self newLabel label: 'Host: '.  hostInput := self newTextInput     autoAccept: true;     whenTextChanged: [ self updateOkButton ];     yourselfowner  ^ownermcPackage  ^package mcPackageprintOn: aStream  aStream     nextPutAll: self class name;     nextPut: $(;     nextPutAll: name asString;     nextPut: $)height  ^self extent yinitializeWidgets  super initializeWidgets.  usernameLabel := self newLabel label: 'Username: '.  usernameInput := self newTextInput     autoAccept: true;     whenTextChanged: [ self updateOkButton ];     yourself.  passwordLabel := self newLabel label: 'Password: '.  passwordInput := self newTextInput     beEncrypted;     autoAccept: true;     whenTextChanged: [ self updateOkButton ];     yourselfmorphicOpen: workingCopy  | shouldOpenIceberg |  shouldOpenIceberg := UIManager default confirm: ('{1} belongs to {2} and cannot be browsed here. Do you want to open the Iceberg Browser instead?' format: {workingCopy packageName .               self repository name}) label: 'Browsing an iceberg repository' trueChoice: 'Open' falseChoice: 'Cancel' cancelChoice: nil default: true.  shouldOpenIceberg ifFalse: [ ^self ].  IceTipRepositoriesBrowser new openWithSpecrefresh  packagesList widget     in: [:this |  this selectRowIndexes: #().        this dataSource           rootForItems: self model repositoryModelsByGroup;           expandAll ];     refreshusernameLabel  ^usernameLabelvisitDirectoryDefinition: anIceDirectoryDefinition  self visitChildrenOf: currentNodechooseUpgradePolicyFor: aMetacelloUpgradeRequest  | projectName optionA optionB context |  context := IceMetacelloLoadSessionContext value.  projectName := aMetacelloUpgradeRequest projectName.  optionA := aMetacelloUpgradeRequest newProjectRegistration printString.  optionB := aMetacelloUpgradeRequest existingProjectRegistration printString.  ^context recordChoiceProject: projectName optionA: optionA optionB: optionB ifAbsentAnswer: [ self chooseUpgradePolicyProject: projectName optionA: optionA optionB: optionB ]mergeCommit: aCommit  self subclassResponsibilitywithoutHead  self branchesList widget dataSource elements: (self branchModels reject: #isHead).  self branchesList widget selectFirstVisibleRowdirectory: aDirectory  rootItem := (self class rootItemFor: {aDirectory})     dataSource: self;     yourself.  self rootItem: rootItemreferencesSameRemoteLocationAs: another  ^self url sameAs: another urlprojectNameLabel: anObject  projectNameLabel := anObjectpackageNamed: aString  ^self packagesDictionary at: aStringvisitFileNode: anIceFileDefinition  index addPath: anIceFileDefinition pathpackageNameFromDirectory: aString  ^self writerClass packageNameFromDirectory: aStringprojectLocation: anObject  projectLocation := anObjectcodeDirectoryWithDelim  ^self repository subdirectory isEmptyOrNil ifTrue: [ '' ] ifFalse: [ self repository subdirectory , '/' ]diff: anIceDiff  diff := anIceDiffcheckoutStrategy: aStrategy  checkoutStrategy := aStrategyacceptError: anObject  anObject visitMissingCredentialsError: selfinitializeWidgets  super initializeWidgets.  self initializeSourceDirectory.  projectNameLabel := self newLabel label: 'Project name'.  projectNameInputText := self newTextInput     ghostText: 'e.g., MyProject';     autoAccept: true.  projectNameInputText whenTextChanged: [:text |  projectLocation appendPath: text ].  self focusOrder     add: self projectNameInputText;     add: self projectLocation;     add: self subdirectoryInputText;     add: self remoteInputTextallPathSegments  self isRoot ifTrue: [ ^#() ].  self parent isRoot ifTrue: [ ^{self key} ].  ^self parent allPathSegments copyWith: self keygtDisplayOn: stream  ^self printOn: streamrepositories  ^IceRepository registry collect: [:each |  (IceTipRepositoryModel on: each) beCached ]newContext  ^IceTipPullRequestsContext for: selforganisation  ^organisationname: aString  name := aStringtool: aBrowser  tool := aBrowserfileName  ^fileNameprojectPath  ^self pathdescription  ^'Nothing loaded'replace: oldNode with: newNode  self assert: oldNode name = newNode name.  childrenDictionary at: oldNode name put: newNodeicon  ^self class iconbaseRemote: anObject  baseRemote := anObjectcommit  ^self entity workingCopy referenceCommithasMultipleAncestors  | ancestors |  ancestors := self ancestors.  ^ancestors notNil and: [ ancestors size > 1 ]initialize  super initialize.  job := IceExternalJob new     title: 'Fetching Git objects...';     yourself.  self initializeBlockcheckoutStrategyLabel: anObject  checkoutStrategyLabel := anObjecthasChanges  ^falsevisitClassDefinition: anIceClassDefinition  repository workingCopy applyDefinition: anIceClassDefinition inNode: currentNode.  self visitChildrenOf: currentNodeinstallBaseline: icePackage  ^self installBaseline: icePackage groups: #()removeFromRepositoryCheckbox: anObject  removeFromRepositoryCheckbox := anObject= another  self subclassResponsibilitysubdirectoryReference  ^self location resolve: self subdirectoryPathvalidate  self assert: self selectedPackage isNotNil description: 'Please select a branch to checkout.'outgoingCommits  ^#()isResolved  ^falseignoreNotificationsDuring: aBlock  | oldValue |  oldValue := shouldIgnoreNotifications.  shouldIgnoreNotifications := true.  aBlock ensure: [ shouldIgnoreNotifications := oldValue ]headBranchList  ^headBranchListcanBeBrowsed  ^Smalltalk globals at: className ifPresent: [:class |  class includesSelector: name ] ifAbsent: [ false ]visitRootDefinition: anIceRootDefinition  self visitChildrenOf: currentNodefullname  ^nameworkingCopy: aWorkingCopy  workingCopy := aWorkingCopy.  workingCopy repository: selfmigratePackage: packageName commit: commit  | filetreePackage srcDir subDirWithDelim mcVersion |  srcDir := self codeDirectory.  subDirWithDelim := self codeDirectoryWithDelim.  mcVersion := (commit versionFor: packageName) mcVersion.  mcVersion := self ensureMCVersionWithClassOrganisation: mcVersion.  self writerClass forInternalStoreFileOut: mcVersion on: repository.  filetreePackage := commit writerClass directoryNameFor: packageName.  (srcDir / filetreePackage) ensureDeleteAll.  self repository addFilesToIndex: {(subDirWithDelim , (IceLibgitTonelWriter directoryNameFor: packageName)) .         (subDirWithDelim , (IceLibgitFiletreeWriter directoryNameFor: packageName))}name  ^self fullname withoutPrefix: self branchNamePrefixtonelMethodClassExtension: aMethod  aMethod isExtension ifTrue: [ ^'.extension' ].  aMethod origin isTrait ifTrue: [ ^'.trait' ].  ^'.class'model: anObject  model := anObjectisModified  ^self isMissing not and: [ super isModified ]addPackage: aPackage  self subclassResponsibilityvisitMissingCredentialsError: anError  self visitGenericError: anErrorusername  ^username ifNil: [ username := '' ]name: aString  name := aStringnewToolbarItemFont  | buttonFont |  buttonFont := Smalltalk ui theme buttonFont.  ^LogicalFont familyName: buttonFont familyName pointSize: buttonFont pointSize - 3doAccept  self validate.  self selectedBranch previewCheckoutinitializeBlock  self signature: self class fnSpec block: self blockpackages  ^self packageNames collect: [:name |  IcePackage named: name repository: self repository ]visitConflictingOperation: anIceConflictingOperation  anIceConflictingOperation isResolved ifFalse: [ self error: 'Cannot apply a non resolved conflict' ].  ^anIceConflictingOperation chosenOperation accept: selfnextVersionName  ^'{1}-{2}.{3}' format: {self package packageName .         self author .         (self info versionNumber + 1)}isHead  ^truefileName  ^fileNamebePositionRight  self position: IceTipItemPosition rightpath: aRelativePath  path := aRelativePathinitialize  super initialize.  self color: Color transparentstubVersionInfo: aVersionInfo  stubVersionInfo := aVersionInfonewCommitWalk  ^IceNullCommitWalk newpackageNames  ^self subclassResponsibilityisBranch  ^falserefreshCommitTabPanel  selectedModel ifNotNil: [ self showInfoTabs ] ifNil: [ self showEmptyTab ]browse  ^self leftDefinition browsemergeWithLeftAddition: anIceAddition  self shouldNotImplementcanReadProjectFromCommitish: aCommitish  ^aCommitish isWorkingCopy and: [ (aCommitish fileSystem / '.project') exists not ]diffPanel  ^diffPanelemailLabel: anObject  emailLabel := anObjectexecute  ^IceGitHubRemoveBranchesAction new     repository: self repository;     remote: self remote;     executeexecute  self withErrorHandlingDo: [ [ [ self basicExecute ] on: IceAuthenticationError do: [:e |  retries = 0 ifTrue: [ e pass ].              retries := retries - 1.              ^self execute ] ] on: LGitNoCredentialsProvided do: [ ^self ].        self finishSuccess ]toolbarItemFont: anObject  toolbarItemFont := anObjectactionColumn: column  elements := elements sorted: [:a :b |  (a at: column id) < (b at: column id) ]subdirectoryLabel: anObject  subdirectoryLabel := anObjectisRepositoryDetached  ^self entity workingCopy isDetached or: [ self entity head isDetached ]accept  | items |  self window delete.  items := self packagesList widget dataSource selectedItems.  items ifEmpty: [ UIManager default inform: 'No packages selected.'.        ^self ].  self model addPackages: itemstypeLabel: anObject  typeLabel := anObjectunloadFromImageCheckbox  ^unloadFromImageCheckboxoperationIcon  self subclassResponsibilityisParentOf: aCommit  ^falsevisitEEXISTS: anError  (anError messageText beginsWith: 'Failed to write reference ''refs/tags') ifTrue: [ | refName messageStream |        messageStream := anError messageText readStream.        refName := messageStream           upTo: $/;           upTo: $/;           upTo: $'.        IceTagAlreadyExists new           tagName: refName;           signal ].  self visitGenericError: anErrorprintOn: aStream  aStream     nextPutAll: self class name;     nextPutAll: ': ';     print: self namelocation  ^locationcontextClass  ^IceTipHistoryContextpreferredColor  ^self isResolved ifTrue: [ Color gray ] ifFalse: [ nil ]addNode: aNode  self at: aNode key put: aNode.  ^aNodeupdateIndex: anIceDiff  anIceDiff tree accept: (IceIndexUpdateVisitor new           index: self;           diff: anIceDiff)icon  ^iconimportOn: aNode  | currentSegment fileReference filePath |  currentSegment := path segments first.  filePath := aNode path / currentSegment.  fileReference := version fileSystem resolve: filePath.  fileReference exists ifFalse: [ ^self ].  ((diff isCodeSubdirectory: aNode) and: [ version writerClass isValidPackage: fileReference ]) ifTrue: [ ^self ensurePackageFromDirectory: fileReference inParentNode: aNode ].  path size = 1 ifTrue: [ fileReference exists ifTrue: [ ^aNode addChild: (IceFileDefinition named: currentSegment path: filePath fileReference: fileReference) ] ].  path size > 1 ifTrue: [ | directoryReference directoryPath |        directoryPath := aNode path / currentSegment.        directoryReference := version fileSystem resolve: directoryPath.        directoryReference exists ifTrue: [ self nextPath importOn: (self ensureDirectory: fileReference inParentNode: aNode) ] ]tool  ^toolrepository: anObject  repository := anObjectparentNode: anIcePackageNode  parentNode := anIcePackageNoderepository  ^repositorylocation  ^entity locationdescriptionWithDecoration  | text |  text := self displayString asText.  self entity isLoaded ifFalse: [ text := text makeAllColor: self colorNotLoaded ].  self entity isModified ifTrue: [ text := ('*' , text) asText makeAllColor: self colorModified ].  ^textpackageNames  ^#()issueNumberText: anObject  issueNumberText := anObjectformatList  ^formatListrepository: anObject  repository := anObjectisBranch  ^trueinitialize  super initialize.  suspendAll := false.  suspendedConditions := OrderedCollection new: 5isLoaded  ^self entity loadedPackages notEmptytoText  ^toTextcontentsString  ^ByteArray streamContents: [:stream |  (STONWriter on: (ZnCharacterWriteStream on: stream))           prettyPrint: true;           newLine: OSPlatform current lineEnding;           nextPut: self properties ]beClean  isDirty := falseisDefault  ^falseparent: anObject  parent := anObjectstoreVersion: aMCVersion  self subclassResponsibilitycomment  ^self commit commentorganisation: anObject  organisation := anObjectdescription  ^'Unknown {1}' format: {self shortId}visitFileNode: anIceFileDefinition  updateLabelOn: aCommitModel  self tab label: (self labelFor: aCommitModel)commitList: anObject  commitList := anObjectrepository  ^repositoryinstallBaseline: icePackage groups: anArray  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Installing baseline {1} of {2}' format: {(icePackage name allButFirst: self class baselinePrefix size) .               self repositoryModel name});     onSuccessRepositoryModified;     execute: [ Iceberg announcer suspendAllForRepository: self repositoryModel entity while: [ self basicInstallBaseline: icePackage groups: anArray ] ]isMissing  ^self entity isMissinglocationInput  ^locationInputvisitModification: anIceModification  ^anIceModification leftDefinition accept: selfinitializeWidgets  iconWidget := self newIcePanel.  textWidget := self newIceReadOnlyTexttab: anObject  tab := anObjectconfigureBuilder: aBuilder  aBuilder beBitbucketrefreshProjectFromRepository  | commitToCheck maybeProject |  commitToCheck := referenceCommit isCollection ifTrue: [ referenceCommit first ] ifFalse: [ referenceCommit ].  maybeProject := commitToCheck project.  maybeProject isInvalid ifFalse: [ self basicSetProject: maybeProject ].  properties := commitToCheck properties asBornProperties.  self refreshProject.  ^projectproperties  ^IceRepositoryProperties fromFileReferenceDirectory: self project sourceDirectoryReference commitish: selfisRemote  ^falseformatList: anObject  formatList := anObjectaddModification: anIceModification toPatcher: aMCPatcher  url: aString  self basicUrl: aString.  self parseUrlincludesPackageNamed: aString  ^self commit includesPackageNamed: aStringmergeType: anObject  mergeType := anObjectinitialExtent  ^(600 @ 400) scaledByDisplayScaleFactorstoreCredential: credential  self loadFromStore.  credential storeInto: self forHostname: credential host.  self saveIntoStorevisitPackage: anIcePackageDefinition  (self repository packageNamed: anIcePackageDefinition name) isLoaded ifFalse: [ ^self ].  currentNode accept: (IceMCSnapshotPatchVisitor new           patcher: loader;           yourself)branchModel  ^branchModelclassIsMeta  ^classIsMetacommits  ^self newCommitWalk commitsuptoCommit: commit  self revwalk hideCommit: (LGitId fromHexString: commit id)branchName  ^self branchInputText text asString trimBothremote  ^remote ifNil: [ remote := self askRemote ]removeFiletreeRemnants  | filetreeFiles |  filetreeFiles := self codeDirectory allChildrenMatching: '.filetree'.  filetreeFiles do: #ensureDelete.  self repository addFilesToIndex: (filetreeFiles collect: [:each |  (each relativeTo: self codeDirectory) printWithDelimiter: $/ ])initializeWidgetsContents  self initializeCurrentBranchLabel.  tagNameLabel := self newLabel label: 'New tag'.  tagNameInputText := self newTextInput     autoAccept: true;     ghostText: 'e.g., v[X].[Y].[Z]'.  self initializeNextTagPanel.  self initializeExistingTagsList.  spacePanel := PanelMorph new asSpecAdaptermessageLabel  ^messageLabelitem  ^itemvalidate  self selectedBranch ifNil: [ IceError signal: 'Please select a branch to checkout.' ]removeFileSystemCheckbox: anObject  removeFileSystemCheckbox := anObjectlocationLabel  ^locationLabelinitializeWidgets  messageLabel := self newLabel.  messageText := self newText autoAccept: true.  acceptButton := self newButton.  messageLabel label: 'Comment'.  messageText whenBuiltDo: [:this |  this widget withGhostText: self class messageGhostText ].  acceptButton label: 'Reject pull request'.  acceptButton action: [ self accept ].  self focusOrder     add: messageText;     add: acceptButtonsetModelBeforeInitialization: anObject  model := anObjectat: aKey  ^self properties at: aKeylocalBranches  self subclassResponsibilitycommit  ^commitbodyText  ^bodyTexttitle  ^'Add SSH credential'leftCommit  ^self isInverseMerge ifTrue: [ self headCommit ] ifFalse: [ self imageCommit ]visitProjectChange: anIceProjectChange  version project addToChangeBuilder: selfexecute  selectedCommitish adopt.  Iceberg announcer announce: (IceRepositoryModified for: self repositoryModel entity)projectPath  ^self repository origin projectPathname  ^'Metacello'visitECONFLICT: anError  anError object = LGitErrorTypeEnum giterr_checkout ifTrue: [ ^anError resignalAs: IceCheckoutConflictError new ].  self visitGenericError: anErrordefaultLocation  | remoteToUse |  remoteToUse := self remoteToUse.  ^IceLibgitRepository repositoriesLocation / remoteToUse organizer / remoteToUse projectNamevisitRemoteDesynchronizedError: anError  self visitGenericError: anErrorexecute  branchModel previewCheckoutexecute  onClickBlock ifNotNil: [ onClickBlock cull: self ]initializePackageList  packageList widget     beResizable;     addColumn: (IceTipTableColumn new           id: 'Name';           action: #descriptionWithDecoration;           yourself);     addColumn: (IceTipTableColumn new           id: 'Status';           action: #statusWithDecoration;           yourself);     dataSource: self newPackagesDataSource;     selectIndex: 1;     enableFilter: IceTipPackageFilter;     explicitFunctionversionFor: aCommitId  ^aCommitId commit versionFor: selfexecute  ^IceGitHubViewPullRequestAction new     repository: self repository;     remote: self remote;     executerepositoryModel  ^repositoryModeldoPush  self model pushThen: [ self window delete ]basicRemovePackage: aPackage  self packagesDictionary removeKey: aPackage name ifAbsent: [  ]remoteHostname: anObject  remoteHostname := anObjectlog  ^self subclassResponsibilityput: aString with: aBlock  ^self jsonContentsWithValidationDo: [ (self newRequestTo: aString)           in: aBlock;           put;           response ]finishSuccess  successBlock ifNotNil: [ successBlock value ]acceptButton  ^acceptButtoncanUpgradeTo: anMCGitBasedRepository  (anMCGitBasedRepository isKindOf: self class) ifFalse: [ ^false ].  ^self projectPath = anMCGitBasedRepository projectPath and: [ self repoPath = anMCGitBasedRepository repoPath and: [ self projectVersion = anMCGitBasedRepository projectVersion ] ]validateCanCommit  self validateMessageNotEmptylabel: aString  label := aString.  self locationLabel label: aStringnewChangeTreeDataSource  ^IceTipTreeDataSource new     tool: self;     rootForItems: self model treeRoots;     childrenBlock: [:data |  data children ];     icon: [:each |  each value icon ];     format: #description;     yourselfopenDialogWithSpec  ^super openDialogWithSpec     okAction: [ self accept ];     yourselfaddShortcutsTo: aWidget  super addShortcutsTo: aWidget.  aWidget bindKeyCombination: Character cr asKeyCombination toAction: [ self accept ]userNameInputText: anObject  userNameInputText := anObjectaddToChangeBuilder: anIceChangeImporter  newCommitsDataSource  ^IceTipDataSource new     tool: self;     elements: #();     yourselfdefinitionFor: aMethod path: aPath commit: aCommit  ^((IceLibgitTonelLogReader fileName: aPath on: aCommit)     package: aMethod package mcPackage;     packageDirectory: (self repository directoryPathStringForPackage: aMethod package);     definitions) detect: [:each |  each isMethodDefinition and: [ each selector = aMethod selector ] ] ifNone: [ MCMethodDefinition className: aMethod origin name selector: aMethod selector category: #'' timeStamp: nil source: '' ]validate  self assert: self branchName isNotEmpty description: 'Please enter your new branch name.'.  self assert: (self branchName noneSatisfy: #isSeparator) description: 'You can''t have spaces in your branch name.'removeItem  (list includes: item) ifFalse: [ ^self ].  list remove: itemlocationInput: anObject  locationInput := anObjectmergeWithOperation: anOperation  self subclassResponsibilitycommitList: anObject  commitList := anObjectrepository: anIceLibgitRepository  repository := anIceLibgitRepositoryformatToUse  ^IceLibgitRepository defaultFileFormatrepositoryProperties  ^self repository propertiesnewCommitWalk  ^repository newCommitWalk fromCommit: selfcommitish: aCommitish  commitish := aCommitishexecute  self packageModel unloadpackages  ^#()onAccept: aBlock  acceptBlock := aBlockreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  item := aToolContext itementryByPath: aString  ^aString = '.' ifTrue: [ self ] ifFalse: [ (($/ split: aString) reject: #isEmpty) inject: self into: [:treeBuilder :name |  treeBuilder entryByName: name ] ]anySatisfy: aBlockClosure  ^falsedescription  ^target descriptiondescription  ^'User: ' , self username , ' Public: ' , self publicKey , ' Private: ' , self privateKey= aWrapper  ^self item = aWrapper itemvisitNoModification: anIceNoModification  anIceNoModification definition accept: selfrowHeight: aNumber  rowHeight := aNumbersourceDirectoryTree  ^sourceDirectoryTreevisitShouldCommitBeforePullError: anError  | continue |  continue := UIManager default confirm: 'Your repository has uncommited changes. Merging incoming commits will changeyour current working copy and your current state will not be recoverable. We recommend that you commit first and then pull incoming changes again.' label: 'You might loose your current changes!' trueChoice: 'Proceed anyway' falseChoice: 'Cancel' cancelChoice: nil default: false.  continue ifFalse: [ ^self ].  anError resumeensureDirectory: aFileReference inParentNode: aNode  aNode childAt: aFileReference basename ifPresent: [:node |  self assert: node value isDirectoryDefinition.        ^node ].  ^aNode addChild: (IceDirectoryDefinition named: aFileReference basename)location: aFileReference  location := aFileReference.  self resetHandlefileUtils  ^IceLibgitFiletreeFileUtilsaccept: aVisitor  ^aVisitor visitEmptyNode: selfchangeSelected  | index |  self flag: #todo.  index := changeList widget selectedIndex.  index = 0 ifTrue: [ ^nil ].  ^changeList widget dataSource realElementAt: indextagNameInputText: anObject  tagNameInputText := anObjectsetModelBeforeInitialization: anObject  model := anObjectmergeWithLeftModification: anIceModification  ^IceNonConflictingOperation operation: anIceModificationnewBadgeFont  | baseBadgeFont |  baseBadgeFont := StandardFonts codeFont.  ^(LogicalFont familyName: baseBadgeFont familyName pointSize: baseBadgeFont pointSize - 3) weightValue: 700includes: anIceGitCommit  ^self commitDictionary includesKey: anIceGitCommit idpackage  ^packageexecute  tool viewPullRequest: itemisSameAs: aNode  ^aNode species = self species and: [ self name = aNode name and: [ aNode name notNil ] ]initializeWidgets  commitLabel := self newLabel.  commits := self newIceTable.  diff := self instantiate: IceTipCommitInfoPresenter.  mergeButton := self newButton.  acceptButton := self newButton.  rejectButton := self newButton.  commitLabel label: 'Commits'.  self initializeCommitsTable.  self initializeDiff.  mergeButton label: 'Merge into image'.  acceptButton label: 'Accept pull request'.  rejectButton label: 'Reject pull request'.  self focusOrder     add: commits;     add: diff;     add: mergeButton;     add: acceptButton;     add: rejectButtonsetModelBeforeInitialization: anObject  model := anObjectinitializeCredentialsList  credentialsList widget     beResizable;     addColumn: (IceTipTableColumn new           id: 'Host';           action: #hostDescription;           width: 100 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Type';           action: #type;           width: 75 * World displayScaleFactor;           yourself);     addColumn: (IceTipTableColumn new           id: 'Description';           action: #description;           yourself);     dataSource: self newCredentialsDataSource;     selectRowIndex: 1;     enableFilter: IceTipRepositoryFilter;     explicitFunctiontextField  ^textFieldisFileDefinition  ^trueinitializeWidgets  super initializeWidgets.  pullRequests := self newIceTable.  details := self instantiate: IceGitHubPullRequestDetailModel.  self initializePullRequestsTable.  self focusOrder     add: pullRequests;     add: detailsfromTag: anIceTag  self subclassResponsibilityerrorLabel: anObject  errorLabel := anObjectvisitPackage: anIcePackageDefinition  index addPackage: anIcePackageDefinitionpackage: anObject  package := anObjectmarkAsConflict  self selectedChangeWrapper item value clearSelection.  self changed: #changes.  self updateSourcenewDiffTab  ^self newTab     label: 'Diff';     icon: (self iconNamed: #diff);     closeable: false;     yourselfcommit: aCommitIssue then: aBlock  aCommitIssue     repository: self entity;     onSuccess: aBlock;     executeaddButton  ^addButtonlast: anObject  last := anObject.  (anObject ~= #none and: [ self first = anObject ]) ifTrue: [ self first: #none ]statusBar: anObject  statusBar := anObjectaddItemLeft: aButton  self leftPanel addMorphBack: aButtonusernameInput  ^usernameInputpackage: anObject  package := anObjectvisitShouldCommitBeforePullError: anError  self visitGenericError: anErrordefaultMenuItemName  ^'Reset ' , selectedBranch name , ' to commit ' , selectedCommitish shortIdrepository: anObject  repository := anObjectconfigureBuilder: aBuilder  aBuilder beGithubpath  ^RelativePath newcommit  repository handleLibgitError: [ | gitCommit gitId |        gitId := (self repositoryHandle lookupLocalBranch: self name) targetId.        gitCommit := LGitCommit of: self repositoryHandle fromId: gitId.        ^self repository commitFromGitCommit: gitCommit ]checkoutBranchPanelsOnModel: aModel  ^self plugins inject: #() into: [:all :each |  all , (each checkoutBranchPanelsOnModel: aModel) ]writerClass  ^self repository properties writerClasscommitish: anIceTipCachedModel  commitishToTag := anIceTipCachedModelpackageNames  ^self repository commitsInPackageCache at: self ifAbsentPut: [ self fetchPackageNames ]privateKey  ^privateKeyInput location ifNil: [ '' ] ifNotNil: [:x |  x pathString ]mcCommit  ^MCVersion newversion  ^self itemfileNameForMethod: aMethod  | path |  path := OrderedCollection new.  self repository subdirectory ifNotEmpty: [:subDir |  path add: subDir ].  path     add: (self cypressPackageName: aMethod package);     add: (self cypressClassOrTraitName: aMethod);     add: (self cypressMethodSideName: aMethod);     add: (self cypressMethodName: aMethod).  ^String streamContents: [:stream |  path asStringOn: stream delimiter: '/' ]mergeStateWith: aMergeableState  ^aMergeableState mergeWithInMergeWorkingCopyState: selfinitialize  super initialize.  first := #modified.  last := #notLoadedbasicExecute  self fetchAllRemotes.  (IceTipCheckoutBranchDialog on: self repositoryModel)     withOnlyNewBranch;     openDialogWithSpecrepository: anObject  repository := anObjectloadPackageNamed: aString  self repository workingCopy loadPackageNamed: aString fromCommit: selfcontents  ^item children collect: [:each |  IceMergeListWrapper with: each model: model ]emailLabel  ^emailLabelprojectName  ^builder locationToUse basenameexecute  self withErrorHandlingDo: [ self validateRemotesPresent.        (IceTipPushBrowser onRepositoryModel: self repositoryModel) openWithSpec ]execute  IceTipAddPlaintextCredentialsModel new     credentialStore: store;     tool: tool;     openNonModalcontextSelection  ^nilisBinary  [ contents utf8Decoded ] on: ZnInvalidUTF8 do: [ ^true ].  ^falseicon  ^self iconNamed: #dirtyMonticelloPackageinitializeWidgets  iconPanel := self newIcePanel.  iconPanel widget addMorph: (self iconNamed: #question) asMorph.  confirmLabel := self newIceReadOnlyText.  confirmLabel widget contentsWrapped: (self class confirmMessage format: {self repository name .               self branchName}).  mergeWithMasterCheckbox := self newCheckBox     label: ('Merge with branch {1}' format: {self repository branchName});     state: true.  self focusOrder add: mergeWithMasterCheckboxdefinitionFor: aMethod path: aPath commit: aCommit  ^((IceLibgitFiletreeLogReader fileName: aPath on: aCommit)     package: aMethod package mcPackage;     packageDirectory: (self repository directoryPathStringForPackage: aMethod package);     definitions) detect: [:each |  each isMethodDefinition and: [ each selector = aMethod selector ] ] ifNone: [ MCMethodDefinition className: aMethod origin name selector: aMethod selector category: #'' timeStamp: nil source: '' ]removeDirectory  | toRemove |  toRemove := selectedDirectoryPath asResolvedBy: self model fileSystem.  toRemove exists ifTrue: [ (UIManager default questionWithoutCancel: ('Are you sure to delete ''{1}''?' format: {toRemove basename}) title: 'Remove directory') ifFalse: [ ^self ].        toRemove ensureDelete ].  sourceDirectoryTree widget dataSource updateData.  sourceDirectoryTree widget dataSource expandAll.  sourceDirectoryTree widget selectIndex: (sourceDirectoryTree widget dataSource indexOfElement: toRemove parent)readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  package := self packageModel entitygetBranches: owner project: projectName  ^self get: 'repos/' , owner , '/' , projectName , '/branches'addRemote  (IceTipAddRemoteDialog on: self model repositoryModel)     onAccept: [:newRemoteName |  self model reset.        self refresh.        self selectRemoteNamed: newRemoteName ];     openDialogWithSpecentry  ^entrypushTag: tag toRemote: aRemote gitRemote: gitRemote progress: pushProgress  gitRemote pushWithRefSpec: (LGitRefSpec new           source: 'refs/tags/' , tag name;           destination: 'refs/tags/' , tag name;           yourself) pushOptions: (LGitPushOptions defaults           callbacks: ((LGitRemoteCallbacks withProvider: (IceCredentialsProvider defaultForRemote: aRemote))                 pushTransferProgress: pushProgress;                 yourself);           yourself)newDataSourceMatching: aFilter  ^aFilter executeOn: selfmodifyingPackage: anObject  modifyingPackage := anObjectaddChild: anObject  children ifNil: [ children := OrderedCollection new ].  children add: anObject.  anObject parent: self.  ^anObjectpath  ^self parent ifNotNil: [:p |  p path , {self} ] ifNil: [ {self} ]model  ^modeltypeLabel  ^typeLabelreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  (self repositoryModel isNotNil and: [ self repositoryModel isMissing not ]) ifTrue: [ self badge: self repositoryModel numberOfOutgoingCommits ]baseSHA  ^(self jsonAt: #base) at: #shabasicSetProject: aProject  project := aProjectbranchNameMorph  ^('{1} at ' format: {model branchName}) asMorphadditionHighlightColor  ^super removalHighlightColordefaultMessageText  ^'There was an authentication error while trying to execute the operation: {1}. This happens usually because you didn''t provide a valid set of credentials. You may fix this problem in different ways: 1. adding your keys to ssh-agent, executing ssh-add ~/.ssh/id_rsa in your command line.2. adding your keys in settings (open settings browser search for "Use custom SSH keys" andadd your public and private keys).3. using HTTPS instead SSH (Just use an url in the form HTTPS://etc.git)'name  ^name , (isMeta ifTrue: [ ' class' ] ifFalse: [ '' ])messageLabel: anObject  messageLabel := anObjecthasParent  ^self gitRepositoryInfo includesKey: #parentmoveToRemote: aRemoteModel  aRemoteModel ifNil: [ ^self ].  self model useRemote: aRemoteModel.  self model reset.  self refreshCommits.  self updateTitlehasNext  ^result isNil or: [ self parseMorePages: (result headers at: 'Link' ifAbsent: [ nil ]) ]compatibleUsername  ^'CompatibleUserName'commitishNamed: aName  ^self subclassResponsibilityhash  ^self name hashdataSource: aDataSource  dataSource := aDataSourceallBranches  self subclassResponsibilitytool: anObject  tool := anObjecttitle  ^'Push {1}/{2} to {3}' format: {self model repositoryName .         self model branchName .         self model remoteName}diffToFirstAncestor  | diff ancestorCommit |  ancestorCommit := self entity ancestors ifNotEmpty: #first ifEmpty: [ IceNoCommit new ].  diff := self calculateDiff: [ self entity diffTo: ancestorCommit ].  ^IceTipCommitDiffModel repositoryModel: self repositoryModel on: diffcanReadProjectFromCommitish: aCommitish  ^aCommitish isWorkingCopy not and: [ (aCommitish fileSystem / '.project') exists not ]refreshRepositoryProperties  properties := self referenceCommit properties asBornPropertiesaddDirectoryButton  ^addDirectoryButtonvalidateRemotesPresent  self repositoryModel hasRemotes ifFalse: [ IceNoRemote signal ]contentsString  ^ByteArray streamContents: [:stream |  (STONWriter on: (ZnCharacterWriteStream on: stream))           prettyPrint: true;           newLine: OSPlatform current lineEnding;           nextPut: self properties ]visitAddition: anIceAddition  anIceAddition definition accept: selfnewActionButton  ^self subclassResponsibilitycommitsPanel: anObject  commitsPanel := anObjectisUnborn  ^truewriteVersion: aVersion  (self repositoryDirectory / aVersion package name) ensureDeleteAll.  self writeSnapshot: aVersion snapshotrightOperation: anOperation  rightOperation := anOperationdescription  ^'Fetch required. ' , self referenceCommit descriptionwithoutNewRepository  types := self allTypes reject: #isNewRepository.  typeList widget dataSource elements: types.  typeList widget refreshsourceDirectorySelectionChanged: selectedIndexes  | selectedDirectory selection |  selectedIndexes ifEmpty: [ selectedDirectoryPath := RelativePath new.        self sourceDirectoryTree widget selectRowIndex: 1.        selection := self sourceDirectoryTree widget dataSource rootItem children first.        selectedDirectory := self sourceDirectoryTree widget dataSource rootItem children first data ] ifNotEmpty: [ [ selection := self sourceDirectoryTree widget dataSource elementAt: selectedIndexes first ] on: SubscriptOutOfBounds do: [ ^self ] ].  selectedDirectory := selection data.  selectedDirectoryPath := selectedDirectory relativeTo: self model fileSystem.  formatList setSelectedItem: (self guessFormatFromDirectory: selectedDirectory).  self updateRemoveAndAddButtonid  ^self commit idprojectNameLabel  ^projectNameLabelrepository: anObject  repository := anObjectinitializeWidgets  super initializeWidgets.  self initializeRemoteURL.  self remoteInputText ghostText: 'e.g., ssh://[user@]host.xz[:port]/path/to/repo.git'.  self remoteInputText whenTextChanged: [:text |  self projectLocation appendPath: (self extractProjectName: text) ].  self focusOrder add: self remoteInputTextnewLayout  ^SpecLayout composed newColumn: [:column |   ]source  ^String streamContents: [:stream |  stream << '"protocol: ' << self definition category           << '"';           cr;           << self definition sourceCode ]leftContents  ^definition contentscanRevertChanges  ^truemcRepositoryClass  ^MCGitBasedNetworkRepository allSubclasses detect: [:e |  e basicDescription = self class type ]select: aBlock  | selectedChildren newNode |  selectedChildren := self children collect: [:childNode |  childNode select: aBlock ].  ((selectedChildren anySatisfy: [:each |  each isEmptyNode not ]) or: [ aBlock value: self value ]) ifFalse: [ ^IceEmptyNode new ].  newNode := self class value: self value.  selectedChildren do: [:e |  e addTo: newNode ].  ^newNodecredentials  ^credentialsreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  tool := aToolContext tooltextField: aTextPresenter  textField := aTextPresenter.  textField whenTextChanged: [:ann |  self textUpdated: ann ]subdirectoryInputText  ^subdirectoryInputTextmodel: anObject  model := anObjectaccept  IceTipStandardAction new     repository: self repository;     message: ('Migrating {1} sources to tonel' format: {self repository name});     onSuccessRepositoryModified;     onSuccess: [ UIManager default inform: 'Sources migrated!' ];     execute: [ self doAccept ]leftContents  self subclassResponsibilityedit  < noCache>  (IceTipEditProjectDialog on: self entity project) openDialogWithSpecauthorText  ^authorTexthasBranches  ^self branches isNotEmptyemailInput: anObject  emailInput := anObjectfromLGitId: lGitId  self revwalk pushCommit: lGitIdrepository  ^repositorymessageText: anObject  messageText := anObjectproperties  ^propertiesbasicPushTo: aRemote  | gitRemote |  gitRemote := (LGitRemote of: self repositoryHandle named: aRemote name) lookup.  [ | pushProgress |  pushProgress := IcePushTransferProgress new.  self pushBranchToRemote: aRemote gitRemote: gitRemote progress: pushProgress.  self pushTagsToRemote: aRemote gitRemote: gitRemote progress: pushProgress.  self setUpstreamIfMissing: aRemote ] on: LGit_GIT_ENONFASTFORWARD do: [:e |  e resignalAs: (IceRemoteDesynchronized new                 remote: aRemote;                 yourself) ]sourceVersion  ^mergeCommitpath  ^Path from: filePathStringnewContextWithSelection: anObject  ^self newContext     packageModel: anObject;     yourselfbrowseRepositoryVersion  < noCache>  | snapshot |  snapshot := self entity mcSnapshotInRepository.  (MCSnapshotBrowser forSnapshot: snapshot) showLabelled: 'Snapshot for ' , self entity namebranchName  ^self repositoryModel branchNamefromBranch: branch  [ self revwalk pushReference: (lgitRepository lookupBranch: (branch isRemote ifTrue: [ branch fullname ] ifFalse: [ branch shortname ]) remote: branch isRemote) ] on: LGit_GIT_EINVALIDSPEC do: [ self fromLGitId: (lgitRepository revparse: branch name) id ]do: aBlockClosure  aBlockClosure value: self value.  self childrenDo: [:node |  node do: aBlockClosure ]isRemote  ^falsecommitsDo: aBlockClosure  self newCommitWalk commitsDo: aBlockClosurematches: aString  ^self entity name matchesRegexIgnoringCase: aStringowner  ^nilstoreSshCredential: credential forHostname: aHostname  sshCredentials at: aHostname put: credentialisLoadedPackageNamed: aString  ^RPackageOrganizer default includesPackageNamed: aStringdefinition: aRingDefinition  definition := aRingDefinitioninfo: anObject  info := anObjecthash  ^self class hashnormalBorderStyle  ^BorderStyle simple     width: 0;     baseColor: Color transparenticon  ^self class iconmergeWith: anotherTree onLeft: leftBlock onRight: rightBlock onMerge: mergeBlock  | mergedTree newNode |  mergedTree := mergeBlock value: self value value: anotherTree value.  newNode := self class value: mergedTree.  self keysDo: [:key |  (anotherTree includesKey: key) ifTrue: [ | childNode |              childNode := self / key mergeWith: anotherTree / key onLeft: leftBlock onRight: rightBlock onMerge: mergeBlock.              childNode addTo: newNode ] ifFalse: [ newNode addNode: (self / key collect: leftBlock) ] ].  anotherTree keysDo: [:key |  (self includesKey: key) ifFalse: [ newNode addNode: (anotherTree / key collect: rightBlock) ] ].  ^newNodelookupSnapshot  ^commit snapshotForPackage: self packagecontents: anObject  self basicAt: 1 put: anObjectitems: aDictionary  items removeAll.  items addAll: aDictionary.  self refreshinitialExtent  ^(500 @ (self class inputTextHeight * 2 + self class buttonHeight + 50)) scaledByDisplayScaleFactornodesDo: aBlockClosure  childrenDictionary valuesDo: aBlockClosureisLeftChosen  ^chosen = operationinitializeWidgets  self initializeWidgetsContents.  self initializeFocusOrderisCloneOfUrl: aString  ^self origin url = aStringinitializeFocusOrder  self focusOrder add: self tagNameInputTextfileReference: aFileReference  fileReference := aFileReferencecontents  ^'"' , self protocol , '"' , sourceCodeupdateDiskWorkingCopy: anIceDiff  anIceDiff tree accept: (IceGitWorkingCopyUpdateVisitor new           repository: repository;           index: self;           diff: anIceDiff)loadPackagesNamed: aCollection  self loadPackagesNamed: aCollection fromCommit: self repository head committagName  ^self tagNameInputText text asString trimBothputFocusOrder  self focusOrder     add: usernameInput;     add: publicKeyInput locationInput;     add: privateKeyInput locationInput;     add: passphraseInput;     add: storeCheckboxvalidateCanPull  self isModified ifTrue: [ IceShouldCommitBeforePull signal ]all  | stream |  stream := Array new writeStream.  [ self hasNext ] whileTrue: [ stream << self next ].  ^stream contentsdefaultAction  | window mergeMorph |  mergeMorph := IceTipMergeMorph forMerger: merge.  mergeMorph     fromDescription: merge sourceDescription;     toDescription: merge targetDescription.  window := mergeMorph newWindow     title: 'Merge';     yourself.  UIManager default openModal: window.  ^mergeMorph mergedcommit: anIceCommit  self subclassResponsibilitytool: aBrowser  tool := aBrowserexecute  self flag: #pharo8.  self class environment at: #ManifestNativeBrowser ifPresent: [:class |  location openInNativeBrowser ] ifAbsent: [ self inform: 'This action needs the Native-Browser project loaded in the image to work.' ]emailInput  ^emailInputchooseButton  ^chooseButtoninitialize  super initialize.  ensureProjectFile := falserepository  ^index repositorykey  ^leftOperation keyrepositoryName  ^self repositoryModel nameinitialExtent  ^(1000 @ 700) scaledByDisplayScaleFactorupdateSource  | sel |  sel := self selectedChange.  self diffMorph allowJoinClicks: false.  sel isNil ifTrue: [ self diffMorph from: '' to: '' ] ifFalse: [ self diffMorph from: sel rightContents asText to: sel leftContents asText contextClass: sel contextClass ].  (sel isNil or: [ sel isConflict not ]) ifTrue: [ ^self ].  sel isLeftChosen ifTrue: [ self diffMorph indicateDst ] ifFalse: [ self diffMorph indicateSrc ]defaultColor  ^self theme backgroundColor negated alpha: 0.05fileSystem  ^self commit fileSystemmergeWithOperation: anOperation  ^anOperation mergeWithLeftModification: selfhostInput  ^hostInputaccept: aVisitor  ^aVisitor visitRemoval: selfinitializeWidgets  super initializeWidgets.  passwordInput encrypted: falsereadContextParametersFromModel: aModel  super readContextParametersFromModel: aModel.  selectedBranch := aModelinitialize  super initialize.  self bindKeyCombination: PharoShortcuts current copySelectionShortcut toAction: [:target |  target editor copySelection ].  self bindKeyCombination: PharoShortcuts current selectAllShortcut toAction: [:target |  target handleEdit: [ target selectAll ] ]visitDirectoryDefinition: anIceDirectoryDefinition  self visitChildrenOf: currentNodeaddToPatcher: aMCPatcher  (self isMeta and: [ mcDefinition isNil ]) ifTrue: [ ^self ].  aMCPatcher addDefinition: self asMCDefinitionensureDirectoryAtPath: aPathSegments inNode: aNode  | firstChild |  aPathSegments ifEmpty: [ ^aNode ].  firstChild := self ensureDirectoryNamed: aPathSegments first inNode: aNode.  ^self ensureDirectoryAtPath: aPathSegments allButFirst inNode: firstChildcommitsDo: aBlockClosure  self newCommitWalk commitsDo: aBlockClosurepackageList: anObject  packageList := anObjectaddItem: anObject into: aToolbar  aToolbar addItemLeft: anObjectmodel: anObject  model := anObjectrepository  ^repositoryisConflict  ^falsediscardChanges  self discardChanges: self diffToReferenceCommit treecontextClass  ^operation contextClassnewSelectionMorphFor: item  ^CheckboxButtonMorph new     selected: (self isSelected: item data);     target: [ self toggleSelectionOf: item ];     actionSelector: #value;     yourselffirstNodeSuchThat: conditionBlock ifNone: noneBlock  (conditionBlock value: self) ifTrue: [ ^self ].  ^noneBlock valuerevparse: aName  self handleLibgitError: [ | gitCommit gitId |        gitId := (self repositoryHandle revparse: aName) object id.        gitCommit := LGitCommit of: self repositoryHandle fromId: gitId.        ^self commitFromGitCommit: gitCommit ]children  ^#()sourceVersion: aCommitish  source := aCommitishinitialize  tries := 0checksTable  ^checksTableoldDefinition  ^oldNodedeleteBranch: owner project: projectName name: branchName  ^self delete: 'repos/' , owner , '/' , projectName , '/git/refs/heads/' , branchNamepatch: aString with: aBlock  ^self jsonContentsWithValidationDo: [ (self newRequestTo: aString)           in: aBlock;           patch;           response ]< aMagnitude  | version |  version := aMagnitude iceSemanticVersion.  ^self asInteger < version asIntegerremoveFrom: aPatcher  self subclassResponsibilityhistory: anObject  history := anObjectcolorError  ^Smalltalk ui theme dangerTextColorinitialExtent  ^(700 @ 500) scaledByDisplayScaleFactorsnapshotForPackage: anIceSavedPackage  ^[ (self mcVersionFor: (self versionFor: anIceSavedPackage)) snapshot ] on: IceVersionDoesNotExist do: [ MCSnapshot empty ]labelWidth: aNumber  ^labelWidth := aNumberhasIncomingCommitsFrom: aRemote  aRemote fetch.  ^aRemote hasRemoteBranchNamed: self namestoreCredentials  ^storeCheckbox stateisCommitMerged: aCommit  self subclassResponsibilityputFocusOrder  self focusOrder     add: hostInput;     add: usernameInput;     add: passwordInput;     add: storeCheckboxexecuteOn: aDataSource  self dataSource: aDataSource.  ^self executeconfirmLabel  ^confirmLabelnext  nextPage ifNil: [ nextPage := 1 ].  [ result := self api getRaw: (self request asUrl ? (#page -> nextPage asString)) asString ] ensure: [ nextPage := nextPage + 1 ].  ^STON fromString: result contentsobtainSshCredentials: credentialsToReturn  | returnedCred |  returnedCred := IceTipAskSSHCredentialsModel new     credentials: self sshCredentials;     credentialStore: self credentialStore;     open.  credentialsToReturn readFrom: returnedCredcanActivateCommand: aCommandClass  ^aCommandClass actsOnBranch: selfmodifiedPackages  ^self workingCopy modifiedPackagessnapshotFor: package  ^[ (self repository mcVersionFor: (self versionFor: package)) snapshot ] on: IceVersionDoesNotExist do: [:e |  MCSnapshot empty ]mergeCommit: aCommit  mergeCommit := aCommitoptionA: anObject  optionA := anObjectinitializeSidebarTree  sidebarTree widget dataSource: self newSidebarTreeDataSource.  self selectCurrentBranchcontents  self subclassResponsibilityfileSystem  ^self commit fileSystemrepositoryModel: aRepositoryModel  repositoryModel := aRepositoryModelselectedProtocol  ^self protocolDropList selectedItembuildWidget  ^SwappedColorDiffMorph new     on: self;     from: self leftText to: self rightText contextClass: self contextClass;     hResizing: #spaceFill;     vResizing: #spaceFill;     setBalloonText: self help;     showOptions: self showOptions;     showOnlyDestination: self showOnlyDestination;     yourselfincludesPackageNamed: aString  ^self isEmpty not and: [ self codeSubdirectoryNode includesKey: aString ]beSwitchAndMerge  self allTypes do: #beSwitchAndMergeinitializeWidgets  super initializeWidgets.  diffPanel leftLabel: 'Working Copy'.  diffPanel rightLabel: 'Checkout ' , model targetName.  checkoutStrategyLabel := self newLabel label: 'How to checkout:'.  checkoutStrategyList := self newDropList.  self initializeCheckoutStrategyList.  self focusOrder     removeAll;     add: self actionPanel;     add: self checkoutStrategyList;     add: self diffPanelcheckoutWithStrategy: aCheckoutStrategy  self repository localBranches detect: [:each |  each name = self shortName ] ifFound: [:each |  ^each checkout ].  self repository createBranch: self shortName inCommit: self commit.  ^super checkoutWithStrategy: aCheckoutStrategytitle  ^'Edit credential for ' , credential host= aBranch  ^aBranch isRemote and: [ self name = aBranch name ]matches: aRepositoryModel  ^aRepositoryModel name asLowercase includesSubstring: self pattern asLowercaseacceptError: aVisitor  aVisitor visitAuthenticationError: selfaccept: aVisitor  ^tree accept: aVisitordiff  ^diff ifNil: [ diff := self newDiff ]nameInput: anObject  nameInput := anObjectuserName  ^self userNameInputText text asString trimmedauthor  ^self commit authorvalidate  self assert: self location notNil description: 'Project location must exist!'.  self assert: self location exists description: 'Project location must exist!'.  self assert: (IceRepositoryCreator isGitRoot: self location) description: 'Project location does not seems to be a valid git repository.'contextClass  ^IceTipContextmergeWithLeftRemoval: anIceRemoval  ^IceConflictingOperation left: anIceRemoval right: selfownerName  ^classNameisDetached  ^truemergeWithLeftAddition: anIceAddition  self subclassResponsibilitydelete  self subclassResponsibilityisDetached  ^self referenceCommits first ~= self repository headCommitcopyCommitIDToClipboard  < noCache>  self copyToClipboardId: self commitIddiffPanel: anObject  diffPanel := anObjectuser  ^userbasicExecute  self repositoryModel edittimeStamp  self subclassResponsibilitycreateBranch: branchName  | newBranch |  self handleLibgitError: [ [ self repositoryHandle isUnborn ifTrue: [ self location / '.git' / 'HEAD'                 ensureDelete;                 writeStreamDo: [:stream |  stream                       nextPutAll: 'ref: refs/heads/';                       nextPutAll: branchName ] ] ifFalse: [ newBranch := self repositoryHandle createBranch: branchName target: self repositoryHandle head.              self repositoryHandle setHead: newBranch ] ] on: LGit_GIT_EEXISTS do: [:error |  IceBranchAlreadyExists new                 branchName: branchName;                 signal ].        ^self head ]credentialStore: aStore  credentialStore := aStoredefaultHelp  ^self class defaultHelpstoreInto: aCredentialStore forHostname: aHost  host := aHost.  aCredentialStore storePlaintextCredential: self forHostname: aHostdisplayMode  ^displayMode ifNil: [ displayMode := IceTipToolbarDisplayMode default ]readProjectFromCommitish: aCommitish  ^IceInvalidProject onCommitish: aCommitishiconPanel: anObject  iconPanel := anObjectchooseLocal  ^item value selectRightdiffToHead  | head diff |  head := self repositoryModel entity headCommit.  diff := self calculateDiff: [ self entity diffTo: head ].  ^IceTipCommitDiffModel repositoryModel: self repositoryModel on: difftypeList  ^typeListcheckout  self checkout: (IceCheckoutAlreadyLoadedPackages new           committish: self;           yourself)executeCheckoutActionAndThen: aBlock  < noCache>  IceTipStandardAction new     repository: self repository;     message: ('Checking out {1} from {2}' format: {self targetName .               self repositoryName});     onSuccessRepositoryModified;     onSuccess: aBlock;     execute: [ self checkout ]sortByName: aCollection  ^aCollection sorted: #packageName ascendingisMerged  ^history headHistory includes: iceCommitbeAnonymous  isAnonymous := truelocked  ^falsestoreVersion: aMCVersion  repository internalStoreVersion: aMCVersionresolve: aRelativePath ifPresent: presentBlock ifAbsent: absentBlock  ^absentBlock valueallBaselines  ^(self workingCopy packages select: [:each |  each name beginsWith: self class baselinePrefix ]) sorted: [:a :b |  a name < b name ]remoteBranchNamed: aString ifPresent: aBlockClosure  ^self branchNamed: aString ifPresent: aBlockClosure ifAbsent: [ self ]updateRemoveAndAddButton  addDirectoryButton enabled: selectedDirectoryPath isNotNil.  removeDirectoryButton enabled: selectedDirectoryPath isWorkingDirectory notorganizer  ^self ownerinternalStoreVersion: aMCVersion  self subclassResponsibilityrootForItems: aCollection  self rootItem: (FTRootItem new           data: aCollection;           yourself)newCommitWalk  self subclassResponsibilitydiff  ^self subclassResponsibilityremoveClassNamed: aString  (Smalltalk globals at: aString ifAbsent: [ ^self ]) removeFromSystemonAccept: aBlock  acceptBlock := aBlockisDirectoryDefinition  ^falserequest  ^requestdirectory  ^self backend codeDirectoryresolveConflicts  self hasConflicts ifTrue: [ | resolved |        resolved := IceMergeResolutionRequest new           merger: self;           signal: 'Merging ' , mergeCommit description , ' into ' , self leftCommit description.        resolved ifFalse: [ IceMergeAborted signal ] ]updateOn: aCommitModel  self updateLabelOn: aCommitModel.  self updateContentsOn: aCommitModelname  ^namesetMergeStateBetweenCommits: aCollection  self referenceCommit: aCollectionshortId  ^self entity shortIditem: anObject  item := anObjectvalidateIsBranch  newIndex  ^IceGitIndex on: selfchanges  ^changes ifNil: [ changes := OrderedCollection new ]cancelAction  icon  self isRightChosen ifTrue: [ ^self iconNamed: #changeBlock ].  self isLeftChosen ifTrue: [ ^self iconNamed: #forward ].  ^self operationIconisUnbornBranch  ^truetitlePanel: anObject  titlePanel := anObjectaddComment: messageString  IceGitHubAPI new addComment: self owner project: self projectName number: self number data: {(#body -> messageString)} asDictionaryheadLabel  ^(self jsonAt: #head) at: #labelcommit  ^commitselectLabel: aString  self selectButton label: aStringisRightChosen  self subclassResponsibilityisEmpty  self subclassResponsibilityinitialize  super initialize.  isDirty := falselabel  ^label ifNil: [ self class defaultLabel ]storeCredential: credential forHostname: aHostname  self loadFromStore.  credential storeInto: self forHostname: aHostname.  self saveIntoStorechangesFromNoCommit: anIceNoCommit  ^#()isHead  ^commitish = repository headtimeStamp  ^self entity timeStamploadAncestorsAndStepChildren  self shouldBeImplementedlocation  ^locationbasicContents  ^contentsisRepositoryMissing  ^self repositoryModel isMissing or: [ self repositoryModel isCodeMissing ]mergeWithLeftModification: anIceModification  ^self subclassResponsibilitypreferredColor  ^nildiffFor: aCommitModel  ^aCommitModel diffFromHeadonChoose: aBlockClosure  chooseBlock := aBlockClosureinitializePresenter  super initializePresenter.  self typeList     items: self class availableTypes;     displayBlock: [:each |  each ];     setSelectedItem: self class defaultTypeicon  ^icontoFileName: aMethod  ^self subclassResponsibilityremoteBranchNamed: aString ifPresent: presentBlock ifAbsent: absentBlock  self handleLibgitError: [ | branchRef |        branchRef := self repositoryHandle lookupRemoteBranch: aString ifAbsent: [ ^absentBlock value ].        presentBlock value: (self basicNewRemoteBranchNamed: branchRef name) ]model  ^modelinitialExtent  ^(500 @ (self class inputTextHeight * 2 + self class buttonHeight + 50)) scaledByDisplayScaleFactorisUnborn  ^truerefreshToolbar  toolbar refreshaccept: aVisitor  ^aVisitor visitModification: selfputFocusOrder  self focusOrder     add: hostInput;     add: usernameInput;     add: publicKeyInput locationInput;     add: privateKeyInput locationInput;     add: passphraseInput;     add: storeCheckboxprotocolDropList  ^protocolDropListpanel: anObject  panel := anObjectbranchModel: anObject  branchModel := anObjectgtInspectorItemsIn: composite  < gtInspectorPresentationOrder: 0>  ^composite fastTable     title: 'Items';     display: [ self children ];     column: 'Key' evaluated: [:each |  each key ] width: 200 * World displayScaleFactor;     column: 'Value' evaluated: [:each |  each value ] width: 400 * World displayScaleFactorprintOn: stream  stream << (self name ifNil: [ 'noname' ]) << ' (' << self url << ')'versionsFor: package  self modifyingPackage: package.  ^self commits collect: [:commit |  commit versionFor: package ]urlLabel: anObject  urlLabel := anObjectnewContextWithSelection: anObject  ^self newContext     repositoryModel: anObject;     yourselfallTypes  ^types ifNil: [ types := self createCheckoutBranchTypes ]visitChildrenOf: anIceNode  anIceNode childrenDo: [:each |  each accept: self ]location: anObject  location := anObjectbranchNamePrefix  ^'refs/heads/'protocol: aProtocol  protocol := aProtocolsetModelBeforeInitialization: anObject  model := anObjectnameInput  ^nameInputvalidateCanCommit  order  ^SmallInteger maxVal - 1500versionName  ^'{1}-{2}.{3}' format: {self packageNameFromPackageDirectory .         self commit compatibleUsername .         self versionNumber}packages  ^#()selectedPackage  | index |  self flag: #todo.  index := packagesList widget selectedRowIndex.  index = 0 ifTrue: [ ^nil ].  ^packagesList widget dataSource elementAt: indexmarkAllAsConflict  self model mergeTree do: [:c |  c isConflict ifTrue: [ c clearSelection ] ].  self changed: #changes.  self updateSourcelocation  ^locationexecute  self installBaseline: self packageincludesKey: aString  ^falsecommitTabPanel: anObject  commitTabPanel := anObjectrightContents  ^oldNode contentsremoteBranchNamed: aString ifPresent: presentBlock ifAbsent: absentBlock  localRepository handleLibgitError: [ | found |        found := self repositoryHandle lookupRemoteBranch: self name , '/' , aString ifAbsent: [ nil ].        ^found ifNil: absentBlock ifNotNil: [ ^presentBlock value: (localRepository basicNewRemoteBranchNamed: found name) ] ]initialExtent  ^self class defaultExtentkey  ^super key , (self isMeta ifTrue: [ ' class' ] ifFalse: [ '' ])hash  ^self key hashshouldIgnoreNotifications  ^shouldIgnoreNotifications = trueaccept: aVisitor  ^aVisitor visitImageChange: selfcheckMissing  self isMissing ifTrue: [ IceError signal: ('You have no repository atttached to project "{1}"' format: {self name}) ]uptadeSelectedPullRequest: anEvent  self details pullRequest: (anEvent newSelectedRowIndexes ifNotEmpty: [:indexes |  self pullRequests widget dataSource elementAt: indexes first ] ifEmpty: [ IceGitHubNilPullRequest new ])project  self subclassResponsibilitycanRevertChanges  ^falseversion: aVersion  version := aVersioninitialize  selectedItems := Set new.  super initializeokAction  | cred |  cred := self credentials.  self storeCredentials ifTrue: [ credentialStore storeCredential: cred forHostname: remoteHostname ].  accepted := true.  ^credicon  ^iconBlockchoose  self chooseReference ifNotNil: [:reference |  self location: reference.        self onChoose ifNotNil: #value ]plugins  ^pluginsreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  branchModel := aToolContext itemexecute  | result |  result := UIManager default request: 'Groups to install (a comma separated string)' initialAnswer: '' title: 'Enter groups to install'.  result ifNil: [ ^self ].  self installBaseline: self package groups: ((result substrings: ',') collect: #trimmed as: Array)contentPanel: anObject  contentPanel := anObjectmcRepository  | baseRepo |  self guessRegisteredRepository ifNotNil: [:repo |  repo isValid ifTrue: [ ^repo metacelloAdapter: self projectVersion ].        repo forget ].  baseRepo := self mcRepositoryClass location: self location.  ^(Iceberg icebergRepositoriesURLs includes: baseRepo scpUrl) ifTrue: [ baseRepo ] ifFalse: [ baseRepo getOrCreateIcebergRepository metacelloAdapter: self projectVersion ]rightContents  ^definition contentsexecute  (IceTipAddPackagesDialog on: self repositoryModel) openDialogWithSpecdetect: aBlock  ^(self firstNodeSuchThat: aBlock) valueexecute  remoteModel fetchtitle  ^'Select branch to merge into ' , self model branchNamenewContextWithSelection: anObject  ^self newContext     item: anObject;     yourselfmatches: treeModel  ^treeModel model name asLowercase includesSubstring: self patternaccept  acceptBlock ifNotNil: [ acceptBlock cull: self ].  self window deleteitem  ^itemwithResultDo: aBlockClosure  callback := aBlockClosurerejectButton: anObject  rejectButton := anObjectinitializeWidgets  iconPanel := self newIcePanel.  iconPanel widget addMorph: (self iconNamed: #question) asMorph.  confirmLabel := self newLabel label: (self class confirmMessage format: {self model name}).  removeFileSystemCheckbox := self newCheckBox label: self class removeMessage.  self focusOrder add: self removeFileSystemCheckboxcommitIdFrom: aLGitCommit  ^aLGitCommit id hexStringisMergeWithCurrentBranch  ^mergeWithCurrentBranchleftPanel: anObject  leftPanel := anObjecttextUpdated: anAnnouncement  self filterWith: self textField getText= anotherProject  self species = anotherProject species ifFalse: [ ^false ].  properties = anotherProject properties ifFalse: [ ^false ].  self repository = anotherProject repository ifFalse: [ ^false ].  ^truerepository  ^commitish repositoryModel entityhttpsUrl  ^'https://{1}/{2}.git' format: {self host .         self projectPath}isSingleCommitState  ^truefromLabel: anObject  fromLabel := anObjecttagName: anObject  tagName := anObjectreload  < noCache>  IceTipStandardAction new     repository: self entity repository;     message: ('Reloading package {1}' format: {self entity name});     onSuccessRepositoryModified;     execute: [ Iceberg announcer suspendAllForRepository: self entity repository while: [ self entity reload ] ]addRemote: aRemote  (self hasRemoteNamed: aRemote name) ifTrue: [ IceRemoteAlreadyExistsError new           remoteName: aRemote name;           signal ].  self remoteAt: aRemote name put: aRemote.  aRemote localRepository: selfcreateSourceDirectory  (location / self subdirectory) ensureCreateDirectory.  self properties     fileFormat: self class defaultFileFormat;     storehash  ^properties hashrepository: aRepository  repository := aRepositorysuspendAllMatching: matchBlock while: aBlock  suspendedConditions add: matchBlock.  aBlock ensure: [ suspendedConditions remove: matchBlock ]repositoryModel  ^nilsourceDirectoryTree: anObject  sourceDirectoryTree := anObjectdiffToWorkingCopy  | diff |  diff := self calculateDiff: [ self entity diffToWorkingCopy ].  ^IceTipCommitDiffModel repositoryModel: self repositoryModel on: diffactionPanel  ^actionPanelhost  ^nilremote  ^remoteappendPath: aString  keptLocation ifNil: [ keptLocation := self location ].  self basicLocation: (aString ifNotEmpty: [ (keptLocation ifNil: [ '.' asFileReference ]) / aString ] ifEmpty: [ keptLocation ])name  ^'Commits from {1} to {2}' format: {self fromCommit shortId .         self toCommit shortId}credentials: anObject  credentials := anObjectoptionsList: anObject  optionsList := anObjectmessage  ^messagebaseRemote  ^baseRemoterightContents  ^operation rightContentsjson  ^jsonasBornProperties  ^selfheadModel  | head |  head := self entity head.  ^head isBranch ifTrue: [ self branchModelFor: head ] ifFalse: [ self commitModelFor: head ]isNewRepository  ^falsesourceDirectory  ^''initializeWidgets  super initializeWidgets.  hostLabel := self newLabel label: 'Host: '.  hostInput := self newTextInput     autoAccept: true;     whenTextChanged: [ self updateOkButton ];     yourselflibGitCommitsFrom: aLGitRepository for: aListOfCommitish  ^aListOfCommitish collect: [:commitish |  LGitCommit of: aLGitRepository fromId: (LGitId fromHexString: commitish id) ]contextClass  ^definition contextClassaddToChangeBuilder: anIceChangeImporter  ^selftonelMethodClassOrTraitName: aMethod  ^aMethod origin instanceSide name , (self tonelMethodClassExtension: aMethod) , '.st'title  ^'Edit SSH keys for ' , self credentials hostDescriptionmcVersion  ^commit mcVersionFor: selfupstream  ^self subclassResponsibilityload  < noCache>  IceTipStandardAction new     repository: self entity repository;     message: ('Loading package {1}' format: {self entity name});     onSuccessRepositoryModified;     execute: [ Iceberg announcer suspendAllForRepository: self entity repository while: [ self entity load ] ]packageModel  ^packageModelversion  ^versionremoteAt: aString put: aRemote  self handleLibgitError: [ self repositoryHandle addRemote: aRemote name url: aRemote url ]defaultMenuItemName  ^'Adopt commit ' , selectedCommitish shortId= anotherBranch  ^anotherBranch isUnbornBranchrefresh  self rebuildToolbar.  packageList widget     in: [:this |  this dataSource elements: self model packageModels ];     refresh.  statusBar refreshinitializeWidgets  nameLabel := self newLabel label: 'Project Name'.  nameInput := self newLabel label: self model name.  sourceDirectoryLabel := self newLabel     label: 'Code directory';     yourself.  sourceDirectoryTree := self newIceTreeTable.  formatLabel := self newLabel label: 'Format'.  formatList := self newDropList.  addDirectoryButton := self newButton     label: '';     help: 'Create a new directory under the selected one';     iconName: #add;     enabled: false;     action: [ self addDirectory ];     yourself.  removeDirectoryButton := self newButton     label: '';     help: 'Removes the selected directory';     iconName: #remove;     enabled: false;     action: [ self removeDirectory ];     yourself.  self initializeMessagePanel.  self initializeDirectoryTree.  self focusOrder     add: nameInput;     add: sourceDirectoryTree;     add: formatListupto: aCommitish  self uptoCommit: aCommitish commitcodeDirectory  ^self repository codeDirectoryleftContents  ^definition contentsiceCommitFrom: aGitCommit  ^self commitFromGitCommit: aGitCommitnumber  ^self jsonAt: #numberdefaultPosition  ^self class defaultPositionisGlobal  ^self globalCheckbox statecolumnTitleFor: column  column id = #target_url ifTrue: [ ^'' ].  ^super columnTitleFor: columnconfigureButton: aButton item: aToolbarItem  aButton on: aToolbarItem getState: nil action: #execute label: nil icon: #icon menu: nil.  aButton badgeSelector: #badgeheadLabel  ^'No PR selected'visitCheckoutConflict: anError  self visitGenericError: anErrornameLabel  ^nameLabelisSSHUrl: aString  ^self class isSSHUrl: aStringbePositionLeft  self position: IceTipItemPosition lefttitle  ^'Commit on {1} branch {2}' format: {self model name .         self model branchName}treeToShow  ^self changesToWorkingCopyTreesubdirectoryInputText: anObject  subdirectoryInputText := anObjectdefinition: aDefinition  definition := aDefinitionsidebarTree  ^sidebarTreeselectLeft  self subclassResponsibilityportName  ^self port asStringvalidate  self assert: (issueNumberText text asString notEmpty and: [ issueNumberText text isAllDigits ]) description: 'Please enter a valid issue number'.  self assert: fetched description: 'Please fetch a valid issue number'hasRemotes  ^self entity remotes notEmptylabel  ^labeldiffFor: aCommitModel  ^aCommitModel diffToFirstAncestorheadBranchName: anObject  headBranchName := anObjectfetch  self remotes do: [:each |  each fetch ] displayingProgress: [:each |  'Remote: ' , each name asString ]sidebarTree: anObject  sidebarTree := anObjectincomingCommitsFrom: aRemote  | remoteBranch |  remoteBranch := aRemote remoteBranchNamed: self name ifAbsent: [ ^#() ].  ^remoteBranch newCommitWalk     uptoCommit: self commit;     commitsincludesPackageNamed: aName  ^self packageNames includes: aNameremoveFrom: aPatcher  aPatcher removeMethod: selfcopyCommitIDToClipboard  < noCache>  repositoryModel copyCommitIDToClipboardnewContextWithSelection: anObject  ^self newContext     item: anObject;     yourselficeSemanticVersion  ^selfprintOn: aStream  super printOn: aStream.  aStream     nextPut: $[;     nextPutAll: self name;     nextPut: $]initialExtent  ^(500 @ (self class inputTextHeight * 2 + self class buttonHeight + 50)) scaledByDisplayScaleFactordiffPanel: anObject  diffPanel := anObjectremote  ^remoteeditModelClass  ^IceTipEditPlaintextCredentialsModelopenDialogWithSpec  ^super openDialogWithSpec     okAction: [ self accept ];     yourselfcanActivateCommand: aCommandClass  ^aCommandClass actsOnTag: selfcommit: aCommit  commit := aCommitvisitMethodNode: anIceMethodDefinition  repository workingCopy applyDefinition: anIceMethodDefinition inNode: currentNoderepositoryHandle  < repositoryHandleAccessor>  ^repository repositoryHandleaccept  basicExecute  credentials := IceGitHubAPI ensureCredentials.  UIManager default informUser: ('Retrieving branch information from {1}' format: {self remote url}) during: [ self cacheAllBranches ].  IceGitHubSelectListModel new     setModal: true;     title: ('Select branches to remove on remote {1}' format: {self remote name});     selectLabel: 'Remove branches';     items: self remoteBranches;     displayBlock: [:each |  '{1} ({2})' format: {(each at: 'name') .               (self timeSinceLastCommit: each)} ];     onAccept: [:selection |  self removeBranches: selection ];     openWithSpecloadChangesInWorkingCopy: aTree  | visitor |  visitor := IceWorkingCopyPatcherVisitor on: self repository.  aTree accept: visitor.  self ignoreNotificationsDuring: [ visitor load ]copyToClipboardId: id  Clipboard clipboardText: id informing: ('Commitish ID copied to clipboard ({1})' format: {id})delete  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Removing tag {1}' format: {self name});     onSuccessRepositoryModified;     do: [ self repositoryModel entity removeTag: self entity ]readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  packageModel := aToolContext packageModellocalRepository  ^localRepositoryacceptError: aVisitor  aVisitor visitGenericError: selfwithErrorHandlingDo: aBlock  aBlock on: IceError , IceWarning do: [:e |  e acceptError: (IceTipInteractiveErrorVisitor on: self repository) ]newChecksTable  ^FTTableMorph new     addColumn: ((FTColumn id: #target_url) width: 18 * World displayScaleFactor);     addColumn: ((FTColumn id: #state) width: 65 * World displayScaleFactor);     addColumn: ((FTColumn id: #context) width: 100 * World displayScaleFactor);     addColumn: (FTColumn id: #description);     cellInset: 5 * World displayScaleFactor;     beResizable;     vResizing: #spaceFill;     hResizing: #spaceFill;     asSpecAdaptericon: anObject  icon := anObjectdiffToParent  ^self diffTo: (self ancestors ifNotEmpty: #first ifEmpty: [ nil ])remotePanel: anObject  remotePanel := anObjectrequestRemoteBranches  ^IceGitHubAPI new getBranches: self remote owner project: self remote projectBasenameselectAllChildrenOf: item  (self withAllChildrenOf: item) do: [:each |  selectedItems add: each data ]refreshWhenRepository: ann  (self model repositoryModel isModelOf: ann repository) ifFalse: [ ^self ].  self model reset.  self refreshinitializeBlock  self signature: self class fnSpec block: self blockname  ^packagemergedTree  self shouldBeImplementedkeyPassphrase: anObject  keyPassphrase := anObject.  self storeIfDefaultaddString: string at: fileNameOrPath encodedTo: ignored  | split path fileName |  split := fileNameOrPath lastIndexOf: $/.  path := fileNameOrPath first: split.  fileName := fileNameOrPath copyFrom: split + 1.  (self packageFileDirectory entryByPath: path) addEntryNamed: fileName withContents: stringmergeCommit: mergeCommit  ^IceMerge new     repository: self repository;     mergeCommit: mergeCommit;     executebasicExecute  credentials := IceGitHubAPI ensureCredentials.  remote ifNil: [ remote := self repository branch hasUpstream ifTrue: [ self repository branch upstream remote ] ifFalse: [ self askRemote: self repository ] ].  (self validateMakePullRequestOn: self repository) ifFalse: [ ^#() ].  (IceGitHubCreatePullRequestModel repository: self repository credentials: self credentials headRemote: remote)     setModal: true;     onAccept: [:pullRequest |  [ | pullRequestDatas url |        pullRequestDatas := pullRequest send.        url := pullRequestDatas at: 'html_url'.        UIManager default inform: 'Pull request created. Click to view on Github.' actionOnClick: [ self class environment at: #WebBrowser ifPresent: [:webBrowser |  webBrowser openOn: url ] ifAbsent: [ self inform: ('Cannot open "{1}" because the project WebBrowser is not present by default in Pharo 6.' format: {url}) ] ] ] on: IceGitHubError do: [:e |  self reportError: e ] ];     openWithSpecdefaultMenuItemName  ^'Remove Remote Branches'isAncestorOf: aCommit  ^falsewithTypes: aCollection  types := aCollection.  typeList widget dataSource elements: types.  typeList widget refresh= anotherIceMCVersionInfo  ^super = anotherIceMCVersionInfo and: [ package name = anotherIceMCVersionInfo package name ]categories: aCollection  categories := aCollectionwriterClass  ^self referenceCommit writerClasspath  ^pathcommitLabel  ^commitLabelname  self flag: #pharo6.  ^self realObject namecommitChanges: aDiff withMessage: message force: forcing  | newCommit |  self validateCanCommit.  self repository index     updateDiskWorkingCopy: aDiff;     updateIndex: aDiff.  (forcing not and: [ repository index isEmpty ]) ifTrue: [ IceNothingToCommit signal ].  newCommit := self repository commitIndexWithMessage: message andParents: (self workingCopyState referenceCommits reject: [:each |  each isNoCommit ]).  ^newCommitlabelFor: aCommitModel  ^'{1} to {2}' format: {aCommitModel shortId .         aCommitModel ancestorShortIdOrOrigin}pull  self branch pullcollect: aBlockClosure  ^selfincludesCommit: anIceCommit  ^self referenceCommit = anIceCommitrepository: anIceLibgitRepository  repository := anIceLibgitRepositoryvalidate  self assert: self tagName isNotEmpty description: 'Please enter your new branch name.'.  self assert: (self tagName noneSatisfy: #isSeparator) description: 'You can''t have spaces in your branch name.'openDialogWithSpec  ^super openDialogWithSpec     okAction: [ self accept ];     yourselfwriteVersion: aVersion  | members |  directory := (members := MCFileTreeRepository parseName: aVersion info name) last.  self deleteExistingPackageStructureFor: members.  self fileUtils ensureDirectoryExists: self packageFileDirectory.  self initializePackageFileDirectoryCache.  self writeFormat.  self writePackage: aVersion package.  self writeDefinitions: aVersion.  aVersion dependencies do: [:ea |  self writeVersionDependency: ea ]title  ^self class titleactionWidth  ^actionWidth ifNil: [ self class defaultActionWidth ]createCheckoutBranchTypes  | allTypes |  allTypes := {(IceTipCheckoutNewBranchPanel on: self model) .   ((IceTipCheckoutBranchPanel on: self model)     title: 'Local';     icon: (self iconNamed: #branch);     yourself)} , (self model remoteModels collect: [:each |  (IceTipCheckoutBranchPanel on: each)                 title: each name;                 icon: (self iconNamed: #remote);                 yourself ]) , (self model entity pluginManager checkoutBranchPanelsOnModel: self model).  allTypes do: [:each |  each onAccept: [ self window delete ] ].  ^allTypesremote  ^remoteincludesInWorkingCopyPackageNamed: aString  ^(self packagesDictionary includesKey: aString) and: [ (self packageNamed: aString) isLoaded ]newContextWithSelection: aCommitModel  ^self newContext     item: aCommitModel;     yourselfprojectName  ^self projectNameInputText text asString trimmedwait: time thenDo: aBlock  currentWaitingProcess ifNotNil: [ currentWaitingProcess terminate ].  currentWaitingProcess := [ time wait.  aBlock value ] forkNamed: 'GitHub issue tracker'targetVersion  ^targetbranch  ^self repository branchdataSource: aDataSource  super dataSource: aDataSource.  aDataSource expandRootsisClassDefinition  ^trueisGitRoot: aReference  ^IceRepositoryCreator isGitRoot: aReferencesnapshotFor: anIceSavedPackage  ^MCSnapshot emptyisNewBranch  ^truecomment: aString  comment := aStringrepository  ^repositoryisEmptyNode  ^truenewProjectFromCommit: aCommit  ^IceProjectReader readProjectFrom: selfrepositoryModel  ^repositoryModelhost  ^self hostInput texttags  ^self commit tagsmergeableLabel  ^mergeableLabelisInvalid  ^falserefresh  actionMorphPanel removeAllMorphs.  actions do: [:each |  actionMorphPanel addMorphBack: (each buildWithSpec                 hResizing: #rigid;                 width: self actionWidth;                 yourself) ]contextClass  ^IceTipPullRequestsListContextpullThen: aBlock  IceTipStandardAction new     repository: self entity;     message: ('Pulling from {1}' format: {self remote name});     onSuccessRepositoryModified;     onSuccess: aBlock;     execute: [ self entity pullFrom: self remote ]acceptError: aVisitor  self subclassResponsibilityformat: anObject  formatBlock := anObjectcypressPackageName: aPackage  ^aPackage name , '.package'packageNames  ^self subclassResponsibilitylabel: anObject  label := anObject= anotherOperation  ^super = anotherOperation and: [ self rightDefinition = anotherOperation rightDefinition ]conflictCount  ^(self model ifNil: [ ^0 ]) unresolvedConflictCountselectedItems  ^selectedItemssource  ^self entity sourcebadge  ^badgehost  ^self hostInput texttable: aTable  super table: aTable.  self addBindingsToTableisPackageExported: anIceSavedPackage  | packageLocation |  packageLocation := self packageLocationFor: anIceSavedPackage.  ^packageLocation exists and: [ packageLocation hasChildren ]statusBar  ^statusBarchangesTo: aCommitish  ^aCommitish changesFromCommit: selfbuildUrl  ^protocol composeUrlWithHost: host repositoryPath: patholdNode  ^oldNodeselectLeft  chosen := operationcheckoutStrategies  ^checkoutStrategiesprojectLocation  ^projectLocationadoptCommit: aCommit  | oldCommit |  self referenceCommit = aCommit ifTrue: [ ^self ].  oldCommit := self referenceCommit.  self referenceCommit: aCommit.  (oldCommit isNoCommit not and: [ oldCommit id = aCommit id ]) ifFalse: [ self forceCalculateDirtyPackages ]initialTree  ^initialTreemessage: anObject  message := anObjectrepositoryModel  ^self explicitRequirementbeBitbucket  self host: 'bitbucket.org'visitClassTraitDefinition: aMCClassTraitDefinition  | classTraitDefinitionNode |  classTraitDefinitionNode := self ensureMethodOwnerNamed: aMCClassTraitDefinition className isMeta: true isTrait: true isExtension: false.  classTraitDefinitionNode value mcDefinition: aMCClassTraitDefinition.  ^classTraitDefinitionNodestatus  [ self entity repository isMissing ifTrue: [ ^self toErrorMessage: 'Local repository missing' ].  self entity isLoaded ifFalse: [ ^'Not loaded' ].  self entity isModified ifTrue: [ ^'Uncommited changes' ].  ^'Up to date' ] on: Error do: [:e |  ^self toErrorMessage: e description ]hasAnyNonKeptConflicts  ^self model mergeTree anySatisfy: [:conflict |  conflict isConflict and: [ conflict isResolved not or: [ conflict isRightChosen ] ] ]initializeReasonPanel  reasonPanel widget addMorphBack: (IceTipReadOnlyTextMorph new           hResizing: #spaceFill;           vResizing: #spaceFill;           contentsWrapped: self model longStatus;           yourself)newChangeTreeDataSource  ^IceTipTreeSelectingDataSource new     tool: self;     rootForItems: self model treeRoots;     childrenBlock: [:data |  data children ];     icon: [:each |  each value icon ];     format: #description;     selectAll;     yourselfbuilder  ^builder ifNil: [ builder := LGitTreeBuilder of: self repository fromTree: self initialTree ]currentBranchLabel: anObject  currentBranchLabel := anObjectnewContext  ^(self contextClass for: self)     readContextParametersFromModel: self model;     yourselfcurrentCommitishLabel: anObject  currentCommitishLabel := anObjectissueText: anObject  issueText := anObjectpackagesDictionary  ^packagesdisplayString  ^'{1}: {2}' format: {self name .         self url}isCommitMerged: aCommit  ^self workingCopyState isCommitMerged: aCommitbeGitLab  self host: 'gitlab.com'commit  self shouldBeImplementedtoFileName: aMethod  ^self fileNameForMethod: aMethodguessFormatFromDirectory: aFileReference  | guineaPig |  guineaPig := aFileReference children detect: [:any |  any isDirectory ] ifNone: [ ^defaultFormat ].  ((formats includes: IceLibgitFiletreeWriter) and: [ IceLibgitFiletreeWriter isValidPackage: guineaPig ]) ifTrue: [ ^IceLibgitFiletreeWriter ].  ^formats detect: [:each |  each isValidPackage: guineaPig ] ifNone: [ ^defaultFormat ]nameLabel  ^nameLabelinitializePackagesFromRepository  | commitToAdopt |  commitToAdopt := referenceCommit isNoCommit ifTrue: [ self repository headCommit ] ifFalse: [ referenceCommit ].  self adoptCommit: commitToAdoptancestorIds  ^ancestorIdsrefreshDiffFromAncestorLabel  ancestorTabContainer updateLabelOn: selectedModeladdButton: anObject  addButton := anObjectinitializeWidgets  storeCheckbox := self newCheckBox     label: 'Do you want this credentials to be stored for future use?';     help: 'Please note that storing your credentials is handy but unsafe';     state: true.  self whenWindowChanged: [ self updateOkButton ]changesTo: aCommitish  | removedPackages changes |  changes := Set new.  changes addAll: (aCommitish changesFromCommit: self referenceCommit).  removedPackages := aCommitish packages \ self packages.  changes addAll: (self modifiedPackages , removedPackages collect: [:each |  IceImageChange package: each ]).  self project isDirty ifTrue: [ changes add: IceProjectChange new ].  self repositoryProperties isDirty ifTrue: [ changes add: IceCypressPropertiesChange new ].  ^changescontents: anObject  contents := anObjectshortId  ^iceCommit shortIdbaseBranchNames  ^self baseBranches collect: [:each |  each at: #name ]selectionIsRemoteChosen  self selectedChange ifNil: [ ^false ].  ^self selectedChange isConflict and: [ self selectedChange isRightChosen ]sourceDirectory  ^properties at: 'srcDirectory' ifAbsent: [ 'src' ]nameInput: anObject  nameInput := anObjectinitialize  selectedDirectoryPath := RelativePath new.  formats := TIceRepositoryWriter users sorted: [:a :b |  a description < b description ].  defaultFormat := IceLibgitRepository defaultFileFormat.  super initializewithOthers: aSymbol  self first = aSymbol ifTrue: [ self first: nil ].  self last = aSymbol ifTrue: [ self last: nil ]clearSelection  chosen := nilleftPanel  ^leftPanelisValid  ^truedescription  ^', ' join: (self referenceCommits collect: #description)id  ^self entity idrepository  ^parent ifNotNil: [ self parent repository ] ifNil: [ self initialTree owner ]visitFileNode: anIceFileDefinition  | reference |  reference := repository location resolve: anIceFileDefinition path.  reference parent ensureCreateDirectory.  reference     ensureDelete;     binaryWriteStreamDo: [:writeStream |  writeStream nextPutAll: anIceFileDefinition basicContents ]descriptionWithDecoration  ^self nameheaderColumn: column  column id ifNil: [ ^nil ].  ^SimpleButtonMorph new     layoutPolicy: RowLayout new;     listDirection: #leftToRight;     wrapCentering: #center;     cellInset: 5 @ 0;     layoutInset: 5 @ 0;     label: (self columnTitleFor: column);     target: self;     actionSelector: #actionColumn:;     arguments: {column};     yourselfselectedType  ^typecommitChanges: aDiff withMessage: message  ^self commitChanges: aDiff withMessage: message force: falsepullRequests  ^pullRequests= otherExtension  ^self species = otherExtension species and: [ self name = otherExtension name ]addItemsFromContext: aContext  | menu |  menu := CmdMenu activatedBy: IceTipToolbarActivation.  menu buildInContext: aContext.  menu buildIceToolbarOn: selfremote  | remote |  remote := IceGitRemote name: self author url: (((self jsonAt: #head) at: #repo) at: #ssh_url).  ^self repository remotes detect: [:each |  each = remote ] ifFound: [:each |  each ] ifNone: [ self repository addRemote: remote.        remote ]upstream  ^self upstreamIfNone: [ IceUpstreamNotConfigured signal ]createTag: aString  ^self workingCopy referenceCommit createTag: aStringfetch  < noCache>  IceTipStandardAction new     repository: self repositoryModel entity;     message: ('Fetching remote {1}' format: {self name});     onSuccessRepositoryModified;     do: [ self entity fetch ]repository  ^repositoryModel entityat: aKey put: aValue  self properties at: aKey put: aValuevalidateIsBranch  globalCheckbox  ^globalCheckboxexecute  ^IceGitHubNewPullRequestAction new     repository: self repository;     remote: self remote;     executeunload  repository workingCopy unloadPackage: selfdescription  ^self repository origin url , '[' , projectVersion , ']'description  ^value descriptionuptoBranch: anIceBranch  self uptoCommit: anIceBranch lastCommitnewPanelMorph  ^PanelMorph new     changeTableLayout;     hResizing: #spaceFill;     vResizing: #spaceFill;     yourselfname  ^name ifNil: [ name := self obtainRepositoryName ]mergePullRequestIntoImage  (UIManager default confirm: ('I will create a new local branch named {1}. Should I continue?' format: {self pullRequest branchName})) ifFalse: [ ^self ].  IceGitHubAPI ensureCredentials.  self pullRequest mergeIntoWorkingCopynewStatusBarItemOn: aStatusBar  ^self contents asMorph asReadOnlyMorphdatetime  self subclassResponsibilitystoreCheckbox  ^storeCheckboxaction: aSymbolOrBlock  action := aSymbolOrBlockstore: anObject  store := anObjectisLocalRepository  ^trueprojectName  ^projectNamevisitMissingCredentialsError: anError  ((IceTipGitUsernameAndEmailDialog on: self repository)     onAccept: [ anError resume ];     openDialogWithSpec) modalRelativeTo: WorldloadPackagesNamed: aCollection fromCommit: aCommit  self ignoreNotificationsDuring: [ | loader |        loader := MCVersionLoader new.        aCollection do: [:name |  | package packageVersion |              package := self packageNamed: name.              packageVersion := (IceSavedPackageVersion fromCommit: aCommit package: package) mcVersion.              loader addVersion: packageVersion.              package beClean ].        loader load ]refresh  credentialsList widget     dataSource: self newCredentialsDataSource;     refreshurlLabel  ^urlLabelbasicEqualsTo: aNode  ^self value = aNode valuemarkAsCleanPackagesThat: aBlock  self modifiedPackages do: [:each |  (aBlock value: each) ifTrue: [ each beClean ] ]basicExecute  self fetchAllRemotes.  (IceTipCheckoutBranchDialog on: self repositoryModel)     withoutNewBranch;     openDialogWithSpecnewCommitWalk  ^repository newCommitWalk fromBranch: selfprintString  ^String streamContents: [:stream |  self printOn: stream ]operation: anIceModification  operation := anIceModificationuser  ^userinitialExtent  ^(800 @ 600) scaledByDisplayScaleFactorbody: anObject  body := anObjecttagNames  ^self tags collect: #namecommitInfoTabs  ^commitInfoTabsremoveTag: anIceTag  self subclassResponsibilitycommitModels  ^(self fromCommit newCommitWalk uptoCommit: self toCommit) commits collect: [:each |  (IceTipCommitModel repositoryModel: self repositoryModel on: each) beCached ]color: aColor  color := aColorwriteSnapshot: aSnapshot  (TonelWriter on: self repositoryDirectory) writeSnapshot: aSnapshotfromCommit: commit  self fromCommitId: commit iditem: anObject  item := anObjectrealObject  ^realObjectaddToPatcher: aMCPatcher  removeFromPatcher: aMCPatcher  self isMeta ifTrue: [ ^self ].  aMCPatcher removeDefinition: self asMCDefinitionprojectVersion: anObject  projectVersion := anObjectexecute  branchModel deletehandleLibgitError: aBlock  < libgitErrorHandler>  aBlock on: LGitCallReturnHandler do: [:error |  error acceptError: (IceLibgitErrorVisitor onContext: self) ]initialExtent  ^(500 @ (self class inputTextHeight * 2 + self class buttonHeight + 50)) scaledByDisplayScaleFactornewDiff  ^self entity workingCopyDiffcommitishToTag  ^commitishToTagwriterClass  ^self properties writerClasslocation  | fileReferenceLocation relativePath |  fileReferenceLocation := locationInput text trim ifNotEmpty: [:value |  value asFileReference ] ifEmpty: [ ^nil ].  (fileReferenceLocation isContainedBy: IceLibgitRepository localRepositoriesLocation) ifFalse: [ ^fileReferenceLocation ].  relativePath := IceLibgitRepository localRepositoriesLocation makeRelative: locationInput text trim asFileReference.  ^IceLibgitRepository localRepositoriesLocation resolvePath: relativePathrightContents  ^''addLocalRepository  self repository location: self locationToUse.  self repository pluginManager repositoryWillBeCreated: self repository.  self repository workingCopy initializePackagesFromRepository.  self doEnsureProject.  self repository pluginManager repositoryWasCreated: self repository.  ^self repositoryicon: aBlock  iconBlock := aBlocksetHead: anIceGitCommitish  | progress |  progress := IceGitCheckoutProgress new.  self handleLibgitError: [ self repositoryHandle checkout: anIceGitCommitish gitRef options: (LGitCheckoutOptions defaults                 checkoutStrategy: LGitCheckoutStrategyEnum git_checkout_force;                 progressCallback: progress;                 yourself) ]title  ^self jsonAt: #titlerepositoryWasCreated: aRepository  accept: aVisitor  self subclassResponsibilitytitle: aString  title := aStringcanPush  ^self head isDetached not and: [ self branch tracksRemoteBranch ]confirmLabel: anObject  confirmLabel := anObjectrepository: aRepository  repository := aRepositorykey  ^definition keyrefresh  commitList widget     in: [:this |  this dataSource elements: self model commitModels ];     refresh.  selectedModel := self model commitModels ifNotEmpty: #first ifEmpty: [ nil ].  self refreshCommitTabPanelrepository: anObject  repository := anObject= another  ^self species = another species and: [ self referencesSameRemoteLocationAs: another ]model: anObject  model := anObjectinstall  self asMCDefinition loaddescription  ^self namecommitish: aCommittish  committish := aCommittishpriority  ^100000isOkEnabled  ^super isOkEnabled and: [ self host isNotEmpty ]repository  ^self package repositoryicon: aSymbolOrBlock  icon := aSymbolOrBlockcommitishName  ^branchNamecredential: anObject  credential := anObjectitem: anItem  item := anItemrepositoryStrongSelection: ann  | selection context |  selection := repositoryList widget dataSource elementAt: ann selectedIndex.  context := self newContextWithSelection: selection.  IceTipCommandStrongSelectionActivation activateAllInContext: context by: [:each |  each executeCommand ]addWidgetsTo: column  | last |  last := items associations last.  items associationsDo: [:each |  | label value |        label := each key.        value := each value.        self newWidgetLabel: label value: value do: [:labelId :valueId |  self addRow: labelId value: valueId isLast: last = each to: column ] ]fileFormatId: aFileFormat  self repositoryProperties fileFormatId: aFileFormatcommitWithMessage: aString  ^self commitChanges: self repository workingCopyDiff withMessage: aStringisAlternateSSHUrl: aString  ^self class isAlternateSSHUrl: aStringitems: aCollection  items := aCollection asOrderedCollection.  self refreshrefreshDetailPanel  detailPanel widget removeAllMorphs.  selectedOption ifNotNil: [ detailPanel widget addMorphBack: (IceTipReadOnlyTextMorph new                 hResizing: #spaceFill;                 vResizing: #spaceFill;                 contentsWrapped: selectedOption help;                 yourself) ]initialExtent  ^(350 @ (self class inputTextHeight * 4 + self class buttonHeight)) scaledByDisplayScaleFactorchildren: aCollection  children := aCollection.  children do: [:each |  each parent: self ]acceptError: aVisitor  aVisitor visitNoCommitMessage: selfinitializeWidgets  urlLabel := self newLabel label: 'Url'.  authorLabel := self newLabel label: 'Author'.  fromLabel := self newLabel label: 'From'.  toLabel := self newLabel label: 'Into'.  mergeableLabel := self newLabel label: 'Mergeable'.  statusLabel := self newLabel label: 'Status'.  urlText := self newTextInput enabled: false.  authorText := self newTextInput enabled: false.  fromText := self newTextInput enabled: false.  toText := self newTextInput enabled: false.  mergeablePanel := self newMergeablePanel.  statusPanel := self newStatusPanel.  checksTable := self newChecksTable.  bodyText := self newText enabled: falseremoteNamed: aString ifAbsent: aBlockClosure  self subclassResponsibilitypackage  ^packagemergeWithMasterCheckbox  ^mergeWithMasterCheckboxproviderName  ^self class providerNameremote: anObject  remote := anObjectisOkEnabled  ^self username isNotEmpty and: [ self publicKey isNotEmpty and: [ self privateKey isNotEmpty ] ]url  ^self jsonAt: #urlcontents: anObject  contents := anObjectexecute  (IceGitHubOpenOnGithubAction organisation: self remote owner projectName: self remote projectName) executeshouldInclude: aLGitCommit  ^self modifyingPackage ifNil: [ true ] ifNotNil: [:package |  aLGitCommit changesFileNamed: package directoryPathString ]selectCurrentBranch  | index branch |  branch := self model headModel.  index := sidebarTree widget dataSource indexOfElementMatching: [:each |  each isLeaf and: [ each model name = branch name ] ].  sidebarTree widget selectIndex: indexinitialExtent  ^(350 @ (self class inputTextHeight * 6 + self class buttonHeight)) scaledByDisplayScaleFactorfileSystem  ^FileSystem memory rootfileReference  ^fileReferenceremoveClass: anIceClassDefinition  repository workingCopy removeClassNamed: anIceClassDefinition namevalidateCanCommit  self repository validateCanCommit.  self workingCopyState validateCanCommithash  ^((self species hash bitXor: self major) bitXor: self minor) bitXor: self patchcommitLabel: anObject  commitLabel := anObjectdoesNotUnderstand: aMessage  ^aMessage sendTo: (self findVersionInfo ifNotNil: [:versionInfo |  self becomeForward: versionInfo copyHash: false ] ifNil: [ self stubVersionInfo ])newRepository  UIManager default informUser: ('Cloning repository {1}' format: {self remoteUrl}) during: [ ^IceRepositoryCreator new           repository: repository;           remote: (IceGitRemote url: self remoteUrl);           location: self projectLocation location;           createRepository ]newContextWithSelection: anObject  ^self newContext     item: anObject;     yourselfancestors  ^ancestorIds collect: [:each |  repository lookupCommit: each ]adopt  self entity adoptisMissing  ^self repositoryDirectory isNil or: [ self repositoryDirectory exists not ]gitRepositoryInfo  ^gitRepositoryInfo ifNil: [ gitRepositoryInfo := self requestGitRepositoryInfo ]isMeta: anObject  isMeta := anObjectfromCommitId: commitId  self fromLGitId: (LGitId fromHexString: commitId)password  ^passwordInput textvisitCloneLocationAlreadyExists: anError  UIManager default alert: ('The clone location {1} already exists' format: {anError location}) title: 'Clone action failed'hasMultipleAncestors  | ancestors |  ancestors := self ancestorIds.  ^ancestors notNil and: [ ancestors size > 1 ]accept  self window delete.  selectedOption executeWith: self modelbaseBranchList: anObject  baseBranchList := anObjectremoteModel  ^repositoryModel remoteModels detect: [:e |  e entity = self remote ]outgoingCommitsTo: aRemote  | remoteBranch walk |  remoteBranch := aRemote remoteBranchNamed: self name ifAbsent: [ ^self reducedOutgoingCommitsWhenNoRemote ].  walk := self newCommitWalk.  remoteBranch ifNotNil: [ walk uptoCommit: remoteBranch commit ].  ^walk commitsitemNameWithoutBranches  ^'View Pull Request...'contents  ^self response contentsrepository: aRepository  repository := aRepositoryexecute  (IceTipCommitBrowser on: self repositoryModel) openWithSpecbasicCodeDirectory  ^self subdirectory isEmptyOrNil ifTrue: [ self repositoryDirectory ] ifFalse: [ self repositoryDirectory / self subdirectory ]name: anObject  name := anObjectmerge  ^mergevisitAddition: anIceAddition  repository workingCopy applyDefinition: anIceAddition definition inNode: currentNodeselectRight  chosen := operation inversechangesFromCommit: anIceGitCommit  | files |  files := self repository changedFilesBetween: anIceGitCommit and: self.  ^files collect: [:each |  IceGitChange on: each ]remoteNamed: aString  ^self remoteNamed: aString ifAbsent: [ IceRemoteNotFoundError new           remoteName: aString;           signal ]shortCommitId  ^[ self entity headCommit shortId ] on: Error do: [ nil ]initialExtent  ^(500 @ 300) scaledByDisplayScaleFactorlocationLabel: anObject  locationLabel := anObjectreadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  item := aToolContext itemaccept: aVisitor  ^aVisitor visitExtensionDefinition: selfremoteLabel: anObject  remoteLabel := anObjectconfigureButton: aButton item: aToolbarItem  aButton on: aToolbarItem getState: nil action: #execute label: #label icon: #icon menu: nil.  aButton badgeSelector: #badgecontents  ^''refresh  leftPanel removeAllMorphs.  rightPanel removeAllMorphs.  items do: [:each |  each position addItem: (each newStatusBarItemOn: self) into: self ]remoteBranchNamed: aString ifPresent: presentClosure ifAbsent: absentClosure  ^absentClosure valuemodel  ^modelmergeCommit: aCommit  ^self workingCopyState mergeCommit: aCommittoWarningMessage: aString  ^aString asText allBold makeAllColor: self colorWarninginspect  ^Smalltalk tools inspector inspect: selfproject  ^self workingCopy projectoutgoingCommits  self hasUpstream ifFalse: [ ^#() ].  ^self outgoingCommitsTo: self upstream remoteexecute  tagModel deletewriteClassDefinition: definition to: classPath  self writeInDirectoryName: classPath fileName: 'README' extension: '.md' visit: [ self writeClassComment: definition ].  self writeInDirectoryName: classPath fileName: 'properties' extension: self propertyFileExtension visit: [ self writeClassDefinition: definition ]refreshDiffFromAncestor  ancestorTabContainer updateContentsOn: selectedModelcomment  ^''visitWorkingCopyDesynchronizedError: anError  self visitGenericError: anErrorhost  ^'local filesystem'loadPackageNamed: aString  self loadPackagesNamed: {aString}name: aString  name := aStringmergeWithLeftNoOperation: anIceNoModification  ^self subclassResponsibilityadopt  self repository workingCopy adoptCommit: selfoperationIcon  ^self iconNamed: #changeUpdateinitializeWidgets  nameLabel := self newLabel label: 'Remote name'.  nameText := self newTextInput     ghostText: 'e.g., user-remote';     autoAccept: true.  urlLabel := self newLabel label: 'Remote URL'.  urlText := self newTextInput     ghostText: 'e.g., git@github.com:user/project.git';     autoAccept: true.  self focusOrder     add: nameText;     add: urlTextexecute  item ifNil: [ ^self ].  IceTipStandardAction new     repository: item entity;     message: 'Recalculating Dirty Packages';     onSuccessRepositoryModified;     execute: [ item entity workingCopy forceCalculateDirtyPackages ]checkout: aCheckoutStrategy  | localBranch |  self repository branchNamed: self shortName ifPresent: [:branch |  IceError signal: ('Branch {1} already exists' format: {self shortName}) ].  localBranch := self repository createBranch: self shortName inCommit: self commit.  aCheckoutStrategy committish: localBranch.  ^localBranch checkout: aCheckoutStrategyremoteUrl  ^remoteUrlrebuildToolbar  toolbar items: #().  toolbar addItemsFromContext: self newContexttargetName  ^commitish namesetModelBeforeInitialization: aCommitish  self commitish: aCommitishentity  ^entitysourceDirectoryLabel: anObject  sourceDirectoryLabel := anObjectmergeableLabel: anObject  mergeableLabel := anObjectspacePanel: anObject  spacePanel := anObjectmessage  ^self commentText text asStringcommit  ^commitsnapshotForPackage: aPackage  ^aPackage isLoaded ifTrue: [ (MCPackage named: aPackage name) basicSnapshot ] ifFalse: [ self referenceCommit snapshotForPackage: aPackage ]initializeWidgets  super initializeWidgets.  remotePanel := self instantiate: IceTipSelectRemotePresenter on: self model.  remotePanel remoteList whenSelectedItemChanged: [:remoteModel |  self moveToRemote: remoteModel ].  self focusOrder     add: self commitsPanel;     add: self actionPanel;     add: self remotePanelchildAt: aString ifPresent: aBlockClosure  ^childrenDictionary at: aString ifPresent: aBlockClosureexecute  (IceTipCheckoutPreviewBrowser onBranch: selectedCommit) openWithSpecprojectVersion  ^(location substrings: '/') third copyAfter: $:withErrorHandlingDo: aBlock  aBlock on: IceError do: [:e |  e acceptError: (IceTipInteractiveErrorVisitor on: self repositoryModel entity) ]bePositionRight  self position: IceTipItemPosition rightid  self subclassResponsibilitysourceDirectoryPath  ^RelativePath withAll: (RelativePath canonicalizeElements: ($/ split: self sourceDirectory))mcSnapshot  ^self mcVersion snapshotformat: anObject  format := anObjectorigin  self subclassResponsibilitytextWidget  ^textWidgetrefreshPullRequests  | table |  table := self pullRequests widget.  table dataSource elements: self fetchPullRequests.  (table hasSelection not and: [ table dataSource hasElements ]) ifTrue: [ table selectRowIndex: 1 ]branch  fetched ifFalse: [ self fetch ].  ^branch ifNil: [ branch := (self repository remoteNamed: self remote name) remoteBranchNamed: ((self jsonAt: #head) at: #ref) ]initialExtent  ^(400 @ (self class inputTextHeight * 3 + self class buttonHeight + 50)) scaledByDisplayScaleFactorisResumable  ^resumableprojectBasename  ^self projectName withoutSuffix: '.git'newBranchListDataSource  ^IceTipDataSource new     tool: self;     elements: self branchModels;     yourselfrightDefinition  ^oldNodeisBranch  ^trueinitialize  super initialize.  self subscribeToAnnouncementsremoteName  ^remoteNameexecute  (IceTipCheckoutNewBranchPanel on: self repositoryModel)     commitish: selectedCommit entity;     withResultDo: [:branch |  branch checkout ];     openDialogWithSpecisModelOf: anObject  ^self entity = anObjectbranchesFrom: aRepository  ^aRepository branches select: [:branch |  branch isRemote and: [ branch remoteName = self name ] ]isExtensionDefinition  ^falseinitializeWidgets  packagesList := self newIceTreeTable.  packageNameText := self newTextInput     autoAccept: true;     ghostText: 'e.g., Collections'.  self initializePackagesList.  self initializePackageNameText.  self focusOrder     add: self packagesList;     add: self packageNameTextcellColumn: column row: rowIndex  column id = #target_url ifTrue: [ ^self targetUrlCellColumn: column rowIndex: rowIndex ].  column id = #state ifTrue: [ ^self statusCellColumn: column rowIndex: rowIndex ].  column id = #context ifTrue: [ ^self contextCellColumn: column rowIndex: rowIndex ].  ^super cellColumn: column row: rowIndexcreateTag: aString thenDo: aBlockClosure  < noCache>  IceTipStandardAction new     repository: self entity;     message: ('Creating tag {1} on commit {2}' format: {aString .               self commit shortId});     onSuccessRepositoryModified;     execute: [ | branch |        branch := self commit createTag: aString.        aBlockClosure value: branch ]readerClass  ^TIceRepositoryReader users detect: [:each |  each id = self fileFormat id ]datetime  ^datetimebodyPanel  ^bodyPanelcommits: anObject  commits := anObjectselectedBranch  ^selectedBranchinitializeToolbar  isModified  ^self isDirtysnapshotWriterClass  ^IceLibgitFiletreeSnapshotWriterlatestTagPartsIn: tagNames  | prefix parts |  parts := #('v' 0 0 0).  prefix := 'v'.  (tagNames select: [:each |  'v?[0-9]' asRegex matchesPrefix: each ]) ifNotEmpty: [:tags |  | latestTag |        latestTag := tags sorted last.        parts := ((latestTag beginsWith: prefix) ifTrue: [ #('v') ] ifFalse: [ #('') ]) , ((((latestTag withoutPrefix: prefix) copyUpTo: $-) splitOn: '.') collect: [:each |  NumberParser parse: each onError: [ 0 ] ]).        parts := parts , (#(0 0 0) first: 4 - parts size) ].  ^partsicon  ^self iconNamed: #class= anotherProject  self species = anotherProject species ifFalse: [ ^false ].  self repository = anotherProject repository ifFalse: [ ^false ].  self properties = anotherProject properties ifFalse: [ ^false ].  ^truepreferredColor  ^self isResolved ifTrue: [ Color gray ] ifFalse: [ Color red ]doCheckout  self model executeCheckoutActionAndThen: [ self window delete ]isNewRepository  ^truesortingStrategy  ^sortingStrategy ifNil: [ sortingStrategy := IceSortingStrategy new first: #modified ]filter  pattern ifNil: [ ^self ].  table dataSource: (pattern ifNotEmpty: [ initialDataSource newDataSourceMatching: (filterClass pattern: pattern) ] ifEmpty: [ initialDataSource ]).  table selectRowIndexes: #().  table dataSource expandAll.  self isExplicite ifTrue: [ self resizeWidget ]ensureBranch: branchName  (self hasLocalBranchNamed: branchName) ifFalse: [ self createBranch: branchName ]tagNamed: aString  (self hasTagNamed: aString) ifFalse: [ IceTagNotFound new           tagName: aString;           signal ].  ^IceTag named: aString inRepository: selfbaseLabel: anObject  baseLabel := anObjectrepositoryList: anObject  repositoryList := anObjectmergeOn: aModel then: aBlock  self subclassResponsibilitycredentials  ^self subclassResponsibilitytree  ^treeisEmpty  ^self diff isEmptysanitizeTitle: aString  | separators safeSeparator |  aString isEmptyOrNil ifTrue: [ ^self class unknownTitle ].  safeSeparator := $-.  separators := {Character space .   Character tab .   $_ .   safeSeparator}.  ^String streamContents: [:str |  aString do: [:c |  (separators includes: c) ifTrue: [ str nextPut: safeSeparator ].              c isAlphaNumeric ifTrue: [ str nextPut: c ] ] ]fullWorkingCopyDiff  ^IceDiff new     source: self workingCopy;     target: self head;     buildFull;     yourselfname  ^nameaddFileToIndex: aFile  self addFilesToIndex: {aFile}descriptionWithDecoration  ^self model descriptionWithDecorationpull  self pullFrom: repository origincontextClass  ^IceTipRepositoryContextdoAccept  self validate.  IceTipStandardAction new     repository: self model entity;     message: ('Verifying merge from {1}' format: {self selectedBranch name});     onSuccess: [ self selectedBranch previewMerge: self mergeType ];     execute: [ self validate ]sourceCode  ^sourceCodeaccept: aVisitor  ^aVisitor visitClassDefinition: selfselectRight  self subclassResponsibilityasMCDefinition  ^MCOrganizationDefinition categories: categoriessetModelBeforeInitialization: anObject  model := anObjectchangesFromCommit: anIceCommit  ^self subclassResponsibilityinitialize  super initialize.  fetched := falsetypeList  ^typeListfinishSuccess  super finishSuccess.  Iceberg announcer announce: (IceRepositoryModified for: self repository)isSingleCommitState  ^falseisDetached  ^self referenceCommit ~= repository head commitmergeWith: aCommit  self subclassResponsibilitybasicExecute  (IceTipCheckoutPreviewBrowser onBranch: self repositoryModel branchModel) openWithSpecchangesFromNoCommit: anIceNoCommit  ^self packages collect: [:each |  IceImageChange package: each ]printPathOn: aStream  parent ifNil: [ aStream nextPutAll: initialTree repository workingDirectoryName ] ifNotNil: [ parent printPathOn: aStream.        aStream           nextPut: $/;           nextPutAll: entryName ]name  ^namedoAccept  self selectedType doAcceptsubscribeToAnnouncements  self announcer when: IceTipDiffRefreshed send: #refreshWhenRepository: to: self.  Iceberg announcer weak when: IceRepositoryAnnouncement send: #refreshWhenRepository: to: selfwriteVersion: aVersion  directory := aVersion package name , '.package'.  packageFileDirectory := stream / directory.  self packageFileDirectory ensureDeleteAll.  self writeFormat.  self writePackage: aVersion package.  self writeDefinitions: aVersion.  aVersion dependencies do: [:ea |  self writeVersionDependency: ea ]remote: aRemote  ^remote := aRemotebranchName  ^self branch nameancestors  ^self subclassResponsibilityisPackageDefinition  ^falseversionName  ^'{1}-{2}.{3}' format: {self packageNameFromPackageDirectory .         self commit compatibleUsername .         self versionNumber}protocolLabel  ^protocolLabelremoteTrackedBranches  self handleLibgitError: [ ^OrderedCollection new: 10 streamContents: [:stream |  self repositoryHandle remoteBranchesDo: [:br :isLocal |  self assert: isLocal not.                    stream nextPut: (self basicNewRemoteBranchNamed: br name) ] ] ]initialize  selectedItems := Set new.  super initialize.  self title: self class titlevisitModification: anIceModification  anIceModification leftDefinition addModification: anIceModification toPatcher: patcher.  self visitChildrenOf: currentNodeaccept  self validate.  self model addRemoteNamed: self remoteName url: self remoteUrl.  ^acceptBlock ifNotNil: [ acceptBlock cull: self remoteName ]executeMergeActionAndThen: aBlock  < noCache>  IceTipStandardAction new     repository: self repository;     message: ('Merging {1} into {2}' format: {self targetName .               self repositoryName});     onSuccessRepositoryModified;     onSuccess: aBlock;     execute: [ self merge ]model: anObject  model := anObject.  self allTypes do: [:each |  each model: anObject ]fromCommit  ^self entitybasicExecute  (IceTipEditProjectDialog on: (IceBasicProject onRepository: self repositoryModel entity)) openDialogWithSpecremoteToUse  self remote ifNotNil: [ ^self remote ].  self url ifNotNil: [ ^IceGitRemote url: self url ].  ^nilfileSystem  ^self commit fileSystemtitle  ^'Repositories'isSelected: anObject  ^selectedItems includes: anObjectisMerged  ^self entity isMergedtypeList: anObject  typeList := anObject= aGitCommit  (aGitCommit isKindOf: self species) ifFalse: [ ^false ].  ^self id = aGitCommit idexecute  branchModel deleteexecute  (IceTipRepairRepositoryDialog on: self repositoryModel) openDialogWithSpecstoreIfDefault  self isDefault ifFalse: [ ^self ].  IceCredentialStore current storeCredential: selfmodel: anObject  model := anObjectinitializeWithTree: aLGitTree  initialTree := aLGitTreetagName  ^tagNameselectButton: anObject  selectButton := anObjectissueText  ^issueTextmessageText  ^self jsonContents at: #messageisAncestorOfCommitId: anotherCommitId  ^self commit isAncestorOf: (self repository lookupCommit: anotherCommitId)extent  ^45 @ 40libgitCommit  repository handleLibgitError: [ ^LGitCommit of: self repositoryHandle fromHexString: self id ]packageNode: anIcePackageNode  packageNode := anIcePackageNodeversionsFor: package detect: selectBlock ifNone: ifNoneBlock  self modifyingPackage: package.  self commitsDo: [:commit |  | version |        version := commit versionFor: package.        (selectBlock value: version) ifTrue: [ ^version ] ].  ^ifNoneBlock valueremote  ^repository remoteNamed: self remoteNameheadRemote  ^headRemote ifNil: [ self repository head upstream remote ]lookupHead  self handleLibgitError: [ | head |        self repositoryHandle isUnborn ifTrue: [ ^IceGitUnbornBranch inRepository: self ].        head := self repositoryHandle head.        ^head isBranch ifTrue: [ self basicNewBranchNamed: head name ] ifFalse: [ head object asIcebergObjectInRepository: self ] ]branches  ^self entity localBrancheschooseTitle  ^chooseTitle ifNil: [ self class defaultChooseDialogTitle ]goferPriority  ^8badge  ^badgenewEmptyTab  ^self newTab     label: 'Info';     icon: (self iconNamed: #smallQuestion);     closeable: false;     contents: '(No commit selected)' asMorph;     yourselfsuspendAllForRepository: aRepository while: aBlock  ^self suspendAllMatching: [:ann |  ann appliesToRepository: aRepository ] while: aBlockcanBrowseReferences  ^falsemergeWithLeftNoOperation: anIceNoModification  ^IceConflictingOperation left: anIceNoModification right: selfstripPossibleExtension: aString  ^(aString endsWith: '.git') ifTrue: [ aString allButLast: 4 ] ifFalse: [ aString ]readParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  commitModel := aToolContext itemiconPanel  ^iconPanelaccept  acceptBlock ifNotNil: [ acceptBlock cull: self ].  self window deleteupdatePullRequest: owner project: projectName number: aNumber data: aDictionary  ^self patch: 'repos/' , owner , '/' , projectName , '/pulls/' , aNumber asString with: [:client |  client           entity: (ZnEntity text: (STON toJsonString: aDictionary));           contentType: ZnMimeType applicationJson ]body  ^bodyversionFor: aPackage  ^IceSavedPackageVersion fromCommit: self package: aPackagename  ^nameitemNameWithoutBranches  ^'Remove Branches...'basicExecute  [ | url |  url := (self github getRepository: self organisation project: self projectName) at: 'html_url'.  self class environment at: #WebBrowser ifPresent: [:webBrowser |  webBrowser openOn: url ] ifAbsent: [ self inform: ('Cannot open "{1}" because the project WebBrowser is not present by default in Pharo 6.' format: {url}) ] ] on: IceGitHubError do: [ self inform: ('Invalid Github repository. No project named "{1}" found for the owner "{2}"' format: {self projectName .                     self organisation}) ]description  self tags ifNotEmpty: [:tags |  ^', ' join: (tags collect: [:each |  each name ]) ].  ^'Detached at {1}' format: {self shortId}remoteUrl  ^self remoteInputText text asString trimmed