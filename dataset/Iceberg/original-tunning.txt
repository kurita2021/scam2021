nameOfBaseline: baselinePackage  ^baselinePackage name allButFirst: self class baselinePrefix sizeonSuccessRepositoryModified  ^self onSuccessAnnounce: [ IceRepositoryModified for: self repository ]name  ^self iddataSource: anObject  dataSource := anObjectaddButton: anObject  addButton := anObjectremoveSSHCredential: aCredential  sshCredentials removeKey: aCredential hostobtainPlaintextCredentials: response  self subclassResponsibilitycontextClass  | class |  class := Smalltalk globals at: self className ifAbsent: [ ^nil ].  self classIsMeta ifTrue: [ class := class classSide ].  ^classselectionChanged: ann  self basicSelectionChanged: (ann newSelectedIndexes ifNotEmpty: [:indexes |  self typeList widget dataSource realElementAt: indexes first ] ifEmpty: [ nil ])diff  ^diffModel ifNil: [ | diff |        UIManager default informUser: 'Calculating diff' during: [ diff := self calculateDiff ].        diffModel := IceTipCommitDiffModel repositoryModel: self repositoryModel on: diff ]initialize  self beForCommit.  super initializebuilder  ^buildercontext: anObject  context := anObjectglobalCheckbox: anObject  globalCheckbox := anObjectisDirectoryDefinition  ^trueoutgoingCommitsTo: aRemote  ^self branch outgoingCommitsTo: aRemotehost: aString  host := aStringtarget  ^targetvisitAddition: anIceAddition  anIceAddition definition addToPatcher: patcher.  self visitChildrenOf: currentNodeinitialize  super initialize.  items := OrderedCollection newchildrenDo: aBlockClosure  self children do: aBlockClosurerepositoryHandle  < repositoryHandleAccessor>  ^repository repositoryHandlename  ^self repository nameheadRemote  ^headRemoteorder  ^SmallInteger maxVal - 1000cellColumn: column row: rowIndex  | item cell |  item := self elementAt: rowIndex.  cell := FTCellMorph new     cellInset: 5;     yourself.  (column readIcon: item) ifNotNil: [:icon |  cell addMorphBack: icon asMorph ].  cell addMorphBack: (IceTipLabelMorph new contentsAsIs: (column read: item)).  ^cellmergeWithLeftNoOperation: anIceNoModification  ^IceNonConflictingOperation operation: selfpackage: anIcePackage  package := anIcePackageurl  ^'No PR selected'diffPanel  ^diffPaneladdPackage: anIcePackageDefinition  | pathSegments |  pathSegments := repository subdirectoryPath segments asOrderedCollection.  pathSegments add: (repository writerClass directoryNameFor: anIcePackageDefinition).  self addPath: (RelativePath withAll: pathSegments)chooseUpgradePolicyProject: projectName optionA: optionA optionB: optionB  ^UIManager default chooseFrom: {('Use INCOMING version {1}' format: {optionA}) .         ('Use LOADED version {1}' format: {optionB})} values: {#useIncoming .         #useLoaded} message: ('There is already a project "{1}" in this installation.' format: {projectName}) title: 'Duplicated project!'defaultToolbarItemName  ^self class defaultToolbarItemNameresetHandle  handle := nilindexOfElementMatching: aBlock  1 to: self numberOfRows do: [:index |  (aBlock value: (self realElementAt: index)) ifTrue: [ ^index ] ].  ^0commonAncestorWithCommit: anIceGitCommit  repository handleLibgitError: [ | mergeBaseId |        mergeBaseId := [ (self repositoryHandle mergeBaseBetween: (LGitId fromHexString: self id) and: (LGitId fromHexString: anIceGitCommit id)) hexString ] on: LGit_GIT_ENOTFOUND do: [ nil ].        ^mergeBaseId ifNotNil: [ self repository lookupCommit: mergeBaseId ] ]withAllChildrenOf: item  ^item children inject: {item} into: [:all :each |  all , (self withAllChildrenOf: each) ]iconPanel: anObject  iconPanel := anObjectaddToChangeBuilder: anIceChangeImporter  self addProjectFileToChangeBuilder: anIceChangeImporteraddModification: anIceModification toPatcher: aMCPatcher  aMCPatcher modifyDefinition: anIceModification rightDefinition asMCDefinition to: anIceModification leftDefinition asMCDefinitionisRightChosen  ^chosen = rightOperationinfo  ^{('Branch' -> self entity branch name) .   ('Location' -> self entity location pathString) .   ('Upstream' -> self entity upstream asString)}putFocusOrder  self focusOrder     add: usernameInput;     add: passwordInputname  ^self entity namevisitMethodDefinition: aMCMethodDefinition  | ownerName isMeta isTrait ownerNode |  ownerName := aMCMethodDefinition className.  isMeta := aMCMethodDefinition classIsMeta.  isTrait := self isTrait: aMCMethodDefinition className.  ownerNode := self ensureMethodOwnerNamed: ownerName isMeta: isMeta isTrait: isTrait isExtension: (self isExtension: aMCMethodDefinition className).  ^ownerNode addChild: (IceMethodDefinition className: aMCMethodDefinition className classIsMeta: aMCMethodDefinition classIsMeta protocol: aMCMethodDefinition protocol name: aMCMethodDefinition selector sourceCode: aMCMethodDefinition source)repository  ^repositorypackagesList  ^packagesListreasonPanel  ^reasonPanellazy  ^selfport  ^porttoErrorMessage: aString  ^aString asText allBold makeAllColor: self colorErrorstore  ^storegitRef  ^self namecommitsDo: aBlock  self rawResultsDo: [:result |  aBlock value: (self commitFrom: result) ]prefix  ^'refs/remotes/'mergeWithLeftRemoval: anIceRemoval  self subclassResponsibilitynotifyPackageModified: aString  ^self workingCopy notifyPackageModified: aStringinitialize  super initialize.  messageText := '' asTexttab  ^tabbasicExecute  credentials := IceGitHubAPI ensureCredentials.  UIManager default informUser: ('Retrieving pull requests from {1}' format: {self remote}) during: [ (IceTipGitHubPullRequestListBrowser onRepository: self repository)           remote: self remote;           refreshPullRequests;           openWithSpec ]setModelBeforeInitialization: anObject  model := anObjectinitializeWidgets  super initializeWidgets.  commitList := self newIceTable.  commitInfoTabs := self instantiate: IceTipCommitInfoPresenter.  self initializeCommitList.  commitList widget onAnnouncement: FTSelectionChanged send: #selectionChanged: to: self.  self focusOrder     add: commitList;     add: commitInfoTabs.  self refreshonAccept: aBlock  acceptBlock := aBlockoptionB: anObject  optionB := anObjectinitializeWidgets  isAddition  ^truerefresh  remoteList items: self model remoteModelsname  ^'{1}>>{2}' format: {self entity origin name .         self entity selector}branchNamed: aString ifPresent: presentBlock ifAbsent: absentBlock  self handleLibgitError: [ | found |        found := self repositoryHandle lookupLocalBranch: aString ifAbsent: [ nil ].        ^found ifNil: absentBlock ifNotNil: [ presentBlock value: (self basicNewBranchNamed: found name) ] ]mcRepository  | baseRepo |  self guessRegisteredRepository ifNotNil: [:repo |  repo isValid ifTrue: [ ^repo metacelloAdapter: self projectVersion ].        repo forget ].  baseRepo := self mcRepositoryClass location: self location.  ^baseRepo getOrCreateIcebergRepository metacelloAdapter: self projectVersionrepository  ^modelsnapshot  ^version snapshotForPackage: self packageisRemote  ^trueisCache  ^falsestoreMCVersion: aMCVersion  | pathSegments |  repository internalStoreVersion: aMCVersion.  pathSegments := OrderedCollection new.  repository subdirectory ifNotEmpty: [:directory |  pathSegments add: directory ].  pathSegments add: (repository writerClass directoryNameFor: aMCVersion package).  self addPath: (RelativePath withAll: pathSegments)addPackages: aCollection  aCollection keysDo: [:each |  self addPackageNamed: each ]printDescriptionOn: aStream  aStream     nextPut: $(;     nextPutAll: package;     nextPutAll: ', ';     nextPutAll: (self isLoaded ifTrue: 'loaded' ifFalse: 'not loaded');     nextPut: $)canActivateCommand: aCommandClass  ^falseaddToPatcher: aMCPatcher  aMCPatcher addDefinition: self asMCDefinitioncommitModels  self subclassResponsibilitytagNames  ^self tags collect: #namecypressClassOrTraitName: aMethod  ^aMethod origin instanceSide name , (self cypressMethodClassExtension: aMethod)isEmpty  ^modifiedFilePaths isEmptyisTag  ^trueicon  ^self class iconbranchName  ^self branch namepackage  ^packagebeForCommit  headTabContainer := IceTipHistoryDiffFromHead tab: headTab.  ancestorTabContainer := IceTipHistoryDiffToAncestor tab: ancestorTabisWorkingCopy  ^trueloadFromStore  | array |  self flag: #implementAnEncryptedVersion.  storeFile ifNil: [ ^self ].  storeFile exists ifFalse: [ ^self ].  array := FLMaterializer materializeFromFileNamed: storeFile resolve pathString.  plainCredentials := array at: 1.  sshCredentials := array at: 2doAccept  IceConvertFormatAction new     repository: self repository;     branchName: self branchName;     format: #tonel;     mergeWithCurrentBranch: self mergeWithMasterCheckbox state;     executeregister  self checkForRegistryConflicts.  self class registerRepository: self.  Iceberg announcer announce: (IceRepositoryCreated repository: self).  ^selfentryByName: aString  ^self children at: aString ifAbsentPut: [ self class new initializeWithParent: self entryName: aString ]iconForStatus: status  status = 'success' ifTrue: [ ^self iconNamed: #testGreen ].  status = 'failure' ifTrue: [ ^self iconNamed: #testRed ].  status = 'pending' ifTrue: [ ^self iconNamed: #testYellow ].  ^self iconNamed: #testNotRunshowFilterFieldFromKeystrokeEvent: anEvent  | text |  text := anEvent keyCharacter asString.  self textField takeKeyboardFocus.  self textField text: self textField text , text.  self flag: #hack.  self textField textArea cursorEnd: anEventbranchName  self entity isMissing ifTrue: [ ^self class unknownBranchLabel ].  ^self entity head descriptioncommitFrom: result  ^self repository commitFromGitCommit: resultkeepAllCurrentVersion  self model mergeTree do: [:c |  c isConflict ifTrue: [ c selectLeft ] ].  self changed: #changes.  self updateSourcelabelColor  ^labelColor ifNil: [ labelColor := Smalltalk ui theme textColor ]credentialsList  ^credentialsListisLeaf  ^self isGroup nottitle  ^'Checkout ' , super title asLowercasecommitsDo: aBlock  self maxNumber ifNil: [ super commitsDo: aBlock ] ifNotNil: [ | count |        count := 0.        super commitsDo: [:commit |  aBlock value: commit.              count := count + 1.              count == self maxNumber ifTrue: [ ^self ] ] ]canRevertChanges  ^source canRevertChangescompatibleUsername  ^'CompatibleUserName'isUnknownCommit  ^falsedisplayingProgressString  ^'Comparing changes of ' , filePathStringheadDescription  ^self head descriptionwithOnlyNewBranch  types := self allTypes select: #isNewBranch.  typeList widget dataSource elements: types.  typeList widget refreshdefinition  self subclassResponsibilityremoteModels  ^self repositoryModel remoteModelsprojectName: anObject  projectName := anObjecthasMonticelloMetadata  ^falsebranchNamed: aString ifPresent: aBlockClosure  ^self branchNamed: aString ifPresent: aBlockClosure ifAbsent: [ self ]initialExtent  ^(350 @ (self class inputTextHeight * 5 + self class buttonHeight)) scaledByDisplayScaleFactorrefreshPackages  | commitPackages |  commitPackages := self referenceCommit isCollection ifTrue: [ (self referenceCommit flatCollect: [:each |  each packages ]) asSet ] ifFalse: [ self referenceCommit project packages ].  self packages \ commitPackages do: [:each |  self basicRemovePackage: each ].  commitPackages \ self packages do: [:each |  self basicAddPackage: each ]initialize  super initialize.  shouldIgnoreNotifications := false.  packages := Dictionary new.  referenceCommit := repository newNoCommit.  self basicSetProject: referenceCommit project.  properties := referenceCommit properties asBornPropertiesnewToolbarButtonOn: aToolbar  | button |  button := (IceTipToolbarItemButtonMorph on: self getState: nil action: #execute)     helpText: self help;     font: aToolbar toolbarItemFont;     beIconTop;     hResizing: #rigid;     vResizing: #spaceFill;     borderWidth: 0;     borderColor: Color transparent;     cellPositioning: #center;     width: aToolbar toolbarItemSize;     yourself.  aToolbar displayMode configureButton: button item: self.  ^buttonmergeWithCurrentBranch: anObject  mergeWithCurrentBranch := anObjectgetOrCreateIcebergRepository  ^self repositorybuildForPackages: aCollection  | leftTree rightTree |  leftTree := IceNode value: IceRootDefinition new.  rightTree := IceNode value: IceRootDefinition new.  (aCollection collect: [:package |  IceImageChange package: package ]) do: [:change |  change accept: (IceChangeImporter new                 version: source;                 diff: self;                 parentNode: leftTree;                 yourself).        change accept: (IceChangeImporter new                 version: target;                 diff: self;                 parentNode: rightTree;                 yourself) ].  tree := self diff: leftTree with: rightTreebody  ^''isValid  self flag: #todo.  ^self isMissing notinitializeWidgets  super initializeWidgets.  diffPanel := self instantiate: IceTipDiffPanel on: self model diff.  actionPanel := self newIceActionPanel.  actionPanel addAction: (button := self newActionButton).  self whenBuiltDo: [:ann |  self addShortcutsTo: ann widget ].  self focusOrder     add: self actionPanel;     add: self diffPanelpullFrom: aRemote  | remoteBranch |  aRemote fetchBranch: self.  remoteBranch := aRemote remoteBranchNamed: self name ifAbsent: [ ^self ].  self repository workingCopy mergeCommit: remoteBranch commitisInMerge  ^falseinitializeWidgetsContents  spacePanel := PanelMorph new asSpecAdapter.  self initializeCurrentBranchLabel.  remotePanel := self instantiate: IceTipSelectRemotePresenter on: self selectRemoteModel.  remotePanel remoteList whenSelectedItemChanged: [:remoteModel |  self useRemote: remoteModel ].  branchLabel := self newLabel label: 'Issue number:'.  issueNumberText := self newTextInput     ghostText: 'e.g., 123';     autoAccept: true.  issueLabel := self newLabel label: 'Title:'.  issueText := self newTextInput     ghostText: 'e.g., 123-github-issue';     autoAccept: true.  issueNumberText whenBuiltDo: [:w |  w widget wrapFlag: false ].  issueText whenBuiltDo: [:w |  w widget wrapFlag: false.        w widget enabled: false ].  issueNumberText textHolder whenChangedDo: [:text |  self validateIssue: text ]imageChanges  ^(source loadedPackages collect: [:package |  IceImageChange package: package ]) asArraysend  | pullRequestData |  pullRequestData := {('title' -> self title) .   ('head' -> (self headRemote owner , ':' , self headBranchName)) .   ('base' -> self baseBranchName) .   ('body' -> self body)} asDictionary.  ^IceGitHubAPI new     credentials: self credentials;     addPullRequest: self baseRemote owner project: self baseRemote projectBasename data: pullRequestDatastatusLabel  ^statusLabelvalidate  self validateLocation.  self validateAlreadyPresentAndNotGit.  self validateNotDuplicatedpackage: aPackage  package := aPackagereset  objects := SmallDictionary newblock  ^[:current :total :bytes :payload |  job ensureStarted.  job min: 0.  job max: total.  job current: current.  job title: (self title , ' ({1}/{2})' format: {current .               total}).  job changed.  0 ]notifyPackageModified: aString  self flag: #todo.  self shouldIgnoreNotifications ifTrue: [ ^false ].  (self includesInWorkingCopyPackageNamed: aString) ifTrue: [ | package |        package := self packageNamed: aString.        package isDirty ifFalse: [ package beDirty.              ^true ] ].  ^falserepository: anObject  repository := anObjecthelp  ^self class helprepository  ^repositoryisAncestorOf: anotherVersion  ^self commit isAncestorOf: anotherVersion commitreferencesSameRemoteLocationAs: aRemote  ^(super referencesSameRemoteLocationAs: aRemote) or: [ self httpsUrl sameAs: aRemote httpsUrl ]commitTabPanel  ^commitTabPanelremoteTrackedBranches  self subclassResponsibilityauthorLabel: anObject  authorLabel := anObjectnextConflict  | node firstNode |  firstNode := self selectedChangeWrapper ifNil: [ IceMergeListWrapper with: model mergeTree children first model: model ].  node := firstNode item nextNodeSuchThat: [:item |  item value isConflict and: [ item value isResolved not ] ] ifNone: [ ^nil ].  ^IceMergeListWrapper with: node model: modelfillContextMenu: aMenu using: aCommandActivator  self allBaselines do: [:each |  self fillDefaultMenu: aMenu using: aCommandActivator baseline: each.        self fillGroupMenu: aMenu using: aCommandActivator baseline: each ]indexOfElement: anObject  1 to: self numberOfRows do: [:index |  (self realElementAt: index) = anObject ifTrue: [ ^index ] ].  ^0readContextParametersFromModel: aModel  super readContextParametersFromModel: aModel.  repositoryDetached := aModel isRepositoryDetacheddetailedInfo  ^{('Origin' -> self url) .   ('Remote host' -> (self port = self class defaultPort ifTrue: [ self host ] ifFalse: [ self host , ':' , self portName ])) .   ('Repo Owner' -> self owner)}setModelBeforeInitialization: anObject  model := anObjectmergeButton  ^mergeButtonprotocolLabel: anObject  protocolLabel := anObjectisMethodDefinition  ^truebuild  | leftTree rightTree |  leftTree := IceNode value: IceRootDefinition new.  rightTree := IceNode value: IceRootDefinition new.  (source changesTo: target) do: [:change |  change accept: (IceChangeImporter new                 version: source;                 diff: self;                 parentNode: leftTree;                 yourself).        change accept: (IceChangeImporter new                 version: target;                 diff: self;                 parentNode: rightTree;                 yourself) ].  tree := self diff: leftTree with: rightTreerepository  ^repositorybeSwitchAndMerge  self mergeType: IceTipMergeType switchAndMergeasString  ^item value descriptionisLeftChosen  self subclassResponsibilitysingleCommit  ^self referenceCommitremoteName  ^self nameText text trimmedpackage  ^MCPackage named: self iceVersion packageNameaccept  | title |  title := self titlePanel text trim.  title ifEmpty: [ UIManager default alert: 'You need to specify a title for the pull request.' title: 'Error'.        ^self ].  acceptBlock ifNotNil: [ acceptBlock cull: self createPullRequest ].  self window deletehandleUnauthorized: aZnResponse  | newCredentials |  aZnResponse isSuccess ifTrue: [ ^self ].  aZnResponse status ~= 401 ifTrue: [ ^self ].  newCredentials := IcePlaintextCredentials new.  (IceCredentialsProvider defaultForHost: 'github.com') obtainPlaintextCredentials: newCredentials.  IceAuthenticationError signal: 'Retry to use the new credentials'writeDefinitions: aCollection  | classDirExtension extensionClasses extensionMethodDefinitions extensionMethodMap methodHolders |  self writeBasicDefinitions: aCollection.  extensionClasses := OrderedCollection new.  extensionMethodDefinitions := OrderedCollection new.  methodHolders := self classDefinitions , self traitDefinitions.  self methodDefinitions keysAndValuesDo: [:className :extensionMethods |  methodHolders at: className ifAbsent: [ extensionClasses add: className.              extensionMethodDefinitions addAll: extensionMethods ] ].  extensionClasses do: [:className |  self methodDefinitions removeKey: className ].  self writeMethodHolderDefinitions: self traitDefinitions extension: '.trait' to: '' do: [:definition :classPath |  self writeTraitDefinition: definition to: classPath ].  self writeMethodHolderDefinitions: self classDefinitions extension: '.class' to: '' do: [:definition :classPath |  self writeClassDefinition: definition to: classPath ].  classDirExtension := '.extension'.  extensionMethodMap := Dictionary new.  extensionMethodDefinitions do: [:methodDefinition |  | classPath |        (extensionMethodMap at: methodDefinition className ifAbsent: [ extensionMethodMap at: methodDefinition className put: OrderedCollection new ]) add: methodDefinition.        classPath := methodDefinition className , classDirExtension , self fileUtils pathNameDelimiter asString.        self writeExtensionClassDefinition: methodDefinition to: classPath ].  extensionMethodMap keysAndValuesDo: [:className :classMethodDefinitions |  | classPath filenameMetaMap |        filenameMetaMap := self fileNameMapFor: classMethodDefinitions.        classMethodDefinitions do: [:methodDefinition |  | filename methodPath |              filename := (filenameMetaMap at: methodDefinition classIsMeta) at: methodDefinition selector.              classPath := methodDefinition className , classDirExtension , self fileUtils pathNameDelimiter asString.              methodPath := classPath , (methodDefinition classIsMeta ifTrue: [ 'class' ] ifFalse: [ 'instance' ]) , self fileUtils pathNameDelimiter asString.              self writeMethodDefinition: methodDefinition to: methodPath filename: filename ] ]writeTraitDefinition: definition to: classPath  self writeInDirectoryName: classPath fileName: 'README' extension: '.md' visit: [ self writeClassComment: definition ].  self writeInDirectoryName: classPath fileName: 'properties' extension: self propertyFileExtension visit: [ self writeTraitDefinition: definition ]push  self pushTo: self upstream remotevisitCloneRemoteNotFound: anError  self visitGenericError: anErrorlocalRepository: aRepository  localRepository := aRepositorycount: aBlockClosure  | count |  count := 0.  (aBlockClosure value: self value) ifTrue: [ count := 1 ].  self childrenDo: [:each |  count := count + (each count: aBlockClosure) ].  ^countcalculateChanges  | commonAncestor sourceDiff targetDiff |  mergeTree ifNotNil: [ ^self ].  commonAncestor := (self leftCommit commonAncestorWith: mergeCommit) ifNil: [ IceNoCommit new ].  sourceDiff := self sourceVersion diffTo: commonAncestor.  targetDiff := self targetVersion diffTo: commonAncestor.  mergeTree := self merge: sourceDiff tree into: targetDiff tree.  changesToWorkingCopyTree := self isInverseMerge ifTrue: [ self merge: targetDiff tree into: sourceDiff tree ] ifFalse: [ mergeTree ]referenceCommit  ^repository workingCopy referenceCommitwindowIcon  ^self iconNamed: #komitterSmalltalkhubRemotecreateMergeBranchTypes  | allTypes |  allTypes := {((IceTipMergeBranchPanel on: self model)     title: 'Local';     withoutHead;     icon: (self iconNamed: #branch);     yourself)} , (self model remoteModels collect: [:each |  (IceTipMergeBranchPanel on: each)                 title: each name;                 icon: (self iconNamed: #remote);                 yourself ]).  allTypes do: [:each |  each onAccept: [ self window delete ] ].  ^allTypespropertyFileExtension  ^MCFileTreeRepository defaultPropertyFileExtensionisAnnouncementSuspended: anAnnouncement  suspendAll ifTrue: [ ^true ].  suspendedConditions ifEmpty: [ ^false ].  ^suspendedConditions anySatisfy: [:each |  each value: anAnnouncement ]isTag  ^falseonAccept: aBlock  acceptBlock := aBlockmergeWithOperation: anOperation  ^anOperation mergeWithLeftNoOperation: selfbody  ^self jsonAt: #bodycanReadProjectFromCommitish: aCommitish  self subclassResponsibilitycommitsDo: aBlock  actualClass  ^leftOperation definition actualClasscommonAncestorWith: aCommitish  ^aCommitishreadIcon: anObject  ^self icon ifNotNil: [ self icon value: anObject ]fromText  ^fromTexticon: anIcon  icon := anIconmcRepository  | repository tuple extractedLocation |  tuple := self splitRootAndSubdirectoryFromLocation.  extractedLocation := tuple first asFileReference asAbsolute.  repository := IceRepository registry detect: [:each |  each location notNil and: [ each location asAbsolute = extractedLocation ] ] ifNone: [ (IceRepositoryCreator new           location: tuple first;           subdirectory: tuple second;           ensureProjectFile;           createRepository) register ].  ^repository metacelloAdapter: repository head descriptioncomment  self subclassResponsibilityworkingCopyDiff  < noCache>  ^IceTipWorkingCopyDiffModel repositoryModel: self on: self entityvisitRemoval: anIceRemoval  self visitAddition: anIceRemovalcredentials  ^credentialspackages  ^self entity workingCopy packagesversionFor: package  ^IceSavedPackageVersion fromCommit: self package: packagecheckout: aCheckoutStreategy  basicExecute  self repositoryModel createSourceDirectory.  self repository workingCopy refreshProjectFromRepository.  Iceberg announcer announce: (IceRepositoryModified for: self repository)asSpotterCandidateLink  ^GTSpotterCandidateLink value: selfobtainSshCredentials: response  LGitNoCredentialsProvided signalproperties  ^propertiestoString: aFileReference  ^aFileReference basenameconfigureButton: aButton item: aToolbarItem  self subclassResponsibilityrefreshDiffFromHeadLabel  headTabContainer updateLabelOn: selectedModelinitializeWidgets  remoteLabel := self newLabel label: 'Remote:'.  remoteList := self newDropList.  remoteList     items: self model remoteModels;     displayBlock: [:each |  each descriptionWithDecoration ].  addButton := self newButton icon: self icon.  addButton action: [ self addRemote ].  remoteList setSelectedItem: self model remoteModel.  self focusOrder add: remoteListcreateSourceDirectory  < noCache>  entity createSourceDirectoryname  ^self entity namebuildFull  | leftTree rightTree |  leftTree := IceNode value: IceRootDefinition new.  rightTree := IceNode value: IceRootDefinition new.  self imageChanges , (source referenceCommit changesTo: target) asArray do: [:change |  change accept: (IceChangeImporter new                 version: source;                 diff: self;                 parentNode: leftTree;                 yourself).        change accept: (IceChangeImporter new                 version: target;                 diff: self;                 parentNode: rightTree;                 yourself) ] displayingProgress: [:change |  change displayingProgressString ].  tree := self diff: leftTree with: rightTreediffFromHead  | commitModel |  commitModel := IceTipCommitModel on: self entity commit.  ^commitModel diffFromHeadpost: aString with: aBlock  ^self jsonContentsWithValidationDo: [ (self newRequestTo: aString)           in: aBlock;           post;           response ]newProjectRegistration  ^IceMetacelloProjectRegistration new     version: builder commitishName;     yourselfpackageNames  ^self commit packageNamesexecute  (IceTipFiletreeToTonelDialog on: self repositoryModel entity) openDialogWithSpecisUnknownCommit  ^trueopen  self openWithSpecproperties: aDictionary  properties := aDictionaryat: aString put: aNode  aNode parent: self.  childrenDictionary at: aString put: aNodetagModels  ^self entity tags collect: [:each |  (IceTipTagModel repositoryModel: self on: each) beCached ]httpsUrl  ^self urlitem: anObject  item := anObjectpreviewCheckout  < noCache>  (IceTipCheckoutPreviewBrowser onBranch: self) openWithSpecbodyLabel: anObject  bodyLabel := anObjectnewBaselineGroupCommand: anIcePackage  ^IceTipMetacelloInstallBaselineGroupCommand new     repositoryModel: self repositoryModel;     package: anIcePackage;     yourselfexecute  IceTipRegisterRepositoryDialog new openDialogWithSpecrefresh  repository: anExistingRepository  repository := anExistingRepositoryrefreshCommitInfo  infoTab contents: (selectedModel info ifNotNil: [ (IceTipReadOnlyForm items: selectedModel info) buildWithSpec ])withNode: anIceNode do: aBlockClosure  | previousNode |  previousNode := currentNode.  currentNode := anIceNode.  aBlockClosure ensure: [ currentNode := previousNode ]existingProjectRegistration  | repository |  repository := IceLibgitRepository new location: builder locationToUse.  ^IceMetacelloProjectRegistration new     version: repository head description;     yourselfcheckForRegistryConflicts  self location ifNil: [ ^self ].  self class registry detect: [:repo |  repo location = self location ] ifFound: [:repo |  self origin = repo origin ifTrue: [ IceDuplicatedRepository signal: ('You already have an Iceberg repository at {1} and with the same origin URL. If you really whant create another one, please locate it in a different directory.' format: {self location pathString}) ] ifFalse: [ IceDuplicatedRepository signal: ('You already have an Iceberg repository at {1} but with a different origin URL.You provided {2} and the original repository''s url is {3}.' format: {self location .                           self origin .                           repo origin}) ] ]newCellFor: item  | cell |  cell := FTIndentedCellMorph new.  cell indentBy: item depth * 16.  cell addMorphBack: (self buttonFor: item).  cell addMorphBack: (self newSelectionMorphFor: item).  (self iconFor: item data) ifNotNil: [:icon |  cell addMorphBack: icon asMorph ].  cell addMorphBack: (self toString: item data) asMorph.  ^cellcontents  ^self subclassResponsibilityexecute  | newElements |  newElements := self dataSource elements species new.  self dataSource elements do: [:each |  (self matches: each) ifTrue: [ newElements add: each ] ].  ^self dataSource copy     elements: newElements;     yourselfisPackageDefinition  ^truedelete  self forgetisMeta  ^isMetamerge  ^self repository workingCopy mergeCommit: self commitremoveMethod: anIceMethodDefinition  anIceMethodDefinition asMCDefinition unloaduseIncoming  ^self resume: self builder addLocalRepositoryAndCheckoutvalidateCanCommit  self head isDetached ifTrue: [ IceWorkingCopyDesyncronized signal ]pushCheckbox: anObject  pushCheckbox := anObjectmergeType  ^mergeType ifNil: [ IceTipMergeType default ]project  self subclassResponsibilityinitialize  retries := 3preferredColor  ^self item value preferredColorpatchButton  ^patchButtonparseSSHLocation: aString  | segments |  segments := aString substrings: '@:'.  user := segments first.  host := segments second.  path := self pathFrom: segments thirdremoteNamed: aName ifAbsent: aBlockClosure  self handleLibgitError: [ | gitRemote |        [ gitRemote := (LGitRemote of: self repositoryHandle named: aName) lookup.        ^(IceGitRemote name: gitRemote remoteName url: gitRemote url)           localRepository: self;           yourself ] on: LGitObjectNotInitialized do: [ ^aBlockClosure value ] ]properties  ^self commit propertiesname  ^self entity namereadParametersFromContext: aToolContext  super readParametersFromContext: aToolContext.  selectedCommitish := aToolContext itemuserNameInputText  ^userNameInputTextmergeWithLeftRemoval: anIceRemoval  ^IceNonConflictingOperation operation: anIceRemovallocation  ^locationcontents  ^self target perform: super contentsselectedCheckoutStrategy  ^selectedCheckoutStrategyisLocal  ^truecommits  ^#()mouseEnter: evt  self currentHand showTemporaryCursor: Cursor webLinkinitializeWidgets  messageLabel := self newLabel.  messageText := self newText autoAccept: true.  typeLabel := self newLabel.  typeList := self newDropList.  acceptButton := self newButton.  messageLabel label: 'Comment'.  messageText whenBuiltDo: [:this |  this widget withGhostText: self class messageGhostText ].  typeLabel label: 'Merge type'.  acceptButton label: 'Accept pull request'.  acceptButton action: [ self accept ].  self focusOrder     add: messageText;     add: typeList;     add: acceptButtoninitialExtent  ^(700 @ 700) scaledByDisplayScaleFactorbeDirty: aBoolean  isDirty := aBooleanlabelFor: aCommitModel  ^self subclassResponsibilityhasChanges  ^hasChanges or: [ initialTree isNil or: [ self children anySatisfy: #hasChanges ] ]basicAddPackage: aPackage  self packagesDictionary at: aPackage name put: aPackageat: aKey ifPresent: anObject  ^objects at: aKey ifPresent: anObjectancestors  ^iceCommit ancestorIdscommitWithMessage: message andParents: parentCommits  self subclassResponsibilityurlLabel  ^urlLabelinitialize  super initialize.  self resethash  ^self name hashaccept: aVisitor  ^aVisitor visitNoModification: selfpushTo: aRemote  repository handleLibgitError: [ self basicPushTo: aRemote ]description  ^'Github operations'cloneRepository  IceGitClone new     location: self locationToUse;     url: self remoteToUse url;     execute.  self repository location: self locationToUse.  self commitishName ifNotNil: [ self repository switchToCommitishNamed: self commitishName ].  self repository pluginManager repositoryWillBeCreated: self repository.  self doEnsureProject.  self repository workingCopy initializePackagesFromRepository.  self repository pluginManager repositoryWasCreated: self repository.  ^self repositoryactionColumn: column  self flag: #todo.  self tableRefreshrepository  ^repository ifNil: [ repository := IceLibgitRepository new ]repositoryModel  ^repositoryModelsubdirectory: aString  self project sourceDirectory: aStringcommit  ^self entity commitdiffContentsLeft: leftString right: rightString  diffPanel     leftText: '';     rightText: '';     leftText: leftString;     rightText: rightStringvisitDirectoryDefinition: anIceDirectoryDefinition  self visitChildrenOf: currentNodeisRepositoryOperational  ^self isRepositoryMissing not and: [ self isRepositoryDetached not and: [ self hasUnbornProject not ] ]initializePresenter  super initializePresenter.  self titlePanel text: self branch shortname.  self headForkList     items: self availableRemotes;     displayBlock: [:each |  each owner , '/' , each projectName ];     setSelectedItem: self headRemote.  self headBranchList     items: self availableBranchNames;     displayBlock: [:each |  each ];     setSelectedItem: self defaultHeadBranchName.  self baseForkList     items: self availableRemotes;     displayBlock: [:each |  each owner , '/' , each projectName ];     setSelectedItem: self baseRemote.  self baseBranchList     items: self availableBranchNames;     displayBlock: [:each |  each ];     setSelectedItem: self defaultBaseBranchName.  self bodyPanel text: self obtainLastCommitMessageremoveFromPatcher: aMCPatcher  isMeta ifTrue: [ ^true ].  aMCPatcher removeDefinition: self asMCDefinitioninitializePresenter  super initializePresenter.  self pullRequests widget onAnnouncement: FTSelectionChanged send: #uptadeSelectedPullRequest: to: self.  self pullRequests widget onAnnouncement: FTStrongSelectionChanged send: #strongSelection: to: selflocationToUse  ^self location ifNil: [ self defaultLocation ]properties  ^self workingCopy repositoryPropertiesmergeWithBranch: anIceGitRemoteBranch  self shouldBeImplementedprovideSshAgentCredentialsTo: credentials  tries := tries + 1.  tries >= 3 ifTrue: [ Transcript           show: 'aborting';           cr.        LGitNoCredentialsProvided signal: 'No ssh-agent credentials found.' ]contextClass  self subclassResponsibilityhost  ^hostcontextClass  ^IceTipPullContextvalidateNotDuplicated  (self remoteToUse isNotNil and: [ self locationToUse exists and: [ self locationToUse hasChildren ] ]) ifTrue: [ IceDuplicatedRepository signal: ('You already have an Iceberg repository at {1}. If you really want create another one, please locate it in a different directory.' format: {self locationToUse pathString}) ]optionA  ^optionAtitle  ^self model ifNotNil: [ 'History of {1}' format: {self model name} ] ifNil: [ 'History' ]detailedInfo  ^#()addModification: anIceModification toPatcher: aMCPatcher  aMCPatcher removeDefinition: anIceModification rightDefinition asMCDefinition.  ^aMCPatcher addDefinition: anIceModification leftDefinition asMCDefinitioncommitAt: commitId  ^self lookupCommit: commitIdinitializeRepository: aRepository credentials: aCredentials headRemote: aRemote  repository := aRepository.  credentials := aCredentials.  headRemote := aRemote.  self initializepath  ^pathmajorButton  ^majorButtongoferReferences  self repository head description = projectVersion ifFalse: [ (self repository commitishNamed: projectVersion) checkoutWithStrategy: IceCheckoutDoNotLoadPackages new ].  ^self repository workingCopy packages collect: [:package |  GoferResolvedReference name: package latestVersion info name repository: self ]shortId  ^self id first: 7shortCommitId  ^self entity shortIdpushRemoteName  ^self entity branch upstream namepropertiesFilePath  ^repository project sourceDirectoryPath / self class propertiesFileNameaccept  self username isEmptyOrNil ifTrue: [ ^UIManager default alert: 'user.name is required.' ].  self email isEmptyOrNil ifTrue: [ ^UIManager default alert: 'user.email is required.' ].  (model getConfigurationGlobal: self isGlobal)     username: self username;     email: self email.  self window delete.  acceptCallback ifNotNil: [ acceptCallback value ]initialize  model ifNil: [ model := IceCredentialStore current ].  super initializeobtainSshCredentials: response  self subclassResponsibilitydescription  ^definition nameisLocal  ^self isRemote notextent  ^25 @ 25= anotherOperation  ^self species = anotherOperation species and: [ self leftDefinition = anotherOperation leftDefinition ]browsePackage  < noCache>  self entity browseacceptButton  ^acceptButtoncredentials  ^credentialsaddPullRequest: owner project: projectName data: aDictionary  ^self post: 'repos/' , owner , '/' , projectName , '/pulls' with: [:client |  client           entity: (ZnEntity text: (STON toJsonString: aDictionary));           contentType: ZnMimeType applicationJson ]provideSshCredentialsTo: credentials  tries := tries + 1.  tries >= 3 ifTrue: [ Transcript           show: 'aborting';           cr.        LGitNoCredentialsProvided signal: 'There where already three failed attempts, aborting' ].  tries = 1 & self sshCredentials isPresent ifTrue: [ credentials readFrom: self sshCredentials ] ifFalse: [ self obtainSshCredentials: credentials ]hostInput  ^hostInputancestorIds: aCollection  ancestorIds := aCollectionselectAll  selectedItems := Set new.  self rootItem children do: [:each |  self selectAllChildrenOf: each ].  self tableRefreshbaseForkList: anObject  baseForkList := anObjectinitializeWidgets  listPanel := self instantiate: FastTablePresenter.  listPanel icons: [:each |  self createCheckboxFor: each ].  selectButton := self newButton.  selectButton     label: self class buttonLabel;     action: [ self confirmSelection ].  self focusOrder     add: listPanel;     add: selectButtonopenNonModal  ^self openDialogWithSpec     okAction: [ self okAction ];     cancelAction: [ self cancelAction ];     whenClosedDo: [ self closeAction ];     centeredmerger: anIceMerge  merge := anIceMergebasicExecute  self validateCanCommit.  UIManager default informUser: 'Commiting...' during: [ self repository commitChanges: (diff copyWithOnly: items) withMessage: message ].  Iceberg announcer announce: (IceRepositoryModified for: self repository)locationIfPresent: aBlock ifAbsent: absentBlock  self location ifNil: [ ^absentBlock value ].  ^self location exists ifTrue: [ aBlock value: location ] ifFalse: [ absentBlock value ]headLabel  ^headLabelbranchModels  ^self branches collect: [:each |  (IceTipBranchModel repositoryModel: self repositoryModel on: each) beCached ]entry  ^entrydefaultSubdirectory  ^IceLibgitRepository defaultCodeSubdirectoryremovePackage: aDefinition  (repository location resolvePath: aDefinition path) ensureDeleteAllnewContextWithSelection: anObject  ^self newContext     item: anObject;     yourselfupdateOkButton  acceptButton ifNil: [ ^self ].  acceptButton enabled: self isOkEnabledisLeftChosen  ^chosen = leftOperationcommitish: anObject  self assert: anObject isNotNil.  commitish := anObjectdescription  ^self workingCopyState descriptionlocalBranches  self handleLibgitError: [ self repositoryHandle isUnborn ifTrue: [ ^{self head} ].        ^OrderedCollection new: 10 streamContents: [:stream |  self repositoryHandle localBranchesDo: [:br :isLocal |  stream nextPut: (self basicNewBranchNamed: br name) ] ] ]incomingCommits  ^self entity incomingCommitsisEditing  ^repository isNil notisUnknownCommitState  ^trueheadHistory  ^headHistory ifNil: [ headHistory := IceHistory on: repository headCommit repository: repository ]mergeWithLeftModification: anIceModification  anIceModification leftDefinition = self leftDefinition ifTrue: [ ^IceNonConflictingOperation operation: anIceModification ].  ^IceConflictingOperation left: anIceModification right: selfdiffFromHead  | head diff |  head := self repositoryModel entity headCommit.  diff := self calculateDiff: [ head diffTo: self entity ].  ^IceTipCommitDiffModel repositoryModel: self repositoryModel on: diffdirectoryPathStringForPackage: aMCPackage  ^self subdirectory isEmptyOrNil ifTrue: [ self directoryNameForPackage: aMCPackage ] ifFalse: [ self subdirectory , '/' , (self directoryNameForPackage: aMCPackage) ]addEntryNamed: name withContents: aString  self builder addEntry: (LGitBlob of: self repository fromString: aString) filename: name.  self changes add: name.  hasChanges := truerepositoryDirectory: anObject  repositoryDirectory := anObjectdatetime  ^iceCommit datetimeisDetached  ^self entity workingCopy isDetached or: [ self entity head isDetached ]badgeFont  ^badgeFont ifNil: [ badgeFont := self newBadgeFont ]onSuccess: aBlock  successBlock := aBlockaddChild: aChild  ^self addNode: (self class value: aChild)mouseEnter: evt  self currentHand showTemporaryCursor: Cursor webLink.  super mouseEnter: evtisDetached  ^self isBranch notmcVersionFor: anIceSavedPackageVersion  ^repository mcVersionFor: anIceSavedPackageVersionbasicNewBranchNamed: aString  ^IceGitLocalBranch named: aString inRepository: selftitle  ^titleheadForkList: anObject  headForkList := anObjecthead  self subclassResponsibilitywriterClass  ^format = #tonel ifTrue: [ IceLibgitTonelWriter ] ifFalse: [ IceLibgitFiletreeWriter ]removeMethod: anIceMethodDefinition  repository workingCopy removeMethod: anIceMethodDefinitiontagNameLabel: anObject  tagNameLabel := anObjectmatches: anObject  self subclassResponsibilitysetModelBeforeInitialization: anObject  model := anObjectusernameInput  ^usernameInputrepositoryModel  ^nilinitialExtent  ^(1050 @ 800) scaledByDisplayScaleFactorprivateKey  ^privateKey ifNil: [ privateKey := self class defaultPrivateKey ]referenceCommit: aCommit  self referenceCommit = aCommit ifTrue: [ ^self ].  referenceCommit := aCommit.  self refreshProjectFromRepositoryemptyPanel  ^PanelMorph new     changeProportionalLayout;     vResizing: #spaceFill;     hResizing: #spaceFill;     yourselfcontextClass  ^IceTipBranchContextparseHTTPLocation: aString  | url |  url := aString asUrl.  host := url host.  port := url port.  path := self pathFrom: url pathbasepathOf: aPath  ^aPathrepository  ^repositoryparent: anObject  parent := anObjectpackage  ^packagemergeType: anObject  self model mergeType: anObjectcommentText: anObject  commentText := anObjectcommitishSelected: ann  | selection |  ann newSelectedRowIndexes ifNotEmpty: [:indexes |  selection := sidebarTree widget dataSource elementAt: indexes first.        (selection depth = 0 or: [ selection hasChildren ]) ifTrue: [ ^self ].        historyPanel model: selection data model ]dataSource  ^dataSourcebranchName: aBranchName  branchName := aBranchNamebasicUrl: aString  url := aStringdiff  ^self entityisLoaded  ^falsehistoryPanel: anObject  historyPanel := anObject